#include "ls.icl"
#include "or.icl"
#cmdbuff external

#define VERSION        "1.56"

// 1.10: Added commands DEFREGION and MAKEZMAP.
// 1.11: Added commands INPORT32 and OUTPORT32.
// 1.12: Support for head cameras.
// 1.13: Support for exact R with individual power/current limits.
// 1.14: Added measurement subcommand BURN.
// 1.15: Added support for command S_VIDEOCAM.
// 1.16: Support for MSD measurements.
// 1.17: Updated SPS messages and errors.
// 1.18: Added measurement subcommand CONTCAP.
// 1.19: Encoder coordinate on lost phase.
// 1.20: Manual LATEST baseline/calibration (LAMBASE/LAMCAL)
// 1.21: LATEST baseline/calibration with heads (LABASE/LACAL)
// 1.22: Several new commands and answers.
// 1.23: SPS messages are translated (mostly) into English (well, a kind of).
// 1.24: Support for second measurement card.
// 1.25: Support for L&M automation.
// 1.26: SERV.Startlmauto().
// 1.27: Added measurement subcommand CONTKELV.
// 1.28: Added measurement subcommand LART.
// 1.29: Added measurement subcommand MC.
// 1.30: Support for instant retest (ASSERT).
// 1.31: Added measurement subcommand UNIC.
// 1.32: Extended ("long") HV initialization. I mean, long parameter list.
// 1.33: Support for C postcalibration in the air (CAIR).
// 1.34: Support for S_RLINIT.
// 1.35: Support fpr M_DIVIDER.
// 1.36: Load L&M barcode driver only if specified explicitly.
// 1.37: M_CALIRATE with multiple reference heads.
// 1.38: Extended EXTINIT and M_EXTERN.
// 1.39: Support for M_RLIM.
// 1.40: EXTINIT and M_EXTERN extended again.
// 1.41: UMAX and RMAX in EXACTLIM, ERETEST and RLIM.
// 1.42: Rewritten command parsing.
// 1.43: Bug in detection of Parameter Server.
// 1.44: Bug in encoding of CONTCAP.
// 1.45: Support for M_RRELIM.
// 1.46: Selection of measurement device, high F for M_EXACTLIM and M_UNIC.
// 1.47: Encoder movements.
// 1.48: New prefixes AVERAGE() and MEDIAN().
// 1.49: Support for M_COMP.
// 1.50: Delay after contact for many measurements.
// 1.51: Additional subcommands in M_COMP.
// 1.52: Details for resistance measurements.
// 1.53: COMP:ASSERT and multireference R and C.
// 1.54: MOVE in M_COMP.
// 1.55: Support for backdrill component measurements.
// 1.56: Support for 2-step HV measurements.

#data errmsg="re.icl"            // Decoding of error messages

// Layout configuration bits in $LAY.config.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae
// Alternative (old) interpretation of LC_OHTYPE bits.
#define LC_PHASEADJ    0x00000800      // On-heads with adjustable field phase
#define LC_ACTIVEONHD  0x00000400      // Active on-heads (with Dallas/R1-R4)
// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_TMASK       (LC_TYPEMASK|LC_ISM2|LC_HIGHZ|LC_LDELAY)
#define LC_LMAUTO      (LC_LM|LC_A2LOADER)
#define LC_LMS2AUTO    (LC_LMS2|LC_A2LOADER)
#define LC_EPCOSAUTO   (LC_EPCOS|LC_A2LOADER)
// Debug mode window definitions:
#define DMX1           10              // X origin of the frame "Head items"
#define DMX2           175             // X origin of the frame "Video items"
#define DMX3           340             // X origin of the frame "Enabled rails"
#define DMYB           245

#define ER             0x00000001      // Display error messages
#define SR             0x00000002      // Display soft reset
#define DM             0x00000004      // Display dummy movements
#define BA             0x00000008      // Display bad measurements
#define MS             0x00000010      // Display all measurements
#define DT             0x00000020      // Display data transfer
#define DB             0x00000040      // Display debug commands
#define LU             0x00000080      // Display lookups
#define IO             0x00000100      // Display I/O commands
#define ST             0x00001000      // Decode measurement status
#define SM             0x00002000      // Display internal script messages
#define FL             0x00010000      // Display field
#define DU             0x80000000      // Dump answers
// Embedded version only:
#define EC             0x00004000      // Display erroneous commands
#define DI             0x00008000      // Display full debug information
#define ME             0x10000000      // Display MECH.DLL interpreter
#define IC             0x20000000      // Display all incoming commands
#define DC             0x40000000      // Dump commands



function int serv_log(char *vlog)
    handle f_log_main
    if f_log_main==NULL f_log_main=Fopen("fpt_ca_log.log","at")
    if f_log_main!=NULL fprintf(f_log_main, "%s \n", vlog)
end

// Checks whether filename has any extention (.xxx). If no, it adds specified
// extention.
function int SERV.Addextention(char *filename,char *defext)
  char drv[8],dir[260],name[260],ext[260]
  Fnsplit(filename,drv,dir,name,ext)
  if ext[0]=='\0' Fnmerge(filename,drv,dir,name,defext)
end

function int SERV.Ohmstotext(float r,int status,char *s)
  int i,units
  if (status & 0x0100)!=0 r=r*1.0e-6   // Resistance in microOhms
  while Abs(r)>1000.0 && units<3 do
    r=r/1000.0; units++
  enddo
  if Abs(r)<10 then
    i=sprintf(s,"%6.3f",r)
  else if Abs(r)<100 then
    i=sprintf(s,"%6.2f",r)
  else
    i=sprintf(s,"%6.1f",r)
  endif
  if units==0 i=i+sprintf(s+i,"  Ohm")
  if units==1 i=i+sprintf(s+i," kOhm")
  if units==2 i=i+sprintf(s+i," MOhm")
  if units==3 i=i+sprintf(s+i," GOhm")
  return i
end

function int SERV.Ohmsshort(float r,int status,char *s)
  int i,units
  if (status & 0x0100)!=0 r=r*1.0e-6   // Resistance in microOhms
  while Abs(r)>1000.0 && units<3 do
    r=r/1000.0; units++
  enddo
  if Abs(r)<10 then
    i=sprintf(s,"%6.3f",r)
  else if Abs(r)<100 then
    i=sprintf(s,"%6.2f",r)
  else
    i=sprintf(s,"%6.1f",r)
  endif
  if units==0 i=i+sprintf(s+i," ")
  if units==1 i=i+sprintf(s+i,"k")
  if units==2 i=i+sprintf(s+i,"M")
  if units==3 i=i+sprintf(s+i,"G")
  return i
end

function int SERV.Milliohmstotext(float r,int status,char *s)
  int i,units
  if (status & 0x0100)!=0 then
    r=r*1.0e-3                         // Convert microOhms to milliOhms
  else
    r=r*1.0e3                          // Convert Ohms to milliOhms
  endif
  while Abs(r)>1000.0 && units<4 do
    r=r/1000.0; units++
  enddo
  if Abs(r)<10 then
    i=sprintf(s,"%8.5f",r)
  else if Abs(r)<100 then
    i=sprintf(s,"%8.4f",r)
  else
    i=sprintf(s,"%8.3f",r)
  endif
  if units==0 i=i+sprintf(s+i," mOhm")
  if units==1 i=i+sprintf(s+i,"  Ohm")
  if units==2 i=i+sprintf(s+i," kOhm")
  if units==3 i=i+sprintf(s+i," MOhm")
  if units==4 i=i+sprintf(s+i," GOhm")
  return i
end

function int SERV.Pftotext(float c,char *s)
  int i,units                          // SCRIPT2 zeroes local variables
  while Abs(c)>1000.0 && units<4 do
    c=c/1000.0; units++
  enddo
  if Abs(c)<10 then
    i=sprintf(s,"%6.3f",c)
  else if Abs(c)<100 then
    i=sprintf(s,"%6.2f",c)
  else
    i=sprintf(s,"%6.1f",c)
  endif
  if units==0 i=i+sprintf(s+i," pF")
  if units==1 i=i+sprintf(s+i," nF")
  if units==2 i=i+sprintf(s+i," uF")
  if units==3 i=i+sprintf(s+i," mF")
  if units==4 i=i+sprintf(s+i,"  F")
  return i
end

function int SERV.Pfpftotext(float c1,float c2,char *s)
  int i,units
  float c
  c=Max(Abs(c1),Abs(c2))
  while Abs(c)>1000.0 && units<4 do
    c=c/1000.0; c1=c1/1000.0; c2=c2/1000.0; units++
  enddo
  if Abs(c)<10 then
    i=sprintf(s,"%6.3f :%6.3f",c1,c2)
  else if Abs(c1)<100 then
    i=sprintf(s,"%6.2f :%6.2f",c1,c2)
  else
    i=sprintf(s,"%6.1f :%6.1f",c1,c2)
  endif
  if units==0 i=i+sprintf(s+i," pF")
  if units==1 i=i+sprintf(s+i," nF")
  if units==2 i=i+sprintf(s+i," uF")
  if units==3 i=i+sprintf(s+i," mF")
  if units==4 i=i+sprintf(s+i,"  F")
  return i
end

function int SERV.Henrytotext(float h,char *s)
  int i,units
  h=h/1000.0                           // Don't show nanohenry, below accuracy
  while Abs(h)>1000.0 && units<2 do
    h=h/1000.0; units++
  enddo
  if Abs(h)<10 then
    i=sprintf(s,"%6.3f",h)
  else if Abs(h)<100 then
    i=sprintf(s,"%6.2f",h)
  else
    i=sprintf(s,"%6.1f",h)
  endif
  if units==0 i=i+sprintf(s+i," uH")
  if units==1 i=i+sprintf(s+i," mH")
  if units==2 i=i+sprintf(s+i,"  H")
  return i
end

function int SERV.Convertfield(char *answer,float *zc,float *zr)
  int k,status,err
  float c,r,f,fi,fk,temp
  status=$uint2(answer+6)
  c=0.0; r=0.0
  if $int2(answer+14)==0 then
    err=-1                             // COS_CHAN is zero
  else
    if $GLOBAL.a5!=0 && (status & 0x0004)!=0 then
      k=28+(Max(answer[9]-answer[8]+1,0)+Max(answer[11]-answer[10]+1,0))*4
      f=$uint2(answer+k)
    else
      f=$LAY.frequency
    endif
    if f==0.0 f=1953.0                 // Set default if frequency unavailable
    if (status & 0x0100) then
      f=f*6.2831853072                 // 1 V AC
    else
      f=f*62.831853072                 // 10 V AC
    endif
    if (status & 0x6000)==0x0000 then
      f=f*1.0e5                        // Resistor 100 k (default)
    else if (status & 0x6000)==0x2000 then
      f=f*1.0e4                        // Resistor 10 k (active on-head only)
    else if (status & 0x6000)==0x4000 then
      f=f*1.0e3                        // Resistor 1 k (active on-head only)
    else
      f=f*1.0e6                        // Resistor 1 M (active on-head only)
    endif
    if (status & 1)==0 then            // Amplification x10
      if $LAY.nfing==0 then fk=0.1;
      else fk=$LAY.ac0v1/1.0e6; endif
      f=f*$int2(answer+16)
    else                               // Amplification x1
      if $LAY.nfing==0 then fk=1.0;
      else fk=$LAY.ac1v/1.0e6; endif
      f=f*$int2(answer+18)
    endif
    if f==0.0 then fk=0.0; err=-1;
    else fk=fk/f*1.0e12; endif
    temp=$int2(answer+20)
    r=($int2(answer+22)*$int2(answer+12))/$int2(answer+14)
    fi=Atan2($int2(answer+24),$int2(answer+26))
    c=(temp*Cos(fi)-r*Sin(fi))*fk
    r=-(temp*Sin(fi)+r*Cos(fi))*fk
  endif
  zc[0]=c; zr[0]=r
  return err
end

// Extracts capacity and Z component from M_FASTC and M_MULTIC.
function int SERV.Convertfastc(char *answer,float *zc,float *zr)
  int k,status,err
  float c,r,f,fi,fk,temp
  status=$uint2(answer+6)
  if answer[5]==0x48 then
    status=status & 0xFE7F             // Multiple C makes only AC measurements
  endif
  c=0.0; r=0.0
  if (status & 0x8000) then            // No hardware
    err=-1
  else if (status & 0x0180)==0x0180 then
    // Measured with AC bridge.
    c=$float4(answer+10)
    r=$float4(answer+14)               // Ohms
  else if (status & 0x0180)==0x0080 then
    // Measured with charge-discharge.
    c=$float4(answer+10)
    r=$float4(answer+14)*0.0006        // Convert into milliseconds
  else
    // Measured with AC (or AC with C calibration in the air).
    if $int2(answer+12)==0 then
      err=-1                           // COS_CHAN is zero
    else
      if (status & 1)==0 then          // Amplification x10
        if $LAY.nfing==0 then fk=0.1;
        else fk=$LAY.ac0v1/1.0e6; endif
      else                             // Amplification x1
        if $LAY.nfing==0 then fk=1.0;
        else fk=$LAY.ac1v/1.0e6; endif
      endif
      if $GLOBAL.a5!=0 && (status & 0x0004)!=0 then
        k=$uint2(answer)-2
        if (status & 0x0180)==0x0100 k=k-4
        f=$uint2(answer+k)
      else
        f=$LAY.frequency
      endif
      if f==0.0 f=1953.0               // Set default if frequency unavailable
      f=f*3.14159265*$int2(answer+16)*answer[9]
      if (status & 0x6000)==0x0000 then
        f=f*1.0e5                      // Resistor 100 k (default)
      else if (status & 0x6000)==0x2000 then
        f=f*1.0e4                      // Resistor 10 k (active on-head only)
      else if (status & 0x6000)==0x4000 then
        f=f*1.0e3                      // Resistor 1 k (active on-head only)
      else
        f=f*1.0e6                      // Resistor 1 M (active on-head only)
      endif
      if f==0.0 then fk=0.0; err=-1;
      else fk=fk/f*1.0e12; endif
      fi=Atan2($int2(answer+22),$int2(answer+24))
      temp=$int2(answer+18)
      r=($int2(answer+20)*$int2(answer+10))/$int2(answer+12)
      c=(temp*Cos(fi)-r*Sin(fi))*fk
      r=-(temp*Sin(fi)+r*Cos(fi))*fk
    endif
  endif
  zc[0]=c; zr[0]=r
  return err
end

// Extracts capacity and Z component from the n-th measurement in M_MULTIC.
function int SERV.Convertmultic(char *answer,int n,float *zc,float *zr)
  int status,offset,len,err
  float c,r,f,fi,fk,temp
  status=$uint2(answer+6) & 0xFE7F
  len=$uint2(answer)
  if (status & 0x0004)!=0 then
    len=len-2                          // Frequency follows
  endif
  offset=26+n*4
  c=0.0; r=0.0
  if len<30 then
    err=-1                             // Answer is too short
  else if n<0 || n>=(len-26)/4 then
    err=-1                             // Invalid index
  else if (status & 0x8000) then
    err=-1                             // No hardware
  else if $int2(answer+12)==0 then
    err=-1                             // COS_CHAN is zero
  else
    if (status & 1)==0 then            // Amplification x10
      if $LAY.nfing==0 then fk=0.1;
      else fk=$LAY.ac0v1/1.0e6; endif
    else                               // Amplification x1
      if $LAY.nfing==0 then fk=1.0;
      else fk=$LAY.ac1v/1.0e6; endif
    endif
    if $GLOBAL.a5!=0 && (status & 0x0004)!=0 then
      f=$uint2(answer+len)
    else
      f=$LAY.frequency
    endif
    if f==0.0 f=1953.0                 // Set default if frequency unavailable
    f=f*3.14159265*$int2(answer+16)*answer[9]
    if (status & 0x6000)==0x0000 then
      f=f*1.0e5                        // Resistor 100 k (default)
    else if (status & 0x6000)==0x2000 then
      f=f*1.0e4                        // Resistor 10 k (active on-head only)
    else if (status & 0x6000)==0x4000 then
      f=f*1.0e3                        // Resistor 1 k (active on-head only)
    else
      f=f*1.0e6                        // Resistor 1 M (active on-head only)
    endif
    if f==0.0 then fk=0.0; err=-1;
    else fk=fk/f*1.0e12; endif
    fi=Atan2($int2(answer+22),$int2(answer+24))
    temp=$int2(answer+offset)
    r=($int2(answer+offset+2)*$int2(answer+10))/$int2(answer+12)
    c=(temp*Cos(fi)-r*Sin(fi))*fk
    r=-(temp*Sin(fi)+r*Cos(fi))*fk
  endif
  zc[0]=c; zr[0]=r
  return err
end

// Starts Parameter Server, MECH and bcode for L&M tester. Barcode reader is
// started inly if declared in Options.
function int SERV.Startlmauto()
  int n,t,ps,bcode,mech,loadbcode
  handle huser32,hmessage,htext,hcancel
  char psname[260],mechname[260],bcodename[260]
  // Set default commands (A5a).
  Strcpy(psname,"C:\\Tower\\PS\\startup.bat")
  if $LAY.software==0xB8 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
    Strcpy(mechname,"perl C:\\Tower\\mechA7a\\startup.pl")
  else
    Strcpy(mechname,"perl C:\\Tower\\mecha5a\\startup.pl")
  endif
  Strcpy(bcodename,"")
  // Get actual settings from the initialization file.
  getini("System","PS 4710","%s",psname)
  getini("System","MECH","%s",mechname)
  getini("System","bcode","%s",bcodename)
  loadbcode=(($LAY.config & LC_LDMASK)==LC_LMAUTO && bcodename[0]!='\0')
  huser32=LoadDLL("user32.dll")
  ps=CallDLL(huser32,"FindWindowA",0,"PS 4710")
  if ps==0 then
    ps=CallDLL(huser32,"FindWindowA",0,"C:\\Perl\\bin\\perl.exe")
  endif
  if loadbcode then
    bcode=CallDLL(huser32,"FindWindowA",0,"bcode")
  else
    bcode=1
  endif
  mech=CallDLL(huser32,"FindWindowA",0,"MECH")
  if ps==0 || bcode==0 || mech==0 then
    if ps==0 then
      // Parameter server is not yet here. Message 0x2 is WM_DESTROY.
      if loadbcode && (bcode!=0) then
        CallDLL(huser32,"PostMessageA",bcode,0x2,0,0)
      endif
      if mech!=0 then
        CallDLL(huser32,"PostMessageA",mech,0x2,0,0)
      endif
      SYS.Winexec(psname)
      delay 1000
      ps=CallDLL(huser32,"FindWindowA",0,"PS 4710")
      if ps==0 then
        ps=CallDLL(huser32,"FindWindowA",0,"C:\\Perl\\bin\\perl.exe")
      endif
    endif
    if ps!=0 then
      // Parameter Server is already running.
      if bcode==0 then
        SYS.Winexec(bcodename)
      endif
      if mech==0 then
        SYS.Winexec(mechname)
      endif
    endif
    // Wait till all windows are open.
    hmessage=control WINDOW
      window=NULL
      position=10,10,300,110
      name="启用参数服务器"
      help=" "
      color=BLACK
      bkcolor=YELLOW
      mode=M_MODAL
    endc
    n=15
    htext=control TEXT
      window=hmessage
      position=0,20,300,30
      help=" "
      color=BLACK
      bkcolor=YELLOW
      font=MEDIUMFONT
      mode=M_CENTERED
    endc
    hcancel=control BUTTON
      window=hmessage
      position=95,70,110,25
      text="关闭"
      help="按下可停止等待"
      font=MEDIUMFONT
    endc
    t=Time()
    while n>0 do
      change htext text=format("Starting Parameter Server - %i",n)
      while 1 do
        ps=CallDLL(huser32,"FindWindowA",0,"PS 4710")
        if ps==0 then
          ps=CallDLL(huser32,"FindWindowA",0,"C:\\Perl\\bin\\perl.exe")
        endif
        if loadbcode then
          bcode=CallDLL(huser32,"FindWindowA",0,"bcode")
        else
          bcode=1
        endif
        mech=CallDLL(huser32,"FindWindowA",0,"MECH")
        if ps!=0 && bcode!=0 && mech!=0 break
        if Pressed(hcancel) then
          destroy hmessage
          return -1
        endif
        if Time()-t>=1000 break
        wait
      enddo
      if ps!=0 && bcode!=0 && mech!=0 break
      n--
      t=t+1000
    enddo
    if ps==0 || bcode==0 || mech==0 then
      change htext color=LIGHTRED
      change htext text="Unable to start Parameter Server!"
      while 1 do
        if Pressed(hcancel) then
          destroy hmessage
          return -1
        endif
        wait
      enddo
    endif
    // Wait additional 3 seconds.
    change htext text="Activating Parameter Server..."
    delay 3000
    destroy hmessage
  endif
  UnloadDLL(huser32)
end

function int SERV.Info(handle hw,handle *hq,int nq)
  handle hmain
  handle hquit
  handle htext,hdate,dummy
  int i,hi,lo,os,used,total,size
  char s[256]
  if hw==NULL then
    hmain=control WINDOW
      window=NULL
      position=100,100,505,278
      mode=M_MODAL
      name="系统信息"
      help=" "
      bkcolor=YELLOW
    endc
  else
    hmain=hw
  endif
  if hw==NULL || nq==0 then
    hquit=control WINBUTTON
      window=hmain
      position=405,DMYB,90,24
      name="确定"
      help="按下可关闭系统信息"
    endc
  endif
  SYS.Version(&hi,&lo,&os)
  dummy=control ICON
    name="MAINICON"
    window=hmain
    position=30,45,36,36
  endc
  htext=control TEXT
    window=hmain
    color=BLACK
    font=MEDIUMFONT
    position=80,30,400,100
    text="诊断软件"//format("OLLYTEST v %i.%i",hi,lo)
  endc
  hdate=control TEXT
    window=hmain
    color=BLACK
    font=MEDIUMFONT
    position=80,140,400,72
  endc
  //add htext text=format("\nRunning under %s",                                  \
  //  os==0?"Win32s":(os==1?"Windows 95/98":"Windows NT/2000/XP/7"))
  add htext text="\n"
  add htext text="Copyright 2017-2019 HENGCE\n"
  //add htext text="Written by Oleh Yuschuk"
  while 1 do
    if hw==NULL || nq==0 then
      if hquit==NULL || Pressed(hquit) break
    else
      for i=0,i<nq,i++
        if Pressed(hq[i]) then
          clear hmain
          return i
        endif
      enddo
    endif
    //i=Strtime(s,"Current date is %a %d-%b-%Y %H:%M:%S\n",0,0)
    //SYS.Statistics(2,&used,&total,&size)
    //i=i+sprintf(s+i,"Installed physical memory %uK\n",                         \
    //  (size>>10) & 0x003FFFFF)
    //i=i+sprintf(s+i,"Used virtual memory %uK out of %uK\n",                    \
    //  (used>>10) & 0x003FFFFF,(total>>10) & 0x003FFFFF)
    //SYS.Statistics(3,&used,&total,&size)
    //sprintf(s+i,"%i%% OLLYTEST resources free",((total-used)*100)/total)
    //change hdate text=s
    //delay 500
  enddo
  if hw==NULL destroy hmain
  return -1
end

function int SERV.Debugmode(handle hw,handle *hq,int nq)
  int i,j,changed,status
  handle hmain
  handle dummy                         // Variable for dummy assignments
  handle hrail[16]
  handle hhead[10]
  handle hvide[9]
  handle halon,halof                   // Buttons "All on" and "All off"
  handle hdset                         // Button "Set mode"
  handle hquit                         // Button "Quit"
  char s[80]
  char framhelp[3,56] = {                                                      \
    "Enable or disable head and hardware functions",                           \
    "Enable or disable functions of video cameras and groups",                 \
    "Enable or disable head controllers as a whole" };
  char headname[10,18] = {                                                     \
    "线性马达","旋转马达","Z方向运行","左测试头",            \
    "右测试头","测量","硬件","跳过零点",                 \
    "编码器反馈","打印机" };
  char headhelp[10,49] = {                                                     \
    "*linear motors of all heads",                                             \
    "*rotational motors of all heads",                                         \
    "*Z movements of all heads",                                               \
    "*all movements of all left heads",                                        \
    "*all movements of all right heads",                                       \
    "*all kinds of measurements",                                              \
    "*hardware and hardware checks",                                           \
    "Disable to find zero pulse of rotational encoder",                        \
    "Use/don't use encoders for head positioning",                             \
    "*printer on automation" };
  char videoname[9,20] = {                                                     \
    "X马达","Y马达","M2组","上/左相机","下/右相机",\
    "","M2架板框","跳过零点","编码器反馈" };
  char videhelp[9,49] = {                                                      \
    "*X motors of both cameras",                                               \
    "*Y motors of both cameras",                                               \
    "*group movements on M2 tester",                                           \
    "*all movements of upper camera & left M2 group",                          \
    "*all movements of lower camera & right M2 group",                         \
    " ",                                                                       \
    "*movements of M2 shuttle",                                                \
    " ",                                                                       \
    "Use/don't use encoders for camera positioning" };
  if hw==NULL then
    hmain=control WINDOW
      window=NULL
      position=100,100,505,278
      mode=M_MODAL
      name="诊断模式"
      help=" "
      bkcolor=YELLOW
    endc
  else
    hmain=hw
  endif
  for i=0,i<3,i++                      // Create named frames around controls
    dummy=control FRAME
      window=hmain
      position=(i==0?DMX1:(i==1?DMX2:DMX3)),7,155,230
      text=(i==0?"测试头部分:":(i==1?"摄像头部分:":"轨道部分:"))
      help=framhelp[i]
      font=MEDIUMFONT
    endc
  enddo
  for i=0,i<9,i++                      // Create "Head items"-controls
    if headhelp[i,0]=='*' then
      sprintf(s,"Enable or disable %s",headhelp[i]+1)
    else
      Strcpy(s,headhelp[i])
    endif
    j=(($GLOBAL.debugmode>>(i==8?13:i)) & 1) ^ 1
    hhead[i]=control CHECKBOX
      window=hmain
      position=DMX1+10,i*22+35,135,20
      mode=(j==0?0:M_CHECKED)
      name=headname[i]
      help=s
      bkcolor=WHITE
    endc
  enddo
  j=(($GLOBAL.debugmode>>8) & 1) ^ 1
  hhead[9]=control CHECKBOX
    window=hmain
    position=DMX2+10,5*22+35,137,20
    mode=(j==0?0:M_CHECKED)
    name=headname[9]
    help=format("启用或禁用 %s",headhelp[9]+1)
    bkcolor=WHITE
  endc
  for i=0,i<9,i++                      // Create "Video items"-controls
    if videhelp[i,0]=='*' then
      sprintf(s,"Enable or disable %s",videhelp[i]+1)
    else
      Strcpy(s,videhelp[i])
    endif
    j=(($GLOBAL.videomode>>(i==8?13:i)) & 1) ^ 1
    if i==5 j=0
    hvide[i]=control CHECKBOX
      window=hmain
      position=DMX2+10,i*22+35,i==5?0:137,20
      mode=(j==0?0:M_CHECKED)
      name=videoname[i]
      help=s
      bkcolor=WHITE
    endc
  enddo
  disable(hvide[5])
  for i=0,i<16,i++                     // Create "Enabled rails"-controls
    j=(($GLOBAL.disabledrails>>i) & 1) ^ 1
    hrail[i]=control CHECKBOX
      window=hmain
      position=(i<8?DMX3+10:DMX3+80),(i<8?i*22+35:(i-8)*22+35),70,20
      mode=(j==0?0:M_CHECKED)
      name=format("轨道 %i",i)
      help=format("启用或禁用所有移动轨道 %i",i)
      bkcolor=WHITE
    endc
  enddo
  halon=control WINBUTTON
    window=hmain
    position=DMX3+10,8*22+38,60,21
    name="全开"
    help="立刻启用所有可用的轨道"
    font=INFOFONT
  endc
  halof=control WINBUTTON
    window=hmain
    position=DMX3+80,8*22+38,60,21
    name="全关"
    help="立刻禁用所有轨道"
    font=INFOFONT
  endc
  if hw==NULL || nq==0 then
    Strcpy(s,"Set debug mode and close this window")
  else
    Strcpy(s,"Set debug mode")
  endif
  hdset=control WINBUTTON
    window=hmain
    position=DMX1,DMYB,90,24
    name="设置模式"
    help=s
  endc
  if hw==NULL || nq==0 then
    hquit=control WINBUTTON
      window=hmain
      position=405,DMYB,90,24
      name="取消"
      help="退出但不更改调试模式"
    endc
  endif
  changed=0
  while 1 do
    if ($LAY.config & LC_TYPEMASK)==LC_S3 then
      // S3 cameras can be enabled or disabled only simultaneously.
      if Pressed(hvide[3]) then
        status=Status(hvide[3])
        if Status(hvide[4])!=status then
          change hvide[4] mode=(status==0?0:M_CHECKED)
        endif
      else if Pressed(hvide[4]) then
        status=Status(hvide[4])
        if Status(hvide[3])!=status then
          change hvide[3] mode=(status==0?0:M_CHECKED)
        endif
      endif
    endif
    if Pressed(hdset) then
      for i=0,i<10,i++                 // Read current enable status of heads
        if Status(hhead[i])==0 then
          $GLOBAL.debugmode=$GLOBAL.debugmode|(1<<(i==8?13:(i==9?8:i)))
        else
          $GLOBAL.debugmode=$GLOBAL.debugmode&(~(1<<(i==8?13:(i==9?8:i))))
        endif
      enddo
      for i=0,i<9,i++                  // Read current enable status of cameras
        if Status(hvide[i])==0 then
          $GLOBAL.videomode=$GLOBAL.videomode|(1<<(i==8?13:i))
        else
          $GLOBAL.videomode=$GLOBAL.videomode&(~(1<<(i==8?13:i)))
        endif
      enddo
      for i=0,i<16,i++                 // Read current enable status of rails
        if Status(hrail[i])==0 then
          $GLOBAL.disabledrails=$GLOBAL.disabledrails|(1<<i)
        else
          $GLOBAL.disabledrails=$GLOBAL.disabledrails&(~(1<<i))
        endif
      enddo
      if $GLOBAL.crateloaded==1 then
        s[0]=S_DEBUG
        s[1]=0x01                      // Set debugging mode
        $uint2(s+2)=$GLOBAL.debugmode
        $uint2(s+4)=$GLOBAL.disabledrails
        $uint2(s+6)=$GLOBAL.videomode
        SYS.Send(8,s,0)
      endif
      changed=1
      if hw==NULL || nq==0 break
    else if Pressed(halon) then
      j=$LAY.nfing; if $LAY.cameras!=0 j++
      if j==0 j=16
      for i=0,i<16,i++
        change hrail[i] mode=(i<j?M_CHECKED:0)
      enddo
    else if Pressed(halof) then
      for i=0,i<16,i++
        change hrail[i] mode=0
      enddo
    else if hw==NULL || nq==0 then
      if hquit==NULL || Pressed(hquit) break
    else
      for i=0,i<nq,i++
        if Pressed(hq[i]) then
          clear hmain
          return i
        endif
      enddo
    endif
    wait
  enddo
  if hw==NULL destroy hmain
  if changed!=0 SYS.Broadcast(8,"CHG DBG")
  return -1
end

function int SERV.Measmode(handle hw,handle *hq,int nq)
  int i,j,x,y,changed
  char s[256]
  handle hmain
  handle dummy                         // Variable for dummy assignments
  handle hhead[32]
  handle halon,halof
  handle hdset
  handle hquit
  if hw==NULL then
    hmain=control WINDOW
      window=NULL
      position=100,100,505,278
      mode=M_MODAL
      name="测量模式"
      help=" "
      bkcolor=YELLOW
    endc
  else
    hmain=hw
  endif
  dummy=control FRAME                  // Create named frame around heads
    window=hmain
    position=DMX1,7,245,230
    text="允许测试的头:"
    help="启用或禁用列出的测试进行头测量"
    font=MEDIUMFONT
  endc
  j=$uint4($GLOBAL+280)                // $GLOBAL.measmode
  for i=0,i<32,i++                     // Create "Enabled head"-controls
    x=(i/16==0?DMX1+10:DMX1+140)
    if (i & 1) x=x+50
    y=((i % 16)/2)*22+35
    hhead[i]=control CHECKBOX
      window=hmain
      position=x,y,50,20
      mode=((j & (1<<i))==0?M_CHECKED:0)
      name=format("%i%c",i/2,i & 1?'R':'L')
      help=format(                                                             \
        "Enable or disable measurements on head %i%c",i/2,i & 1?'R':'L')
      bkcolor=WHITE
    endc
  enddo
  halon=control WINBUTTON
    window=hmain
    position=DMX1+57,8*22+36,60,18
    name="全开"
    help="立刻启用所有可用测试头"
    font=INFOFONT
  endc
  halof=control WINBUTTON
    window=hmain
    position=DMX1+127,8*22+36,60,18
    name="全关"
    help="立刻禁用所有可用的测试头"
    font=INFOFONT
  endc
  if hw==NULL || nq==0 then
    Strcpy(s,"Set measurement mode and close this window")
  else
    Strcpy(s,"Set measurement mode")
  endif
  hdset=control WINBUTTON
    window=hmain
    position=DMX1,DMYB,90,24
    name="设置模式"
    help=s
  endc
  if hw==NULL || nq==0 then
    hquit=control WINBUTTON
      window=hmain
      position=405,DMYB,90,24
      name="取消"
      help="退出但不改变测量模式"
    endc
  endif
  changed=0
  while 1 do
    if Pressed(hdset) then
      for i=0,i<32,i++ do              // Read current status of heads
        if Status(hhead[i])==0 then
          $uint4($GLOBAL+280)=$uint4($GLOBAL+280)|(1<<i)
        else
          $uint4($GLOBAL+280)=$uint4($GLOBAL+280) & (~(1<<i))
        endif
      enddo
      if $GLOBAL.crateloaded==1 then
        s[0]=S_DEBUG
        s[1]=0x0F                      // Set debug mode of measurement card
        $uint4(s+2)=$uint4($GLOBAL+280)
        $uint4(s+6)=0
        $uint4(s+10)=0
        $uint4(s+14)=0
        SYS.Send(18,s,0)
      endif
      changed=1
      if hw==NULL || nq==0 break
    else if Pressed(halon) then
      j=$LAY.nfing*2; if j==0 j=16
      for i=0,i<32,i++
        change hhead[i] mode=(i<j?M_CHECKED:0)
      enddo
    else if Pressed(halof) then
      for i=0,i<32,i++
        change hhead[i] mode=0
      enddo
    else if hw==NULL || nq==0 then
      if hquit==NULL || Pressed(hquit) break
    else
      for i=0,i<nq,i++
        if Pressed(hq[i]) then
          clear hmain
          return i
        endif
      enddo
    endif
    wait
  enddo
  if hw==NULL destroy hmain
  if changed!=0 SYS.Broadcast(8,"CHG DBG")
  return -1
end

function int SERV.Displaymode(handle hw,handle *hq,int nq)
  int i,j,ret
  handle hmain,hquit
  handle hedit,hbrow,hlgon,hlgof,hdump,hstat
  handle hsmes,hfldd,hmech,htpdi,htpic,htpdc
  handle hansw[9]
  handle dummy                         // Variable for dummy assignments
  char s[266]
  char answname[9,17] = {                                                      \
    "错误信息", "软件复位", "模仿运动", "无效测量",         \
    "全部测量","数据传输",  "诊断命令", "查找",           \
    "I/O端口" };
  char answhelp[9,63] = {                                                      \
    "Display or hide error messages. Better keep enabled!",                    \
    "Display or hide Soft Reset and related messages",                         \
    "Display or hide \"READY\" answers to pure movements",                     \
    "Display or hide results of measurements with nontrivial status",          \
    "Display or hide results of all measurements (including bad)",             \
    "Display or hide answers to data transfer commands",                       \
    "Display or hide answers to debugging commands",                           \
    "Display or hide debugging messages generated by Dump()",                  \
    "Display or hide answers to INPORT/OUTPORT commands" };
  if hw==NULL then
    hmain=control WINDOW
      window=NULL
      position=100,100,505,278
      mode=M_MODAL
      name="展示模式"
      help=" "
      bkcolor=YELLOW
    endc
  else
    hmain=hw
  endif
  dummy=control FRAME
    window=hmain
    position=DMX1,7,165,230
    text="显示:"
    help="从内核启用或禁用以下类型的响应"
    font=MEDIUMFONT
  endc
  j=1
  for i=0,i<9,i++                      // Create display mode controls
    hansw[i]=control CHECKBOX
      window=hmain
      position=DMX1+10,i*22+35,150,20
      name=answname[i]
      help=answhelp[i]
      mode=($GLOBAL.displaymode & j)==0?0:M_CHECKED
      bkcolor=WHITE
    endc
    j=j<<1
  enddo
  dummy=control TEXT
    window=hmain
    position=DMX2+10,8,200,30
    text="日志文件:"
    font=MEDIUMFONT
  endc
  hedit=control COMBOEDIT
    window=hmain
    position=DMX2+10,27,245,160
    name="主日志文件"
    help="在此处键入或选择主日志文件的名称"
  endc
  hbrow=control BUTTON
    window=hmain
    position=DMX2+260,27,60,24
    name="浏览"
    help="按可浏览主日志文件的名称"
  endc
  i=SYS.Message(0,5,"LOG?")
  hlgon=control BUTTON
    window=hmain
    position=DMX2+10,56,150,23
    name="开始记录"
    help="按下开始记录主列表信息"
  endc
  hlgof=control BUTTON
    window=hmain
    position=DMX2+170,56,150,23
    name="停止记录"
    help="按下可停止记录主列表信息"
  endc
  if i==0 then disable hlgof;
  else disable hlgon;
  endif
  hdump=control CHECKBOX
    window=hmain
    position=DMX2+10,85,230,19
    name="丢弃答案"
    help="选中此项以十六进制转储所有显示的答案"
    mode=($GLOBAL.displaymode & 0x80000000)==0?0:M_CHECKED
  endc
  hstat=control CHECKBOX
    window=hmain
    position=DMX2+10,104,230,19
    name="解码状态"
    help="解码测量状态的重要位"
    mode=($GLOBAL.displaymode & ST)==0?0:M_CHECKED
  endc
  hfldd=control CHECKBOX
    window=hmain
    position=DMX2+10,123,230,19
    name="丢弃电场和U-I"
    help="选中显示原始字段和U-I组件"
    mode=($GLOBAL.displaymode & FL)==0?0:M_CHECKED
  endc
  hsmes=control CHECKBOX
    window=hmain
    position=DMX2+10,142,230,19
    name="显示脚本信息"
    help="检查以显示内部过程间通信消息"
    mode=($GLOBAL.displaymode & SM)==0?0:M_CHECKED
  endc
  // The following controls are available in embedded (DLL) version only.
  if Embedded()!=0 then
    htpic=control CHECKBOX
      window=hmain
      position=DMX2+10,164,230,19
      name="显示输入命令"
      help="显示HARD.DLL收到的所有命令"
      mode=($GLOBAL.displaymode & IC)==0?0:M_CHECKED
    endc
    htpdc=control CHECKBOX
      window=hmain
      position=DMX2+10,183,230,19
      name="解码命令"
      help="解码指令发送给测试机"
      mode=($GLOBAL.displaymode & DC)==0?0:M_CHECKED
    endc
    hmech=control CHECKBOX
      window=hmain
      position=DMX2+10,202,230,19
      name="显示MECH翻译"
      help="检查在MECH.DLL中显示内部数据流"
      mode=($GLOBAL.displaymode & ME)==0?0:M_CHECKED
    endc
    htpdi=control CHECKBOX
      window=hmain
      position=DMX2+10,221,230,19
      name="HARD.DLL中的全部诊断信息"
      help="检查HARD.DLL显示附加信息"
      mode=($GLOBAL.displaymode & DI)==0?0:M_CHECKED
    endc
  endif
  if hw==NULL || nq==0 then
    hquit=control WINBUTTON
      window=hmain
      position=405,DMYB,90,24
      name="关闭"
      help="关闭此窗口"
    endc
  endif
  while 1 do
    if Pressed(hlgon) then
      confirm hedit
      Strcpy(s,"LOG "); Text(hedit,s+4);
      i=SYS.Message(0,Strlen(s)+1,s);
      if i==0 then
        enable hlgon; disable hlgof;
      else
        disable hlgon; enable hlgof
      endif
    else if Pressed(hlgof) then
      i=SYS.Message(0,5,"LOG ")
      if i==0 then
        enable hlgon; disable hlgof;
      else
        disable hlgon; enable hlgof
      endif
    else if Pressed(hbrow) then
      Text(hedit,s)
      if SYS.Browse(hmain,s,"Select log file",0)!=0 then
        change hedit text=s
      endif
    endif
    if hw==NULL || nq==0 then
      if hquit==NULL || Pressed(hquit) then
        ret=-1; goto finish
      endif
    else
      for ret=0,ret<nq,ret++
        if Pressed(hq[ret]) goto finish
      enddo
    endif
    wait
  enddo
finish:
  j=1
  for i=0,i<9,i++
    if Status(hansw[i])==0 then
      $GLOBAL.displaymode=$GLOBAL.displaymode & (~j)
    else
      $GLOBAL.displaymode=$GLOBAL.displaymode | j
    endif
    j=j<<1
  enddo
  if Status(hdump)==0 then
    $GLOBAL.displaymode=$GLOBAL.displaymode & (~DU)
  else
    $GLOBAL.displaymode=$GLOBAL.displaymode | DU
  endif
  if Status(hstat)==0 then
    $GLOBAL.displaymode=$GLOBAL.displaymode & (~ST)
  else
    $GLOBAL.displaymode=$GLOBAL.displaymode | ST
  endif
  if Status(hsmes)==0 then
    $GLOBAL.displaymode=$GLOBAL.displaymode & (~SM)
  else
    $GLOBAL.displaymode=$GLOBAL.displaymode | SM
  endif
  if Status(hfldd)==0 then
    $GLOBAL.displaymode=$GLOBAL.displaymode & (~FL)
  else
    $GLOBAL.displaymode=$GLOBAL.displaymode | FL
  endif
  if Embedded()!=0 then
    if Status(hmech)==0 then
      $GLOBAL.displaymode=$GLOBAL.displaymode & (~ME)
    else
      $GLOBAL.displaymode=$GLOBAL.displaymode | ME
    endif
    if Status(htpdi)==0 then
      $GLOBAL.displaymode=$GLOBAL.displaymode & (~DI)
    else
      $GLOBAL.displaymode=$GLOBAL.displaymode | DI
    endif
    if Status(htpic)==0 then
      $GLOBAL.displaymode=$GLOBAL.displaymode & (~IC)
    else
      $GLOBAL.displaymode=$GLOBAL.displaymode | IC
    endif
    if Status(htpdc)==0 then
      $GLOBAL.displaymode=$GLOBAL.displaymode & (~DC)
    else
      $GLOBAL.displaymode=$GLOBAL.displaymode | DC
    endif
  endif
  if hw==NULL then
    destroy hmain
  else
    clear hmain
  endif
  return ret
end

function int Geteditchar(handle hw)
  char s[32]
  int i
  Text(hw,s);
  if s[0]=='\'' then                   // Character constant
    return s[1];
  else if Isdigit(s[0]) then           // Decimal or hexadecimal constant
    if (s[0]=='0' && Toupper(s[1])=='X') then
      sscanf(s+2,"%x",&i);             // Hexadecimal constant
    else
      sscanf(s,"%i",&i);               // Decimal constant
    endif
    return i
  else if s[0]=='\\' then              // C-like control symbol
    if Toupper(s[1])=='N' then
      return '\n'                      // End of line (line feed)
    else if Toupper(s[1])=='R' then
      return '\r'                      // Carriage return
    else
      return 0                         // Error, symbol not recognized
    endif
  else if Stricmp(s,"CR")==0 then
    return '\r'                        // Carriage return
  else if Stricmp(s,"LF")==0 then
    return '\n'                        // End of line (line feed)
  else if Stricmp(s,"ESC")==0 then
    return 27                          // Escape character
  else if Stricmp(s,"EOT")==0 then
    return 4                           // EOT character
  else
    return s[0]                        // Any other character
  endif
end

function int Seteditchar(handle hw,int c)
  if c==0 then
    change hw text=""                  // Leave edit control empty
  else if c==4 then
    change hw text="EOT"               // EOT character
  else if c=='\n' then
    change hw text="LF"                // End of line (line feed)
  else if c=='\r' then
    change hw text="CR"                // Carriage return
  else if c==27 then
    change hw text="ESC"               // Escape character
  else if c>=32 && c<127 then
    change hw text=format("\'%c\'",c)  // Printable character
  else
    change hw text=format("0x%x",c)    // Nonprintable character
  endif
end

function int SERV.Setexternal(handle hw,handle *hq,int nq)
  int i,j,ret,channel,current,changeto,redraw,emode,echan
  char s[64]
  handle hmain,hquit
  handle hnumb,hnscr,hseri,hieee,hvars,hcrlf
  handle hnoco,hbaud,hbits,hpari,htout,htscr
  handle hansw
  handle hecon,hpron,heron             // RS232 mode only
  handle hecho,hpmpt,herr1,herr2,herr3 // RS232 mode only
  handle hconv,hprim,hseco             // IEEE mode only
  handle hcscr,hpscr,hsscr             // IEEE mode only
  handle dummy                         // Variable for dummy assignments
  if hw==NULL then
    hmain=control WINDOW
      window=NULL
      position=100,100,505,278
      mode=M_MODAL
      name="外部设备设置"
      help=" "
      bkcolor=YELLOW
    endc
  else
    hmain=hw
  endif
  dummy=control TEXT
    window=hmain
    position=DMX1,11,75,21
    name="通道:"
    font=MEDIUMFONT
  endc
  hnumb=control EDIT
    window=hmain
    position=DMX1+77,9,20,25
    help="选择此设备连接到的通道"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hnscr=control VSCROLL
    window=hmain
    position=DMX1+97,9,20,25
    help="选择此设备连接到的通道"
    limits=1,-1
    mode=M_NOTAB
  endc
  dummy=control FRAME
    window=hmain
    position=DMX1,42,116,48
  endc
  hseri=control RADIO
    window=hmain
    position=DMX1+10,45,90,21
    text="RS232"
    help="选择RS232控制设备"
    bkcolor=WHITE
  endc
  hieee=control RADIO
    window=hmain
    position=DMX1+10,66,90,21
    text="IEEE488"
    help="检查选择通过适配器连接的IEEE 488(GPIB)设备"
    bkcolor=WHITE
  endc
  if $GLOBAL.a5!=0 disable hieee
  dummy=control CHILD
    window=hmain
    position=DMX1+1,100,114,136
    size=128
    help=" "
  endc
  draw window=dummy
  draw at 5,16 text="波特率:"
  hbaud=control COMBOLIST
    window=dummy
    position=26,17,80,90
    help="设置所选串行通讯通道的波特率"
  endc
  add hbaud text="1200"
  add hbaud text="2400"
  add hbaud text="4800"
  add hbaud text="9600"
  draw at 5,60 text="数据位:"
  hbits=control COMBOLIST
    window=dummy
    position=26,61,80,58
    help="设置数据位数(不包括奇偶校验或停止位)"
  endc
  add hbits text="7"
  add hbits text="8"
  draw at 5,104 text="奇偶位:"
  hpari=control COMBOLIST
    window=dummy
    position=26,105,80,74
    help="设置奇偶校验"
  endc
  add hpari text="无"
  add hpari text="奇数"
  add hpari text="偶数"
  hvars=control CHILD
    window=hmain
    position=DMX1+125,43,359,193
    help=" "
    size=256
  endc
  if hw==NULL || nq==0 then
    hquit=control WINBUTTON
      window=hmain
      position=405,DMYB,90,24
      name="关闭"
      help="关闭此窗口"
    endc
  endif
  channel=0; current=-1; redraw=1
  while 1 do
    if $GLOBAL.a5!=0 then
      emode=0
    else
      emode=$GLOBAL.extmode[channel] & 0x04
    endif
    echan=-1
    // Look whether some control was pressed.
    if $GLOBAL.a5==0 then
      if Pressed(hseri) then
        echan=channel
        $GLOBAL.extmode[channel]=$GLOBAL.extmode[channel] & 0xFB
      else if Pressed(hieee) then
        echan=channel
        $GLOBAL.extmode[channel]=$GLOBAL.extmode[channel] | 0x04
      endif
    endif
    if Pressed(hnumb) || Pressed(hnscr) then
      echan=channel
      i=Status(hnscr)
      Text(hnumb,s); channel=0; sscanf(s,"%i",&channel)
      if $GLOBAL.a5!=0 then
        channel=Max(0,Min(7,channel+i))
      else
        channel=Max(0,Min(3,channel+i))
      endif
      change hnscr select=0
      redraw=1
    else if Pressed(hbaud) then
      i=Status(hbaud)
      $GLOBAL.extbaud[channel]=($GLOBAL.extbaud[channel] & 0x1B) | (i*32+128)
    else if Pressed(hbits) then
       i=Status(hbits)
      $GLOBAL.extbaud[channel]=($GLOBAL.extbaud[channel] & 0xF8) | (i+2)
    else if Pressed(hpari) then
       i=Status(hpari)
      $GLOBAL.extbaud[channel]=($GLOBAL.extbaud[channel] & 0xE3) |             \
      (i==0?0x00:(i==1?0x08:0x18))
    else if Pressed(hcrlf) then
      i=$uint1($GLOBAL+508+channel)    // $GLOBAL.extopt
      if Status(hcrlf)==0 then i=i & 0xFE; else i=i|0x01; endif
      $uint1($GLOBAL+508+channel)=i
    else if Pressed(hnoco) then
      i=$GLOBAL.extmode[channel]
      if Status(hnoco)==0 then i=i & 0xF7; else i=i|0x08; endif
      $GLOBAL.extmode[channel]=i
    else if Pressed(htout) || Pressed(htscr) then
      i=Status(htscr)
      Text(htout,s); j=0; sscanf(s,"%i",&j)
      j=Max(0,Min(99,j+i))
      change htscr select=0
      $GLOBAL.extwait[channel]=j
      redraw=1
    endif
    if current==0 then                 // Look whether RS232 conrol was pressed
      i=$GLOBAL.extmode[channel]
      if Pressed(hecon) then
        if Status(hecon)==0 then i=i & 0x7F; else i=i|0x80; endif
      else if Pressed(hpron) then
        if Status(hpron)==0 then i=i & 0xDF; else i=i|0x20; endif
      else if Pressed(heron) then
        if Status(heron)==0 then i=i & 0xEF; else i=i|0x10; endif
      else if Pressed(hecho) || Pressed(hansw) || Pressed(hpmpt) then
        echan=channel
      else if Pressed(herr1) || Pressed(herr2) || Pressed(herr3) then
        echan=channel
      endif
      $GLOBAL.extmode[channel]=i
    else if $GLOBAL.a5==0 then         // Look whether IEEE conrol was pressed
      if Pressed(hansw) then
        echan=channel
      else if Pressed(hconv) || Pressed(hcscr) then
        i=Status(hcscr)
        Text(hconv,s); j=0; sscanf(s,"%i",&j)
        j=Max(0,Min(1,j+i))
        change hcscr select=0
        $GLOBAL.extconverter[channel]=j
        redraw=1
      else if Pressed(hprim) || Pressed(hpscr) then
        i=Status(hpscr)
        Text(hprim,s); j=0; sscanf(s,"%i",&j)
        j=Max(0,Min(30,j+i))
        change hpscr select=0
        $GLOBAL.extprimary[channel]=j
        redraw=1
      else if Pressed(hseco) || Pressed(hsscr) then
        i=Status(hsscr)
        Text(hseco,s); j=0; sscanf(s,"%i",&j)
        j=Max(-1,Min(30,j+i))
        change hsscr select=0
        $GLOBAL.extsecondary[channel]=j
        redraw=1
      endif
    endif
    if echan>=0 && current>=0 then     // Get current status of edit controls
      if emode==0 then                 // Get RS232 controls
        $GLOBAL.extecho[echan]=Geteditchar(hecho)
        $GLOBAL.extanswer[echan]=Geteditchar(hansw)
        $GLOBAL.extprompt[echan]=Geteditchar(hpmpt)
        $GLOBAL.exterr1[echan]=Geteditchar(herr1)
        $GLOBAL.exterr2[echan]=Geteditchar(herr2)
        $GLOBAL.exterr3[echan]=Geteditchar(herr3)
      else                             // Get IEEE controls
        $GLOBAL.extanswer[echan]=Geteditchar(hansw)
        Text(hconv,s); j=$GLOBAL.extconverter[echan];
        sscanf(s,"%i",&j); $GLOBAL.extconverter[echan]=j
        Text(hprim,s); j=$GLOBAL.extprimary[echan];
        sscanf(s,"%i",&j); $GLOBAL.extprimary[echan]=j
        Text(hseco,s); j=$GLOBAL.extsecondary[echan];
        sscanf(s,"%i",&j); $GLOBAL.extsecondary[echan]=j
      endif
      redraw=1
    endif
    if $GLOBAL.a5==0  then
      changeto=(($GLOBAL.extmode[channel] & 0x04)==0?0:1)
    else
      changeto=0
    endif
    if changeto!=current then
      clear hvars                      // Redraw mode-specific buttons
      draw window=hvars
      hcrlf=control CHECKBOX
        window=hvars
        position=30,111,240,21
        name="附加CR/LF到命令"
        help="将CR / LF添加到OllyTest发送的命令中"
      endc
      hnoco=control CHECKBOX
        window=hvars
        position=30,136,190,21
        name="灵敏测试"
        help="检查其他手臂是否不允许接触PCB"
      endc
      draw at 30,182 text="超时"
      htout=control EDIT               // Create controls common for both modes
        window=hvars
        position=95,163,25,21
        help="指定等待外部设备应答的时间"
      endc
      htscr=control VSCROLL
        window=hvars
        position=120,163,20,21
        limits=1,-1
        help="按可更改超时"
        mode=M_NOTAB
      endc
      draw at 145,182 text="秒"
      if (changeto==0) then            // Create RS232-specific controls
        draw at 5,26 text="设备反馈:"
        hecon=control CHECKBOX
          window=hvars
          position=30,31,76,23
          name="- 响应"
          help="当外部设备响应命令时打开"
          mode=M_RIGHT
        endc
        hpron=control CHECKBOX
          window=hvars
          position=30,57,76,23
          name="- 提示符"
          help="执行命令后设备反馈提示时打开"
          mode=M_RIGHT
        endc
        heron=control CHECKBOX
          window=hvars
          position=30,83,76,23
          name="- 错误"
          help="当外部设备支持特殊错误提示时打开"
          mode=M_RIGHT
        endc
        draw at 123,26 text="答案结尾 ="
        hansw=control EDIT
          window=hvars
          position=231,7,40,21
          help="答案结尾字符(例如，CR，'X'或27)"
        endc
        draw at 123,52 text="响应结尾 ="
        hecho=control EDIT
          window=hvars
          position=231,33,40,21
          help="响应结束字符(例如，CR，'X'或27)"
        endc
        draw at 123,78 text="提示符结尾 ="
        hpmpt=control EDIT
          window=hvars
          position=231,59,40,21
          help="提示结束(例如CR，'X'或27)"
        endc
        draw at 123,104 text="错误提示符 ="
        herr1=control EDIT
          window=hvars
          position=231,85,40,21
          help="第一种可能的错误提示(例如CR，'X'或27)"
        endc
        herr2=control EDIT
          window=hvars
          position=273,85,40,21
          help="第二种可能的错误提示(例如CR，'X'或27)"
        endc
        herr3=control EDIT
          window=hvars
          position=315,85,40,21
          help="第三种可能的错误提示(例如CR，'X'或27)"
        endc
      else if (changeto==1) then       // Create IEEE-specific controls
        draw at 58,26 text="End of answer ="
        hansw=control EDIT
          window=hvars
          position=231,7,40,21
          help="答案结尾字符(例如，CR，'X'或27)"
        endc
        draw at 58,52 text="RS-IEEE convertor type ="
        hconv=control EDIT
          window=hvars
          position=231,33,40,21
          help="此处指定RS-IEEE转换器类型"
        endc
        hcscr=control VSCROLL
          window=hvars
          position=271,33,20,21
          help="按下可更改RS-IEEE转换器类型"
          limits=1,-1
          mode=M_NOTAB
        endc
        draw at 58,78 text="Primary IEEE adress ="
        hprim=control EDIT
          window=hvars
          position=231,59,40,21
          help="此处指定主IEEE地址(0..30)"
        endc
        hpscr=control VSCROLL
          window=hvars
          position=271,59,20,21
          help="按下可更改主IEEE地址"
          limits=1,-1
          mode=M_NOTAB
        endc
        draw at 58,104 text="Secondary IEEE adress ="
        hseco=control EDIT
          window=hvars
          position=231,85,40,21
          help="指定二级IEEE地址(0..30或-1，如果不需要)"
        endc
        hsscr=control VSCROLL
          window=hvars
          position=271,85,20,21
          help="按下可更改二级IEEE地址"
          limits=1,-1
          mode=M_NOTAB
        endc
      endif
      draw show
      current=changeto; redraw=1
    endif
    if redraw!=0 then                  // Update all available controls
      change hnumb text=format("%i",channel)
      i=$GLOBAL.extbaud[channel]
      j=(i>>5) & 0x07
      change hbaud select=(j<4?3:j-4)
      change hbits select=((i & 0x03)==0x02?0:1)
      change hpari select=((i & 0x08)==0?0:((i & 0x10)==0?1:2))
      i=$GLOBAL.extmode[channel]
      if ((i & 0x0004)==0) then
        change hseri mode=M_CHECKED
      else
        change hieee mode=M_CHECKED
      endif
      change hnoco mode=(i & 0x08)==0?0:M_CHECKED
      i=$uint1($GLOBAL+508+channel)    // $GLOBAL.extopt
      change hcrlf mode=(i & 0x01)==0?0:M_CHECKED
      change htout name=format("%i",$GLOBAL.extwait[channel])
      Seteditchar(hansw,$GLOBAL.extanswer[channel])
      if current==0 then               // Update RS232-specific controls
        change hecon mode=((i & 0x80)!=0)
        change hpron mode=((i & 0x20)!=0)
        change heron mode=((i & 0x10)!=0)
        Seteditchar(hecho,$GLOBAL.extecho[channel])
        Seteditchar(hpmpt,$GLOBAL.extprompt[channel])
        Seteditchar(herr1,$GLOBAL.exterr1[channel])
        Seteditchar(herr2,$GLOBAL.exterr2[channel])
        Seteditchar(herr3,$GLOBAL.exterr3[channel])
      else                             // Update IEEE-specific controls
        change hconv text=format("%i",$GLOBAL.extconverter[channel])
        change hprim text=format("%i",$GLOBAL.extprimary[channel])
        change hseco text=format("%i",$GLOBAL.extsecondary[channel])
      endif
      redraw=0
    endif
    if hw==NULL || nq==0 then
      if hquit==NULL || Pressed(hquit) then
        ret=-1; goto finish
      endif
    else
      for ret=0,ret<nq,ret++
        if Pressed(hq[ret]) goto finish
      enddo
    endif
    wait
  enddo
finish:
  if hw==NULL then
    destroy hmain
  else
    clear hmain
  endif
  return ret
end

// Sets common options, such as user (prefere=0), debug mode (1), display mode
// (3), external measurements or miscelanneous options (3).
function int SERV.Options(int prefere)
  int i,lastsel
  handle hmain,hfunc
  handle hbutt[6]
  char bname[6,8] = { "信息","诊断","测试","显示","外部","关闭" }
  char bhelp[6,44] = {                                                         \
    "Press to see system information",                                         \
    "Press to set hardware debug mode",                                        \
    "Press to set measurements options",                                       \
    "Press to set protocol and display options",                               \
    "Press to set properties of external devices",                             \
    "Press to close Options window" };
  hmain=control WINDOW
    window=NULL
    position=100,100,515,308
    name="选项"
    help="使用此窗口可设置系统、显示和调试选项"
    bkcolor=GRAY
    mode=M_MODAL
  endc
  do i=0,5,1
    hbutt[i]=control BUTTON
      window=hmain
      position=4+84*i,4,(i==5?87:84),23
      name=bname[i]
      help=bhelp[i]
    endc
  enddo
  if $GLOBAL.a5==0 disable hbutt[2]    // Not supported by A2/3/4
  hfunc=control CHILD
    window=hmain
    position=5,27,505,278
    help=" "
    bkcolor=YELLOW
  endc
  lastsel=prefere
  while 1 do
    for i=0,i<6,i++
      change hbutt[i] color=(i==prefere?LIGHTRED:BLACK)
      change hbutt[i] bkcolor=(i==prefere?YELLOW:GRAY)
    enddo
    if prefere<0 then
    else if prefere==0 then
      lastsel=prefere
      prefere=SERV.Info(hfunc,hbutt,6)
    else if prefere==1 then
      lastsel=prefere
      prefere=SERV.Debugmode(hfunc,hbutt,6)
    else if prefere==2 then
      lastsel=prefere
      prefere=SERV.Measmode(hfunc,hbutt,6)
    else if prefere==3 then
      lastsel=prefere
      prefere=SERV.Displaymode(hfunc,hbutt,6)
    else if prefere==4 then
      lastsel=prefere
      prefere=SERV.Setexternal(hfunc,hbutt,6)
    else
      break
    endif
    if Pressed(hbutt[5]) break
  enddo
  destroy hmain
  SYS.Broadcast(8,"CHG DBG")           // Debug mode is not necessarily changed
  return lastsel
end

// Function decodes command sent to the tester into the text array s.
// Returns color of the text, or -1 if command type is not in the mask.
function int SERV.Decodecommand(char *command,char *s,int mask)
  int i,j,k,n,type,len,cmd,subcmd,color,first
  float r
  color=BLUE
  len=$uint2(command)
  if (len<5) then
    sprintf(s,"Command is too short, only %i bytes",len)
    return RED                         // Command is too short
  endif
  cmd=command[4]
  switch cmd
  case S_NOP:
    sprintf(s,"NOP")
  case S_FIELD,S_RMEAS,S_FINDPAD,S_HVMEAS,S_LAMEAS,S_EXACTR,                   \
    S_EXTERN,S_CMEAS,S_FASTC:
    i=1;
    if cmd==0x01 then s[0]='F';
    else if cmd==0x02 then s[0]='R';
    else if cmd==0x0D then i=sprintf(s,"FINDPAD")
    else if cmd==0x0E then s[0]='H'; s[1]='V'; i++;
    else if cmd==0x16 then s[0]='L'; s[1]='A'; i++;
    else if cmd==0x18 then s[0]='E';
    else if cmd==0x19 then s[0]='E'; s[1]='X'; s[2]='T'; i=i+2;
    else if cmd==0x1B then s[0]='C';
    else if cmd==0x25 then s[0]='A';
    else if cmd==0x48 then s[0]='M'; s[1]='C'; i++;
    else if cmd==0x49 then s[0]='U'; s[1]='C'; i++;
    else s[0]='?'; endif
    i=i+sprintf(s+i," (%i:%g,%g,%g,D%i)",command[5],                           \
      $int3(command+6)/1000.0,$int3(command+9)/1000.0,                         \
      $uint2(command+12)/1000.0,command[14])
    if cmd==S_FIELD then               // Field measurement
      i=i+sprintf(s+i," %i:%i,%i:%i",                                          \
      command[15],command[16],command[17],command[18])
    else if cmd==S_FINDPAD then        // Find pad
      i=i+sprintf(s+i," Dir=%i",command[15])
    else if cmd==S_FASTC then          // Fast capacity
      i=i+sprintf(s+i," Range=%i",command[15] & 0x1F)
      if (command[15] & 0x80)!=0 i=i+sprintf(s+i," NoShort")
    else
      i=i+sprintf(s+i," (%i:%g,%g,%g,D%i)",command[15],                        \
      $int3(command+16)/1000.0,$int3(command+19)/1000.0,                       \
      $uint2(command+22)/1000.0,command[24])
    endif
  case S_SHOWPOINT,S_TOUCHPOINT:
    if cmd==S_SHOWPOINT then i=sprintf(s,"SHOW");
    else i=sprintf(s,"TOUCH"); endif
    i=i+sprintf(s+i," (%i:%g,%g)",command[5],                                  \
    $int3(command+6)/1000.0,$int3(command+9)/1000.0)
  case S_DETOUCH:
    sprintf(s,"DETOUCH");
  case S_LOADRUN:
    type=command[5]
    i=sprintf(s,"LOADRUN %i",type)
    switch type
    case 0: sprintf(s+i,"(Hard reset)")
    case 1: sprintf(s+i,"(Load crate)")
    case 2: sprintf(s+i,"(%s)",len==10?"Start crate":"Reload layout")
    case 3: sprintf(s+i,"(Load layout)")
    case 4: sprintf(s+i,"(Reload measurement parameters)")
    case 5: sprintf(s+i,"(Load heads)")
    case 6: sprintf(s+i,"(Start heads)")
    case 7,8: sprintf(s+i,"(Corrections %i%c column %i)",                      \
      $uint2(command+6),type==7?'L':'R',$uint2(command+8))
    case 15: sprintf(s+i,"(Load extended layout)")
    case 16: sprintf(s+i,"(Load headcam corrections)")
    case 17: sprintf(s+i,"(Load optional corrections)")
    case 18: sprintf(s+i,"(Load fine head corrections)")
    case 19: sprintf(s+i,"(Load fine headcam corrections)")
    case 20: sprintf(s+i,"(Load additional extention %i)",$uint4(command+6))
    case 32: sprintf(s+i,"(X acceleration table)")
    endsw
  case S_LAYOUT:
    type=command[5]
    i=sprintf(s,"LAYOUT %i",type)
    switch type
    case 2: sprintf(s+i," (Read layout)")
    case 3: sprintf(s+i," (Get layout)")
    case 15: sprintf(s+i," (Get extended layout)")
    case 20: sprintf(s+i," (Get additional extention %i)",$uint4(command+6))
    endsw
  case S_RESET:
    sprintf(s,"RESET")
  case S_CHECKZERO:
    sprintf(s,"CHECKZERO rail=%i",$uint2(command+5))
  case S_DEFBOARD:
    sprintf(s,"默认板 %g,%g,%g,%g",$int3(command+6)/1000.0,                  \
    $int3(command+9)/1000.0,$int3(command+12)/1000.0,$int3(command+15)/1000.0)
  case S_HVINIT:
    if len==13 then
      sprintf(s,"HVINIT %i,C%iA%iT%i",$uint2(command+5),$uint2(command+7),     \
      $uint2(command+9),$uint2(command+11))
    else if len==35 then
      i=sprintf(s,"HVINIT %i,IMAX=%g,RMAX=%i",                                 \
        $uint2(command+5),$uint2(command+9)/1000.0,$uint2(command+11))
      if ($uint2(command+7) & 0x10) i=i+sprintf(s+i," GOHM")
      i=i+sprintf(s+i,",TTEST=%i,VRISE=%g",                                    \
        $uint4(command+13),$uint4(command+17)/1000.0)
      if $uint2(command+23)!=0                                                 \
        i=i+sprintf(s+i,",RLOW=%i",$uint2(command+23))
      if $uint2(command+25)!=0                                                 \
        i=i+sprintf(s+i,",ULOW=%g",$uint2(command+25)/1000.0)
      if ($uint2(command+7) & 0x01) i=i+sprintf(s+i,",DIS")
      if ($uint2(command+7) & 0x02) i=i+sprintf(s+i,",POL")
      if ($uint2(command+7) & 0x04) i=i+sprintf(s+i,",FIX")
      if ($uint2(command+7) & 0x08) i=i+sprintf(s+i,",UNI")
    else if len==53 then
      i=sprintf(s,"HVSTEPS ")
      if $uint2(command+7)!=0                                                  \
        i=i+sprintf(s+i,"RLOW=%i,",$uint2(command+7))
      if $uint2(command+9)!=0                                                  \
        i=i+sprintf(s+i,"ULOW=%g,",$uint2(command+9)/1000.0)
      if $uint2(command+11)!=0                                                 \
        i=i+sprintf(s+i,"IMAX=%g,",$uint2(command+11)/1000.0)
      i=i+sprintf(s+i,"VRISE=%g,",                                             \
        $uint4(command+13)/1000.0)
      if $uint2(command+19)!=0                                                 \
        i=i+sprintf(s+i,"GAP=%i,",$uint2(command+19))
      if s[i-1]==',' then
        s[i-1]=' '
      else if s[i-1]!=' ' then
        i=i+sprintf(s+i," ")
      endif
      if $uint2(command+25)!=0                                                 \
        i=i+sprintf(s+i,"U1=%i,",$uint2(command+25))
      if $uint4(command+27)!=0                                                 \
        i=i+sprintf(s+i,"R1=%i,",$uint4(command+27))
      if $uint4(command+31)!=0                                                 \
        i=i+sprintf(s+i,"T1=%i,",$uint4(command+31))
      if s[i-1]==',' then
        s[i-1]=' '
      else if s[i-1]!=' ' then
        i=i+sprintf(s+i," ")
      endif
      if $uint2(command+39)!=0                                                 \
        i=i+sprintf(s+i,"U2=%i,",$uint2(command+39))
      if $uint4(command+41)!=0                                                 \
        i=i+sprintf(s+i,"R2=%i,",$uint4(command+41))
      if $uint4(command+45)!=0                                                 \
        i=i+sprintf(s+i,"T2=%i,",$uint4(command+45))
      if ($uint2(command+5) & 0x01) i=i+sprintf(s+i,"DIS,")
      if ($uint2(command+5) & 0x02) i=i+sprintf(s+i,"POL,")
      if ($uint2(command+5) & 0x04) i=i+sprintf(s+i,"FIX,")
      if ($uint2(command+5) & 0x08) i=i+sprintf(s+i,"UNI,")
      i--; s[i]='\0'
    else
      sprintf(s,"HVINIT %i,C%iA%iT%iV%i",$uint2(command+5),$uint2(command+7),  \
      $uint2(command+9),$uint2(command+11),$uint2(command+13))
    endif
  case S_DUMP:
    i=sprintf(s,"DUMP ")
    if command[5]==0xFF then
      i=i+sprintf(s+i,"CRATE ")
    else
      i=i+sprintf(s+i,"RAIL(%i) ",command[5])
    endif
    sprintf(s+i,"ITEM=%i LENGTH=%i ADDR=%i",command[6],                        \
    $uint2(command+7),$uint2(command+9))
  case S_DEBUG:
    i=sprintf(s,"DEBUG ")
    if command[5]==0x01 then
      sprintf(s+i,"DEBUGMODE=%04X VIDEO=%04X RAILS %04X",$uint2(command+6),    \
      $uint2(command+10),$uint2(command+8))
    else if command[5]==0x0F then
      sprintf(s+i,"MEAS EXCLUDED=%04X",$uint4(command+6))
    else if command[5]==0x14 then
      sprintf(s+i,"QUERY AUTOMATION")
    else if command[5]==0x16 then
      sprintf(s+i,"QUERY PRINTER")
    else if command[5]==0x28 then
      sprintf(s+i,"READ SPS BASE=%i COUNT=%i",                                 \
      $uint2(command+6),$uint2(command+8))
    else if command[5]==0x29 then
      sprintf(s+i,"WRITE SPS BASE=%i COUNT=%i ...",                            \
      $uint2(command+6),$uint2(command+8))
    else if command[5]==0x2A then
      sprintf(s+i,"EXECUTE SPS CMD=%i NARG=%i ...",                            \
      $uint4(command+6),command[10])
    else if command[5]==0x2D then
      sprintf(s+i,"SPS HARD RESET")
    else
      sprintf(s+i,"MODE=%i (%02X)",command[5],command[5])
    endif
  case S_STROKES:
    if command[5]==0xFE then
      i=sprintf(s,"STROKES INITCOUNT %u",$uint4(command+6))
    else if command[5]==0xFF then
      i=sprintf(s,"STROKES GETCOUNT %u",$uint4(command+6))
    else
      i=sprintf(s,"STROKES mode=%i value=%u",command[5],$uint4(command+6))
    endif
  case S_LAINIT:
    i=sprintf(s,"LAINIT")
  case S_EXACTINIT:
    i=sprintf(s,"EXACTINIT P=%.1f mW, I=%.1f mA",                              \
    $uint2(command+5)/100.0,$uint2(command+7)/1000.0)
  case S_CRTINIT:
    i=sprintf(s,"MSDINIT U=%i V",$uint2(command+5))
  case S_INPORT:
    sprintf(s,"INPORT 0x%X",$uint2(command+5))
  case S_OUTPORT:
    sprintf(s,"OUTPORT 0x%X,%i",$uint2(command+5),$uint2(command+7))
  case S_LOCKDOOR:
    i=sprintf(s,"门锁 %i",command[5])
    switch command[5]
    case 0:  sprintf(s+i," (Unlock)")
    case 1:  sprintf(s+i," (Lock)")
    case 2:  sprintf(s+i," (Unlock A1/8 shuttle)")
    case 3:  sprintf(s+i," (Reset automation)")
    case 4:  sprintf(s+i," (Stop automation)")
    case 5:  sprintf(s+i," (Continue)")
    case 6:  sprintf(s+i," (To bad & printpos)")
    case 7:  sprintf(s+i," (To good & printpos)")
    case 8:  sprintf(s+i," (To bad)")
    case 9:  sprintf(s+i," (To good)")
    case 10: sprintf(s+i," (Detach)")
    case 16: sprintf(s+i," (Load N=%i)",command[6])
    case 17: sprintf(s+i," (Cyclical load N=%i)",command[6])
    case 18: sprintf(s+i," (Set PCB count=%i)",command[6])
    case 32: sprintf(s+i," (Barcodes N=%i)",command[6])
    default: if len==7 sprintf(s+i,", COUNT=%i",command[6])
    endsw
  case S_MARK:
    if command[5]==8 then
      i=sprintf(s,"MARK PEN")
      n=7
      while n+12<=len && i<200 do
        i=i+sprintf(s+i," (%g,%g)",                                            \
          $int4(command+n)/1000.0,$int4(command+n+4)/1000.0)
        n=n+12
      enddo
      if n<len sprintf(s+i," ...")
    else
      i=sprintf(s,"MARK %i",command[5])
      i=i+sprintf(s+i," (%i:%g[S%g*%i],%g[S%g*%i],DIR%i)...",command[6],       \
      $int3(command+7)/1000.0,$int2(command+13)/1000.0,$uint2(command+17),     \
      $int3(command+10)/1000.0,$int2(command+15)/1000.0,$uint2(command+19),    \
      command[21])
    endif
  case S_MESSAGE:
    i=sprintf(s,"MESSAGE ")
    type=command[5]
    subcmd=command[6]
    if type==1 then
      i=i+sprintf(s+i,"CLOSE INFO ")
    else if type==2 then
      i=i+sprintf(s+i,"CLOSE ERROR ")
    else
      i=i+sprintf(s+i,"TYPE=%i ",type)
    endif
    if subcmd==1 then
      sprintf(s+i,"[Cancel]")
    else if subcmd==2 then
      sprintf(s+i,"[OK]")
    else
      sprintf(s+i,"BUTTON=%i",subcmd)
    endif
  case S_INPORT32:
    i=sprintf(s,"INPORT32 ");
    if (command[5]==0xFF) then i=i+sprintf(s+i,"CRATE");
    else if (command[5]==0xFE) then i=i+sprintf(s+i,"SPS");
    else if (command[5]==0x80) then i=i+sprintf(s+i,"MEAS");
    else i=i+sprintf(s+i,"HEAD[%i]",command[5]); endif
    sprintf(s+i,":0x%X",$uint4(command+6))
  case S_OUTPORT32:
    i=sprintf(s,"OUTPORT32 ");
    if (command[5]==0xFF) then i=i+sprintf(s+i,"CRATE");
    else if (command[5]==0xFE) then i=i+sprintf(s+i,"SPS");
    else if (command[5]==0x80) then i=i+sprintf(s+i,"MEAS");
    else i=i+sprintf(s+i,"HEAD[%i]",command[5]); endif
    sprintf(s+i,":0x%X,%i",$uint4(command+6),$uint4(command+10))
  case S_LMAUTO:
    i=sprintf(s,"LMAUTO ");
    if (command[5]==0x01) then
      i=i+sprintf(s+i,"PROTOCOL ON ");
      j=6; n=len-6
    else if (command[5]==0x02) then
      i=i+sprintf(s+i,"PROTOCOL OFF ");
      j=6; n=len-6
    else if (command[5]==0x03) then
      i=i+sprintf(s+i,"QUERY ");
      j=6; n=len-6
    else if (command[5]==0x04) then
      i=i+sprintf(s+i,"CMD dT=%i ",$uint2(command+6));
      j=8; n=len-8
    else
      i=i+sprintf(s+i,"MODE=%i",command[5]);
      j=0; n=0
    endif
    while n>0 do
      if command[j]=='\n' || command[j]=='\0' then
        j++; n--; break;
      else
        s[i]=command[j]; i++; j++; n--
      endif
    enddo
    if (command[5]==0x04) then
      s[i]=':'; i++
      while n>0 do
        if command[j]=='\n' || command[j]=='\0' break
        s[i]=command[j]; i++; j++; n--
      enddo
    endif
    s[i]='\0'
  case S_RLINIT:
    i=sprintf(s,"RLINIT ");
    if ($uint2(command+5) & 0xC000)==0x4000 then
      i=i+sprintf(s+i,"INTERNAL ");
    else if ($uint2(command+5) & 0xC000)==0x8000 then
      i=i+sprintf(s+i,"EXTERNAL ");
    else
      i=i+sprintf(s+i,"AUTO ");
    endif
    if ($uint2(command+5) & 0x0003)==0x0001 then
      i=i+sprintf(s+i,"FAST ");
    else if ($uint2(command+5) & 0x0003)==0x0002 then
      i=i+sprintf(s+i,"MEDIUM ");
    else if ($uint2(command+5) & 0x0003)==0x0003 then
      i=i+sprintf(s+i,"SLOW ");
    endif
    if ($uint2(command+5) & 0x0070)!=0x0000 then
      i=i+sprintf(s+i,"RANGE=%i ",($uint2(command+5) & 0x0070)>>4);
    endif
    i=i+sprintf(s+i,"F=%i ",$uint4(command+7));
    i=i+sprintf(s+i,"U=%f",$uint4(command+11)/1000.0);
  case S_VIDEOCAM:
    i=sprintf(s,"VIDEOCAM ");
    if (command[5]==0x01) then i=i+sprintf(s+i,"INIT")
    else if (command[5]==0x02) then i=i+sprintf(s+i,"START ch=%i...",command[6])
    else if (command[5]==0x03) then i=i+sprintf(s+i,"STOP ch=%i",command[6])
    else i=i+sprintf(s+i,"???"); endif
  case S_MOVE:
    i=sprintf(s,"M"); j=5;
    while j<len do
      subcmd=command[j]; j++
      switch subcmd
      case 0x00:
        i=i+sprintf(s+i," NOP")
      case 0x01:
        i=i+sprintf(s+i," F(%i",command[j]); j++
        type=command[j]; j++
        if type==0 || type==1 then
          i=i+sprintf(s+i,",%i:%i,%i:%i",                                      \
            command[j],command[j+1],command[j+2],command[j+3])
          j=j+4
        else if type==2 then
          n=command[j+1]-command[j]+1; if (n<0) n=0
          if (command[j+3]>=command[j+2]) n=n+command[j+3]-command[j+2]+1
          j=j+4
          while n>0 do
            i=i+sprintf(s+i,",%i",command[j])
            j++; n--;
          enddo
        endif
        i=i+sprintf(s+i,")")
      case 0x2,0xE,0x12,0x16,0x18,0x1B,0x1C,0x25,0x2A,0x2C,0x2E,0x45,0x46,     \
        0x48,0x4C,0x4E,0x51:
        if subcmd==0x02 then i=i+sprintf(s+i," R(%i",command[j]);
        else if subcmd==0x0E then i=i+sprintf(s+i," H(%i",command[j]);
        else if subcmd==0x12 then i=i+sprintf(s+i," D(%i",command[j]);
        else if subcmd==0x16 then i=i+sprintf(s+i," L(%i",command[j]);
        else if subcmd==0x18 then i=i+sprintf(s+i," E(%i",command[j]);
        else if subcmd==0x1B then i=i+sprintf(s+i," C(%i",command[j]);
        else if subcmd==0x1C then i=i+sprintf(s+i," E(%i",command[j]);
        else if subcmd==0x25 then
          i=i+sprintf(s+i," A(%i,%i",command[j],command[j+1] & 0x1F);
          if (command[j+1] & 0x80)!=0 i=i+sprintf(s+i,"N")
          if (command[j+1] & 0x40)!=0 i=i+sprintf(s+i,"T")
          if (command[j+1] & 0x20)!=0 i=i+sprintf(s+i,"F")
          j++
        else if subcmd==0x2A then i=i+sprintf(s+i," RL(%i",command[j]);
        else if subcmd==0x2C then i=i+sprintf(s+i," CONTCAP(%i",command[j]);
        else if subcmd==0x2E then
          if (command[j+1] & 0x1F)==0 then
            i=i+sprintf(s+i," CRT(%i",command[j]);
          else
            i=i+sprintf(s+i," CRT(%i,%i",command[j],command[j+1] & 0x1F);
          endif
          j++
        else if subcmd==0x45 then i=i+sprintf(s+i," UI(%i",command[j]);
        else if subcmd==0x46 then i=i+sprintf(s+i," UIEX(%i",command[j]);
        else if subcmd==0x48 then
          i=i+sprintf(s+i," MC(%i,Range=%i",command[j],command[j+1] & 0x1F);
          if (command[j+1] & 0x80)!=0 i=i+sprintf(s+i,",NoShort")
          j++
        else if subcmd==0x4C then i=i+sprintf(s+i," WARM(%i",command[j]);
        else if subcmd==0x4E then i=i+sprintf(s+i," R(%i",command[j]);
        else if subcmd==0x51 then i=i+sprintf(s+i," H(%i",command[j]);
        endif
        j++; n=command[j]; j++
        while n>0 do
          i=i+sprintf(s+i,",%i",command[j])
          j++; n--;
        enddo
        if subcmd==0x1C then
          if ($uint4(command+j) & 0x00FF0000)!=0                               \
            i=i+sprintf(s+i,",DLY=%i",($uint4(command+j)>>16) & 0xFF)
          if ($uint4(command+j) & 0x3000)==0x1000 i=i+sprintf(s+i,",INT")
          if ($uint4(command+j) & 0x3000)==0x2000 i=i+sprintf(s+i,",EXTA")
          if ($uint4(command+j) & 0x3000)==0x3000 i=i+sprintf(s+i,",EXTB")
          if ($uint4(command+j) & 1)!=0 i=i+sprintf(s+i,",FIX")
          if ($uint4(command+j) & 2)!=0 i=i+sprintf(s+i,",HIR")
          if ($uint4(command+j) & 0x0C)==0x04 then
            i=i+sprintf(s+i,",CONS")
          else if ($uint4(command+j) & 0x0C)==0x08 then
            i=i+sprintf(s+i,",CMED")
          else if ($uint4(command+j) & 0x0C)==0x0C then
            i=i+sprintf(s+i,",CSHI")
          endif
          if ($uint4(command+j) & 0x10)!=0 i=i+sprintf(s+i,",FREE")
          if ($uint4(command+j) & 0x20)!=0 i=i+sprintf(s+i,",LONG")
          if ($uint4(command+j) & 0x40)!=0 i=i+sprintf(s+i,",POL")
          j=j+4
          i=i+sprintf(s+i,",PMAX=%g",$uint4(command+j)/1000000.0); j=j+4
          i=i+sprintf(s+i,",IMAX=%g",$uint4(command+j)/1000000.0); j=j+4
          if $uint2(command+j)!=0                                              \
            i=i+sprintf(s+i,",UMAX=%g",$uint2(command+j)/1000.0);
          j=j+2
          if $uint2(command+j)!=0                                              \
            i=i+sprintf(s+i,",RMAX=%g",$uint2(command+j))
          j=j+2
        else if subcmd==0x45 then
          i=i+sprintf(s+i,",UMIN=%g",$float4(command+j)); j=j+4
          i=i+sprintf(s+i,",UMAX=%g",$float4(command+j)); j=j+4
          i=i+sprintf(s+i,",IMIN=%g",$float4(command+j)*1000.0); j=j+4
          i=i+sprintf(s+i,",IMAX=%g",$float4(command+j)*1000.0); j=j+4
          i=i+sprintf(s+i,",N=%i",$uint2(command+j)); j=j+2
          if $uint2(command+j)!=0 i=i+sprintf(s+i,",DELAY=%i",$uint2(command+j))
          j=j+2
          if ($uint2(command+j) & 0x0007)==0x0001 i=i+sprintf(s+i,",DIODE")
          j=j+6
        else if subcmd==0x46 then
          i=i+sprintf(s+i,",UMIN=%g",$float4(command+j)); j=j+4
          i=i+sprintf(s+i,",UMAX=%g",$float4(command+j)); j=j+4
          n=$uint2(command+j);  i=i+sprintf(s+i,",N=%i",n); j=j+2
          if $uint2(command+j)!=0 i=i+sprintf(s+i,",DELAY=%i",$uint2(command+j))
          j=j+2
          if ($uint2(command+j) & 0x0007)==0x0001 i=i+sprintf(s+i,",DIODE")
          j=j+6
          i=i+sprintf(s+i,",I=(")
          while n>0 do
            i=i+sprintf(s+i,"%g,",$float4(command+j)*1000.0); j=j+4
            n--
          enddo
          i=i-1;
          i=i+sprintf(s+i,"))")
        else if subcmd==0x4C then
          k=$uint2(command+j)
          j=j+2
          if $int2(command+j)!=0                                               \
            i=i+sprintf(s+i,",DX=%g",$uint2(command+j)/1000.0)
          j=j+2
          if $int2(command+j)!=0                                               \
            i=i+sprintf(s+i,",DY=%g",$uint2(command+j)/1000.0)
          j=j+2
          if $uint4(command+j)!=0                                              \
            i=i+sprintf(s+i,",DT=%i",$uint4(command+j))
          j=j+4
          if $uint2(command+j)!=0                                              \
            i=i+sprintf(s+i,",TCONT=%i",$uint2(command+j))
          j=j+8
          if (k & 0x0007)==0x0001 i=i+sprintf(s+i,",DIAG")
        else if subcmd==0x4E then
          if ($uint4(command+j) & 0x00FF0000)!=0                               \
            i=i+sprintf(s+i,",DLY=%i",($uint4(command+j)>>16) & 0xFF)
          if ($uint4(command+j) & 0x10)!=0 i=i+sprintf(s+i,",FREE")
          if ($uint4(command+j) & 0x20)!=0 i=i+sprintf(s+i,",LONG")
          if ($uint4(command+j) & 0x100)!=0 i=i+sprintf(s+i,",SIMPLE")
          j=j+4
          j=j+4
          if $uint4(command+j)!=0                                              \
            i=i+sprintf(s+i,",IMAX=%g",$uint4(command+j)/1000000.0)
          j=j+4
          if $uint2(command+j)!=0                                              \
            i=i+sprintf(s+i,",UMAX=%g",$uint2(command+j)/1000.0)
          j=j+2
          if $uint2(command+j)!=0                                              \
            i=i+sprintf(s+i,",RMAX=%g",$uint2(command+j))
          j=j+2
        else if subcmd==0x51 then
          if $uint2(command+j+3)!=0                                            \
            i=i+sprintf(s+i,",RLOW=%i",$uint2(command+j+3))
          if $uint2(command+j+5)!=0                                            \
            i=i+sprintf(s+i,",ULOW=%g",$uint2(command+j+5)/1000.0)
          if $uint2(command+j+21)==0 then
            i=i+sprintf(s+i,",UMAX=%i",$uint2(command+j+7))
            if $uint4(command+j+9)!=0                                          \
              i=i+sprintf(s+i,",RMAX=%i",$uint4(command+j+9))
            if $uint4(command+j+13)!=0                                         \
              i=i+sprintf(s+i,",T=%i",$uint4(command+j+13))
            ;
          else
            i=i+sprintf(s+i,",U1=%i",$uint2(command+j+7))
            if $uint4(command+j+9)!=0                                          \
              i=i+sprintf(s+i,",R1=%i",$uint4(command+j+9))
            if $uint4(command+j+13)!=0                                         \
              i=i+sprintf(s+i,",T1=%i",$uint4(command+j+13))
            i=i+sprintf(s+i,",U2=%i",$uint2(command+j+21))
            if $uint4(command+j+23)!=0                                         \
              i=i+sprintf(s+i,",R2=%i",$uint4(command+j+23))
            if $uint4(command+j+27)!=0                                         \
              i=i+sprintf(s+i,",T2=%i",$uint4(command+j+27))
            if $uint2(command+j+35)!=0                                         \
              i=i+sprintf(s+i,",GAP=%i",$uint2(command+j+35))
            ;
          endif
          if command[j+2]!=0 then
            i=i+sprintf(s+i,",DLY=%i",command[j+2])
          endif
          j=j+37
        endif
        i=i+sprintf(s+i,")")
      case 0x09:
        if command[j+1]==0 && (command[j+7] & 0x70)==0x20 then
          // No reference, Kelvin calibration.
          i=i+sprintf(s+i," CALKELV(%i",command[j]);
          j=j+2
          i=i+sprintf(s+i,",W%i",$uint2(command+j)); j=j+2
          i=i+sprintf(s+i,"D%i",command[j]); j++
          j=j+2
        else if command[j+1]==0 && (command[j+7] & 0x70)==0x30 then
          // No reference, capacity to environment.
          i=i+sprintf(s+i," CALCENV(%i",command[j]);
          j=j+2
          i=i+sprintf(s+i,",W%i",$uint2(command+j)); j=j+2
          i=i+sprintf(s+i,"D%i",command[j]); j++
          j=j+2
        else
          i=i+sprintf(s+i," CAL(%i",command[j]);
          j++; n=command[j]; j++
          while n>0 do
            i=i+sprintf(s+i,",%i",command[j])
            j++; n--;
          enddo
          i=i+sprintf(s+i,",W%i",$uint2(command+j)); j=j+2
          i=i+sprintf(s+i,"D%i",command[j]); j++
          j=j+2
          if (command[j] & 0x70)==0x10 then
            i=i+sprintf(s+i,",C")
          else if (command[j] & 0x70)==0x20 then
            i=i+sprintf(s+i,",K")
          else if (command[j] & 0x70)==0x30 then
            i=i+sprintf(s+i,",G")
          else if (command[j] & 0x70)==0x40 then
            i=i+sprintf(s+i,",H")
          endif
        endif
        if command[j] & 0x08 i=i+sprintf(s+i,",LONG")
        i=i+sprintf(s+i,")")
        j=j+4
      case 0x0D:
        i=i+sprintf(s+i," FIND(%i",command[j]);
        j++; n=command[j]; j++
        while n>0 do
          i=i+sprintf(s+i,",%i",command[j])
          j++; n--;
        enddo
        i=i+sprintf(s+i,",W%i",$uint2(command+j)); j=j+2
        i=i+sprintf(s+i,",D%i",command[j]); j++
        i=i+sprintf(s+i,",M%i",$uint2(command+j)); j=j+2
        if (command[j] & 0x17) i=i+sprintf(s+i,",")
        if (command[j] & 0x01) i=i+sprintf(s+i,"S")
        if (command[j] & 0x02) i=i+sprintf(s+i,"P")
        if (command[j] & 0x04) i=i+sprintf(s+i,"N")
        if (command[j] & 0x70)==0x10 then
          i=i+sprintf(s+i,",C")
        else if (command[j] & 0x70)==0x20 then
          i=i+sprintf(s+i,",K")
        endif
        i=i+sprintf(s+i,")")
        j=j+4
      case 0x17:
        if command[j]==0 then i=i+sprintf(s+i," LB(%i",command[j+1]);
        else i=i+sprintf(s+i," LC(%i",command[j+1]); endif
        j=j+2; n=command[j]; j++
        while n>0 do
          i=i+sprintf(s+i,",%i",command[j])
          j++; n--;
        enddo
        r=$uint2(command+j)/10.0; j=j+2
        if r!=0 i=i+sprintf(s+i,"CAL%g",r)
        r=$uint2(command+j); j=j+2
        if r!=0 i=i+sprintf(s+i,"DLY%g",r)
        r=$uint2(command+j); j=j+2;
        if r!=0 i=i+sprintf(s+i,"THR%g",r)
        j++; if command[j]!=0 i=i+sprintf(s+i,"M0x%X",command[j])
        j++; i=i+sprintf(s+i,")")
      case 0x19:
        i=i+sprintf(s+i," EXT(%i",command[j+1])
        j++; n=command[j]; j++
        while n>0 do
          i=i+sprintf(s+i,",%i",command[j])
          j++; n--;
        enddo
        i=i+sprintf(s+i,",CHAN=%i",command[j] & 0x7); j=j+2
        if command[j]!=0 i=i+sprintf(s+i,",WAIT=%i",command[j])
        j++
        if command[j]==0 && command[j+1]!=0 && command[j+2]==0                 \
          i=i+sprintf(s+i,",EOL=0x%02X",command[j+1])
        j=j+3
        if command[j]!=0 i=i+sprintf(s+i,",END=\"%.3s\"",command+j)
        j=j+3
        if $int2(command+j)!=0 then
          i=i+sprintf(s+i,",CONN=(%X,%X,%X,%X)",$int2(command+j) & 0xF,        \
          ($int2(command+j)>>4) & 0xF,($int2(command+j)>>8) & 0xF,             \
          ($int2(command+j)>>12) & 0xF)
        endif
        j=j+2
        n=$uint2(command+j); j=j+2
        i=i+sprintf(s+i," \"")
        while n>0 do
          if Isprint(command[j]) then
            s[i]=command[j]; i++
          else
            i=i+sprintf(s+i,"\\x%02X",command[j])
          endif
          j++; n--
        enddo
        if j>len then
          i=i+sprintf(s+i,"\" ?Wrong length")
          color=RED
        else
          i=i+sprintf(s+i,"\")")
        endif
      case 0x1F:
        i=i+sprintf(s+i," SHC(%i",command[j]); j++
        if ($int4(command+j) & 1)!=0 i=i+sprintf(s+i,",R")
        if ($int4(command+j) & 2)!=0 i=i+sprintf(s+i,",C")
        if ($int4(command+j) & 4)!=0 i=i+sprintf(s+i,",H")
        if ($int4(command+j) & 0xFFFFFFF8)!=0 i=i+sprintf(s+i,",?")
        j=j+16
        s[i]=')'; i++; s[i]='\0'
      case 0x20:
        i=i+sprintf(s+i," Z(%i)",command[j]); j++
      case 0x26:
        i=i+sprintf(s+i," RT(%i,%i,R%g)",                                      \
          command[j],command[j+1],$float4(command+j+2)/1.0e6)
        j=j+10
      case 0x27:
        i=i+sprintf(s+i," Q(%i,%i,%i,%i%s",                                    \
          command[j],command[j+1],command[j+2],command[j+3],                   \
          (command[j+4] & 0x3)==0x1?",H":"")
        if (command[j+4] & 0x30)==0x10 then
          i=i+sprintf(s+i,",LONG")
        else if (command[j+4] & 0x30)==0x20 then
          i=i+sprintf(s+i,",XL")
        else if (command[j+4] & 0x30)==0x30 then
          i=i+sprintf(s+i,",XXL")
        endif
        if (command[j+4] & 0x0C)==0x04 then
          i=i+sprintf(s+i,",CONS")
        else if (command[j+4] & 0x0C)==0x08 then
          i=i+sprintf(s+i,",CMED")
        else if (command[j+4] & 0x0C)==0x0C then
          i=i+sprintf(s+i,",CHI")
        endif
        if $uint2(command+j+5)!=0                                              \
          i=i+sprintf(s+i,",UMAX=%g",$uint2(command+j+5)/1000.0)
        if command[j+7]!=0                                                     \
          i=i+sprintf(s+i,",DLY=%i",command[j+7])
        i=i+sprintf(s+i,")")
        j=j+9
      case 0x28:
        i=i+sprintf(s+i," %s(%i:%i,%i:%i",                                     \
          $uint4(command+j+2) & 0x200?"ES":"ERT",                              \
          command[j],$uint2(command+j+18),                                     \
          command[j+1],$uint2(command+j+20))
        i=i+sprintf(s+i,",PMAX=%g",$uint4(command+j+6)/1000.0)
        i=i+sprintf(s+i,",IMAX=%g",$uint4(command+j+10)/1000.0)
        if $uint2(command+j+14)!=0                                             \
          i=i+sprintf(s+i,",UMAX=%g",$uint2(command+j+14)/1000.0)
        if $uint2(command+j+16)!=0                                             \
          i=i+sprintf(s+i,",RMAX=%g",$uint2(command+j+16))
        if ($uint4(command+j+2) & 1)!=0 i=i+sprintf(s+i,",FIX")
        if ($uint4(command+j+2) & 2)!=0 i=i+sprintf(s+i,",HIR")
        if ($uint4(command+j+2) & 0x0C)==0x04 then
          i=i+sprintf(s+i,",CONS")
        else if ($uint4(command+j+2) & 0x0C)==0x08 then
          i=i+sprintf(s+i,",CMED")
        else if ($uint4(command+j+2) & 0x0C)==0x0C then
          i=i+sprintf(s+i,",CHI")
        endif
        if ($uint4(command+j+2) & 0x10)!=0 i=i+sprintf(s+i,",FREE")
        if ($uint4(command+j+2) & 0x40)!=0 i=i+sprintf(s+i,",POL")
        if ($uint4(command+j+2) & 0xA0)==0x20 then
          i=i+sprintf(s+i,",LONG")
        else if ($uint4(command+j+2) & 0xA0)==0x80 then
          i=i+sprintf(s+i,",XL")
        else if ($uint4(command+j+2) & 0xA0)==0xA0 then
          i=i+sprintf(s+i,",XXL")
        endif
        if ($uint4(command+j+2) & 0x00FF0000)!=0                               \
          i=i+sprintf(s+i,",DLY=%i",($uint4(command+j+2)>>16) & 0xFF)
        i=i+sprintf(s+i,")")
        j=j+22
      case 0x32:
        i=i+sprintf(s+i," LART(%i:%i,%i:%i",                                   \
          command[j],$uint2(command+j+18),                                     \
          command[j+1],$uint2(command+j+20))
        if command[j+2]!=0                                                     \
          i=i+sprintf(s+i,",DLY=%i",command[j+2])
        i=i+sprintf(s+i,")")
        j=j+22
      case 0x3C:
        i=i+sprintf(s+i," CONTKELV(%i)",command[j])
        j=j+1
      case 0x42:
        i=i+sprintf(s+i," LAMAN");
      case 0x43:
        if command[j]==0 then
          i=i+sprintf(s+i," LAMBASE")
        else if command[j]==1 then
          i=i+sprintf(s+i," LAMCAL")
        else
          i=i+sprintf(s+i," LAMCAL ?Wrong mode")
          color=RED
        endif
        j=j+17
      case 0x44:
        if command[j]==0 then
          i=i+sprintf(s+i," LABASE")
        else if command[j]==1 then
          i=i+sprintf(s+i," LACAL")
        else
          i=i+sprintf(s+i," LACAL MODE=%i",command[j])
        endif
        j++
        i=i+sprintf(s+i,"(%i",command[j]); j++
        n=command[j]; j++
        while n>0 do
          i=i+sprintf(s+i,",%i",command[j]); j++; n--
        enddo
        i=i+sprintf(s+i,")")
        j=j+16
      case 0x49:
        i=i+sprintf(s+i," UC(%i",command[j]);
        j++; n=command[j]; j++
        while n>0 do
          i=i+sprintf(s+i,",%i",command[j])
          j++; n--;
        enddo
        type=$uint2(command+j); j=j+2
        if (type & 0x3000)==0x1000 i=i+sprintf(s+i,",INT")
        if (type & 0x3000)==0x2000 i=i+sprintf(s+i,",EXTA")
        if (type & 0x3000)==0x3000 i=i+sprintf(s+i,",EXTB")
        if (type & 0x001F)!=0 i=i+sprintf(s+i,",RANGE=%i",type & 0x1F)
        if (type & 0x0120)==0x0020 then
          i=i+sprintf(s+i,",CDCONLY")
        else if (type & 0x0120)==0x0100 then
          i=i+sprintf(s+i,",BRIDGE")
        else if (type & 0x0120)==0x0120 then
          i=i+sprintf(s+i,",BRONLY")
        endif
        if (type & 0x0080)!=0 i=i+sprintf(s+i,",N")
        if (type & 0x0200)!=0 i=i+sprintf(s+i,",PAR")
        if (type & 0x0800)!=0 i=i+sprintf(s+i,",FREE")
        if (type & 0x4000)!=0 i=i+sprintf(s+i,",SIMPLE")
        if $uint2(command+j)!=0 then
          i=i+sprintf(s+i,",F=%i",$uint2(command+j))
          if (type & 0x0400)!=0 i=i+sprintf(s+i," KHZ")
        endif
        j=j+2
        if $uint2(command+j)!=0                                                \
          i=i+sprintf(s+i,",U=%g",$uint2(command+j)/1000.0)
        j=j+2
        if $int2(command+j)!=0                                                 \
          i=i+sprintf(s+i,",OFFS=%g",$int2(command+j)/1000.0)
        j=j+2
        if command[j]!=0                                                       \
          i=i+sprintf(s+i,",DLY=%i",command[j])
        j++
        if (command[j] & 0x03)==0x01 then
          i=i+sprintf(s+i,",LONG")
        else if (command[j] & 0x03)==0x02 then
          i=i+sprintf(s+i,",XL")
        else if (command[j] & 0x03)==0x03 then
          i=i+sprintf(s+i,",XXL")
        endif
        j=j+3
        i=i+sprintf(s+i,")")
      case 0x4A:
        i=i+sprintf(s+i," DIV(%i",command[j])
        j++; n=command[j]; j++
        while n>0 do
          i=i+sprintf(s+i,",%i",command[j])
          j++; n--;
        enddo
        if ($uint2(command+j) & 0x0001)!=0                                     \
          i=i+sprintf(s+i,",ABS")
        if ($uint2(command+j) & 0x0002)!=0                                     \
          i=i+sprintf(s+i,",PAR")
        if command[j+1]!=0                                                     \
          i=i+sprintf(s+i,",DLY=%i",command[j+1])
        j=j+2
        if $float4(command+j)!=0.0                                             \
          i=i+sprintf(s+i,",IMAX=%g",$float4(command+j)*1000.0)
        j=j+4
        if $float4(command+j)!=0.0                                             \
          i=i+sprintf(s+i,",UMAX=%g",$float4(command+j))
        j=j+8
        i=i+sprintf(s+i,")")
      case 0x4B:
        if ($uint2(command+j) & 0x0001)!=0 then
          i=i+sprintf(s+i," COMPX(")
        else
          i=i+sprintf(s+i," COMP(")
        endif
        j=j+2; n=$uint2(command+j); j=j+2
        if j+n>len then
          i=i+sprintf(s+i," ?Wrong length")
          color=RED
          j=len
        else
          k=0; first=1
          while k<n do
            if first==0 i=i+sprintf(s+i," ")
            switch command[j+k]
            case 0x01:
              i=i+sprintf(s+i,"I(%i,I=%g",                                     \
                command[j+k+1],$float4(command+j+k+2))
              if $int4(command+j+k+6)!=0 i=i+sprintf(s+i,",UMAX=%g",           \
                $float4(command+j+k+6))
              i=i+sprintf(s+i,")")
              k=k+10
            case 0x02:
              i=i+sprintf(s+i,"U(%i,U=%g",                                     \
                command[j+k+1],$float4(command+j+k+2))
              if $int4(command+j+k+6)!=0 i=i+sprintf(s+i,",IMAX=%g",           \
                $float4(command+j+k+6))
              if $int4(command+j+k+10)!=0 i=i+sprintf(s+i,",R=%g",             \
                $float4(command+j+k+10))
              i=i+sprintf(s+i,")")
              k=k+14
            case 0x03:
              i=i+sprintf(s+i,"IAC(%i,I=%g",                                   \
                command[j+k+1],$float4(command+j+k+2))
              if $int4(command+j+k+6)!=0 i=i+sprintf(s+i,",UMAX=%g",           \
                $float4(command+j+k+6))
              if $int4(command+j+k+10)!=0 i=i+sprintf(s+i,",OFFS=%g",          \
                $float4(command+j+k+10))
              i=i+sprintf(s+i,",F=%g)",$float4(command+j+k+14))
              k=k+18
            case 0x04:
              i=i+sprintf(s+i,"UAC(%i,U=%g",                                   \
                command[j+k+1],$float4(command+j+k+2))
              if $int4(command+j+k+6)!=0 i=i+sprintf(s+i,",IMAX=%g",           \
                $float4(command+j+k+6))
              if $int4(command+j+k+10)!=0 i=i+sprintf(s+i,",R=%g",             \
                $float4(command+j+k+10))
              if $int4(command+j+k+14)!=0 i=i+sprintf(s+i,",OFFS=%g",          \
                $float4(command+j+k+14))
              i=i+sprintf(s+i,",F=%g)",$float4(command+j+k+18))
              k=k+22
            case 0x08:
              i=i+sprintf(s+i,"HV(%i,U=%g",                                    \
                command[j+k+1],$float4(command+j+k+2))
              if $int4(command+j+k+6)!=0 i=i+sprintf(s+i,",IMAX=%g",           \
                $float4(command+j+k+6))
              if $int2(command+j+k+10)!=0 i=i+sprintf(s+i,",DLY=%i",           \
                $int2(command+j+k+10))
              i=i+sprintf(s+i,")")
              k=k+12
            case 0x0B:
              i=i+sprintf(s+i,"GNDI(%i)",command[j+k+1])
              k=k+2
            case 0x0C:
              i=i+sprintf(s+i,"GND(%i)",command[j+k+1])
              k=k+2
            case 0x0D:
              i=i+sprintf(s+i,"RGND(%i,R=%g)",command[j+k+1],                  \
                $float4(command+j+k+2))
              k=k+6
            case 0x0E:
              i=i+sprintf(s+i,"SHORT(%i,%i)",command[j+k+1],command[j+k+2])
              k=k+3
            case 0x0F:
              i=i+sprintf(s+i,"SET(%i,%g)",command[j+k+1],                     \
                $float4(command+j+k+2))
              k=k+6
            case 0x10:
              i=i+sprintf(s+i,"DLY(%i)",$uint2(command+j+k+1))
              k=k+3
            case 0x11,0x13,0x15:
              if command[j+k]==0x11 then
                i=i+sprintf(s+i,"MI(")
              else if command[j+k]==0x13 then
                i=i+sprintf(s+i,"MIAC(")
              else
                i=i+sprintf(s+i,"MIPH(")
              endif
              i=i+sprintf(s+i,"%i",command[j+k+1])
              if $int4(command+j+k+2)!=0 i=i+sprintf(s+i,",IMAX=%g",           \
                $float4(command+j+k+2))
              i=i+sprintf(s+i,")")
              k=k+6
            case 0x12,0x14,0x16,0x17,0x18,0x19:
              if command[j+k]==0x12 then
                i=i+sprintf(s+i,"MU(")
              else if command[j+k]==0x14 then
                i=i+sprintf(s+i,"MUAC(")
              else if command[j+k]==0x16 then
                i=i+sprintf(s+i,"MUPH(")
              else if command[j+k]==0x17 then
                i=i+sprintf(s+i,"MUDIFF(")
              else if command[j+k]==0x18 then
                i=i+sprintf(s+i,"MUACD(")
              else
                i=i+sprintf(s+i,"MUPHD(")
              endif
              if command[j+k+1]==0xFF then
                i=i+sprintf(s+i,"GND")
              else
                i=i+sprintf(s+i,"%i",command[j+k+1])
              endif
              if command[j+k+2]==0xFF then
                i=i+sprintf(s+i,",GND)")
              else
                i=i+sprintf(s+i,",%i)",command[j+k+2])
              endif
              k=k+3
            case 0x1A:
              i=i+sprintf(s+i,"HVI")
              k++
            case 0x1B:
              i=i+sprintf(s+i,"HVU")
              k++
            case 0x1F:
              i=i+sprintf(s+i,"ASSERT(MIN=%g,MAX=%g)",                         \
                $float4(command+j+k+1),$float4(command+j+k+5))
              k=k+9
            case 0x20:
              i=i+sprintf(s+i,"RESET")
              k++
            case 0x22:
              i=i+sprintf(s+i,"R(%i,%i",command[j+k+1],command[j+k+2])
              if $int4(command+j+k+3)!=0 i=i+sprintf(s+i,",UMAX=%g",           \
                $float4(command+j+k+3))
              if $int4(command+j+k+7)!=0 i=i+sprintf(s+i,",IMAX=%g",           \
                $float4(command+j+k+7))
              i=i+sprintf(s+i,")")
              k=k+11
            case 0x23:
              i=i+sprintf(s+i,"QUAD(%i,%i,%i,%i",                              \
                command[j+k+1],command[j+k+2],command[j+k+3],command[j+k+4])
              if $int4(command+j+k+5)!=0 i=i+sprintf(s+i,",UMAX=%g",           \
                $float4(command+j+k+5))
              if $int4(command+j+k+9)!=0 i=i+sprintf(s+i,",IMAX=%g",           \
                $float4(command+j+k+9))
              i=i+sprintf(s+i,")")
              k=k+13
            case 0x24:
              i=i+sprintf(s+i,"C(%i,%i",command[j+k+1],command[j+k+2])
              if $int4(command+j+k+3)!=0 i=i+sprintf(s+i,",UMAX=%g",           \
                $float4(command+j+k+3))
              if $int4(command+j+k+7)!=0 i=i+sprintf(s+i,",OFFS=%g",           \
                $float4(command+j+k+7))
              if $int4(command+j+k+11)!=0 i=i+sprintf(s+i,",F=%g",             \
                $float4(command+j+k+11))
              i=i+sprintf(s+i,")")
              k=k+15
            case 0x25,0x26,0x27:
              if command[j+k]==0x25 then
                i=i+sprintf(s+i,"HVLEAK")
              else if command[j+k]==0x26 then
                i=i+sprintf(s+i,"HVVAR")
              else
                i=i+sprintf(s+i,"HVR")
              endif
              i=i+sprintf(s+i,"(%i,%i",command[j+k+1],command[j+k+2])
              if $int4(command+j+k+3)!=0 i=i+sprintf(s+i,",U=%g",              \
                $float4(command+j+k+3))
              if $int2(command+j+k+7)!=0 i=i+sprintf(s+i,",DLY=%i",            \
                $int2(command+j+k+7))
              i=i+sprintf(s+i,")")
              k=k+13
            case 0x28:
              i=i+sprintf(s+i,"R(%i,%i",command[j+k+1],command[j+k+2])
              if command[j+k+3]!=0xFF i=i+sprintf(s+i,",%i",command[j+k+3])
              if command[j+k+4]!=0xFF i=i+sprintf(s+i,",%i",command[j+k+4])
              if $int4(command+j+k+5)!=0 i=i+sprintf(s+i,",UMAX=%g",           \
                $float4(command+j+k+5))
              if $int4(command+j+k+9)!=0 i=i+sprintf(s+i,",IMAX=%g",           \
                $float4(command+j+k+9))
              i=i+sprintf(s+i,")")
              k=k+13
            case 0x29:
              i=i+sprintf(s+i,"C(%i,%i",command[j+k+1],command[j+k+2])
              if command[j+k+3]!=0xFF i=i+sprintf(s+i,",%i",command[j+k+3])
              if command[j+k+4]!=0xFF i=i+sprintf(s+i,",%i",command[j+k+4])
              if $int4(command+j+k+5)!=0 i=i+sprintf(s+i,",UMAX=%g",           \
                $float4(command+j+k+5))
              if $int4(command+j+k+9)!=0 i=i+sprintf(s+i,",OFFS=%g",           \
                $float4(command+j+k+9))
              if $int4(command+j+k+13)!=0 i=i+sprintf(s+i,",F=%g",             \
                $float4(command+j+k+13))
              i=i+sprintf(s+i,")")
              k=k+17
            case 0x30:
              i=i+sprintf(s+i,"BD(%i,%i",command[j+k+1],command[j+k+2])
              if command[j+k+3]!=0xFF i=i+sprintf(s+i,",%i",command[j+k+3])
              if $int4(command+j+k+4)!=0 i=i+sprintf(s+i,",UMAX=%g",           \
                $float4(command+j+k+4))
              if $int4(command+j+k+8)!=0 i=i+sprintf(s+i,",F=%g",              \
                $float4(command+j+k+8))
              if (command[j+k+12] & 0x03)==0x01 then
                i=i+sprintf(s+i,",LONG")
              else if (command[j+k+12] & 0x03)==0x02 then
                i=i+sprintf(s+i,",XL")
              else if (command[j+k+12] & 0x03)==0x03 then
                i=i+sprintf(s+i,",XXL")
              endif
              i=i+sprintf(s+i,")")
              k=k+13
            case 0x31:
              i=i+sprintf(s+i,"BZ(%i",command[j+k+1])
              i=i+sprintf(s+i,",Z=%g",$int2(command+j+k+2)/1000.0)
              i=i+sprintf(s+i,",ZMIN=%g)",$int2(command+j+k+4)/1000.0)
              k=k+6
            case 0x32:
              i=i+sprintf(s+i,"BC(%i",command[j+k+1])
              i=i+sprintf(s+i,",Z=%g)",$int2(command+j+k+2)/1000.0)
              k=k+4
            case 0x33:
              i=i+sprintf(s+i,"BT(%i,%i)",command[j+k+1],command[j+k+2])
              k=k+3
            case 0x81:
              i=i+sprintf(s+i,"MOVE(%i",command[j+k+1])
              i=i+sprintf(s+i,",X=%g",$int3(command+j+k+2)/1000.0)
              if $int2(command+j+k+10)!=0                                      \
                i=i+sprintf(s+i,"%+g",$int2(command+j+k+10)/1000.0)
              i=i+sprintf(s+i,",Y=%g",$int3(command+j+k+5)/1000.0)
              if $int2(command+j+k+12)!=0                                      \
                i=i+sprintf(s+i,"%+g",$int2(command+j+k+12)/1000.0)
              if $uint2(command+j+k+8)!=0 i=i+sprintf(s+i,",R=%.3f",           \
                $uint2(command+j+k+8)/1000.0)
              i=i+sprintf(s+i,")")
              k=k+14
            case 0x82:
              i=i+sprintf(s+i,"UP(%i)",command[j+k+1])
              k=k+2
            case 0x83:
              i=i+sprintf(s+i,"DOWN(%i)",command[j+k+1])
              k=k+2
            default:
              i=i+sprintf(s+i," ?Unknown measurement %02X",command[j+k])
              color=RED
              k=n
            endsw
            first=0
          enddo
          i=i+sprintf(s+i,")")
          j=j+n
        endif
      case 0x4F:
        i=i+sprintf(s+i," %s(%i:%i,%i:%i",                                     \
          $uint4(command+j+2) & 0x200?"RS":"RTL",                              \
          command[j],$uint2(command+j+18),                                     \
          command[j+1],$uint2(command+j+20))
        i=i+sprintf(s+i,",IMAX=%g",$uint4(command+j+10)/1000.0)
        if $uint2(command+j+14)!=0                                             \
          i=i+sprintf(s+i,",UMAX=%g",$uint2(command+j+14)/1000.0)
        if $uint2(command+j+16)!=0                                             \
          i=i+sprintf(s+i,",RMAX=%g",$uint2(command+j+16))
        if ($uint4(command+j+2) & 0x10)!=0 i=i+sprintf(s+i,",FREE")
        if ($uint4(command+j+2) & 0x20)!=0 i=i+sprintf(s+i,",LONG")
        if ($uint4(command+j+2) & 0x00FF0000)!=0                               \
          i=i+sprintf(s+i,",DLY=%i",($uint4(command+j+2)>>16) & 0xFF)
        i=i+sprintf(s+i,")")
        j=j+22
      case 0x50:
        n=command[j+1];
        if command[j+n+2]==0 then
          i=i+sprintf(s+i," LREF(")
        else if command[j+n+2]==1 then
          i=i+sprintf(s+i," LMEAS(")
        else
          i=i+sprintf(s+i," L%i(",command[j+n+2])
        endif
        i=i+sprintf(s+i,"%i",command[j])
        j=j+2
        while n>0 do
          i=i+sprintf(s+i,",%i",command[j])
          j++; n--;
        enddo
        j++
        type=$uint2(command+j); j=j+2
        if (type & 0xC000)==0x4000 i=i+sprintf(s+i,",INT")
        if (type & 0xC000)==0x8000 i=i+sprintf(s+i,",EXTA")
        if (type & 0xC000)==0xC000 i=i+sprintf(s+i,",EXTB")
        if type & 0x0100 i=i+sprintf(s+i,",HICURR")
        if (type & 0x70)!=0 i=i+sprintf(s+i,",G=%i",(type>>4)&7)
        if (type & 3)==1 i=i+sprintf(s+i,",FAST")
        if (type & 3)==2 i=i+sprintf(s+i,",MEDIUM")
        if (type & 3)==3 i=i+sprintf(s+i,",LONG")
        if $uint4(command+j) i=i+sprintf(s+i,",F=%i",$uint4(command+j))
        j=j+4
        if $uint4(command+j) i=i+sprintf(s+i,",U=%g",$uint4(command+j)/1000.0)
        j=j+4
        if command[j]!=0 i=i+sprintf(s+i,",DLY=%i",command[j])
        j=j+8
        i=i+sprintf(s+i,")")
      case 0x80:
        i=i+sprintf(s+i," %i(SAME)",command[j]); j++
      case 0x81,0x89,0x91,0x99,0xC1,0xC9,0xD1,0xD9:
        if (subcmd & 0x40)==0 then i=i+sprintf(s+i," %i(",command[j]);
        else i=i+sprintf(s+i," %i[",command[j]); endif;
        i=i+sprintf(s+i,"%g",$int3(command+j+4)/1000.0)
        if (subcmd & 0x08)!=0 then
          r=$int2(command+j+15)/1000.0
          i=i+sprintf(s+i,"%c%g",(r<0?'-':'+'),Abs(r))
        endif
        i=i+sprintf(s+i,",%g",$int3(command+j+7)/1000.0)
        if (subcmd & 0x08)!=0 then
          r=$int2(command+j+17)/1000.0
          i=i+sprintf(s+i,"%c%g",(r<0?'-':'+'),Abs(r))
        endif
        r=$uint2(command+j+10)/1000.0
        if r!=0 i=i+sprintf(s+i,",%g",r)
        i=i+sprintf(s+i,",A%iV%iP%i",command[j+12],command[j+13],command[j+14])
        i=i+sprintf(s+i,"H%g",$uint2(command+j+1)/1000.0);
        if (subcmd & 0x10)!=0 then
          if (subcmd & 0x08)==0 then r=$int2(command+j+15);
          else r=$int2(command+j+19); endif
          i=i+sprintf(s+i,"Z%g",r/1000.0);
        endif
        if (subcmd & 0x40)==0 then i=i+sprintf(s+i,")");
        else i=i+sprintf(s+i,"]"); endif;
        j=j+15
        if (subcmd & 0x08)!=0 j=j+4
        if (subcmd & 0x10)!=0 j=j+2
      case 0x82:
        i=i+sprintf(s+i," UP(%i)",command[j]); j++
      case 0x83:
        i=i+sprintf(s+i," DN(%i)",command[j]); j++
      case 0x84:
        i=i+sprintf(s+i," GND(%i)",command[j]); j++
      case 0x85:                       // M_SAFEMASK is no longer supported!
        i=i+sprintf(s+i," SAFE(0x%X)",$uint4(command+j)); j=j+4
      case 0x86:
        i=i+sprintf(s+i," %i(Z)",command[j]); j++
      case 0x87:
        i=i+sprintf(s+i," GROUP(%i,%i)",                                       \
        $uint2(command+j),$uint2(command+j+2)); j=j+4;
      case 0x88:
        i=i+sprintf(s+i," SHIELD(%i)",command[j]); j++
      case 0x8C,0xCC:
        if (subcmd & 0x40)==0 then i=i+sprintf(s+i," %i:(",command[j]);
        else i=i+sprintf(s+i," %i:[",command[j]); endif;
        i=i+sprintf(s+i,"%.8g",$int4(command+j+4)/256000.0)
        r=$int4(command+j+20)/256000.0
        if r!=0.0 then
          i=i+sprintf(s+i,"%c%.7g",(r<0?'-':'+'),Abs(r))
        endif
        i=i+sprintf(s+i,",%.8g",$int4(command+j+8)/256000.0)
        r=$int4(command+j+24)/256000.0
        if r!=0.0 then
          i=i+sprintf(s+i,"%c%.7g",(r<0?'-':'+'),Abs(r))
        endif
        r=$uint4(command+j+12)/256000.0
        if r!=0 i=i+sprintf(s+i,",%.7g",r)
        i=i+sprintf(s+i,",A%.4g",$uint2(command+j+16)/256.0)
        i=i+sprintf(s+i,"V%iP%i",command[j+18],command[j+19])
        i=i+sprintf(s+i,"H%g",$uint2(command+j+1)/1000.0);
        if (command[j+3] & 0x03)==0x01 then
          i=i+sprintf(s+i,"Q%g",$uint2(command+j+28)/1000.0)
        else
          r=$int2(command+j+28)
          if r!=0 i=i+sprintf(s+i,"Z%g",r/1000.0)
        endif
        if (subcmd & 0x40)==0 then i=i+sprintf(s+i,")")
        else i=i+sprintf(s+i,"]"); endif;
        j=j+32
      case 0x90:
        i=i+sprintf(s+i," %i(PARK)",command[j]); j++
      case 0x92:                       // Encoder movement
        i=i+sprintf(s+i," #%i[",command[j])
        i=i+sprintf(s+i,"%g",$int3(command+j+4)/1000.0)
        i=i+sprintf(s+i,",%g",$int3(command+j+7)/1000.0)
        r=$uint2(command+j+10)/1000.0
        if r!=0 i=i+sprintf(s+i,",%g",r)
        i=i+sprintf(s+i,",A%iV%iP%i",command[j+12],command[j+13],command[j+14])
        i=i+sprintf(s+i,"H%g",$uint2(command+j+1)/1000.0)
        i=i+sprintf(s+i,"]")
        j=j+15
      case 0x93:                       // Warmup pad
        i=i+sprintf(s+i," %i(WARM",command[j])
        i=i+sprintf(s+i,",A%iV%iP%i",command[j+3],command[j+4],command[j+5])
        i=i+sprintf(s+i,"H%g)",$uint2(command+j+1)/1000.0);
        j=j+8
      case 0x97:
        i=i+sprintf(s+i," GROUP(%i,%i,%i)",                                    \
        $uint2(command+j),$uint2(command+j+2),$uint3(command+j+4)); j=j+7;
      case 0x9B:
        i=i+sprintf(s+i," SH(%i)",command[j]); j++
      case 0x9C:
        i=i+sprintf(s+i," SHY(%.8g)",$int4(command+j)/256000.0); j=j+6;
      case 0xA7:
        i=i+sprintf(s+i," NETS(%i,%i",$uint2(command+j),$uint2(command+j+2))
        j=j+4
        n=command[j]
        j++
        while n>0 do
          i=i+sprintf(s+i,",%i:%i",command[j+3] & 0x3F,$uint3(command+j))
          j=j+4; n--
        enddo
        i=i+sprintf(s+i,")")
      case 0xAC:
        i=i+sprintf(s+i," BCY(%.8g)",$int4(command+j)/256000.0); j=j+6;
      case 0xC2:
        i=i+sprintf(s+i," MASTER");
      case 0xC3:
        i=i+sprintf(s+i," SLAVE");
      case 0xC7:
        i=i+sprintf(s+i," PADS(")
        n=command[j]
        j++; first=1
        while n>0 do
          if first==0 i=i+sprintf(s+i,",")
          i=i+sprintf(s+i,"%i:%i",command[j+3] & 0x3F,$uint3(command+j))
          j=j+4; n--
          first=0
        enddo
        i=i+sprintf(s+i,")")
      case 0xCA:                       // Headcam movement
        i=i+sprintf(s+i," @%i[",command[j]);
        i=i+sprintf(s+i,"%g",$int3(command+j+4)/1000.0)
        r=$int2(command+j+15)/1000.0
        if r!=0 i=i+sprintf(s+i,"%c%g",(r<0?'-':'+'),Abs(r))
        i=i+sprintf(s+i,",%g",$int3(command+j+7)/1000.0)
        r=$int2(command+j+17)/1000.0
        if r!=0 i=i+sprintf(s+i,"%c%g",(r<0?'-':'+'),Abs(r))
        r=$uint2(command+j+10)/1000.0
        if r!=0 i=i+sprintf(s+i,",%g",r)
        i=i+sprintf(s+i,",A%iV%iP%i",command[j+12],command[j+13],command[j+14])
        i=i+sprintf(s+i,"H%g",$uint2(command+j+1)/1000.0);
        i=i+sprintf(s+i,"]")
        j=j+19
      case 0xCB:                       // Headcam movement, nanometer accuracy
        i=i+sprintf(s+i," @%i:[",command[j]);
        i=i+sprintf(s+i,"%.8g",$int4(command+j+2)/256000.0)
        r=$int4(command+j+12)/256000.0
        if r!=0.0 i=i+sprintf(s+i,"%c%.7g",(r<0?'-':'+'),Abs(r))
        i=i+sprintf(s+i,",%.8g",$int4(command+j+6)/256000.0)
        r=$int4(command+j+16)/256000.0
        if r!=0.0 i=i+sprintf(s+i,"%c%.7g",(r<0?'-':'+'),Abs(r))
        i=i+sprintf(s+i,",A%.4g",$uint2(command+j+10)/256.0)
        i=i+sprintf(s+i,"]")
        j=j+28
      case 0xE2:                       // Retest if value is higher than limit
        i=i+sprintf(s+i," ASSERT(<%g)",$float4(command+j))
        j=j+4
      case 0xE3:                       // Retest if value is lower than limit
        i=i+sprintf(s+i," ASSERT(>%g)",$float4(command+j))
        j=j+4
      case 0xE4:                       // Postcalibrate capacity in the air
        i=i+sprintf(s+i," CAIR")
      case 0xE5:                       // Lights must be turned off
        i=i+sprintf(s+i," DARK")
      case 0xE6:                       // Average
        i=i+sprintf(s+i," AVERAGE(%i)",command[j])
        j++
      case 0xE7:                       // Median
        i=i+sprintf(s+i," MEDIAN(%i)",command[j])
        j++
      case 0xE8:                       // Keep order of measurements
        i=i+sprintf(s+i," KEEPORDER")
      default:
        i=i+sprintf(s+i," ?Wrong subcommand 0x%X",subcmd)
        j=len;
      endsw
    enddo
    if j>len then
      i=i+sprintf(s+i," ?Wrong length")
      color=RED
    endif
  default:
    sprintf(s,"Unrecognized command 0x%X",cmd)
  endsw
  return color
end

// Service function, extracts (language-specific) error field n from errmsg
// into text. Returns Strlen(text), or 0 on error.
function int Geterrorword(int n,char *text)
  int i=0,j,c
  while n>0 do
    while errmsg[i]!=' ' && errmsg[i]!='\t' do
      if errmsg[i]=='\n' || errmsg[i]=='\r' then
        text[0]='\0'; return 0         // Too high index of error field
      endif
      i++
    enddo
    while errmsg[i]==' ' || errmsg[i]=='\t' do i++; enddo
    n--
  enddo
  for j=0,1,j++ do
    c=errmsg[i]
    if c==' ' || c=='\t' || c=='\n' || c=='\r' break
    text[j]=c
    i++
  enddo
  text[j]='\0'; return j
end

// Converts raw error message received from the tester into the text line s.
// Additional explanations, if available, are placed into the array extra. Lines
// in this array are separated by symbols '\n', end of explanations is marked
// by byte '\0'. First symbol means color: '+' - red, '-' - gray, any other is
// for black. Returns number of bytes written into array extra.
function int Decodeerror(char *answer,char *s,char *extra)
  int i,j,k,n,c,d,ne,code,extended,subcmd,suberr
  char tmp[5]
  extended=0                           // No data to be extended
  ne=0                                 // Number of bytes in extra message
  if $uint2(answer)>=20 then
    if ($uint2(answer+18) & 0xE000)==0xE000 then
      j=sprintf(s,"%04i ",$uint2(answer+18) & 0x1FFF)
    endif
  else
    j=Geterrorword(1,s)                // "ERROR "
    s[j]=' '; j++   
  endif
  subcmd=answer[5]; suberr=answer[9];
  i=0                                  // Offset in errmsg
  while 1 do
    while errmsg[i]!='\n' do i++; enddo
    i++; if errmsg[i]=='\r' i++        // Skip CRLF
    c=errmsg[i]; i++
    if c=='?' then
      break                            // No match, report unknown error
    else if c=='&' then
      continue                         // Extention of previous error, skip
    else
      d=errmsg[i]; i++
      code=(c<='9'?c-'0':c-'A'+10)*16+(d<='9'?d-'0':d-'A'+10)
      if code!=subcmd continue         // Wrong error, skip
      if errmsg[i]!='.' break          // Message found, report it
      c=errmsg[i+1]; d=errmsg[i+2]; i=i+3
      code=(c<='9'?c-'0':c-'A'+10)*16+(d<='9'?d-'0':d-'A'+10)
      if code==suberr break            // Message found, report it
    endif
  enddo
  while errmsg[i]==' ' do i++; enddo   // Skip spaces
  while 1 do
    c=errmsg[i]; i++
    if c=='\n' || c=='\r' then         // End of message
      break
    else if c=='%' then                // Format
      c=errmsg[i]; i++
      switch c
      case 'E':                        // Subcommand as hexadecimal
        j=j+sprintf(s+j,"0x%X",subcmd)
      case 'f':                        // List of available fingers
        d=$long(answer+10)
        for n=0,n<16,n++
          if (d & 3)!=0 then
            if n==15 && $GLOBAL.a5!=0 then
              s[j]='M'; j++
            else
              s[j]=(n<10?'0'+n:'A'-10+n); j++
              if (d & 3)==1 then
                s[j]='L'; j++
              else if (d & 3)==2 then
                s[j]='R'; j++
              endif
            endif
          endif
          d=d>>2
        enddo
      case 'F':                        // List of fingers in layout
        d=$long(answer+14)
        for n=0,n<16,n++
          if (d & 3)!=0 then
            if n==15 && $GLOBAL.a5!=0 then
              s[j]='M'; j++
            else
              s[j]=(n<10?'0'+n:'A'-10+n); j++
              if (d & 3)==1 then
                s[j]='L'; j++
              else if (d & 3)==2 then
                s[j]='R'; j++
              endif
            endif
          endif
          d=d>>2
        enddo
      case 'i':                        // First short as integer
        j=j+sprintf(s+j,"%i",$int2(answer+10))
      case 'j':                        // Second short as integer
        j=j+sprintf(s+j,"%i",$int2(answer+12))
      case 'k':                        // Thirs short as integer
        j=j+sprintf(s+j,"%i",$int2(answer+14))
      case 'l':                        // First long as integer
        j=j+sprintf(s+j,"%i",$int4(answer+10))
      case 'L':                        // First long as hexadecimal
        j=j+sprintf(s+j,"0x%X",$uint4(answer+10))
      case 'M':                        // DC initialization error
        if (answer[14]==0) then
          j=j+sprintf(s+j,"ADC overloaded")
        else if (answer[14]==1) then
          j=j+sprintf(s+j,"signal %i, expecting %i bits",                      \
          $int2(answer+10),$int2(answer+12))
        else if (answer[14]==2) then
          j=j+sprintf(s+j,"unstable signal (rise %i, max %i)",                 \
          $int2(answer+10),$int2(answer+12))
        else if (answer[14]==3) then
          j=j+sprintf(s+j,"noise %i, allowed %i bits",                         \
          $int2(answer+10),$int2(answer+12))
        else if (answer[14]==4) then
          j=j+sprintf(s+j,"unreproducible (diff %i, allowed %i bits)",         \
          $int2(answer+10),$int2(answer+12))
        else
          j=j+sprintf(s+j,"suberror %i (%i:%i bits)",answer[14],               \
          $int2(answer+10),$int2(answer+12))
        endif
      case 'p':                        // Optional encoder coordinate
        if $int4(answer+14)!=0 then
          j=j+sprintf(s+j,", Enc=%i",$int4(answer+14))
        endif
      case 'P':                        // Velocity, mm/s
        j=j+sprintf(s+j,"%.1f",$int2(answer+10)/6.4)
      case 'R':                        // Relays, if necessary
        if ($uint2(answer+10) & 0xFF00) then
          s[j]=' '; j++
          s[j]='('; j++
          while Isalpha(errmsg[i]) do
            s[j]=errmsg[i]; j++; i++
          enddo
          j=j+sprintf(s+j," 0x%X)",$uint2(answer+12))
        endif
        while Isalpha(errmsg[i]) do i++; enddo
      case 's':                        // Suberror
        j=j+sprintf(s+j,"%i",suberr)
      case 'S':                        // Suberror as hexadecimal
        extended=suberr
        j=j+sprintf(s+j,"0x%X",suberr)
      case 't':                        // Temperature, degrees
        j=j+sprintf(s+j,"%.1f C",$int2(answer+10)/10.0)
      case 'u':                        // First short as unsigned
        j=j+sprintf(s+j,"%u",$uint2(answer+10))
      case 'v':                        // Version of head controller software
        j=j+sprintf(s+j,"%i.%1i",suberr/10,suberr%10)
      case 'V':                        // Requested head controller software
        j=j+sprintf(s+j,"%i.%1i",answer[10]/10,answer[10]%10)
      case 'X':                        // First short as hexadecimal
        extended=$uint2(answer+10)
        j=j+sprintf(s+j,"0x%X",extended)
      case 'y':                        // First byte as hexadecimal
        j=j+sprintf(s+j,"0x%X",answer[10])
      case 'Y':                        // Second byte as hexadecimal
        j=j+sprintf(s+j,"0x%X",answer[11])
      default:                         // Unknown format
        s[j]='?'; j++
      endsw
    else
      s[j]=c; j++                      // Ordinary character - simply copy
    endif
  enddo
  while 1 do                           // Fetch extra explanations, if any
    while errmsg[i]!='\n' do i++; enddo
    i++; if errmsg[i]=='\r' i++        // Skip CRLF
    if errmsg[i]!='&' break            // No (more) extra details
    code=-1;
    Memcpy(tmp,errmsg+i+1,4); tmp[4]='\0'
    sscanf(tmp,"%04X",&code)
    if code==(-1) break                // Unable to read feature code
    if (extended & code)==0 continue   // Feature unavailable
    i=i+5; while errmsg[i]==' ' do i++; enddo
    extra[ne]='+'; ne++
    while errmsg[i]!='\n' && errmsg[i]!='\r' do
      extra[ne]=errmsg[i]; ne++; i++
    enddo
    extra[ne]='\n'; ne++
  enddo
  if ne>0 ne--                         // Remove last '\n'
  extra[ne]=0                          // Mark end of explanations
  // Coordinates in the error are optional.
  if $uint2(answer)>=36 then                                                   \
    j=j+sprintf(s+j," X=%.3f,Y=%.3f",                                          \
      $int4(answer+20)/1000.0,$int4(answer+24)/1000.0)
    if $int4(answer+28)!=0 then
      j=j+sprintf(s+j,",Z=%i,Zexp=%i",$uint2(answer+28),$uint2(answer+30))
    endif
  endif
  k=answer[6]
  s[j]=' '; j++
  j=j+Geterrorword((k & 0x01)==0?2:3,s+j)
  s[j]=','; j++                        // "Rec," or "Unrec,"
  j=j+Geterrorword((k & 0x02)==0?4:5,s+j)
  s[j]=','; j++                        // "soft," or "hard,"
  if (k & 0x04) then
    j=j+Geterrorword(6,s+j)            // "crate"
  else if (k & 0x08) then
    j=j+Geterrorword(7,s+j)            // "slave"
  else if (k & 0x10) then
    j=j+Geterrorword(8,s+j)            // "meas"
    if answer[8] & 0x80 then
      j=j+sprintf(s+j," 1")
    else if answer[8] & 0x20 then
      j=j+sprintf(s+j," 2")
    endif
  else if (k & 0x20) then
    j=j+Geterrorword(9,s+j)            // "AFMCU"
  else if (k & 0x80) then
    j=j+Geterrorword(10,s+j)           // "general"
  else if $uint2(answer)>8 && answer[7]==0x10 then
    j=j+Geterrorword(14,s+j)           // "extant"
    if $uint2(answer)>=10 && answer[8]!=0 then
      k=answer[8]
      if (k & 0x33)!=0 && (k & 0xCC)==0 then
        j=j+sprintf(s+j," 0")
      else if (k & 0x33)==0 && (k & 0xCC)!=0 then
        j=j+sprintf(s+j," 1")
      endif
      if k & 0x80 then
        j=j+sprintf(s+j," ")
        j=j+Geterrorword(8,s+j)        // "meas"
        j=j+sprintf(s+j," 1")
      else if k & 0x20 then
        j=j+sprintf(s+j," ")
        j=j+Geterrorword(8,s+j)        // "meas"
        j=j+sprintf(s+j," 2")
      endif
    endif
  else if $uint2(answer)>8 && answer[7]>=0x11 && answer[7]<=0x14 then
    j=j+sprintf(s+j,"ext %i",answer[7]-0x11)
    if $uint2(answer)>=10 && answer[8]!=0 then
      k=answer[8]
      if (k & 0x33)!=0 && (k & 0xCC)==0 then
        j=j+sprintf(s+j,":0")
      else if (k & 0x33)==0 && (k & 0xCC)!=0 then
        j=j+sprintf(s+j,":1")
      endif
    endif
  else
    j=j+Geterrorword(11,s+j)           // "rail"
    if $uint2(answer)>8 && answer[7]!=0xFF then
      j=j+sprintf(s+j," %i",answer[7])
    endif
    if $uint2(answer)>=10 && (answer[8] & 0x5F)!=0 && answer[7]!=0xFF then
      k=answer[8] & 0x5F
      if (k & 0xF0)!=0 then
        s[j]=','; j++
        if (k & 0x50)==0x10 then
          j=j+Geterrorword(12,s+j)     // "left"
          s[j]=' '; j++
        else if (k & 0x50)==0x40 then
          j=j+Geterrorword(13,s+j)     // "right"
          s[j]=' '; j++
        endif
        s[j]='Z'; j++
      else if ((k & 0x0F)!=0x0F && (k & 0x0F)!=0) then
        if (k & 0x03)!=0 then
          s[j]=','; j++
          j=j+Geterrorword(12,s+j)     // "left"
          if (k & 0x03)==0x01 then
            s[j]=' '; s[j+1]='X'; j=j+2
          else if (k & 0x03)==0x02 then
            s[j]=' '; s[j+1]='Y'; j=j+2
          endif
        endif
        if (k & 0x0C)!=0 then
          s[j]=','; j++
          j=j+Geterrorword(13,s+j)     // "right"
          if (k & 0x0C)==0x04 then
            s[j]=' '; s[j+1]='X'; j=j+2
          else if (k & 0x0C)==0x08 then
            s[j]=' '; s[j+1]='Y'; j=j+2
          endif
        endif
      endif
    endif
    if answer[8] & 0x80 then
      s[j]=','; j++
      j=j+Geterrorword(8,s+j)          // "meas"
      j=j+sprintf(s+j," 1")
    else if answer[8] & 0x20 then
      s[j]=','; j++
      j=j+Geterrorword(8,s+j)          // "meas"
      j=j+sprintf(s+j," 2")
    endif
  endif
  s[j]='\0'
  if $uint2(answer)>=20 then
    k=$uint2(answer+18) & 0xE000
    if (k!=0xE000) then
      if (k==0x0000) then      j=j+sprintf(s+j," MAIN")
      else if (k==0x2000) then j=j+sprintf(s+j," MEAS")
      else if (k==0x4000) then j=j+sprintf(s+j," HVOL")
      else if (k==0x6000) then j=j+sprintf(s+j," SERV")
      else if (k==0x8000) then j=j+sprintf(s+j," H500")
      else if (k==0xA000) then j=j+sprintf(s+j," FING")
      else if (k==0xC000) then j=j+sprintf(s+j," LATE")
      else                     j=j+sprintf(s+j," ????")
      endif
      j=j+sprintf(s+j,":%i",k & 0x1FFF)
    endif
  endif
  return ne
end

// Converts raw error message received from the tester into the text line s.
// Additional explanations, if available, are placed into the array extra. Lines
// in this array are separated by symbols '\n', end of explanations is marked
// by code '\0'. First symbol means color: '+' - red, '-' - gray, any other is
// for black. Returns number of bytes written into array extra.
function int DecodeerrorOLD(char *answer,char *s,char *extra)
  int i,j,k,ne,subcmd,suberr
  i=sprintf(s,"ERROR ")
  ne=0
  subcmd=answer[5]; suberr=answer[9];
  if subcmd==0x00 then
    i=i+sprintf(s+i,"(ROM) Crate not loaded")
  else if subcmd==0x01 then
    i=i+sprintf(s+i,"No finger programm/data")
  else if subcmd==0x02 then
    i=i+sprintf(s+i,"Fingers (")
    k=$long(answer+10);
    for j=0,j<16,j++
      if (k & 3)!=0 then
        s[i]=(j<10?'0'+j:'A'-10+j); i++
      endif
      k=k>>2
    enddo
    i=i+sprintf(s+i,") differ from layout (")
    k=$long(answer+14);
    for j=0,j<16,j++
      if (k & 3)!=0 then
        s[i]=(j<10?'0'+j:'A'-10+j); i++
      endif
      k=k>>2
    enddo
    i=i+sprintf(s+i,")")
  else if subcmd==0x03 then
    i=i+sprintf(s+i,"Bad FC software (v%i.%1i), %i.%1i+ required",             \
    suberr/10,suberr%10,answer[10]/10,answer[10]%10)
  else if subcmd==0x04 then
    i=i+sprintf(s+i,"FIELDSAFE line damaged")
  else if subcmd==0x05 then
    if suberr==0 then
      i=i+sprintf(s+i,"Damaged or misadjusted Z sensor")
    else if suberr==134 then
      i=i+sprintf(s+i,"Potentially dangerous AFMCU error")
    else
      i=i+sprintf(s+i,"Unknown self-test error %i",suberr)
    endif
  else if subcmd==0x06 then
    if suberr==0 then
      i=i+sprintf(s+i,"Z-movement down timeout")
    else if suberr==1 then
      i=i+sprintf(s+i,"Z-movement up timeout")
    else if suberr==2 then
      i=i+sprintf(s+i,"Contact over the surface detected")
    else
      i=i+sprintf(s+i,"Unknown Z movement error %i",suberr)
    endif
  else if subcmd==0x07 then
    k=$uint2(answer+10)
    i=i+sprintf(s+i,"Multiplexer error 0x%X",k)
    if k & 0xFF00 i=i+sprintf(s+i," (relays 0x%X)",$uint2(answer+12))
    if k & 0x4000 ne=ne+sprintf(extra+ne,"+Reed relay is short-cuted\n")
    if k & 0x2000 ne=ne+sprintf(extra+ne,"+Extended on-head control absent\n")
    if k & 0x1000 ne=ne+sprintf(extra+ne,"+Two outs connected to same finger\n")
    if k & 0x0800 ne=ne+sprintf(extra+ne,"+Finger connected to wrong output\n")
    if k & 0x0400 ne=ne+sprintf(extra+ne,"+Relay is too slow\n")
    if k & 0x0200 ne=ne+sprintf(extra+ne,"+Relay is short-cuted\n")
    if k & 0x0100 ne=ne+sprintf(extra+ne,"+Relay resistance is too high\n")
    if k & 0x0080 ne=ne+sprintf(extra+ne,"+Damaged breakdown detector\n")
    if k & 0x0040 ne=ne+sprintf(extra+ne,"+DC channel is out of order\n")
    if k & 0x0030 ne=ne+sprintf(extra+ne,"+Bad channel amplification\n")
    if k & 0x000E ne=ne+sprintf(extra+ne,"+High zero shift\n")
    if k & 0x0001 ne=ne+sprintf(extra+ne,"+Multiplexer absent\n")
  else if subcmd==0x08 then
    i=i+sprintf(s+i,"Phase lost at v=%i (%.1f mm/s)",                          \
    $int2(answer+10),$int2(answer+10)/6.4)
  else if subcmd==0x09 then
    if suberr==0 then
      i=i+sprintf(s+i,"End sensor not found")
    else if suberr==1 then
      i=i+sprintf(s+i,"Unable to pass encoder zero pulse")
    else if suberr==2 then
      i=i+sprintf(s+i,"Shifted encoder phase A zero, value %i",$int2(answer+10))
    else if suberr==3 then
      i=i+sprintf(s+i,"Shifted encoder phase B zero, value %i",$int2(answer+10))
    else if suberr==4 then
      i=i+sprintf(s+i,"Encoder phase A absent, value %i",$int2(answer+10))
    else if suberr==5 then
      i=i+sprintf(s+i,"Wrong differential encoder amplitude, value %i",        \
      $int2(answer+10))
    else if suberr==6 then
      i=i+sprintf(s+i,"Unable to find encoder zero pulse")
    else if suberr==7 then
      i=i+sprintf(s+i,"Digital encoder counter failed, value %i",              \
      $int2(answer+10))
    else if suberr==8 then
      i=i+sprintf(s+i,"Unable to repeat encoder zero pulse")
    else if suberr==9 then
      i=i+sprintf(s+i,"Encoder counter missed pulses, value %i",               \
      $int2(answer+10))
    else if suberr==10 then
      i=i+sprintf(s+i,"Microstep not corrected")
    else if suberr==16 then
      i=i+sprintf(s+i,"Upper Z coordinate low, value %i",$uint2(answer+10))
    else if suberr==17 then
      i=i+sprintf(s+i,"Upper Z coordinate too high, value %i",$uint2(answer+10))
    else if suberr==18 then
      i=i+sprintf(s+i,"Misadjusted pressure sensor, value %i",$uint2(answer+10))
    else if suberr==19 then
      i=i+sprintf(s+i,"Noisy pressure sensor, value %i",$uint2(answer+10))
    else if suberr==20 then
      i=i+sprintf(s+i,"Absolutely noiseless pressure sensor")
    else if suberr==255 then
      i=i+sprintf(s+i,"Encoder card absent or damaged")
    else
      i=i+sprintf(s+i,"Unknown encoder error %i, value %i",                    \
      suberr,$int2(answer+10))
    endif
  else if subcmd==0x0A then
    if suberr==0 then
      i=i+sprintf(s+i,"Temperature sensor absent")
    else if suberr==1 then
      i=i+sprintf(s+i,"Bad temperature sensor resistance (%.1f C)",            \
      $int2(answer+10)*0.1)
    else if suberr==2 then
      i=i+sprintf(s+i,"Connection between analog buses")
    else if suberr==3 then
      i=i+sprintf(s+i,"Temperature sensor completely damaged")
    else
      i=i+sprintf(s+i,"Unknown temperature sensor error %i, value %.1f C",     \
      suberr,$int2(answer+10)*0.1)
    endif
  else if subcmd==0x0B then
    i=i+sprintf(s+i,"Emergency mode 0x%X active",suberr);
    if suberr & 1 ne=ne+sprintf(extra+ne,"+User stop mode active\n")
    if suberr & 2 ne=ne+sprintf(extra+ne,"+Emergency button pressed\n")
    if suberr & 4 ne=ne+sprintf(extra+ne,"+Low air pressure\n")
    if suberr & 8 ne=ne+sprintf(extra+ne,"+Dangerous error stop active\n")
  else if subcmd==0x0D then
    if suberr==0 then
      i=i+sprintf(s+i,"Unable to determine type of U/I switch")
    else
      i=i+sprintf(s+i,"Unknown head controller error %i",suberr)
    endif
  else if subcmd==0x20 then
    if suberr==0 then
      i=i+sprintf(s+i,"Data transfer error (crate-to-head)")
    else if suberr==1 then
      i=i+sprintf(s+i,"Serial bus test error (0x%2X instead of 0x%X)",         \
      answer[10],answer[11])
    else if suberr==2 then
      i=i+sprintf(s+i,"Serial bus error detected by head")
    else if suberr==3 then
      i=i+sprintf(s+i,"Serial bus error detected by crate")
    else if suberr==4 then
      i=i+sprintf(s+i,"Error in serial data from slave")
    else if suberr==5 then
      i=i+sprintf(s+i,"Digital bus test error (0x%2X instead of 0x%X)",        \
      answer[10],answer[11])
    else
      i=i+sprintf(s+i,"Unknown I/O error %i",suberr)
    endif
  else if subcmd==0x21 then
    i=i+sprintf(s+i,"Wrong 0 sensors")
  else if subcmd==0x22 then
    i=i+sprintf(s+i,"Wrong coordinates")
  else if subcmd==0x23 then
    i=i+sprintf(s+i,"Wrong sequence of commands")
  else if subcmd==0x24 then
    i=i+sprintf(s+i,"Bad command")
    if suberr!=0 i=i+sprintf(s+i," 0x%X",suberr)
  else if subcmd==0x25 then
    i=i+sprintf(s+i,"Bad command size")
  else if subcmd==0x26 then
    i=i+sprintf(s+i,"Table/queue overflow")
  else if subcmd==0x27 then
    i=i+sprintf(s+i,"Zero phases wrong")
  else if subcmd==0x28 then
    i=i+sprintf(s+i,"Bad data")
  else if subcmd==0x29 then
    i=i+sprintf(s+i,"Pad not found, step %i",answer[10])
  else if subcmd==0x2A then
    i=i+sprintf(s+i,"AFMCU error %i (0x%8X)",suberr,$int4(answer+10))
  else if subcmd==0x2B then
    i=i+sprintf(s+i,"Division by zero")
  else if subcmd==0x2C then
    i=i+sprintf(s+i,"Marking error %i",suberr)
  else if subcmd==0x50 then
    i=i+sprintf(s+i,"Broken cable")
  else if subcmd==0x51 then
    i=i+sprintf(s+i,"On-head amplifier shift %i bits",$int2(answer+10))
  else if subcmd==0x52 then
    i=i+sprintf(s+i,"Needle or cable shortened to shield")
  else if subcmd==0x53 then
    if suberr==0 then
      i=i+sprintf(s+i,"Timeout while waiting 100 mks")
    else if suberr==1 then
      i=i+sprintf(s+i,"Timeout due to 8253 fail")
    else
      i=i+sprintf(s+i,"Unknown timeout error %i",suberr)
    endif
  else if subcmd==0x54 then
    k=$uint2(answer+10)
    i=i+sprintf(s+i,"Measurement card error 0x%X",k)
    if k & 0x0001 ne=ne+sprintf(extra+ne,"+Measurement card absent\n")
    if k & 0x0002 ne=ne+sprintf(extra+ne,"+No 50 Hz synchronization\n")
    if k & 0x007C ne=ne+sprintf(extra+ne,"+DC parameters out of range\n")
    if k & 0x0F80 ne=ne+sprintf(extra+ne,"+AC parameters out of range\n")
    if k & 0x1000 ne=ne+sprintf(extra+ne,"+Bus voltage out of range\n")
    if k & 0x2000 ne=ne+sprintf(extra+ne,"+ACCH connection absent\n")
  else if subcmd==0x55 then
    i=i+sprintf(s+i,"Bad capacity of the analog cable")
    k=$uint2(answer+10)
    if k!=0 then
      i=i+sprintf(s+i," (%i pF)",k)
    endif
  else if subcmd==0xE0 then
    i=i+sprintf(s+i,"Open-close sensors do not work")
  else if subcmd==0xE1 then
    i=i+sprintf(s+i,"Can't lock shuttle")
  else if subcmd==0xE2 then
    i=i+sprintf(s+i,"Lock sensors do not work")
  else if subcmd==0xE3 then
    i=i+sprintf(s+i,"Shuttle is open but locked")
  else if subcmd==0xE4 then
    i=i+sprintf(s+i,"Can't unlock shuttle")
  else if subcmd==0xE5 then
    i=i+sprintf(s+i,"No 24V power")
  else if subcmd==0xE6 then
    i=i+sprintf(s+i,"No vacuum or high pins")
  else if subcmd==0xE7 then
    i=i+sprintf(s+i,"Air pressure is low")
  else if subcmd==0xE8 then
    i=i+sprintf(s+i,"SPS error %i",suberr)
    if suberr==1 then
      i=i+sprintf(s+i," - Unable to communicate with SPS");
    else if suberr==2 then
      i=i+sprintf(s+i," - Automatic loader not connected");
    else if suberr==11 then
      i=i+sprintf(s+i," - Emergency cirquit activated");
    else if suberr==12 then
      i=i+sprintf(s+i," - Self-test error");
    else if suberr==13 then
      i=i+sprintf(s+i," - Internal error");
    else if suberr==14 then
      i=i+sprintf(s+i," - Unrecognized command");
    else if suberr==15 then
      i=i+sprintf(s+i," - Pusher in push position");
    else if suberr==16 then
      i=i+sprintf(s+i," - Some unit is still moving");
    else if suberr==17 then
      i=i+sprintf(s+i," - Operation is not allowed");
    else if suberr==18 then
      i=i+sprintf(s+i," - Unable to continue");
    else if suberr==20 || suberr==21 then
      i=i+sprintf(s+i," - Input unit");
    else if suberr==22 then
      i=i+sprintf(s+i," - Output unit");
    else if suberr==23 then
      i=i+sprintf(s+i," - Stopper");
    else if suberr==24 then
      i=i+sprintf(s+i," - Stopper sensor");
    else if suberr==25 then
      i=i+sprintf(s+i," - Unexpected PCB on band");
    else if suberr==26 then
      i=i+sprintf(s+i," - Lifters not in down position");
    else if suberr==27 then
      i=i+sprintf(s+i," - Loader pneumatics");
    else if suberr==28 then
      i=i+sprintf(s+i," - Suction board");
    else if suberr==29 then
      i=i+sprintf(s+i," - Shuttle pneumatics");
    else if suberr==30 then
      i=i+sprintf(s+i," - Input pile empty");
    else if suberr==31 then
      i=i+sprintf(s+i," - Unable to load PCB");
    else if suberr==32 then
      i=i+sprintf(s+i," - Output pile full");
    else if suberr==33 then
      i=i+sprintf(s+i," - Unable to home printing head");
    else if suberr==34 then
      i=i+sprintf(s+i," - Invalid X-Y print coordinates");
    else if suberr==40 then
      i=i+sprintf(s+i," - Unable to communicate with jet printer");
    endif
  else
    i=i+sprintf(s+i,"Undefined error code 0x%X",subcmd)
  endif
  j=answer[6]
  i=i+sprintf(s+i," %s,%s,%s",                                                 \
    (j & 0x01)==0?"Rec":"Unrec",                                               \
    (j & 0x02)==0?"soft":"hard",                                               \
    (j & 0x04)?"crate":((j & 0x08)?"slave":((j & 0x10)?"meas":                 \
    ((j & 0x20)?"AFMCU":((j & 0x80)?"general":"rail")))))
  if (j & 0x9C)==0 && $uint2(answer)>8 then
    i=i+sprintf(s+i," %i",answer[7])
  endif
  if $uint2(answer)>=10 && answer[8]!=0 then
    j=answer[8]
    if (j & 0xF0)!=0 then
      if (j & 0x30)==0x30 then
        i=i+sprintf(s+i,",Z")
      else if (j & 0x10)!=0 then
        i=i+sprintf(s+i,",left Z")
      else if (j & 0x40)!=0 then
        i=i+sprintf(s+i,",right Z")
      endif
    else if ((j & 0x0F)!=0x0F && (j & 0x0F)!=0) then
      if (j & 0x03)==0x03 then
        i=i+sprintf(s+i,",left")
      else if (j & 0x01)!=0 then
        i=i+sprintf(s+i,",left X")
      else if (j & 0x02)!=0 then
        i=i+sprintf(s+i,",left Y")
      endif
      if ((j & 0x0C)==0x0C) then
        i=i+sprintf(s+i,",right")
      else if (j & 0x04)!=0 then
        i=i+sprintf(s+i,",right X")
      else if (j & 0x08)!=0 then
        i=i+sprintf(s+i,",right Y")
      endif
    endif
  endif
  if $uint2(answer)>=20 then
    j=$uint2(answer+18)
    if ((j & 0xE000)==0x0000) then
      i=i+sprintf(s+i," MAIN")
    else if ((j & 0xE000)==0x2000) then
      i=i+sprintf(s+i," MEAS")
    else if ((j & 0xE000)==0x4000) then
      i=i+sprintf(s+i," HVOL")
    else if ((j & 0xE000)==0x6000) then
      i=i+sprintf(s+i," SERV")
    else if ((j & 0xE000)==0x8000) then
      i=i+sprintf(s+i," H500")
    else if ((j & 0xE000)==0xA000) then
      i=i+sprintf(s+i," FING")
    else if ((j & 0xE000)==0xC000) then
      i=i+sprintf(s+i," LATE")
    else
      i=i+sprintf(s+i," ????")
    endif
    i=i+sprintf(s+i,":%i",j & 0x1FFF)
  endif
  extra[ne]=0                          // Mark end of explanations
  return ne
end

// Service function, decodes 16-bit status returned by measurement commands.
function int Decodestatus(char *text,int status,int mask,char *pat)
  int i,i0,j,k,m,n
  i=sprintf(text," St=%04X",status)
  if (mask & ST)==0 return i
  i0=i; j=0x8000; k=0; n=0
  text[i]=' '; text[i+1]='('; i=i+2
  while pat[k]!='\0' && pat[k]!=')' do
    if pat[k]=='#' then
      k++                              // Two adjacent bits (#11:10:01:00)
      m=((status & j)==0?0x00:0x02)
      j=j>>1
      if (status & j)!=0 m=m|0x01
      while m!=0x03 && pat[k]!='|' && pat[k]!='\0' && pat[k]!=')' do
        if pat[k]==':' m++
        k++;
      enddo
      if m==0x03 && pat[k]!=':' && pat[k]!='|' then
        if n!=0 then
          text[i]=','; i++
        endif
        n++
        while pat[k]!='|' && pat[k]!=':' && pat[k]!='\0' && pat[k]!=')' do
          text[i]=pat[k]; i++; k++
        enddo
      endif
      while pat[k]!='|' && pat[k]!='\0' && pat[k]!=')' do k++; enddo
    else
      if ((status & j)!=0 && pat[k]!='|') then
        if n!=0 then                   // Copy next field
          text[i]=','; i++
        endif
        n++
        while pat[k]!='|' && pat[k]!=':' && pat[k]!='\0' && pat[k]!=')' do
          text[i]=pat[k]; i++; k++
        enddo
        if pat[k]==':' then
          while pat[k]!='|' && pat[k]!='\0' && pat[k]!=')' do k++; enddo
        endif
      else                             // Advance to next field
        while pat[k]!='|' && pat[k]!=':' && pat[k]!='\0' && pat[k]!=')' do
          k++
        enddo
      endif
      if pat[k]==':' then              // Display zero bit field
        k++
        if n!=0 then
          text[i]=','; i++
        endif
        n++
        while pat[k]!='|' && pat[k]!='\0' && pat[k]!=')' do
          text[i]=pat[k]; i++; k++
        enddo
      endif
    endif
    if pat[k]=='|' k++
    j=j>>1
  enddo
  if n==0 then
    text[i0]='\0'                      // No decoded fields, remove parenthesis
    return i0
  else
    if pat[k]!=')' then
      text[i]=')'; i++
    endif
    text[i]='\0'
    return i
  endif
end

function int SERV.Decodespsinfo(int code,char *s)
  static char spsinfo[58][80] = { \
  "001:Waiting for boards, OK for fast up", \
  "002:Board at paternoster inflow", \
  "003:Board is in bad stacker unit", \
  "004:Board is in good stacker unit", \
  "005:Board is in marking unit", \
  "006:Fehler in Zufhrung, warten bis Staplerzyklus beendet ist", \
  "007:Fehler in Tester, warten bis Staplerzyklus beendet ist", \
  "008:Fehler in Tester, warten bis Zufhrung beendet ist", \
  "009:Fehler in Stapler, warten bis Zufhrung beendet ist", \
  "010:Cycle stopped", \
  "011:Good stacker full", \
  "012:Bad stacker full", \
  "013:Label printer lot paper or paper empty", \
  "014:Paternoster Offsetermittlung: Phase 1 luft !\nAuflageschiene Nr. %d", \
  "015:Paternoster Offsetermittlung: Phase 2 luft !\nZeitdifferenz:%d ms", \
  "016:Tester locked, function cannot carried out", \
  "017:Stacker can be docked now, OK when docked, CANCEL for cancel", \
  "018:Stacker already docked", \
  "019:Stacker already undocked", \
  "020:Stacker can be undocked now, OK when undocked, CANCEL for cancel", \
  "021:Width adjustment busy, cancel with function Cancel", \
  "022:Turn key switch ON", \
  "023:Start clamp sequence with 2 hand buttons", \
  "024:Release 2 hand buttons", \
  "025:Calibration mode active:start clamping sequence with 2 hand buttons", \
  "026:Automation will be resetted", \
  "027:Stapler kann jetzt an/abgedockt werden\n\nOK wenn an- oder abgedockt ist!", \
  "028:Band initialisation running", \
  "029:Band initialisation terminated", \
  "030:Fehler in Bandinitialisierung\n\nalle Produkte entnehmen!", \
  "031:Alle Produkte werden in Schlechtstapler gefahren!", \
  "032:Alle Produkte werden in Schlechtstapler transportiert", \
  "033:Paternoster initialisation running", \
  "034:Paternoster board moving up", \
  "035:Board on pusher, clamping sequence cannot be carried out", \
  "036:Calibration Mode (Glasplatte): mit 2-Hand Klemm/Entklemmsequenz aktivieren", \
  "037:Strechframe Mode:\nSpannrahmen entnehmen, dann auf Standard Mode umschalten!", \
  "038:2 Handbedienung bettigen fr\n\nVacuumbox entklemmen!", \
  "039:2 Handbedienung bettigen fr\n\nVacuumbox in Grundstellung bringen!", \
  "040:2 Handbedienung bettigen fr\n\nShuttle in Grundstellung bringen!", \
  "041:Einbau der Auflageleisten und Vakuumbox\n\n2- Handbedienung bettigen", \
  "042:Light curtain feeding stack interrupted", \
  "043:Light curtain good or bad stack interrupted", \
  "044:Light curtain feeding and taking stack interrupted", \
  "045:Press 2 hand buttons to clamp vacuum box", \
  "046:Please close hood", \
  "047:Please turn kez switch OFF!", \
  "048:Dangerous contour in shuttle", \
  "049:open shuttle", \
  "050:Limit for width adjustment exceeded!", \
  "051:Automatic width adjustment is running", \
  "052:Width adjustement:end position lesser than current position!", \
  "053:Width adjustement:timeout!", \
  "054:Width adjustement:end position bigger than current position!", \
  "055:<OK> to start automaticc width adjustment", \
  "056:Width adjustement is not possible, as shuttle is not in basic position", \
  "057:Width adjustement is not possible. There are products in shuttle.", \
  "" }
  int i,j
  for i=0,spsinfo[i,0]!='\0',i++ do
    j=(spsinfo[i,0]-'0')*100+(spsinfo[i,1]-'0')*10+(spsinfo[i,2]-'0')
    if j==code then
      Strcpy(s,spsinfo[i]+4)
      return Strlen(s)
    endif
  enddo
  return sprintf(s,"SPS info %i",code)
end

function int SERV.Decodespserror(int code,char *s)
  static char spserr[189][80] = { \
  "001:Left tester band not out", \
  "002:Right tester band not out", \
  "003:Left tester band not in", \
  "004:Right tester band not in", \
  "005:Left tester band both sensors in/out active", \
  "006:Left tester band both sensors in/out not active", \
  "007:Right tester band both sensors in/out active", \
  "008:Right tester band both sensors in/out not active", \
  "009:No sensor for pusher up/down active", \
  "010:Both sensors for pusher up/down busy", \
  "011:No sensor for pusher forwards/backwards active", \
  "012:Both sensors for pusher forwards/backwards busy", \
  "013:Left lateral clamping out, right clamping in", \ 
  "014:Right lateral clamping out, left clamping in", \ 
  "015:No sensor for stopper up/down active", \ 
  "016:Both sensors for stopper up/down busy", \ 
  "017:Board up down left down, right up", \ 
  "018:Board up/down left up, right down", \ 
  "019:Left lateral catch in, right catch out", \ 
  "020:Left lateral catch out, right catch in", \ 
  "021:Servo error Y-marking axis", \ 
  "022:Y-marking axis nominal position out of range", \
  "023:Emergency off:front button", \ 
  "024:Emergency off:rear button", \ 
  "025:Emergency off:hood open", \ 
  "026:Emergency off:power part", \
  "027:Emergency off:air", \ 
  "028:Emergency off:paternoster motor safety switch ", \ 
  "029:Emergency off:button in pater noster", \ 
  "030:Emergency off:stacker motor safety switch", \ 
  "031:Emergency off:button in stacker", \ 
  "032:Emergency off:Y marking axis", \ 
  "033:Task cannot be made ready", \ 
  "034:Task cannot be started", \ 
  "035:Number of modules of basic unit wrong", \ 
  "036:Number of modules of automation wrong", \ 
  "037:Number of slave modules of basic unit wrong", \
  "038:Number of slave modules of automation wrong", \ 
  "039:Emergency off bridge by relays for paternoster unit faulty", \ 
  "040:Emergency off bridge by relays for stacker unit faulty", \
  "041:Pusher not moving up", \
  "042:Pusher not moving down", \ 
  "043:Pusher still at back, should move forwards", \ 
  "044:Pusher moves too far forwards in end position ", \ 
  "045:Pusher not moving backwards", \ 
  "046:Left lateral catch not in home position", \ 
  "047:Right lateral catch not in home position", \ 
  "048:Left lateral catch still in home position, no move out", \ 
  "049:Right lateral catch still in home position, no move out", \ 
  "050:Right tester bands not out", \ 
  "051:Left tester bands not out", \ 
  "052:Right tester bands not in", \ 
  "053:Left tester band not in", \ 
  "054:Board right side not down", \ 
  "055:Board left side not down", \ 
  "056:Board still down right side", \ 
  "057:Board still down left side", \ 
  "058:Right lateral clamping still in", \
  "059:Left lateral clamping still in ", \ 
  "060:Right lateral clamping not in", \ 
  "061:Left lateral clamping not in", \ 
  "062:Stopper not up", \
  "063:Stopper not down", \ 
  "064:2nd sensor in test area not reached", \ 
  "065:2nd sensor cannot be left", \ 
  "066:1st Sensor not reached", \ 
  "067:Feeding inflow sensor not reached", \ 
  "068:Run in sensor cannot be left", \ 
  "069:Outflow sensor cannot be reached", \ 
  "070:Pater noster cannot move - overloaded", \
  "071:Paternoster motor right not starting", \ 
  "072:Paternoster motor left not starting", \ 
  "073:Front top cylinder of suction plate not down", \
  "074:Front bottom cylinder of suction plate not down", \ 
  "075:Rear top cylinder of suction plate not down", \ 
  "076:Rear bottom cylinder of suction plate not down", \ 
  "077:Front bottom cylinder of suction plate not up", \
  "078:Rear bottom cylinder of suction plate not up", \ 
  "079:Front top cylinder of suction plate not up", \ 
  "080:Rear top cylinder of suction plate not up", \ 
  "081:Push in cylinder does not move forwards", \
  "082:Push in cylinder does not move backwards", \ 
  "083:Rear roller support does not move in", \
  "084:Front roller support does not move in", \ 
  "085:Rear roller support does not move out", \ 
  "086:Front roller support does not move out", \ 
  "087:Front clamping does not move backwards", \ 
  "088:Rear clamping does not move backwards", \ 
  "089:Clamping does not move backwards", \ 
  "090:Front clamping not moved out", \ 
  "091:Rear clamping not moved out", \ 
  "092:Clamping not moved out", \ 
  "093:Board not present during clamping", \ 
  "094:Vacuum loss", \
  "095:Right motor standing, left motor too long running", \ 
  "096:Left motor standing, right motor too long running", \ 
  "097:Initialisation too long", \ 
  "098:Initialisation cannot be left", \
  "099:Control cannot be switched off", \ 
  "100:Control cannot be switched on", \ 
  "101:ID out of valid range", \ 
  "102:Tester outflow not reached", \ 
  "103:Left marking stopper does not move up", \ 
  "104:Right marking stopper does not move up", \ 
  "105:Left marking stopper does not move down", \ 
  "106:Right marking stopper does not move down", \ 
  "107:Stacker inflow not reached", \ 
  "108:Marking stopper not reached", \ 
  "109:Left good stopper does not move up", \
  "110:Right good stopper does not move up", \ 
  "111:Left good stopper does not move down", \ 
  "112:Right good stopper does not move down", \ 
  "113:Left bad stopper does not move up", \
  "114:Right bad stopper does not move up", \ 
  "115:Left bad stopper does not move down", \ 
  "116:Right bad stopper does not move down", \ 
  "117:Good stacker no reaction", \ 
  "118:Good stacker right side no reaction", \ 
  "119:Good stacker left side no respond", \ 
  "120:Good stacker eccenter sensors not reached", \ 
  "121:Good stacker right eccenter sensor not reached", \ 
  "122:Good stacker left eccenter sensor not reached", \ 
  "123:Good stacker ini still busy although board is stacked upwards", \ 
  "124:Bad stacker no response", \ 
  "125:Bad stacker right side no response", \ 
  "126:Bad stacker left side no response", \ 
  "127:Bad stacker eccenter sensors are not reached", \ 
  "128:Bad stacker right eccenter sensor not reached", \ 
  "129:Bad stacker left eccenter sensor not reached", \ 
  "130:Bad stacker busy ini still active, although board is stacked up", \
  "131:Task control not ready, different function running", \ 
  "132:Cycle not running", \ 
  "133:Stacker inflow cannot be left", \ 
  "134:Good stacker not reached", \
  "135:Bad stopper not reached", \ 
  "136:Stopper assign wrong", \ 
  "137:Stacker band inflow not reached", \ 
  "138:Stacker band unflow cannot be left during the separation of boards", \
  "139:Paper cylinder does not move up", \
  "140:Paper cylinder does not move down", \
  "141:Y-marking axis reference sensor not reached", \
  "142:Y-marking reference sensor cannot be left", \
  "143:Paper label cannot be taken off", \
  "144:Task cannot be started", \
  "145:Task control not ready or emergency off", \
  "146:Produkte befinden sich\nbereits im Tester", \
  "147:TST UNLOAD luft gerade\nabgesetzter Befehl:TST LOAD", \ 
  "148:Testerfehler\nabgesetzter Befehl:TST LOAD oder TST UNLOAD", \
  "149:TST LOAD luft gerade\nabgesetzter Befehl:TST UNLOAD", \
  "150:TST UNLOAD:\nStapler hat alle Produkte\nnoch nicht abgestapelt!", \ 
  "151:No more boards vor stacking", \
  "152:Kommando:to Bad stacker\nluft gerade\nabgesetzter Befehl:STP TO GOOD", \ 
  "153:Kommando:to Good stacker\nluft gerade\nabgesetzter Befehl:STP TO BAD", \ 
  "154:Fahrt zurck zu Bandeinlauf:\n\nBandeinlauf und Markierung belegt!", \ 
  "155:Papierlabler hat Paier verloren\n\noder Papier ist leer", \ 
  "156:Label printer does not exist", \ 
  "157:Inkjet not present", \ 
  "158:Marking position cannot be left", \ 
  "159:Paternoster not installed", \
  "160:Stacker not initialised", \ 
  "161:Marking busy ini not active", \ 
  "162:Marking inflow not active", \ 
  "163:Stacker inflow not active", \ 
  "164:Tester band outflow active", \
  "165:Tester band 1st sensor active", \
  "166:Tester band 2nd sensor active", \
  "167:Feeding inflow and outflow active", \
  "168:Outflow sensor cannot be left", \
  "169:Error during board separation", \
  "170:Stacker inflow not reached", \
  "171:Feeding cycle cannot be stopped", \
  "172:Bad stacker full, request return to A6", \
  "173:Bad stacker full, request return to A6", \
  "174:Cycle cancelled, CANCEL pushed during tester load", \
  "175:Invalid printer type in Do Marking", \
  "176:Band position in \"Do marking\" larger than board width", \
  "177:Timeout:no barcode result", \
  "178:Barcode does not exist", \
  "179:Transfer to external band system, cannot leave good sensor", \
  "180:Function cannot be executed because of interrupt in light curtain", \
  "181:lable printer does not exist", \
  "182:Z axis label printer remains in basic position, doesn't move down", \
  "183:Z axis label printer remains in basic position, doesn't move up", \
  "184:no lable stored in printer", \
  "185:lable printer not ready", \
  "186:lable printer reports error", \
  "187:label still stored in printer", \
  "188:lable printer not in basic position", \
  "" }
  int i,j
  for i=0,spserr[i,0]!='\0',i++ do
    j=(spserr[i,0]-'0')*100+(spserr[i,1]-'0')*10+(spserr[i,2]-'0')
    if j==code then
      Strcpy(s,spserr[i]+4)
      return Strlen(s)
    endif
  enddo
  return sprintf(s,"SPS error %i",code)
end

// Function decodes raw answer received from the tester into the text line s.
// Returns color of the text, or -1 if answer type is not in the mask.
function int SERV.Decodeanswer(char *answer,char *s,char *extra,int mask)
  int i,j,k,n,ne,x0,y0,x1,y1,sta,status,factor,cair
  int len,color,cmd,subcmd,decodecmd
  char c,type[8],buf[1024]
  float value,zc,zr,zairc,zairr
  color=BLACK
  extra[0]=0; ne=0; decodecmd=0
  len=$uint2(answer)
  if (len<5) then
    sprintf(s,"Answer is too short, only %i bytes",len)
    return RED                         // Answer is too short
  endif
  
  cmd=answer[4]
  if (cmd==S_READY) then
    if answer[2]==0 && (mask & SR)==0 return -1
    if answer[2]!=0 && (mask & DM)==0 return -1
    sprintf(s,"READY")
  else if (cmd==S_SHOWPOINT) then
    if (mask & DM)==0 return -1
    sprintf(s,"SHOW")
  else if (cmd==S_TOUCHPOINT) then
    if (mask & DM)==0 return -1
    sprintf(s,"TOUCH")
  else if (cmd==S_DETOUCH) then
    if (mask & DM)==0 return -1
    sprintf(s,"DETOUCH")
  else if (cmd==S_LOADRUN) then
    if (mask & DT)==0 return -1
    i=sprintf(s,"LOADRUN")
    if len>=7 sprintf(s+i," Tester=0x%02X Nlayext=%i",answer[5],answer[6])
  else if (cmd==S_LAYOUT) then
    if (mask & DT)==0 return -1
    i=sprintf(s,"LAYOUT ")
    if len==774 && answer[5]!=20 then
      if answer[5]==2 || answer[5]==3 then
        switch $LAY(answer+6).software
        case 0x00: Strcpy(type,"A")
        case 0x80: Strcpy(type,"A1")
        case 0x84: Strcpy(type,"A2")
        case 0x86: Strcpy(type,"A2X")
        case 0x88: Strcpy(type,"M2")
        case 0x8C: Strcpy(type,"A3")
        case 0xA5: Strcpy(type,"A5")
        case 0xA6: Strcpy(type,"A6")
        case 0xA7: Strcpy(type,"S1")
        case 0xA8: Strcpy(type,"S2")
        case 0xA9: Strcpy(type,"S3")
        case 0xB7: Strcpy(type,"A7")
        case 0xB8: Strcpy(type,"A8")
        default: Strcpy(type,"A?")
        endsw
        sprintf(s+i,"(%s/%i)",type,$uint2(answer+6)*2)
      else if answer[5]==15 then
        sprintf(s+i,"EXTENTION")
      endif
    else if len==778 && answer[5]==20 then
      sprintf(s+i,"EXT%i",$uint4(answer+6))
    else
      if (mask & (DT|ER))==0 return -1
      sprintf(s+i,"- Wrong length of answer")
      color=RED
    endif
  else if (cmd==S_MEASUREBUS) then
    if (mask & MS)==0 return -1
    sprintf(s,"BUS")
  else if (cmd==S_CALIBRATE) then
    i=sprintf(s,"CALIBRATE ");
    if len>=21 then
      if (mask & MS)==0 return -1
      x0=$int4(answer+5)
      x1=$int4(answer+9)
      y0=$int4(answer+13)
      y1=$int4(answer+17)
      i=i+sprintf(s+i,"X=%7.3f Y=%7.3f dX=%6.3f dY=%6.3f",                     \
        (x0+x1)/2000.0,(y0+y1)/2000.0,(x1-x0)/1000.0,(y1-y0)/1000.0)
      if len>=23 then
        sprintf(s+i," Z=%5i",$int2(answer+21))
      endif
    else
      if (mask & (MS|BA|ER))==0 return -1
      sprintf(s+i,"- Wrong length of answer")
      color=RED
    endif
  else if (cmd==S_RESET) then
    if (mask & SR)==0 return -1
    sprintf(s,"RESET")
  else if (cmd==S_CHECKZERO) then
    i=sprintf(s,"CHECKZERO ")
    if len==8 then
      if (mask & DM)==0 return -1
      i=i+sprintf(s+i," rail %i ",$char(answer+5))
      subcmd=$int2(answer+6)
      if subcmd==0 then
        sprintf(s+i,"OK")
      else
        sprintf(s+i,"errors=0x%X",subcmd)
        color=RED
      endif
    else
      if (mask & (DM|ER))==0 return -1
      sprintf(s+i,"- Wrong length of answer")
      color=RED
    endif
  else if (cmd==S_DEFBOARD) then
    if (mask & (DT|MS))==0 return -1
    sprintf(s,"默认板")
  else if (cmd==S_FINDPAD) then
    i=sprintf(s,"FINDPAD ");
    if len==13 then
      if (mask & MS)==0 return -1
      x0=$int4(answer+5)
      y0=$int4(answer+9)
      sprintf(s+i,"X=%7.3f Y=%7.3f",x0/1000.0,y0/1000.0)
    else
      if (mask & (MS|BA|ER))==0 return -1
      sprintf(s+i,"- Wrong length of answer")
      color=RED
    endif
  else if (cmd==S_HVINIT) then
    i=sprintf(s,"HVINIT")
    if (len>=9) then
      sta=$uint4(answer+5)
      if sta==0 then
        if (mask & MS)==0 return -1
        i=i+sprintf(s+i," OK")
      else
        if (mask & (MS|BA))==0 return -1
        i=i+sprintf(s+i," Error 0x%X",sta)
        color=RED
      endif
    endif
    if (len>=13) then
      if $int2(answer+9)!=0 i=i+sprintf(s+i,", card=HV%i",$int2(answer+9))
      if ($int2(answer+11) & 0x0001) i=i+sprintf(s+i,", unipolar")
    endif
    if (len>=29) then
      if $float4(answer+13)!=0                                                 \
        i=i+sprintf(s+i,", Umax=%g V",$float4(answer+13))
      value=$float4(answer+17)
      if value>=1.0e9 then
        i=i+sprintf(s+i,", Rmax=%g GOhm",value/1.0e9)
      else if value!=0.0 then
        i=i+sprintf(s+i,", Rmax=%g MOhm",value/1.0e6)
      endif
    endif
  else if (cmd==S_ERROR) then
    if answer[2]==0 && (mask & ER)==0 return -1
    if answer[2]!=0 && (mask & (MS|BA|ER))==0 return -1
    ne=Decodeerror(answer,s,extra)
    color=RED
  else if (cmd==S_DUMP) then
    if answer[2]!=0 && (mask & DB)==0 return -1
    if answer[2]==0 && (mask & (DB|MS|BA|ER))==0 return -1
    sprintf(s,"DUMP Length=%i",len-5)
    if $GLOBAL.dumpfollows!=0 then
      decodecmd=1
      mask=mask|0x80000000             // Force dump
      $GLOBAL.dumpfollows=0
    endif
  else if (cmd==S_DEBUG) then
    if (mask & DB)==0 return -1
    sprintf(s,"DEBUG")
  else if (cmd==S_STROKES) then
    if answer[5]<16 then
      if len==14 then
        if (mask & SR)==0 return -1
        sprintf(s+i,"Number of strokes for rail %i: left %i, right %i",        \
        answer[5],$uint4(answer+6),$uint4(answer+10))
      else
        if (mask & (SR|ER))==0 return -1
        sprintf(s+i,"STROKES - Wrong message length")
        color=RED
      endif
    else if answer[5]==255 then
      if (mask & (DT|DB))==0 return -1
      sprintf(s+i,"STROKES CONTACTS PER PAD")
      if mask & FL then
        j=6; k=0
        while j+6<=len do
          if k>=6 then
            ne=ne+sprintf(extra+ne,"\n"); k=0
            if ne>=1900 then
              ne=ne+sprintf(extra+ne,"-   ...")
              break
            endif
          endif
          if k==0 ne=ne+sprintf(extra+ne,"- ")
          ne=ne+sprintf(extra+ne,"  [%5i]=%3i",                                \
            $uint4(answer+j),$uint2(answer+j+4))
          j=j+6; k++
        enddo
      endif
    else
      if (mask & (DT|DB))==0 return -1
      sprintf(s+i,"STROKES %i",answer[5])
    endif
  else if (cmd==S_TEST) then
    if (mask & DB)==0 return -1
    i=sprintf(s,"TEST")
    if answer[5]==0x04 then
      i=i+sprintf(s+i," MONITOR")
      if $uint2(answer+6)==0 then
        sprintf(s+i," OK %i points, %i channels",$uint4(answer+9),answer[8])
      else
        if ($uint2(answer+6) & 0x8000)!=0 i=i+sprintf(s+i," MEMORY")
        if ($uint2(answer+6) & 0x0001)!=0 i=i+sprintf(s+i," TIMEOUT")
      endif
    endif
  else if (cmd==S_GROUP) then
    if (mask & DM)==0 return -1
    sprintf(s,"GROUP")
  else if (cmd==S_LAINIT) then
    i=sprintf(s,"LAINIT ")
    if (len==13) then
      sta=$uint4(answer+5)
      if sta==0 then
        if (mask & MS)==0 return -1
        i=i+sprintf(s+i,"OK ")
      else
        if (mask & (MS|BA))==0 return -1
        i=i+sprintf(s+i,"Error 0x%X ",sta)
        if (mask & ST)!=0 && (sta & 0x80000F7C)!=0 then
          s[i]='('; i++
          if sta & 0x80000000 i=i+sprintf(s+i,"Hdwr,")
          if sta & 0x00000800 i=i+sprintf(s+i,"Src,")
          if sta & 0x00000400 i=i+sprintf(s+i,"Open,")
          if sta & 0x00000200 i=i+sprintf(s+i,"Timeout,")
          if sta & 0x00000100 i=i+sprintf(s+i,"NoCt,")
          if sta & 0x00000080 i=i+sprintf(s+i,"OnHead,")
          if sta & 0x00000040 i=i+sprintf(s+i,"Meas,")
          if sta & 0x00000020 i=i+sprintf(s+i,"NoCal,")
          if sta & 0x00000010 i=i+sprintf(s+i,"NoBase,")
          if sta & 0x00000008 i=i+sprintf(s+i,"NoTest,")
          if sta & 0x00000004 i=i+sprintf(s+i,"Damaged,")
          s[i-1]=')'; s[i]=' '; s[i+1]='\0'; i++
        endif
      endif
      if $float4(answer+9)!=0.0 sprintf(s+i,"Defect=%f",$float4(answer+9))
    else
      if (mask & (MS|BA|ER))==0 return -1
      sprintf(s+i,"- Wrong length of answer")
      color=RED
    endif
  else if (cmd==S_EXTINIT) then
    if $uint2(answer+5)==0 && (mask & MS)==0 return -1
    if $uint2(answer+5)!=0 && (mask & (MS|BA))==0 return -1
    i=sprintf(s,"EXTINIT ")
    i=i+sprintf(s+i,"St=0x%04X L=%i",$uint2(answer+5),$uint2(answer+7))
    s[i]=' '; i++
    s[i]='\"'; i++
    for j=9,i<250 && j<len,j++
      if Isprint(answer[j]) then s[i]=answer[j]
      else s[i]='.'
      endif
      i++
    enddo
    s[i]='\"'; i++
    s[i]='\0'; i++
  else if (cmd==S_EXACTINIT) then
    if $uint2(answer+5)==0 && (mask & MS)==0 return -1
    if $uint2(answer+5)!=0 && (mask & (MS|BA))==0 return -1
    i=sprintf(s,"EXACTINIT ")
    i=i+sprintf(s+i,"St=0x%04X",$uint2(answer+5))
  else if (cmd==S_RINIT) then
    if $uint4(answer+5)==0 && (mask & MS)==0 return -1
    if $uint4(answer+5)!=0 && (mask & (MS|BA))==0 return -1
    i=sprintf(s,"RINIT ")
    i=i+sprintf(s+i,"St=0x%08X",$uint4(answer+5))
  else if (cmd==S_CRTINIT) then
    if $uint4(answer+5)==0 && (mask & MS)==0 return -1
    if $uint4(answer+5)!=0 && (mask & (MS|BA))==0 return -1
    i=sprintf(s,"CRTINIT ")
    i=i+sprintf(s+i,"St=0x%08X",$uint4(answer+5))
  else if (cmd==S_INPORT) then
    i=sprintf(s,"INPORT ")
    if (len==7) then
      if (mask & IO)==0 return -1
      sprintf(s+i,"%5i 0x%X",$int2(answer+5),$uint2(answer+5))
    else
      if (mask & (IO|ER))==0 return -1
      sprintf(s+i,"- Wrong length of answer")
      color=RED
    endif
  else if (cmd==S_OUTPORT) then
    if (mask & IO)==0 return -1
    sprintf(s,"OUTPORT")
  else if (cmd==S_STROKE) then
    if (mask & (DB|DT|MS))==0 return -1
    sprintf(s,"STROKE")
  else if (cmd==S_LOCKDOOR) then
    if (mask & (DB|DT|MS))==0 return -1
    sprintf(s,"门锁")
  else if (cmd==S_MARK) then
    if (mask & (DM|MS))==0 return -1
    i=sprintf(s,"MARK")
    if len>5 then                      // Bar codes
      s[i]=' '; s[i+1]='\''; i=i+2; j=5
      while j<len && answer[j]!='\0' do
        s[i]=answer[j]; i++; j++
      enddo
      Memcpy(s+i,"', '",4); i=i+4; j++
      while j<len && answer[j]!='\0' do
        s[i]=answer[j]; i++; j++
      enddo
      s[i]='\''; i++; s[i]='\0'
    endif
  else if (cmd==S_SYSTEM) then
    if (mask & (LU|DB))==0 return -1
    if (mask & (LU|DB))==LU && answer[5]!=127 return -1
    if answer[5]==126 then
      i=sprintf(s,"SYSTEM ALIVE")
    else if answer[5]==127 then
      i=sprintf(s,"Dump: ")
      j=6
      while i<200 do
        if answer[j]==0 || j>=len then
          break
        else if answer[j]=='%' then
          j++; c=Toupper(answer[j]); j++;
          if c=='%' then
            s[i]=c; i++; j++;
          else if c=='I' then
            i=i+sprintf(s+i,"%i",$int2(answer+j)); j=j+2;
          else if c=='U' then
            i=i+sprintf(s+i,"%i",$uint2(answer+j)); j=j+2;
          else if c=='X' then
            i=i+sprintf(s+i,"%x",$uint2(answer+j)); j=j+2;
          else if c=='L' then
            i=i+sprintf(s+i,"%i",$int4(answer+j)); j=j+4;
          else if c=='F' then
            i=i+sprintf(s+i,"%f",$float4(answer+j)); j=j+4;
          else if c=='S' then
            while i<200 && answer[j]!=0 && j<len do
              s[i]=answer[j]; i++; j++
            enddo
            j++
          else
            s[i]=c; i++;
          endif
        else
          s[i]=answer[j]; i++; j++
        endif
      enddo
      s[i]=0
      color=GREEN
    else if answer[5]==192 then
      if len>8 Memcpy(buf,answer+8,len-8)
      buf[len-8]='\0'
      i=sprintf(s,"SYSTEM BARCODE '%s'",buf)
    else if answer[5]==193 then
      i=sprintf(s,"SHUTTLE ")
      if answer[6]==0 then
        i=i+sprintf(s+i,"OUT ")
      else if answer[6]==1 then
        i=i+sprintf(s+i,"TEST ")
      else if answer[6]==2 then
        i=i+sprintf(s+i,"PRELIMINARY ")
      else if answer[6]==3 then
        i=i+sprintf(s+i,"STOP PRELIMINARY ")
      else
        i=i+sprintf(s+i,"<%i> ",answer[6])
      endif
      if answer[7]==0 then
        i=i+sprintf(s+i,"ANY")
      else if answer[7]==1 then
        i=i+sprintf(s+i,"LEFT")
      else if answer[7]==2 then
        i=i+sprintf(s+i,"RIGHT")
      else if answer[7]==3 then
        i=i+sprintf(s+i,"BOTH")
      else
        i=i+sprintf(s+i,"<%i>",answer[7])
      endif
    else
      i=sprintf(s,"SYSTEM %i",answer[5])
    endif
  else if (cmd==S_MESSAGE) then
    if (len<21) then
      if (mask & (DT|ER))==0 return -1
      sprintf(s,"MESSAGE - Wrong length of answer")
      color=RED
    else if (mask & (DT|DB))==0 then
      return -1
    else
      i=sprintf(s,"MESSAGE ")
      switch answer[5]
      case 0:                          // Do nothing
        ;
      case 1:
        sprintf(s+i,"SHOW INFO %i ",$uint2(answer+6))
        ne=Decodespsinfo($uint2(answer+6),extra)
      case 2:
        sprintf(s+i,"SHOW ERROR %i ",$uint2(answer+6))
        ne=Decodespserror($uint2(answer+6),extra)
      case 3:
        sprintf(s+i,"CLOSE INFO")
      case 4:
        sprintf(s+i,"CLOSE ERROR")
      case 5:
        sprintf(s+i,"NOTIFICATION %i",$uint2(answer+6))
      case 6:
        sprintf(s+i,"L&M ERROR = ")
        for j=21,j<len && j<1000,j++ do
          s[i]=answer[j]; i++
        enddo
        s[i]='\0'
      endsw
    endif
  else if (cmd==S_INPORT32) then
    i=sprintf(s,"INPORT32 ")
    if (len==9) then
      if (mask & IO)==0 return -1
      sprintf(s+i,"%7i 0x%X",$int4(answer+5),$uint4(answer+5))
    else
      if (mask & (IO|ER))==0 return -1
      sprintf(s+i,"- Wrong length of answer")
      color=RED
    endif
  else if (cmd==S_OUTPORT32) then
    if (mask & IO)==0 return -1
    sprintf(s,"OUTPORT32")
  else if (cmd==S_LMAUTO) then
    if (mask & (IO|DT))==0 return -1
    i=sprintf(s,"LMAUTO ")
    if answer[5]==0 then
      i=i+sprintf(s+i,"PROTOCOL ")
      j=6; n=len-6
    else if answer[5]==1 then
      i=i+sprintf(s+i,"PROTOCOL ON")
      j=6; n=0
    else if answer[5]==2 then
      i=i+sprintf(s+i,"PROTOCOL OFF")
      j=6; n=0
    else if answer[5]==3 then
      j=6; n=len-6
    else if answer[5]==4 then
      i=i+sprintf(s+i,"CMD ")
      j=8; n=len-8
    else
      i=i+sprintf(s+i,"MODE=%i",answer[5])
      j=6; n=0
    endif
    while n>0 do
      if answer[j]=='\n' then
        j++; n--; break;
      else
        s[i]=answer[j]; i++; j++; n--
      endif
    enddo
    if answer[5]==4 && n>0 && answer[j]!='\n' then
      i=i+sprintf(s+i,", ERR=")
      while n>0 do
        if answer[j]=='\n' then
          j++; n--; break;
        else
          s[i]=answer[j]; i++; j++; n--
        endif
      enddo
    endif
    s[i]='\0'
    if answer[5]==4 then
      sta=$uint2(answer+6)
      i=i+Decodestatus(s+i,sta,mask,"Hdwr|||||||||||||Errmsg|Answ|Tmout")
    endif
  else if (cmd==S_RLINIT) then
    if $uint2(answer+5)==0 && (mask & MS)==0 return -1
    if $uint2(answer+5)!=0 && (mask & (MS|BA))==0 return -1
    i=sprintf(s,"RLINIT ")
    i=i+sprintf(s+i,"St=0x%04X",$uint2(answer+5))
  else if (cmd==S_VIDEOCAM) then
    if (mask & (IO|DT))==0 return -1
    i=sprintf(s,"VIDEOCAM ")
    if answer[5]==0 then
      i=i+sprintf(s+i,"%X DATA L=%i OFFS=%i",answer[6],len-23,$uint4(answer+15))
    else if answer[5]==1 then
      i=i+sprintf(s+i,"INIT")
      for j=0,j<16,j++ do
        if $uint2(answer+6+16*j)!=0 && $uint2(answer+8+16*j)!=0 then
          ne=ne+sprintf(extra+ne,"-   Channel %2i: %ix%i pixel\n",             \
          j,$uint2(answer+6+16*j),$uint2(answer+8+16*j))
        endif
      enddo
    else if answer[5]==2 then
      i=i+sprintf(s+i,"START ")
      if answer[6]==0 then i=i+sprintf(s+i,"OK");
      else if answer[6]==1 then i=i+sprintf(s+i,"NOCHAN");
      else i=i+sprintf(s+i,"ANSWER=%i",answer[6]); endif
    else if answer[5]==3 then
      i=i+sprintf(s+i,"STOP")
    else
      i=i+sprintf(s+i,"%i",answer[5])
    endif
  else if (cmd==S_PMDUMP) then
    if (mask & DB)==0 return -1
    sprintf(s,"PMDUMP L=%i",len-5)
  else if (cmd==S_MOVE) then
    if (len<8) then
      if (mask & (MS|BA|ER))==0 return -1
      sprintf(s,"MOVE - Wrong length of answer")
      color=RED
    else
      subcmd=answer[5]
      sta=$uint2(answer+6)
      if subcmd==0x01 then             // FIELD
        if (sta & 0x9E20)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E20)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"FIELD ")
        cair=($GLOBAL.a5!=0 && (sta & 0x0080)!=0)
        if cair then
          Memcpy(buf,answer,len)
          $int4(buf+20)=$int4(answer+(len-4))
          if Convertfield(buf,&zairc,&zairr)!=0 cair=0
        endif
        if Convertfield(answer,&zc,&zr)==0 then
          if cair then
            i=i+sprintf(s+i,"CAIR ")
            i=i+Pfpftotext(zc,zairc,s+i)
          else
            i=i+Pftotext(zc,s+i)
          endif
          i=i+sprintf(s+i," Z=")
          if cair then
            i=i+Pfpftotext(zr,zairr,s+i)
          else
            i=i+Pftotext(zr,s+i)
          endif
        endif
        if $GLOBAL.a5==0 then
          i=i+Decodestatus(s+i,sta,mask,"Hdwr|#1M:1K:10K:100K|Ovld|Bad|"       \
          "NoCtA|NoCt|1V:10V|||#SureShort:Short|Aircal|Nt||x1:x10")
        else
          i=i+Decodestatus(s+i,sta,mask,"Hdwr|#1M:1K:10K:100K|Ovld|Bad|"       \
          "NoCtA|NoCt|1V:10V|||#SureShort:Short|Aircal|F||x1:x10")
        endif
        if (sta & 0x0004)!=0 then
          k=28+(Max(answer[9]-answer[8]+1,0)+Max(answer[11]-answer[10]+1,0))*4
          if k<len then
            if $GLOBAL.a5==0 then
              ne=sprintf(extra,"-Head:Net ")
              for k=k,k<len,k=k+4 do
                ne=ne+sprintf(extra+ne,"%i:%i ",answer[k+3],$uint3(answer+k))
              enddo
            else if k+4<=len then
              sprintf(s+i," F=%i/%i Hz",$uint2(answer+k),$uint2(answer+k+2))
            endif
          endif
        endif
        if mask & FL then
          if ne!=0 then
            extra[ne]='\n'; ne++;
          endif
          k=(len-28)/4
          for i=0,i<k,i++ do
            if (i & 3)==0 ne=ne+sprintf(extra+ne,"-    ")
            ne=ne+sprintf(extra+ne,"%6i/%6i  ",                                \
            $int2(answer+28+4*i),$int2(answer+30+4*i))
            if (i & 3)==3 then
              extra[ne-1]='\n'
            else if i!=k-1 then
              extra[ne-2]=','
            endif
          enddo
        endif
      else if subcmd==0x02 then        // RMEAS
        if (sta & 0x9E00)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E00)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"RMEAS ")
        i=i+Milliohmstotext($float4(answer+8),sta,s+i)
        Decodestatus(s+i,sta,mask,                                             \
          "Hdwr|ExtMeas|Avg|Retested|Bad|NoCt2|NoCt1||||||||Details|Inaccurate")
        if (mask & FL)!=0 && len>=28 then
          ne=sprintf(extra,"-     U = %g V\n-     I = %g A",                   \
          $float4(answer+12),$float4(answer+16))
        endif
      else if subcmd==0x0E then        // HVMEAS
        if (sta & 0x967F)==0 && (mask & MS)==0 return -1
        if (sta & 0x967F)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"HVMEAS ")
        if (sta & 0x0020)!=0 then
          i=i+sprintf(s+i,"break %3i V",$float4(answer+8))
        else
          i=i+Ohmstotext($float4(answer+8),sta & 0xFEFF,s+i)
        endif
        Decodestatus(s+i,sta,mask,                                             \
          "Hdwr||Avg|Retested|Details|NoCt2|NoCt1|LowVolt|GndShort|"           \
          "IDiff||Supply|UExt|URes|Unstab|UUnstab")
        if (mask & FL)!=0 && len>=28 then
          ne=sprintf(extra,"-     U = %g V\n-     I = %g A",                   \
          $float4(answer+12),$float4(answer+16))
        endif
      else if subcmd==0x16 then        // LAMEAS
        if (sta & 0x8E32)==0 && (mask & MS)==0 return -1
        if (sta & 0x8E32)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"LAMEAS Value=%6.0f",$float4(answer+8))
        if (len>=16) then
          i=i+sprintf(s+i,", R=")      // Extended form (with resistance)
          i=i+Ohmstotext($float4(answer+12),sta,s+i)
        endif
        Decodestatus(s+i,sta,mask,                                             \
        "Hdwr||Nocal||Bad|NoCt2|NoCt1||HiR2|HiR1|Open|Damage|||Timeout|")
      else if subcmd==0x18 then        // EXACTR
        if (sta & 0x9E00)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E00)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"EXACTR ")
        i=i+Milliohmstotext($float4(answer+8),sta,s+i)
        Decodestatus(s+i,sta,mask,"Hdwr|ExtMeas|Avg|Retested|Bad|"             \
          "NoCt2|NoCt1||HiR2|HiR1|||||Details|Inaccurate")
        if (mask & FL)!=0 && len>=28 then
          ne=sprintf(extra,"-     U = %g V\n-     I = %g A",                   \
          $float4(answer+12),$float4(answer+16))
        endif
      else if subcmd==0x19 then        // EXTERN
        if (sta & 0x867A)==0 && (mask & MS)==0 return -1
        if (sta & 0x867A)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"EXTERN ")
        i=i+sprintf(s+i,"St=0x%04X L=%i",sta,$uint2(answer+8))
        s[i]=' '; i++
        s[i]='\"'; i++
        for j=10,i<250 && j<len && j<$uint2(answer+8)+10,j++
          if Isprint(answer[j]) then
            s[i]=answer[j]; i++
          else
            i=i+sprintf(s+i,"\\x%02X",answer[j])
          endif
        enddo
        s[i]='\"'; i++
        s[i]='\0'; i++
      else if subcmd==0x1B then        // CMEAS
        if (sta & 0x9E20)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E20)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"CMEAS ")
        i=i+Pftotext($float4(answer+8),s+i)
        zr=$float4(answer+12)/1000.0   // Convert into milliseconds
        if zr<0 || zr>1000.0 then
          i=i+sprintf(s+i," dT>1000 ms")
        else if zr>=1.0 then
          i=i+sprintf(s+i," dT=%#4.3g ms",zr)
        else
          i=i+sprintf(s+i," dT=%#4.2g ms",zr)
        endif
        Decodestatus(s+i,sta,mask,                                             \
        "Hdwr|||Retested|Bad|NoCt2|NoCt1||||Overflow")
      else if subcmd==0x1F then        // SHCONN
        if (sta & 0x8227)==0 && (mask & MS)==0 return -1
        if (sta & 0x8227)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"SHCONN R=")
        i=i+Ohmstotext($float4(answer+8),0,s+i)
        i=i+sprintf(s+i,", C=")
        i=i+Pftotext($float4(answer+12),s+i)
        i=i+sprintf(s+i,", H=")
        i=i+Ohmstotext($float4(answer+16),0,s+i)
        Decodestatus(s+i,sta,mask,                                             \
        "Hdwr||||||NoCt1||||Break|HVinit||BadHV|BadC|BadR")
      else if subcmd==0x25 then        // FASTC
        if (sta & 0x9E20)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E20)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"FASTC ")
        cair=0
        if Convertfastc(answer,&zc,&zr)==0 then
          if (sta & 0x0180)==0x0100 then
            Memcpy(buf,answer,len)
            $int4(buf+18)=$int4(answer+(len-4))
            if Convertfastc(buf,&zairc,&zairr)==0 cair=1
          endif
          if cair then
            i=i+sprintf(s+i,"CAIR ")
            i=i+Pfpftotext(zc,zairc,s+i)
          else
            i=i+Pftotext(zc,s+i)
          endif
          if (sta & 0x0180)==0x0000 || (sta & 0x0180)==0x0100 then
            i=i+sprintf(s+i," Z=")
            if cair then
              i=i+Pfpftotext(zr,zairr,s+i)
            else
              i=i+Pftotext(zr,s+i)
            endif
          else if (sta & 0x0180)==0x0180 then
            i=i+sprintf(s+i," R=")
            i=i+Ohmstotext(zr,0,s+i)
          else
            if zr<0 || zr>1000.0 then
              i=i+sprintf(s+i," dT>1000 ms")
            else if zr>=1.0 then
              i=i+sprintf(s+i," dT=%#4.3g ms",zr)
            else
              i=i+sprintf(s+i," dT=%#4.2g ms",zr)
            endif
          endif
          i=i+sprintf(s+i," Range=%2i",answer[8])
        endif
        i=i+Decodestatus(s+i,sta,mask,"Hdwr|#1M:1K:10K|Ovld|Bad|NoCt2|"        \
          "NoCt1|#Bridge:AC:Charge:AC||#SureShort:Short:NoShort|Aircal|||X1")
        if (sta & 0x0004)!=0 then
          if (sta & 0x0080)==0 then k=26;
          else k=18; endif
          if k<len then
            if $GLOBAL.a5==0 then
              ne=sprintf(extra,"-Head:Net ")
              for k=k,k<len,k=k+4 do
                ne=ne+sprintf(extra+ne,"%i:%i ",answer[k+3],$uint3(answer+k))
              enddo
            else if k+2<=len then
              sprintf(s+i," F=%i Hz",$uint2(answer+k))
            endif
          endif
        endif
      else if subcmd==0x2A then        // RLMEAS
        if (sta & 0x9E00)==0 && (mask & MS)==0 return -1
        if (sta & 0xBE00)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"RLMEAS ")
        i=i+Ohmstotext($float4(answer+8),sta,s+i)
        i=i+sprintf(s+i,", ")
        i=i+Henrytotext($float4(answer+12),s+i)
        Decodestatus(s+i,sta,mask,                                             \
        "Hdwr|ExtMeas|Nocal|Retested|Bad|NoCt2|NoCt1||||Open|||||Avg")
      else if subcmd==0x2C then        // CONTCAP
        if (sta & 0x9000)==0 && (mask & MS)==0 return -1
        if (sta & 0x9000)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"CONTCAP %i fF",$int4(answer+8))
        Decodestatus(s+i,sta,mask,"Hdwr|||Overload|||NoCt1")
      else if subcmd==0x2E then        // MSD
        if (sta & 0x9E24)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E24)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"CRT ")
        if (sta & 0x0020)!=0 then
          i=i+sprintf(s+i,"break %3i V",$float4(answer+13))
        else
          i=i+Pftotext($float4(answer+9),s+i)
          i=i+sprintf(s+i," R=")
          i=i+Ohmstotext($float4(answer+13),0,s+i)
          if answer[8]!=0 i=i+sprintf(s+i," Range=%2i",answer[8])
        endif
        Decodestatus(s+i,sta,mask,                                             \
        "Hdwr||Avg|Rep|Bad|NoCt2|NoCt1|Short|||Break|Supply|Aircal|Ures||")
      else if subcmd==0x3C then        // CONTKELV
        if (sta & 0x8000)==0 && (mask & MS)==0 return -1
        if (sta & 0x8000)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"CONTKELV ")
        i=i+Ohmstotext($float4(answer+8),sta,s+i)
        Decodestatus(s+i,sta,mask,"Hdwr||||||NoCt1")
      else if subcmd==0x43 then        // LAMBASE/LAMCAL
        if (sta & 0x8820)==0 && (mask & MS)==0 return -1
        if (sta & 0x8820)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"LAMCAL ")
        i=i+Ohmstotext($float4(answer+8),0,s+i)
        Decodestatus(s+i,sta,mask,"Hdwr||||Bad||||||Open|||||")
      else if subcmd==0x44 then        // LABASE/LACAL
        if (sta & 0x8820)==0 && (mask & MS)==0 return -1
        if (sta & 0x8820)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"LACAL ")
        i=i+Ohmstotext($float4(answer+8),0,s+i)
        Decodestatus(s+i,sta,mask,                                             \
        "Hdwr||Nocal|Unst|Bad|NoCt2|NoCt1||||Open|||||")
      else if subcmd==0x45 || subcmd==0x46 then // UI or UIEX
        if (sta & 0x8E00)==0 && (mask & MS)==0 return -1
        if (sta & 0x8E00)!=0 && (mask & (MS|BA))==0 return -1
        if subcmd==0x45 then
          i=sprintf(s,"UI")
        else
          i=sprintf(s,"UIEX")
        endif
        Decodestatus(s+i,sta,mask,                                             \
          "Hdwr|||Limit|Bad|NoCt2|NoCt1|||||||||")
        if mask & FL then
          if ne!=0 then
            extra[ne]='\n'; ne++;
          endif
          k=(len-8)/10
          for i=0,i<k && Sizeof(extra+ne)>40,i++ do
            if i>0 ne=ne+sprintf(extra+ne,"\n")
            ne=ne+sprintf(extra+ne,"-     I=%7.3f mA, ",                       \
              $float4(answer+14+10*i)*1000.0)
            ne=ne+sprintf(extra+ne,"U=%7.3f V, ",$float4(answer+10+10*i))
            ne=ne+sprintf(extra+ne,"status=%04X",$uint2(answer+8+10*i))
            if ($uint2(answer+8+10*i) & 0x9800)!=0 then
              ne=ne+sprintf(extra+ne," (")
              if $uint2(answer+8+10*i) & 0x8000 then
                ne=ne+sprintf(extra+ne,"Hardware,")
              endif
              if $uint2(answer+8+10*i) & 0x1000 then
                ne=ne+sprintf(extra+ne,"Limit,")
              endif
              if $uint2(answer+8+10*i) & 0x0800 then
                ne=ne+sprintf(extra+ne,"Bad,")
              endif
              ne--
              ne=ne+sprintf(extra+ne,")")
            endif
          enddo
          if i<k ne=ne+sprintf(extra+ne,"\n-     ...")
        endif
      else if subcmd==0x48 then        // MULTIC
        if (sta & 0x9E20)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E20)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"MULTIC ")
        if Convertfastc(answer,&zc,&zr)==0 then
          i=i+Pftotext(zc,s+i)
          i=i+sprintf(s+i," Z=")
          i=i+Pftotext(zr,s+i)
          i=i+sprintf(s+i," Range=%2i",answer[8])
        endif
        i=i+Decodestatus(s+i,sta,mask,"Hdwr|#1M:1K:10K:100K|Ovld|Bad|"         \
          "NoCt2|NoCt1||||#SureShort:Short:NoShort|Aircal|||X1")
        if (sta & 0x0004)!=0 then
          k=len-2
          sprintf(s+i," F=%i Hz",$uint2(answer+k))
        endif
        if mask & FL then
          if ne!=0 then
            extra[ne]='\n'; ne++;
          endif
          k=len-26
          if (sta & 0x0004)!=0 k=k-2
          k=k/4
          for i=0,i<k,i++ do
            ne=ne+sprintf(extra+ne,"-     ")
            Convertmultic(answer,i,&zc,&zr)
            ne=ne+Pftotext(zc,extra+ne)
            ne=ne+sprintf(extra+ne,"/")
            ne=ne+Pftotext(zr,extra+ne)
            ne=ne+sprintf(extra+ne,"\n")
          enddo
        endif
      else if subcmd==0x49 then        // UNIC
        if (sta & 0x9E20)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E20)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"UNIC ")
        if (sta & 0x0180)==0x0100 then
          i=i+sprintf(s+i,"CAIR ")
          i=i+Pfpftotext($float4(answer+10),$float4(answer+24),s+i)
        else
          i=i+Pftotext($float4(answer+10),s+i)
        endif
        i=i+sprintf(s+i," R=")
        if sta & 0x0040 then
          i=i+Ohmsshort($float4(answer+14),0,s+i)
          i=i+sprintf(s+i," Rpar=")
          i=i+Ohmsshort($float4(answer+18),0,s+i)
        else
          i=i+Ohmstotext($float4(answer+14),0,s+i)
        endif
        i=i+sprintf(s+i," G=%2i",answer[8])
        i=i+Decodestatus(s+i,sta,mask,"Hdwr|ExtMeas|Nocal|Ovld|Bad|NoCt2|"     \
          "NoCt1|#Bridge:AC:Charge:AC|Rpar|#SureShort:Short:NoShort|Aircal|||")
        if $uint2(answer+22)!=0 sprintf(s+i," F=%i Hz",$uint2(answer+22))
      else if subcmd==0x4A then        // DIV
        if (sta & 0x9E01)==0 && (mask & MS)==0 return -1
        if (sta & 0x9E01)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"DIVIDER %6.4f",$float4(answer+8))
        if sta & 0x0040 then
          i=i+sprintf(s+i," P=")
          i=i+Ohmstotext($float4(answer+12),0,s+i)
          i=i+sprintf(s+i," G=")
          i=i+Ohmstotext($float4(answer+16),0,s+i)
        endif
        if sta & 0x0020 then
          i=i+sprintf(s+i," Par=")
          i=i+Ohmstotext($float4(answer+20),0,s+i)
        endif
        i=i+Decodestatus(s+i,sta,mask,                                         \
        "Hdwr|||Rep|Bad|NoCt2|NoCt1|||||||||Inacc")
      else if subcmd==0x4B then        // COMP
        if (sta & 0x9DF1)==0 && (mask & MS)==0 return -1
        if (sta & 0x9DF1)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"COMP")
        if answer[8]!=0 then
          i=i+sprintf(s+i," Error %i ",answer[8])
          switch answer[8]
            case   1: i=i+sprintf(s+i,"(uninitialized hardware) ")
            case   2: i=i+sprintf(s+i,"(invalid command size) ")
            case   3: i=i+sprintf(s+i,"(unsupported microcommand) ")
            case   4: i=i+sprintf(s+i,"(invalid head) ")
            case   5: i=i+sprintf(s+i,"(type of source changes) ")
            case   6: i=i+sprintf(s+i,"(SET to undefined source) ")
            case   7: i=i+sprintf(s+i,"(shortcut between sources) ")
            case   8: i=i+sprintf(s+i,"(resistor is shortcut) ")
            case   9: i=i+sprintf(s+i,"(resistance out of range) ")
            case  10: i=i+sprintf(s+i,"(no matching resistor) ")
            case  11: i=i+sprintf(s+i,"(I measurement without source) ")
            case  12: i=i+sprintf(s+i,"(no mapping to hardware) ")
            case  13: i=i+sprintf(s+i,"(internal error) ")
            case  14: i=i+sprintf(s+i,"(unsupported function) ")
            case  15: i=i+sprintf(s+i,"(mixed HV and low voltage) ")
            case  16: i=i+sprintf(s+i,"(uninitialized HV) ")
            case  17: i=i+sprintf(s+i,"(HVI or HVU without HV) ")
            case  18: i=i+sprintf(s+i,"(error in HV measurement) ")
            case  19: i=i+sprintf(s+i,"(invalid parameters) ")
            case  20: i=i+sprintf(s+i,"(intermediate movement failed) ")
            case  21: i=i+sprintf(s+i,"(uninitialized backdrill measurement) ")
            case  22: i=i+sprintf(s+i,"(not a backdrill needle) ")
            case  23: i=i+sprintf(s+i,"(too many measurements) ")
            case 255: i=i+sprintf(s+i,"(answer is emulated) ")
          endsw
          i=i+sprintf(s+i,"in subcommand %i",answer[9] & 0x7F)
        endif
        i=i+Decodestatus(s+i,sta,mask,                                         \
        "Hdwr|Status||Rep|Bad|NoCt||Assert|Depth|Short|Break|Ovld||||Ovfl")
        if mask & FL then
          if ne!=0 then
            extra[ne]='\n'; ne++;
          endif
          if (sta & 0x4000)!=0 then
            k=(len-10)/8               // Pairs value/status
          else
            k=(len-10)/4               // Values only
          endif
          for i=0,i<k && Sizeof(extra+ne)>40,i++ do
            if i>0 ne=ne+sprintf(extra+ne,"\n")
            if (sta & 0x4000)!=0 then
              value=$float4(answer+10+i*8)
              status=$int4(answer+14+i*8)
            else
              value=$float4(answer+10+i*4)
              status=0
            endif
            factor=0
            if (status & 0x000F0000)!=0 then
              if value!=0.0 && (status & 0x000F0000)!=0x00050000 &&            \
                (status & 0x000F0000)!=0x00060000                              \
              then
                while Abs(value)>1000.0 && factor<3 do
                  value=value/1000.0; factor++
                enddo
                while Abs(value)<0.999999 && factor>(-4) do
                  value=value*1000.0; factor--
                enddo
              endif
              ne=ne+sprintf(extra+ne,"-     [%2i] = %8.5g ",i,value)
              switch factor
                case 3:  ne=ne+sprintf(extra+ne,"G")
                case 2:  ne=ne+sprintf(extra+ne,"M")
                case 1:  ne=ne+sprintf(extra+ne,"k")
                case 0:
                case -1: ne=ne+sprintf(extra+ne,"m")
                case -2: ne=ne+sprintf(extra+ne,"u")
                case -3: ne=ne+sprintf(extra+ne,"n")
                case -4: ne=ne+sprintf(extra+ne,"p")
                case -5: ne=ne+sprintf(extra+ne,"f")
                default: ne=ne+sprintf(extra+ne,"?")
              endsw
              switch (status & 0x000F0000)
                case 0x00010000: ne=ne+sprintf(extra+ne,"V")
                case 0x00020000: ne=ne+sprintf(extra+ne,"A")
                case 0x00030000: ne=ne+sprintf(extra+ne,"Ohm")
                case 0x00040000: ne=ne+sprintf(extra+ne,"F")
                case 0x00050000: ne=ne+sprintf(extra+ne,"deg")
                case 0x00060000: ne=ne+sprintf(extra+ne,"um")
                default: ne=ne+sprintf(extra+ne,"???")
              endsw
              if (status & 0x99F1)!=0 then
                ne=ne+sprintf(extra+ne," Status %04X (",status & 0xFFFF)
                if status & 0x8000 ne=ne+sprintf(extra+ne,"Hdwr,")
                if status & 0x1000 ne=ne+sprintf(extra+ne,"Rep,")
                if status & 0x0800 ne=ne+sprintf(extra+ne,"Bad,")
                if status & 0x0100 ne=ne+sprintf(extra+ne,"Assert,")
                if status & 0x0080 ne=ne+sprintf(extra+ne,"Depth,")
                if status & 0x0040 ne=ne+sprintf(extra+ne,"Short,")
                if status & 0x0020 ne=ne+sprintf(extra+ne,"Break,")
                if status & 0x0010 ne=ne+sprintf(extra+ne,"Ovld,")
                if status & 0x0001 ne=ne+sprintf(extra+ne,"Ovfl,")
                ne--
                ne=ne+sprintf(extra+ne,")")
              endif
            else
              if Abs(value)>0.001 then
                ne=ne+sprintf(extra+ne,"-     [%2i] = %8.5g",i,value)
              else
                ne=ne+sprintf(extra+ne,"-     [%2i] = %8.3e",i,value)
              endif
            endif
          enddo
          if i<k ne=ne+sprintf(extra+ne,"\n-     ...")
        endif
      else if subcmd==0x4C then        // WARM
        if sta==0 && (mask & MS)==0 return -1
        if sta!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"WARMUP")
        Decodestatus(s+i,sta,mask,"")
      else if subcmd==0x50 then        // RLDIFF
        if (sta & 0x9E00)==0 && (mask & MS)==0 return -1
        if (sta & 0xBE00)!=0 && (mask & (MS|BA))==0 return -1
        i=sprintf(s,"RLDIFF ")
        i=i+Ohmstotext($float4(answer+8),sta,s+i)
        i=i+sprintf(s+i,", ")
        i=i+Henrytotext($float4(answer+12),s+i)
        Decodestatus(s+i,sta,mask,                                             \
        "Hdwr|ExtMeas|Noref|Retested|Bad|NoCt2|NoCt1||Ref|Dist|Open|||||Avg")
      else
        if (mask & (MS|BA|ER))==0 return -1
        sprintf(s,"MOVE - Unknown type of measurement 0x%2X",subcmd)
        color=RED
      endif
    endif
  else if (cmd==0xF0) then             // Message from other process
    if (mask & SM)==0 return -1
    i=sprintf(s,"recv msg info %i: ",answer[3])
    for j=5,j<len && j<220,j++
      if answer[j]=='\0' break
      s[i]=answer[j]; i++
    enddo
    s[i]='\0'
    color=MAGENTA
  else if (cmd==0xFE) then             // Incomplete answer (power on/off?)
    if (mask & (MS|BA|ER))==0 return -1
    sprintf(s,"Incomplete answer from crate discarded")
    color=RED
  else if (cmd==0xFF) then             // Lost answer
    if (mask & (MS|BA|SR|ER))==0 return -1
    sprintf(s,"Command lost due to soft or hard reset")
    color=RED
  else
    if (mask & 0xFFFF)==0 return -1
    sprintf(s,"Unknown answer 0x%2X length=%i",cmd,len)
    color=RED
  endif
  if decodecmd!=0 then
    if ne!=0 then
      extra[ne]='\n'; ne++;
    endif
    extra[ne]='-'; ne++
    SERV.Decodecommand(answer+5,extra+ne,0xFFFFFFFF)
    j=Strlen(extra+ne)
    while j>55 do
      n=0
      for i=0,i<j,i++
        if (extra[ne+i]==' ') then
          if i>=55 && n!=0 break
          n=i
        endif
      enddo
      if n>0 then
        ne=ne+n; j=j-n
        Memcpy(extra+ne+3,extra+ne,j)
        extra[ne]='\n'; extra[ne+1]='-';
        extra[ne+2]=' '; ne=ne+3
      else
        break
      endif
    enddo
    ne=ne+j
  endif
  if (mask & 0x80000000)!=0 then
    if ne!=0 then
      extra[ne]='\n'; ne++;
    endif
    for i=0,i<len,i++
      if Sizeof(extra+ne)<20 break
      if (i & 0x0F)==0 then
        if i!=0 then
          extra[ne]='\n'; ne++;
        endif
        ne=ne+sprintf(extra+ne,"-+%03X",i)
      endif
      if (i & 0x03)==0 then
        extra[ne]=' '; ne++;
      endif
      ne=ne+sprintf(extra+ne," %02X",answer[i])
    enddo
    if i<len ne=ne+sprintf(extra+ne,"\n-...")
    extra[ne]='\0'
  endif
  

  serv_log(s)
  
  
  return color
end

// Skips spaces and specified character from the line. Returns number of skipped
// bytes.
function int SERV.Skipchar(char *cmd,char c)
  int i
  while cmd[i]==' ' || cmd[i]=='\t' do i++; enddo
  if cmd[i]==c then
    i++
    while cmd[i]==' ' || cmd[i]=='\t' do i++; enddo
  endif
  return i
end

// Scans signed decimal, hexadecimal or character integer value from the cmd.
// Returns number of scanned bytes or -1 if there is no integer number in the
// cmd.
function int SERV.Scanint(char *cmd,int *value)
  int i,j,k,n,sign
  i=Skipchar(cmd,' ')                  // Skip leading spaces
  if cmd[i]=='\'' then
    // Character.
    i++
    if cmd[i]=='\0' then
      value[0]=0; return -1
    else if cmd[i]!='\\' then
      n=cmd[i]
    else
      i++
      if cmd[i]=='\0' then
        value[0]=0; return -1
      else if cmd[i]=='n' then
        n='\n'
      else if cmd[i]=='r' then
        n='\r'
      else if cmd[i]=='t' then
        n='\t'
      else if cmd[i]=='0' then
        n='\0'
      else
        n=cmd[i]
      endif
    endif
    i++
    if cmd[i]!='\'' then
      value[0]=0; return -1
    else
      i++
    endif
  else
    // Integer or hexadecimal value.
    if cmd[i]=='-' then sign=-1; i++;
    else if cmd[i]=='+' then i++;
    endif
    if cmd[i]=='\0' return -1
    if cmd[i]=='0' && Toupper(cmd[i+1])=='X' then
      i=i+2; k=0                       // Hexadecimal number
      while 1 do
        j=Toupper(cmd[i])
        if j>='0' && j<='9' then
          n=n*16+j-'0'; i++
        else if j>='A' && j<='F' then
          n=n*16+j-'A'+10; i++
        else
          break
        endif
        k++
      enddo
      if k==0 return -1                // Invalid hexadecimal number
    else                               // Decimal number
      if Isdigit(cmd[i])==0 return -1  // Not an integer
      while Isdigit(cmd[i])!=0 do
        n=n*10+cmd[i]-'0'; i++
      enddo
    endif
    if sign<0 n=-n
  endif
  value[0]=n
  return i
end

// Scans signed float number from the cmd. Returns number of scanned bytes or
// -1 if there is no float number in the cmd.
function int SERV.Scanfloat(char *cmd,float *value)
  int i,sign,exp,expsign
  float f,mult
  i=Skipchar(cmd,' ')                  // Skip leading spaces
  if cmd[i]=='-' then sign=-1; i++;
  else if cmd[i]=='+' then i++;
  endif
  if Isdigit(cmd[i])==0 return -1      // Not a number
  while Isdigit(cmd[i])!=0 do
    f=f*10.0+cmd[i]-'0'; i++
  enddo
  if cmd[i]=='.' then
    i++; mult=0.1
    while Isdigit(cmd[i]) do
      f=f+(cmd[i]-'0')*mult
      mult=mult/10.0; i++
    enddo
  endif
  if Toupper(cmd[i])=='E' then         // Exponent
    i++
    if cmd[i]=='-' then expsign=-1; i++;
    else if cmd[i]=='+' then i++;
    endif
    while Isdigit(cmd[i])!=0 do
      exp=exp*10+cmd[i]-'0'; i++
    enddo
    if expsign<0 exp=-exp
    f=f*Pow10(exp)
  endif
  if sign<0 f=-f
  value[0]=f
  return i
end

// Scans keyword from the cmd (at most 31+1 characters long) and converts it to
// uppercase. Digits are not allowed. Returns number of scanned bytes. If there
// is no keyword, sets key to empty string.
function int SERV.Scanname(char *s,char *key)
  int i,n
  i=Skipchar(s,' ')
  if Isalpha(s[i])==0 then
    key[0]='\0'; return i
  endif
  key[0]=Toupper(s[i]); n=1; i++
  while n<31 do
    if s[i]=='\0' break                // End of string reached
    if Isalpha(s[i])==0 break
    key[n]=Toupper(s[i]); n++; i++
  enddo
  key[n]='\0'
  return i+Skipchar(s+i,' ')
end

// Scans keyword from the cmd (at most 31+1 characters long) and converts it to
// uppercase. Digits after the first character are allowed. Returns number of
// scanned bytes. If there is no keyword, sets key to empty string.
function int SERV.Scanalphanum(char *s,char *key)
  int i,n
  i=Skipchar(s,' ')
  if Isalpha(s[i])==0 then
    key[0]='\0'; return i
  endif
  key[0]=Toupper(s[i]); n=1; i++
  while n<31 do
    if s[i]=='\0' break                // End of string reached
    if Isalnum(s[i])==0 break
    key[n]=Toupper(s[i]); n++; i++
  enddo
  key[n]='\0'
  return i+Skipchar(s+i,' ')
end

// Service function, converts two hexadecimal characters into the hex number.
function int Hexbyte(char *s)
  int x
  if s[0]=='\0' return 0
  if s[0]>='0' && s[0]<='9' then
    x=(s[0]-'0')*16
  else if s[0]>='A' && s[0]<='F' then
    x=(s[0]-'A'+10)*16
  else if s[0]>='a' && s[0]<='f' then
    x=(s[0]-'a'+10)*16
  else
    x=0
  endif
  if s[1]>='0' && s[1]<='9' then
    x=x+s[1]-'0'
  else if s[1]>='A' && s[1]<='F' then
    x=x+s[1]-'A'+10
  else if s[1]>='a' && s[1]<='f' then
    x=x+s[1]-'a'+10
  endif
  return x
end

#define DLEN           48             // Length of descriptor string
#define CMDNAME        0              // Offset of command or prefix name
#define ISMEAS         11             // Offset of "is a command" flag
#define BINCODE        12             // Binary code of command
#define ALTCODE        14             // Alternative binary code
#define MODE           16             // Command extension
#define PARMS          18             // List of parameters

// List of measurement commands, control commands and prefixes.
// CMDNAME:   name of command or prefix, '#' marks end of the list;
// ISMEAS:    '+' if this is a measurement command, '*' if this is a command
//            that allows digits in the parameter (like "U2" - in this case '='
//            after parameter is obligatory);
// BINCODE:   hexadecimal binary code of command or prefix;
// ALTCODE:   alternative binary code. If present, primary code is used if
//            command specifies no parameters except for heads and alternative
//            if any non-head parameter is used, even default;
// MODE:      If supplied, extension of the command byte, precedes head list
// PARMS:     parameters that follow command and mode in the binary code,
//            exactly in the order of their appearance:
//            H - single head, may repeat if command uses fixed number of heads
//            G - single head optionally followed by search distance
//            U - single head or ground connection in component test
//            O - optional head in component measurements. If any opional head
//                is present, alternative subcommand is used and optional heads
//                are filled (missing heads are set to 0xFF). If alternative
//                subcommand equals to the main, optional heads are always
//                present
//            R - range and additional flags (1 byte)
//            X - implicit range set to 0
//            T - antenna list, as in the field command
//            N[o] - number of heads, followed by the list of heads. Options:
//                   0 - 0 or more heads, 1..9 - exactly the specified count,
//                   * - 1 or 3 heads
//            F - antenna number and heads, like in field measurement
//            < - assertion prefix
//            Ann - arguments, nn is the size of parameters in bytes
//            Bnn - same, but argument names are 1 character long
//            C - a sequence of COMP subcommands
//            D - debug data, mix of strings and bytes
//            S - ASCII string to external device, preceded with length
//            L - panel,group[,net], substitutes binary code
//            M - panel, group, multiple head:net paits
//            E - multiple head:pad pairs
//            Pxxx - postprocessing, depends on type (any number of characters,
//                   must be last in the list
// Arguments: > - initialization,size+offset:idata
//            = - argument (may be unnamed) belongs to A field, subparameters:
//                M - binary field, size+offset(min,max,factor):mask
//                B - binary flag, size+offset:value:mask
//                I - integer input, size+offset(min,max)
//                F - floating input or coordinates with individual corrections,
//                    (min,max,factor)[Isize/F]+offset[(lim)Isize+offset],
//                    factor may be parametrized by adding :base,type pair,
//                    where base is the additional multiplier for the physical
//                    quantity and type is one of the U,I,R,C,P,F,T meaning
//                    volts, amperes, Ohms, farades, watts, Herz and seconds.
//                    If units are not specified, main factor alone is used.
//                    Units are case-insensitive except for the prefixes m and
//                    M in  resistance units m, M, mOhm and MOhm. (Megavolts or
//                    megafarades are extremely seldom anyway). If (lim) is
//                    present, it scans and adds individual corrections.
//                T - same as F; if value exceeds max, divides it by 1000 and
//                    sets binary field or flag which name follows F:
//                    (min,max,factor)[Isize/F]+offset:<fieldname>
//                X - simplified coordinates as used by M_COMP, X+offset,
//                    converted from input in form [panel:]pad[,DX=dx][,DY=dy].
//                    Ann must be immediately preceded by the H parameter!
//                C - extdev connections,+offset
//                S - ASCII string, size+offset
//                * - list, extends arguments F(min,max,factor)Icntsize+cntoffs,
//                    factor may be parametrized but only I and U are currently
//                    supported
//                , - next argument follows
//            : - additional range flags, same as above (only B is used now)
//
// Name.......MBBAAMMParms.......................
static char w[391][DLEN] = {                                                   \
  "N          +00",                                                            \
  "NOP        +00",                                                            \
  "F          +01    HT",                                                      \
  "R          +024E  HNA16",                                                   \
  " =FREE      B4+0:0x10:0x10",                                                \
  " =L         B4+0:0x20:0x20",                                                \
  " =LONG      B4+0:0x20:0x20",                                                \
  " =SIMPLE    B4+0:0x100:0x100",                                              \
  " =IMAX      F(0,1,1e6:1,I)I4+8",                                            \
  " =UMAX      F(0,15,1000:1,U)I2+12",                                         \
  " =RMAX      F(0,20000,1:1e-6,R)I2+14",                                      \
  " =DLY       I1+2(0,255)",                                                   \
  " =DELAY     I1+2(0,255)",                                                   \
  "CAL        +09    HNA9",                                                    \
  " =W         I2+0(1,16383)",                                                 \
  " =D         I1+2(0,255)",                                                   \
  " =C         B1+5:0x10:0x70",                                                \
  " =K         B1+5:0x20:0x70",                                                \
  " =G         B1+5:0x30:0x70",                                                \
  " =H         B1+5:0x40:0x70",                                                \
  " =L         B1+5:0x08:0x08",                                                \
  " =LONG      B1+5:0x08:0x08",                                                \
  "CALCENV    +09    HA10",                                                    \
  " >          I1+6:0x30",                                                     \
  " =W         I2+1(1,16383)",                                                 \
  " =D         I1+3(0,255)",                                                   \
  " =L         B1+6:0x08:0x08",                                                \
  " =LONG      B1+6:0x08:0x08",                                                \
  "CALKELV    +09    HA10",                                                    \
  " >          I1+6:0x20",                                                     \
  " =W         I2+1(1,16383)",                                                 \
  " =D         I1+3(0,255)",                                                   \
  " =L         B1+6:0x08:0x08",                                                \
  " =LONG      B1+6:0x08:0x08",                                                \
  "FIND       +0D    HN1A9",                                                   \
  " =W         I2+0(1,16383)",                                                 \
  " =D         I1+2(0,255)",                                                   \
  " =M         I2+3(0,16383)",                                                 \
  " =C         B1+5:0x10:0x70",                                                \
  " =K         B1+5:0x20:0x70",                                                \
  " =N         B1+5:0x04:0x04",                                                \
  " =P         B1+5:0x02:0x02",                                                \
  " =S         B1+5:0x01:0x01",                                                \
  "H          *0E51  HNA37",                                                   \
  " =RLOW      F(-1,20000,1:1e-6,R)I2+3",                                      \
  " =ULOW      F(0,10,1000:1,U)I2+5",                                          \
  " =U         F(0,1000,1:1,U)I2+7",                                           \
  " =UMAX      F(0,1000,1:1,U)I2+7",                                           \
  " =U1        F(0,1000,1:1,U)I2+7",                                           \
  " =RMAX      F(0,20000,1:1e-6,R)I4+9",                                       \
  " =R1        F(0,20000,1:1e-6,R)I4+9",                                       \
  " =T         F(0,3.6e6,1:1000,T)I4+13",                                      \
  " =T1        F(0,3.6e6,1:1000,T)I4+13",                                      \
  " =U2        F(0,1000,1:1,U)I2+21",                                          \
  " =R2        F(0,20000,1:1e-6,R)I4+23",                                      \
  " =T2        F(0,3.6e6,1:1000,T)I4+27",                                      \
  " =GAP       F(0,60000,1:1000,T)I2+35",                                      \
  " =DLY       I1+2(0,255)",                                                   \
  " =DELAY     I1+2(0,255)",                                                   \
  "HV         *0E51  HNA37",                                                   \
  " =RLOW      F(-1,20000,1:1e-6,R)I2+3",                                      \
  " =ULOW      F(0,10,1000:1,U)I2+5",                                          \
  " =U         F(0,1000,1:1,U)I2+7",                                           \
  " =UMAX      F(0,1000,1:1,U)I2+7",                                           \
  " =U1        F(0,1000,1:1,U)I2+7",                                           \
  " =RMAX      F(0,20000,1:1e-6,R)I4+9",                                       \
  " =R1        F(0,20000,1:1e-6,R)I4+9",                                       \
  " =T         F(0,3.6e6,1:1000,T)I4+13",                                      \
  " =T1        F(0,3.6e6,1:1000,T)I4+13",                                      \
  " =U2        F(0,1000,1:1,U)I2+21",                                          \
  " =R2        F(0,20000,1:1e-6,R)I4+23",                                      \
  " =T2        F(0,3.6e6,1:1000,T)I4+27",                                      \
  " =GAP       F(0,60000,1:1000,T)I2+35",                                      \
  " =DLY       I1+2(0,255)",                                                   \
  " =DELAY     I1+2(0,255)",                                                   \
  "DEBUG      +12    D",                                                       \
  "D          +12    D",                                                       \
  "DLY        +12    A4",                                                      \
  " >          I1+0:0x3A",                                                     \
  " >          I1+1:0x02",                                                     \
  " =          I2+2(1,10000)",                                                 \
  "L          +16    HN",                                                      \
  "LA         +16    HN",                                                      \
  "LB         +17  00HNA8",                                                    \
  " >          I2+0:800",                                                      \
  " =CAL       F(0,1000,10)I2+0",                                              \
  " =DLY       I2+2(0,10000)",                                                 \
  " =THR       F(0,32767,1)I2+4",                                              \
  " =IMAX      F(0,2.5,50:1,I)I1+7",                                           \
  " =N         M1+7(0,7,16):0x70",                                             \
  " =C         B1+7:1:1",                                                      \
  "LC         +17  01HNA8",                                                    \
  " >          I2+0:800",                                                      \
  " =CAL       F(0,1000,10)I2+0",                                              \
  " =DLY       I2+2(0,10000)",                                                 \
  " =THR       F(0,32767,1)I2+4",                                              \
  " =IMAX      F(0,2.5,50:1,I)I1+7",                                           \
  " =N         M1+7(0,7,16):0x70",                                             \
  " =C         B1+7:1:1",                                                      \
  "E          +181C  HNA16",                                                   \
  " =DLY       I1+2(0,255)",                                                   \
  " =DELAY     I1+2(0,255)",                                                   \
  " =FREE      B4+0:0x10:0x10",                                                \
  " =L         B4+0:0x20:0xA0",                                                \
  " =LONG      B4+0:0x20:0xA0",                                                \
  " =XL        B4+0:0x80:0xA0",                                                \
  " =XXL       B4+0:0xA0:0xA0",                                                \
  " =POL       B4+0:0x40:0x40",                                                \
  " =CONS      B4+0:0x04:0x0C",                                                \
  " =CMED      B4+0:0x08:0x0C",                                                \
  " =CHI       B4+0:0x0C:0x0C",                                                \
  " =HIR       B4+0:0x02:0x02",                                                \
  " =HIGHR     B4+0:0x02:0x02",                                                \
  " =FIX       B4+0:0x01:0x01",                                                \
  " =AUTO      B4+0:0:0x3000",                                                 \
  " =INT       B4+0:0x1000:0x3000",                                            \
  " =EXT       B4+0:0x2000:0x3000",                                            \
  " =EXTA      B4+0:0x2000:0x3000",                                            \
  " =EXTB      B4+0:0x3000:0x3000",                                            \
  " =PMAX      F(0,1,1e6:1,P)I4+4",                                            \
  " =IMAX      F(0,1,1e6:1,I)I4+8",                                            \
  " =UMAX      F(0,15,1000:1,U)I2+12",                                         \
  " =RMAX      F(0,20000,1:1e-6,R)I2+14",                                      \
  "EXT        +19    HNA11SPEXT",                                              \
  " =CHAN      M1+0(0,7,1):0x07",                                              \
  " =WAIT      I1+2(0,255)",                                                   \
  " =CONN      C+9",                                                           \
  " =EOL       I1+4(0,255)",                                                   \
  " =END       S3+6",                                                          \
  "X          +19    HNA11SPEXT",                                              \
  " =CHAN      M1+0(0,7,1):0x07",                                              \
  " =WAIT      I1+2(0,255)",                                                   \
  " =CONN      C+9",                                                           \
  " =EOL       I1+4(0,255)",                                                   \
  " =END       S3+6",                                                          \
  "C          +1B    HN",                                                      \
  "SHC        +1F    HB16",                                                    \
  " =R         B4+0:1:1",                                                      \
  " =C         B4+0:2:2",                                                      \
  " =H         B4+0:4:4",                                                      \
  "Z          +20    H",                                                       \
  "A          +25    HRN",                                                     \
  " :N         B1+0:0x80:0x80",                                                \
  " :T         B1+0:0x40:0x40",                                                \
  " :F         B1+0:0x20:0x20",                                                \
  "RT         +26    HHA8",                                                    \
  " =T         F(0,4294,1E6:1,R)F+0",                                          \
  " =R         F(0,4294,1E6:1,R)F+0",                                          \
  "Q          +27    HHHHA5",                                                  \
  " =H         B1+0:0x80:0x80",                                                \
  " =L         B1+0:0x10:0x30",                                                \
  " =LONG      B1+0:0x10:0x30",                                                \
  " =XL        B1+0:0x20:0x30",                                                \
  " =XXL       B1+0:0x30:0x30",                                                \
  " =CONS      B1+0:0x04:0x08",                                                \
  " =CMED      B1+0:0x08:0x08",                                                \
  " =CHI       B1+0:0x0C:0x08",                                                \
  " =UMAX      F(0,15,1000:1,U)I2+1",                                          \
  " =DLY       I1+3(0,255)",                                                   \
  " =DELAY     I1+3(0,255)",                                                   \
  "ERT        +28    GGA16",                                                   \
  " =FREE      B4+0:0x10:0x10",                                                \
  " =L         B4+0:0x20:0xA0",                                                \
  " =LONG      B4+0:0x20:0xA0",                                                \
  " =XL        B4+0:0x80:0xA0",                                                \
  " =XXL       B4+0:0xA0:0xA0",                                                \
  " =POL       B4+0:0x40:0x40",                                                \
  " =CONS      B4+0:0x04:0x0C",                                                \
  " =CMED      B4+0:0x08:0x0C",                                                \
  " =CHI       B4+0:0x0C:0x0C",                                                \
  " =HIR       B4+0:0x02:0x02",                                                \
  " =HIGHR     B4+0:0x02:0x02",                                                \
  " =FIX       B4+0:0x01:0x01",                                                \
  " =DLY       I1+2(0,255)",                                                   \
  " =DELAY     I1+2(0,255)",                                                   \
  " =PMAX      F(0,1,1e6:1,P)I4+4",                                            \
  " =IMAX      F(0,1,1e6:1,I)I4+8",                                            \
  " =UMAX      F(0,15,1000:1,U)I2+12",                                         \
  " =RMAX      F(0,20000,1:1e-6,R)I2+14",                                      \
  "ES         +28    GGA16",                                                   \
  " >          I4+0:0x200",                                                    \
  " =FREE      B4+0:0x10:0x10",                                                \
  " =L         B4+0:0x20:0xA0",                                                \
  " =LONG      B4+0:0x20:0xA0",                                                \
  " =XL        B4+0:0x80:0xA0",                                                \
  " =XXL       B4+0:0xA0:0xA0",                                                \
  " =POL       B4+0:0x40:0x40",                                                \
  " =CONS      B4+0:0x04:0x0C",                                                \
  " =CMED      B4+0:0x08:0x0C",                                                \
  " =CHI       B4+0:0x0C:0x0C",                                                \
  " =HIR       B4+0:0x02:0x02",                                                \
  " =HIGHR     B4+0:0x02:0x02",                                                \
  " =FIX       B4+0:0x01:0x01",                                                \
  " =DLY       I1+2(0,255)",                                                   \
  " =DELAY     I1+2(0,255)",                                                   \
  " =PMAX      F(0,1,1e6:1,P)I4+4",                                            \
  " =IMAX      F(0,1,1e6:1,I)I4+8",                                            \
  " =UMAX      F(0,15,1000:1,U)I2+12",                                         \
  " =RMAX      F(0,20000,1:1e-6,R)I2+14",                                      \
  "RTL        +4F    GGA16",                                                   \
  " =FREE      B4+0:0x10:0x10",                                                \
  " =L         B4+0:0x20:0x20",                                                \
  " =LONG      B4+0:0x20:0x20",                                                \
  " =T         F(0,2e8,1:1,R)F+4",                                             \
  " =R         F(0,2e8,1:1,R)F+4",                                             \
  " =IMAX      F(0,1,1e6:1,I)I4+8",                                            \
  " =UMAX      F(0,15,1000:1,U)I2+12",                                         \
  " =RMAX      F(0,20000,1:1e-6,R)I2+14",                                      \
  " =DLY       I1+2(0,255)",                                                   \
  " =DELAY     I1+2(0,255)",                                                   \
  "RS         +4F    GGA16",                                                   \
  " >          I4+0:0x200",                                                    \
  " =FREE      B4+0:0x10:0x10",                                                \
  " =L         B4+0:0x20:0x20",                                                \
  " =LONG      B4+0:0x20:0x20",                                                \
  " =T         F(0,2e8,1:1,R)F+4",                                             \
  " =R         F(0,2e8,1:1,R)F+4",                                             \
  " =IMAX      F(0,1,1e6:1,I)I4+8",                                            \
  " =UMAX      F(0,15,1000:1,U)I2+12",                                         \
  " =RMAX      F(0,20000,1:1e-6,R)I2+14",                                      \
  " =DLY       I1+2(0,255)",                                                   \
  " =DELAY     I1+2(0,255)",                                                   \
  "RL         +2A    HN",                                                      \
  "BURN       +2B    HNA12",                                                   \
  " =I         F(-1e3,1e3,1e3)I4+4,B2+0:0:255",                                \
  " =IA        F(-1e3,1e3,1e3)I4+4,B2+0:1:255",                                \
  " =T         I2+2(0,10000)",                                                 \
  "CONTCAP    +2C    HN0",                                                     \
  "CRT        +2E    HXN",                                                     \
  "MSD        +2E    HXN",                                                     \
  "LART       +32    GGA16",                                                   \
  " =DLY       I1+0(0,255)",                                                   \
  " =DELAY     I1+0(0,255)",                                                   \
  "CONTKELV   +3C    H",                                                       \
  "LAMAN      +42    ",                                                        \
  "LAMBASE    +43  00A16",                                                     \
  "LAMCAL     +43  01A16",                                                     \
  "LABASE     +44  00HNA16",                                                   \
  "LACAL      +44  01HNA16",                                                   \
  "UI         +45    HNA26",                                                   \
  " =UMIN      F(-12.5,12.5,1:1,U)F+0",                                        \
  " =UMAX      F(-12.5,12.5,1:1,U)F+4",                                        \
  " =IMIN      F(-300,300,0.001:1000,I)F+8",                                   \
  " =I0        F(-300,300,0.001:1000,I)F+8",                                   \
  " =IMAX      F(-300,300,0.001:1000,I)F+12",                                  \
  " =I1        F(-300,300,0.001:1000,I)F+12",                                  \
  " =N         I2+16(1,40)",                                                   \
  " =DELAY     I2+18(0,1023)",                                                 \
  " =DLY       I2+18(0,1023)",                                                 \
  " =DIODE     B2+20:0x01:0x07",                                               \
  " =D         B2+20:0x01:0x07",                                               \
  "UIEX       +46    HNA18",                                                   \
  " =UMIN      F(-12.5,12.5,1:1,U)F+0",                                        \
  " =UMAX      F(-12.5,12.5,1:1,U)F+4",                                        \
  " =N         I2+8(1,40)",                                                    \
  " =DELAY     I2+10(0,1023)",                                                 \
  " =DLY       I2+10(0,1023)",                                                 \
  " =DIODE     B2+12:0x01:0x07",                                               \
  " =D         B2+12:0x01:0x07",                                               \
  " =I         *F(-300,300,0.001:1000,I)I2+8",                                 \
  "MC         +48    HRN",                                                     \
  " :N         B1+0:0x80:0x80",                                                \
  "UC         +49    HNA12",                                                   \
  " =G         M2+0(0,31,1):0x1F",                                             \
  " =RANGE     M2+0(0,31,1):0x1F",                                             \
  " =STD       B2+0:0:0x120",                                                  \
  " =CDC       B2+0:0:0x120",                                                  \
  " =BRIDGE    B2+0:0x100:0x120",                                              \
  " =BR        B2+0:0x100:0x120",                                              \
  " =CDCONLY   B2+0:0x20:0x120",                                               \
  " =CO        B2+0:0x20:0x120",                                               \
  " =BRONLY    B2+0:0x120:0x120",                                              \
  " =BO        B2+0:0x120:0x120",                                              \
  " =N         B2+0:0x80:0x80",                                                \
  " =D         B2+0:0x200:0x200",                                              \
  " =PAR       B2+0:0x200:0x200",                                              \
  " =KHZ       B2+0:0x400:0x400",                                              \
  " =FREE      B2+0:0x800:0x800",                                              \
  " =AUTO      B2+0:0:0x3000",                                                 \
  " =INT       B2+0:0x1000:0x3000",                                            \
  " =EXT       B2+0:0x2000:0x3000",                                            \
  " =EXTA      B2+0:0x2000:0x3000",                                            \
  " =EXTB      B2+0:0x3000:0x3000",                                            \
  " =SIMPLE    B2+0:0x4000:0x4000",                                            \
  " =F         T(0,65535,1)I2+2:KHZ",                                          \
  " =U         F(0,10,1000:1,U)I2+4",                                          \
  " =OFFS      F(-10,10,1000:1,U)I2+6",                                        \
  " =DLY       I1+8(0,255)",                                                   \
  " =DELAY     I1+8(0,255)",                                                   \
  " =L         B1+9:0x1:0x3",                                                  \
  " =LONG      B1+9:0x1:0x3",                                                  \
  " =XL        B1+9:0x2:0x3",                                                  \
  " =XXL       B1+9:0x3:0x3",                                                  \
  "DIV        +4A    HNA14",                                                   \
  " =IMAX      F(0,1000,0.001:1000,I)F+2",                                     \
  " =UMAX      F(0,10,1:1,U)F+6",                                              \
  " =ABS       B2+0:1:1",                                                      \
  " =PAR       B2+0:2:2",                                                      \
  " =DLY       I1+1(0,255)",                                                   \
  " =DELAY     I1+1(0,255)",                                                   \
  "COMP       +4B    C",                                                       \
  "COMPX      +4B    CPSTA",                                                   \
  "WARM       +4C    HN0A18",                                                  \
  " =DIAG      B2+0:1:7",                                                      \
  " =DX        F(0,65.5,1000)I2+2",                                            \
  " =DY        F(0,65.5,1000)I2+4",                                            \
  " =DT        F(0,3.6e6,1:1000,T)I4+6",                                       \
  " =T         F(0,3.6e6,1:1000,T)I4+6",                                       \
  " =TCONT     F(0,65535,1:1000,T)I2+10",                                      \
  " =TC        F(0,65535,1:1000,T)I2+10",                                      \
  "LREF       +50    HN*A19",                                                  \
  " =MAIN      B1+0:1:0xFF",                                                   \
  " =AUTO      B2+1:0:0xC000",                                                 \
  " =INT       B2+1:0x4000:0xC000",                                            \
  " =EXT       B2+1:0x8000:0xC000",                                            \
  " =EXTA      B2+1:0x8000:0xC000",                                            \
  " =EXTB      B2+1:0xC000:0xC000",                                            \
  " =HICURR    B2+1:0x100:0x100",                                              \
  " =HI        B2+1:0x100:0x100",                                              \
  " =G         M2+1(0,7,0x10):0x70",                                           \
  " =RANGE     M2+1(0,7,0x10):0x70",                                           \
  " =FAST      B2+1:1:3",                                                      \
  " =MED       B2+1:2:3",                                                      \
  " =MEDIUM    B2+1:2:3",                                                      \
  " =SLOW      B2+1:3:3",                                                      \
  " =L         B2+1:3:3",                                                      \
  " =LONG      B2+1:3:3",                                                      \
  " =FREQ      F(0,1e6,1:1,F)I4+3",                                            \
  " =F         F(0,1e6,1:1,F)I4+3",                                            \
  " =VOLT      F(0,10,1000:1,U)I4+7",                                          \
  " =U         F(0,10,1000:1,U)I4+7",                                          \
  " =DLY       I1+11(0,255)",                                                  \
  " =DELAY     I1+11(0,255)",                                                  \
  "LMEAS      +50    HN*A19",                                                  \
  " >          I1+0:1",                                                        \
  " =MAIN      B1+0:1:0xFF",                                                   \
  " =AUTO      B2+1:0:0xC000",                                                 \
  " =INT       B2+1:0x4000:0xC000",                                            \
  " =EXT       B2+1:0x8000:0xC000",                                            \
  " =EXTA      B2+1:0x8000:0xC000",                                            \
  " =EXTB      B2+1:0xC000:0xC000",                                            \
  " =HICURR    B2+1:0x100:0x100",                                              \
  " =HI        B2+1:0x100:0x100",                                              \
  " =G         M2+1(0,7,0x10):0x70",                                           \
  " =RANGE     M2+1(0,7,0x10):0x70",                                           \
  " =FAST      B2+1:1:3",                                                      \
  " =MED       B2+1:2:3",                                                      \
  " =MEDIUM    B2+1:2:3",                                                      \
  " =SLOW      B2+1:3:3",                                                      \
  " =L         B2+1:3:3",                                                      \
  " =LONG      B2+1:3:3",                                                      \
  " =FREQ      F(0,1e6,1:1,F)I4+3",                                            \
  " =F         F(0,1e6,1:1,F)I4+3",                                            \
  " =VOLT      F(0,10,1000:1,U)I4+7",                                          \
  " =U         F(0,10,1000:1,U)I4+7",                                          \
  " =DLY       I1+11(0,255)",                                                  \
  " =DELAY     I1+11(0,255)",                                                  \
  "UP          82    H",                                                       \
  "DN          83    H",                                                       \
  "DOWN        83    H",                                                       \
  "G           84    H",                                                       \
  "GND         84    H",                                                       \
  "GROUP       87    L",                                                       \
  "PANEL       87    L",                                                       \
  "SHIELD      88    H",                                                       \
  "NETS        A7    M",                                                       \
  "PADS        C7    E",                                                       \
  "MASTER      C2",                                                            \
  "SLAVE       C3",                                                            \
  "ASSERT      E2    <A4",                                                     \
  " =          F(-1e10,1e10,1)F+0",                                            \
  "CAIR        E4",                                                            \
  "DARK        E5",                                                            \
  "NOLIGHT     E5",                                                            \
  "AVERAGE     E6    A1",                                                      \
  " =          I1+0(1,32)",                                                    \
  "MEDIAN      E7    A1",                                                      \
  " =          I1+0(1,32)",                                                    \
  "KEEPORDER   E8",                                                            \
  "ORDER       E8",                                                            \
  "SH          9B    A1",                                                      \
  " =          I1+0(0,2)",                                                     \
  "SHUTTLE     9B    A1",                                                      \
  " =          I1+0(0,2)",                                                     \
  "SHY         9C    A6",                                                      \
  " =          F(-5e3,5e3,256000)I4+0",                                        \
  " =Y         F(-5e3,5e3,256000)I4+0",                                        \
  "BCY         AC    A6",                                                      \
  " =          F(-5e3,5e3,256000)I4+0",                                        \
  " =Y         F(-5e3,5e3,256000)I4+0",                                        \
  "#END" }

// Subcommands of M_COMP.
static char comp[154][DLEN] = {                                                \
  "I          +01    HA8",                                                     \
  " =          F(-0.3,0.3,1:1,I)F+0",                                          \
  " =I         F(-0.3,0.3,1:1,I)F+0",                                          \
  " =CURRENT   F(-0.3,0.3,1:1,I)F+0",                                          \
  " =UMAX      F(-15,15,1:1,U)F+4",                                            \
  "U          +02    HA12",                                                    \
  " =          F(-15,15,1:1,U)F+0",                                            \
  " =U         F(-15,15,1:1,U)F+0",                                            \
  " =IMAX      F(-1,1,1:1,I)F+4",                                              \
  " =R         F(0,1e6,1:1,R)F+8",                                             \
  " =ROUT      F(0,1e6,1:1,R)F+8",                                             \
  "IAC        +03    HA16",                                                    \
  " =          F(-0.3,0.3,1:1,I)F+0",                                          \
  " =I         F(-0.3,0.3,1:1,I)F+0",                                          \
  " =CURRENT   F(-0.3,0.3,1:1,I)F+0",                                          \
  " =UMAX      F(-15,15,1:1,U)F+4",                                            \
  " =OFFS      F(-0.3,0.3,1:1,U)F+8",                                          \
  " =OFFSET    F(-0.3,0.3,1:1,U)F+8",                                          \
  " =F         F(100,1e6,1:1,F)F+12",                                          \
  " =FREQ      F(100,1e6,1:1,F)F+12",                                          \
  "UAC        +04    HA20",                                                    \
  " =          F(-15,15,1:1,U)F+0",                                            \
  " =U         F(-15,15,1:1,U)F+0",                                            \
  " =IMAX      F(-1,1,1:1,I)F+4",                                              \
  " =R         F(0,1e6,1:1,R)F+8",                                             \
  " =ROUT      F(0,1e6,1:1,R)F+8",                                             \
  " =OFFS      F(-15,15,1:1,U)F+12",                                           \
  " =OFFSET    F(-15,15,1:1,U)F+12",                                           \
  " =F         F(100,1e6,1:1,F)F+16",                                          \
  " =FREQ      F(100,1e6,1:1,F)F+16",                                          \
  "HV         +08    HA10",                                                    \
  " =          F(0,500,1:1,U)F+0",                                             \
  " =U         F(0,500,1:1,U)F+0",                                             \
  " =I         F(0,10,1:1,I)F+4",                                              \
  " =IMAX      F(0,10,1:1,I)F+4",                                              \
  " =DLY       F(0,1000,1:1000,T)I2+8",                                        \
  " =DELAY     F(0,1000,1:1000,T)I2+8",                                        \
  "GNDI       +0B    H",                                                       \
  "GI         +0B    H",                                                       \
  "GND        +0C    H",                                                       \
  "G          +0C    H",                                                       \
  "RGND       +0D    HA4",                                                     \
  " =          F(0,1e6,1:1,R)F+0",                                             \
  " =R         F(0,1e6,1:1,R)F+0",                                             \
  "RG         +0D    HA4",                                                     \
  " =          F(0,1e6,1:1,R)F+0",                                             \
  " =R         F(0,1e6,1:1,R)F+0",                                             \
  "SH         +0E    HH",                                                      \
  "SHORT      +0E    HH",                                                      \
  "SET        +0F    HA4",                                                     \
  " =          F(-500,500,1)F+0",                                              \
  " =HV        F(-500,500,1:1,U)F+0",                                          \
  " =U         F(-15,15,1:1,U)F+0",                                            \
  " =I         F(-0.3,0.3,1:1,A)F+0",                                          \
  " =CURRENT   F(-0.3,0.3,1:1,A)F+0",                                          \
  "DLY        +10    A2",                                                      \
  " =          F(0,65535,1:1000,T)I2+0",                                       \
  "DELAY      +10    A2",                                                      \
  " =          F(0,65535,1:1000,T)I2+0",                                       \
  "MI         +11    HA4",                                                     \
  " =          F(-0.3,0.3,1:1,I)F+0",                                          \
  " =IMAX      F(-0.3,0.3,1:1,I)F+0",                                          \
  "MU         +12    UU",                                                      \
  "MIAC       +13    HA4",                                                     \
  " =          F(-0.3,0.3,1:1,I)F+0",                                          \
  " =IMAX      F(-0.3,0.3,1:1,I)F+0",                                          \
  "MUAC       +14    UU",                                                      \
  "MIPHASE    +15    HA4",                                                     \
  " =          F(-0.3,0.3,1:1,I)F+0",                                          \
  " =IMAX      F(-0.3,0.3,1:1,I)F+0",                                          \
  "MIPH       +15    HA4",                                                     \
  " =          F(-0.3,0.3,1:1,I)F+0",                                          \
  " =IMAX      F(-0.3,0.3,1:1,I)F+0",                                          \
  "MUPHASE    +16    UU",                                                      \
  "MUPH       +16    UU",                                                      \
  "MUDIFF     +17    UU",                                                      \
  "MUACD      +18    UU",                                                      \
  "MUPHD      +19    UU",                                                      \
  "HVI        +1A",                                                            \
  "HVU        +1B",                                                            \
  "ASSERT     +1F    A8",                                                      \
  " =MIN       F(-1e30,1e30,1)F+0",                                            \
  " =MAX       F(-1e30,1e30,1)F+4",                                            \
  " =IMIN      F(-1e30,1e30,1:1,I)F+0",                                        \
  " =IMAX      F(-1e30,1e30,1:1,I)F+4",                                        \
  " =UMIN      F(-1e30,1e30,1:1,U)F+0",                                        \
  " =UMAX      F(-1e30,1e30,1:1,U)F+4",                                        \
  " =RMIN      F(-1e30,1e30,1:1,R)F+0",                                        \
  " =RMAX      F(-1e30,1e30,1:1,R)F+4",                                        \
  " =CMIN      F(-1e30,1e30,1:1,C)F+0",                                        \
  " =CMAX      F(-1e30,1e30,1:1,C)F+4",                                        \
  "RESET      +20",                                                            \
  "RS         +20",                                                            \
  "R          +2228  HHOOA8",                                                  \
  " =UMAX      F(-15,15,1:1,U)F+0",                                            \
  " =IMAX      F(-0.3,0.3,1:1,I)F+4",                                          \
  "Q          +23    HHHHA8",                                                  \
  " =UMAX      F(-15,15,1:1,U)F+0",                                            \
  " =IMAX      F(-0.3,0.3,1:1,I)F+4",                                          \
  "QUAD       +23    HHHHA8",                                                  \
  " =UMAX      F(-15,15,1:1,U)F+0",                                            \
  " =IMAX      F(-0.3,0.3,1:1,I)F+4",                                          \
  "C          +2429  HHOOA12",                                                 \
  " =U         F(-10,10,1:1,U)F+0",                                            \
  " =UMAX      F(-10,10,1:1,U)F+0",                                            \
  " =OFFS      F(-10,10,1:1,U)F+4",                                            \
  " =OFFSET    F(-10,10,1:1,U)F+4",                                            \
  " =F         F(100,1e6,1:1,F)F+8",                                           \
  " =FREQ      F(100,1e6,1:1,F)F+8",                                           \
  "HVLEAK     +25    HHA10",                                                   \
  " =U         F(10,1000,1:1,U)F+0",                                           \
  " =UMAX      F(10,1000,1:1,U)F+0",                                           \
  " =DLY       F(0,65535,1:1000,T)I2+4",                                       \
  "HVVAR      +26    HHA10",                                                   \
  " =U         F(10,1000,1:1,U)F+0",                                           \
  " =UMAX      F(10,1000,1:1,U)F+0",                                           \
  " =DLY       F(0,65535,1:1000,T)I2+4",                                       \
  "HVR        +27    HHA10",                                                   \
  " =U         F(10,1000,1:1,U)F+0",                                           \
  " =UMAX      F(10,1000,1:1,U)F+0",                                           \
  " =DLY       F(0,65535,1:1000,T)I2+4",                                       \
  "BD         +3030  HHOA9",                                                   \
  " =L         B1+8:0x1:0x3",                                                  \
  " =LONG      B1+8:0x1:0x3",                                                  \
  " =XL        B1+8:0x2:0x3",                                                  \
  " =XXL       B1+8:0x3:0x3",                                                  \
  " =U         F(-10,10,1:1,U)F+0",                                            \
  " =UMAX      F(-10,10,1:1,U)F+0",                                            \
  " =F         F(100,1e6,1:1,F)F+4",                                           \
  " =FREQ      F(100,1e6,1:1,F)F+4",                                           \
  "BZ         +31    HA4",                                                     \
  " =Z         F(-32.7,32.7,1000)I2+0",                                        \
  " =ZMIN      F(-32.7,32.7,1000)I2+2",                                        \
  "BC         +32    HA2",                                                     \
  " =Z         F(-32.7,32.7,1000)I2+0",                                        \
  "BT         +33    HH",                                                      \
  "MOVE       +81    HA12",                                                    \
  " =          F(-8000,8000,1000)I3+0(5)I2+8",                                 \
  " =          F(-8000,8000,1000)I3+3(3)I2+10",                                \
  " =          F(0,65,1000)I2+6",                                              \
  " =X         F(-8000,8000,1000)I3+0(5)I2+8",                                 \
  " =Y         F(-8000,8000,1000)I3+3(3)I2+10",                                \
  " =R         F(0,65,1000)I2+6",                                              \
  "M          +81    HA12",                                                    \
  " =          F(-8000,8000,1000)I3+0(5)I2+8",                                 \
  " =          F(-8000,8000,1000)I3+3(3)I2+10",                                \
  " =          F(0,65,1000)I2+6",                                              \
  " =X         F(-8000,8000,1000)I3+0(5)I2+8",                                 \
  " =Y         F(-8000,8000,1000)I3+3(3)I2+10",                                \
  " =R         F(0,65,1000)I2+6",                                              \
  "UP         +82    H",                                                       \
  "DOWN       +83    H",                                                       \
  "DN         +83    H",                                                       \
  "#END" }

// Parameters of HVINIT.
static char hvinit[18][DLEN] = {                                               \
  " >          I4+6:2",                                                        \
  " >          I4+10:1000000",                                                 \
  " =G         B2+0:0x10:0x10",                                                \
  " =GOHM      B2+0:0x10:0x10",                                                \
  " =UNI       B2+0:8:8",                                                      \
  " =UP        B2+0:8:8",                                                      \
  " =FIX       B2+0:4:4",                                                      \
  " =POL       B2+0:2:2",                                                      \
  " =DIS       B2+0:1:1",                                                      \
  " =IMAX      F(0,10,1000:1000,I)I2+2",                                              \
  " =I         F(0,10,1000:1000,I)I2+2",                                              \
  " =RMAX      T(0,200000,1)I2+4:GOHM",                                        \
  " =TTEST     F(0,60000,1:1000,T)I4+6",                                       \
  " =VRISE     F(0,10000,1000)I4+10",                                          \
  " =TINIT     F(0,60000,1:1000,T)I2+14",                                      \
  " =RLOW      F(0,20000,1)I2+16",                                             \
  " =ULOW      F(0,10,1000)I2+18",                                             \
  "#END" }

// Parameters of HVSTEPS.
static char hvsteps[28][DLEN] = {                                              \
  " >          I4+8:1000000",                                                  \
  " >          I4+26:2",                                                       \
  " >          I4+40:2",                                                       \
  " =UNI       B2+0:8:8",                                                      \
  " =UP        B2+0:8:8",                                                      \
  " =FIX       B2+0:4:4",                                                      \
  " =POL       B2+0:2:2",                                                      \
  " =DIS       B2+0:1:1",                                                      \
  " =RLOW      F(0,20000,1)I2+2",                                              \
  " =ULOW      F(0,10,1000)I2+4",                                              \
  " =IMAX      F(0,10,1000:1000,I)I2+6",                                       \
  " =I         F(0,10,1000:1000,I)I2+6",                                       \
  " =VRISE     F(0,10000,1000)I4+8",                                           \
  " =TINIT     F(0,60000,1:1000,T)I2+12",                                      \
  " =GAP       F(0,60000,1:1000,T)I2+14",                                      \
  " =UMAX1     F(0,1000,1:1,U)I2+20",                                          \
  " =U1        F(0,1000,1:1,U)I2+20",                                          \
  " =RMAX1     F(0,200000,1:1e6,R)I4+22",                                      \
  " =R1        F(0,200000,1:1e6,R)I4+22",                                      \
  " =TTEST1    F(0,60000,1:1000,T)I4+26",                                      \
  " =T1        F(0,60000,1:1000,T)I4+26",                                      \
  " =UMAX2     F(0,1000,1:1,U)I2+34",                                          \
  " =U2        F(0,1000,1:1,U)I2+34",                                          \
  " =RMAX2     F(0,200000,1:1e6,R)I4+36",                                      \
  " =R2        F(0,200000,1:1e6,R)I4+36",                                      \
  " =TTEST2    F(0,60000,1:1000,T)I4+40",                                      \
  " =T2        F(0,60000,1:1000,T)I4+40",                                      \
  "#END" }

// Parameters of EXTINIT.
static char extinit[9][DLEN] = {                                               \
  " >          I1+0:0x40",                                                     \
  " =          M1+0(0,7,1):0x07",                                              \
  " =CHAN      M1+0(0,7,1):0x07",                                              \
  " =NO        B1+0:0:0x40",                                                   \
  " =NOANSWER  B1+0:0:0x40",                                                   \
  " =WAIT      I1+2(0,255)",                                                   \
  " =EOL       I1+4(0,255)",                                                   \
  " =END       S3+6",                                                          \
  "#END" }

// Parameters of RLINIT.
static char rlinit[16][DLEN] = {                                               \
  " =INTERNAL  B2+0:0x4000:0xC000",                                            \
  " =INT       B2+0:0x4000:0xC000",                                            \
  " =EXTERNAL  B2+0:0x8000:0xC000",                                            \
  " =EXT       B2+0:0x8000:0xC000",                                            \
  " =AUTO      B2+0:0x0000:0xC000",                                            \
  " =FAST      B2+0:0x0001:0x0003",                                            \
  " =MEDIUM    B2+0:0x0002:0x0003",                                            \
  " =MED       B2+0:0x0002:0x0003",                                            \
  " =SLOW      B2+0:0x0003:0x0003",                                            \
  " =RANGE     M2+0(0,7,0x10):0x70",                                           \
  " =RNG       M2+0(0,7,0x10):0x70",                                           \
  " =FREQ      F(0,1e6,1)I4+2",                                                \
  " =F         F(0,1e6,1)I4+2",                                                \
  " =VOLT      F(0,10,1000)I4+6",                                              \
  " =U         F(0,10,1000)I4+6",                                              \
  "#END" }

// Service function, processes field, where cmd is the input string with skipped
// field name, key is the field name (used to report errors), d is the field
// description, f is field, m is mask, and size is the size of filed and mask.
// On success, returns number of characters scanned from s. On error, sets err
// and returns -1.
function int Processfield(char *cmd,char *key,char *d,char *f,char *m,         \
  int size,int *extrasize,char *err,char *setfld)
  int i,j,k,n,q,c,len,offs,ival,imin,imax,ifactor,mask,par,nlist,setflag
  float value,vmin,vmax,factor,ufactor
  char unit[32],utype
  i=0; n=0; extrasize[0]=0
  setfld[0]='\0'
next:
  if d[n]=='M' || d[n]=='B' then
    // Binary field or binary flag.
    c=d[n]; n++
    len=0; n=n+Scanint(d+n,&len)
    n=n+Skipchar(d+n,'+')
    offs=0; n=n+Scanint(d+n,&offs)
    if offs<0 || offs+len>size goto interr
    if c=='M' then
      // Binary field.
      i=i+Skipchar(cmd+i,'=')
      j=Scanint(cmd+i,&ival); i=i+j
      if j<0 then
        sprintf(err,"Missing or invalid value of '%s'",key); return -1; endif
      n=n+Skipchar(d+n,'(')
      imin=0x7FFFFFFF; n=n+Scanint(d+n,&imin)
      n=n+Skipchar(d+n,',')
      imax=0x80000000; n=n+Scanint(d+n,&imax)
      n=n+Skipchar(d+n,',')
      ifactor=0; n=n+Scanint(d+n,&ifactor)
      n=n+1+Skipchar(d+n+1,')')
      if imin>imax goto interr
      if ival<imin || ival>imax then
        sprintf(err,"Value of '%s' is out of range",key); return -1; endif
      ival=ival*ifactor
    else
      // Binary flag.
      n=n+Skipchar(d+n,':')
      ival=0; j=Scanint(d+n,&ival); n=n+j
      if j==0 goto interr
    endif
    n=n+Skipchar(d+n,':')
    mask=0; n=n+Scanint(d+n,&mask)
    if (ival & (~mask))!=0 then
      sprintf(err,"Value of '%s' does not fit",key); return -1; endif
    if len==1 then
      if mask & 0xFFFFFF00 goto interr
      if ($uint1(m+offs) & mask)!=0 goto redefined
      $uint1(m+offs)=$uint1(m+offs)|mask
      $uint1(f+offs)=($uint1(f+offs) & (~mask))|ival
    else if len==2 then
      if mask & 0xFFFF0000 goto interr
      if ($uint2(m+offs) & mask)!=0 goto redefined
      $uint2(m+offs)=$uint2(m+offs)|mask
      $uint2(f+offs)=($uint2(f+offs) & (~mask))|ival
    else if len==4 then
      if ($uint4(m+offs) & mask)!=0 goto redefined
      $uint4(m+offs)=$uint4(m+offs)|mask
      $uint4(f+offs)=($uint4(f+offs) & (~mask))|ival
    else
      goto interr
    endif
  else if d[n]=='I' then
    // Integer field without scale, saved as integer value.
    i=i+Skipchar(cmd+i,'=')
    j=Scanint(cmd+i,&ival); i=i+j
    if j<0 then
      sprintf(err,"Missing or invalid value of '%s'",key); return -1; endif
    n++; len=0; n=n+Scanint(d+n,&len)
    n=n+Skipchar(d+n,'+')
    offs=0; n=n+Scanint(d+n,&offs)
    if offs<0 || offs+len>size goto interr
    n=n+Skipchar(d+n,'(')
    imin=0x7FFFFFFF; n=n+Scanint(d+n,&imin)
    n=n+Skipchar(d+n,',')
    imax=0x80000000; n=n+Scanint(d+n,&imax)
    n=n+1+Skipchar(d+n+1,')')
    if imin>imax goto interr
    if len==1 then
      if $uint1(m+offs)!=0 goto redefined
      $uint1(m+offs)=0xFF
      $uint1(f+offs)=ival
    else if len==2 then
      if $uint2(m+offs)!=0 goto redefined
      $uint2(m+offs)=0xFFFF
      $uint2(f+offs)=ival
    else if len==4 then
      if $uint4(m+offs)!=0 goto redefined
      $uint4(m+offs)=0xFFFFFFFF
      $uint4(f+offs)=ival
    else
      goto interr
    endif
  else if d[n]=='F' || d[n]=='T' then
    // F: floating field, may be saved as floating or integer value; T: same,
    // but if exceeds maximum, divides by 1000 and sets flag.
    i=i+Skipchar(cmd+i,'=')
    j=Scanfloat(cmd+i,&value); i=i+j
    if j<0 then
      sprintf(err,"Missing or invalid value of '%s'",key); return -1; endif
    c=d[n]; n++; n=n+Skipchar(d+n,'(')
    vmin=1.0e99; n=n+Scanfloat(d+n,&vmin)
    n=n+Skipchar(d+n,',')
    vmax=-1.0e99; n=n+Scanfloat(d+n,&vmax)
    n=n+Skipchar(d+n,',')
    factor=0.0; n=n+Scanfloat(d+n,&factor)
    n=n+Skipchar(d+n,' ')
    if d[n]==':' then
      // Check for the optional unit of measurements following the value.
      // Attention, it's optional, don't confuse it with the next parameter!
      n++
      j=Scanname(cmd+i,unit)
      if unit[0]!='\0' then
        ufactor=0.0; n=n+Scanfloat(d+n,&ufactor)
        if ufactor==0.0 goto interr
        n=n+Skipchar(d+n,',')
        if d[n]=='U' then              // Volts expected
          if Stricmp(unit,"V")==0 then
            i=i+j; value=value*ufactor
          else if Stricmp(unit,"mV")==0 then
            i=i+j; value=value*ufactor/1000.0
          else if Stricmp(unit,"uV")==0 then
            i=i+j; value=value*ufactor/1.0e6
          else if Stricmp(unit,"kV")==0 then
            i=i+j; value=value*ufactor*1000.0
          else if Stricmp(unit,"nV")==0 then
            i=i+j; value=value*ufactor/1.0e9
          endif
        else if d[n]=='I' then         // Amperes expected
          if Stricmp(unit,"mA")==0 then
            i=i+j; value=value*ufactor/1000.0
          else if Stricmp(unit,"A")==0 then
            i=i+j; value=value*ufactor
          else if Stricmp(unit,"uA")==0 then
            i=i+j; value=value*ufactor/1.0e6
          else if Stricmp(unit,"nA")==0 then
            i=i+j; value=value*ufactor/1.0e9
          else if Stricmp(unit,"pA")==0 then
            i=i+j; value=value*ufactor/1.0e12
          endif
        else if d[n]=='R' then         // Ohms expected
          if Stricmp(unit,"R")==0 || Stricmp(unit,"Ohm")==0 then
            i=i+j; value=value*ufactor
          else if Stricmp(unit,"k")==0 || Stricmp(unit,"kOhm")==0 then
            i=i+j; value=value*ufactor*1000.0
          else if Strcmp(unit,"M")==0 || Strcmp(unit,"MOhm")==0 then
            i=i+j; value=value*ufactor*1.0e6
          else if Stricmp(unit,"G")==0 || Stricmp(unit,"GOhm")==0 then
            i=i+j; value=value*ufactor*1.0e9
          else if Stricmp(unit,"T")==0 || Stricmp(unit,"TOhm")==0 then
            i=i+j; value=value*ufactor*1.0e12
          else if Strcmp(unit,"m")==0 || Strcmp(unit,"mOhm")==0 then
            i=i+j; value=value*ufactor/1000.0
          else if Stricmp(unit,"u")==0 || Stricmp(unit,"uOhm")==0 then
            i=i+j; value=value*ufactor/1.0e6
          else if Stricmp(unit,"n")==0 || Stricmp(unit,"nOhm")==0 then
            i=i+j; value=value*ufactor/1.0e9
          endif
        else if d[n]=='C' then         // Farades expected
          if Stricmp(unit,"pF")==0 then
            i=i+j; value=value*ufactor*1.0e-12
          else if Stricmp(unit,"fF")==0 then
            i=i+j; value=value*ufactor*1.0e-15
          else if Stricmp(unit,"nF")==0 then
            i=i+j; value=value*ufactor*1.0e-9
          else if Stricmp(unit,"uF")==0 then
            i=i+j; value=value*ufactor*1.0e-6
          else if Stricmp(unit,"mF")==0 then
            i=i+j; value=value*ufactor*1.0e-3
          else if Stricmp(unit,"aF")==0 then
            i=i+j; value=value*ufactor*1.0e-18
          else if Stricmp(unit,"F")==0 then
            i=i+j; value=value*ufactor
          endif
        else if d[n]=='P' then         // Watts expected
          if Stricmp(unit,"mW")==0 then
            i=i+j; value=value*ufactor/1000.0
          else if Stricmp(unit,"W")==0 then
            i=i+j; value=value*ufactor
          else if Stricmp(unit,"uW")==0 then
            i=i+j; value=value*ufactor/1.0e6
          else if Stricmp(unit,"nW")==0 then
            i=i+j; value=value*ufactor/1.0e9
          endif
        else if d[n]=='T' then         // Seconds expected
          if Stricmp(unit,"s")==0 then
            i=i+j; value=value*ufactor
          else if Stricmp(unit,"ms")==0 then
            i=i+j; value=value*ufactor/1000.0
          else if Stricmp(unit,"us")==0 then
            i=i+j; value=value*ufactor/1.0e6
          endif
        else if d[n]=='F' then         // Hertz expected
          if Stricmp(unit,"Hz")==0 then
            i=i+j; value=value*ufactor
          else if Stricmp(unit,"k")==0 || Stricmp(unit,"kHz")==0 then
            i=i+j; value=value*ufactor*1000.0
          else if Stricmp(unit,"M")==0 || Stricmp(unit,"MHz")==0 then
            i=i+j; value=value*ufactor*1.0e6
          endif
        else
          sprintf(err,"Unsupported physical value '%c'",d[n]); return -1;
        endif
      endif
      while d[n]!='\0' && d[n]!=')' do n++; enddo
    endif
    n=n+Skipchar(d+n,')')
    if factor==0.0 || vmin>=vmax goto interr
    if value>vmax && c=='T' then
      value=value/1000.0
      setflag=1
    else
      setflag=0
    endif
    if value<vmin || value>vmax then
      sprintf(err,"Value of '%s' is out of range",key); return -1; endif
    if d[n]=='I' then
      // Integer field.
      n++; len=0; n=n+Scanint(d+n,&len)
      n=n+Skipchar(d+n,'+')
      offs=0; n=n+Scanint(d+n,&offs)
      if offs<0 || offs+len>size goto interr
      if len==1 then
        if $uint1(m+offs)!=0 goto redefined
        $uint1(m+offs)=0xFF
        $uint1(f+offs)=Floor(value*factor+0.5)
      else if len==2 then
        if $uint2(m+offs)!=0 goto redefined
        $uint2(m+offs)=0xFFFF
        $uint2(f+offs)=Floor(value*factor+0.5)
      else if len==3 then
        if $uint3(m+offs)!=0 goto redefined
        $uint3(m+offs)=0xFFFFFF
        $uint3(f+offs)=Floor(value*factor+0.5)
      else if len==4 then
        if $uint4(m+offs)!=0 goto redefined
        $uint4(m+offs)=0xFFFFFFFF
        $uint4(f+offs)=Floor(value*factor+0.5)
      else
        goto interr
      endif
    else if d[n]=='F' then
      // Floating field, always 4 bytes long.
      n++; len=4
      n=n+Skipchar(d+n,'4')
      n=n+Skipchar(d+n,'+')
      offs=0; n=n+Scanint(d+n,&offs)
      if offs<0 || offs+len>size goto interr
      if $uint4(m+offs)!=0 goto redefined
      $uint4(m+offs)=0xFFFFFFFF
      $float4(f+offs)=value*factor
    else
      goto interr
    endif
    if c=='F' && d[n]=='(' && (cmd[i]=='+' || cmd[i]=='-' || cmd[i]==':') then
      // Individual correction.
      if cmd[i]==':' i++
      j=Scanfloat(cmd+i,&value); i=i+j
      if j<0 then
        sprintf(err,"Missing or invalid correction '%s'",key); return -1; endif
      n++
      vmax=-1.0e99; n=n+Scanfloat(d+n,&vmax)
      if Abs(value)>vmax then
        sprintf(err,"Correction '%s' is out of range",key); return -1; endif
      n=n+Skipchar(d+n,')')
      if d[n]=='I' then
        n++; len=0; n=n+Scanint(d+n,&len)
        if len!=2 goto interr
        n=n+Skipchar(d+n,'+')
        offs=0; n=n+Scanint(d+n,&offs)
        if offs<0 || offs+len>size goto interr
      else
        goto interr
      endif
      // Only 2-byte integer is supported
      if $uint2(m+offs)!=0 goto redefined
      $uint2(m+offs)=0xFFFF
      $uint2(f+offs)=Floor(value*factor+0.5)
    else if c=='T' then
      n=n+Skipchar(d+n,':')
      Scanname(d+n,setfld)
      if setflag==0 setfld[0]='\0'
    endif
  else if d[n]=='C' then
    // Connections list for external device, always 2 bytes long.
    i=i+Skipchar(cmd+i,'=')
    len=2
    n++; n=n+Skipchar(d+n,'+')
    offs=0; n=n+Scanint(d+n,&offs)
    if offs<0 || offs+len>size goto interr
    i=i+Skipchar(cmd+i,'(')
    ival=0
    for k=0,k<16,k=k+4 do
      q=0
      while 1 do                       // Not a 100% accurate processing
        if cmd[i]>='0' && cmd[i]<='9' then
          q=cmd[i]-'0'; i++; break
        else if cmd[i]>='A' && cmd[i]<='F' then
          q=cmd[i]-'A'+10; i++; break
        else if cmd[i]>='a' && cmd[i]<='f' then
          q=cmd[i]-'a'+10; i++; break
        else if cmd[i]=='U' then
          q=q|1; i++
        else if cmd[i]=='M' then
          q=q|2; i++
        else if cmd[i]=='P' then
          q=q|4; i++
        else if cmd[i]=='G' then
          q=q|8; i++
        else if cmd[i]==' ' || cmd[i]=='\t' then
          i++
        else if cmd[i]==',' || cmd[i]==')' || cmd[i]=='\0' then
          break
        else
          sprintf(err,"Invalid connections list in '%s'",key); return -1
        endif
      enddo
      ival=ival | (q<<k)
      if cmd[i]==')' then
        i++; break
      else if cmd[i]==',' && k<12 then
        i++
      else
        sprintf(err,"Invalid connections list in '%s'",key); return -1
      endif
      $uint2(m+offs)=0xFFFF
      $uint2(f+offs)=ival
    enddo
  else if d[n]=='S' then
    // Fixed-size string.
    n++; len=0; n=n+Scanint(d+n,&len)
    n=n+Skipchar(d+n,'+')
    offs=0; n=n+Scanint(d+n,&offs)
    if offs<0 || offs+len>size goto interr
    i=i+Skipchar(cmd+i,'=')
    if cmd[i]!='\"' then
      sprintf(err,"Expecting quoted ASCII string in '%s'",key); return -1
    endif
    i++
    for k=0,k<len,k++ do
      if cmd[i]=='\0' then
        sprintf(err,"Expecting quoted ASCII string in '%s'",key); return -1
      else if cmd[i]=='\"' then
        break
      endif
      m[offs+k]=0xFF
      f[offs+k]=cmd[i]
      i++
    enddo
    if cmd[i]!='\"' then
      sprintf(err,"String is too long in '%s'",key); return -1
    endif
    i++
  else if d[n]=='*' then
    // List.
    n++
    if d[n]=='F' then
      // Floating-point list.
      n++; n=n+Skipchar(d+n,'(')
      vmin=1.0e99; n=n+Scanfloat(d+n,&vmin)
      n=n+Skipchar(d+n,',')
      vmax=-1.0e99; n=n+Scanfloat(d+n,&vmax)
      n=n+Skipchar(d+n,',')
      factor=0.0; n=n+Scanfloat(d+n,&factor)
      n=n+Skipchar(d+n,' ')
      if d[n]==':' then
        // Optional units of measurements following the value apply.
        n++
        ufactor=0.0; n=n+Scanfloat(d+n,&ufactor)
        if ufactor==0.0 goto interr
        n=n+Skipchar(d+n,',')
        if d[n]=='U' then                // Volts expected
          utype='U'
        else if d[n]=='I' then           // Amperes expected
          utype='I'
        else
          sprintf(err,"Unsupported physical value '%c'",d[n]); return -1;
        endif
        n++
      else
        ufactor=1.0; utype='\0'
      endif
      n=n+Skipchar(d+n,')')
      if d[n]=='I' then
        n++; len=0; n=n+Scanint(d+n,&len)
        n=n+Skipchar(d+n,'+')
        offs=0; n=n+Scanint(d+n,&offs)
        if offs<0 || offs+len>size goto interr
      else
        goto interr
      endif
      i=i+Skipchar(cmd+i,'=')
      if cmd[i]=='(' then
        par=')'; i++
      else
        par=0
      endif
      nlist=0
      while 1 do
        if nlist>=40 then
          sprintf(err,"Too many items in '%s'",key); return -1; endif
        j=Scanfloat(cmd+i,&value); i=i+j
        if j<0 then
          sprintf(err,"Missing or invalid value of '%s'",key); return -1; endif
        j=Scanname(cmd+i,unit)
        if unit[0]!='\0' then
          if utype=='U' then           // Volts expected
            if Stricmp(unit,"V")==0 then
              i=i+j; value=value*ufactor
            else if Stricmp(unit,"mV")==0 then
              i=i+j; value=value*ufactor/1000.0
            else if Stricmp(unit,"uV")==0 then
              i=i+j; value=value*ufactor/1.0e6
            else if Stricmp(unit,"kV")==0 then
              i=i+j; value=value*ufactor*1000.0
            else if Stricmp(unit,"nV")==0 then
              i=i+j; value=value*ufactor/1.0e9
            endif
          else if utype=='I' then      // Amperes expected
            if Stricmp(unit,"mA")==0 then
              i=i+j; value=value*ufactor/1000.0
            else if Stricmp(unit,"A")==0 then
              i=i+j; value=value*ufactor
            else if Stricmp(unit,"uA")==0 then
              i=i+j; value=value*ufactor/1.0e6
            else if Stricmp(unit,"nA")==0 then
              i=i+j; value=value*ufactor/1.0e9
            else if Stricmp(unit,"pA")==0 then
              i=i+j; value=value*ufactor/1.0e12
            endif
          endif
        endif
        if value<vmin || value>vmax then
          sprintf(err,"Value of '%s' is out of range",key); return -1; endif
        $float4(f+size+extrasize[0])=value*factor
        extrasize[0]=extrasize[0]+4
        nlist++
        i=i+Skipchar(cmd+i,' ')
        if cmd[i]==',' then
          i=i+Skipchar(cmd+i,',')
        else if cmd[i]=='\0' || cmd[i]==par then
          break
        endif
      enddo
      if par!=0 then
        i=i+Skipchar(cmd+i,' ')
        if cmd[i]!=par then
          sprintf(err,"Expecting parenthesis '%c'",par); return -1
        endif
        i++
      endif
      if len==2 then
        if $uint2(m+offs)!=0 && $uint2(f+offs)!=nlist then
          sprintf(err,"Conflicting counts in '%s'",key); return -1; endif
        $uint2(m+offs)=0xFFFF
        $uint2(f+offs)=nlist
      else
        goto interr
      endif
    else
      goto interr                      // As yet unsupported list type
    endif
  else
    goto interr                        // Undefined field type
  endif
  if d[n]==',' then
    n++; goto next                     // Next argument follows
  endif
  return i                             // Success
redefined:
  sprintf(err,"Duplicated parameter '%s'",key); return -1
interr:
  sprintf(err,"Internal error while processing '%s'",key); return -1
end

// Decodes named flags and arguments.
function int Processarguments(char *cmd,int shortargs,int allowdigits,char *w, \
  char *arg,char *amask,int asize,int *xsize,int *hasargs,char *error)
  int i,j,q,p,length,offset,ival,nempty,iempty
  char key[32],setfld[32],dummy[32]
  Memset(arg,0,asize)
  Memset(amask,0,asize)
  i=0
  nempty=0
  for q=0,1,q=q+DLEN do
    // Initialization of arguments.
    if w[q]!='\0' then
      if w[q]==' ' then
        for j=0,j<DLEN,j++ do
          if w[q+j]==' ' w[q+j]='\0'
        enddo
      else
        break
      endif
    endif
    if w[q+1]!='>' continue            // Not an initializer
    p=q+BINCODE
    if w[p]!='I' continue              // As yet unsupported field
    p++; length=0; p=p+Scanint(w+p,&length)
    p=p+Skipchar(w+p,'+')
    offset=0; p=p+Scanint(w+p,&offset)
    if offset<0 || offset+length>asize                                         \
      continue                         // In fact, internal error
    p=p+Skipchar(w+p,':')
    if Isdigit(w[p]) || w[p]=='-' then
      ival=0; p=p+Scanint(w+p,&ival)
    else
      continue                         // Undefined type of initializer
    endif
    if length==1 then
      $int1(arg+offset)=ival
    else if length==2 then
      $int2(arg+offset)=ival
    else if length==4 then
      $int4(arg+offset)=ival
    endif
  enddo
  while 1 do
    i=i+Skipchar(cmd+i,' ')
    if shortargs==0 then
      if Isdigit(cmd[i]) || cmd[i]=='-' || cmd[i]=='.' then
        key[0]='\0'                    // Unnamed parameter
      else if allowdigits then
        i=i+Scanalphanum(cmd+i,&key); if key[0]=='\0' break
      else
        i=i+Scanname(cmd+i,&key); if key[0]=='\0' break
      endif
    else
      if Isalpha(cmd[i])==0 break
      key[0]=cmd[i]; key[1]='\0'
      i++
    endif
    if key[0]=='\0' then
      if nempty>=999 then
        sprintf(error,"Unnamed parameter after named"); return -1; endif
      nempty++
    else
      nempty=9999                      // No unnamed parameters after named
    endif
    iempty=0
    for q=0,1,q=q+DLEN do
      if w[q+0]!='\0' then
        sprintf(error,"Unknown key '%s'",key); return -1; endif
      if w[q+1]!='=' continue          // Not an argument
      if w[q+2]=='\0' iempty++
      if Strcmp(w+q+2,key)==0 then
        if key[0]=='\0' && iempty<nempty continue
        break
      endif
    enddo
    j=Processfield(cmd+i,key,w+q+BINCODE,arg,amask,asize,xsize,error,setfld)
    if j<0 return -1
    hasargs[0]=1
    i=i+j
    i=i+Skipchar(cmd+i,',')
    if setfld[0]!='\0' then
      // Request to set field or flag.
      for q=0,1,q=q+DLEN do
        if w[q+0]!='\0' then
          sprintf(error,"Internal error: Can't set field '%s'",setfld)
          return -1;
        endif
        if w[q+1]!='=' continue        // Not an argument
        if Strcmp(w+q+2,setfld)==0 break
      enddo
      j=Processfield(cmd+i,setfld,w+q+BINCODE,arg,amask,asize,xsize,error,dummy)
      if j<0 return -1
    endif
  enddo
  return i
end

// Decodes data string, as used in EXTINIT and MOVE:EXT.
function int Processdatastring(char *cmd,char *str,int *nstr,char *error)
  int i,l,n,q
  i=Skipchar(cmd,' ')
  if cmd[i]!='\"' then
    Strcpy(error,"ASCII command expected"); return -1; endif
  i++
  n=0
  while 1 do
    if cmd[i]=='\"' then
      i++; break
    else if cmd[i]=='\0' then
      Strcpy(error,"Unterminated string"); return -1
    else
      if cmd[i]=='\\' && cmd[i+1]=='n' then
        str[n]='\n'; n++; i=i+2
      else if cmd[i]=='\\' && cmd[i+1]=='r' then
        str[n]='\r'; n++; i=i+2
      else if cmd[i]=='\\' && cmd[i+1]=='t' then
        str[n]='\t'; n++; i=i+2
      else if cmd[i]=='\\' && Toupper(cmd[i+1])=='X' then
        i=i+2; q=0
        for l=0,l<2,l++ do
          if cmd[i]>='0' && cmd[i]<='9' then
            q=q*16+cmd[i]-'0'
          else if cmd[i]>='A' && cmd[i]<='F' then
            q=q*16+cmd[i]-'A'+10
          else if cmd[i]>='a' && cmd[i]<='f' then
            q=q*16+cmd[i]-'a'+10
          else
            break
          endif
          i++
        enddo
        str[n]=q; n++
      else if cmd[i]=='\\' && cmd[i+1]!='\0' then
        str[n]=cmd[i+1]; n++; i=i+2
      else
        str[n]=cmd[i]; n++; i++
      endif
    endif
  enddo
  nstr[0]=n
  return i
end

// Parses all possible arguments of S_MOVE and decodes them to binary form.
// Expects that "M" (or "MOVE") is already extracted from cmd and code of
// S_MOVE is added to buf. On success, returns number of decoded bytes. On
// error, creates error message and returns -1.
function int SERV.Parsemovecmd(char *cmd,char *buf,int *nbuf,char *error)
  int i,j,k,l,m,n,p,q,z,h,c,length,offset,par,isheadcam,isencoder,hiacc
  int sign,havez,nmeas,ival,chan,cmdcode,panel,group,net,t,u,v
  int cmdpos,altcmd,allowdigits,dummy1,dummy2
  float f,dx,dy,r
  char key[64],setfld[32],type[32]
  // Command parts.
  char heads[10]; int nhead                         // List of single heads
  char hlist[80]; int nlist                         // List of secondary heads
  char range,rmask; int rpresent                    // Range
  char arg[768],amask[768]; int asize,xsize,hasargs // Arguments
  char dist[32]; int ndist                          // Search distances
  char str[1024]; int nstr                          // String prefixed by length
  // If called for the first time, separate fields in the table.
  if w[0,10]!='\0' then
    for m=0,w[m,0]!='#',m++ do
      for j=0,j<DLEN,j++ do
        if w[m,j]==' ' w[m,j]='\0'
      enddo
    enddo
  endif
  // Get all components of the move command, one after another.
  i=0; n=nbuf[0]; nmeas=0
  while 1 do
    // Parts of the command may be commented out. Comment starts with the
    // slash-asterisk combination and ends after the first encountered
    // asterisk-slash counterpair.
    i=i+Skipchar(cmd+i,' ')
    if cmd[i]=='/' && cmd[i+1]=='*' then
      i=i+2
      while 1 do
        if cmd[i]=='\0' break
        if cmd[i]=='*' && cmd[i+1]=='/' then
          i=i+2
          break
        endif
        i++
      enddo
      continue
    endif
    // I accept comma as a separator between the move command specifiers.
    if cmd[i]=='\0' break              // End of move command reached
    i=i+Skipchar(cmd+i,',')
    if Isdigit(cmd[i]) || cmd[i]=='@' || cmd[i]=='#' then
      // Head, headcam or encoder coordinate.
      if (cmd[i]=='@') then
        isheadcam=1; isencoder=0
        i=i+Skipchar(cmd+i,'@')
        if Isdigit(cmd[i])==0 then
          Strcpy(error,"Missing head ID after '@'"); return -1
        endif
      else if (cmd[i]=='#') then
        isheadcam=0; isencoder=1
        i=i+Skipchar(cmd+i,'#')
        if Isdigit(cmd[i])==0 then
          Strcpy(error,"Missing head ID after '#'"); return -1
        endif
      else
        isheadcam=0; isencoder=0
      endif
      offset=n
      buf[n]=0x81; n++                 // Stub for coordinate subcommand
      j=Scanint(cmd+i,&k); i=i+j
      if j<0 then
        Strcpy(error,"Syntax error"); return -1; endif
      if Toupper(cmd[i])=='L' then
        k=k*2; i++
      else if Toupper(cmd[i])=='R' then
        k=k*2+1; i++
      endif
      if k<0 || k>=34 then
        Strcpy(error,"Head out of range 0..33"); return -1; endif
      buf[n]=k; n++                    // Destination finger
      i=i+Skipchar(cmd+i,' ')
      hiacc=0
      if cmd[i]==':' then
        if isencoder then
          Strcpy(error,"High accuracy for encoder is not allowed")
          return -1
        endif
        hiacc=1; i++
        i=i+Skipchar(cmd+i,' ')
      endif
      par=cmd[i]; i++
      if par=='(' then
        if isheadcam then
          Strcpy(error,"Round parentheses for head camera are not allowed")
          return -1
        else if isencoder then
          Strcpy(error,                                                        \
            "Round parentheses for encoder coordinate are not allowed")
          return -1
        endif
        par=')'
      else if par=='[' then
        par=']'; buf[offset]=buf[offset]|0x40
      else
        Strcpy(error,"Expecting parenthesis '(' or '['"); return -1
      endif
      i=i+Skipchar(cmd+i,' ')
      if Toupper(cmd[i])=='Z' then
        if isheadcam then
          Strcpy(error,"Attempt to move head camera in home position")
          return -1
        else if isencoder then
          Strcpy(error,"Encoder movement in home position is not allowed")
          return -1
        endif
        i++; buf[offset]=0x86          // Move in home position
        i=i+Skipchar(cmd+i,' ')
        hiacc=0
        if cmd[i]!=par then
          sprintf(error,"Closing parenthesis '%c' missing",par); return -1
        endif
        i++
      else if Strnicmp(cmd+i,"PARK",4)==0 then
        if isheadcam then
          Strcpy(error,"Attempt to move head camera in park position")
          return -1
        else if isencoder then
          Strcpy(error,"Encoder movement in park position is not allowed")
          return -1
        endif
        i=i+4; buf[offset]=0x90        // Move in park position
        i=i+Skipchar(cmd+i,' ')
        hiacc=0
        if cmd[i]!=par then
          sprintf(error,"Closing parenthesis '%c' missing",par); return -1
        endif
        i++
      else if Strnicmp(cmd+i,"SAME",4)==0 then
        i=i+4; buf[offset]=0x80        // Move to same position
        i=i+Skipchar(cmd+i,' ')
        hiacc=0
        if cmd[i]!=par then
          sprintf(error,"Closing parenthesis '%c' missing",par); return -1
        endif
        i++
      else if Strnicmp(cmd+i,"WARM",4)==0 then
        i=i+4; buf[offset]=0x93        // Move to warmup pad
        $uint2(buf+n)=$GLOBAL.defheight
        buf[n+2]=$GLOBAL.defaccuracy
        buf[n+3]=$GLOBAL.defstroke
        buf[n+4]=$GLOBAL.defpressure
        while 1 do
          i=i+Skipchar(cmd+i,' ')
          if cmd[i]==par then
            i++; break
          endif
          i=i+Skipchar(cmd+i,',')
          if Toupper(cmd[i])=='A' then
            i++                        // Process accuracy
            j=Scanfloat(cmd+i,&f); i=i+j
            if j<0 then
              Strcpy(error,"Invalid accuracy after 'A'"); return -1
            endif
            buf[n+2]=Max(0.0,Min(f,255.0))
          else if Toupper(cmd[i])=='H' then
            i++                        // Process height
            j=Scanfloat(cmd+i,&f); i=i+j
            if j<0 then
              Strcpy(error,"Invalid height after 'H'"); return -1
            endif
            f=Max(0.5,Min(f,60.0))
            $uint2(buf+n)=f*1000.0
          else if Toupper(cmd[i])=='V' then
            i++                        // Process speed
            j=Scanint(cmd+i,&k); i=i+j
            if j<0 then
              Strcpy(error,"Invalid stroke after 'V'"); return -1
            endif
            k=Max(0,Min(k,255))
            buf[n+3]=k
          else if Toupper(cmd[i])=='P' then
            i++                        // Process pressure
            j=Scanint(cmd+i,&k); i=i+j
            if j<0 then
              Strcpy(error,"Invalid pressure after 'P'"); return -1
            endif
            k=Max(0,Min(k,255))
            buf[n+4]=k
          else
            Strcpy(error,"Syntax error in head coordinate"); return -1
          endif
        enddo
        $uint2(buf+n+5)=0
        n=n+7
      else if isheadcam!=0 && hiacc!=0 then
        buf[offset]=0xCB               // Headcam movement, nanometer accuracy
        buf[n]=0; n++                  // Mode is currently 0
        dx=0; dy=0
        j=Scanfloat(cmd+i,&f); i=i+j
        if j<0 then
          Strcpy(error,"Invalid X coordinate"); return -1; endif
        $int4(buf+n)=f*256000.0; n=n+4
        i=i+Skipchar(cmd+i,' ')
        if (cmd[i]=='+' || cmd[i]=='-' || cmd[i]==':') then
          if cmd[i]==':' i=i+Skipchar(cmd+i,':')
          if cmd[i]=='-' then
            sign=-1; i++
          else if cmd[i]=='+' then
            sign=1; i++
          else
            sign=1
          endif
          j=Scanfloat(cmd+i,&dx); i=i+j
          if j<0 then
            Strcpy(error,"Invalid X correction")
            return -1; endif
          dx=dx*sign
        endif
        i=i+Skipchar(cmd+i,' ')
        if cmd[i]!=',' then
          Strcpy(error,"Missing comma between coordinates"); return -1; endif
        i++
        j=Scanfloat(cmd+i,&f); i=i+j
        if j<0 then
          Strcpy(error,"Invalid Y coordinate"); return -1; endif
        $int4(buf+n)=f*256000.0; n=n+4
        i=i+Skipchar(cmd+i,' ')
        if (cmd[i]=='+' || cmd[i]=='-' || cmd[i]==':') then
          if cmd[i]==':' i=i+Skipchar(cmd+i,':')
          if cmd[i]=='-' then
            sign=-1; i++
          else if cmd[i]=='+' then
            sign=1; i++
          else
            sign=1
          endif
          j=Scanfloat(cmd+i,&dy); i=i+j
          if j<0 then
            Strcpy(error,"Invalid Y correction")
            return -1; endif
          dy=dy*sign
        endif
        $int2(buf+n)=$GLOBAL.defaccuracy*256
        while 1 do
          i=i+Skipchar(cmd+i,' ')
          if cmd[i]==par then
            i++; break
          endif
          i=i+Skipchar(cmd+i,',')
          if Toupper(cmd[i])=='A' then
            i++                        // Process accuracy
            j=Scanfloat(cmd+i,&f); i=i+j
            if j<0 then
              Strcpy(error,"Invalid accuracy after 'A'"); return -1
            endif
            $int2(buf+n)=Max(0.0,Min(f,255.0))*256.0
          else
            Strcpy(error,"Syntax error in head coordinate"); return -1
          endif
        enddo
        n=n+2
        $int4(buf+n)=dx*256000; n=n+4
        $int4(buf+n)=dy*256000; n=n+4
        $int4(buf+n)=0; n=n+4
        $int4(buf+n)=0; n=n+4
      else
        dx=0; dy=0; z=0; havez=0x0000
        $uint2(buf+n)=$GLOBAL.defheight; n=n+2
        buf[n]=0; n++                  // No bending
        j=Scanfloat(cmd+i,&f); i=i+j
        if j<0 then
          Strcpy(error,"Invalid X coordinate"); return -1; endif
        if hiacc then
          $int4(buf+n)=f*256000.0; n=n+4
        else
          $int3(buf+n)=f*1000.0; n=n+3
        endif
        i=i+Skipchar(cmd+i,' ')
        if (cmd[i]=='+' || cmd[i]=='-' || cmd[i]==':') then
          if cmd[i]==':' i=i+Skipchar(cmd+i,':')
          if cmd[i]=='-' then
            sign=-1; i++
          else if cmd[i]=='+' then
            sign=1; i++
          else
            sign=1
          endif
          j=Scanfloat(cmd+i,&dx); i=i+j
          if j<0 then
            Strcpy(error,"Invalid X correction")
            return -1; endif
          if isencoder!=0 then
            Strcpy(error,"Corrections are not allowed for encoder movement")
            return -1; endif
          dx=dx*sign
        endif
        i=i+Skipchar(cmd+i,' ')
        if cmd[i]!=',' then
          Strcpy(error,"Missing comma between coordinates"); return -1; endif
        i++
        j=Scanfloat(cmd+i,&f); i=i+j
        if j<0 then
          Strcpy(error,"Invalid Y coordinate"); return -1; endif
        if hiacc then
          $int4(buf+n)=f*256000.0; n=n+4
        else
          $int3(buf+n)=f*1000.0; n=n+3
        endif
        i=i+Skipchar(cmd+i,' ')
        if (cmd[i]=='+' || cmd[i]=='-' || cmd[i]==':') then
          if cmd[i]==':' i=i+Skipchar(cmd+i,':')
          if cmd[i]=='-' then
            sign=-1; i++
          else if cmd[i]=='+' then
            sign=1; i++
          else
            sign=1
          endif
          j=Scanfloat(cmd+i,&dy); i=i+j
          if j<0 then
            Strcpy(error,"Invalid Y correction")
            return -1; endif
          if isencoder!=0 then
            Strcpy(error,"Corrections are not allowed for encoder movement")
            return -1; endif
          dy=dy*sign
        endif
        i=i+Skipchar(cmd+i,' ')
        r=0.0                          // Process radius, if any
        if cmd[i]==',' then
          i=i+Skipchar(cmd+i,',')
          if Isdigit(cmd[i]) || cmd[i]=='-' || cmd[i]=='+' || cmd[i]=='.' then
            j=Scanfloat(cmd+i,&r); i=i+j
            if j<0 || r<0.0 || r>=64.0 then
              Strcpy(error,"Invalid radius"); return -1; endif
            if isheadcam!=0 && r!=0.0 then
              Strcpy(error,"Radius is not allowed for head camera")
              return -1
            else if isencoder!=0 && r!=0.0 then
              Strcpy(error,"Radius is not allowed for encoder movement")
              return -1
            endif
          endif
        endif
        if hiacc then
          $uint4(buf+n)=r*256000.0; n=n+4
        else
          $uint2(buf+n)=r*1000.0; n=n+2
        endif
        if hiacc then
          $int2(buf+n)=$GLOBAL.defaccuracy*256
        else
          buf[n]=$GLOBAL.defaccuracy
        endif
        buf[n+1+hiacc]=$GLOBAL.defstroke
        buf[n+2+hiacc]=$GLOBAL.defpressure
        while 1 do
          i=i+Skipchar(cmd+i,' ')
          if cmd[i]==par then
            i++; break
          endif
          i=i+Skipchar(cmd+i,',')
          if Toupper(cmd[i])=='A' then
            i++                        // Process accuracy
            j=Scanfloat(cmd+i,&f); i=i+j
            if j<0 then
              Strcpy(error,"Invalid accuracy after 'A'"); return -1
            endif
            if hiacc then
              $int2(buf+n)=Max(0.0,Min(f,255.0))*256.0
            else
              buf[n]=Max(0.0,Min(f,255.0))
            endif
          else if Toupper(cmd[i])=='H' then
            i++                        // Process height
            j=Scanfloat(cmd+i,&f); i=i+j
            if j<0 then
              Strcpy(error,"Invalid height after 'H'"); return -1
            endif
            f=Max(0.5,Min(f,60.0))
            $uint2(buf+offset+2)=f*1000.0
          else if Toupper(cmd[i])=='Z' then
            i++                        // Process Z coordinate
            j=Scanfloat(cmd+i,&f); i=i+j
            if j<0 then
              Strcpy(error,"Invalid Z coordinate after 'Z'")
              return -1; endif
            if isencoder then
              Strcpy(error,"Z coordinate is not allowed for encoder movement")
              return -1; endif
            f=Max(-32.7,Min(f,32.7))
            z=Floor(f*1000.0+0.5); havez=0x8000
          else if Toupper(cmd[i])=='Q' then
            i++                        // Process absolute Z coordinate
            j=Scanfloat(cmd+i,&f); i=i+j
            if j<0 then
              Strcpy(error,"Invalid Z coordinate after 'Q'")
              return -1; endif
            if isencoder then
              Strcpy(error,"Z coordinate is not allowed for encoder movement")
              return -1; endif
            if hiacc==0 then
              Strcpy(error,"Use hi-acc movement for absolute Z coordinate")
              return -1; endif
            if f<5.0 || f>65.0 then
              Strcpy(error,"Absolute Z coordinate out of range 5..65 mm")
              return -1; endif
            z=Floor(f*1000.0+0.5); havez=0x8001
          else if Toupper(cmd[i])=='V' then
            i++                        // Process speed
            j=Scanint(cmd+i,&k); i=i+j
            if j<0 then
              Strcpy(error,"Invalid stroke after 'V'"); return -1
            endif
            k=Max(0,Min(k,255))
            buf[n+1+hiacc]=k
          else if Toupper(cmd[i])=='P' then
            i++                        // Process pressure
            j=Scanint(cmd+i,&k); i=i+j
            if j<0 then
              Strcpy(error,"Invalid pressure after 'P'"); return -1
            endif
            k=Max(0,Min(k,255))
            buf[n+2+hiacc]=k
          else
            Strcpy(error,"Syntax error in head coordinate"); return -1
          endif
        enddo
        n=n+3+hiacc
        if hiacc then
          buf[offset]=(buf[offset] & 0x40)|0x8C
          $int4(buf+n)=dx*256000; n=n+4
          $int4(buf+n)=dy*256000; n=n+4
          $int2(buf+n)=z; n=n+2
          buf[offset+4]=(buf[offset+4] & 0xFC) | (havez & 0x03)
          $int2(buf+n)=0; n=n+2        // Must be zero
        else if isencoder then
          buf[offset]=0x92
        else
          if dx!=0 || dy!=0 || isheadcam then
            buf[offset]=buf[offset]|0x08
            $int2(buf+n)=dx*1000; n=n+2
            $int2(buf+n)=dy*1000; n=n+2
          endif
          if havez!=0 then
            buf[offset]=buf[offset]|0x10
            $int2(buf+n)=z; n=n+2
          endif
          if isheadcam buf[offset]=0xCA
        endif
      endif
      continue
    endif
    // If this is not a coordinate, it must be a prefix, a control or a
    // measurement.
    i=i+Scanname(cmd+i,key)
    if key[0]=='\0' then
      Strcpy(error,"Expecting measurement, control or prefix"); return -1
    endif
    // Find measurement in the table.
    for m=0,w[m,CMDNAME]!='#',m++ do
      if w[m,CMDNAME]=='\0' continue
      if Strcmp(w[m]+CMDNAME,key)==0 break
    enddo
    if w[m,CMDNAME]=='#' then
      sprintf(error,"Unknown measurement '%s'",key); return -1
    endif
    if w[m,ISMEAS]=='*' then
      allowdigits=1
    else
      allowdigits=0
    endif
    // Extract parenthesis, if any.
    i=i+Skipchar(cmd+i,' ')
    if cmd[i]=='(' then
      par=')'; i++
    else
      if w[m,PARMS]!=0 then
        sprintf(error,"Missing left parenthesis after '%s'",key); return -1
      endif
      par=0
    endif
    cmdcode=Hexbyte(w[m]+BINCODE)
    // Initialize working variables.
    nhead=0; nlist=0
    ndist=0
    rpresent=0                         // Range is present
    hasargs=0                          // As yet no arguments specified
    asize=0                            // Size of arguments as yet undefined
    xsize=0                            // No additional arguments
    nstr=-1                            // String as yet undefined
    // Get arguments.
    k=PARMS
    while w[m,k]!='\0' do
      if w[m,k]=='<' then
        k++
        i=i+Skipchar(cmd+i,' ')
        if cmd[i]=='<' then
          i++
        else if cmd[i]=='>' then
          i++; cmdcode++
        else
          Strcpy(error,"ASSERT requires '<' or '>'"); return -1
        endif
      endif
      if w[m,k]=='H' || w[m,k]=='G' || w[m,k]=='U' then
        // Single head, single head followed by distance, or single head or GND.
        c=w[m,k]; k++
        i=i+Skipchar(cmd+i,' ')
        if c=='U' && Isalpha(cmd[i]) then
          i=i+Scanname(cmd+i,&key)
          if Stricmp(key,"GND")==0 then
            h=0xFF                     // Measurement to GND
          else
            Strcpy(error,"Expecting head or GND"); return -1
          endif
        else
          j=Scanint(cmd+i,&h); i=i+j
          if j<0 then
            Strcpy(error,"Missing head"); return -1; endif
          if Toupper(cmd[i])=='L' then
            h=h*2; i++
          else if Toupper(cmd[i])=='R' then
            h=h*2+1; i++
          endif
          if h<0 || h>64 then
            Strcpy(error,"Head out of allowed range"); return -1
          endif
        endif
        heads[nhead]=h; nhead++
        if c=='G' then
          i=i+Skipchar(cmd+i,' ')
          if cmd[i]==':' then
            i++
            h=0; j=Scanint(cmd+i,&h)
            if j<0 || h<0 || h>16384 then
              Strcpy(error,"Invalid search distance"); return -1; endif
            i=i+j
            $int2(dist+ndist)=h
          endif
          ndist=ndist+2
        endif
        i=i+Skipchar(cmd+i,',')
      else if w[m,k]=='R' then
        // Range and additional flags.
        k++; rpresent=1
        i=i+Skipchar(cmd+i,' ')
        if Isalpha(cmd[i])!=0 then
          i=i+Scanname(cmd+i,&key)
          if Stricmp(key,"RANGE")!=0 && Stricmp(key,"R")!=0 then
            Strcpy(error,"Missing or invalid range"); return -1; endif
          i=i+Skipchar(cmd+i,'=')
        endif
        h=0; j=Scanint(cmd+i,&h)
        if j<0 || h<0 || h>=32 then
          Strcpy(error,"Missing or invalid range"); return -1; endif
        i=i+j; range=h; rmask=0x1F
        while 1 do
          i=i+Skipchar(cmd+i,' ')
          if Isalpha(cmd[i])==0 break
          key[0]=cmd[i]; key[1]='\0'; i++
          for q=m+1,1,q++ do
            if w[q,0]!='\0' then
              sprintf(error,"Unknown key '%s'",key); return -1; endif
            if w[q,1]!=':' continue    // Not a range modifier
            if Strcmp(w[q]+2,key)==0 break
          enddo
          j=Processfield(cmd+i,key,w[q]+BINCODE,&range,&rmask,1,               \
            &xsize,error,setfld)
          if j<0 return -1
          i=i+j
        enddo
        i=i+Skipchar(cmd+i,',')
      else if w[m,k]=='X' then
        // Range set to 0.
        k++; range=0; rpresent=1
      else if w[m,k]=='T' || w[m,k]=='N' then
        // List of antennas or heads.
        if w[m,k]=='T' then
          hlist[nlist]=0x02; nlist++
          hlist[nlist]=1; nlist++
          hlist[nlist]=0; nlist++
          hlist[nlist]=1; nlist++
        endif
        hlist[nlist]=0; nlist++
        q=0
        while 1 do
          i=i+Skipchar(cmd+i,' ')
          if Isdigit(cmd[i])==0 break
          j=Scanint(cmd+i,&h); i=i+j
          if j<0 then
            Strcpy(error,"Syntax error"); return -1; endif
          if Toupper(cmd[i])=='L' then
            h=h*2; i++
          else if Toupper(cmd[i])=='R' then
            h=h*2+1; i++
          endif
          if h<0 || h>64 then
            Strcpy(error,"Head out of allowed range"); return -1; endif
          hlist[nlist+q]=h; q++
          i=i+Skipchar(cmd+i,',')
        enddo
        hlist[nlist-1]=q; nlist=nlist+q
        k++
        // Options.
        if w[m,k]=='*' then
          if q!=1 && q!=3 then
            sprintf(error,"Expecting 1 or 3 secondary heads"); return -1
          endif
          k++
        else if w[m,k]=='0' then
          k++
        else if Isdigit(w[m,k]) then
          if q!=w[m,k]-'0' then
            sprintf(error,"Expecting %i secondary heads",w[m,k]-'0'); return -1
          endif
          k++
        else if q==0 then
          Strcpy(error,"Expecting list of secondary heads"); return -1
        endif
      else if w[m,k]=='A' || w[m,k]=='B' then
        // Arguments.
        c=w[m,k]; k++
        j=Scanint(w[m]+k,&asize); k=k+j
        if j<0 || asize<=0 || asize>80 then
          Strcpy(error,"Internal error"); return -1; endif
        j=Processarguments(cmd+i,c=='B',allowdigits,w[m+1],arg,amask,asize,    \
          &xsize,&hasargs,error)
        if j<0 return -1
        i=i+j
      else if w[m,k]=='C' then
        // A sequence of COMP subcommands.
        k++
        // If called for the first time, separate fields in the table.
        if comp[0,10]!='\0' then
          for u=0,comp[u,0]!='#',u++ do
            for v=0,v<DLEN,v++ do
              if comp[u,v]==' ' comp[u,v]='\0'
            enddo
          enddo
        endif
        // Reserve place for options (currently 0) and subcommand size.
        $int4(arg)=0; asize=4
        // Add subcommands.
        while 1 do
          // Find subcommand in the table.
          i=i+Scanname(cmd+i,&key)
          if key[0]=='\0' then
            Strcpy(error,"Expecting closing parenthesis after COMP"); return -1
          endif
          for u=0,comp[u,CMDNAME]!='#',u++ do
            if comp[u,CMDNAME]=='\0' continue
            if Strcmp(comp[u]+CMDNAME,key)==0 break
          enddo
          if comp[u,CMDNAME]=='#' then
            sprintf(error,"Unknown COMP subcommand '%s'",key); return -1
          endif
          cmdpos=asize                 // Offset of subcommand in arg
          arg[asize]=Hexbyte(comp[u]+BINCODE); asize++
          i=i+Skipchar(cmd+i,' ')
          if comp[u,PARMS]=='\0' then
            if cmd[i]=='(' then
              i++
              i=i+Skipchar(cmd+i,' ')
              if cmd[i]!=')' then
                Strcpy(error,"Expecting closing parenthesis"); return -1
              endif
              i++
              i=i+Skipchar(cmd+i,' ')
            endif
            if cmd[i]==')' break
            continue
          endif
          // Extract parenthesis.
          if cmd[i]!='(' then
            sprintf(error,"Missing left parenthesis after '%s'",key); return -1
          endif
          i++
          // Extract arguments. Only H, U, O and A are allowed. This part more
          // or less repeats code above in this routine.
          v=PARMS
          altcmd=0
          while comp[u,v]!='\0' do
            if comp[u,v]=='H' || comp[u,v]=='U' || comp[u,v]=='O' then
              // Single head, single head or GND, or optional head.
              c=comp[u,v]; v++
              i=i+Skipchar(cmd+i,' ')
              if c=='U' && Isalpha(cmd[i]) then
                i=i+Scanname(cmd+i,&key)
                if Stricmp(key,"GND")==0 then
                  h=0xFF               // Measurement to GND
                else
                  Strcpy(error,"Expecting head or GND"); return -1
                endif
                arg[asize]=h; asize++
              else if c=='H' || c=='U' then
                j=Scanint(cmd+i,&h); i=i+j
                if j<0 then
                  Strcpy(error,"Missing head"); return -1; endif
                if Toupper(cmd[i])=='L' then
                  h=h*2; i++
                else if Toupper(cmd[i])=='R' then
                  h=h*2+1; i++
                endif
                if h<0 || h>64 then
                  Strcpy(error,"Head out of allowed range"); return -1
                endif
                arg[asize]=h; asize++
              else
                if arg[cmdpos]==Hexbyte(comp[u]+ALTCODE) then
                  // Always fill optional heads.
                  altcmd=1
                endif
                if Isdigit(cmd[i]) then
                  arg[cmdpos]=Hexbyte(comp[u]+ALTCODE)
                  altcmd=1
                  j=Scanint(cmd+i,&h); i=i+j
                  if j<0 then
                    Strcpy(error,"Missing head"); return -1; endif
                  if Toupper(cmd[i])=='L' then
                    h=h*2; i++
                  else if Toupper(cmd[i])=='R' then
                    h=h*2+1; i++
                  endif
                  if h<0 || h>64 then
                    Strcpy(error,"Head out of allowed range"); return -1
                  endif
                  arg[asize]=h; asize++
                else if altcmd!=0 then
                  arg[asize]=0xFF      // Head is not used
                  asize++
                else
                  continue
                endif
              endif
              i=i+Skipchar(cmd+i,',')
            else if comp[u,v]=='A' then
              // Arguments.
              v++
              j=Scanint(comp[u]+v,&t); v=v+j
              if j<0 || t<0 || t>80 then
                Strcpy(error,"Internal error"); return -1; endif
              j=Processarguments(cmd+i,0,0,comp[u+1],arg+asize,                \
                amask+asize,t,&dummy1,&dummy2,error)
              if j<0 return -1
              i=i+j
              asize=asize+t
            else
              Strcpy(error,"Internal error (COMP description)"); return -1
            endif
          enddo
          i=i+Skipchar(cmd+i,' ')
          if cmd[i]!=')' then
            Strcpy(error,"Expecting closing parenthesis after COMP"); return -1
          endif
          i++
          i=i+Skipchar(cmd+i,' ')
          if cmd[i]==')' break
          i=i+Skipchar(cmd+i,',')
        enddo
        if asize<=4 then
          Strcpy(error,"Missing COMP data"); return -1
        endif
        $int2(arg+2)=asize-4
      else if w[m,k]=='D' then
        // Debug data.
        k++
        asize=0
        while 1 do
          i=i+Skipchar(cmd+i,' ')
          if Isdigit(cmd[i]) then
            j=Scanint(cmd+i,&h); i=i+j
            if j<0 then
              Strcpy(error,"Syntax error"); return -1; endif
            if Toupper(cmd[i])=='L' then
              h=h*2; i++
            else if Toupper(cmd[i])=='R' then
              h=h*2+1; i++
            endif
            if asize>=256 then
              Strcpy(error,"Too long DEBUG data"); return -1; endif
            arg[asize]=h; asize++
          else if cmd[i]=='\"' then
            i++
            while 1 do
              if cmd[i]=='\"' then
                i++; break
              else if cmd[i]=='\0' then
                Strcpy(error,"Unterminated string"); return -1
              else if asize>=256 then
                Strcpy(error,"Too long DEBUG data"); return -1
              else
                arg[asize]=cmd[i]; asize++
                i++
              endif
            enddo
          else
            Strcpy(error,"Unsupported dump item"); return -1; endif
          i=i+Skipchar(cmd+i,' ')
          if cmd[i]==')' break
          i=i+Skipchar(cmd+i,',')
        enddo
        if asize==0 then
          Strcpy(error,"Missing DEBUG data"); return -1
        endif
        // Second byte of the debug data is the length of the following data.
        if asize>1 Memcpy(arg+2,arg+1,asize-1)
        arg[1]=asize-1
        asize++
      else if w[m,k]=='S' then
        // String, preceeded by two-byte length.
        k++
        j=Processdatastring(cmd+i,str,&nstr,error)
        if j<0 return -1
        i=i+j
      else if w[m,k]=='L' then
        // Panel, group, net.
        k++
        j=Scanint(cmd+i,&panel); i=i+j
        if j<0 then
          Strcpy(error,"Missing panel ID"); return -1; endif
        if panel<0 || panel>=65535 then
          Strcpy(error,"Invalid panel ID"); return -1; endif
        i=i+Skipchar(cmd+i,',')
        j=Scanint(cmd+i,&group); i=i+j
        if j<0 then
          Strcpy(error,"Missing group ID"); return -1; endif
        if group<0 || group>=65535 then
          Strcpy(error,"Invalid group ID"); return -1; endif
        i=i+Skipchar(cmd+i,' ')
        if cmd[i]==',' || Isdigit(cmd[i]) then
          i=i+Skipchar(cmd+i,',')
          j=Scanint(cmd+i,&net); i=i+j
          if j<0 then
            Strcpy(error,"Missing net ID"); return -1; endif
          if net<0 || net>=0x00FFFFFF then
            Strcpy(error,"Invalid net ID"); return -1;
          endif
        else
          net=0
        endif
        $uint2(arg+asize)=panel; asize=asize+2
        $uint2(arg+asize)=group; asize=asize+2
        if net==0 then
          cmdcode=0x87
        else
          cmdcode=0x97
          $uint3(arg+asize)=net; asize=asize+3
        endif
        hasargs=1
      else if w[m,k]=='M' || w[m,k]=='E' then
        // Panel, group, multiple head:net pairs, or multiple head:pad pairs.
        if w[m,k]=='M' then
          j=Scanint(cmd+i,&panel); i=i+j
          if j<0 then
            Strcpy(error,"Missing panel ID"); return -1; endif
          if panel<0 || panel>=65535 then
            Strcpy(error,"Invalid panel ID"); return -1; endif
          i=i+Skipchar(cmd+i,',')
          j=Scanint(cmd+i,&group); i=i+j
          if j<0 then
            Strcpy(error,"Missing group ID"); return -1; endif
          if group<0 || group>=65535 then
            Strcpy(error,"Invalid group ID"); return -1; endif
          i=i+Skipchar(cmd+i,' ')
          $uint2(arg+asize)=panel; asize=asize+2
          $uint2(arg+asize)=group; asize=asize+2
          Strcpy(type,"net")
        else
          Strcpy(type,"pad")
        endif
        k++
        offset=asize
        arg[asize]=0; asize++
        while 1 do
          i=i+Skipchar(cmd+i,' ')
          if cmd[i]==')' break
          i=i+Skipchar(cmd+i,',')
          if arg[offset]>=32 then
            sprintf(error,"More than 32 head:%s pairs",type); return -1; endif
          j=Scanint(cmd+i,&h); i=i+j
          if j<0 then
            Strcpy(error,"Syntax error"); return -1; endif
          if Toupper(cmd[i])=='L' then
            h=h*2; i++
          else if Toupper(cmd[i])=='R' then
            h=h*2+1; i++
          endif
          if h<0 || h>=32 then
            Strcpy(error,"Head out of range 0..31"); return -1; endif
          arg[asize+3]=h
          if cmd[i]!=':' then
            sprintf(error,"Missing colon in head:%s",type); return -1; endif
          i++
          j=Scanint(cmd+i,&net); i=i+j
          if j<0 then
            Strcpy(error,"Syntax error"); return -1; endif
          if net<0 || net>=0x00FFFFFF then
            sprintf(error,"Invalid %s ID",type); return -1; endif
          $uint3(arg+asize)=net
          arg[offset]++
          asize=asize+4
        enddo
      else if w[m,k]=='P' then
        // Command-depending postprocessing. Stays last in the list, all data
        // is already gathered.
        k++
        if Memcmp(w[m]+k,"EXT",3)==0 then
          // External measurement.
          k=k+3
          if (amask[0] & 0x07)==0 then
            chan=($GLOBAL.a5==0?0:4)
          else
            chan=arg[0] & ($GLOBAL.a5==0?0x03:0x07)
          endif
          if $GLOBAL.a5==0 then
            arg[0]=(($GLOBAL.extmode[chan]|0x40) & 0xFC)+chan
          else
            arg[0]=(($GLOBAL.extmode[chan]|0x40) & 0xF8)+chan
          endif
          arg[1]=$GLOBAL.extbaud[chan]
          if amask[2]==0 arg[2]=$GLOBAL.extwait[chan]
          if amask[4]==0 then
            arg[3]=$GLOBAL.extecho[chan]
            arg[4]=$GLOBAL.extanswer[chan]
            arg[5]=$GLOBAL.extprompt[chan]
            if ($uint1($GLOBAL+508+chan) & 0x01)!=0 &&                         \
              (nstr==0 || (str[nstr-1]!='\n' && str[nstr-1]!='\r'))            \
            then
              str[nstr]='\r'; nstr++   // $GLOBAL.extopt: add CR/LF
              str[nstr]='\n'; nstr++
            endif
          else
            if nstr==0 || str[nstr-1]!=arg[4] then
              str[nstr]=arg[4]
              nstr++
            endif
          endif
        else if Memcmp(w[m]+k,"STA",3)==0 then
          // Extended COMP answer, include individual statuses.
          arg[0]=arg[0] | 0x01
        endif
        break                          // Last in the description
      else
        Strcpy(error,"Internal error (measurement description)"); return -1
      endif
    enddo
    // Get matching closing parenthesis.
    if par!=0 then
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!=par then
        Strcpy(error,"Expecting closing parenthesis"); return -1
      endif
      i++
    endif
    // Gather processed fields into a single command.
    if w[m,ISMEAS]=='+' || w[m,ISMEAS]=='*' then
      nmeas++                          // This is a measurement
    endif
    if Isxdigit(w[m,ALTCODE]) && hasargs!=0 then
      // Use alternative command code.
      buf[n]=Hexbyte(w[m]+ALTCODE)
    else if Isxdigit(w[m,ALTCODE]) && hasargs==0 then
      // Use main command code, no arguments.
      buf[n]=cmdcode; asize=0
    else
      buf[n]=cmdcode
    endif
    n++
    // Add mode.
    if Isxdigit(w[m,MODE]) then
      buf[n]=Hexbyte(w[m]+MODE); n++
    endif
    // Add heads.
    if nhead>0 then
      Memcpy(buf+n,heads,nhead); n=n+nhead
    endif
    // Add range.
    if rpresent then
      buf[n]=range; n++
    endif
    // Add hlist.
    if nlist>0 then
      Memcpy(buf+n,hlist,nlist); n=n+nlist
    endif
    // Add arguments.
    if asize>0 then
      Memcpy(buf+n,arg,asize+xsize); n=n+asize+xsize
    endif
    // Add search distances.
    if ndist>0 then
      Memcpy(buf+n,dist,ndist); n=n+ndist
    endif
    // Add string.
    if nstr>=0 then
      $uint2(buf+n)=nstr; n=n+2
      if nstr>0 then
        Memcpy(buf+n,str,nstr); n=n+nstr
      endif
    endif
  enddo
  if nmeas==0 then
    Strcpy(error,"Command contains no measurements"); return -1
  endif
  nbuf[0]=n
  return i
end

// Decodes command in ASCII format to binary buffer. On success, returns number
// of decoded bytes. On error, creates error message and returns -1. Supports
// external antennas (pseudoheads 32,33) and multiple measurements in S_MOVE.
function int SERV.Parsecmdext(char *cmd,char *buf,char *error)
  int i,j,k,n,ext,xsize,hasargs,chan,nstr
  float f,g
  char key[64],subkey[64],amask[64],str[1024]
  n=0
  i=Scanalphanum(cmd,key)
  if key[0]=='\0' then
    Strcpy(error,"Missing command"); return -1; endif
  if Strcmp(key,"M")==0 || Strcmp(key,"MOVE")==0 then
    buf[n]=S_MOVE; n++
    j=SERV.Parsemovecmd(cmd+i,buf,&n,error)
    if j<0 return -1
    i=i+j
  else if Strcmp(key,"DEFBOARD")==0 then
    buf[n]=S_DEFBOARD; n++
    buf[n]=0; n++
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    $int3(buf+n)=f*1000.0; n=n+3
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    $int3(buf+n)=f*1000.0; n=n+3
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    $int3(buf+n)=f*1000.0; n=n+3
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    $int3(buf+n)=f*1000.0; n=n+3
  else if Strcmp(key,"DEFREGION")==0 then
    buf[n]=S_DEFBOARD; n++
    buf[n]=1; n++
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    $int3(buf+n)=f*1000.0; n=n+3
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    $int3(buf+n)=f*1000.0; n=n+3
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    $int3(buf+n)=f*1000.0; n=n+3
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    $int3(buf+n)=f*1000.0; n=n+3
    i=i+Skipchar(cmd+i,',')
    i=i+Scanname(cmd+i,subkey)
    if subkey[0]!='\0' && Strcmp(subkey,"H")!=0 then
      sprintf(error,"Invalid key '%s'",subkey); return -1; endif
    if subkey[0]!='\0' i=i+Skipchar(cmd+i,'=')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    if f<0 || f>65.535 goto badrange
    $uint2(buf+n)=f*1000.0; n=n+2
  else if Strcmp(key,"MAKEZMAP")==0 then
    buf[n]=S_DEFBOARD; n++
    buf[n]=2; n++
  else if Strcmp(key,"HVINIT")==0 then
    buf[n]=S_HVINIT; n++
    // First parameter must be voltage.
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    if f<0.0 || f>1000.0 goto badrange
    $uint2(buf+n)=f; n=n+2
    i=i+Skipchar(cmd+i,' ')
    ext=0
    if cmd[i]==',' then
      ext=1; i=i+Skipchar(cmd+i,',')
    endif
    if Isdigit(cmd[i]) then
      ext=1                            // Old style initialization
    else if Isalpha(cmd[i]) then
      ext=2                            // "Long" initialization
    endif
    if ext==1 then
      // Old style initialization.
      $int2(buf+n)=1000; n=n+2
      j=Scanfloat(cmd+i,&f); i=i+j
      if j<0 goto badparm
      f=Max(1.0,Min(f,50.0))
      $int2(buf+n)=f*10; n=n+2
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]==',' then
        i++
        j=Scanint(cmd+i,&k); i=i+j
        if j<0 goto badparm
        k=Max(1,Min(k,10000))
        $int2(buf+n)=k; n=n+2
        i=i+Skipchar(cmd+i,' ')
        if cmd[i]==',' then
          i++
          j=Scanint(cmd+i,&k); i=i+j
          if j<0 goto badparm
          k=Max(1,Min(k,100))
          $int2(buf+n)=k; n=n+2
        else
          $int2(buf+n)=0; n=n+2
        endif
      else
        $int2(buf+n)=250; n=n+2
      endif
    else if ext==2 then
      // "Long" initialization.
      j=Processarguments(cmd+i,0,0,hvinit,buf+n,amask,28,&xsize,&hasargs,error)
      if j<0 return -1
      i=i+j
      n=n+28
    else
      // Default initialization.
      $int2(buf+n)=1000; n=n+2
      $int2(buf+n)=50; n=n+2
      $int2(buf+n)=10; n=n+2
      $int2(buf+n)=1;  n=n+2
    endif
  else if Strcmp(key,"HVSTEP")==0 || Strcmp(key,"HVSTEPS")==0 then
    buf[n]=S_HVINIT; n++
    j=Processarguments(cmd+i,0,1,hvsteps,buf+n,amask,48,&xsize,&hasargs,error)
    if j<0 return -1
    i=i+j
    n=n+48
  else if Strcmp(key,"EXACTINIT")==0 then
    buf[0]=S_EXACTINIT; n=1
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    if f<0.0 || f>327.67 goto badrange
    $int2(buf+n)=f*100.0; n=n+2
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    if f<0.0 || f>32.767 goto badrange
    $int2(buf+n)=f*1000.0; n=n+2
    $int2(buf+n)=0; n=n+2
    i=i+Skipchar(cmd+i,',')
    j=Scanint(cmd+i,&k); i=i+j
    if j<0 goto badparm
    $int2(buf+n)=k; n=n+2
  else if Strcmp(key,"RINIT")==0 then
    buf[0]=S_RINIT; n=1
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    if f<0.0 || f>512.0 goto badrange
    $int2(buf+n)=f; n=n+2
    $int4(buf+n)=0; n=n+4
    $int4(buf+n)=0; n=n+4
  else if Strcmp(key,"CRTINIT")==0 || Strcmp(key,"MSDINIT")==0 then
    buf[0]=S_CRTINIT; n=1
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    if f<0.0 || f>1024.0 goto badrange
    $int2(buf+n)=f; n=n+2
    i=i+Skipchar(cmd+i,',')
    if Isalpha(cmd[i]) then
      i=i+Scanname(cmd+i,subkey)
      if Strcmp(subkey,"ADJUST")!=0 goto badparm
      $int2(buf+n)=0x0001; n=n+2
    else
      $int2(buf+n)=0x0000; n=n+2
    endif
    $int2(buf+n)=0; n=n+2
    $int4(buf+n)=0; n=n+4
  else if Strcmp(key,"SHORT")==0 then
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    f=Max(1.0e7,Min(f,1.0e8))          // Allowed range is 10..100 M
    buf[0]=S_DEBUG
    buf[1]=0x0E
    $float4(buf+2)=f
    $int4(buf+6)=0
    $int4(buf+10)=0
    $int4(buf+14)=0
    n=18
  else if Strcmp(key,"INPORT")==0 then
    buf[0]=S_INPORT; n=1
    j=Scanint(cmd+i,&k); i=i+j
    if j<0 goto badparm
    $uint2(buf+n)=k; n=n+2
  else if Strcmp(key,"OUTPORT")==0 then
    buf[0]=S_OUTPORT; n=1
    j=Scanint(cmd+i,&k); i=i+j
    if j<0 goto badparm
    $uint2(buf+n)=k; n=n+2
    i=i+Skipchar(cmd+i,',')
    j=Scanint(cmd+i,&k); i=i+j
    if j<0 goto badparm
    $uint2(buf+n)=k; n=n+2
  else if Strcmp(key,"INPORT32")==0 then
    buf[0]=S_INPORT32
    i=i+Scanname(cmd+i,subkey)
    if Strcmp(subkey,"HEAD")==0 then
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!='(' then
        Strcpy(error,"Missing parenthesis after HEAD"); return -1; endif
      i++
      j=Scanint(cmd+i,&k); i=i+j
      if j<0 goto badparm
      if k<0 || k>31 goto badrange
      buf[1]=k
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!=')' then
        Strcpy(error,"Missing parenthesis after HEAD"); return -1; endif
      i++
    else if Strcmp(subkey,"VIDEO")==0 then
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!='(' then
        Strcpy(error,"Missing parenthesis after VIDEO"); return -1; endif
      i++
      j=Scanint(cmd+i,&k); i=i+j
      if j<0 goto badparm
      if k<0 || k>1 goto badrange
      buf[1]=k+$LAY.nfing*2
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!=')' then
        Strcpy(error,"Missing parenthesis after VIDEO"); return -1; endif
      i++
    else if Strcmp(subkey,"MEAS")==0 then
      buf[1]=0x80
    else if Strcmp(subkey,"CRATE")==0 then
      buf[1]=0xFF
    else
      sprintf(error,"Invalid %s destination",key); return -1
    endif
    i=i+Skipchar(cmd+i,',')
    j=Scanint(cmd+i,&k); i=i+j
    if j<0 goto badparm
    $int4(buf+2)=k
    n=6
  else if Strcmp(key,"OUTPORT32")==0 then
    buf[0]=S_OUTPORT32
    i=i+Scanname(cmd+i,subkey)
    if Strcmp(subkey,"HEAD")==0 then
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!='(' then
        Strcpy(error,"Missing parenthesis after HEAD"); return -1; endif
      i++
      j=Scanint(cmd+i,&k); i=i+j
      if j<0 goto badparm
      if k<0 || k>31 goto badrange
      buf[1]=k
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!=')' then
        Strcpy(error,"Missing parenthesis after HEAD"); return -1; endif
      i++
    else if Strcmp(subkey,"ALL")==0 then
      buf[1]=0x7F
    else if Strcmp(subkey,"VIDEO")==0 then
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!='(' then
        Strcpy(error,"Missing parenthesis after VIDEO"); return -1; endif
      i++
      j=Scanint(cmd+i,&k); i=i+j
      if j<0 goto badparm
      if k<0 || k>1 goto badrange
      buf[1]=k+$LAY.nfing*2
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]!=')' then
        Strcpy(error,"Missing parenthesis after VIDEO"); return -1; endif
      i++
    else if Strcmp(subkey,"MEAS")==0 then
      buf[1]=0x80
    else if Strcmp(subkey,"CRATE")==0 then
      buf[1]=0xFF
    else
      sprintf(error,"Invalid %s destination",key); return -1
    endif
    i=i+Skipchar(cmd+i,',')
    j=Scanint(cmd+i,&k); i=i+j
    if j<0 goto badparm
    $int4(buf+2)=k
    i=i+Skipchar(cmd+i,',')
    j=Scanint(cmd+i,&k); i=i+j
    if j<0 goto badparm
    $int4(buf+6)=k
    n=10
  else if Strcmp(key,"STROKE")==0 then
    buf[0]=S_STROKE; n=1
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    f=Max(1.0,Min(f,127.0))
    $GLOBAL.defstroke=f
    buf[n]=f/2; n++
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&g); i=i+j
    if j<0 goto badparm
    g=Max(1.0,Min(g,127.0))
    $GLOBAL.defpressure=g
    buf[n]=Max(0.0,(g-f/2.0)/3.2); n++
    i=i+Skipchar(cmd+i,',')
    j=Scanfloat(cmd+i,&f); i=i+j
    if j<0 goto badparm
    f=Max(0.1,Min(f,32.0))
    $GLOBAL.defheight=f*1000.0
    buf[n]=f*4+1; n++
  else if Strcmp(key,"EXTINIT")==0 then
    buf[0]=S_EXTINIT; n=1
    j=Processarguments(cmd+i,0,0,extinit,buf+n,amask,11,&xsize,&hasargs,error)
    if j<0 return -1
    i=i+j
    j=Processdatastring(cmd+i,str,&nstr,error)
    if j<0 return -1
    i=i+j
    if nstr==0 then
      Strcpy(error,"Empty data string"); return -1; endif
    if (amask[0] & 0x07)==0 then
      chan=($GLOBAL.a5==0?0:4)
    else
      chan=buf[n] & ($GLOBAL.a5==0?0x03:0x07)
    endif
    if $GLOBAL.a5==0 then
      buf[n]=($GLOBAL.extmode[chan] & 0xBC) | (buf[n] & 0x40) | chan
    else
      buf[n]=($GLOBAL.extmode[chan] & 0xB8) | (buf[n] & 0x40) | chan
    endif
    buf[n+1]=$GLOBAL.extbaud[chan]
    if amask[2]==0 buf[n+2]=$GLOBAL.extwait[chan]
    if amask[4]==0 then
      buf[n+3]=$GLOBAL.extecho[chan]
      buf[n+4]=$GLOBAL.extanswer[chan]
      buf[n+5]=$GLOBAL.extprompt[chan]
      if ($uint1($GLOBAL+508+chan) & 0x01)!=0 &&                               \
        (nstr==0 || (str[nstr-1]!='\n' && str[nstr-1]!='\r'))                  \
      then
        str[nstr]='\r'; nstr++
        str[nstr]='\n'; nstr++
      endif
    else
      if nstr==0 || str[nstr-1]!=buf[n+4] then
        str[nstr]=buf[n+4]
        nstr++
      endif
    endif
    n=n+11
    $int2(buf+n)=nstr; n=n+2
    Memcpy(buf+n,str,nstr)
    n=n+nstr
  else if Strcmp(key,"RLINIT")==0 then
    buf[0]=S_RLINIT; n=1
    j=Processarguments(cmd+i,0,0,rlinit,buf+n,amask,26,&xsize,&hasargs,error)
    if j<0 return -1
    i=i+j
    n=n+26
  else if Strcmp(key,"BIN")==0 then
    n=0
    while 1 do
      i=i+Skipchar(cmd+i,' ')
      if cmd[i]=='\0' || (cmd[i]=='/' && cmd[i+1]=='/') break
      if n>=1020 then
        Strcpy(error,"Too long binary data"); return -1; endif
      if Isxdigit(cmd[i])==0 || Isxdigit(cmd[i+1])==0 then
        Strcpy(error,"Non-hexadecimal binary data"); return -1; endif
      if Isdigit(cmd[i]) then
        j=(cmd[i]-'0')*16
      else
        j=(Toupper(cmd[i])-'A'+10)*16
      endif
      i++
      if Isdigit(cmd[i]) then
        j=j+(cmd[i]-'0')
      else
        j=j+(Toupper(cmd[i])-'A'+10)
      endif
      i++
      buf[n]=j; n++
    enddo
    if n==0 then
      Strcpy(error,"Missing binary data"); return -1
    endif
  else
    sprintf(error,"Unknown command '%s'",key); return -1
  endif
  i=i+Skipchar(cmd+i,' ')
  if cmd[i]!='\0' && (cmd[i]!='/' || cmd[i+1]!='/') then
    Strcpy(error,"Extra characters on line"); n=-1
  endif
  return n
badparm:
  Strcpy(error,"Invalid or missing parameter")
  return -1
badrange:
  Strcpy(error,"Parameter out of range")
  return -1
end

// Compatible version of command parser without error report. Decodes command
// in ASCII format to binary buffer. On success, returns number of decoded
// bytes. On error, returns -1. Supports external antennas (pseudoheads 32,33)
// and multiple measurements in S_MOVE.
function int SERV.Parsecmd(char *cmd,char *buf)
  char error[256]
  return Parsecmdext(cmd,buf,error)
end

// Decodes command in ASCII format and sends it as an easy command. As for any
// easy command, only one answer per command is allowed. If command begins with
// dollar sign, sends command to HARD.DLL (succeeds in embedded version only).
function int SERV.Cmdimm(int ident,char *cmd)
  int i
  char buf[1024],error[256]
  if cmd[0]=='$' then
    if Embedded()==0 return -1
    return SYS.Sendtextimm(ident,cmd+1)
  else
    i=SERV.Parsecmdext(cmd,buf,error)
    if i<=0 return -1
    return SYS.Sendimm(ident,i,buf)
  endif
end

// Dummy function, necessary due to the SCRIPT2 syntax rules.
function int main()

end
