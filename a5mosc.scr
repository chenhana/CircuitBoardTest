#include "ls.icl"                  // Standard functions
#include "or.icl"                // A2 command names
#include "pa.icl"                  // Support for files in rich text format
#anyid                                 // Answerproc receives all answers
#multinst                              // We need at most 2
#cmdbuff 1

#define VERSION        ""
#define DESCRIPTION    "Oscilloscope for measurement card"

// 1.05: Associated command.
// 1.06: Sweep extended to 100 ms/div.
// 1.07: Small cosmetical changes.
// 1.08: Subtract DAC.
// 1.09: Fast Fourier transform, changed layout, no card selection.
// 1.10: Background data.
// 1.11: Signals changed to signed with zero at 32768 bits;
//       background plot can be shifted to the right or left.
// 1.12: External manual strobe.
// 1.13: ADC-DAC between cursors (best fit) instead of Subtract DAC.
// 1.14: ADC-DAC with 1/20 point interpolation.
// 1.15: Support for dual measurement card.
// 1.16: Bug in the legend for the background curve (main data displayed).
// 1.17: Save/restore state to/from disk.
// 1.18: Rewritten for better behaviour, improved FFT and save.
// 1.19: Mean value in the regression display.
// 1.20: Improved regression, indication of sigma.
// 1.21: Two Fourier cursors, total energy.
// 1.22: Trigger on range and on out of range.

#define HEADER         "atg measurement card oscillogramm 1.0 "

#define NOSC           4096            // Maximal number of data points
#define NCMD           512             // Maximal length of command (text)
#define NHIST          32              // Maximal number of history plots
#define MINFWIDTH      256             // Minimal FFT width
#define MAXFWIDTH      2048            // Maximal FFT width

#define PLOTDX         512             // Width of plot window
#define PLOTDY         400             // Height of plot window
#define CMDDY          45              // Total height of command bar
#define OVDX           300             // Width of overview window
#define OVDY           108             // Height of overview window
#define CHANDX         164             // Distance between control groups
#define OVERSCAN       3600            // Number of points in overscan mode
#define SYNCDX         384             // Synchronization interval for free run
#define FFTXOFFS       20              // Start of FFT plot, pixel

#define MANUAL         0               // Manual trigger
#define FREERUN        1               // Free run
#define FREESYNC1      2               // Free run with autosync on channel 1
#define FREESYNC2      3               // Free run with autosync on channel 2
#define MEASTRIG       6               // Trigger on measurement
#define BADTRIG        7               // Trigger on bad measurement
#define INRANGE        8               // Trigger on range
#define OUTRANGE       9               // Trigger on out of range

#define ZERO           32768           // Zero of DAC/ADC

typedef struct t_data                  // Oscillogramm
  int            card                  // Card (1: master, 2: slave)
  int            count                 // Number of data points in data[]
  float          data[2][NOSC]         // 2 data channels
  int            ofs[2]                // Data count in channel
  int            complete[2]           // Channel is completed
  char           cmd[NCMD]             // Command in text form
  int            cmdid                 // Identifier of measurement command
  char           answer[NCMD]          // Answer in text form
ends

typedef struct t_saveosci              // Oscillogramm file header
  int            card                  // Measurement card
  int            trigger               // Trigger settings
  int            sweep                 // Sweep speed index
  int            overscan              // Overscan flag
  int            procmode              // Processing mode
  int            subtract              // Fit curve flag
  int            regress               // Linear regression flag
  int            xoffset               // X offset in overscan mode, pixels
  int            bgcount               // Number of data points in bg
  int            bgoffset[2]           // Offset index for background data
  int            bgmanual[2]           // Manual offset for background data
  int            bgshift               // X shift of background data, pixels
  int            yoffset               // Y offset in overscan mode, pixels
  $float4        vmin                  // Low range limit
  $float4        vmax                  // High range limit
  int            reserved[7]           // Reserved for the future use
  int            scale0                // ADC scale
  int            offset0               // ADC offset
  int            manual0               // ADC mode
  int            reserved0[5]          // Reserved for the future use
  int            scale1                // DAC scale
  int            offset1               // DAC offset
  int            manual1               // DAC mode
  int            reserved1[5]          // Reserved for the future use
  int            cursor1               // Position of first cursor
  int            cursor2               // Position of second cursor
  int            totalhist             // Number of following oscillogramms
  int            histcount[NHIST]      // Number of points in history item
  int            histcard[NHIST]       // Card history
ends

int              loadchanged           // 1: load status changed
int              layoutchanged         // 1: layout changed
int              hardreset             // 1: hard reset
handle           hmain                 // Main window
handle           hplot                 // Displays oscillogrammes
handle           hcmd                  // Answer and command
handle           hcard                 // Measurement card
handle           htrig                 // Trigger
handle           hsweep                // Sweep speed
handle           hoverscan             // Extended X
handle           hvmintxt              // Text for low range limit
handle           hvmin                 // Low range limit
handle           hvmaxtxt              // Text for high range limit
handle           hvmax                 // High range limit
handle           hstart                // Start oscilloscope
handle           hstop                 // Stop oscilloscope
handle           hnormal               // Show oscillogramm
handle           hhistogram            // Show histogramm
handle           hfourier              // Show FFT
handle           hfwidth               // Width of FFT area
handle           hfwchange             // Change width of FFT area
handle           hsubtract             // Subtract best fit
handle           hsubleft              // Move subtract left
handle           hsubright             // Move subtract right
handle           hregress              // Linear regression between cursors
handle           hload                 // Load data from disc
handle           hsave                 // Save data to disc
handle           hoverview             // Overview in case of overscan
handle           hsca[2]               // ADC/DAC scales
handle           hofs[2]               // ADC/DAC modes
handle           hscr[2]               // ADC/DAC shifts

int              nmeascard             // Number of measurement cards: 1 or 2
int              card                  // 0: both, 1: master, 2: slave
int              maxcount              // Requested number of data points
int              trigger               // Condition to start acquisition
int              sweep                 // Sweep index
int              overscan              // Overscan mode
int              procmode              // Data processing mode
int              fwidth                // FFT width, MINFWIDTH..MAXFWIDTH points
int              subtract              // Fit curve flag
int              regress               // Linear regression flag
int              oscman                // Click on manual from Answerproc
int              start                 // Send command to controller
int              redraw                // Redraw screen
int              cursor1               // Position of first cursor, pixel
int              cursor2               // Position of second cursor, pixel
int              cursorh               // Position of histogram cursor, pixel
int              cursorf1              // Position of first Fourier curs, pixel
int              cursorf2              // Position of second Fourier curs, pixel
int              catched               // Cursor catched in hplot, 0: none
int              ovcatch               // Cursor catched in hoverview, 0: none
int              ovx0,ovy0             // Mouse where cursor was catched
int              ovofsx,ovofsy         // Offset when cursor was catched
int              running               // Acquisition running
int              stopupdate            // Temporarily stop history updating
int              scale[2]              // Scale index
int              offset[2]             // Offset index
int              manual[2]             // Manual offset, divisions
struct t_data    inbuf[2]              // Input buffers, master and slave
int              datavalid             // OK to use data
int              xoffset               // X offset in overscan mode, pixels
int              yoffset               // Y offset in overscan mode, pixels
float            vmin                  // Low range limit
float            vmax                  // High range limit
int              fftshift              // Start of FFT graph, points
char             savefile[260]         // Last used save file name
struct t_data    hist[NHIST]           // History data
int              histindex             // Newest (last written) history slot
int              totalhist             // Total number of valid plots
int              backinhist            // Currently selected backward offset
struct t_data    bg                    // Background oscillogramm
int              bgshift               // X shift of background data, pixels
int              bgoffset[2]           // Offset index for background data
int              bgmanual[2]           // Manual offset for background data

int              chcolor[4]  = { BLACK,     LIGHTRED,  LIGHTBLUE,  MAGENTA }
int              lowcolor[2] = { LIGHTGRAY, PINK }

external int SERV.Decodecommand(char *command,char *s,int mask)
external int SERV.Decodeanswer(char *answer,char *text,char *extra,int mask);

function int Answerproc(char *answer,int info)
  int i,j,n,ch,ofs,cmdid,index,fullanswer
  char s[1024],extra[4096]
  cmdid=$uint2(answer+2)
  if answer[4]==0xF0 then
    // Internal OLLYTEST message.
    if Stricmp(answer+5,"CHG LOAD")==0 loadchanged=1
    if Stricmp(answer+5,"CHG LAY")==0 layoutchanged=1
    if Stricmp(answer+5,"HARD RESET")==0 hardreset=1
    if Stricmp(answer+5,"OSC MAN")==0 oscman=1
    return
  else if answer[4]==S_TEST && answer[5]==0x03 && cmdid==0 && running!=0 then
    // Oscillogramm.
    i=answer[6]-0x80                   // Head from answer
    if (i==0 && card<=1) || (i==1 && (card==0 || card==2)) then
      inbuf[i].card=i+1                // Card
      ch=answer[7]                     // Channel
      if ch==3 then                    // Contains original command
        if SERV.Decodecommand(answer+14,s,-1)<0 then
          inbuf[i].cmd[0]='\0'
        else
          Strncpy(inbuf[i].cmd,s,NCMD)
        endif
        inbuf[i].cmdid=$uint1(answer+16)
      endif
      if ch>=2 return                  // Unsupported channel
      inbuf[i].count=$uint2(answer+8)  // Total number of data points
      ofs=$uint2(answer+10)            // Offset of first data point
      n=$uint2(answer+12)              // Number of data points in answer
      if ofs!=inbuf[i].ofs[ch] || ofs+n>NOSC then
        inbuf[i].card=0                // Missing or invalid data, discard
        inbuf[i].count=0
        inbuf[i].ofs[0]=0
        inbuf[i].ofs[1]=0
        inbuf[i].complete[0]=0
        inbuf[i].complete[1]=0
        inbuf[i].cmdid=0
        inbuf[i].cmd[0]='\0'
        inbuf[i].answer[0]='\0'
        goto restart
      endif
      for j=0,j<n,j++ do
        inbuf[i].data[ch,ofs+j]=$float4(answer+14+j*4)
      enddo
      inbuf[i].ofs[ch]=ofs+n
      if ofs+n>=$uint2(answer+8) inbuf[i].complete[ch]=1
    endif
  else
    // Some other answer. Check whether oscillogramm is present in the queue.
    if cmdid!=0 then
      for i=0,i<totalhist,i++ do
        index=(histindex-i+NHIST)%NHIST
        if hist[index].cmdid==cmdid then
          SERV.Decodeanswer(answer,hist[index].answer,extra,0xFFFFFFFF)
          hist[index].cmdid=0
          if i==backinhist then
            change hcmd text=hist[index].cmd
            add hcmd text="\n"
            add hcmd text=hist[index].answer
          endif
          break
        endif
      enddo
    endif
    return                             // inbuf remains unchanged
  endif
  // Check whether we have all answers we need.
  fullanswer=0
  for i=0,i<2,i++ do                   // For both measurement cards
    for ch=0,ch<2,ch++ do
      if inbuf[i].complete[ch]==0 break
    enddo
    if ch<2 continue                   // Some data is still missed
    fullanswer=1
    if stopupdate==0 then
      histindex=(histindex+1)%NHIST
      Strcpy(inbuf[i].answer,"No answer")
      Memcpy(hist[histindex],inbuf[i],Sizeof(inbuf)/2)
      totalhist=Min(NHIST,totalhist+1)
      backinhist=0
      redraw=1
      datavalid=1
      enable hsave
    endif
    inbuf[i].card=0
    inbuf[i].count=0
    inbuf[i].ofs[0]=0
    inbuf[i].ofs[1]=0
    inbuf[i].complete[0]=0
    inbuf[i].complete[1]=0
    inbuf[i].cmdid=0
    inbuf[i].cmd[0]='\0'
    inbuf[i].answer[0]='\0'
  enddo
  if fullanswer==0 return
restart:
  if running!=0 then
    if (trigger==FREERUN ||                                                    \
      (trigger>=FREESYNC1 && trigger<=FREESYNC2)) then
      start=1
    else if trigger==MANUAL then
      running=0
      change hstart color=BLACK
      change hstop color=LIGHTRED
    endif
  endif
end

function int Closecard(int card)
  char buf[64]
  buf[0]=S_TEST
  buf[1]=0x03                          // Setup A5 oscilloscope
  buf[2]=card+0x80                     // Card
  buf[3]=0                             // Trigger
  $uint2(buf+4)=1                      // Compression
  $uint2(buf+6)=0                      // Maximal length of protocol
  buf[8] =0                            // Data source for channel 1
  buf[9] =0                            // Data source for channel 2
  buf[10]=0                            // Data source for channel 3
  buf[11]=0                            // Data source for channel 4
  SYS.Send(12,buf,0)
  start=0
end

// Service function, enables or disables some oscilloscope controls and
// updates values of some variables.
function int Setcontrols()
  if procmode==2 then
    enable hfwidth
    enable hfwchange
    if fwidth>PLOTDX && overscan==0 then
      fwidth=MINFWIDTH
      while fwidth*2<=PLOTDX do fwidth=fwidth*2; enddo
    endif
    change hfwidth text=format("%i",fwidth)
    change hfwidth bkcolor=WHITE
  else
    disable hfwidth
    disable hfwchange
    change hfwidth text=""
    change hfwidth bkcolor=LIGHTGRAY
  endif
  if totalhist==0 then
    disable hsave
  else
    enable hsave
  endif
  if overscan==0 && (xoffset>0 || yoffset!=0) then
    xoffset=0
    yoffset=0
    redraw=1
  endif
  if overscan==0 && (cursor1>=PLOTDX || cursor2>=PLOTDX) then
    cursor1=PLOTDX/4; cursor2=PLOTDX*3/4
    redraw=1
  endif
  if overscan==0 && fftshift+fwidth>PLOTDX then
    fftshift=PLOTDX-fwidth
    redraw=1
  else if overscan!=0 && fftshift+fwidth>OVERSCAN then
    fftshift=OVERSCAN-fwidth
    redraw=1
  endif
  if trigger==INRANGE || trigger==OUTRANGE then
    if hvmintxt==NULL then
      hvmintxt=control TEXT
        window=hmain
        position=PLOTDX+19,122,30,15
        text="Min="
        help=" "
        font=SMALLFONT
        color=BLACK
        bkcolor=LIGHTGRAY
      endc
      hvmin=control EDIT
        window=hmain
        position=PLOTDX+50,120,67,17
        text=format("%g",vmin)
        help="触发范围下限"
        font=SMALLFONT
        color=BLACK
        bkcolor=WHITE
      endc
      hvmaxtxt=control TEXT
        window=hmain
        position=PLOTDX+19,138,30,15
        text="Max="
        help=" "
        font=SMALLFONT
        color=BLACK
        bkcolor=LIGHTGRAY
      endc
      hvmax=control EDIT
        window=hmain
        position=PLOTDX+50,136,67,17
        text=format("%g",vmax)
        help="触发范围上限"
        font=SMALLFONT
        color=BLACK
        bkcolor=WHITE
      endc
    endif
    change hoverscan position=PLOTDX+20,102,98,18
    change hstart position=PLOTDX+19,157,47,22
    change hstop position=PLOTDX+70,157,47,22
  else
    if hvmintxt!=NULL then
      destroy hvmintxt; hvmintxt=NULL
      destroy hvmin; hvmin=NULL
      destroy hvmaxtxt; hvmaxtxt=NULL
      destroy hvmax; hvmax=NULL
    endif
    change hoverscan position=PLOTDX+20,104,98,18
    change hstart position=PLOTDX+19,125,98,24
    change hstop position=PLOTDX+19,155,98,24
  endif

// THERE IS AN ERROR ABOVE, CHECK!!!!!
if fftshift<0 fftshift=0

end

function int Prvalue(char *txt,char c,float value)
  float a
  if c==0 then
    draw text=txt
  else
    draw text=format("%c%s",c,txt)
  endif
  a=Abs(value)
  if a==0.0 then
    draw text="0.0"
  else if a<10.0 then
    draw text=format("%6.4f",value)
  else if a<100.0 then
    draw text=format("%6.3f",value)
  else if a<1000.0 then
    draw text=format("%6.2f",value)
  else if a<10000.0 then
    draw text=format("%6.1f",value)
  else if a<100000.0 then
    draw text=format("%6.0f",value)
  else if a<1000000.0 then
    draw text=format("%6.3fe5",value/100000.0)
  else if a<10000000.0 then
    draw text=format("%6.3fe6",value/1000000.0)
  else if a<9.9e9 then
    draw text=format("%6.4g",value)
  else
    draw text=format("%6.3g",value)
  endif
end

// Display modal "dialog box" with error message.
function int Error(char *s1,char *s2)
  handle herr,hdummy,hok
  herr=control WINDOW
    window=hmain
    position=0,0,350,135
    name="错误"
    mode=M_MODAL
    bkcolor=YELLOW
  endc
  hok=control BUTTON
    window=herr
    position=135,100,80,24
    name="确定"
    help="按下可以确认错误消息"
  endc
  hdummy=control ICON
    window=herr
    position=5,30,36,36
    name="EXCLAM"
    bkcolor=YELLOW
  endc
  hdummy=control TEXT
    window=herr
    position=41,20,300,24
    name=s1
    bkcolor=YELLOW
    mode=M_CENTERED
  endc
  hdummy=control TEXT
    window=herr
    position=41,45,300,54
    name=s2
    bkcolor=YELLOW
    mode=M_CENTERED
  endc
  while Pressed(hok)==0 do; enddo
  destroy herr
end

int compression[12] = {                                                        \
  1, 2, 5, 10, 25, 50, 125, 250, 500, 1000, 2500, 5000 }
float scalefactor[22] = {                                                      \
  0.01,    0.02,    0.05,    0.1,     0.2,     0.5,     1.0,     2.0,          \
  5.0,     10.0,    20.0,    50.0,    100.0,   200.0,   500.0,   1000.0,       \
  2000.0,  5000.0,  10000.0, 20000.0, 50000.0, 100000.0 }

// Saves current set of oscillogramms to binary file.
function int Saveosci(char *path)
  int i,j,n,index
  char *buf
  handle f
  struct t_saveosci so
  f=Fopen(path,"wb")
  if f==NULL then
    Error("Unable to create file",path)
    return -1
  endif
  // Save header.
  Fwrite(HEADER,Strlen(HEADER),f)
  // Save oscillogramm header.
  so.card=card
  so.trigger=trigger
  so.sweep=sweep
  so.overscan=overscan
  so.procmode=procmode
  so.subtract=subtract
  so.regress=regress
  so.xoffset=xoffset
  so.bgcount=bg.count
  so.bgoffset[0]=bgoffset[0]
  so.bgoffset[1]=bgoffset[1]
  so.bgmanual[0]=bgmanual[0]
  so.bgmanual[1]=bgmanual[1]
  so.bgshift=bgshift
  so.yoffset=yoffset
  so.vmin=vmin
  so.vmax=vmax
  so.scale0=scale[0]
  so.offset0=offset[0]
  so.manual0=manual[0]
  so.scale1=scale[1]
  so.offset1=offset[1]
  so.manual1=manual[1]
  so.cursor1=cursor1
  so.cursor2=cursor2
  so.totalhist=totalhist
  for i=0,i<NHIST,i++ do
    index=(histindex-i+NHIST)%NHIST
    so.histcount[i]=hist[index].count
    so.histcard[i]=hist[index].card
  enddo
  Fwrite(so,Sizeof(so),f)
  // Save oscillogramms.
  Alloc(buf,NOSC*4)
  for i=0,i<totalhist,i++ do
    index=(histindex-i+NHIST)%NHIST
    for j=0,j<hist[index].count,j++ do
      $float4(buf+j*4)=hist[index].data[0][j]
    enddo
    Fwrite(buf,hist[index].count*4,f)
    for j=0,j<hist[index].count,j++ do
      $float4(buf+j*4)=hist[index].data[1][j]
    enddo
    Fwrite(buf,hist[index].count*4,f)
    Fwrite(hist[index].cmd,NCMD,f)
    Fwrite(hist[index].answer,NCMD,f)
  enddo
  // Save background image.
  if bg.count>0 then
    for j=0,j<bg.count,j++ do
      $float4(buf+j*4)=bg.data[0][j]
    enddo
    Fwrite(buf,bg.count*4,f)
    for j=0,j<bg.count,j++ do
      $float4(buf+j*4)=bg.data[1][j]
    enddo
    Fwrite(buf,bg.count*4,f)
  endif
  Free(buf)
  Fclose(f)
  return 0
end

// Loads set of oscillogramms from the disc.
function int Loadosci(char *path)
  int i,j,k,n,index
  char s[256],*buf
  handle f
  struct t_saveosci so
  f=Fopen(path,"rb")
  if f==NULL then
    Error("Unable to open file",path)
    return -1
  endif
  // Check header.
  k=Strlen(HEADER)
  n=Fread(s,k,f)
  if n!=k || Memcmp(s,HEADER,k)!=0 goto error
  // Read oscillogramm header.
  n=Fread(so,Sizeof(so),f)
  if n!=Sizeof(so) goto error
  card=so.card
  change hcard select=card
  trigger=so.trigger
  change htrig select=(trigger>=6?trigger-2:trigger)
  sweep=so.sweep
  change hsweep select=sweep
  overscan=so.overscan
  change hoverscan mode=(overscan?M_CHECKED:0)
  procmode=so.procmode
  Setcontrols()
  change hnormal mode=(procmode==0?M_CHECKED:0)
  change hhistogram mode=(procmode==1?M_CHECKED:0)
  change hfourier mode=(procmode==2?M_CHECKED:0)
  subtract=so.subtract
  change hsubtract mode=(subtract?M_CHECKED:0)
  if subtract then
    enable hsubleft
    enable hsubright
  else
    disable hsubleft
    disable hsubright
  endif
  Memset(bg,0,Sizeof(bg))
  regress=so.regress
  change hregress mode=(regress?M_CHECKED:0)
  xoffset=so.xoffset
  bg.count=so.bgcount
  bgoffset[0]=so.bgoffset[0]
  bgoffset[1]=so.bgoffset[1]
  bgmanual[0]=so.bgmanual[0]
  bgmanual[1]=so.bgmanual[1]
  bgshift=so.bgshift
  yoffset=so.yoffset
  vmin=so.vmin
  vmax=so.vmax
  scale[0]=so.scale0
  offset[0]=so.offset0
  manual[0]=so.manual0
  scale[1]=so.scale1
  offset[1]=so.offset1
  manual[1]=so.manual1
  for i=0,i<2,i++ do
    change hsca[i] select=scale[i]
    change hofs[i] select=offset[i]
    change hscr[i] select=manual[i]
  enddo
  cursor1=so.cursor1
  cursor2=so.cursor2
  totalhist=so.totalhist
  datavalid=(totalhist!=0)
  backinhist=0
  Memset(hist,0,Sizeof(hist))
  for i=0,i<NHIST,i++ do
    index=(histindex-i+NHIST)%NHIST
    hist[index].count=so.histcount[i]
    hist[index].card=so.histcard[i]
  enddo
  // Restore oscillogramms.
  Alloc(buf,NOSC*4)
  for i=0,i<totalhist,i++ do
    index=(histindex-i+NHIST)%NHIST
    n=Fread(buf,hist[index].count*4,f)
    if n!=hist[index].count*4 goto error
    for j=0,j<hist[index].count,j++ do
      hist[index].data[0][j]=$float4(buf+j*4)
    enddo
    n=Fread(buf,hist[index].count*4,f)
    if n!=hist[index].count*4 goto error
    for j=0,j<hist[index].count,j++ do
      hist[index].data[1][j]=$float4(buf+j*4)
    enddo
    n=Fread(hist[index].cmd,NCMD,f)
    if n!=NCMD goto error
    n=Fread(hist[index].answer,NCMD,f)
    if n!=NCMD goto error
  enddo
  // Restore background image.
  if bg.count>0 then
    n=Fread(buf,bg.count*4,f)
    if n!=bg.count*4 goto error
    for j=0,j<bg.count,j++ do
      bg.data[0][j]=$float4(buf+j*4)
    enddo
    n=Fread(buf,bg.count*4,f)
    if n!=bg.count*4 goto error
    for j=0,j<bg.count,j++ do
      bg.data[1][j]=$float4(buf+j*4)
    enddo
  endif
  Free(buf)
  Fclose(f)
  return 0
error:
  Fclose(f)
  Error("Damaged or unsupported file",path)
  return -1
end

function int main()
  int i,j,k,n,q,t,x,y,x0,y0,xofs,bgxofs,sync,nf,mx,my,mb
  int sub1,sub2,ssh,reg1,reg2,hyst[PLOTDX],hystmax,cmdlen
  float subshift,ssd
  float r,f,yfact,yoffs,tfact,ymin,ymax,fstep,foffs
  float sum,tempfit[NOSC],uint[NOSC]
  float tempdata[2][NOSC],rein[4096],imin,reout[4096],imout[4096]
  float fftampl[2,512],fftfreq[512]
  float sx,sy,sxx,sxy,syy,det,rega,regb,regsigma
  char c,buf[64],s[256]
  handle hfind,hhist,hinc,hdec,hclear,hcopy,hcshift,hcleft,hcright
  handle hquit,hresend,hclip
  struct t_data temp
  loadchanged=0
  layoutchanged=0
  hardreset=0
  // Get number of measurement cards. If unavailable, assume 2 cards.
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x1002001E             // Query number of measurement cards
  SYS.Sendimm(0,6,buf)
  t=Time()
  hmain=control WINDOW
    window=NULL
    position=10,10,PLOTDX+129,PLOTDY+CMDDY+124
    name=format("测试卡示波器%s",VERSION)
    help=" "
    bkcolor=GRAY
    size=2048
  endc
  while 1 do
    if $A[0].length>0 break
    if Time()-t>700 then               // 700 ms is usually enough
      SYS.Killimm(0)
      break
    endif
    wait
  enddo
  if $A[0].length>0 && $A[0].answer==S_INPORT32 then
    nmeascard=$uint4($A[0]+5)
    if nmeascard==0 nmeascard=1
  else
    nmeascard=2                        // More or less safe default
  endif
  hplot=control GRAPH
    window=hmain
    position=6,5,PLOTDX,PLOTDY
    help="协议数据"
    bkcolor=WHITE
  endc
  draw window=hmain
  card=0; trigger=MANUAL; sweep=0; overscan=0;
  procmode=0; subtract=0; regress=0
  vmin=0.0
  vmax=200.0e6
  getini("Measscope","Settings","%i,%i,%i,%i,%i,%i,%i,%f,%f",                  \
    &card,&trigger,&sweep,&overscan,&procmode,&subtract,&regress,&vmin,&vmax)
  if card<0 || card>2 card=0
  if procmode!=1 && procmode!=2 procmode=0
  Strcpy(savefile,"a5mosc.osc")
  getini("Measscope","Savefile",savefile)
  hcmd=control TEXT
    window=hmain
    position=5,PLOTDY+7,PLOTDX-19,CMDDY-1
    help="与显示测量关联的命令" 
    font=SMALLFONT
    color=BLUE
    bkcolor=WHITE
    mode=M_BORDER
  endc
  hresend=control BUTTON
    window=hmain
    position=PLOTDX-15,PLOTDY+7,22,CMDDY/2
    name="S"
    help="再次发送命令"
    bkcolor=LIGHTGRAY
  endc
  hclip=control BUTTON
    window=hmain
    position=PLOTDX-15,PLOTDY+7+CMDDY/2,22,CMDDY/2
    name=""
    help="将命令复制到剪贴板"
    bkcolor=LIGHTGRAY
  endc
  // Trigger and X sweep controls.
  draw color=BLACK bkcolor=LIGHTGRAY font=SMALLFONT
  draw at PLOTDX+12,4 fillrect PLOTDX+124,184
  draw at PLOTDX+28,19 text="触发和扫描"
  hcard=control COMBOLIST
    window=hmain
    position=PLOTDX+19,24,98,200
    help="选择要监控的测量卡"
    font=MAINFONT
    mode=M_VSCROLL
  endc
  add hcard text=" Any card"
  add hcard text=" 主触发"
  add hcard text=" Slave"
  if nmeascard==1 card=1               // Single card: master only
  change hcard select=card
  if nmeascard==1 disable hcard
  htrig=control COMBOLIST
    window=hmain
    position=PLOTDX+19,50,98,200
    help="选择开始采集的事件"
    font=MAINFONT
    mode=M_VSCROLL
  endc
  add htrig text=" Manual"
  add htrig text=" 自由运动"
  add htrig text=" Sync ADC"
  add htrig text=" Sync DAC"
  add htrig text=" Meas"
  add htrig text=" Bad meas"
  add htrig text=" In range"
  add htrig text=" Off range"
  change htrig select=(trigger>=6?trigger-2:trigger)
  hsweep=control COMBOLIST
    window=hmain
    position=PLOTDX+19,76,98,250
    help="选择扫描速度"
    font=MAINFONT
    mode=M_VSCROLL
  endc
  add hsweep text=" 20 us/div"
  add hsweep text=" 40 us/div"
  add hsweep text="100 us/div"
  add hsweep text="200 us/div"
  add hsweep text="500 us/div"
  add hsweep text="  1 ms/div"
  add hsweep text="2.5 ms/div"
  add hsweep text="  5 ms/div"
  add hsweep text=" 10 ms/div"
  add hsweep text=" 20 ms/div"
  add hsweep text=" 50 ms/div"
  add hsweep text="100 ms/div"
  change hsweep select=sweep
  hoverscan=control CHECKBOX
    window=hmain
    position=PLOTDX+20,102,98,18
    name="扩展X"
    help=format("检查以收集%i X点替代%i",OVERSCAN,PLOTDX)
    bkcolor=LIGHTGRAY
    mode=(overscan?M_CHECKED:0)
  endc
  hstart=control BUTTON
    window=hmain
    position=PLOTDX+19,125,98,24
    text="开始"
    help="开始手动获取"
    font=MAINFONT
  endc
  hstop=control BUTTON
    window=hmain
    position=PLOTDX+19,155,98,24
    text="停止"
    color=LIGHTRED
    help="暂停获取"
    font=MAINFONT
  endc
  // Presentation controls.
  draw color=BLACK bkcolor=LIGHTGRAY font=SMALLFONT
  draw at PLOTDX+12,188 fillrect PLOTDX+124,329               //+4
  draw at PLOTDX+40,203 text="数据处理"
  hnormal=control RADIO
    window=hmain
    position=PLOTDX+20,206,45,19
    name="Osc"
    help="将ADC扫描显示为标准波形图"
    bkcolor=LIGHTGRAY
    mode=(procmode==0?M_CHECKED:0)
  endc
  hhistogram=control RADIO
    window=hmain
    position=PLOTDX+20,225,45,19
    name="直方图"
    help="将ADC扫描显示为直方图"
    bkcolor=LIGHTGRAY
    mode=(procmode==1?M_CHECKED:0)
  endc
  hfourier=control RADIO
    window=hmain
    position=PLOTDX+20,244,45,19
    name="FFT"
    help="显示ADC扫描的快速傅立叶变换"
    bkcolor=LIGHTGRAY
    mode=(procmode==2?M_CHECKED:0)
  endc
  hfind=control BUTTON
    window=hmain
    position=PLOTDX+71,207,46,16
    name="指针"
    help="将光标移至可见区域"
    font=TERMINALFONT
    bkcolor=LIGHTGRAY
  endc
  hfwidth=control EDIT
    window=hmain
    position=PLOTDX+71,244,30,17
    help="FFT区域的宽度，样本"
    font=SMALLFONT
    bkcolor=WHITE
    MODE=M_NOEDIT
  endc
  hfwchange=control BUTTON
    window=hmain
    position=PLOTDX+100,244,17,17
    help="更改FFT区域的宽度"
    bkcolor=GRAY
  endc
  hsubtract=control CHECKBOX
    window=hmain
    position=PLOTDX+20,270,55,20
    name="-DAC"
    help="显示ADC减去光标之间的最佳拟合DAC"
    bkcolor=LIGHTGRAY
    mode=(subtract?M_CHECKED:0)
  endc
  hsubleft=control BUTTON
    window=hmain
    position=PLOTDX+76,270,21,18
    name="<<"
    help="按住可将DAC左移"
    bkcolor=LIGHTGRAY
    mode=M_REPEAT
  endc
  if subtract==0 disable hsubleft
  hsubright=control BUTTON
    window=hmain
    position=PLOTDX+96,270,21,18
    name=">>"
    help="按住可将DAC右移"
    bkcolor=LIGHTGRAY
    mode=M_REPEAT
  endc
  if subtract==0 disable hsubright
  hregress=control CHECKBOX
    window=hmain
    position=PLOTDX+20,290,98,20
    name="回归"
    help="显示光标之间的线性最小平方拟合"
    bkcolor=LIGHTGRAY
    mode=(regress?M_CHECKED:0)
  endc
  // History controls.
  draw color=BLACK bkcolor=LIGHTGRAY font=SMALLFONT
  draw at PLOTDX+12,333 fillrect PLOTDX+124,421
  draw at PLOTDX+51,348 text="历史"
  hhist=control TEXT
    window=hmain
    position=PLOTDX+19,352,34,20
    help="  历史绘图(Act表示实际数据)，点击显示实际数据 "
    font=MEDIUMFONT
    bkcolor=WHITE
    mode=M_CENTERED|M_BORDER
  endc
  hinc=control BUTTON
    window=hmain
    position=PLOTDX+55,352,21,20
    name="<<"
    help="按住可滚动回看历史记录"
    bkcolor=LIGHTGRAY
    mode=M_REPEAT
  endc
  hdec=control BUTTON
    window=hmain
    position=PLOTDX+75,352,21,20
    name=">>"
    help="按住可向前滚动历史记录"
    bkcolor=LIGHTGRAY
    mode=M_REPEAT
  endc
  hclear=control BUTTON
    window=hmain
    position=PLOTDX+98,352,19,20
    name="C"
    help="清除示波器和历史记录"
    bkcolor=LIGHTGRAY
  endc
  hcopy=control BUTTON
    window=hmain
    position=PLOTDX+19,376,24,18
    name="BG"
    help="将图像复制到背景或删除背景图像"
    bkcolor=GRAY
  endc
  hcshift=control TEXT
    window=hmain
    position=PLOTDX+42,376,35,18
    help="背景图的X偏移 "
    bkcolor=LIGHTGRAY
    mode=M_CENTERED|M_BORDER
  endc
  disable hcshift
  hcleft=control BUTTON
    window=hmain
    position=PLOTDX+76,376,21,18
    name="<<"
    help="按住可将背景图向左移动"
    bkcolor=LIGHTGRAY
    mode=M_REPEAT
  endc
  disable hcleft
  hcright=control BUTTON
    window=hmain
    position=PLOTDX+96,376,21,18
    name=">>"
    help="按住可将背景图向右移动"
    bkcolor=LIGHTGRAY
    mode=M_REPEAT
  endc
  disable hcright
  hload=control BUTTON
    window=hmain
    position=PLOTDX+19,398,48,18
    name="载入"
    help="从文件中加载先前保存的示波器图"
    font=SMALLFONT
    bkcolor=LIGHTGRAY
  endc
  hsave=control BUTTON
    window=hmain
    position=PLOTDX+69,398,48,18
    name="保存"
    help="按下可将波形图和控件状态保存到文件"
    font=SMALLFONT
    bkcolor=LIGHTGRAY
  endc
  // Channel controls.
  for i=0,i<2,i++ do
    sprintf(s,"Channel[%i]",i)
    scale[i]=6; offset[i]=0; manual[i]=0;
    getini("Measscope",s,"%i,%i,%i",scale+i,offset+i,manual+i)
    scale[i]=Max(0,Min(21,scale[i]))
    draw color=chcolor[i] bkcolor=lowcolor[i] font=MEDIUMFONT
    draw at 5+CHANDX*i,PLOTDY+CMDDY+10 fillrect 165+CHANDX*i,PLOTDY+CMDDY+120
    draw at 64+CHANDX*i,PLOTDY+CMDDY+32 text=(i==0?"ADC":"DAC")
    draw font=INFOFONT color=BLACK
    draw at 12+CHANDX*i,PLOTDY+CMDDY+56 text="刻度:"
    draw at 12+CHANDX*i,PLOTDY+CMDDY+83 text="补偿:"
    hsca[i]=control COMBOLIST
      window=hmain
      position=61+CHANDX*i,PLOTDY+CMDDY+36,96,400
      help=format("通道%i的刻度，单位/刻度 ",i+1)
      font=MAINFONT
      mode=M_VSCROLL
    endc
    add hsca[i] text=" 0.01/div"
    add hsca[i] text=" 0.02/div"
    add hsca[i] text=" 0.05/div"
    add hsca[i] text=" 0.1/div"
    add hsca[i] text=" 0.2/div"
    add hsca[i] text=" 0.5/div"
    add hsca[i] text=" 1/div"
    add hsca[i] text=" 2/div"
    add hsca[i] text=" 5/div"
    add hsca[i] text=" 10/div"
    add hsca[i] text=" 20/div"
    add hsca[i] text=" 50/div"
    add hsca[i] text=" 100/div"
    add hsca[i] text=" 200/div"
    add hsca[i] text=" 500/div"
    add hsca[i] text=" 1K/div"
    add hsca[i] text=" 2K/div"
    add hsca[i] text=" 5K/div"
    add hsca[i] text=" 10K/div"
    add hsca[i] text=" 20K/div"
    add hsca[i] text=" 50K/div"
    add hsca[i] text=" 100K/div"
    change hsca[i] select=scale[i]
    hofs[i]=control COMBOLIST
      window=hmain
      position=61+CHANDX*i,PLOTDY+CMDDY+63,96,200
      help=format("通道%i的偏移量",i+1 )
    endc
    add hofs[i] text=" Auto (AC)"
    add hofs[i] text=" Cursor 1"
    add hofs[i] text=" Cursor 2"
    add hofs[i] text=" Manual"
    change hofs[i] select=offset[i]
    hscr[i]=control HSCROLL
      window=hmain
      position=12+CHANDX*i,PLOTDY+CMDDY+91,145,20
      help=format("手动通道%i的偏移量",i+1 )
      limits=-35,35
    endc
    change hscr[i] select=manual[i]
  enddo
  draw show
  // Overview window.
  hoverview=control GRAPH
    window=hmain
    position=7+CHANDX*2,PLOTDY+CMDDY+11,OVDX,OVDY
    help="扩展X数据总览. 左边鼠标:移动 X,右边:移动 X-Y"
  endc
  // Auxiliary controls.
  hquit=control BUTTON
    window=hmain
    position=PLOTDX+12,PLOTDY+CMDDY-20,112,26
    text="关闭"
    help="关闭示波器"
  endc
  // Prepare for the operation.
  start=0
  running=0
  redraw=1
  datavalid=0
  xoffset=0
  yoffset=0
  maxcount=PLOTDX
  fwidth=MAXFWIDTH
  cursor1=PLOTDX/4; cursor2=PLOTDX*3/4
  cursorh=PLOTDX/2;
  cursorf1=FFTXOFFS; cursorf2=PLOTDX-FFTXOFFS-1
  catched=0; ovcatch=0
  fftshift=0
  Setcontrols()
  while 1 do
    // Check for pressed buttons.
    if Pressed(hquit) then
      break
    else if Pressed(hcard) then
      card=Status(hcard)
    else if Pressed(htrig) then
      trigger=Status(htrig)
      if trigger>3 trigger=trigger+2
      Setcontrols()
      running=1
      start=1
      change hstart color=LIGHTRED
      change hstop color=BLACK
    else if Pressed(hsweep) then
      if running!=0 && trigger>=MEASTRIG start=1
    else if Pressed(hstart) then
      running=1
      start=1
      change hstart color=LIGHTRED
      change hstop color=BLACK
    else if oscman!=0 then
      oscman=0
      if trigger==0 && running==0 then
        running=1
        start=1
        change hstart color=LIGHTRED
        change hstop color=BLACK
      endif
    else if Pressed(hstop) then
      Closecard(0)
      if nmeascard==2 Closecard(1)
      running=0
      start=0
      change hstart color=BLACK
      change hstop color=LIGHTRED
    else if Pressed(hoverscan) then
      overscan=Status(hoverscan)
      if running!=0 && trigger>=MEASTRIG start=1
      Setcontrols()
      redraw=1
    else if hvmin!=NULL && Pressed(hvmin) then
      vmin=0.0; Text(hvmin,s); sscanf(s,"%f",&vmin)
      change hvmin text=format("%g",vmin)
    else if hvmax!=NULL && Pressed(hvmax) then
      vmax=0.0; Text(hvmax,s); sscanf(s,"%f",&vmax)
      change hvmax text=format("%g",vmax)
    else if Pressed(hsubtract) then
      subtract=Status(hsubtract)
      if subtract then
        enable hsubleft
        enable hsubright
      else
        disable hsubleft
        disable hsubright
      endif
      subshift=0.0
      redraw=1
    else if Pressed(hsubleft) then
      subshift=Max(-250.0,Min(subshift-0.05*(Status(hsubleft)+1),250.0))
      redraw=1
    else if Pressed(hsubright) then
      subshift=Max(-250.0,Min(subshift+0.05*(Status(hsubright)+1),250.0))
      redraw=1
    else if Pressed(hregress) then
      regress=Status(hregress)
      redraw=1
    else if Pressed(hnormal) then
      procmode=0
      Setcontrols()
      redraw=1
    else if Pressed(hhistogram) then
      procmode=1
      Setcontrols()
      redraw=1
    else if Pressed(hfourier) then
      procmode=2
      Setcontrols()
      redraw=1
    else if Pressed(hfind) then
      if procmode==1 then
        cursorh=PLOTDX/2
      else if procmode==2 then
        cursorf1=FFTXOFFS; cursorf2=PLOTDX-FFTXOFFS-1
      else
        if overscan then x0=xoffset; else x0=0; endif
        cursor1=x0+PLOTDX/4; cursor2=x0+PLOTDX*3/4
      endif
      redraw=1
    else if Pressed(hfwchange) then
      fwidth=fwidth*2
      if overscan==0 && fwidth>PLOTDX then
        fwidth=MINFWIDTH
      else if overscan==1 && fwidth>MAXFWIDTH then
        fwidth=MINFWIDTH
      endif
      Setcontrols()
      redraw=1
    else if Pressed(hhist) && backinhist!=0 then
      backinhist=0
      redraw=1
    else if Pressed(hdec) && backinhist!=0 then
      backinhist=Max(0,backinhist-1)
      redraw=1
    else if Pressed(hinc) && totalhist>0 then
      backinhist=Min(totalhist-1,backinhist+1)
      redraw=1
    else if Pressed(hcopy) then
      i=(histindex-backinhist+NHIST)%NHIST
      if bg.count>0 then
        bg.count=0
        change hcopy bkcolor=GRAY
        change hcshift text=""
        change hcshift bkcolor=LIGHTGRAY
        disable hcshift
        disable hcleft
        disable hcright
      else if hist[i].count>0 then
        Memcpy(bg,hist[i],Sizeof(bg))
        bgoffset[0]=offset[0]; bgoffset[1]=offset[1]
        bgmanual[0]=manual[0]; bgmanual[1]=manual[1]
        bgxofs=xofs
        bgshift=0
        change hcopy bkcolor=YELLOW
        enable hcshift
        change hcshift bkcolor=WHITE
        enable hcleft
        enable hcright
      endif
      redraw=1
    else if Pressed(hcleft) then
      bgshift=Max(-999,bgshift-Status(hcleft)/3-1)
      redraw=1
    else if Pressed(hcright) then
      bgshift=Min(999,bgshift+Status(hcright)/3+1)
      redraw=1
    else if Pressed(hload) then
      stopupdate=1
      if SYS.Browse(hmain,savefile,"Select oscillogramm file",0) then
        Closecard(0)
        if nmeascard==2 Closecard(1)
        running=0
        start=0
        change hstart color=BLACK
        change hstop color=LIGHTRED
        Loadosci(savefile)
        redraw=1
      endif
      stopupdate=0
    else if Pressed(hsave) then
      stopupdate=1
      if SYS.Browse(hmain,savefile,"Select file to save oscillogramm",0) then
        Saveosci(savefile)
      endif
      stopupdate=0
    else if Pressed(hclear) then
      totalhist=0; backinhist=0; datavalid=0
      Setcontrols()
      redraw=1
    else if Pressed(hclip) then
      i=(histindex-backinhist+NHIST)%NHIST
      Clipcopy(hist[i].cmd)
    else if Pressed(hresend) then
      i=(histindex-backinhist+NHIST)%NHIST
      SERV.Cmdimm(0,hist[i].cmd)
    else if hardreset then
      hardreset=0
      running=0
      start=0
      change hstart color=BLACK
      change hstop color=LIGHTRED
    endif
    for i=0,i<2,i++ do
      if Pressed(hsca[i]) then
        scale[i]=Status(hsca[i])
        redraw=1
      else if Pressed(hofs[i]) then
        offset[i]=Status(hofs[i])
        redraw=1
      else if Pressed(hscr[i]) then
        manual[i]=Status(hscr[i])
        redraw=1
      endif
    enddo
    // Move overview window.
    if procmode==0 && overscan!=0 &&                                           \
      (Mousexy(hoverview,&mx,&my,&mb)==1 || ovcatch!=0) && (mb & 0x3)!=0 then
      x=mx
      if ovcatch==0 then
        ovcatch=1
        ovx0=mx
        ovofsx=xoffset
        ovy0=my
        if (mb & 2)==0 then
          yoffset=0; redraw=1
        endif
        ovofsy=yoffset/20
      else
        mx=Max(0,Min(OVERSCAN-PLOTDX,ovofsx+(mx-ovx0)*12))
        if mx!=xoffset then
          xoffset=mx; redraw=1
        endif
        if (mb & 2)!=0 then
          my=Max(11-OVDY/2,Min(ovofsy+my-ovy0,OVDY/2-11))*20
          if my!=yoffset then
            yoffset=my; redraw=1
          endif
        endif
      endif
    else if procmode==2 && Status(hoverview)==1 then
      x=Limit0(hoverview)
      if ovcatch==0 then
        ovcatch=1
        ovx0=x
        ovofsx=fftshift
      else
        x=Max(0,Min((overscan?OVERSCAN:PLOTDX)-fwidth,ovofsx+(x-ovx0)*12))
        if x!=fftshift then
          fftshift=x
          redraw=1
        endif
      endif
    else
      ovcatch=0
    endif
    // Move cursors.
    if (Status(hplot)==1) then
      x=Limit0(hplot)
      if procmode==1 then              // Histogram
        x=Max(0,Min(PLOTDX-1,x))
        if catched==0 && Abs(cursorh-x)<5 catched=3
        if catched==3 && cursorh!=x then
          cursorh=x; redraw=1
        endif
      else if procmode==2 then         // Fast Fourier transform
        x=Max(FFTXOFFS,Min(PLOTDX-FFTXOFFS-1,x))
        if catched==0 && Abs(cursorf1-x)<5 catched=3
        if catched==0 && Abs(cursorf2-x)<5 catched=4
        if catched==3 && cursorf1!=x then
          cursorf1=x; redraw=1
        else if catched==4 && cursorf2!=x then
          cursorf2=x; redraw=1
        endif
      else                             // X-Y plot
        if overscan then
          if x<0 && xoffset>0 then
            xoffset=Max(0,xoffset+(x-5)/10); redraw=1
          else if x>=PLOTDX && xoffset<OVERSCAN-PLOTDX-1 then
            xoffset=Min(OVERSCAN-PLOTDX,xoffset+(x-PLOTDX+5)/10); redraw=1
          endif
        endif
        x=Max(0,Min(PLOTDX-1,x))+(overscan==0?0:xoffset)
        if catched==0 && Abs(cursor1-x)<5 catched=1
        if catched==0 && Abs(cursor2-x)<5 catched=2
        if catched==1 && cursor1!=x then
          cursor1=x; redraw=1
        else if catched==2 && cursor2!=x then
          cursor2=x; redraw=1
        endif
      endif
    else
      if catched!=0 redraw=1           // Reset cursor highlighting
      catched=0
    endif
    // Send command to tester.
    if start then                      // Start oscilloscope
      sweep=Max(0,Min(11,Status(hsweep)))
      buf[0]=S_TEST
      buf[1]=0x03                      // Setup A5 oscilloscope
      if trigger==MANUAL || trigger==FREERUN ||                                \
        (trigger>=FREESYNC1 && trigger<=FREESYNC2) then
        buf[3]=1                       // Trigger
      else
        buf[3]=trigger
      endif
      $uint2(buf+4)=compression[sweep] // Compression
      maxcount=(overscan?OVERSCAN:PLOTDX)
      if trigger==FREESYNC1 || trigger==FREESYNC2 then
        maxcount=maxcount+SYNCDX
      endif
      $uint2(buf+6)=maxcount           // Maximal length of protocol
      buf[8]=1                         // Data source for channel 1
      buf[9]=2                         // Data source for channel 2
      buf[10]=0                        // Data source for channel 3
      buf[11]=0                        // Data source for channel 4
      if trigger==INRANGE || trigger==OUTRANGE then
        vmin=0.0; Text(hvmin,s); sscanf(s,"%f",&vmin)
        change hvmin text=format("%g",vmin)
        vmax=0.0; Text(hvmax,s); sscanf(s,"%f",&vmax)
        change hvmax text=format("%g",vmax)
        $uint4(buf+12)=0
        $uint4(buf+16)=0
        $float4(buf+20)=Max(-1.0e30,Min(vmin,1.0e30))
        $float4(buf+24)=Max(-1.0e30,Min(vmax,1.0e30))
        cmdlen=28
      else
        cmdlen=12
      endif
      if card==0 || card==1 then
        buf[2]=0x80                    // Card
        SYS.Send(cmdlen,buf,0)
      endif
      if card==0 || card==2 then
        buf[2]=0x81                    // Card
        SYS.Send(cmdlen,buf,0)
      endif
      start=0
    endif
    // Redraw oscillogrammes.
    if redraw then
      clear hplot
      draw window=hplot
      if procmode!=0 || overscan==0 then
        x0=0
      else
        x0=xoffset
      endif
      backinhist=Min(backinhist,totalhist)
      if backinhist==0 then
        change hhist text="Act"
        change hhist color=BLACK
      else
        change hhist text=format("-%i",backinhist)
        change hhist color=LIGHTRED
      endif
      i=(histindex-backinhist+NHIST)%NHIST
      Memcpy(temp,hist[i],Sizeof(temp))
      change hcmd text=temp.cmd
      add hcmd text="\n"
      add hcmd text=temp.answer
      if temp.cmd[0]=='\0' then
        disable hresend
        disable hclip
      else
        enable hresend
        enable hclip
      endif
      xofs=0
      if trigger==FREESYNC1 || trigger==FREESYNC2 then
        sync=trigger-FREESYNC1
        n=Min(SYNCDX,temp.count)
        ymin=temp.data[sync,0]
        ymax=temp.data[sync,0]
        for j=1,j<n,j++ do
          ymin=Min(ymin,temp.data[sync,j])
          ymax=Max(ymax,temp.data[sync,j])
        enddo
        r=(ymin+ymax)/2.0
        for xofs=1,xofs<n,xofs++ do
          if temp.data[sync,xofs-1]<=r && temp.data[sync,xofs]>=r break
        enddo
        if xofs==n then
          for xofs=1,xofs<n,xofs++ do
            if temp.data[sync,xofs-1]>=r && temp.data[sync,xofs]<=r break
          enddo
        endif
      endif
      if subtract || regress then
        for i=0,i<temp.count,i++ do
          tempdata[0][i]=temp.data[0][i]
          tempdata[1][i]=temp.data[1][i]
        enddo
      endif
      // If requested, subtract best fit of DAC from ADC signal between cursors.
      if subtract then
        sub1=Min(cursor1+xofs,cursor2+xofs,temp.count)
        sub2=Min(Max(cursor1+xofs,cursor2+xofs),temp.count)
        if subshift>sub1 subshift=sub1
        if sub2-subshift>temp.count subshift=sub2-temp.count
        if sub1!=sub2 then
          f=1.0
          ssh=subshift                 // Integer part
          ssd=subshift-ssh             // Remainder
          for i=0,i<sub2-sub1,i++ do
            uint[i]=tempdata[1][sub1-ssh+i]*ssd+                               \
            tempdata[1][sub1-ssh+i+1]*(1.0-ssd)
          enddo
          if SYS.Linfit(sub2-sub1,tempdata[1]+(sub1-ssh),tempdata[0]+sub1,     \
            &f,sub2-sub1,uint,tempfit+sub1)<0                                  \
          then
            sub1=0; sub2=0             // Oops! Fitting is not possible!
          else
            for i=sub1,i<sub2,i++ do
              tempfit[i]=tempdata[0][i]-tempfit[i]
            enddo
          endif
        endif
      else
        sub1=0; sub2=0
      endif
      // If requested, calculate linear regression.
      if regress then
        reg1=Min(cursor1+xofs,cursor2+xofs,temp.count)
        reg2=Min(Max(cursor1+xofs,cursor2+xofs),temp.count)
        if reg2-reg1<5 reg2=reg1       // Too few points for reliable fit
        if reg1!=reg2 then
          sx=0.0; sy=0.0; sxx=0.0; sxy=0.0; syy=0.0
          for j=reg1,j<reg2,j++ do
            sx=sx+j
            sy=sy+tempdata[0][j]
            sxx=sxx+j*j
            sxy=sxy+j*tempdata[0][j]
            syy=syy+tempdata[0][j]*tempdata[0][j]
          enddo
          det=sx*sx-(reg2-reg1)*sxx
          if Abs(det)<1.0e-32 then
            reg1=0; reg2=0             // Oops! Fitting is not possible!
          else
            rega=(sx*sy-(reg2-reg1)*sxy)/det
            regb=(sx*sxy-sxx*sy)/det
            regsigma=Sqrt(Abs(syy-rega*sxy-regb*sy)/(reg2-reg1-2))
          endif
        endif
      else
        reg1=0; reg2=0
      endif
      // Draw grid.
      draw color=LIGHTGRAY
      for j=20,j<OVERSCAN,j=j+20 do
        k=j-x0
        if k<0 continue
        if k>PLOTDX break
        draw at k,0 to k,PLOTDY
      enddo
      for j=-10,j<10,j++ do
        k=PLOTDY/2+j*20
        if k<0 continue
        if k>=PLOTDY break
        draw at 0,k to PLOTDX,k
      enddo
      // Draw card name.
      if datavalid!=0 && nmeascard==2 then
        draw at 5,PLOTDY-5 font=MAINFONT color=BROWN mode=M_LEFT
        if temp.card==0 then
          draw text="Master"
        else
          draw text="Slave"
        endif
      endif
      // Draw background of overview window.
      draw window=hoverview
      if overscan then
        draw bkcolor=WHITEBLUE clear
      else
        draw bkcolor=GRAY clear
      endif
      // Draw main oscilloscope window.
      if procmode==1 then              // Histogram
        // Draw histogram of gathered data.
        if datavalid then
          n=temp.count-xofs            // Total number of displayable points
          for i=0,i<2,i++ do
            yfact=20.0/scalefactor[scale[i]]
            if offset[i]==0 then       // "AC" mode
              yoffs=0.0
              for j=0,j<n,j++ do
                yoffs=yoffs+temp.data[i,j+xofs]
              enddo
              if n>0 yoffs=yoffs/n
            else if offset[i]==1 then  // Offset at cursor 1
              yoffs=temp.data[i,cursor1+xofs]
            else if offset[i]==2 then  // Offset at cursor 2
              yoffs=temp.data[i,cursor2+xofs]
            else
              yoffs=32768              // Manual offset
            endif
            yoffs=yoffs-manual[i]*scalefactor[scale[i]]
            if i==0 then
              Memset(hyst,0,Sizeof(hyst))
              hystmax=0; sy=0.0; syy=0.0
              for j=0,j<n,j++ do
                f=temp.data[i,j+xofs+x0]
                sy=sy+f; syy=syy+f*f
                y=(f-yoffs)*yfact+PLOTDX/2
                if y>=0 && y<PLOTDX then
                  hyst[y]++
                  hystmax=Max(hystmax,hyst[y])
                endif
              enddo
              draw window=hplot
              if catched!=3 then
                draw color=STRANGE at cursorh-x0,0 to cursorh-x0,PLOTDY
              endif
              draw color=WHITE at PLOTDX-221,0 fillrect PLOTDX,40
              if catched==3 then
                draw color=LIGHTRED at cursorh-x0,0 to cursorh-x0,PLOTDY
              endif
              draw color=BLACK font=SMALLFONT
              if n>5 then              // OK to calculate dispersion
                f=(n*syy-sy*sy)/n/(n-1)
                if f<0.0 then
                  f=0.0
                else
                  f=Sqrt(f)
                endif
                draw at PLOTDX-210,15 text=format("Mean = %.6g",sy/n-ZERO)
                draw at PLOTDX-115,15 text=format("sigma = %.4g",f)
              endif
              y=(cursorh-PLOTDX/2)/yfact+yoffs+0.5
              draw at PLOTDX-210,28 text=format("ADC = %i",y-ZERO)
              y=Max(0,Min((y-yoffs)*yfact+PLOTDX/2,PLOTDX-1))
              draw at PLOTDX-135,28 text=format("n = %i",hyst[y])
              draw at PLOTDX-70,28 text=format("%.2f%%",hyst[y]*100.0/n)
              y0=PLOTDY-20
              yfact=(PLOTDY-40.0)/(hystmax+PLOTDY/4)
              draw color=GRAY at 0,y0 to PLOTDX,y0
              draw color=chcolor[i]
              for j=0,j<PLOTDX,j++ do
                draw at j,y0-hyst[j]*yfact to j,y0
              enddo
            endif
            if overscan then
              draw window=hoverview color=chcolor[i]
              yfact=1.0/scalefactor[scale[i]]
              y=Max(0.0,                                                       \
                Min(OVDY-1,OVDY/2-(temp.data[i,xofs]-yoffs)*yfact))
              draw at 0,y
              for j=1,j<OVDX,j++ do
                if j*12+xofs>=temp.count break
                y=Max(0.0,                                                     \
                  Min(OVDY-1,OVDY/2-(temp.data[i,j*12+xofs]-yoffs)*yfact))
                draw to j,y
              enddo
            endif
          enddo
        endif
      else if procmode==2 then         // Fast Fourier transform
        // Draw fast Fourier transform of gathered data.
        if datavalid then
          n=temp.count-xofs            // Total number of displayable points
          nf=512-2*FFTXOFFS            // Number of points in spectrum
          fstep=1000000.0/(fwidth*compression[sweep])
          for i=0,i<2,i++ do
            yfact=20.0/scalefactor[scale[i]]
            sum=0.0
            for j=0,j<fwidth && j+fftshift<n,j++ do
              r=temp.data[i,j+fftshift+xofs]
              sum=sum+r
              rein[j]=r
            enddo
            if j>0 sum=sum/j
            for q=0,q<j,q++ do
              rein[q]=rein[q]-sum
            enddo
            for j=j,j<fwidth,j++ do
              rein[j]=0.0              // Fill rest with zeros, no good solution
            enddo
            imin=0.0
            SYS.Fft(fwidth,rein,&imin,reout,imout)
            f=0.0
            if fwidth==256 then
              for j=0,j<128,j++ do
                r=Sqrt(reout[j]*reout[j]+imout[j]*imout[j])
                fftampl[i,j*4]=r
                fftampl[i,j*4+1]=r
                fftampl[i,j*4+2]=r
                fftampl[i,j*4+3]=r
                fftfreq[j*4]=f
                fftfreq[j*4+1]=f
                fftfreq[j*4+2]=f
                fftfreq[j*4+3]=f
                f=f+fstep
              enddo
            else if fwidth==512 then
              for j=0,j<256,j++ do
                r=Sqrt(reout[j]*reout[j]+imout[j]*imout[j])/2.0
                fftampl[i,j*2]=r
                fftampl[i,j*2+1]=r
                fftfreq[j*2]=f
                fftfreq[j*2+1]=f
                f=f+fstep
              enddo
            else if fwidth==1024 then
              for j=0,j<512,j++ do
                r=Sqrt(reout[j]*reout[j]+imout[j]*imout[j])/4.0
                fftampl[i,j]=r
                fftfreq[j]=f
                f=f+fstep
              enddo
            else if fwidth==2048 then
              for j=0,j<512,j++ do
                r=reout[j*2]*reout[j*2]+imout[j*2]*imout[j*2]
                r=r+reout[j*2+1]*reout[j*2+1]+imout[j*2+1]*imout[j*2+1]
                fftampl[i,j]=Sqrt(r)/8.0
                fftfreq[j]=f
                f=f+fstep*2.0
              enddo
            else
              for j=0,j<512,j++ do
                fftampl[i,j]=0.0
                fftfreq[j]=0.0
              enddo
            endif
          enddo
          draw window=hplot font=SMALLFONT mode=M_CENTERED
          if catched!=3 then
            draw color=STRANGE at cursorf1-x0,12 text="1" to cursorf1-x0,PLOTDY
          endif
          if catched!=4 then
            draw color=STRANGE at cursorf2-x0,12 text="2" to cursorf2-x0,PLOTDY
          endif
          draw color=WHITE at PLOTDX-231,0 fillrect PLOTDX,60
          if catched==3 then
            draw color=PINK bkcolor=PINK at PLOTDX-215,15
            draw fillrect PLOTDX-140,38
            draw color=LIGHTRED bkcolor=WHITE
            draw at cursorf1-x0,12 text="1" to cursorf1-x0,PLOTDY
          else if catched==4 then
            draw color=PINK bkcolor=PINK at PLOTDX-140,15
            draw fillrect PLOTDX-65,38
            draw color=LIGHTRED bkcolor=WHITE
            draw at cursorf2-x0,12 text=" 2" to cursorf2-x0,PLOTDY
          endif
          draw color=DARKGRAY mode=M_LEFT
          draw at PLOTDX-210,15
          if fftfreq[cursorf1-FFTXOFFS]<1000.0 then
            draw text=format("f1 = %.4g Hz",fftfreq[cursorf1-FFTXOFFS])
          else
            draw text=format("f1 = %.4g kHz",fftfreq[cursorf1-FFTXOFFS]/1000.0)
          endif
          draw at PLOTDX-135,15
          if fftfreq[cursorf2-FFTXOFFS]<1000.0 then
            draw text=format("f2 = %.4g Hz",fftfreq[cursorf2-FFTXOFFS])
          else
            draw text=format("f2 = %.4g kHz",fftfreq[cursorf2-FFTXOFFS]/1000.0)
          endif
          for i=0,i<2,i++ do
            draw color=chcolor[i]
            draw at FFTXOFFS,PLOTDY-140-manual[i]*20
            draw to PLOTDX-FFTXOFFS,PLOTDY-140-manual[i]*20
            r=scalefactor[scale[i]]*nf/512.0
            foffs=PLOTDY-140-manual[i]*20
            draw at FFTXOFFS,foffs-fftampl[i,0]/r
            for j=1,j<nf,j++ do
              draw to j+FFTXOFFS,foffs-fftampl[i,j]/r
            enddo
            draw color=chcolor[i] at PLOTDX-210,28+11*i
            Prvalue("1 = ",'A',fftampl[i,cursorf1-FFTXOFFS])
            draw at PLOTDX-135,28+11*i
            Prvalue("2 = ",'A',fftampl[i,cursorf2-FFTXOFFS])
            j=Min(cursorf1,cursorf2)-FFTXOFFS
            k=Max(cursorf1,cursorf2)-FFTXOFFS
            if fwidth==256 then
              j=j & 0xFFFFFFFC
              k=(k & 0xFFFFFFFC)+3
            else if fwidth==512 then
              j=j & 0xFFFFFFFE
              k=(k & 0xFFFFFFFE)+1
            endif
            r=0.0
            for j=j,j<=k,j++ do
              r=r+fftampl[i,j]*fftampl[i,j]
            enddo
            draw at PLOTDX-70,28+11*i
            if fwidth==256 then
              r=r/4.0
            else if fwidth==512 then
              r=r/2.0
            endif
            Prvalue(" = ",'S',Sqrt(r))
          enddo
          draw window=hoverview color=GRAY bkcolor=WHITE
          draw at fftshift/12,-1
          draw fillrect (fftshift+fwidth)/12+1,OVDY+1
          for i=0,i<2,i++ do
            if offset[i]==0 then       // "AC" mode
              yoffs=0.0
              for j=0,j<n,j++ do
                yoffs=yoffs+temp.data[i,j+xofs]
              enddo
              if n>0 yoffs=yoffs/n
            else if offset[i]==1 then  // Offset at cursor 1
              yoffs=temp.data[i,cursor1+xofs]
            else if offset[i]==2 then  // Offset at cursor 2
              yoffs=temp.data[i,cursor2+xofs]
            else
              yoffs=32768              // Manual offset
            endif
            draw color=chcolor[i]
            yfact=1.0/scalefactor[scale[i]]
            y=Max(0.0,                                                         \
              Min(OVDY-1,OVDY/2-(temp.data[i,xofs]-yoffs)*yfact))
            draw at 0,y
            for j=1,j<OVDX,j++ do
              if j*12+xofs>=temp.count break
              y=Max(0.0,                                                       \
                Min(OVDY-1,OVDY/2-(temp.data[i,j*12+xofs]-yoffs)*yfact))
              draw to j,y
            enddo
          enddo
        endif
      else                             // Ordinary X-Y plot
        // Draw normal time sweep.
        draw window=hplot font=SMALLFONT mode=M_CENTERED
        if catched!=1 then
          draw color=STRANGE at cursor1-x0,12 text="1" to cursor1-x0,PLOTDY
        endif
        if catched!=2 then
          draw color=STRANGE at cursor2-x0,12 text=" 2" to cursor2-x0,PLOTDY
        endif
        draw color=WHITE at PLOTDX-221,0 fillrect PLOTDX,(bg.count?63:40)
        if catched==1 then
          draw color=PINK bkcolor=PINK at PLOTDX-215,15
          draw fillrect PLOTDX-140,(bg.count?63:38)
          draw color=LIGHTRED bkcolor=WHITE
          draw at cursor1-x0,12 text="1" to cursor1-x0,PLOTDY
        else if catched==2 then
          draw color=PINK bkcolor=PINK at PLOTDX-140,15
          draw fillrect PLOTDX-65,(bg.count?63:38)
          draw color=LIGHTRED bkcolor=WHITE
          draw at cursor2-x0,12 text=" 2" to cursor2-x0,PLOTDY
        endif
        draw color=DARKGRAY mode=M_LEFT
        if compression[sweep]<50 then
          tfact=compression[sweep]
          draw at PLOTDX-210,15
          draw text=format("t1 = %g us",cursor1*tfact)
          draw at PLOTDX-135,15
          draw text=format("dt = %g us",(cursor2-cursor1)*tfact)
        else
          tfact=compression[sweep]*0.001
          draw at PLOTDX-210,15
          draw text=format("t1 = %g ms",cursor1*tfact)
          draw at PLOTDX-135,15
          draw text=format("dt = %g ms",(cursor2-cursor1)*tfact)
        endif
        if cursor2!=cursor1 then
          f=Abs(1.0e6/(cursor2-cursor1)/compression[sweep])
          draw at PLOTDX-70,15
          if f<9.999999 then
            draw text=format("f = %5.3f Hz",f)
          else if f<99.999999 then
            draw text=format("f = %5.2f Hz",f)
          else if f<999.99999 then
            draw text=format("f = %5.1f Hz",f)
          else if f<9999.9999 then
            draw text=format("f = %5.3f kHz",f/1000.0)
          else if f<99999.999 then
            draw text=format("f = %5.2f kHz",f/1000.0)
          else if f<999999.99 then
            draw text=format("f = %5.1f kHz",f/1000.0)
          else if f<9999999.9 then
            draw text=format("f = %5.3f MHz",f/1000000.0)
          else
            draw text=format("f = %5.2f MHz",f/1000000.0)
          endif
        endif
        y=28
        for i=0,i<2,i++ do
          c=(i==0?'A':'D')
          draw color=chcolor[i]
          if cursor1+xofs<temp.count then
            draw at PLOTDX-210,y
            Prvalue("1 = ",c,temp.data[i,cursor1+xofs]-ZERO)
          endif
          if cursor2+xofs<temp.count then
            draw at PLOTDX-135,y
            Prvalue("2 = ",c,temp.data[i,cursor2+xofs]-ZERO)
          endif
          if cursor1+xofs<temp.count && cursor2+xofs<temp.count then
            draw at PLOTDX-60,y
            Prvalue("d = ",0,temp.data[i,cursor2+xofs]-                        \
            temp.data[i,cursor1+xofs])
          endif
          y=y+11
        enddo
        if bg.count>0 then
          change hcshift text=format("%i",bgshift)
          y=y+2
          for i=0,i<2,i++ do
            c=(i==0?'A':'D')
            draw color=chcolor[i+2]
            if cursor1+xofs-bgshift>=0 && cursor1+xofs-bgshift<bg.count then
              draw at PLOTDX-210,y
              Prvalue("1 = ",c,bg.data[i,cursor1+xofs-bgshift]-ZERO)
            endif
            if cursor2+xofs-bgshift>=0 && cursor2+xofs-bgshift<bg.count then
              draw at PLOTDX-135,y
              Prvalue("2 = ",c,bg.data[i,cursor2+xofs-bgshift]-ZERO)
            endif
            if cursor1+xofs-bgshift>=0 && cursor1+xofs-bgshift<bg.count &&     \
              cursor2+xofs-bgshift>=0 && cursor2+xofs-bgshift<bg.count then
              draw at PLOTDX-60,y
              Prvalue("d = ",0,                                                \
                bg.data[i,cursor2+xofs-bgshift]-bg.data[i,cursor1+xofs-bgshift])
              ;
            endif
            y=y+11
          enddo
        endif
        // Draw background.
        if bg.count>0 then
          n=bg.count-bgxofs
          for i=0,i<2,i++ do
            yfact=20.0/scalefactor[scale[i]]
            if bgoffset[i]==0 then     // "AC" mode
              yoffs=0.0
              for j=0,j<n,j++ do
                yoffs=yoffs+bg.data[i,j+bgxofs]
              enddo
              if n>0 yoffs=yoffs/n
            else if bgoffset[i]==1 then// Offset at cursor 1
              yoffs=bg.data[i,cursor1+bgxofs]
            else if bgoffset[i]==2 then// Offset at cursor 2
              yoffs=bg.data[i,cursor2+bgxofs]
            else
              yoffs=32768              // Manual offset
            endif
            yoffs=yoffs-bgmanual[i]*scalefactor[scale[i]]
            draw window=hplot color=chcolor[i+2]
            k=0
            for j=0,j<bg.count,j++ do
              x=j-bgxofs-x0+bgshift
              if x<0 continue
              if x>=PLOTDX break
              y=PLOTDY/2-(bg.data[i,j]-yoffs)*yfact-yoffset
              if k==0 then
                draw at x,y
                k=1
              else
                draw to x,y
              endif
            enddo
            if k draw to x+1,y
            y=PLOTDY/2-bgmanual[i]*20.0
            draw at 4,y+1 to 1,y+4 to 1,y-4 to 2,y-3 to 2,y+2
            draw to 3,y+1 to 3,y-2 to 4,y-1 to 4,y to 8,y
            draw color=WHITE
            draw at 5,y+1 to 0,y+6 to 0,y-6 to 6,y
          enddo
        endif
        // Draw gathered data.
        if datavalid then
          n=temp.count-xofs            // Total number of displayable points
          for i=0,i<2,i++ do
            yfact=20.0/scalefactor[scale[i]]
            if offset[i]==0 then       // "AC" mode
              yoffs=0.0
              for j=0,j<n,j++ do
                yoffs=yoffs+temp.data[i,j+xofs]
              enddo
              if n>0 yoffs=yoffs/n
            else if offset[i]==1 then  // Offset at cursor 1
              yoffs=temp.data[i,cursor1+xofs]
            else if offset[i]==2 then  // Offset at cursor 2
              yoffs=temp.data[i,cursor2+xofs]
            else
              yoffs=32768              // Manual offset
            endif
            yoffs=yoffs-manual[i]*scalefactor[scale[i]]
            // Draw linear regression.
            if i==0 && regress && reg1<reg2 then
              draw window=hplot color=LIGHTBLUE
              y=PLOTDY/2-(rega*(xoffset+xofs)+regb-yoffs)*yfact-yoffset
              draw at 0,y
              y=PLOTDY/2-(rega*(xoffset+xofs+PLOTDX)+regb-yoffs)*yfact-yoffset
              draw to PLOTDX,y
              r=rega*(reg1+reg2)/2.0+regb
              draw at 10,15 text=format("Mean %.5g bits",r-32768.0)
              draw at 10,28
              r=rega/compression[sweep]
              if (compression[sweep]<10.0) then
                draw text=format("Slope %.5g bits/us",r)
              else
                draw text=format("Slope %.5g bits/ms",r*1000)
              endif
              draw at 10,41 text=format("Sigma %.5g bits",regsigma)
            endif
            // Draw data.
            draw window=hplot color=chcolor[i]
            q=0
            y=PLOTDY/2-(temp.data[i,xofs+x0]-yoffs)*yfact-yoffset
            draw at 0,y
            k=0
            for j=1,j+x0<n && j<PLOTDX,j++ do
              if i==0 && subtract!=0 && sub1<sub2 then
                if j>sub1-xofs-x0 && j<sub2-xofs-x0 && q==0 then
                  draw color=GRAY; q=1
                else if (j<=sub1-xofs-x0 || j>=sub2-xofs-x0) && q!=0 then
                  draw color=chcolor[i]; q=0
                endif
              endif
              k=1
              y=PLOTDY/2-(temp.data[i,j+xofs+x0]-yoffs)*yfact-yoffset
              draw to j,y
            enddo
            if k draw to j+1,y
            y=PLOTDY/2-manual[i]*20.0-yoffset
            draw at 4,y+1 to 1,y+4 to 1,y-4 to 2,y-3 to 2,y+2
            draw to 3,y+1 to 3,y-2 to 4,y-1 to 4,y to 8,y
            draw color=WHITE
            draw at 5,y+1 to 0,y+6 to 0,y-6 to 6,y
            // Draw best fit between cursors.
            if i==0 && subtract && sub1<sub2 then
              draw window=hplot color=GREEN
              if Abs(subshift)>0.01 then
                draw at 10,15
                draw text=format("DAC shift %.2f points",subshift)
                r=compression[sweep]*subshift
                if Abs(r)<1000.0 then
                  draw text=format(" (%g us)",r)
                else
                  draw text=format(" (%g ms)",r/1000.0)
                endif
              endif
              f=-manual[i]*scalefactor[scale[i]]
              sub1=Max(sub1,xofs+x0)
              y=PLOTDY/2-(tempfit[sub1]-f)*yfact-yoffset
              draw at sub1-xofs-x0,y
              k=0
              for j=sub1-xofs-x0,j<sub2-xofs-x0 && j<PLOTDX,j++ do
                k=1
                y=PLOTDY/2-(tempfit[j+xofs+x0]-f)*yfact-yoffset
                draw to j,y
              enddo
              if k draw to j+1,y
            endif
            // Draw overview.
            if overscan then
              draw window=hoverview
              if i==0 then
                draw color=GRAY bkcolor=WHITE
                draw at x0/12,OVDY/2-11+yoffset/20
                draw fillrect (x0+PLOTDX)/12+1,OVDY/2+11+yoffset/20
              endif
              draw color=STRANGE at cursor1/12,0 to cursor1/12,OVDY
              draw color=STRANGE at cursor2/12,0 to cursor2/12,OVDY
              draw color=chcolor[i]
              yfact=1.0/scalefactor[scale[i]]
              y=Max(0.0,                                                       \
                Min(OVDY-1,OVDY/2-(temp.data[i,xofs]-yoffs)*yfact))
              draw at 0,y
              for j=1,j<OVDX,j++ do
                if j*12+xofs>=temp.count break
                y=Max(0.0,                                                     \
                  Min(OVDY-1,OVDY/2-(temp.data[i,j*12+xofs]-yoffs)*yfact))
                draw to j,y
              enddo
            endif
          enddo
        endif
      endif
      draw window=hplot show
      draw window=hoverview show
      redraw=0
    endif
    wait
  enddo
  // Save settings to .ini file and close oscilloscope on controller.
  trigger=Status(htrig); if trigger>3 trigger=trigger+2
  sweep=Status(hsweep)
  setini("Measscope","Settings","%i,%i,%i,%i,%i,%i,%i,%f,%f",                  \
    card,trigger,sweep,overscan,procmode,subtract,regress,vmin,vmax)
  setini("Measscope","Savefile",savefile)
  Closecard(0)
  if nmeascard==2 Closecard(1)
  for i=0,i<2,i++ do
    sprintf(s,"Channel[%i]",i)
    setini("Measscope",s,"%i,%i,%i",scale[i],offset[i],manual[i])
  enddo
end

