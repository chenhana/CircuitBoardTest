#include "ls.icl"
#include "or.icl"
#include "pa.icl"                  // Rich Text Format extentions

#cmdbuff 34                            // 32+2 answer buffers
#zeroid                                // Process answers with zero command ID

#define VERSION        "1.18"
#define DESCRIPTION    "Accuracy with special board"

// 1.00: First release.
// 1.01: Option to select widthes for test.
// 1.02: Protocolling to RTF file.
// 1.03: Support for single-sided S1.
// 1.04: Support for A5a/A7a.
// 1.05: Determination of best accuracy.
// 1.06: Home move at the end of the test.
// 1.07: Support for M_RLIM to avoid board damage.
// 1.08: Support for additional layout extentions.
// 1.09: Uses external USB temperature sensor if internal is absent.
// 1.10: Support for S3.
// 1.11: Support for EL100-2.
// 1.12: Automatic adjustment of opposite illumination.
// 1.13: Histogram test.
// 1.14: Support for double-sided S3.
// 1.15: Capacitive measurements on double-sided testers.
// 1.16: Support for split shuttle.
// 1.17: Support for S3 with split shuttle.
// 1.18: Support for external antenna on single-sided testers.

#bitmap "logo"<"guoke.bmp"               // All bitmaps are compressed
#bitmap "bkground"<"aluminum.bmp"      // Alternative: "pcb1.bmp"
#bitmap "unknown"<"unknown.bmp"

// Dimensions of main window.
#define MAINX          600
#define MAINY          400
#define SPLIT          330
#define SERVY          25
#define LEFTX          320             // (SPLIT-10)
#define LEFTY          365             // (MAINY-SERVY-10)
#define RIGHTX         265             // (MAINX-SPLIT-5)
#define RIGHTY         335             // (MAINY-SERVY-SERVY-15)
#define USERY          280

// Constants determining tester type.
#define TT_WRONG       (-1)
#define TT_UNDEF       0
#define TT_A1          1
#define TT_A2          2
#define TT_A2L         3
#define TT_A2H         4
#define TT_A3          5
#define TT_A3L         6
#define TT_A4          7
#define TT_A5          8
#define TT_A5L         9
#define TT_A6          10
#define TT_S1          11
#define TT_S2          12
#define TT_A7          13
#define TT_A8          14
#define TT_S3          15
#define TT_M2          16

// Selectable actions in main menu.
#define ACT_QUIT       (-1)            // Quit test
#define ACT_CANCEL     0               // Finish test
#define ACT_ACC        1               // Accuracy test
#define ACT_HIST       2               // Histogram
#define ACT_REPLACE    3               // Change placement
#define ACT_OPENLOG    4               // Open protocol file
#define ACT_CLOSELOG   5               // Close protocol file

// Layout configuration bits in $LAY.config.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae
// Alternative (old) interpretation of LC_OHTYPE bits.
#define LC_PHASEADJ    0x00000800      // On-heads with adjustable field phase
#define LC_ACTIVEONHD  0x00000400      // Active on-heads (with Dallas/R1-R4)
// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMSPLIT     0x20000000      // L&M auto split shuttle
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_SPLITAUTO   (LC_LMSPLIT|LC_A2LOADER)
#define LC_LMAUTO      (LC_LM|LC_A2LOADER)
#define LC_LMS2AUTO    (LC_LMS2|LC_A2LOADER)
#define LC_EPCOSAUTO   (LC_EPCOS|LC_A2LOADER)

// Features supported by measurement card.
#define MF_CONTAIR     0x00000001      // Contact check corrections supported
#define MF_CRT         0x00000002      // CRT measurements supported
#define MF_KELVSCAN    0x00000004      // Kelvin scan supported
#define MF_FIXCDC      0x00000008      // Forcing charge-discharge in FastC
#define MF_CCORR       0x00000010      // Calibration of capacitive phase
#define MF_SLAVE       0x00000020      // Supports second measurement card
#define MF_CPHASE      0x00000040      // C phase corrections from layout
#define MF_MULTIC      0x00000080      // Multiple C supported
#define MF_DSCAN       0x00000100      // Charge-discharge scan supported
#define MF_CRTCONCE    0x00000200      // Permanent CRT calibration in air
#define MF_UNIC        0x00000400      // Universal C supported
#define MF_CONCE       0x00000800      // Permanent C calibration in air
#define MF_HVINITEX    0x00001000      // Extended HV initialization (meas card)
#define MF_POSTAIR     0x00002000      // C in air after M_FASTC (meas card)
#define MF_EXTMEAS     0x00004000      // External measurement device
#define MF_DMEM        0x00008000      // Read/write from Dallas memory (meas)
#define MF_RLIM        0x00010000      // Ordinary R with limits (meas)

// Measurement features supported by crate.
#define MF_RLIMCRATE   0x00800000      // Ordinary R with limits (crate)
#define MF_EXTLAINIT   0x01000000      // Extended S_LAINIT supported
#define MF_RETEST      0x02000000      // Instant retest (M_LIMITHI, M_LIMITLO)
#define MF_HVCRATEEX   0x04000000      // Extended HV initialization (crate)
#define MF_POSTCRATE   0x08000000      // C in air after M_FASTC (crate)
#define MF_RLINIT      0x10000000      // S_RLINIT supported (crate)
#define MF_DMEMCRATE   0x20000000      // Read/write from Dallas memory (crate)
#define MF_MULTICAL    0x40000000      // M_CALIBRATE supports multiple refs

// Options of measurement card.
#define HCM_HV1MA      0x00000001      // Force 1 mA during HV measurements
#define HCM_STRICT     0x00000002      // 20% stricter self-test
#define HCM_NOCTCHK    0x00000004      // Don't check contacts (except ExactR)
#define HCM_PARCONT    0x00000008      // Check influence of parallel contacting
#define HCM_NOACCEL    0x00000010      // Do not accelerate reed relays
#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements
#define HCM_CTOEXT     0x00000040      // Calibrate capacity to shuttle (extant)
#define HCM_ISOEANT    0x00000080      // External antennas isolated
#define HCM_FILTMASK   0x00000F00      // Mask to extract signal filtering
#define   HCM_FNONE    0x00000000      // No signal filtering
#define   HCM_F500K    0x00000100      // 500 kHz filter
#define   HCM_F100K    0x00000200      // 100 kHz filter
#define   HCM_F20K     0x00000300      // 20/50 kHz filter
#define HCM_FILTERC    0x00001000      // Filter C measurements over 300 pF
#define HCM_EXRLONG    0x00002000      // Long EXACTR with 300 mA source
#define HCM_AUTOEANT   0x00004000      // Automatic antenna 1 for all C
#define HCM_HVTYPE     0x000F0000      // Mask to extract type of HV elecronics
#define   HCM_HV500    0x00000000      // Card is capable of 500 V HV
#define   HCM_HV1000   0x00010000      // Card is capable of 1000 V HV
#define   HCM_HVAUTO   0x00070000      // Autodetect HV capabilities
#define HCM_DISCONN    0x00100000      // Disconnect from bus after measurement
#define HCM_EXRNOISY   0x00200000      // Accept noisy EXACTR measurements

#define PI             3.14159265359

#define VSTEP          0.2             // Camera moves in 0.2 mm steps

#define NWIRE          41              // No. of different wires
#define NINDEX         11              // No. of different widths (0: solid)
#define NHIST          29              // No. of histogram contacts per side

typedef struct t_htest                 // Single histogram measurement
  float          x[2],y[2]             // Contact (tester coord, top/bottom)
  int            hand                  // Hand (left/top or right/bottom)
  int            index                 // Distance index
ends

float  width[2][NINDEX] = {          \ // Widths for EL100/EL100-2, 999: solid
  { 999.0, 100.0, 75.0, 50.0, 35.0, 30.0, 25.0, 20.0, 15.0, 10.0, 5.0 },       \
  { 999.0, 75.0, 50.0, 35.0, 30.0, 25.0, 20.0, 15.0, 10.0, 5.0, 2.0 } }
char   wtext[2][NINDEX][8] = {       \ // Width name from index
  { "S", "100", "75", "50", "35", "30", "25", "20", "15", "10", "5" },         \
  { "S", "75", "50", "35", "30", "25", "20", "15", "10", "5", "2" } }

handle hmain                           // Main window
handle hexit                           // Button "Close"
handle hserv,hleft,hright              // Left and right subwindows
handle hinfo                           // Current status
handle hgraph                          // Graphical window
handle htemp                           // Graphical window to draw to RTF
handle htop,hbottom,htopbot            // Side selection in graphical window
handle hlside,hrside,hlrside           // Half selection in graphical window
handle hhead[4]                        // Head selection in graphical window
int    rtfok                           // Non-zero if .RTF log file open

char   crateversion[128]               // Version of loaded crate software
char   layoutversion[128]              // Version of loaded layout
char   headversion[128]                // Version of loaded head software
int    layoutchanged                   // Layout is changed
int    loadchanged                     // Loader is closed
int    oversurface[32]                 // Number of contacts over surface
int    firstscan                       // 1 if scanned for the first time
int    isglassboard                    // IsGlassBoard was set
char   lmteachin[5][256]               // Learned shuttle settings
int    nlmteachin                      // Number of valid lmteachin
int    shuttle                         // Shuttle (0 or 1) or -1 if default
int    pulledshuttle                   // Shuttle for A8eaPreparePullCalib or -1
char   scmd[8]                         // Shuttle selection subcommand

int    testertype                      // Type of tester (TT_xxx)
int    features                        // Features of measurement card, MF_xxx
int    testersides                     // Bit 0x1: top, 0x2: bottom rails
int    illumination                    // 0: direct, 1: shinethru
float  headcamradius                   // Radius of head cameras, millimeters
float  leftlimit,rightlimit            // Limits for the camera
float  oppdx                           // Specified X offset of opposite camera
float  oppdy                           // Y offset for head cameras
float  headcamscale[32]                // Camera millimeters per pixel X & Y
float  headthrudx[32][2]               // Throughshine dX, mm (bot/top)
float  headthrudy[32][2]               // Throughshine dY, mm (bot/top)

int    strokev=10                      // Stroke, mm/s
int    strokep=10                      // Pressure, internal units
float  strokez=5.0                     // Height, millimeters

float  xmin,xmax                       // X extent of working area, mm
float  ymin,ymax                       // Y extent of working area, mm
float  pos1x,pos1y                     // First ref fiducial (tester coords)
float  pos2x,pos2y                     // Second ref fiducial (tester coords)

float  xfid[2][4],yfid[2][4]           // Scanned fiducial coordinates
int    mayreach[32]                    // Head may be used in test
int    safex[32],safey[32]             // Safe head coordinates (if mayreach)
int    showside                        // Show side (0x1:top,0x2:bot,0x3:both)
int    showhalf                        // Show half (0x1:left,0x2:rght,0x3:both)
int    cursor                          // Selection cursor (0..NINDEX-1 or -1)

int    boardtype                       // -1: unknown, 0: EL100, 1: EL100-2
int    use                             // List of widthes to contact
int    fasttest                        // Make fast verification
int    usec;                           // Use capacity measurements  
int    nloop                           // Number of loops to run
int    nastat                          // Expected statistics per side & half
int    astat[2][2][2][NINDEX]          // Accuracy stat [dir][side][half][index]
int    nhstat                          // Max number of contacts per hstat elem.
int    hstat[2][4][2][NHIST]           // Histogram [dir][sidehead][hand][indx]
int    natest                          // Number of accuracy tests so far
int    nhtest                          // Number of histogram tests so far
char   comment[1024]                   // Comment to be added to RTF

float  histstep                        // Last selected histogram step
int    accuracy                        // Requested contacting accuracy
int    histmode                        // 0: linear, 1: random, 2: long moves
int    smallarea                       // 0: large, 1: small
int    moveother                       // 1: move other heads
int    railtop,railbot                 // Rails used in histogram test
struct t_htest ht[5000]                // A batch of tests

// Individual per-camera brightness and contrast.
int    individualbc                    // Whether individual brightness/contrast
handle hbrititle                       // Brightness title
handle hbrightness                     // Brightness control
handle hctrtitle                       // Contrast title
handle hcontrast                       // Contrast control
handle hilltitle                       // Illumination title
handle hilltop                         // Top illumination control
handle hillskew                        // Skew illumination control
handle hilllong                        // Long exposition control
handle hfoctitle                       // Focus title
handle hfocusup                        // Focus up
handle hfocus                          // Z camera position
handle hfocusdn                        // Focus down
int    illtype                         // Illumination (0x3:on,0x4:top,0x8:skew)
int    longexp                         // Long exposition
int    brightness[32]                  // Individual brightness settings
int    contrast[32]                    // Individual contrast settings
int    bchead                          // Head selected for individual bri/ctr
int    focus[2]                        // Focus position of dedicated camera
int    updatefocus[2]                  // Set focus of dedicated camera
int    autoadjust                      // Automatically adjust opposite light

external int SERV.Decodeanswer(char *answer,char *text,char *extra,int mask);
external int SERV.Convertfastc(char *answer,float *zc,float *zr);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// INTERRUPT HANDLER ///////////////////////////////

// Interrupt handler, receives and processes asynchronous messages and errors.
function int Answerproc(char *answer,int info)
  int i
  char s[512],extra[2048]
  if answer[4]==0xF0 then
    // Internal OLLYTEST message.
    if Stricmp(answer+5,"CHG LAY")==0 layoutchanged=1
    if Stricmp(answer+5,"CHG LOAD")==0 loadchanged=1
    return
  else if answer[4]==S_ERROR then
    // Error messages, also with zero ID.
    if answer[5]==E_ZMOVEMENT && answer[9]==2 && answer[7]!=0xFF then
      i=answer[7]*2+((answer[8] & 0x4C)==0?0:1)
      oversurface[i]++                 // Count number of contacts over PCB
    endif
  endif
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////// SERVICE FUNCTIONS: MESSAGES //////////////////////////

// Display modal "dialog box" with error message.
function int Error(char *s1,char *s2)
  handle herr,hdummy,hok
  herr=control WINDOW
    window=hmain
    position=0,0,250,135
    name="错误"
    mode=M_MODAL
    bkcolor=YELLOW
  endc
  hok=control BUTTON
    window=herr
    position=85,100,80,24
    name="确定"
    help="按下可以确认错误消息"
  endc
  hdummy=control ICON
    window=herr
    position=5,30,36,36
    name="EXCLAM"
    bkcolor=YELLOW
  endc
  hdummy=control TEXT
    window=herr
    position=41,20,200,24
    name=s1
    bkcolor=YELLOW
    mode=M_CENTERED
  endc
  hdummy=control TEXT
    window=herr
    position=41,45,200,54
    name=s2
    bkcolor=YELLOW
    mode=M_CENTERED
  endc
  while Pressed(hok)==0 do; enddo
  destroy herr
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// PROTOCOLLING /////////////////////////////////

// Splits long text in two.
function int Splittext(char *s,int limit,char *s1,char *s2)
  int i
  i=Strlen(s)
  if i<=limit then
    Strcpy(s1,s)
    s2[0]='\0'
  else
    for i=limit,i>1,i-- do
      if s[i]==' ' break
    enddo
    Memcpy(s1,s,i); s1[i]='\0'
    Strcpy(s2,s+i+1)
  endif
end

// Reads current tester temperature (in 1/10-th of degree). If necessary, uses
// USB sensor. If operator interrupted C adjust, returns -1. if there was a
// command sending or receiving error, returns 1. Otherwise, returns
// temperature in the range 10..999, which corresponds to 1..99.9 degrees. It
// is the responsibility of caller to display and process errors.
function int Readtemperature()
  int ident,t,temp
  char s[128]
  float etemp
  if ($EXTLAY.measopt & HCM_TMEASOFF) then
    temp=220                           // Default temperature
  else
    sprintf(s,"INPORT %i",0x2011)      // Read effective (smoothed) temperature
    ident=SERV.Cmdimm(32,s)
    if ident<=0 return 1               // Unable to send command
    t=Time()                           // Timeout 5 seconds
    while $A[32].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Time()-t>5000 return 1        // Timeout exhausted
      wait
    enddo
    if $A[32].length!=7 return 1       // Bad length of answer
    if $A[32].answer!=S_INPORT return 1// Bad answer
    temp=$uint2($A[32]+5)
  endif
//  if temp==220 then                    // Default temperature, try USB sensor
//    if SYS.Exttemperature(&etemp)==0 then
//      temp=Floor(etemp*10.0+0.5)
//    endif
//  endif
  return Min(999,Max(10,temp))
end

// Opens protocol file in Rich Text Format. Returns -1 if operator interrupted
// the test, 1 on error and 0 on success.
function int Openprotocol()
  int i,j,t
  char s[256],s1[256],s2[256],type[64],path[260]
  if rtfok!=0 return 0                 // Already open
  getini("Accuracy test","Protocol","%s",path)
  if path[0]=='\0' Strcpy(path,"accuracy.rtf")
  SERV.Addextention(path,".rtf")
  i=SYS.Browse(hmain,path,"Select name of RTF protocol file",0)
  if i==0 return 1                     // User cancelled action
  i=ROpen(path)
  if i!=0 then
    Error("Unable to create protocol file",path)
    return 1
  endif
  setini("Accuracy test","Protocol","%s",path)
  rtfok=1
  Strtime(s,"%a %d-%b-%Y %H:%M",0,0)
  RParagraph(RTF_CENTERED|RTF_HEADER|RTF_FIRST)
  RFmt(RTF_TIMES,RTF_ITALIC,12)
  RAddtext(" ")
  RParagraph(RTF_CENTERED|RTF_HEADER|RTF_THINBRD)
  RFmt(RTF_TIMES,RTF_ITALIC,9)
  RAddfmt("atg Flying prober accuracy test %s - page ",s)
  RAddpagenumber()
  RParagraph(RTF_CENTERED|RTF_SPACE)
  RFmt(RTF_ARIAL,RTF_BOLD|RTF_UL,18)
  RAddtext("Accuracy test")
  RFmt(RTF_ARIAL,RTF_BOLD,14)
  RAddfmt("\n\nVersion %s",VERSION)
  RParagraph(RTF_LEFT)
  RFmt(RTF_TIMES,RTF_NORMAL,12)
  if testertype==TT_A2 then
    j=sprintf(type,"A2/%i",$LAY.nfing*2)
  else if testertype==TT_A2L then
    j=sprintf(type,"A2/%iL",$LAY.nfing*2)
  else if testertype==TT_A2H then
    j=sprintf(type,"A2/%iM",$LAY.nfing*2)
  else if testertype==TT_A3 || testertype==TT_A3L then
    j=sprintf(type,"A3/%i",$LAY.nfing*2)
  else if testertype==TT_A4 then
    j=sprintf(type,"A4/%i",$LAY.nfing*2)
  else if testertype==TT_A5 then
    j=sprintf(type,"A5/%i",$LAY.nfing*2)
  else if testertype==TT_A5L then
    j=sprintf(type,"A5/%iL",$LAY.nfing*2)
  else if testertype==TT_A6 then
    j=sprintf(type,"A6/%i",$LAY.nfing*2)
  else if testertype==TT_S1 then
    j=sprintf(type,"S1/%i",$LAY.nfing*2)
  else if testertype==TT_S2 then
    j=sprintf(type,"S2/%i",$LAY.nfing*2)
  else if testertype==TT_S3 then
    j=sprintf(type,"S3/%i",$LAY.nfing*2)
  else if testertype==TT_A7 then
    j=sprintf(type,"A7/%i",$LAY.nfing*2)
  else if testertype==TT_A8 then
    j=sprintf(type,"A8/%i",$LAY.nfing*2)
  else
    j=sprintf(type,"Unknown")
  endif
  if $LAY.cameras==1 || $LAY.cameras==2 then
    j=j+sprintf(type+j," with 1 dedicated camera")
  else if $LAY.cameras==3 then
    j=j+sprintf(type+j," with 2 dedicated cameras")
  endif
  RAddfmt("\n\tTester type:\t\t%s\n",type)
  Splittext(crateversion,50,s1,s2)
  RAddfmt("\tCrate controller:\t%s\n",s1)
  if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
  Splittext(layoutversion,50,s1,s2)
  RAddfmt("\tLayout:\t\t%s\n",s1)
  if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
  Splittext(headversion,50,s1,s2)
  RAddfmt("\tHead controller:\t%s\n",s1)
  if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
  RAddtext("\tTest tool:\t\tEL100\n")
  RAddfmt("\tStart on:\t\t%s\n",s)
  t=Readtemperature()
  if t<0 return -1
  if t!=220 then                       // Usually (not always) means no sensor
    RAddtext("\tTester temperature:\t")
    if t>=10 && t<990 then
      RAddfmt("%.1f C\n",t/10.0)
    else
      RAddtext("Unable to measure\n")
    endif
  endif
  return 0
end

// Closes protocol file.
function int Closeprotocol()
  char s[128]
  if rtfok==0 return
  Strtime(s,"%a %d-%b-%Y %H:%M\n",0,0)
  RParagraph(RTF_LEFT)
  RFmt(RTF_TIMES,RTF_NORMAL,12)
  RAddfmt("\n\tFinished on:\t\t%s\n",s)      
  RClose()
  rtfok=0
end

// Draws schematic position of the test board on the tester and adds this
// picture to the protocol.
function int Showboardplacement()
  int i,d,border,x0,y0,x1,y1
  float xc,yc,dx,dy,scale
  if rtfok==0 return                   // No protocolling
  border=15
  // Scale is in pixels per millimeter.
  scale=(LEFTX-2*border)/Max(xmax-xmin,ymax-ymin)
  dx=border-xmin*scale
  dy=border+ymax*scale
  // Draw working area.
  draw window=htemp bkcolor=WHITE clear
  draw color=BLACK bkcolor=LIGHTGRAY
  x0=dx+$LAY.leftlimit/1000.0*scale
  x1=dx+$LAY.rightlimit/1000.0*scale
  for i=0,i<$LAY.nfing,i++ do
    y0=dy-$LAY.bottom[i]/1000.0*scale
    y1=dy-$LAY.top[i]/1000.0*scale
    draw at x0,y1 fillrect x1+1,y0+1
  enddo
  // Draw board.
  xc=(pos1x+pos2x)/2.0
  yc=(pos1y+pos2y)/2.0
  x0=dx+(xc-50.0)*scale
  x1=dx+(xc+50.0)*scale
  if ((x1-x0) & 1)==0 x1++
  y0=dy-(yc+50.0)*scale
  y1=dy-(yc-50.0)*scale
  if ((y1-y0) & 1)==0 y0--
  draw color=BLACK bkcolor=WHITECYAN
  draw at x0,y0 fillrect x1,y1
  draw at x0+1,y0+1 fillrect x1-1,y1-1
  for i=-1,i<=1,i++ do
    draw at x0+4,(y0+y1)/2+i to x1-4,(y0+y1)/2+i
    draw at (x0+x1)/2+i,y0+4 to (x0+x1)/2+i,y1-4
  enddo
  // Add picture.
  x1=dx+xmax*scale+border
  y1=dy-ymin*scale+border
  RAddpiczoom(htemp,0,0,x1,y1,0,0.50)
end


////////////////////////////////////////////////////////////////////////////////
/////////////////////// SERVICE FUNCTIONS: VIDEO SUPPORT ///////////////////////

// Reads shinethrough corrections from initialization file.
function int Loadshinethrucorr()
  int head
  char s[256]
  Memset(headthrudx,0,Sizeof(headthrudx))
  Memset(headthrudy,0,Sizeof(headthrudy))
  for head=0,head<32,head++ do
    if $LAY.cameras!=0 then
      // Dedicated camera.
      if head-$LAY.nfing*2<0 continue
      if ($LAY.cameras & (1<<(head-$LAY.nfing*2)))==0 continue
    else
      // Head camera.
      if ($LAY.headcameras & (1<<head))==0 continue
    endif
    sprintf(s,"Shinethru corr[%i]",head)
    getini("Accuracy test",s,"%f,%f,%f,%f",                                    \
    headthrudx[head]+0,headthrudy[head]+0,                                     \
    headthrudx[head]+1,headthrudy[head]+1)
  enddo
end

// Saves shinethrough corrections to initialization file.
function int Saveshinethrucorr()
  int head
  char s[256]
  for head=0,head<32,head++ do
    if $LAY.cameras!=0 then
      // Dedicated camera.
      if head-$LAY.nfing*2<0 continue
      if ($LAY.cameras & (1<<(head-$LAY.nfing*2)))==0 continue
    else
      // Head camera.
      if ($LAY.headcameras & (1<<head))==0 continue
    endif
    sprintf(s,"Shinethru corr[%i]",head)
    setini("Accuracy test",s,"%f,%f,%f,%f",                                    \
    headthrudx[head][0],headthrudy[head][0],                                   \
    headthrudx[head][1],headthrudy[head][1])
  enddo
end

// Given video channel, returns head that carries corresponding video camera,
// or -1 if channel is invalid or not assigned.
function int Headfromchannel(int channel)
  int head,n
  if $LAY.cameras!=0 then
    if channel==0 then
      return ($LAY.cameras & 0x1?$LAY.nfing*2:$LAY.nfing*2+1)
    else if channel==1 && $LAY.cameras==0x3 then
      return $LAY.nfing*2+1
    endif
  else
    n=0
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      if channel==n return head
      n++
    enddo
  endif
  return -1
end

// Given side and Y coordinate, returns left head that can reach this
// coordinate, or -1 if coordinate is not reachable.
function int Headfromy(int side,float y)
  int rail
  for rail=0,rail<$LAY.nfing,rail++ do
    if $LAY.side[rail]!=side continue
    if y>=$LAY.bottom[rail]/1000.0 && y<$LAY.top[rail]/1000.0 break
  enddo
  if rail>=$LAY.nfing return -1
  return rail*2
end

// Reciprocal to Headfromchannel(). Given head, returns associated video
// channel, or -1 if head is invalid or carries no camera.
function int Channelfromhead(int head)
  int i,channel
  if $LAY.cameras!=0 then
    if head==$LAY.nfing*2 && ($LAY.cameras & 0x1)!=0 then
      return 0
    else if head==$LAY.nfing*2+1 && ($LAY.cameras & 0x2)!=0 then
      return (($LAY.cameras & 0x1)==0?0:1)
    endif
  else if ($LAY.headcameras & (1<<head))!=0 then
    channel=0
    for i=0,i<head,i++ do
      if ($LAY.headcameras & (1<<i))!=0 channel++
    enddo
    return channel
  endif
  return -1
end

// Given Y coordinate in millimeters and side, selects camera controller and
// corresponding video channel. If side is set to -1, it will be corrected to
// the first available side. Points on the border can be scanned by both rails.
// Returns head on success, and -1 on any error.
function int Camerafromy(float y,int *channel,int *side,float *angle)
  int head
  float h
  if $LAY.cameras!=0 then
    if side[0]==0 && ($LAY.cameras & 0x1)!=0 then
      channel[0]=0
    else if side[0]==1 && ($LAY.cameras & 0x2)!=0 then
      channel[0]=(($LAY.cameras & 0x1)==0?0:1)
    else
      channel[0]=0
      side[0]=($LAY.cameras & 1)==0?1:0
    endif
    angle[0]=0.0
    return $LAY.nfing*2+side[0]
  else if $LAY.headcameras!=0 then
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      if ($LAY.excludedrails & (1<<(head/2)))!=0 continue
      if side[0]>=0 && $LAY.side[head/2]!=side[0] continue
      if $LAY.top[head/2]/1000.0<=y continue
      if $LAY.bottom[head/2]/1000.0<y break
    enddo
    if head>=$LAY.nfing*2 return -1
    channel[0]=Channelfromhead(head)
    side[0]=$LAY.side[head/2]
    h=y-$LAY.yoffset[head/2]/1000.0
    angle[0]=(Abs(h)>0.9*headcamradius?0.0:Asin(h/headcamradius))
    if side[0]!=0 angle[0]=-angle[0]
    if (head & 1)!=0 angle[0]=-angle[0]
    return head
  else
    return -1                          // No cameras
  endif
end

// Given head and Y coordinate in millimeters, calculates video angle. On
// success, sets angle and returns 0. On error, returns -1.
function int Anglefromy(int head,float y,float *angle)
  float h
  if head>=$LAY.nfing*2 then
    angle[0]=0.0                       // Dedicated camera, if any
    return 0
  else if head>=0 then
    h=y-$LAY.yoffset[head/2]/1000.0
    if Abs(h)>0.9*headcamradius return -1
    angle[0]=Asin(h/headcamradius)
    if $LAY.side[head/2]!=0 angle[0]=-angle[0]
    if (head & 1)!=0 angle[0]=-angle[0]
    return 0
  endif
  return -1
end

// Given camera, returns camera on the opposite side.
function int Oppositecam(int head)
  int nfing,opprail
  nfing=$LAY.nfing
  // S3 allows no opposite camera.
  if testertype==TT_S3 then
    return -1
  endif
  // Check if dedicated camera.
  if head==nfing*2 && ($LAY.cameras & 0x2)!=0 then
    return head+1
  else if head==nfing*2+1 && ($LAY.cameras & 0x1)!=0 then
    return head-1
  else if head>=nfing*2 then
    return -1
  endif
  // Now check for head cameras. If there are several cameras on the rail, I
  // try to select opposite camera on the same left or right side first.
  opprail=((head+nfing)/2)%nfing
  if $LAY.side[opprail]==$LAY.side[head/2] then
    return -1
  else if (head & 1)==0 && ($LAY.headcameras & (1<<(opprail*2)))!=0 then
    return opprail*2
  else if (head & 1)==0 && ($LAY.headcameras & (1<<(opprail*2+1)))!=0 then
    return opprail*2+1
  else if (head & 1)!=0 && ($LAY.headcameras & (1<<(opprail*2+1)))!=0 then
    return opprail*2+1
  else if (head & 1)!=0 && ($LAY.headcameras & (1<<(opprail*2)))!=0 then
    return opprail*2
  else
    return -1
  endif
end

// Calculates flash shinethrough illumination bits for the specified head
// camera.
function int Getoppflash(int head)
  int opp
  if testertype==TT_S3                                                         \
    return 0
  if $LAY.cameras!=0 || $LAY.headcameras==0 || illumination==0 || head<0       \
    return 0
  opp=Oppositecam(head)
  if opp<0 return 0
  return (opp<<16)|0x00800000
end

// Given X-Y coordinates, calculates camera coordinates of the opposite camera
// to illuminate point (x,y). Parameter pos is the position of the fiducial (0:
// bottom row, 1: top row).
function int Oppositexycam(int pos,float x,float y,int opp,                    \
  float *oppx,float *oppy)
  float yoffset,fi
  if opp>=$LAY.nfing*2 then
    // Dedicated camera.
    if x+oppdx>rightlimit then
      oppx[0]=x-oppdx                  // Emergency solution
    else
      oppx[0]=x+oppdx+headthrudx[opp][0]
    endif
    oppy[0]=y+oppdy+headthrudx[opp][0]
    // Limit to working area.
    oppx[0]=Max(leftlimit,Min(oppx[0],rightlimit))
    oppy[0]=Max($LAY.bottom[$LAY.nfing]/1000.0,                                \
      Min(oppy[0],$LAY.top[$LAY.nfing]/1000.0))
    ;
  else
    // Head camera.
    if pos!=0 pos=1
    yoffset=$LAY.yoffset[opp/2]/1000.0
    fi=Abs(Asin((y-yoffset)/headcamradius))
    if (opp & 1)==0 then
      oppx[0]=x+oppdx*Cos(fi)+oppdy*Sin(fi)+headthrudx[opp][pos]
    else
      oppx[0]=x-oppdx*Cos(fi)-oppdy*Sin(fi)+headthrudx[opp][pos]
    endif
    if y<yoffset then
      oppy[0]=y-oppdx*Sin(fi)+oppdy*Cos(fi)+headthrudy[opp][pos]
    else
      oppy[0]=y+oppdx*Sin(fi)-oppdy*Cos(fi)+headthrudy[opp][pos]
    endif
    // Limit to working area.
    oppx[0]=Max(xmin,Min(oppx[0],xmax))
    oppy[0]=Max(ymin,Min(oppy[0],ymax))
  endif
end

// Sets default or gets last known magnifications of cameras.
function int Getcamerascales()
  int i,head,channel,videosizex,videosizey
  float scale,scalex,scaley,headx,heady
  char s[256]
  // Head cameras.
  for head=0,head<$LAY.nfing*2,head++ do
    if ($LAY.headcameras & (1<<head))==0 continue
    // Head camera scales in .ini file are in micrometers per pixel.
    headx=0.0; heady=0.0
    sprintf(s,"Headcam scale[%i]",head)
    getini("System",s,"%f,%f",&headx,&heady)
    if headx>3.0 && headx<20.0 && heady>3.0 && heady<20.0 then
      headcamscale[head]=(headx+heady)/2000.0
      continue
    endif
    // Old-style camera scales are in millimeters per 512 pixels.
    scalex=0.0; scaley=0.0
    sprintf(s,"Video scale[%i]",$LAY.side[head/2])
    getini("System",s,"%f,%f",&scalex,&scaley)
    if scalex>0.2 && scalex<12.0 && scaley>0.2 && scaley<12.0 then
      headcamscale[head]=(scalex+scaley)/1024.0
      continue
    endif
    // Empty .ini file, use defaults.
    channel=Channelfromhead(head)
    if channel<0 then
      videosizex=0
    else
      SYS.Videosize(channel,&videosizex,&videosizey,&i)
    endif
    if videosizex<800 then
      scale=5.0
    else
      scale=3.0
    endif
    headcamscale[head]=scale/512.0
  enddo
  // Dedicated cameras.
  for i=0,i<2,i++ do
    head=$LAY.nfing*2+i
    if head>=32 break
    scalex=0.0; scaley=0.0
    sprintf(s,"Video scale[%i]",i)
    getini("System",s,"%f,%f",&scalex,&scaley)
    if scalex>0.2 && scalex<12.0 && scaley>0.2 && scaley<12.0 then
      headcamscale[head]=(scalex+scaley)/1024.0
    else
      headcamscale[head]=5.0/512.0
    endif
  enddo
end


////////////////////////////////////////////////////////////////////////////////
////////////////// SERVICE FUNCTIONS: BRIGHTNESS AND CONTRAST //////////////////

// Disables automatic adjustment of brightness and contrast on all video
// cameras. Errors are ignored. Works for all kinds of cameras.
function int Disableautoset()
  int head,channel
  for head=0,head<($LAY.nfing+1)*2,head++ do
    channel=Channelfromhead(head)
    if channel<0 continue
    SYS.Autoset(channel,0)
  enddo
end

// Reads individual per-camera brightness, contrast, illumination type and
// focal coordinate from .ini file.
function int Bcgetini()
  int head,bri,ctr
  char key[32]
  // Get defaults for the first run.
  illtype=0x03; longexp=0;
  getini("Video","Illumination type","%i,%i",&illtype,&longexp)
  bri=0; getini("ScrollAutoSave","Brightness","%i",&bri)
  ctr=0; getini("ScrollAutoSave","Contrast","%i",&ctr)
  focus[0]=-1000; getini("Video","Camera focus[0]","%i",focus+0)
  focus[1]=-1000; getini("Video","Camera focus[1]","%i",focus+1)
  for head=0,head<32,head++ do
    brightness[head]=bri
    contrast[head]=ctr
    if individualbc then
      sprintf(key,"Brightness[%i]",head)
      getini("Video",key,"%i",brightness+head)
      sprintf(key,"Contrast[%i]",head)
      getini("Video",key,"%i",contrast+head)
    endif
  enddo
end

// Saves individual per-camera brightness and contrast values to .ini file
function int Bcsetini()
  int head
  char key[32]
  setini("Video","Illumination type","%i,%i",illtype,longexp)
  setini("Video","Camera focus[0]","%i",focus[0])
  setini("Video","Camera focus[1]","%i",focus[1])
  if individualbc==0 then
    // No individual settings.
    setini("ScrollAutoSave","Brightness","%i",brightness[0])
    setini("ScrollAutoSave","Contrast","%i",contrast[0])
  else
    // Individual per-camera settings.
    for head=0,head<32,head++ do
      if $LAY.cameras!=0 then
        if head<$LAY.nfing*2 continue
        if ($LAY.cameras & (1<<(head-$LAY.nfing*2)))==0 continue
      else
        if ($LAY.headcameras & (1<<head))==0 continue
      endif
      sprintf(key,"Brightness[%i]",head)
      setini("Video",key,"%i",brightness[head])
      sprintf(key,"Contrast[%i]",head)
      setini("Video",key,"%i",contrast[head])
    enddo
  endif
end

// Connects brightness and contrast controls to the specified head.
function int Bcsetcam(int channel)
  int head
  if individualbc==0 return
  head=Headfromchannel(channel)
  if head==bchead then
    return
  else if head>=0 && head<32 then
    if hbrightness!=NULL change hbrightness select=brightness[head]
    if hcontrast!=NULL change hcontrast select=contrast[head]
    if hfocus!=NULL && (head==$LAY.nfing*2 || head==$LAY.nfing*2+1) then
      change hfocus text=format(" %i",focus[head-$LAY.nfing*2])
    endif
    bchead=head
  else
    bchead=-1
  endif
end

// Creates brightness, contrast and illumination or focus controls at the
// specified location (default location if x and y are -1).
function int Bccreate(handle hparent,int x,int y,int channel)
  int mode
  if x<0 x=5
  if y<0 y=303
  if testertype==TT_S3 then
    mode=2                             // Create focus controls
  else if illumination!=0 then
    mode=0
  else if (testertype==TT_A7 || testertype==TT_A8) then
    mode=1                             // Create illumination controls
  else
    mode=0
  endif
  hbrititle=control TEXT
    window=hparent
    position=x,y+4,27,16
    name="增益"
    help=" "
    font=INFOFONT
  endc
  hbrightness=control HSCROLL
    window=hparent
    position=x+32,y+2,(mode?120:150),21
    name=(individualbc?"":"亮度")
    help=format("调整所选相机%s",                                  \
      individualbc?" 的图像增益":"")
    limits=-100,100
  endc
  hctrtitle=control TEXT
    window=hparent
    position=x,y+31,27,16
    name="曝光"
    help=" "
    font=INFOFONT
  endc
  hcontrast=control HSCROLL
    window=hparent
    position=x+32,y+29,(mode?120:150),21
    name=(individualbc?"":"对比度")
    help=format("调整所选相机%s",                       \
      individualbc?" 的图像曝光时间":"")
    limits=-100,100
  endc
  if mode==1 then
    // Illumination controls.
    hilltop=control CHECKBOX
      window=hparent
      position=x+160,y,50,18
      name="顶"
      help="打开顶部照明，对所有相机都有效"
      font=INFOFONT
      mode=((illtype & 0x0C)==0 || (illtype & 0x4)!=0?M_CHECKED:0)
    endc
    hillskew=control CHECKBOX
      window=hparent
      position=x+160,y+18,55,18
      name="斜"
      help="打开侧面照明，对所有相机都有效"
      font=INFOFONT
      mode=((illtype & 0x08)!=0?M_CHECKED:0)
    endc
    hilllong=control CHECKBOX
      window=hparent
      position=x+160,y+36,55,18
      name="高亮"
      help="长时间曝光，仅适用于选定的相机"
      font=INFOFONT
      mode=(longexp?M_CHECKED:0)
    endc
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  else if mode==2 then
    // Focus controls.
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=control TEXT
      window=hparent
      position=x+160,y+31,45,16
      name="聚焦"
      help=" "
      font=INFOFONT
    endc
    hfocusup=control BUTTON
      window=hparent
      position=x+205,y+29,21,21
      name="-"
      help="按住可向上移动相机"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hfocus=control TEXT
      window=hparent
      position=x+225,y+29,62,21
      help="当前相机的Z坐标，微米"
      font=MEDIUMFONT
      mode=M_BORDER
      bkcolor=LIGHTYELLOW
      color=DARKGRAY
    endc
    hfocusdn=control BUTTON
      window=hparent
      position=x+286,y+29,21,21
      name="+"
      help="按住可向下移动相机"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    updatefocus[0]=1
    updatefocus[1]=1
  else
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  endif
  bchead=-1
  Bcsetcam(channel)
end

// Checks whether user has changed brightness, contrast or illumination and
// updates data. Returns combination of 0x01 (if brightness or contrast was
// changed) and 0x02 (if illumination type was changed). Additionally, sets
// S3 focus.
function int Bcupdate()
  int head,cam,changed,n
  char s[80]
  if individualbc==0 then
    head=0
  else if bchead<0 || bchead>=32 then
    return 0
  else
    head=bchead
  endif
  changed=0
  if hbrightness!=NULL && Pressed(hbrightness) then
    brightness[head]=Status(hbrightness)
    changed=changed | 0x01
  endif
  if hcontrast!=NULL && Pressed(hcontrast) then
    contrast[head]=Status(hcontrast)
    changed=changed | 0x01
  endif
  if hilltop!=NULL && Pressed(hilltop) then
    if Status(hilltop)!=0 then
      illtype=illtype|0x04
    else
      illtype=illtype & (~0x04)
      if (illtype & 0x0C)==0 then
        illtype=0x0B
        change hillskew mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hillskew!=NULL && Pressed(hillskew) then
    if Status(hillskew)!=0 then
      illtype=illtype|0x08
    else
      illtype=illtype & (~0x08)
      if (illtype & 0x0C)==0 then
        illtype=0x07
        change hilltop mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hilllong!=NULL && Pressed(hilllong) then
    longexp=Status(hilllong)
    changed=changed | 0x01
  endif
  if hfocus!=NULL then
    n=Min(Pressed(hfocusdn),3)
    n=n-Min(Pressed(hfocusup),3)
    cam=head-$LAY.nfing*2
    if n!=0 && (cam==0 || cam==1) then
      focus[cam]=Max(-8000,Min(focus[cam]+n*20,8000))
      change hfocus text=format(" %i",focus[cam])
      updatefocus[cam]=1
    endif
  endif
  if testertype==TT_S3 then
    if ($LAY.cameras & 0x1)!=0 && updatefocus[0]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+0,focus[0])
      SERV.Cmdimm(32,s)
      updatefocus[0]=0
    endif
    if ($LAY.cameras & 0x2)!=0 && updatefocus[1]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+1,focus[1])
      SERV.Cmdimm(32,s)
      updatefocus[1]=0
    endif
  endif
  return changed
end

// Deletes brightness and contrast controls. It's not a sin to forget to call
// this function, but then better not call any Bcxxx() except Bccreate() or
// Bcdisable().
function int Bcdelete()
  if bchead<0 return
  destroy hbrititle; hbrititle=NULL
  destroy hbrightness; hbrightness=NULL
  destroy hctrtitle; hctrtitle=NULL
  destroy hcontrast; hcontrast=NULL
  bchead=-1
  if hilltop!=NULL then
    destroy hilltop; hilltop=NULL
    destroy hillskew; hillskew=NULL
    destroy hilllong; hilllong=NULL
  endif
  if hfocus!=NULL then
    destroy hfoctitle; hfoctitle=NULL
    destroy hfocusup; hfocusup=NULL
    destroy hfocus; hfocus=NULL
    destroy hfocusdn; hfocusdn=NULL
  endif
end

// Disables brightness and contrast processing in the case that corresponding
// controls were not deleted by Bcdelete()
function int Bcdisable()
  hbrititle=NULL
  hbrightness=NULL
  hctrtitle=NULL
  hcontrast=NULL
  bchead=-1
  hilltop=NULL
  hillskew=NULL
  hilllong=NULL
  hfoctitle=NULL
  hfocusup=NULL
  hfocus=NULL
  hfocusdn=NULL
end

// Returns current brightness (-100..100) for the specified channel.
function int Bcgetbri(int channel)
  int head
  if individualbc==0 then
    return brightness[0]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return brightness[head]
  endif
end

// Returns current contrast (-100..100) for the specified head.
function int Bcgetctr(int channel)
  int head
  if individualbc==0 then
    return contrast[0]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return contrast[head]
  endif
end


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// TESTER FUNCTIONS ///////////////////////////////

// Check that Flying Probe Tester is loaded. Leave this procedure only when
// tester is loaded or when Close button is pressed.
function int Loadtester()
  int i,j,t
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="软件复位""
  delay 500
  SYS.Softimm(0)
  t=Time(); i=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("等待软件复位 - %i s",j)
      i=j
    endif
    if j>15 break
    wait
  enddo
  draw window=hright font=TIMESFONT
  if $A[0].length==0 then
    change hinfo name="机箱无应答"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is switched off\n"
    draw text="- Crash in embedded software\n"
    if $GLOBAL.a5==0 then
      draw text="- Flying Debugger or Test Player is running\n"
      draw text="- Optocable is pulled out\n"
    else
      draw text="- Network cable is unplugged\n"
    endif
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    while 1 do
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      wait
    enddo
  else if $A[0].answer==S_ERROR &&                                             \
    ($A[0].subcmd==E_NOCRATDATA || $A[0].subcmd==E_NOFINGDATA) then
    change hinfo name="测试器未加载"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="The Flying Probe Tester is not loaded. Of course, it "
    draw color=LIGHTRED text="must " color=BLACK
    draw text="be loaded before you can start the accuracy test. Typically, "
    draw text="all you need is to press 'Load all' in the appearing window. "
    if $GLOBAL.disabledrails!=0 then
      draw text="Please check for rails disabled in the Debug mode. "
    endif
    if ($GLOBAL.debugmode & 0x20BF)!=0 || ($GLOBAL.videomode & 0x20BF)!=0 ||   \
      $GLOBAL.disabledrails!=0 || $uint4($GLOBAL+280)!=0 then
      draw color=LIGHTRED
      draw text="Please also check that current Debug mode allows you to "
      draw text="run this test!"
    endif
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if $A[0].answer!=S_RESET then
    change hinfo name="软重置错误"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="Flying Probe Tester returned some unexpected answer. Normally, "
    draw text="this never happens. All I may suggest is to press 'Hard Reset' "
    draw text="and then reboot the tester. "
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  endif
  return 0
end

function int Getlayout()
  int i,j,t,ident,err
  char buf[16]
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="获取布局"
  delay 300
  buf[0]=S_LAYOUT
  buf[1]=0x03                          // Read layout with corrected phases
  ident=SYS.Sendimm(0,2,buf)
  t=Time(); i=0; err=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("等待布局 - %i s",j)
      i=j
    endif
    if j>15 break
    wait
  enddo
  if $A[0].length==0 then
    err=2
  else if $A[0].answer!=S_LAYOUT || $A[0].length!=774 then
    err=1
  else
    // Layout received. Get layout extentions.
    Memcpy($LAY,$A[0]+6,768)
    for i=0,i<16,i++                   // Same offsets in tester & inner copy
      $LAYCORR.leftzerox[i]=$LAY.leftzerox[i]
      $LAYCORR.leftzeroy[i]=$LAY.leftzeroy[i]
      $LAYCORR.rightzerox[i]=$LAY.rightzerox[i]
      $LAYCORR.rightzeroy[i]=$LAY.rightzeroy[i]
    enddo
    if $LAY.extlay>=1 then
      buf[0]=S_LAYOUT
      buf[1]=15                        // Read main layout extention
      SYS.Sendimm(0,2,buf)
    endif
    for j=1,j<$LAY.extlay && j<5,j++ do
      buf[0]=S_LAYOUT
      buf[1]=20                        // Read additional layout extention
      $int4(buf+2)=j-1                 // Index
      SYS.Sendimm(j,6,buf)
    enddo
    i=-1
    while 1 do
      for j=0,j<$LAY.extlay && j<5,j++ do
        if $A[j].length==0 break
        if $A[j].answer!=S_LAYOUT || $A[j].length!=(j==0?774:778) then
          err=1; break                 // Invalid answer
        endif
      enddo
      if err!=0 || j>=$LAY.extlay break
      if Pressed(hexit) return -1
      j=(Time()-t)/1000
      if i!=j then
        change hinfo text=format("等待布局 - %i s",j)
        i=j
      endif
      if j>15 then
        err=2; break                   // Timeout!
      endif
      wait
    enddo
    if err==0 then
      Memcpy($EXTLAY,$A[0]+6,768)
      if $LAY.extlay>=2 then
        Memcpy($EXT0,$A[1]+10,768)
      else
        Memset($EXT0,0,768)
      endif
      if $LAY.extlay>=3 then
        Memcpy($EXT1,$A[2]+10,768)
      else
        Memset($EXT1,0,768)
      endif
      if $LAY.extlay>=4 then
        Memcpy($EXT2,$A[3]+10,768)
      else
        Memset($EXT2,0,768)
      endif
      if $LAY.extlay>=5 then
        Memcpy($EXT3,$A[4]+10,768)
      else
        Memset($EXT3,0,768)
      endif
    endif
    SYS.Broadcast(8,"CHG LAY")         // Inform others that layout changed
  endif
  if err==0 then
    buf[0]=S_DUMP                      // Get version of embedded software
    buf[1]=255                         // Request to crate controller
    buf[2]=0x14                        // Get software version
    $uint2(buf+3)=0                    // Number of items
    $uint2(buf+5)=0                    // Start item
    ident=SYS.Sendimm(0,7,buf)
    change hinfo text="获取软件版本"
    delay 300
    t=Time(); i=0; err=0
    while $A[0].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as an interrupt
      if (Time()-t)>5000 break         // Timeout 5 seconds
      wait
    enddo
    if $A[0].length==0 then
      err=2
    else if $A[0].answer==S_DUMP then  // Correct answer, extract subfields
      j=5
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(crateversion,$A[0]+j)
      j=i
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(layoutversion,$A[0]+j)
      j=i
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(headversion,$A[0]+j)
    else
      err=3
    endif
  endif
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if err==1 || err==3 then
    if err==1 then
      change hinfo text="Error getting layout"
      draw text="The script was unable to get layout correctly. "
    else
      change hinfo text="Error getting version"
      draw text="The script was unable to get version of loaded software. "
    endif
    draw text="This error is absolutely unexpected here. Perharps, the best "
    draw text="way to recover is to reboot the tester. If you select this "
    draw text="option, then in the appearing window first press 'Hard reset', "
    draw text="then 'Load all'. After the tester is loaded, try again."
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以重新加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试获取布局或读取软件版本"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if err==2 then
    change hinfo text="No answer from crate"
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is off\n"
    draw text="- Flying Debugger or Test Player is running\n"
    draw text="- Crash in embedded software\n"
    draw text="- Optocable is pulled out\n"
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    while 1 do
      if Pressed(hretry) break
      if Pressed(hexit) return -1
      wait
    enddo
  endif
  return err
end

// Checks layout and sets global variables testertype and testersides. If
// tester is not recognized or not supported, function displays corresponding
// message.
function int Recognizetester()
  int i,w,h
  handle hok
  clear hright
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,60 wrap=RIGHTX-5
  w=($LAY.rightlimit-$LAY.leftlimit)/1000
  h=Min($LAY.top[0]-$LAY.yoffset[0],$LAY.yoffset[0]-$LAY.bottom[0])/500
  testersides=0
  xmin=$LAY.leftlimit/1000.0
  xmax=$LAY.rightlimit/1000.0
  ymin=9.9e99
  ymax=-9.9e99
  for i=0,i<$LAY.nfing,i++
    if $LAY.side[i]==0 then
      testersides=testersides|1
    else
      testersides=testersides|2
    endif
    ymin=Min(ymin,$LAY.bottom[i]/1000.0)
    ymax=Max(ymax,($LAY.top[i]-1)/1000.0)
  enddo
  if $LAY.nfing<=0 || $LAY.nfing>=16 then
    testertype=TT_WRONG                // Wrong layout
    draw text=format("Number of rails specified in the layout (%i) ",$LAY.nfing)
    draw text="is wrong. "
  else if w<=0 || h<=0 then
    testertype=TT_WRONG                // Wrong layout
    draw text="The size of the working area is wrong. "
  else if $LAY.cameras==0 && $LAY.headcameras==0 then
    testertype=TT_WRONG                // At least one camera must be present
    draw text="There are no video cameras on the tester. "
  else if ($LAY.config & 0x80)!=0 then
    if h==45 then
      testertype=TT_WRONG;             // M2 - not supported
      draw text="M2 tester is not supported by this script. "
    else
      testertype=TT_WRONG;             // Contradiction in layout
      draw text="The tester is declared as M2 in the layout, but the height "
      draw text=format("of the rail is %i millimeters instead of 45. ",h)
    endif
  else if testersides==2 then
    testertype=TT_WRONG                // Single-side tester
    draw text="Layout states that this tester is single-sided and that all "
    draw text="heads are from the bottom. "
  else if h==155 && ($LAY.config & 3)==2 then
    if w==600 && $LAY.software==0x84 then
      testertype=TT_A2;                // A1 or A2 with linear motors
    else if w==600 && $LAY.software==0x86 then
      testertype=TT_A2;                // A1 or A2 with belts
    else if w==600 && $LAY.software==0x8A then
      testertype=TT_A2H;               // A2 (MCM modification)
    else if w==600 && $LAY.software==0x8E then
      testertype=TT_A4;                // A4
    else if w>=310 && w<=600 && testersides==0x01 &&                           \
      ($LAY.software==0xA7 || ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S1;                // S1 (A7) tester
    else if w>=310 && w<=600 && testersides==0x03 &&                           \
      ($LAY.software==0xA7 || $LAY.software==0xA8 ||                           \
      ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S2;                // S2 tester
    else if $LAY.software==0xA9 || $LAY.software==0xAA ||                      \
      ($LAY.config & LC_TYPEMASK)==LC_S3 then
      testertype=TT_S3;                // S3 tester
    else if $LAY.software==0xB8 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A8;                // A8 tester
    else if w==600 && ($LAY.software==0xA5 || $LAY.software==0xA6) then
      testertype=TT_A6;                // A6 tester
    else if w==800 && $LAY.software==0x84 then
      testertype=TT_A2L;               // A1L or A2L with linear motors
    else if w==800 && $LAY.software==0x86 then
      testertype=TT_A2L;               // A1L or A2L with belts
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 600 or 800 for A2/A4/A6 tester. "
    endif;
  else if h==200 then
    if w==520 && $LAY.software==0xA5 then
      testertype=TT_A5;                // A5
    else if w==450 then
      testertype=TT_A3;                // A3
    else if w==520 then
      testertype=TT_A3L;               // A3L
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 450 or 520 for A3/A5 testers. "
    endif
  else if h==225 || h==230 || h==240 then
    if w==610 && $LAY.software==0xA5 then
      testertype=TT_A5L;               // A5L
    else if w>=610 && w<=625 && $LAY.software==0xA5 &&                         \
      ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      testertype=TT_A5L;               // A5A (L&M automate)
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 610 for A5L testers. "
    endif
  else if h>=250 && h<=260 then
    if $LAY.software==0xB7 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A7;                // A7
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text="Unable to recognize the type of the tester. "
    endif
  else
    testertype=TT_WRONG;               // Tester not recognized
    draw text="Unable to recognize the type of the tester. "
    if h!=155 && h!=200 then
      draw color=BLACK text="Strange height of the rail "
      draw text=format("(%i millimeters instead of expected 155, ",h)
      draw text="200, 230, 240 or 255) is encountered. "
    endif
  endif
  if testersides==3 && testertype!=TT_S3 then
    illumination=1
  else
    illumination=0
  endif
  if $LAY.cameras!=0 then
    leftlimit=($LAY.leftlimit+$LAY.videodeadx)/1000.0
    if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||         \
      testertype==TT_A2H                                                       \
    then
      rightlimit=($LAY.rightlimit-$LAY.videodeadx)/1000.0
    else
      rightlimit=$LAY.rightlimit/1000.0
    endif
  else
    leftlimit=$LAY.leftlimit/1000.0
    rightlimit=$LAY.rightlimit/1000.0
  endif
  if $LAY.cameras!=0 || $LAY.headcameras==0 then
    oppdx=12.0
    oppdy=0.0
  else if testertype==TT_A7 then
    oppdx=-2.0
    oppdy=15.0
  else
    oppdx=4.5
    oppdy=13.5
  endif
  if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||           \
    testertype==TT_A2H || testertype==TT_A4 || testertype==TT_A6 ||            \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A8 then
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=118.0
    endif
  else if testertype==TT_A3 || testertype==TT_A3L || testertype==TT_A5 ||      \
    testertype==TT_A5L then
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=153.0
    endif
  else if testertype==TT_A7 then
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=183.0
    endif
  else
    draw color=BLACK
    draw text="Therefore I don't know how to run this test. Please "
    if testertype!=TT_M2 && $LAY.cameras!=0 then
      draw text="check the settings in the layout and correct them, or "
    endif
    draw text="use different test procedure which supports given machine."
    draw at 6,30 color=LIGHTRED text="Unrecoverable error detected!"
    draw show
    clear hleft
    change hleft help="无法使用这种测试机"
    draw window=hleft color=DARKGRAY font=LARGEFONT mode=M_CENTERED
    draw at 95,70 bitmap=0,0,0,"unknown"
    draw show
    change hinfo limits=0,0
    change hinfo text="Unable to test"
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="！！..."
      help="按下可以终止测试"
    endc
    while Pressed(hok)==0 && Pressed(hexit)==0 do
      wait
    enddo
    testertype=TT_WRONG
  endif
end

// Gets list of features (MF_xxx) supported by measurement card. If command
// fails, list is zeroed assuming only basical functionality.
function int Getfeatures()
  int t
  char buf[32]
  features=0
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x1002001F             // Query features of measurement card
  SYS.Sendimm(0,6,buf)
  t=Time()
  while $A[0].length==0 do
    if Time()-t>1500 return            // Timeout
    wait
  enddo
  if $A[0].answer!=S_INPORT32 return   // Invalid answer
  features=$uint4($A[0]+5)
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// BOARD /////////////////////////////////////

// Draws board in the left window. If mode is 1, additionally marks location
// of fiducials used to locate rough board position.
function int Drawboard(int mode)
  int i,j,k,a,x,y,x0,y0,x1,y1
  clear hleft
  draw window=hleft color=WHITE bkcolor=WHITE clear
  x0=20
  x1=LEFTX-20
  y0=20
  y1=y0+x1-x0
  // Background.
  draw color=CYAN bkcolor=WHITECYAN
  draw at x0-4,y0-4 fillrect x1+5,y1+5
  // Grid.
  for k=0,k<4,k++ do
    if k==0 then
      a=(x1-x0-32)/2*1.00; draw color=LIGHTGRAY
    else if k==1 then
      a=(x1-x0-32)/2*0.75; draw color=GRAY
    else if k==2 then
      a=(x1-x0-32)/2*0.50; draw color=DARKGRAY
    else
      a=(x1-x0-32)/2*0.25; draw color=BLACK
    endif
    for i=-23,i<=23,i++ do
      if Abs(i)<2 continue
      x=(x0+x1)/2
      y=(y0+y1)/2+i*5
      draw at x-a,y to x+a+1,y
      x=(x0+x1)/2+i*5
      y=(y0+y1)/2
      draw at x,y-a to x,y+a+1
    enddo
  enddo
  // Contour.
  draw color=BLACK bkcolor=BLACK
  draw at x0,y0+16 to x1+1,y0+16
  draw at x0,y1-16 to x1+1,y1-16
  draw at x0+16,y0 to x0+16,y1+1
  draw at x1-16,y0 to x1-16,y1+1
  // Horizontal reference pads.
  for j=0,j<2,j++ do
    y=y0+j*(y1-y0-8)+4
    for i=0,i<3,i++ do
      x=x0+i*(x1-x0-32)/2+16
      draw at x-6,y-4 fillrect x+7,y+5
    enddo
  enddo
  // Vertical reference pads.
  for i=0,i<2,i++ do
    x=x0+i*(x1-x0-8)+4
    for j=0,j<3,j++ do
      y=y0+j*(y1-y0-32)/2+16
      draw at x-4,y-6 fillrect x+5,y+7
    enddo
  enddo
  // Main cross.
  draw at (x0+x1)/2-4,y0 fillrect (x0+x1)/2+5,y1+1
  draw at x0,(y0+y1)/2-4 fillrect x1+1,(y0+y1)/2+5
  // Additional EL100-2 specific contacts.
  if boardtype==1 then
    for j=0,j<2,j++ do
      y=y0+j*(y1-y0-8)+4
      draw at (x0+x1)/2-20,y to (x0+x1)/2+20,y
      for i=0,i<2,i++ do
        x=(x0+x1)/2+(i*2-1)*20
        draw at x-6,y-4 fillrect x+7,y+5
      enddo
    enddo
    for i=0,i<2,i++ do
      x=x0+i*(x1-x0-8)+4
      draw at x,(y0+y1)/2-20 to x,(y0+y1)/2+20
      for j=0,j<2,j++ do
        y=(y0+y1)/2+(j*2-1)*20
        draw at x-4,y-6 fillrect x+5,y+7
      enddo
    enddo
  endif
  // Fiducials.
  for i=0,i<2,i++ do
    x=x0+i*(x1-x0-32)+16
    for j=0,j<2,j++ do
      y=y0+j*(y1-y0-32)+16
      draw bkcolor=WHITECYAN
      draw at x,y fillellipse 10,10
      draw bkcolor=BLACK
      draw at x-2,y-2 fillrect x-0,y-0
      draw at x+1,y-2 fillrect x+3,y-0
      draw at x-2,y+1 fillrect x-0,y+3
      draw at x+1,y+1 fillrect x+3,y+3
    enddo
  enddo
  // Text.
  draw font=SMALLFONT color=BLACK mode=M_LEFT
  if boardtype==1 then
    draw at x0+30,y1 text="EL100-2"
  else
    draw at x0+30,y1 text="EL100"
    draw at (x0+x1)/2-35,y1 text="TOP"
    draw at (x0+x1)/2+12,y1 text="FRONT"
  endif
  // Optional fiducial marks.
  if mode==1 then
    draw color=LIGHTRED font=LARGEFONT
    for k=0,k<2,k++ do
      if k==0 then
        x=x0+16; y=y1-16
      else
        x=x1-16; y=y0+16
      endif
      for i=-1,i<=1,i++ do
        for j=-1,j<=1,j++ do
          draw at x+i,y+j ellipse 21,21
        enddo
      enddo
    enddo
    draw at x0+23,y1-16 text="1"
    draw at x1-42,y0+57 text="2"
  endif
  draw show
end

// Returns 0 on success and -1 if operator decided to interrupt the test.
function int Installboard(int isa4)
  int i,t,ident,portdata,prevdata
  char buf[32]
  handle hstatus,hlock,hunlock,hok
  change hinfo limits=0,0
  change hinfo text="Install board"
  Drawboard(0)
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Install EL100 in the location where you want to check tester "
  draw text="accuracy. This test does not distinguish one head from another "
  draw text="and uses all heads that may reach the lines. Press "
  draw font=MAINFONT text="确定" font=TIMESFONT text="when ready."
  draw show
  if isa4 then
    hstatus=NULL
  else
    hstatus=control TEXT
      window=hright
      name="未知架板框状态"
      position=5,180,RIGHTX-10,21
      font=MEDIUMFONT
      color=BLACK
      bkcolor=PINK
      mode=M_CENTERED|M_BORDER
    endc
  endif
  hlock=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="锁止"
    help="按下可以锁住架板框"
  endc
  hunlock=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="解锁"
    help="按下可以解锁架板框"
  endc
  hok=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="确定"
    help="当产品正确放置后按下"
  endc
  disable hok
  t=0; portdata=-1; prevdata=portdata
  while 1 do
    if portdata!=prevdata then
      if isa4 then
        enable hok
      else
        i=portdata & 0x35
        if i==0x20 then                // Shuttle locked in test position
          enable hok
          change hstatus text="Shuttle locked"
        else if (i & 0x10)==0 && testertype!=TT_S1 &&                          \
          testertype!=TT_S2 then
          disable hok
          change hstatus text="Shuttle in"
        else
          disable hok
          change hstatus text="Shuttle out"
        endif
      endif
      prevdata=portdata
    endif
    if Pressed(hlock) then
      buf[0]=S_LOCKDOOR; buf[1]=1      // Lock door
      SYS.Send(2,buf,0)
    else if Pressed(hunlock) then
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)
    else if Pressed(hok) && (portdata & 0x35)==0x20 then
      return 0
    else if Pressed(hexit) then
      return -1
    endif
    wait
    if t==0 then                       // Send next port query
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      ident=SYS.Sendimm(0,3,buf)
      t=Time()+10000                   // Timeout 10 seconds
    else if $A[0].length>0 then
      if $A[0].answer==S_INPORT then
        portdata=$A[0].inport          // Correct answer
        t=0
      endif
    else if t<Time() then
      SYS.Killsend(ident)
      t=0
    endif
  enddo
end

// Asks L&M for the value of the specified parameter. If answer is present,
// sets value to the received string <parm>=<answer> (i.e. parm and equation
// sign are included). If answer is absent (#), value remains unchanged.
// Returns 0 on success, 1 on failure or if value is absent and -1 if user
// cancelled test.
function int Getlmparameter(char *parm,char *value)
  int i,n,haseq,hashash
  char buf[768]
  SYS.Killimm(33)
  buf[0]=S_LMAUTO
  buf[1]=3                             // Get parameter
  n=2+sprintf(buf+2,"%s",parm)
  SYS.Sendimm(33,n,buf)
  while $A[33].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[33].answer!=S_LMAUTO return 1  // Bad answer
  haseq=0; hashash=0;
  for i=0,i<$A[33].length-6,i++ do
    if $char($A[33]+6+i)=='=' haseq=1
    if $char($A[33]+6+i)=='#' hashash=1
  enddo
  if haseq==0 || hashash!=0 return 1
  for i=0,i<$A[33].length-6,i++ do
    value[i]=$char($A[33]+6+i)
  enddo
  value[i]='\0'
  return 0
end

// Sends text command to L&M automation and waits for answer. Returns 1 on
// success, 0 on failure, 2 on timeout and -1 if user cancelled test.
function int Sendlmcommand(char *cmd,char *answer,char *error,int timeout)
  int m,n,status
  char buf[768]
  SYS.Killimm(33)
  buf[0]=S_LMAUTO
  buf[1]=4                             // Send command
  $uint2(buf+2)=timeout                // Timeout, seconds
  n=4+sprintf(buf+4,"%s\n",cmd)
  n=n+sprintf(buf+n,"%s",answer)
  SYS.Sendimm(33,n,buf)
  while $A[33].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[33].answer!=S_LMAUTO return 0  // Bad answer
  status=$uint2($A[33]+6)
  if (status & 0x01) return 2          // Timeout
  if $char($A[33]+8)=='1' then
    n=8
    m=0                                // Success
    while $char($A[33]+n)!='\n' && n<$A[33].length do
      error[m]=$char($A[33]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 1
  else
    n=8                                // Error
    while $char($A[33]+n)!='\n' && n<$A[33].length do
      n++
    enddo
    if $char($A[33]+n)=='\n' && n<$A[33].length n++
    m=0
    while $char($A[33]+n)!='\n' && n<$A[33].length do
      error[m]=$char($A[33]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 0
  endif
end

// Gets actual teachin settings for L&M hardware. Settings are saved to the
// array lmteachin[], prefix MECH.Teachin is replaced by MECH.Para. Returns 0
// on success, >0 in the case of communication error or -1 if operator decided
// to interrupt the test.
function int Getteachinsettings()
  int i
  nlmteachin=0
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO &&                                 \
    ($LAY.config & LC_LDMASK)!=LC_LMS2AUTO return 0
  i=Getlmparameter("MECH.Teachin.ShuttleX",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  i=Getlmparameter("MECH.Teachin.ShuttleY",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  if ($LAY.config & LC_LDMASK)==LC_LMS2AUTO then
    i=Getlmparameter("MECH.Para.InputShuttleX",lmteachin[nlmteachin])
    if i!=0 return i
    nlmteachin++
    i=Getlmparameter("MECH.Para.InputShuttleY",lmteachin[nlmteachin])
    if i!=0 return i
    nlmteachin++
  else
    i=Getlmparameter("MECH.Para.BoardH",lmteachin[nlmteachin])
    if i!=0 return i
    nlmteachin++
    i=Getlmparameter("MECH.Para.BoardW",lmteachin[nlmteachin])
    if i!=0 return i
    nlmteachin++
  endif
  i=Getlmparameter("MECH.Para.UseCatcherOnly",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  return 0
end

// Installs holder in L&M automatical shuttle. Returns 0 on success, >0 in the
// case of communication error or -1 if operator decided to interrupt script.
function int InstallboardLM()
  int i,t,nfing,setpos,prevdata,portdata,adjusting,adjusted
  int s3split,firsttime,loadrequest,err
  char buf[256],errtxt[256]
  handle f,hstatus,hloadl,hloadr,hunload,hadjust
  handle hok,hyes,hno,hretry,hcancel
  nfing=$LAY.nfing
  firsttime=1
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    s3split=1
  else
    s3split=0
  endif
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  for i=0,i<nfing,i++
    sprintf(buf,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,buf)
  enddo
  t=Time()
  while (1) do
    for i=0,i<nfing,i++
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=nfing break                  // All answers came
    if Pressed(hexit) return -1        // Operator interrupted test
    if Time()-t>10000 break            // No answer within 10 s timeout
    wait
  enddo
retry:
  Drawboard(0)
  clear hright
  change hinfo limits=0,0
  change hinfo text="Setting pure manual mode..."
  // Check that Parameter Server supports MECH.Para.IsGlassBoard. If parameter
  // is initially absent, it would be too dangerous to install glass: it could
  // be destroyed by the centering pieces.
  Strcpy(buf,"#")
  i=Getlmparameter("MECH.Para.IsGlassBoard",buf)
  if i<0 return -1
  if i!=0 || buf[0]=='#' then
    change hinfo text="Old MECH"
    clear hright
    draw window=hright color=LIGHTRED font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text="Your copy of MechA5a.exe does not support glass boards. "
    draw color=BLACK text="When shuttle with board moves, centering bars "
    draw text="will attempt to hold the board. Unfortunately, they are "
    draw text="powerfull enough to break the glass. Please calibrate tester "
    draw text="with FR4 board, or ask atg for the updated Parameter Server."
    draw show
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="！！..."
      help="按下可以终止测试"
    endc
    while Pressed(hok)==0 && Pressed(hexit)==0 do
      wait
    enddo
    return -1
  endif
  // Now set glass board.
  i=Sendlmcommand("MECH.Para.IsGlassBoard=1","",errtxt,10)
  if i<0 return -1
  if i==2 then
    change hinfo text="Unable to handle glass"
    clear hright
    draw window=hright color=LIGHTRED font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text="Calibration script was unable to turn on special glass "
    draw text="handling. Parameter server reported timeout. When shuttle "
    draw text="with board moves, centering bars will attempt to hold the "
    draw text="board. Unfortunately, they are powerfull enough to break the "
    draw text="glass. Please calibrate tester with FR4 board, or restart "
    draw text="the test."
    draw show
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="！！..."
      help="按下可以终止测试"
    endc
    while Pressed(hok)==0 && Pressed(hexit)==0 do
      wait
    enddo
    return -1
  endif
  isglassboard=1                       // IsGlassBoard was set to 1
  // Check whether there is a board in the shuttle. It may happen that previous
  // test was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  if $A[32].length==7 && $A[32].answer==S_INPORT then
    portdata=$A[32].inport
  else
    portdata=0
  endif
  if (portdata & 0x35)!=0x20 then
    // Set positions of L&M actuators for holder board.
    f=Fopen("c:\\hardware\\shuttle_accur.txt","rb")
    if f!=NULL then
      Fclose(f)
      change hinfo text="Setting up shuttle..."
      i=Sendlmcommand("PS.Cmd=FileRead c:/hardware/shuttle_accur.txt",         \
        "PS.Ready.FileRead",errtxt,5)
      if i<0 return -1
      setpos=(i==1)
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock shuttle, moves actuators
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else
      setpos=0                         // Shuttle positions not set
    endif
  else
    setpos=0
  endif
  // Set pure manual automation mode.
  i=Sendlmcommand("MECH.Cmd=SetMode 5","MECH.Ready.SetMode",errtxt,20)
  if i<0 return -1
  // Installation controls.
  change hinfo text="Install holder for glass board"
  hstatus=control TEXT
    window=hright
    name="未知架板框状态"
    position=9,190,RIGHTX-17,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  if s3split==0 then
    hloadl=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY-35,120,24
      name="加载"
      help="按下即可将夹板条装载到架板框上"
    endc
    hloadr=NULL
    hunload=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-35,120,24
      name="卸载"
      help="按下即可将夹板条从架板框上卸下"
    endc
  else
    hloadl=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY-35,120,24
      name="加载左侧"
      help="按下即可将夹板条装载到左边架板框上"
    endc
    hloadr=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-35,120,24
      name="加载右侧"
      help="按下即可将夹板条装载到右边架板框上"
    endc
    hunload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="卸载"
      help="按下即可将夹板条从架板框上卸下"
    endc
  endif
  if s3split==0 then
    hadjust=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="调试"
      help="按下可以使用手动控制箱调节架板框"
    endc
    disable hadjust
  else
    hadjust=NULL
  endif
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="确定"
    help="如果夹板条安装正确，请按下。"
  endc
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="Now install the holder for the accuracy test board. Press "
  draw font=MAINFONT text="Adjust " font=TIMESFONT text="to adjust widht and "
  draw text="height of the shuttle manually. Press " font=MAINFONT text="OK "
  draw font=TIMESFONT text="when holder is correctly placed in the shuttle. "
  draw text="Please be carefull: glass board is fragile!"
  draw show
  // Main loop.
  err=0
  prevdata=-1
  adjusting=0
  adjusted=0
  t=0
  while err==0 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if adjusting then
        change hstatus text="Adjustment mode"
        enable hloadl
        if s3split!=0 enable hloadr
        disable hunload
        if s3split==0 disable hadjust
        disable hok
      else if i==0x20 then             // Shuttle locked in test position
        change hstatus text="Holder in the shuttle"
        disable hloadl
        if s3split!=0 disable hloadr
        enable hunload
        if s3split==0 disable hadjust
        if firsttime then
          disable hok
        else
          enable hok
        endif
      else
        change hstatus text="Shuttle out"
        enable hloadl
        if s3split!=0 enable hloadr
        enable hunload
        //if s3split==0 enable hadjust
        if s3split==0 disable hadjust
        disable hok
      endif
      prevdata=portdata
    endif
    if Pressed(hloadl) then
      loadrequest=0
    else if s3split!=0 && Pressed(hloadr) then
      loadrequest=1
    else
      loadrequest=-1
    endif
    if loadrequest>=0 then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 5","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      if s3split && pulledshuttle!=loadrequest then
        if pulledshuttle>=0 then
          sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i",pulledshuttle)
          i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
          if i<0 return -1
          pulledshuttle=-1
        endif
        if pulledshuttle!=loadrequest then
          sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i 0",loadrequest)
          i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
          if i<0 return -1
          if i!=1 goto nopull
          pulledshuttle=loadrequest
        endif
      endif
      buf[0]=S_LOCKDOOR
      if s3split==0 then
        buf[1]=1                       // Lock door
        shuttle=-1
        Strcpy(scmd,"")
      else if loadrequest==0 then
        buf[1]=80                      // Load board in left shuttle
        shuttle=0
        Strcpy(scmd," SH(1)")
      else
        buf[1]=81                      // Load board in right shuttle
        shuttle=1
        Strcpy(scmd," SH(2)");
      endif
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      firsttime=0
      prevdata=-1
    else if Pressed(hunload) then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      firsttime=0
      prevdata=-1
      if s3split && pulledshuttle>=0 then
        sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i",pulledshuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
        if i<0 return -1
        pulledshuttle=-1
      endif
    else if s3split==0 && Pressed(hadjust) then
      i=Sendlmcommand("MECH.Cmd=SetMode 4","MECH.Ready.SetMode",errtxt,60)
      if i<0 return -1
      i=Sendlmcommand("MECH.Para.Teachin=1","",errtxt,10)
      if i<0 return -1
      adjusting=1
      adjusted=1
      prevdata=-1
    else if Pressed(hok) && ((portdata & 0x35)==0x20) then
      if adjusted!=0 then
        // Shuttle settings were probably changed, ask to update file.
        clear hright
        change hinfo limits=0,0
        change hinfo text="Save shuttle settings"
        draw window=hright color=BLACK font=TIMESFONT
        draw at 6,30 wrap=RIGHTX-5
        draw text="Would you like to save the actual shuttle settings to the "
        draw text="disk, so that the next test will automatically use "
        draw text="them?\n\n" color=GRAY text="Note: board size and catchers "
        draw text="remain unchanged; if necessary, edit them directly in the "
        draw text="file c:\\hardware\\shuttle_accur.txt."
        hyes=control BUTTON
          window=hright
          position=RIGHTX/2-124,USERY,120,24
          name="是"
          help="按下将架板框设置保存到文件"
        endc
        hno=control BUTTON
          window=hright
          position=RIGHTX/2+5,USERY,120,24
          name="否"
          help="按下可仅在当前会话中使用新的架板框设置"
        endc
        while 1 do
          if Pressed(hexit) then
            return -1
          else if Pressed(hno) then
            break
          else if Pressed(hyes) then
            Getteachinsettings()
            if nlmteachin>0 then
              f=Fopen("c:\\hardware\\shuttle_accur.txt","wt")
              if f!=NULL then
                for i=0,i<nlmteachin,i++ do
                  fprintf(f,"%s\n",lmteachin[i])
                enddo
                Fclose(f)
              endif
            endif
            break
          endif
          wait
        enddo
      endif
      break
    else if Pressed(hexit) then
      return -1
    endif
    if t==0 then                       // Send next port query
      SYS.Killimm(32)
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      SYS.Sendimm(32,3,buf)
      t=Time()                         // Timeout 5 seconds
    else if $A[32].length>0 then
      if $A[32].answer==S_INPORT then
        portdata=$A[32].inport         // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if Time()-t>5000 then
      t=0
      err=1                            // No answer from tester
    endif
    wait
  enddo
  return err
nopull:
  // A8eaPreparePullCalib returned error. Inform user. Varioable i is 0 on
  // faiure (reason is in errtxt) and 2 on timeout.
  delay 500                            // Psychology
  clear hright
  change hinfo limits=0,0
  change hinfo text="Unable to prepare shuttle"
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if i==2 then
    draw text="There was no response from the Parameter Server. "
  else
    draw text="Parameter Server reports error on attempt to "
    draw text="prepare shuttle for the accuracy test. "
    draw color=BLACK text=format("Reason: '%s'. ",errtxt)
  endif
  draw color=BLACK text="Press " font=MAINFONT text="Retry "
  draw font=TIMESFONT text="to continue or " font=MAINFONT text="Cancel "
  draw font=TIMESFONT text="to quit verification."
  draw show
  hretry=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="重试"
    help="按下可将命令重新发送到参数服务器"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="取消"
    help="退出校准"
  endc
  while 1 do
    if Pressed(hretry) then
      goto retry
    else if Pressed(hcancel) then
      return -1
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Unloads board from the shuttle. Used in the case of L&M automation. Returns
// -1 if user interrupted the script and 0 in any other case.
function int Unloadboard()
  int i,j,glass,t
  char buf[32],errtxt[256]
  handle hyes,hno,hretry,hcancel
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO                                    \
    return 0                           // Does not apply
  // Check whether there is a board in the shuttle. It may happen that previous
  // test was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  if $A[32].answer==S_INPORT && ($A[32].inport & 0x35)==0 then
//    return 0                           // Shuttle is empty
  endif
  Drawboard(0)
  // Make soft reset before sending commands to automation directly: heads may
  // still move!
  clear hright
  change hinfo limits=0,0
  change hinfo text="软件复位""
  SYS.Softimm(32)
  t=Time(); i=0
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("等待软件复位 - %i s",j)
      i=j
    endif
    if j>15 return 0                   // Too long soft reset
    wait
  enddo
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    SYS.Killimm(32)
    buf[0]=S_LOCKDOOR
    buf[1]=0                           // Unlock door
    SYS.Sendimm(32,2,buf)
    while $A[32].length==0 do
      if Pressed(hexit) return -1      // Interrupt
      wait
    enddo
  endif
  // On S3 with split shuttle, board will be unfixed. Ask operator if he wants
  // to keep board locked.
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    clear hright
    change hinfo limits=0,0
    change hinfo text="Unloading board..."
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK
    draw text="Do you want to keep board holder locked in the shuttle? "
    draw show
    hyes=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="保持"
      help="按下以将夹板条保留在架板框中"
    endc
    hno=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="移除"
      help="按下卸载产品"
    endc
    while 1 do
      if Pressed(hyes) then
        return 0
      else if Pressed(hno) then
        break
      else if Pressed(hexit) then
        return -1
      endif
      wait
    enddo
  endif
retry:
  clear hright
  change hinfo limits=0,0
  change hinfo text="Unloading board..."
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Holder with glass board will be unloaded. To avoid damages, "
  draw text="please remove it from the shuttle."
  draw show
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO &&           \
    pulledshuttle>=0                                                           \
  then
    sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i",pulledshuttle)
    i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
    if i<0 return -1
    if i!=1 goto nopull
    pulledshuttle=-1
  endif
  if (testertype==TT_A5L || testertype==TT_A7) &&                              \
    ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    if isglassboard then
      i=Sendlmcommand("MECH.Para.IsGlassBoard=0","",errtxt,5)
      isglassboard=0
    endif
  else
    // For the case that tester is for some reason in the adjustment mode. May
    // be too dangerous when handling glass.
    i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,5)
  endif
  if i<0 return -1

  if ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
    SYS.Killimm(32)
    buf[0]=S_LOCKDOOR
    buf[1]=0                             // Unlock door
    SYS.Sendimm(32,2,buf)
    while $A[32].length==0 do
      if Pressed(hexit) return -1        // Interrupt
      wait
    enddo
  endif
  return 0
nopull:
  // A8eaRestorePullCalib returned error. Inform user. Variable i is 0 on
  // faiure (reason is in errtxt) and 2 on timeout.
  delay 500                            // Psychology
  clear hright
  change hinfo limits=0,0
  change hinfo text="Unable to unload board"
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if i==2 then
    draw text="There was no response from the Parameter Server. "
  else
    draw text="Parameter Server reports error on attempt to "
    draw text="unload board. "
    draw color=BLACK text=format("Reason: '%s'. ",errtxt)
  endif
  draw color=BLACK text="Press " font=MAINFONT text="Retry "
  draw font=TIMESFONT text="to retry or " font=MAINFONT text="Cancel "
  draw font=TIMESFONT text="to quit calibration."
  draw show
  hretry=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="重试"
    help="按下可将命令重新发送到参数服务器"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="取消"
    help="退出验证"
  endc
  while 1 do
    if Pressed(hretry) then
      goto retry
    else if Pressed(hcancel) then
      return -1
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Asks operator to find the rough location of two fiducials on the board.
// Returns -1 if operator interrupted test, 0 if both crosses are found and
// automatical scanning is requested, and 1 if operator decided to change board
// placement.
function int Locateboard()
  int i,x,y,n,head,opp,selected,firstpos,updatexy,move,moving,okallowed,ret
  int videoon,showvideo,channel,side,updatevideo,updatevtext,oppflash
  float dx,dy,r,posx,posy,oppx,oppy,angle
  char s[256]
  handle hx,hy,hu,hl,hr,hd,hoppu,hoppl,hoppr,hoppd,hauto
  handle hpos1,hpos2,hside,hok,hrepos,hview,hlivevideo
  change hinfo limits=0,0
  change hinfo text="Find board position"
  Drawboard(1)
  clear hright
  // Information.
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now find rough positions of two marked fiducials. Press "
  draw font=MAINFONT text="Fid 1 " font=TIMESFONT text="or " font=MAINFONT
  draw text="Fid 2 " font=TIMESFONT text="to select fiducial. "
  if testersides==0x3 then
    draw text="Press " font=MAINFONT text="Side " font=TIMESFONT
    draw text="to check opposite side. "
  endif
  if illumination==1 then
    draw text="To adjust illumination, use small blue cross."
  endif
  // X-Y coordinates.
  draw color=DARKGRAY font=INFOFONT
  if illumination==0 then
    draw at 11,130 text="Current X="
    draw at 139,130 text=", Y="
    draw at 227,130 text="mm"
  else
    draw at 166,125 text="X="
    draw at 166,154 text="Y="
  endif
  hx=control TEXT
    window=hright
    position=(illumination==0?82:188),(illumination==0?111:106),54,22
    help="相机的实际X坐标"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  hy=control TEXT
    window=hright
    position=(illumination==0?168:188),(illumination==0?111:135),54,22
    help="相机的实际Y坐标"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw show
  // Location cross.
  y=(illumination==0?USERY-88:95)
  hu=control BUTTON
    window=hright
    position=60,y,40,40
    name="上"
    help="按下可以向上移动相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hl=control BUTTON
    window=hright
    position=18,y+43,40,40
    name="左"
    help="按下可以向左移动相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hr=control BUTTON
    window=hright
    position=102,y+43,40,40
    name="右"
    help="按下可以向右移动相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hd=control BUTTON
    window=hright
    position=60,y+86,40,40
    name="下"
    help="按下可将相机向下移动"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  // Illumination cross and auto adjustment.
  if illumination then
    hoppu=control BUTTON
      window=hright
      position=65,235,30,30
      name="光上"
      help="按下可将反光向上移动"
      color=LIGHTBLUE
      bkcolor=WHITEBLUE
      mode=M_REPEAT
    endc
    hoppl=control BUTTON
      window=hright
      position=28,255,30,30
      name="光左"
      help="按下可将反光向左移动"
      color=LIGHTBLUE
      bkcolor=WHITEBLUE
      mode=M_REPEAT
    endc
    hoppr=control BUTTON
      window=hright
      position=102,255,30,30
      name="光右"
      help="按下可将反光向右移动"
      color=LIGHTBLUE
      bkcolor=WHITEBLUE
      mode=M_REPEAT
    endc
    hoppd=control BUTTON
      window=hright
      position=65,275,30,30
      name="光下"
      help="按下可将反光向下移动"
      color=LIGHTBLUE
      bkcolor=WHITEBLUE
      mode=M_REPEAT
    endc
    hauto=control CHECKBOX
      window=hright
      position=28,310,120,20
      name="自动调整"
      help="扫描时检查自动调整反向照明"
      color=BLUE
      mode=(autoadjust?M_CHECKED:0)
    endc
  endif
  // Buttons.
  hpos1=control BUTTON
    window=hright
    position=166,173,RIGHTX-180,24
    name="基准 1"
    help="按下可以找到第一个基准点的位置"
    color=BLACK
    bkcolor=GRAY
  endc
  hpos2=control BUTTON
    window=hright
    position=166,204,RIGHTX-180,24
    name="基准 2"
    help="按下可以找到第二个基准点的位置"
    color=BLACK
    bkcolor=GRAY
  endc
  if testersides==0x3 then
    hside=control BUTTON
      window=hright
      position=166,235,RIGHTX-180,24
      name="Side"
      help="按下可以从另一面检查照明"
      color=BLACK
      bkcolor=GRAY
    endc
  else
    hside=NULL
  endif
  hok=control BUTTON
    window=hright
    position=166,266,RIGHTX-180,24
    name="确定"
    help="当产品的大概位置找到时按下"
    color=BLACK
    bkcolor=GRAY
  endc
  disable hok
  okallowed=0
  hrepos=control BUTTON
    window=hright
    position=166,297,RIGHTX-180,24
    name="Replace"
    help="当需要更改产品的位置时按下"
    color=BLACK
    bkcolor=GRAY
  endc
  // Video viewer.
  hview=control CHILD
    window=hleft
    position=-1000,-1000,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    bkcolor=VIDEOFILL
    help="相机的实时图像"
  endc
  Bccreate(hview,-1,-1,channel)
  // Get expected coordinates from the last run.
  pos1x=0.0; pos1y=0.0;
  pos2x=0.0; pos2y=0.0
  autoadjust=0
  getini("Accuracy test","Fiducials","%g,%g,%g,%g,%i",                         \
    &pos1x,&pos1y,&pos2x,&pos2y,&autoadjust)
  r=Sqrt((pos2x-pos1x)*(pos2x-pos1x)+(pos2y-pos1y)*(pos2y-pos1y))
  if Abs(r-124.45)>1.5 then
    pos1x=$LAY.xoffset/1000.0-44.0
    pos1y=(ymin+ymax)/2.0-44.0
    pos2x=pos1x+88.0
    pos2y=pos1y+88.0
  endif
  videoon=0
  showvideo=(firstscan?0:1)
  selected=0
  firstpos=1
  updatexy=1
  move=showvideo
  moving=0
  updatevideo=1; updatevtext=1
  posx=pos1x; posy=pos1y
  side=-1
  Camerafromy(posy,&channel,&side,&angle)
  // Location loop.
  while 1 do
    // Process location cross.
    if Pressed(hu) then
      dx=0.0; dy=(Status(hu)+1)*VSTEP
    else if Pressed(hl) then
      dx=-(Status(hl)+1)*VSTEP; dy=0.0
    else if Pressed(hr) then
      dx=(Status(hr)+1)*VSTEP; dy=0.0
    else if Pressed(hd) then
      dx=0.0; dy=-(Status(hd)+1)*VSTEP
    else
      dx=0.0; dy=0.0
    endif
    if dx!=0.0 || dy!=0.0 then
      if posx+dx<xmin dx=xmin-posx
      if posx+dx>xmax dx=xmax-posx
      if posy+dy<ymin dy=ymin-posy
      if posy+dy>ymax dy=ymax-posy
      posx=Max(xmin,Min(posx+dx,xmax))
      posy=Max(ymin,Min(posy+dy,ymax))
      if firstpos then
        pos2x=Max(xmin,Min(pos2x+dx,xmax))
        pos2y=Max(ymin,Min(pos2y+dy,ymax))
      endif
      if selected==0 then
        pos1x=posx; pos1y=posy
      else
        pos2x=posx; pos2y=posy
      endif
      showvideo=1; updatexy=1; move=1
    endif
    // Process illumination cross.
    if Pressed(hoppu) then
      dx=0.0; dy=(Status(hoppu)+1)*VSTEP
    else if Pressed(hoppl) then
      dx=-(Status(hoppl)+1)*VSTEP; dy=0.0
    else if Pressed(hoppr) then
      dx=(Status(hoppr)+1)*VSTEP; dy=0.0
    else if Pressed(hoppd) then
      dx=0.0; dy=-(Status(hoppd)+1)*VSTEP
    else
      dx=0.0; dy=0.0
    endif
    if (dx!=0.0 || dy!=0.0) && illumination==1 then
      head=Camerafromy(posy,&channel,&side,&angle)
      if head>=0 then
        opp=Oppositecam(head)
        if opp>=0 then
          dx=Max(-10.0,Min(headthrudx[opp][selected]+dx,10.0))
          dy=Max(-10.0,Min(headthrudy[opp][selected]+dy,10.0))
          if dx!=headthrudx[opp][selected] ||                                  \
            dy!=headthrudy[opp][selected]                                      \
          then
            headthrudx[opp][selected]=dx
            headthrudy[opp][selected]=dy
            move=1; updatexy=1
          endif
        endif
      endif
      showvideo=1
    endif
    if hauto!=NULL && Pressed(hauto) then
      autoadjust=Status(hauto)
    endif
    // Update coordinate display.
    if updatexy then
      change hx text=format("%5.1f",posx)
      change hy text=format("%5.1f",posy)
      updatexy=0
    endif
    // Check distance and allow/disable OK button.
    r=Sqrt((pos2x-pos1x)*(pos2x-pos1x)+(pos2y-pos1y)*(pos2y-pos1y))
    if Abs(r-124.45)>1.5 && okallowed!=0 then
      disable hok
      okallowed=0
    else if Abs(r-124.45)<=1.5 && showvideo==1 && okallowed!=1 then
      enable hok
      okallowed=1
    endif
    // Process action buttons.
    if Pressed(hpos1) then
      posx=pos1x; posy=pos1y
      selected=0
      change hpos1 color=LIGHTRED
      change hpos1 bkcolor=YELLOW
      change hpos2 color=BLACK
      change hpos2 bkcolor=GRAY
      showvideo=1
      firstscan=0
      updatexy=1
      move=1
    else if Pressed(hpos2) then
      posx=pos2x; posy=pos2y
      selected=1
      change hpos2 color=LIGHTRED
      change hpos2 bkcolor=YELLOW
      change hpos1 color=BLACK
      change hpos1 bkcolor=GRAY
      firstpos=0
      showvideo=1
      firstscan=0
      updatexy=1
      move=1
    else if Pressed(hside) then
      side=1-side
      showvideo=1
      firstscan=0
      updatexy=1
      updatevtext=1
      move=1
    else if Pressed(hok) then
      setini("Accuracy test","Fiducials","%g,%g,%g,%g,%i",                     \
        pos1x,pos1y,pos2x,pos2y,autoadjust)
      ret=0; break
    else if Pressed(hrepos) then
      ret=1; break
    else if Pressed(hexit) then
      ret=-1; break
    endif
    // Check whether we need to start camera movement.
    if move!=0 && moving==0 then
      head=Camerafromy(posy,&channel,&side,&angle)
      if head<0 then                     // Error
        ;
      else
        opp=(illumination==0?(-1):Oppositecam(head))
        if opp>=0 then
          Oppositexycam(selected,posx,posy,opp,&oppx,&oppy)
        endif
        if $LAY.cameras!=0 then          // Dedicated cameras
          n=sprintf(s,"M%s %i(%g,%gA2) ",scmd,head,posx,posy)
          if opp>=0 n=n+sprintf(s+n,"%i(%g,%gA255) ",opp,oppx,oppy)
          sprintf(s+n,"NOP")
          SERV.Cmdimm(0,s)
          if opp>=0 then
            sprintf(s,"OUTPORT %i,0",0x2004+side)
            SERV.Cmdimm(32,s)
            sprintf(s,"OUTPORT %i,1",0x2004+1-side)
            SERV.Cmdimm(32,s)
          endif
        else                             // Head cameras
          n=sprintf(s,"M%s @%i[%g,%gA2] ",scmd,head,posx,posy)
          if opp>=0 n=n+sprintf(s+n,"%i(%g,%gA255H30) ",opp,oppx,oppy)
          for i=0,i<$LAY.nfing*2,i++ do
            if i==head || i==opp continue
            if ($LAY.headcameras & (1<<i))==0 continue
            n=n+sprintf(s+n,"%i(Z)",i)
          enddo
          sprintf(s+n,"NOP")
          SERV.Cmdimm(0,s)
          SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,3",opp<0?head:opp)
          SERV.Cmdimm(32,s)
        endif
        moving=1
        move=0
        updatevideo=1
      endif
    endif
    // Check whether movement is finished.
    if moving!=0 && $A[0].length>0 then
      moving=0
    endif
    // Check whether it's time to turn on video.
    if videoon==0 && showvideo!=0 then
      change hview position=-1,-1,LEFTX,LEFTY
      videoon=1
      updatevtext=1
    endif
    // Check whether we need to change displayed image.
    if videoon!=0 then
      if updatevtext then
        draw window=hlivevideo bkcolor=VIDEOFILL clear
        draw color=LIGHTRED font=LARGEFONT mode=M_CENTERED
        x=(LEFTX-10)/2; y=288/2
        if testersides==0x3 then
          draw at x,40 text=(side==0?"TOP":"BOTTOM")
        endif
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        updatevtext=0
      endif
      updatevideo=updatevideo|Bcupdate()
      if updatevideo then
        head=Camerafromy(posy,&channel,&side,&angle)
        Bcsetcam(channel)
        oppflash=Getoppflash(head)
        SYS.Videoangle(hlivevideo,channel|oppflash,side,                       \
          (testertype==TT_S3?0.2:0.5),                                         \
          Bcgetbri(channel),Bcgetctr(channel),2,angle)
        updatevideo=0
      endif
    endif
    wait
  enddo
  Bcdelete()
  return ret
end

// Calculates displacement of the opposite camera necessary for the perfect
// illumination (head coordinates) and, if necessary, adjusts brightness and
// contrast. Assumes that cut on the channel is already done. Parameters xfid
// and yfid are raw coordinates of the fiducial in camera pixels, relative to
// the center of the image. Returns 1 if brightness adjustment was done, 2 if
// opposite camera should be moved, 0 if position of the opposite camera is
// good enough and -1 on error.
function int Autoadjust(int head,int opp,int index,int y,                      \
  float xfid,float yfid,float angle,float *oppdx,float *oppdy)
  int i,j,d,n,adjust,videox,videoy,channel,qmin,qmax,ix,iy
  int hist[256],sum,nsum,quad[4]
  float rcheck,gradx,grady
  char buf[10201]
  if $LAY.cameras!=0 return -1         // Doesn't work with dedicated cameras
  adjust=0
  channel=Channelfromhead(head)
  if channel<0 return -1
  SYS.Videosize(channel,&videox,&videoy,&j)
  // Radius of the outer circle on the board is 1 mm. I check at the distance
  // 1.3 mm. If area is invisible, check is skipped.
  rcheck=1.3/headcamscale[head]
  if Abs(xfid)+rcheck>videox/2 || Abs(yfid)+rcheck>videoy/2                    \
    return -1                          // Check area may be invisible
  oppdx[0]=0.0
  oppdy[0]=0.0
  // Get brightness in 4 quadrants. Quadrants: 1 0
  //                                           2 3
  d=0.25/headcamscale[head]+1
  if d>50 d=50
  qmin=1000; qmax=-1000
  for i=0,i<4,i++ do
    ix=xfid+rcheck*Cos(angle+PI/4.0+PI/2.0*i)
    iy=yfid+rcheck*Sin(angle+PI/4.0+PI/2.0*i)
    n=SYS.Getvideo(channel,ix-d,ix+d+1,1,iy-d,iy+d+1,1,buf)
    Memset(hist,0,Sizeof(hist))
    for j=0,j<n,j++ do
      hist[buf[j]]++
    enddo
    sum=0; nsum=0
    // I take mean over the top 20% of the histogram. This should eliminate
    // fingerprints, dust and needle shades.
    for j=255,j>=0,j-- do
      sum=sum+hist[j]*j
      nsum=nsum+hist[j]
      if nsum*5>=n break
    enddo
    quad[i]=sum/nsum
    qmin=Min(qmin,quad[i])
    qmax=Max(qmax,quad[i])
  enddo
  if qmax>=255 && (brightness[head]>=(-95) || contrast[head]>=(-95)) then
    // Overexposed picture. Reduce amplification or exposition.
    if brightness[head]>contrast[head] then
      brightness[head]=brightness[head]-                                       \
        (qmin==255 && brightness[head]>(-70)?6:3)
      if hbrightness!=NULL change hbrightness select=brightness[head]
      adjust=1
    else
      contrast[head]=contrast[head]-                                           \
        (qmin==255 && contrast[head]>(-70)?6:3)
      if hcontrast!=NULL change hcontrast select=contrast[head]
      adjust=1
    endif
  else if qmax<=160 && (brightness[head]<=95 || contrast[head]<=95) then
    // Dark picture. Increase amplification or exposition.
    if brightness[head]<contrast[head] then
      brightness[head]=brightness[head]+3
      if hbrightness!=NULL change hbrightness select=brightness[head]
      adjust=1
    else
      contrast[head]=contrast[head]+3
      if hcontrast!=NULL change hcontrast select=contrast[head]
      adjust=1
    endif
  else
    // Calculate gradient.
    gradx=(quad[0]+quad[3]-quad[1]-quad[2])*Cos(angle)+                        \
      (quad[0]+quad[1]-quad[2]-quad[3])*Sin(angle)
    grady=(quad[0]+quad[1]-quad[2]-quad[3])*Cos(angle)-                        \
      (quad[0]+quad[3]-quad[1]-quad[2])*Sin(angle)
    if Abs(gradx)>25.0 || Abs(grady)>25.0 then
      // Inhomogeneous illumination, move opposite head.
      if $LAY.side[head/2]==0 then
        oppdx[0]=-gradx*0.005
        oppdy[0]=grady*0.005
      else
        oppdx[0]=gradx*0.005
        oppdy[0]=grady*0.005
      endif
      adjust=2
    endif
  endif
  return adjust
end

// Searches for the fiducial in the vicinity of the coordinates (posx,posy).
// Returns -1 if operator decided to interrupt the test, 1 if operator pressed
// the interrupt button, 2 if procedure was unable to define fiducial, 3 if
// fiducial was not found, 4 if camera was unable to reach the fiducial, 5 on
// timeout and 0 if fiducial was found correctly and posx and posy are assigned
// corrected coordinates.
function int Searchcross(handle hlivevideo,handle hinterrupt,int side,int pos, \
  float *posx,float *posy)
  int i,j,n,t,head,opp,channel,clip,attempts,nfound,oppflash,adjust,err
  int videox,videoy
  float x,y,dx,dy,angle,oppx,oppy,oppdx,oppdy,f
  float found[4][3],corrmax,bestx,besty
  char s[256]
  handle hfid[7]
  x=posx[0]; y=posy[0]
  pos=(pos!=0)
  attempts=8; err=0
  // Select camera on the specified side.
  head=Camerafromy(posy[0],&channel,&side,&angle)
  if head<0 return 4
  oppflash=Getoppflash(head)
  opp=(illumination==0 || testertype==TT_S3?(-1):Oppositecam(head))
  // Define fiducials.
  for j=0,j<7,j++ do                   // Different thickness (-25%,0,+25%)
    f=1.0+(j-3)*0.080
    hfid[j]=SYS.Syntmodel(channel,SYNT_LEFT,                                   \
      0.7/headcamscale[head],0.3*f/headcamscale[head],0.0,0.0,                 \
      (testertype==TT_S3?WHITEONBLACK:BLACKONWHITE))
    if j<=3 && hfid[j]==NULL err=2     // Unable to define fiducial
  enddo
  // Scan.
  SYS.Killimm(0)                       // Recover from previous scanning
  while (attempts>0 && err==0) do
    attempts--
    Anglefromy(head,y,&angle)
    SYS.Videoangle(hlivevideo,channel|oppflash,side,                           \
      (testertype==TT_S3?0.2:0.5),                                             \
      Bcgetbri(channel),Bcgetctr(channel),2,angle)
    if opp>=0 then
      Oppositexycam(pos,x,y,opp,&oppx,&oppy)
    endif
    // Move camera and back illumination into the coordinates. In case of head
    // cameras, all other heads must be moved away.
    if $LAY.cameras!=0 then            // Dedicated camera
      n=sprintf(s,"M%s %i(%g,%gA2) ",scmd,head,x,y)
      if opp>=0 n=n+sprintf(s+n,"%i(%g,%gA255) ",opp,oppx,oppy)
      sprintf(s+n,"NOP")
      SERV.Cmdimm(0,s)
      if opp>=0 then
        sprintf(s,"OUTPORT %i,0",0x2004+side )
        SERV.Cmdimm(32,s)
        sprintf(s,"OUTPORT %i,1",0x2004+1-side )
        SERV.Cmdimm(32,s)
      endif
      clip=0
    else                               // Head camera, move other heads away
      n=sprintf(s,"M%s @%i[%g,%gA2] ",scmd,head,x,y)
      if opp>=0 n=n+sprintf(s+n,"%i(%g,%gA255H30) ",opp,oppx,oppy)
      for i=0,i<$LAY.nfing*2,i++ do
        if i==head || i==opp continue
        if ($LAY.headcameras & (1<<i))==0 continue
        n=n+sprintf(s+n,"%i(Z)",i)
      enddo
      sprintf(s+n,"NOP")
      SERV.Cmdimm(0,s)
      SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
      sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,3",opp<0?head:opp)
      SERV.Cmdimm(32,s)
      clip=((head^side) & 1?1:-1)
    endif
    t=Time()
    while $A[0].length==0 && err==0 do
      if Pressed(hexit) err=-1         // Operator interrupted test
      if Pressed(hinterrupt) err=1
      if Time()-t>10000 err=5          // Timeout
      wait
    enddo
    if err!=0 break
    if $A[0].answer!=S_NOP then
      err=4; break
    endif
    delay 200                          // Some additional delay for camera
    SYS.Nextframe(channel)
    if Pressed(hexit) err=-1           // Operator interrupted test
    if Pressed(hinterrupt) err=1
    SYS.Videosize(channel,&videox,&videoy,&j)
    corrmax=0.0; bestx=0.0; besty=0.0
    for j=0,j<7,j++ do
      if hfid[j]==NULL continue
      nfound=SYS.Recognangle(hfid[j],0,0,videox,videoy,found,angle,0)
      if nfound==0 continue
      if found[0,2]>corrmax then
        bestx=found[0,0]
        besty=found[0,1]
        corrmax=found[0,2]
      endif
    enddo
    adjust=0
    // Check whether we need to adjust opposite illumination.
    if opp>=0 && autoadjust!=0 &&                                              \
      Abs(bestx-videox/2)<64 && Abs(besty-videoy/2)<64 then
      adjust=Autoadjust(head,opp,pos,y,bestx-videox/2,besty-videoy/2,angle,    \
        &oppdx,&oppdy)
      if adjust==2 then                // Request to move opposite camera
        oppdx=Max(-10.0,Min(oppdx+headthrudx[opp][pos],10.0))
        oppdy=Max(-10.0,Min(oppdy+headthrudy[opp][pos],10.0))
        if oppdx==headthrudx[opp][pos] && oppdy==headthrudy[opp][pos] then
          adjust=0
        else
          headthrudx[opp][pos]=oppdx
          headthrudy[opp][pos]=oppdy
        endif
      endif
      if adjust>0 then
        // Some adjustment was made, additional movement is necessary.
        attempts++
      endif
    endif
    dx=(bestx-videox/2)*headcamscale[head]
    dy=(besty-videoy/2)*headcamscale[head]
    // Offsets dx and dy are given in millimeters along the camera
    // axes. We must rotate them into the tester coordinates.
    x=x+(dx*Cos(angle)+dy*Sin(angle))*(side==0?1.0:-1.0)
    y=y-(dy*Cos(angle)-dx*Sin(angle))
    if Abs(dx)<0.05 && Abs(dy)<0.05 && adjust<=0 then
      posx[0]=x                        // Fiducial found exactly
      posy[0]=y
      break
    endif
  enddo
  if attempts<=0 err=3
  // Clean up and report result.
  for j=0,j<7,j++ do
    if hfid[j]!=NULL SYS.Deletemodel(hfid[j])
  enddo
  if err==0 then
    delay 1000                        // Let user see the cross
  endif
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
  endif
  return err
end

// Given board coordinates relative to its center, calculates tester
// coordinates using bilinear interpolation. Fiducials are 44 mm away fron the
// central cross.
function int Boardtotester(int side,float xboard,float yboard,                 \
  float *xtester,float *ytester)
  float r,x0,y0,x1,y1
  // Intermediate points on the bottom and top.
  r=(xboard+44.0)/88.0
  x0=xfid[side][0]*(1.0-r)+xfid[side][1]*r
  y0=yfid[side][0]*(1.0-r)+yfid[side][1]*r
  x1=xfid[side][3]*(1.0-r)+xfid[side][2]*r
  y1=yfid[side][3]*(1.0-r)+yfid[side][2]*r
  // Final point.
  r=(yboard+44.0)/88.0
  xtester[0]=x0*(1.0-r)+x1*r
  ytester[0]=y0*(1.0-r)+y1*r
end

// Given tester coordinates, calculates board coordinates.
function int Testertoboard(int side,float xtester,float ytester,               \
  float *xboard,float *yboard)
  int i
  float xb,yb,xt,yt
  // First approach.
  xb=xtester-(xfid[side][0]+xfid[side][1]+xfid[side][2]+xfid[side][3])*0.25
  yb=ytester-(yfid[side][0]+yfid[side][1]+yfid[side][2]+yfid[side][3])*0.25
  // 4 iterations should be more than sufficient.
  for i=0,i<4,i++ do
    Boardtotester(side,xb,yb,&xt,&yt)
    xb=xb+xtester-xt
    yb=yb+ytester-yt
  enddo
  xboard[0]=xb
  yboard[0]=yb
end

// Scans 4 fiducials on the accuracy test board. Returns -1 if operator
// interrupted test, 0 if all fiducials are found and 1 if operator decided to
// change board placement.
function int Scanboard()
  int i,x,y,n,head,side,result,err
  float cx,cy,dx,dy,xboard,yboard,xtester,ytester,ymin,ymax
  char s[256];
  handle hview,hlivevideo,hinterrupt,hok
  change hinfo limits=0,0
  change hinfo text="Scanning board..."
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Script will now scan 4 fiducials at the corners of the board. To "
  draw text="stop scanning and return to manual search, press " font=MAINFONT
  draw text="Interrupt" font=TIMESFONT text="."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="中断"
    help="按下可中断扫描并返回定位屏幕"
  endc
  clear hleft
  err=0
  // Video viewer.
  hview=control CHILD
    window=hleft
    position=-1,-1,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    bkcolor=VIDEOFILL
    help="相机的实时图像"
  endc
  x=(LEFTX-10)/2; y=288/2
  draw window=hlivevideo color=LIGHTRED
  draw at x-20,y to x-5,y at x+6,y to x+21,y
  draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
  draw show
  // Calculate expected coordinates of fiducials. I use following placement:
  // 3 2
  // 0 1
  cx=(pos1x+pos2x)/2.0; dx=(pos2x-pos1x)/2.0
  cy=(pos1y+pos2y)/2.0; dy=(pos2y-pos1y)/2.0
  xfid[0][0]=cx-dx; xfid[1][0]=cx-dx;
  yfid[0][0]=cy-dy; yfid[1][0]=cy-dy;
  xfid[0][1]=cx+dy; xfid[1][1]=cx+dy;
  yfid[0][1]=cy-dx; yfid[1][1]=cy-dx;
  xfid[0][2]=cx+dx; xfid[1][2]=cx+dx;
  yfid[0][2]=cy+dy; yfid[1][2]=cy+dy;
  xfid[0][3]=cx-dy; xfid[1][3]=cx-dy;
  yfid[0][3]=cy+dx; yfid[1][3]=cy+dx;
  // Scan fiducials.
  for side=0,side<2 && err==0,side++ do
    if (testersides & (1<<side))==0 continue
    for i=0,i<4,i++ do
      change hinfo limits=n,(testersides==0x3?8:4)
      n++
      err=Searchcross(hlivevideo,hinterrupt,side,i/2,xfid[side]+i,yfid[side]+i)
      if err!=0 break
    enddo
  enddo
  if err==0 then
    // Set board size.
    side=(testersides & 0x1?0:1)
    sprintf(s,"默认板 %g,%g,%g,%g",                                          \
      Min(xfid[side][0],xfid[side][3]),Min(yfid[side][0],yfid[side][1]),       \
      Max(xfid[side][1],xfid[side][2]),Max(yfid[side][2],yfid[side][3]))
    SERV.Cmdimm(32,s)
    // Check which heads may reach lines on the board.
    Memset(mayreach,0,Sizeof(mayreach))
    for head=0,head<$LAY.nfing*2,head++ do
      side=$LAY.side[head/2]
      ymin=1.0e99
      ymax=-1.0e99
      for i=0,i<4,i++ do
        xboard=(i & 0x1?44.0:(-44.0))
        yboard=(i & 0x2?44.0:(-44.0))
        Boardtotester(side,xboard,yboard,&xtester,&ytester)
        ymin=Min(ymin,ytester)
        ymax=Max(ymax,ytester)
        if ytester>=$LAY.bottom[head/2]/1000.0 &&                              \
          ytester<$LAY.top[head/2]/1000.0 then
          mayreach[head]=1
        endif
      enddo
      if mayreach[head]!=0 then
        safex[head]=(xfid[side][0]+xfid[side][2])/2.0
        if (head & 1)==0 then        // Left head
          safex[head]=safex[head]-60.0
          if safex[head]<$LAY.leftlimit/1000.0 then
            safex[head]=$LAY.leftlimit/1000.0
          endif
        else                         // Right head
          safex[head]=safex[head]+60.0
          if safex[head]>$LAY.rightlimit/1000.0 then
            safex[head]=$LAY.rightlimit/1000.0
          endif
        endif
        if $LAY.yoffset[head/2]/1000.0<(ymin+ymax)/2.0 then
          safey[head]=ymin
        else
          safey[head]=ymax
        endif
      endif
    enddo
    // Save coordinates of the fiducials.
    i=(testersides & 0x1?0:1)
    setini("Accuracy test","Fiducials","%g,%g,%g,%g",                          \
      xfid[i][0],yfid[i][0],xfid[i][2],yfid[i][2])
    return 0
  endif
  if err==1 return 1
  if err<0 return -1
  // Some error was detected, analyse and report to user.
  Drawboard(0)
  change hinfo name="扫描错误"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=LIGHTRED
  if err==2 then
    draw text="Unable to define fiducial."
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    draw text="This is probably an internal error, but you may try once "
    draw text="again. If this does not help, restart OllyTest. "
  else if err==3 then
    draw text="Unable to find fiducial."
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    draw text="Please check board position, adjust illumination and retry. "
  else if err==4 then
    draw text="Invalid answer from tester."
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    draw text="Check that tester is loaded and that board is placed inside "
    draw text="its working area. "
  else if err==5 then
    draw text="Timeout!"
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    draw text="There was no answer from tester within the expected timeout. "
    draw text="Please check the state of the tester and retry the search. "
  else
    draw text="Unable to scan the board!"
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
  endif
  draw text="Press " font=MAINFONT text="OK " font=TIMESFONT text="to continue."
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="确定"
    help="按下返回定位屏幕"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hok) break
    wait
  enddo
  return err
end

// Determines board type (EL100 or EL100-2) and sets variable boardtype.
// Returns 0 on success, 1 if operator wants to change board position and -1 if
// operator decided to interrupt the test.
function int Determinetype()
  int i,k,n,t,half,pad,side,h0,h1,err
  float xref,yref,xpad,ypad,x0,y0,x1,y1,r
  char s[256]
  handle htype1,htype2,hreplace,hbreak
  Drawboard(0)
  change hinfo limits=0,0
  change hinfo text="Determiming board type..."
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="There are two different boards: EL100 with relatively thick "
  draw text="lines and EL100-2 with minimal line width of only 2 micrometers. "
  draw text="Script will now determine the type of the installed board. "
  draw text="Please wait..."
  draw show
  err=0
  // To increase the reliability, I make all possible measurements. If even one
  // of them returns low resistance, I assume EL100-2.
  k=0
  for half=0,half<2,half++ do          // Left or right head
    if half==0 then
      xref=+47.0+Random(1.5)-0.75
      xpad=-47.0+Random(1.5)-0.75
    else
      xref=-47.0+Random(1.5)-0.75
      xpad=+47.0+Random(1.5)-0.75
    endif
    yref=Random(2.5)-1.25
    for pad=0,pad<2,pad++ do
      if pad==0 then
        ypad=-5.0+Random(1.5)-0.75
      else
        ypad=+5.0+Random(1.5)-0.75
      endif
      for side=0,side<2,side++ do
        if (testersides & (1<<side))==0 continue
        Boardtotester(side,xpad,ypad,&x0,&y0)
        h0=Headfromy(side,y0)
        Boardtotester(side,xref,yref,&x1,&y1)
        h1=Headfromy(side,y1)
        if h0<0 || h1<0 continue       // Reference is unreachable
        if h0/2==h1/2 then
          if x0<x1 then h1++; else h0++; endif
        endif
        n=sprintf(s,"M%s %i(%g,%gA2P%iV%iH%g) %i(%g,%gA2P%iV%iH%g) ",          \
          scmd,h0,x0,y0,strokep,strokev,strokez,                               \
          h1,x1,y1,strokep,strokev,strokez)
        // If embedded software supports resistance with current limit, use it
        // to reduce the probability of damage to the glass board.
        if (features & MF_RLIMCRATE)!=0 then
          sprintf(s+n,"R(%i,%i,IMAX=0.0003,LONG,SIMPLE,FREE)",h0,h1)
        else
          sprintf(s+n,"R(%i,%i)",h0,h1)
        endif
        // Two measurements for additional reliability.
        SERV.Cmdimm(k,s); k++
        SERV.Cmdimm(k,s); k++
      enddo
    enddo
  enddo
  if k==0 err=1                        // No measurements? Impossible...
  t=Time()
  while err==0 do
    for i=0,i<k,i++
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=k break                      // All answers came back
    if Pressed(hexit) return -1        // Operator interrupted test
    if Time()-t>12000 err=2            // No answer within 12 s timeout
    wait
  enddo
  if err==0 then
    for i=0,i<k,i++ do
      if $A[i].answer!=S_MOVE then
        err=3; break                   // Invalid answer
      else
        r=$A[i].r; if ($A[i].status & 0x0100) r=r*1.0e-6
        if r<1.0e7 then
          boardtype=1; break
        endif
      endif
    enddo
    if err==0 then
      if boardtype<0 boardtype=0
      return 0                         // Success
    endif
  endif
  // Unable to determine board type, ask operator.
  change hinfo text="Error determining board type"
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="The script was unable to determine type of the used board. "
  draw color=BLACK
  draw text="Please set board type manually. Minimal line width on EL100 is"
  draw text="5 um, on EL100-2 - 2 um."
  draw show
  htype1=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY-20,120,24
    name="EL100"
    help="按将产品类型设置为EL100"
  endc
  htype2=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY-20,120,24
    name="EL100-2"
    help="按将产品类型设置为EL100-2"
  endc
  hreplace=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY-20,120,24
    name="重放置"
    help="按下以更改板子位置"
  endc
  hbreak=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY-20,120,24
    name="放弃"
    help="关闭脚本"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(htype1) then
      boardtype=0
      return 0
    else if Pressed(htype2) then
      boardtype=1
      return 0
    else if Pressed(hreplace) then
      return 1
    else if Pressed(hbreak) then
      return -1
    endif
    wait
  enddo
end

// Given side (0..1), quadrant (0..3), wire (0..40) and width index (0..10),
// sets tester coordinates of the point and returns left head. On error,
// returns -1. Note that index 0 corresponds to the solid line.
function int Getcontact(int side,int quad,int wire,int index,float *x,float *y)
  int rail
  float r,xbase,ybase,xdir,ydir,xboard,yboard,xtester,ytester
  // Check input parameters.
  if (side!=0 && side!=1) || (testersides & (1<<side))==0  return -1
  if quad<0 || quad>3 || wire<0 || wire>=NWIRE ||                              \
    index<0 || index>=NINDEX return -1
  // Get base of the line relative to the center of the glass board and its
  // direction.
  if side==0 then
    if quad==0 then
      xbase=-1.0; ybase=-2.0-wire*1.0; xdir=-1.0; ydir=0.0
    else if quad==1 then
      xbase=+2.0+wire*1.0; ybase=-1.0; xdir=0.0; ydir=-1.0
    else if quad==2 then
      xbase=+1.0; ybase=+2.0+wire*1.0; xdir=+1.0; ydir=0.0
    else
      xbase=-2.0-wire*1.0; ybase=+1.0; xdir=0.0; ydir=+1.0
    endif
  else
    if quad==0 then
      xbase=-2.0-wire*1.0; ybase=-1.0; xdir=0.0; ydir=-1.0
    else if quad==1 then
      xbase=+1.0; ybase=-2.0-wire*1.0; xdir=+1.0; ydir=0.0
    else if quad==2 then
      xbase=+2.0+wire*1.0; ybase=+1.0; xdir=0.0; ydir=+1.0
    else
      xbase=-1.0; ybase=+2.0+wire*1.0; xdir=-1.0; ydir=0.0
    endif
  endif
  // Get point coordinates relative to the center of the glass board.
  if index==0 then
    r=-Random(1.5)-0.25
    if xdir==0.0 xbase=xbase+Random(1.0)-0.5
    if ydir==0.0 ybase=ybase+Random(1.0)-0.5
  else if index<NINDEX-1 then
    r=(index-1)*4.0+Random(3.5)+0.25
  else
    r=(index-1)*4.0+Random(4.5)+0.25
  endif
  xboard=xbase+r*xdir
  yboard=ybase+r*ydir
  // Convert to tester coordinates.
  Boardtotester(side,xboard,yboard,&xtester,&ytester)
  // Get left head that may reach these coordinates.
  for rail=0,rail<$LAY.nfing,rail++ do
    if $LAY.side[rail]!=side continue
    if $LAY.bottom[rail]/1000.0>ytester continue
    if $LAY.top[rail]/1000.0>ytester break
  enddo
  if rail<$LAY.nfing then
    x[0]=xtester
    y[0]=ytester
    return rail*2
  endif
  return -1
end

// Selects random point on the glass not coated by chrome. Returns 0 on success
// and -1 on error.
function int Getfreepoint(int head,float *x,float *y)
  int i,ix,iy,side
  float xb,yb,xt,yt,x0,y0,x1,y1
  if head<0 || head>=$LAY.nfing*2                                              \
    return -1                          // Error in input parameters
  side=$LAY.side[head/2]
  // Determine quadrant best reachable by the head.
  Boardtotester(side,0.0,0.0,&xt,&yt)
  if $LAY.yoffset[head/2]/1000.0<yt then
    // Take one of the bottom quadrants.
    if (head & 1)==0 then
      // Left head: take left bottom quadrant.
      x0=-41.0; y0=-41.0; x1=-1.0; y1=-1.0
    else
      // Right head: take right bottom quadrant.
      x0=1.0; y0=-41.0; x1=41.0; y1=-1.0
    endif
  else
    // Take one of the top quadrants.
    if (head & 1)==0 then
      // Left head: take left top quadrant.
      x0=-41.0; y0=1.0; x1=-1.0; y1=41.0
    else
      // Right head: take right top quadrant.
      x0=1.0; y0=1.0; x1=41.0; y1=41.0
    endif
  endif
  // No clean solution: it is possible that routine will fail even if there are
  // reachable points. Never mind.
  for i=0,i<50,i++ do
    ix=Random(NWIRE-1)
    iy=Random(NWIRE-1)
    xb=x0+0.5+ix*1.0
    yb=y0+0.5+iy*1.0
    Boardtotester(side,xb,yb,&xt,&yt)
    if yt>$LAY.bottom[head/2]/1000.0+1.0 && yt<$LAY.top[head/2]/1000.0-1.0 then
      x[0]=xt+Random(0.2)-0.1
      y[0]=yt+Random(0.2)-0.1
      return 0
    endif
  enddo
  return -1                            // Well, no point
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// ACCURACY TEST /////////////////////////////////

#define XSCALE         23              // Pixels per width index
#define YSCALE         100             // Full Y scale
#define XSTART         27
#define YSTART         135
#define YSTEP          145

// Paints accuracy histogram in the specified graphical window.
function int Paintaccuracy(handle hgraph,int showside,int showhalf,int curs)
  int i,j,n,nmax,y0,side,half
  char s[256]
  // Clear window.
  draw window=hgraph color=WHITE bkcolor=WHITE clear
  // Button comments.
  draw color=BLACK font=INFOFONT mode=M_CENTERED
  draw at 80,LEFTY-39 text="Side"
  draw at LEFTX/2+80,LEFTY-39 text="Heads"
  // For each direction.
  for i=0,i<2,i++ do
    y0=YSTART+YSTEP*i
    draw color=GRAY font=MEDIUMFONT mode=M_LEFT
    draw at XSTART+1,y0-YSCALE-5
    n=sprintf(s,"%s",(i==0?"X":"Y"))
    if showside!=0x3 || showhalf!=0x3 then
      if showside==0x1 then
        n=n+sprintf(s+n," top")
      else if showside==0x2 then
        n=n+sprintf(s+n,"%s",showhalf==0x3?" bottom":" bot")
      endif
      if showhalf==0x1 then
        n=n+sprintf(s+n," left")
      else if showhalf==0x2 then
        n=n+sprintf(s+n," right")
      endif
    endif
    draw text=s
    // Cursor.
    if cursor>=0 && curs!=0 then
      draw color=LIGHTGREEN bkcolor=LIGHTGREEN
      draw at XSTART+cursor*XSCALE,y0+12
      draw fillrect XSTART+(cursor+1)*XSCALE+1,y0-YSCALE-3
    endif
    // Statistics.
    if nastat>0 then
      draw color=BLUE bkcolor=BLUE
      for j=0,j<NINDEX,j++ do
        n=0; nmax=0
        for side=0,side<2,side++ do
          if (showside & (1<<side))==0 continue
          for half=0,half<2,half++ do
            if (showhalf & (1<<half))==0 continue
            n=n+astat[i,side,half,j]
            nmax=nmax+nastat
          enddo
        enddo
        if j==cursor && curs!=0 then
          draw font=MAINFONT color=BLACK mode=M_LEFT
          draw at XSTART+110,y0-YSCALE-6
          if j==0 then
            draw text="Chrome:"
          else
            draw text=format("%s um:",wtext[boardtype][j])
          endif
          draw at XSTART+175,y0-YSCALE-6
          if (use & (1<<j))==0 then
            draw text=" skipped"
          else
            draw text=format("%3i of %3i (%3i%%)",n,nmax,(n*100)/nmax)
          endif
        endif
        n=(YSCALE*n)/nmax
        if n==0 continue
        draw at XSTART+j*XSCALE+2,y0 fillrect XSTART+(j+1)*XSCALE-1,y0-n
      enddo
    endif
    // Contour.
    draw color=LIGHTGRAY at XSTART,y0-YSCALE to XSTART+NINDEX*XSCALE,y0-YSCALE
    draw to XSTART+NINDEX*XSCALE,y0
    // X axis.
    draw color=BLACK at XSTART,y0 to XSTART+NINDEX*XSCALE+8,y0
    draw font=SMALLFONT mode=M_CENTERED
    for j=0,j<=NINDEX,j++ do
      draw color=BLACK
      draw at XSTART+j*XSCALE,y0+3 to XSTART+j*XSCALE,y0
      if j<NINDEX then
        draw at XSTART+j*XSCALE+XSCALE/2,y0+13 text=wtext[boardtype][j]
      endif
    enddo
    draw color=BLACK at XSTART+NINDEX*XSCALE+10,y0+13 text="?
    // Y axis.
    draw at XSTART,y0 to XSTART,y0-YSCALE-8
    draw font=SMALLFONT mode=M_RIGHT
    for j=0,j<=4,j++ do
      draw at XSTART-3,y0-(j*YSCALE)/4 to XSTART,y0-(j*YSCALE)/4
      draw at XSTART-6,y0-(j*YSCALE)/4+4 text=format("%i",j*25)
    enddo
    draw at XSTART-6,y0-YSCALE-8 text="%"
  enddo
  draw show
end

// Processes mouse and button clicks in the graph window and redraws it if
// necessary or when force is 1. Call this function periodically with force=0
// whenever graph window is displayed.
function int Processaccuracy(int force)
  int i,j,y0,mousex,mousey,buttons
  // Check for mouse movements and set cursor.
  if Mousexy(hgraph,&mousex,&mousey,&buttons)==1 then
    for i=0,i<2,i++ do
      y0=YSTART+YSTEP*i
      if mousex>=XSTART && mousex<XSTART+NINDEX*XSCALE &&                      \
        mousey<=y0 && mousey>=y0-YSCALE                                        \
      then                                                                     \
        j=(mousex-XSTART)/XSCALE
        j=Max(0,Min(j,NINDEX-1))
        if j!=cursor then
          cursor=j
          force=1
        endif
      endif
    enddo
  endif
  // Check for buttons.
  if Pressed(htop) then
    showside=0x1; force=1
  else if Pressed(hbottom) then
    showside=0x2; force=1
  else if Pressed(htopbot) then
    showside=0x3; force=1
  endif
  if Pressed(hlside) then
    showhalf=0x1; force=1
  else if Pressed(hrside) then
    showhalf=0x2; force=1
  else if Pressed(hlrside) then
    showhalf=0x3; force=1
  endif
  // Check whether we need to redraw window.
  if force==0 return
  change htop color=(showside==0x1?LIGHTRED:BLACK)
  change htop bkcolor=(showside==0x1?YELLOW:LIGHTGRAY)
  change hbottom color=(showside==0x2?LIGHTRED:BLACK)
  change hbottom bkcolor=(showside==0x2?YELLOW:LIGHTGRAY)
  change htopbot color=(showside==0x3?LIGHTRED:BLACK)
  change htopbot bkcolor=(showside==0x3?YELLOW:LIGHTGRAY)
  change hlside color=(showhalf==0x1?LIGHTRED:BLACK)
  change hlside bkcolor=(showhalf==0x1?YELLOW:LIGHTGRAY)
  change hrside color=(showhalf==0x2?LIGHTRED:BLACK)
  change hrside bkcolor=(showhalf==0x2?YELLOW:LIGHTGRAY)
  change hlrside color=(showhalf==0x3?LIGHTRED:BLACK)
  change hlrside bkcolor=(showhalf==0x3?YELLOW:LIGHTGRAY)
  // Draw histogram.
  Paintaccuracy(hgraph,showside,showhalf,1)
end

// Runs accuracy test. Returns -1 if operator interrupted test and 0 in any
// other case.
function int Accuracytest()
  int i,j,m,n,t,dt,dir,newv,newp,newloop,redraw,h,head[2],ref1[2],ref2[2],err
  int hlist[2][2],half,nrealloop,loop,nrealwire,wire,quad,index,busy[32]
  int side,tstep,texp,percent[NINDEX],badacc
  float r,r1,r2,c,c1,c2,xboard1,xboard2,yboard,x[2],y[2]
  float xref1[2],yref1[2],xref2[2],yref2[2],acclimit
  float bestacc,done
  char s[256]
  handle huse[NINDEX],hvelo,hvscr,hpres,hpscr,hfast,husec,hloop,hlscr
  handle hcomment,hrun,hskip,hremain,hcancel
  use=0x07FF
  getini("Accuracy test","Settings","%i",&use)
  if use==0 use=0x07FF
repeat:
  change hinfo limits=0,0
  change hinfo text="Start test"
  clear hleft
  showside=testersides
  showhalf=0x3
  cursor=-1
  hgraph=control GRAPH
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BLACK
    bkcolor=WHITE
  endc
  htop=control BUTTON
    window=hgraph
    position=15,LEFTY-33,40,21
    name="正面"
    help="按下以显示上部的统计信息"
    font=SMALLFONT
    color=BLACK
    bkcolor=LIGHTGRAY
  endc
  if (testersides & 0x1)==0 disable htop
  hbottom=control BUTTON
    window=hgraph
    position=60,LEFTY-33,40,21
    name="背面"
    help="按下以显示底部的统计信息"
    font=SMALLFONT
    color=BLACK
    bkcolor=LIGHTGRAY
  endc
  if (testersides & 0x2)==0 disable hbottom
  htopbot=control BUTTON
    window=hgraph
    position=105,LEFTY-33,40,21
    name="两面"
    help="按下以显示双方的均值统计"
    font=SMALLFONT
    color=BLACK
    bkcolor=LIGHTGRAY
  endc
  if testersides!=0x3 disable htopbot
  hlside=control BUTTON
    window=hgraph
    position=LEFTX/2+15,LEFTY-33,40,21
    name="左"
    help="按下以显示左边测试头的统计信息"
    font=SMALLFONT
    color=BLACK
    bkcolor=LIGHTGRAY
  endc
  hrside=control BUTTON
    window=hgraph
    position=LEFTX/2+60,LEFTY-33,40,21
    name="右"
    help="按下以显示右边测试头的统计信息"
    font=SMALLFONT
    color=BLACK
    bkcolor=LIGHTGRAY
  endc
  hlrside=control BUTTON
    window=hgraph
    position=LEFTX/2+105,LEFTY-33,40,21
    name="两面"
    help="按下以显示左右头的均值统计"
    font=SMALLFONT
    color=BLACK
    bkcolor=LIGHTGRAY
  endc
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please set widthes and test options and press " font=MAINFONT
  draw text="Run " font=TIMESFONT text="to verify accuracy. Avoid high stroke "
  draw text="- it reduces the lifespan of the glass board!"
  for i=0,i<NINDEX,i++ do
    huse[i]=control CHECKBOX
      window=hright
      position=17,78+i*17,45,16
      name=wtext[boardtype][i]
      help=format("检查允许在宽度%s 上的接触",wtext[boardtype][i])
      font=INFOFONT
      mode=(use & (1<<i))==0?0:M_CHECKED
    endc
  enddo
  draw at 80,98 font=INFOFONT text="Stroke"
  hvelo=control TEXT
    window=hright
    position=144,79,45,24
    help="指定Z方向下降速度，单位为毫米/秒"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hvscr=control VSCROLL
    window=hright
    position=189,79,20,24
    help="按下以更改Z方向速度"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 217,98 text="mm/s"
  draw at 80,128 text="Pressure"
  hpres=control TEXT
    window=hright
    position=144,109,45,24
    help=" 指定Z方向压力，内部单位"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hpscr=control VSCROLL
    window=hright
    position=189,109,20,24
    help="按下以更改Z方向压力"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 217,128 text="i.u."
  if testersides==0x03 || ($EXTLAY.extant & 0x1)!=0 then
    hfast=control CHECKBOX
      window=hright
      position=80,140,60,20
      name="快速"
      help="每个仅测试4行"
      font=INFOFONT
      mode=(fasttest?M_CHECKED:0)
    endc
    husec=control CHECKBOX
      window=hright
      position=144,140,100,20
      name="使用电容"
      help="防止镀铬线烧坏"
      font=INFOFONT
      mode=(usec?M_CHECKED:0)
    endc
  else
    hfast=control CHECKBOX
      window=hright
      position=144,140,120,20
      name="Fast verification"
      help="每个仅测试4行"
      font=INFOFONT
      mode=(fasttest?M_CHECKED:0)
    endc
    husec=NULL
    usec=0
  endif
  draw at 80,185 text="Loops"
  hloop=control TEXT
    window=hright
    position=144,166,45,24
    help="指定测试循环数"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hlscr=control VSCROLL
    window=hright
    position=189,166,20,24
    help="按下更改测试循环数"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 80,210 text="Comment:"
  hcomment=control EDIT
    window=hright
    position=72,212,185,78
    help="在这里您可以输入您的评论"
    text=comment
    font=TIMESFONT
    mode=M_BORDER|M_VSCROLL
  endc
  if rtfok==0 disable hcomment
  hrun=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+19,120,24
    name="运行"
    help="按下即可进行准确性测试"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+19,120,24
    name="回到菜单"
    help="按下可返回主菜单"
  endc
  draw show
  Processaccuracy(1)
  newv=strokev
  newp=strokep
  newloop=nloop
  redraw=1
  while 1 do
    Processaccuracy(0)
    if Pressed(hexit) then
      return -1
    else if Pressed(hvscr) then
      newv=newv+Status(hvscr)*5; change hvscr select=0
      redraw=1
    else if Pressed(hpscr) then
      newp=newp+Status(hpscr)*5; change hpscr select=0
      redraw=1
    else if Pressed(hfast) then
      fasttest=Status(hfast)
      redraw=1
    else if husec!=NULL && Pressed(husec) then
      usec=Status(husec)
    else if Pressed(hlscr) then
      newloop=newloop+Status(hlscr); change hlscr select=0
      redraw=1
    else if Pressed(hcancel) then
      return 0
    else if Pressed(hrun) then
      break
    endif
    if redraw then
      newv=Max(5,Min(newv,30))
      newp=Max(10,Min(newp,100))
      newloop=Max(1,Min(newloop,10))
      change hvelo text=format(" %i",newv)
      change hvelo bkcolor=(newv<=20?WHITE:PINK)
      change hpres text=format(" %i",newp)
      if fasttest then
        change hloop bkcolor=LIGHTGRAY
        disable hlscr
      else
        change hloop bkcolor=WHITE
        enable hlscr
      endif
      change hloop text=format(" %i",(fasttest?1:newloop))
      strokev=newv
      strokep=newp
      nloop=newloop
      redraw=0
    endif
    wait
  enddo
  for i=0,i<NINDEX,i++ do
    if Status(huse[i])!=0 then
      use=use | (1<<i)
    else
      use=use & (~(1<<i))
    endif
  enddo
  // Based on the tester type, determine the required accuracy (>=90% contacts).
  if testertype==TT_S3 then
    acclimit=10.0
  else if testertype==TT_S1 || testertype==TT_S2 then
    acclimit=20.0
  else if testertype==TT_A7 || testertype==TT_A8 then
    acclimit=35.0
  else if testertype==TT_A6 then
    acclimit=75.0
  else
    acclimit=100.0
  endif
  // Clean needles by contacting glass between the lines for 15 seconds and
  // then letting needles to rest for 5 seconds.
  change hinfo text="Cleaning needles"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Script will attempt to clean the needles by contacting glass "
  draw text="between the chrome lines. This will take 20 seconds."
  draw show
  hskip=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY,120,24
    name="跳过"
    help="按下可跳过清洁步骤"
  endc
  t=Time()
  Memset(busy,0,Sizeof(busy))
  j=-1
  while Time()-t<15000 do
    m=(Time()-t)/1000
    if m!=j then
      change hinfo limits=m,20
      j=m
    endif
    for i=0,i<$LAY.nfing*2,i++ do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Pressed(hskip) t=t-20000
      if busy[i]!=0 && $A[i].length!=0 then
        busy[i]=0
      endif
      if busy[i]==0 then
        if Getfreepoint(i,&r,&c)!=0 continue
        sprintf(s,"M%s %i(%g,%gA20V%iP%i) DLY(5)",scmd,i,r,c,                  \
          Min(strokev+40,100),Min(strokep+40,100))
        SERV.Cmdimm(i,s)
        busy[i]=1
      endif
    enddo
    wait
  enddo
  for i=0,i<$LAY.nfing*2,i++ do
    SYS.Killimm(i)
    sprintf(s,"M %i(Z) NOP",i)
    SERV.Cmdimm(32,s)
  enddo
  // Rest now.
  while Time()-t<20000 do
    m=(Time()-t)/1000
    if m!=j then
      change hinfo limits=m,20
      j=m
    endif
    if Pressed(hexit) return -1        // Button "Exit" works as interrupt
    if Pressed(hskip) t=t-20000
    wait
  enddo
  // Run test.
  Text(hcomment,comment)
  setini("Accuracy test","Settings","%i",use)
  change hinfo text="Verifying accuracy"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Test is running. Please be patient. To stop it, press "
  draw font=MAINFONT text="Interrupt" font=TIMESFONT text="."
  draw show
  hremain=control GRAPH                // To avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,105,200,60
    help="直到结束的测试的持续时间和估计的时间"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY,120,24
    name="中断"
    help="按下中断精度测试"
  endc
  Memset(astat,0,Sizeof(astat))
  Memset(hlist,0,Sizeof(hlist))
  nastat=0
  Processaccuracy(1)
  err=0
  tstep=Time(); texp=-1000000
  nrealloop=(fasttest?1:nloop)
  nrealwire=0
  for wire=0,wire<NWIRE,wire++ do
    if fasttest!=0 && (wire%4)!=0 continue
    nrealwire++
  enddo
  // Loop.
  for loop=0,loop<nrealloop && err==0,loop++ do
    nastat=(loop+1)*2*nrealwire
    if usec==0 then                    // Standard resistive measurements
      // Left or right head.
      for half=0,half<2 && err==0,half++ do
        // Select reference heads and points. They will not move afterwards.
        if half==0 then
          xboard1=+47.0+Random(1.5)-0.75
        else
          xboard1=-47.0+Random(1.5)-0.75
        endif
        yboard=Random(2.5)-1.25
        for side=0,side<2,side++ do
          if (testersides & (1<<side))==0 continue
          Boardtotester(side,xboard1,yboard,xref1+side,yref1+side)
          h=Headfromy(side,yref1[side])
          if h<0 err=1                 // Reference is unreachable
          ref1[side]=h+(1-half)
        enddo
        // Line width.
        for index=0,index<NINDEX && err==0,index++ do
          if (use & (1<<index))==0 continue
          // Quadrant.
          for quad=0,quad<4 && err==0,quad++ do
            // Wire.
            for wire=0,wire<NWIRE && err==0,wire++ do
              if fasttest!=0 && (wire%4)!=0 continue
              n=(((loop*2+half)*NINDEX+index)*4+quad)*NWIRE+wire
              change hinfo limits=n,nrealloop*2*NINDEX*4*NWIRE
              done=(100.0*n)/(nrealloop*2*NINDEX*4*NWIRE)
              // Select test heads and points.
              for side=0,side<2,side++ do
                if (testersides & (1<<side))==0 continue
                head[side]=Getcontact(side,quad,wire,index,x+side,y+side)
                if head[side]<0 then
                  err=2; break
                endif
                head[side]=head[side]+half
                hlist[side][half]=hlist[side][half]|(1<<head[side])
                n=sprintf(s,"M%s %i(%g,%gA2P%iV%iH%g) %i(%g,%gP%iV%i) ",       \
                  scmd,head[side],x[side],y[side],strokep,strokev,strokez,     \
                  ref1[side],xref1[side],yref1[side],Max(strokep,50),strokev)
                // I move heads that don't participate in measurement into the
                // safe positions.
                for h=0,h<$LAY.nfing*2,h++ do
                  if $LAY.side[h/2]!=side continue
                  if h==head[side] || h==ref1[side] continue
                  if mayreach[h]==0 continue
                  n=n+sprintf(s+n,"%i(%g,%gh99) ",h,safex[h],safey[h])
                enddo
                // If embedded software supports resistance with current limit,
                // use it to reduce the probability of damage to the glass
                // board.
                if (features & MF_RLIMCRATE)!=0 then
                  sprintf(s+n,"R(%i,%i,IMAX=0.0003,LONG,SIMPLE,FREE)",         \
                  head[side],ref1[side])
                else
                  sprintf(s+n,"R(%i,%i)",head[side],ref1[side])
                endif
                // For a bit better reliability, send two measurements at once.
                SYS.Killimm(side)
                SYS.Killimm(side+2)
                if SERV.Cmdimm(side,s)<0 then
                  // Old SERV.SCR does not support M_RLIM, roll back to
                  // standard measurement.
                  sprintf(s+n,"R(%i,%i)",head[side],ref1[side])
                  SERV.Cmdimm(side,s)
                endif
                SERV.Cmdimm(side+2,s)
              enddo
              // Wait for answers.
              t=Time()
              while err==0 do
                if Pressed(hexit) err=-1
                if Pressed(hcancel) err=3
                for side=0,side<2,side++ do
                  if (testersides & (1<<side))==0 continue
                  if $A[side].length==0 || $A[side+2].length==0 break
                enddo
                if side>=2 break
                Processaccuracy(0)
                wait
              enddo
              if err!=0 break
              // Process answers.
              for side=0,side<2,side++ do
                if (testersides & (1<<side))==0 continue
                if $A[side].answer!=S_MOVE || $A[side+2].answer!=S_MOVE then
                  err=4; break
                endif
                r1=$A[side].r; if ($A[side].status & 0x0100) r1=r1*1.0e-6
                r2=$A[side+2].r; if ($A[side+2].status & 0x0100) r2=r2*1.0e-6

                //CHECK FOR BAD MEASUREMENTS???

                r=Min(r1,r2)
                // Threshold is arbitrarily set to 10 MOhm.
                if r<1.0e7 then
                  if ((quad^side) & 0x1)==0 then
                    astat[1][side][half][index]++
                  else
                    astat[0][side][half][index]++
                  endif
                endif
              enddo
              // Update statistics.
              dt=Time()-tstep
              if (done>5.0 && dt>30000) || done>15.0 then
                t=dt*(100.0-done)/done
                if t<texp-500 || t>texp+10000 texp=t
              endif
              clear hremain
              draw window=hremain
              t=Time()-tstep+500
              draw at 8,27 color=RED text="Test time:"
              draw at 120,27 text=format("%2im %02is",t/60000,(t/1000)%60)
              draw at 8,52 text="Remains:"
              if texp<0 then
                draw at 120,52 color=DARKGRAY text=" ?"
              else
                draw at 120,52 color=RED
                draw text=format("%2im %02is",texp/60000,(texp/1000)%60)
              endif
              draw show
              Processaccuracy(1)
            enddo
          enddo
        enddo
      enddo
    else                               // Capacitive measurements
      // Top or bottom side. Assumes testersides==0x3 or presence of external
      // antenna.
      for side=0,side<2,side++ do
        if (testersides & (1<<side))==0 continue
        if testersides==0x03 then
          // Select reference heads and points. They will not move afterwards.
          xboard1=-47.0+Random(1.5)-0.75
          xboard2=+47.0+Random(1.5)-0.75
          yboard=Random(2.5)-1.25
          Boardtotester(1-side,xboard1,yboard,xref1+side,yref1+side)
          Boardtotester(1-side,xboard2,yboard,xref2+side,yref2+side)
          h=Headfromy(1-side,yref1[side])
          if h<0 err=1                 // Reference is unreachable
          ref1[side]=h
          h=Headfromy(1-side,yref2[side])
          if h<0 err=1                 // Reference is unreachable
          ref2[side]=h+1
        else
          ref1[side]=-1
          ref2[side]=-1
        endif
        // Left or right head.
        for half=0,half<2 && err==0,half++ do
          // Line width.
          for index=0,index<NINDEX && err==0,index++ do
            if (use & (1<<index))==0 continue
            // Quadrant.
            for quad=0,quad<4 && err==0,quad++ do
              // Wire.
              for wire=0,wire<NWIRE && err==0,wire++ do
                if fasttest!=0 && (wire%4)!=0 continue
                n=((((loop*2+side)*2+half)*NINDEX+index)*4+quad)*NWIRE+wire
                change hinfo limits=n,                                         \
                  nrealloop*(testersides==0x03?2:1)*2*NINDEX*4*NWIRE
                done=(100.0*n)/(nrealloop*2*2*NINDEX*4*NWIRE)
                // Select test head and points. Indexing of head[] is of course
                // not necessary, I just leave it identical to the code above.
                head[side]=Getcontact(side,quad,wire,index,x+side,y+side)
                if head[side]<0 then
                  err=2; break
                endif
                head[side]=head[side]+half
                hlist[side][half]=hlist[side][half]|(1<<head[side])
                n=sprintf(s,"M%s %i(%g,%gA2P%iV%iH%g)",                        \
                  scmd,head[side],x[side],y[side],strokep,strokev,strokez)
                if testersides==0x03 then
                  n=n+sprintf(s+n," %i(%g,%gP%iV%i) %i(%g,%gP%iV%i)",          \
                  ref1[side],xref1[side],yref1[side],Max(strokep,50),strokev,  \
                  ref2[side],xref2[side],yref2[side],Max(strokep,50),strokev)
                endif
                // I move heads that don't participate in measurement into the
                // safe positions.
                for h=0,h<$LAY.nfing*2,h++ do
                  if h==head[side] || h==ref1[side] || h==ref2[side] continue
                  if mayreach[h]==0 continue
                  n=n+sprintf(s+n,"%i(%g,%gh99) ",h,safex[h],safey[h])
                enddo
                if testersides==0x03 then
                  sprintf(s+n," UC(%i,%i,%i,N,U=8.0,F=2000,SIMPLE)",           \
                  head[side],ref1[side],ref2[side])
                else
                  sprintf(s+n," UC(%i,32,N,U=8.0,F=2000,SIMPLE)",head[side])
                endif
                // For a bit better reliability, send two measurements at once.
                // Note that older versions of SERV.SCR do not support SIMPLE.
                if SERV.Cmdimm(0,s)>=0 then
                  SERV.Cmdimm(1,s)
                else if testersides==0x03 then
                  sprintf(s+n," UC(%i,%i,%i,N,U=8.0,F=2000)",                  \
                    head[side],ref1[side],ref2[side])
                  SERV.Cmdimm(0,s)
                  SERV.Cmdimm(1,s)
                else
                  sprintf(s+n," UC(%i,32,N,U=8.0,F=2000)",head[side])
                  SERV.Cmdimm(0,s)
                  SERV.Cmdimm(1,s)
                endif
                // Wait for answers.
                t=Time()
                while err==0 do
                  if Pressed(hexit) err=-1
                  if Pressed(hcancel) err=3
                  if $A[0].length>0 && $A[1].length>0 break
                  Processaccuracy(0)
                  wait
                enddo
                if err!=0 break
                // Process answers.
                if $A[0].answer!=S_MOVE || $A[1].answer!=S_MOVE then
                  err=4; break
                endif
                if $A[0].status & 0x8000 then
                  c1=0.0
                else
                  c1=$float4($A[0]+10) // Picofarades
                endif
                if $A[1].status & 0x8000 then
                  c2=0.0
                else
                  c2=$float4($A[1]+10)
                endif
                c=Max(c1,c2)
                // Threshold is arbitrarily set to 1 pF.
                if c>=1.0 then
                  if ((quad^side) & 0x1)==0 then
                    astat[1][side][half][index]++
                  else
                    astat[0][side][half][index]++
                  endif
                endif
                Processaccuracy(1)
              enddo
              // Update statistics.
              dt=Time()-tstep
              if (done>5.0 && dt>30000) || done>15.0 then
                t=dt*(100.0-done)/done
                if t<texp-500 || t>texp+10000 texp=t
              endif
              clear hremain
              draw window=hremain
              t=Time()-tstep+500
              draw at 8,27 color=RED text="Test time:"
              draw at 120,27 text=format("%2im %02is",t/60000,(t/1000)%60)
              draw at 8,52 text="Remains:"
              if texp<0 then
                draw at 120,52 color=DARKGRAY text=" ?"
              else
                draw at 120,52 color=RED
                draw text=format("%2im %02is",texp/60000,(texp/1000)%60)
              endif
              draw show
            enddo
          enddo
        enddo
      enddo
    endif
  enddo
  // Move all heads in home position.
  for i=0,i<$LAY.nfing,i++
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,s)
    SYS.Killimm(i)
  enddo
  if err<0 return -1
  if err==0 natest++
  // Test finished.
  if err==0 && rtfok!=0 then
    // Write results to the protocol file.
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddfmt("\nResults of accuracy test #%i",natest)
    // Show placement and parameters.
    RFmt(RTF_TIMES,RTF_NORMAL,10)
    RTable(RTF_LEFT|RTF_NOBORDER|RTF_THINSP,0.0,6.0)
    RCell(RTF_CENTERED,70.0)
    RAddtext("\n")
    Showboardplacement()
    RCell(RTF_LEFT,89.0)
    RAddfmt("\nPosition\t\t(%.1f,%.1f)\n",(pos1x+pos2x)/2,(pos1y+pos2y)/2)
    RAddfmt("Pressure\t\t%.1f i.u.\nStroke\t\t%.1f mm/s\nHeight\t\t%.1f mm\n", \
      strokep,strokev,strokez)
    RAddfmt("Loops\t\t%i\n",nrealloop)
    RAddfmt("Contacts\t\t%i per side and direction\n",nastat)
    RAddfmt("Expecting\t90%% at %g um accuracy\n\n",acclimit)
    if comment[0]!='\0' then
      RFmt(RTF_TIMES,RTF_BOLD,10)
      RAddtext(comment)
    endif
    REndtable()
    // Show statistics as a table.
    for dir=0,dir<2,dir++ do
      RFmt(RTF_TIMES,RTF_BOLD,12)
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      if dir==0 then
        RAddtext("\nHorizontal (X) accuracy")
      else
        RAddtext("\nVertical (Y) accuracy")
      endif
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RAddtext("\n")
      RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP|RTF_KEEPNEXT,0.0,6.0)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,16.5)
      RAddtext("Heads")
      for index=0,index<NINDEX,index++ do
        RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,11.5)
        RAddtext(wtext[boardtype][index])
      enddo
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,16.0)
      RAddtext("Result")
      for h=0,h<=4,h++ do              // h=4: total statistics
        if h<4 && (testersides & (1<<(h/2)))==0 continue
        RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP|RTF_KEEPNEXT,0.0,5.0)
        RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,16.5)
        if h==4 then
          RAddtext("All")
        else
          n=0
          for i=0,i<32,i++ do
            if (hlist[h/2][h%2] & (1<<i))==0 continue
            if n>0 n=n+sprintf(s+n,", ")
            n=n+sprintf(s+n,"%i%s",i/2,i& 1?"R":"L")
          enddo
          RAddtext(s)
        endif
        for index=0,index<NINDEX,index++ do
          RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,11.5)
          if (use & (1<<index))==0 continue
          if h<4 then
            m=astat[dir][h/2][h%2][index]
            n=nastat
          else
            m=astat[dir][0,0][index]+astat[dir][0,1][index]+                   \
              astat[dir][1,0][index]+astat[dir][1,1][index]
            if testersides==0x03 then
              n=nastat*4
            else
              n=nastat*2
            endif
          endif
          percent[index]=(m*100)/n
          if percent[index]<90 && width[boardtype][index]>=acclimit then
            RFmt(RTF_TIMES,RTF_BOLD,9)
          else
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
          RAddfmt("%i\n%i%%",m,percent[index])
        enddo
        RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,16.0)
        // Determine reached accuracy at 90% limit.
        badacc=0
        bestacc=width[boardtype][0]
        for index=NINDEX-1,index>0,index-- do
          if (use & (1<<index))==0 continue
          if percent[index]>=90 then
            bestacc=width[boardtype][index]
            break
          else if width[boardtype][index]>=acclimit then
            badacc=1
          endif
        enddo
        if badacc then
          RFmt(RTF_TIMES,RTF_BOLD,9)
        else
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
        RAddfmt("%g um",bestacc)
      enddo
      REndtable()
    enddo
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RAddtext("\n")
    RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP|RTF_KEEPNEXT,0.0,5.0)
    RFmt(RTF_ARIAL,RTF_NORMAL,15)
    for h=0,h<4,h++ do
      if (testersides & (1<<(h/2)))==0 continue
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,39.75)
      n=0
      for i=0,i<32,i++ do
        if (hlist[h/2][h%2] & (1<<i))==0 continue
        if n>0 n=n+sprintf(s+n,", ")
        n=n+sprintf(s+n,"%i%s",i/2,i& 1?"R":"L")
      enddo
      sprintf(s+n,"\n")
      RAddtext(s)
      Paintaccuracy(htemp,1<<(h/2),1<<(h%2),0)
      RAddpiczoom(htemp,0,0,LEFTX,300,0,0.45)
    enddo
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    REndtable()
  endif
  if err==0 then
    change hinfo text="Test finished"
  else
    change hinfo text="Test cancelled"
  endif
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=(err==0 || err==3?BLACK:LIGHTRED)
  if err==0 then
    draw text="Test is finished. Please check the results. Move mouse pointer "
    draw text="over the graphs to get precise values."
  else if err==1 || err==2 then
    draw text="Some points are unreachable!"
    draw at 6,60 color=BLACK
    draw text="You may try to change board position and repeat test."
  else if err==3 then
    draw text="Test was cancelled by user."
  else if err==4 then
    draw text="Invalid answer from tester!"
    draw at 6,60 color=BLACK
    draw text="Please check that tester is loaded."
  else
    draw text="Unknown error!"
    draw at 6,60 color=BLACK
    draw text="This error is not expected. Please report it to atg."
  endif
  draw show
  hrun=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="重复"
    help="按下可以重复测试"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="回到菜单"
    help="按下可返回主菜单"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hrun) then
      goto repeat
    else if Pressed(hcancel) then
      return 0
    endif
    Processaccuracy(0)
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// HISTOGRAM TEST ////////////////////////////////

#define HSCALE         4               // Pixels per histogram index
#define NSTEP          8               // Number of possible accuracy steps

// Paints histogram in the specified graphical window.
function int Painthistogram(handle hgraph,int showside,int showhalf)
  int i,j,n,hand,x0,y0,sidehead
  sidehead=(showside & 1?0:2)+(showhalf & 1?0:1)
  // Clear window.
  draw window=hgraph color=WHITE bkcolor=WHITE clear
  // Head.
  draw color=DARKGRAY font=MEDIUMFONT mode=M_CENTERED at LEFTX/2,LEFTY-45
  draw text=format("%i%s",showside & 1?railtop:railbot,showhalf & 1?"L":"R")
  // For each direction.
  for i=0,i<2,i++ do
    y0=YSTART+YSTEP*i
    // For each hand.
    for hand=0,hand<2,hand++ do
      x0=XSTART+LEFTX/2*hand
      draw color=GRAY font=MEDIUMFONT mode=M_LEFT
      draw at x0,y0-YSCALE-7
      if i==0 && hand==0 then
        draw text="Left"
      else if i==0 && hand==1 then
        draw text="Right"
      else if i==1 && hand==0 then
        draw text="Bot"
      else if i==1 && hand==1 then
        draw text="Top"
      endif
      // Cursor and data.
      if nhstat>0 && cursor>=0 then
        draw color=LIGHTGREEN bkcolor=LIGHTGREEN
        draw at x0+cursor*HSCALE,y0+12
        draw fillrect x0+(cursor+1)*HSCALE+1,y0-YSCALE-3
        draw color=BLACK font=SMALLFONT mode=M_RIGHT
        draw at x0+NHIST*HSCALE,y0-YSCALE-6
        draw text=format("%g um: %2i/%i",                                      \
        (cursor-NHIST/2)*histstep,hstat[i][sidehead][hand][cursor],nhstat)
      endif
      // Statistics.
      if nhstat>0 then
        draw color=BLUE bkcolor=BLUE
        for j=0,j<NHIST,j++ do
          n=(hstat[i][sidehead][hand][j]*YSCALE)/nhstat
          draw at x0+j*HSCALE+1,y0 fillrect x0+(j+1)*HSCALE,y0-n
        enddo
      endif
      // Contour.
      draw color=LIGHTGRAY at x0,y0-YSCALE to x0+NHIST*HSCALE,y0-YSCALE
      draw to x0+NHIST*HSCALE,y0
      // X axis.
      draw color=BLACK at x0,y0 to x0+NHIST*HSCALE+8,y0
      draw font=SMALLFONT mode=M_CENTERED
      for j=0,j<=NHIST,j++ do
        draw at x0+j*HSCALE,y0+3 to x0+j*HSCALE,y0
      enddo
      for j=-(NHIST/2),j<=(NHIST/2),j=j+NHIST/2 do
        draw at x0+(j+NHIST/2)*HSCALE+HSCALE/2,y0+15
        draw text=format("%g",j*histstep)
      enddo
      draw at x0+NHIST*HSCALE+7,y0+15 text="?
      // Y axis.
      draw at x0,y0 to x0,y0-YSCALE-8
      draw font=SMALLFONT mode=M_RIGHT
      for j=0,j<=4,j++ do
        draw at x0-3,y0-(j*YSCALE)/4 to x0,y0-(j*YSCALE)/4
        draw at x0-6,y0-(j*YSCALE)/4+4 text=format("%i",j*25)
      enddo
      draw at x0-6,y0-YSCALE-8 text="%"
    enddo
  enddo
  draw show
end

// Processes mouse and button clicks in the graph window and redraws it if
// necessary or when force is 1. Call this function periodically with force=0
// whenever graph window is displayed.
function int Processhistogram(int force)
  int i,j,hand,x0,y0,mousex,mousey,buttons
  // Check for mouse movements and set cursor.
  if Mousexy(hgraph,&mousex,&mousey,&buttons)==1 then
    for i=0,i<2,i++ do
      y0=YSTART+YSTEP*i
      for hand=0,hand<2,hand++ do
        x0=XSTART+LEFTX/2*hand
        if mousex>=x0 && mousex<x0+NHIST*HSCALE &&                             \
          mousey<=y0 && mousey>=y0-YSCALE                                      \
        then                                                                   \
          j=(mousex-x0)/HSCALE
          j=Max(0,Min(j,NHIST-1))
          if j!=cursor then
            cursor=j
            force=1
          endif
        endif
      enddo
    enddo
  endif
  // Check for buttons.
  for i=0,i<4,i++ do
    if hhead[i]==NULL continue
    if Pressed(hhead[i]) then
      showside=(i & 2?0x2:0x1)
      showhalf=(i & 1?0x2:0x1)
      force=1
    endif
  enddo
  // Check whether we need to redraw window.
  if force==0 return
  for i=0,i<4,i++ do
    if hhead[i]==NULL continue
    j=(showside==0x2?2:0)+(showhalf==0x2?1:0)
    if i==j then
      change hhead[i] color=LIGHTRED
      change hhead[i] bkcolor=YELLOW
    else
      change hhead[i] color=BLACK
      change hhead[i] bkcolor=LIGHTGRAY
    endif
  enddo
  // Draw histogram.
  Painthistogram(hgraph,showside,showhalf)
end

// Service function, randomly moves heads on rails different from rail1 and
// rail2. First time, call with mode=0 (initialization). Call periodically
// with mode=1 to move heads. Finally, call with mode=-1 to stop test. Uses
// command buffers 16..31, please don't interfere!
function int Moveother(int rail1,int rail2,int mode)
  int i,r
  float x0,x1,y0,y1
  char s[256]
  if mode==0 then
    // Initialization.
    for r=0,r<$LAY.nfing,r++ do
      SYS.Killimm(r+16)
      $A[r+16].length=1
    enddo
    return
  else if mode<0 then
    // Finalization.
    for r=0,r<$LAY.nfing,r++ do
      SYS.Killimm(r+16)
    enddo
    return
  endif
  // Movements.
  for r=0,r<$LAY.nfing,r++ do
    if r==rail1 || r==rail2 continue
    if ($LAY.excludedrails & (1<<r))!=0 continue
    if $A[r+16].length==0 continue     // Command is still pending
    x0=$LAY.leftlimit/1000.0+30.0
    y0=$LAY.yoffset[r]/1000.0
    x1=$LAY.rightlimit/1000.0-30.0
    y1=y0
    for i=0,i<2,i++ do
      x0=x0+Random(10.0)-Random(10.0)
      y0=y0+Random(10.0)-Random(10.0)
      x1=x1+Random(10.0)-Random(10.0)
      y1=y1+Random(10.0)-Random(10.0)
    enddo
    sprintf(s,"M%s %i(%.3f,%.3fA10) %i(%.3f,%.3fA10) NOP",                     \
      scmd,r*2,x0,y0,r*2+1,x1,y1)
    SERV.Cmdimm(r+16,s)
  enddo
end

// Runs histogram test. Returns -1 if operator interrupted test and 0 in any
// other case.
function int Histogram()
  int i,j,n,t,tstep,texp,dt,rail,dir,half,side,hand,line,head,newv,newp,err
  int loop,nloop,newloop,nrep,nht,redraw,userlim,usesides
  float r,r1,r2,base,d,done,x,y,xt,yt,ycenter,xboard,yboard,xref[2],yref[2]
  float thw,tx0[2][2],ty0[2][2],tx1[2][2],ty1[2][2],tdx[2][2],tdy[2][2]
  float edge[4][2][2]
  char s[256]
  handle hstep[NSTEP],hvelo,hvscr,hpres,hpscr,haccu,hascr,hloop,hlscr
  handle hmode,harea,hother,hcomment,hrun,hremain,hcancel
  struct t_htest dummy
  float step[NSTEP] = { 0.2, 0.3, 0.5, 1.0, 2.0, 3.0, 5.0, 10.0 }
  if histstep==0.0 histstep=5.0
  // Check that SERV and crate support required extensions.
  if (features & MF_RLIMCRATE)==0 then
    userlim=0
  else if SERV.Parsecmd("M 0(0,0) 1(0,1) R(0,1,LONG,SIMPLE)",s)>0 then
    userlim=2
  else if SERV.Parsecmd("M 0(0,0) 1(0,1) R(0,1,IMAX=0.0003,LONG,FREE)",s)>0 then
    userlim=1
  else
    userlim=0
  endif
  nloop=1; histstep=5.0; accuracy=1; histmode=1; smallarea=1; moveother=0
  getini("Accuracy test","Histogram","%i,%f,%i,%i,%i,%i",                      \
    &nloop,&histstep,&accuracy,&histmode,&smallarea,&moveother)
  nloop=Max(1,Min(nloop,10))
  histstep=Max(0.2,Min(histstep,10.0))
  accuracy=Max(1,Min(accuracy,100))
  histmode=Max(0,Min(histmode,2))
repeat:
  // I run test on the rail to which the center of the glass board belongs.
  err=0
  if testersides==0x1 then
    ycenter=(yfid[0][0]+yfid[0][1]+yfid[0][2]+yfid[0][3])/4.0
  else if testersides==0x2 then
    ycenter=(yfid[1][0]+yfid[1][1]+yfid[1][2]+yfid[1][3])/4.0
  else
    ycenter=(yfid[0][0]+yfid[0][1]+yfid[0][2]+yfid[0][3]+                      \
    yfid[1][0]+yfid[1][1]+yfid[1][2]+yfid[1][3])/8.0
  endif
  railtop=-1; railbot=-1; usesides=0
  for i=0,i<$LAY.nfing,i++ do
    if ($LAY.excludedrails & (1<<i))!=0 continue
    if ycenter>=$LAY.bottom[i]/1000.0 && ycenter<$LAY.top[i]/1000.0 then
      if ($LAY.side[i] & 1)==0 then
        railtop=i; rail=i; usesides=usesides|0x1
      else
        railbot=i; rail=i; usesides=usesides|0x2
      endif
    endif
  enddo
  if railtop<0 && railbot<0 then
    err=1; goto finish                 // Board outside the working area
  endif
  change hinfo limits=0,0
  change hinfo text="Start test"
  clear hleft
  showside=(usesides & 0x1?0x1:0x2)
  showhalf=0x1
  cursor=-1
  nhstat=0
  Memset(hstat,0,Sizeof(hstat))
  Memset(edge,0,Sizeof(edge))
  hgraph=control GRAPH
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BLACK
    bkcolor=WHITE
  endc
  j=(usesides==0x3?LEFTX/2-2*40-10-10/2:LEFTX/2-40-10/2)
  for i=0,i<4,i++ do
    if (usesides & (1<<(i/2)))==0 then
      hhead[i]=NULL
      continue
    endif
    head=(i<2?railtop:railbot)*2+(i & 1)
    hhead[i]=control BUTTON
      window=hgraph
      position=j,LEFTY-33,40,21
      name=format("%i%s",head/2,head & 1?"R":"L")
      help=format("按下可以显示测试头%i%s的统计信息",                 \
        head/2,head & 1?"R":"L")
      font=SMALLFONT
      color=BLACK
      bkcolor=LIGHTGRAY
    endc
    j=j+40+10
  enddo
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please set test options and press " font=MAINFONT text="Run "
  draw font=TIMESFONT text="to verify accuracy."
  draw at 5,79 font=INFOFONT text="Step:"
  j=-1
  for i=0,i<NSTEP,i++ do
    hstep[i]=control RADIO
      window=hright
      position=7,84+i*18,60,16
      name=format("%g um",step[i])
      help=format("将直方图设置步长为%g微米",step[i])
      font=INFOFONT
    endc
    if histstep==step[i] j=i
  enddo
  if j<0 j=3
  change hstep[j] mode=M_CHECKED
  histstep=step[j]
  draw at 83,85 font=INFOFONT text="Stroke"
  hvelo=control TEXT
    window=hright
    position=144,66,45,24
    help="指定Z方向下降速度，单位为毫米/秒"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hvscr=control VSCROLL
    window=hright
    position=189,66,20,24
    help="按下以更改Z方向速度"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 217,85 text="mm/s"
  draw at 83,113 text="Pressure"
  hpres=control TEXT
    window=hright
    position=144,94,45,24
    help=" 指定Z方向压力，内部单位"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hpscr=control VSCROLL
    window=hright
    position=189,94,20,24
    help="按下以更改Z方向压力"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 217,113 text="i.u."
  draw at 83,141 text="Accuracy"
  haccu=control TEXT
    window=hright
    position=144,122,45,24
    help=" 指定精度(以微米为单位)"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hascr=control VSCROLL
    window=hright
    position=189,122,20,24
    help="按下更改所需的精度"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 217,141 text="um"
  draw at 83,169 text="Loops"
  hloop=control TEXT
    window=hright
    position=144,150,45,24
    help="指定测试循环数"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hlscr=control VSCROLL
    window=hright
    position=189,150,20,24
    help="按下更改测试循环数"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 83,197 text="Moves"
  hmode=control COMBOLIST
    window=hright
    position=144,178,105,120
    help="移动方式"
  endc
  add hmode text="Linear"
  add hmode text="Random"
  add hmode text="Long"
  change hmode select=histmode
  draw at 83,225 text="Test area"
  harea=control COMBOLIST
    window=hright
    position=144,206,105,120
    help="测试区大小"
  endc
  add harea text="4x10 mm"
  add harea text="0.2x0.2 mm"
  change harea select=smallarea
  hother=control CHECKBOX
    window=hright
    position=144,236,100,22
    text="Move other"
    help="在测试期间随机移动其它测试头"
    mode=(moveother?M_CHECKED:0)
    font=INFOFONT
  endc
  draw at 5,266 text="Comment:"
  hcomment=control EDIT
    window=hright
    position=5,270,RIGHTX-10,23
    help="在这里您可以输入您的评论"
    text=comment
    font=TIMESFONT
    mode=M_BORDER
  endc
  if rtfok==0 disable hcomment
  hrun=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+19,120,24
    name="运行"
    help="按下即可运行直方图"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+19,120,24
    name="回到菜单"
    help="按下可返回主菜单"
  endc
  draw show
  Processhistogram(1)
  newv=strokev
  newp=strokep
  newloop=nloop
  redraw=1
  while 1 do
    Processhistogram(0)
    if Pressed(hexit) then
      return -1
    else if Pressed(hvscr) then
      newv=newv+Status(hvscr)*5; change hvscr select=0
      redraw=1
    else if Pressed(hpscr) then
      newp=newp+Status(hpscr)*5; change hpscr select=0
      redraw=1
    else if Pressed(hascr) then
      accuracy=Max(1,Min(accuracy+Status(hascr),255)); change hascr select=0
      redraw=1
    else if Pressed(hlscr) then
      newloop=newloop+Status(hlscr); change hlscr select=0
      redraw=1
    else if Pressed(hmode) then
      histmode=Status(hmode)
    else if Pressed(harea) then
      smallarea=Status(harea)
    else if Pressed(hother) then
      moveother=Status(hother)
    else if Pressed(hcancel) then
      return 0
    else if Pressed(hrun) then
      break
    endif
    for i=0,i<NSTEP,i++ do
      if Pressed(hstep[i]) then
        histstep=step[i]
        Processhistogram(1)
      endif
    enddo
    if redraw then
      newv=Max(5,Min(newv,30))
      newp=Max(10,Min(newp,100))
      newloop=Max(1,Min(newloop,10))
      change hvelo text=format(" %i",newv)
      change hvelo bkcolor=(newv<=20?WHITE:PINK)
      change hpres text=format(" %i",newp)
      change haccu text=format(" %i",accuracy)
      change hloop text=format(" %i",newloop)
      strokev=newv
      strokep=newp
      nloop=newloop
      redraw=0
    endif
    wait
  enddo
  setini("Accuracy test","Histogram","%i,%f,%i,%i,%i,%i",                      \
    nloop,histstep,accuracy,histmode,smallarea,moveother)
  // Run test.
  Text(hcomment,comment)
  change hinfo text="Accuracy histogram"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Test is running. Please be patient. To stop it, press "
  draw font=MAINFONT text="Interrupt" font=TIMESFONT text="."
  draw show
  hremain=control GRAPH                // To avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,105,200,60
    help="直到结束的测试的持续时间和估计的时间"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY,120,24
    name="中断"
    help="按下中断精度测试"
  endc
  Processhistogram(1)
  // Move all heads in home position.
  for i=0,i<$LAY.nfing,i++
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,s)
    SYS.Killimm(i)
  enddo
  Moveother(railtop,railbot,0)
  // Select wires that will be used in the test. First wire extends from
  // (tx0,ty0) to (tx1,ty1), each subsequent is shifted by vector (tdx,tdy).
  // Indices: tx0[side][dir] (dir=0: X accuracy, vertical lines; dir=1: Y
  // accuracy, horizontal lines) and so on. I use the thickest wires from the
  // main area (100 or 75 um).
  thw=width[boardtype][1]/2000.0       // Wire halfwidth, mm
  if ycenter<=$LAY.yoffset[rail]/1000.0 then
    // Use structures on the upper half of the board.
    tx0[0][0]=-2.0; ty0[0][0]=+1.1     // Vertical wire on the top side
    tx1[0][0]=-2.0; ty1[0][0]=+4.9
    tdx[0][0]=-1.0; tdy[0][0]=+0.0
    tx0[0][1]=+1.1; ty0[0][1]=+2.0     // Horizontal wire on the top side
    tx1[0][1]=+4.9; ty1[0][1]=+2.0
    tdx[0][1]=+0.0; tdy[0][1]=+1.0
    tx0[1][0]=+2.0; ty0[1][0]=+1.1     // Vertical wire on the botton sode
    tx1[1][0]=+2.0; ty1[1][0]=+4.9
    tdx[1][0]=+1.0; tdy[1][0]=+0.0
    tx0[1][1]=-1.1; ty0[1][1]=+2.0     // Horizontal wire on the bottom side
    tx1[1][1]=-4.9; ty1[1][1]=+2.0
    tdx[1][1]=+0.0; tdy[1][1]=+1.0
  else
    // Use structures on the lower half of the board.
    tx0[0][0]=+2.0; ty0[0][0]=-1.1     // Vertical wire on the top side
    tx1[0][0]=+2.0; ty1[0][0]=-4.9
    tdx[0][0]=+1.0; tdy[0][0]=+0.0
    tx0[0][1]=-1.1; ty0[0][1]=-2.0     // Horizontal wire on the top side
    tx1[0][1]=-4.9; ty1[0][1]=-2.0
    tdx[0][1]=+0.0; tdy[0][1]=-1.0
    tx0[1][0]=-2.0; ty0[1][0]=-1.1     // Vertical wire on the botton sode
    tx1[1][0]=-2.0; ty1[1][0]=-4.9
    tdx[1][0]=-1.0; tdy[1][0]=+0.0
    tx0[1][1]=+1.1; ty0[1][1]=-2.0     // Horizontal wire on the bottom side
    tx1[1][1]=+4.9; ty1[1][1]=-2.0
    tdx[1][1]=+0.0; tdy[1][1]=-1.0
  endif
  if histmode==0 || smallarea!=0 then
    // All measurements must be done on the single line. Select it now.
    line=Random(10)
    for side=0,side<2,side++ do
      for dir=0,dir<2,dir++ do
        tx0[side,dir]=tx0[side,dir]+tdx[side,dir]*line
        tx1[side,dir]=tx1[side,dir]+tdx[side,dir]*line
        ty0[side,dir]=ty0[side,dir]+tdy[side,dir]*line
        ty1[side,dir]=ty1[side,dir]+tdy[side,dir]*line
      enddo
    enddo
  endif
  nrep=10
  nhstat=nrep*nloop
  tstep=Time(); texp=-1000000
  for loop=0,loop<nloop && err==0,loop++ do
    // Loop.
    for half=0,half<2 && err==0,half++ do
      // Left or right head.
      showhalf=1<<half
      Processhistogram(1)
      // Select reference.
      if half==0 then
        xboard=+47.0+Random(1.5)-0.75
      else
        xboard=-47.0+Random(1.5)-0.75
      endif
      yboard=Random(2.5)-1.25
      if ycenter<=$LAY.bottom[rail]/1000.0+0.1 then
        yboard=yboard+44.0
      else if ycenter>=$LAY.top[rail]/1000.0-0.5 then
        yboard=yboard-44.0
      endif
      for side=0,side<2,side++ do
        if (usesides & (1<<side))==0 continue
        Boardtotester(side,xboard,yboard,xref+side,yref+side)
      enddo
      for dir=0,dir<2,dir++ do         // Direction (0 - X, 1 - Y)
        change hinfo limits=((loop*2+half)*2+dir)*nht,nloop*2*2*nht
        // Measure exact position of the line: edge[sidehead][dir][hand] in
        // board coordinates. This must be done only on the first loop. Line
        // is choosen randomly.
        if loop==0 then
          // Set default edges for the case that scanning fails.
          for side=0,side<2,side++ do
            if dir==0 then
              edge[side*2+half][dir][0]=(tx0[side,dir]+tx1[side,dir])/2.0-thw
              edge[side*2+half][dir][1]=(tx0[side,dir]+tx1[side,dir])/2.0+thw
            else
              edge[side*2+half][dir][0]=(ty0[side,dir]+ty1[side,dir])/2.0-thw
              edge[side*2+half][dir][1]=(ty0[side,dir]+ty1[side,dir])/2.0+thw
            endif
          enddo
          // Send three scan commands. Each time we must wait till previous
          // command is executed, or they will interfere with each other.
          r=0.35+Random(0.10)          // Mean positions: 0.4, 0.5, 0.6 +-0.05
          for i=0,i<3,i++ do
            for side=0,side<2,side++ do
              if (usesides & (1<<side))==0 continue
              if dir==0 then
                x=(tx0[side,dir]+tx1[side,dir])/2.0
                y=ty0[side,dir]*r+ty1[side,dir]*(1.0-r)
              else
                x=tx0[side,dir]*r+tx1[side,dir]*(1.0-r)
                y=(ty0[side,dir]+ty1[side,dir])/2.0
              endif
              Boardtotester(side,x,y,&xt,&yt)
              head=(side==0?railtop:railbot)*2+half
              n=sprintf(s,                                                     \
                "M%s %i:(%.6f,%.6fA%gP%iV%iH%g) %i:(%.6f,%.6fP%iV%i) ",        \
                scmd,head,xt,yt,accuracy/2.0,strokep,strokev,strokez+3.0,      \
                head^1,xref[side],yref[side],Max(strokep,50),strokev)
              sprintf(s+n,"CAL(%i,%i,W%iD%i,LONG)",                            \
                head,head^1,thw*2000.0,dir*64)
              SERV.Cmdimm(side+2*i,s)
            enddo
            // Wait for answers.
            t=Time()
            while err==0 do
              if Pressed(hexit) err=-1
              if Pressed(hcancel) err=3
              for side=0,side<2,side++ do
                if (usesides & (1<<side))==0 continue
                if $A[side+2*i].length==0 break
                enddo
              if side>=2 break
              if moveother Moveother(railtop,railbot,1)
              Processhistogram(0)
              wait
            enddo
            if err!=0 goto finish
            r=r+0.10
          enddo
          // Get coordinates of the edges. They must be converted back to the
          // board coordinates.
          for side=0,side<2,side++ do
            if (usesides & (1<<side))==0 continue
            if $A[side].answer!=S_CALIBRATE continue
            // Unfortunately, only micrometer accuracy.
            xt=($int4($A[side]+5)+$int4($A[side+2]+5)+                         \
              $int4($A[side+4]+5))/3000.0+0.0005
            yt=($int4($A[side]+13)+$int4($A[side+2]+13)+                       \
              $int4($A[side+4]+13))/3000.0+0.0015
            Testertoboard(side,xt,yt,&x,&y)
            if dir==0 then
              edge[side*2+half][dir][0]=x
            else
              edge[side*2+half][dir][0]=y
            endif
            xt=($int4($A[side]+9)+$int4($A[side+2]+9)+                         \
              $int4($A[side+4]+9))/3000.0-0.0005
            yt=($int4($A[side]+17)+$int4($A[side+2]+17)+                       \
              $int4($A[side+4]+17))/3000.0-0.0015
            Testertoboard(side,xt,yt,&x,&y)
            if dir==0 then
              edge[side*2+half][dir][1]=x
            else
              edge[side*2+half][dir][1]=y
            endif
          enddo
        endif
        // Prepare complete batch of tests.
        nht=0; base=Random(0.0909)
        for hand=0,hand<2,hand++ do    // For hands (left/top or right/bottom)
          for i=0,i<NHIST,i++ do       // For all distance indices
            d=(i-NHIST/2)*histstep/1000.0
            line=0
            for j=0,j<nrep,j++ do      // For all repeats
              if histmode==0 then
                r=base+0.909*j/nrep
              else
                r=Random(1.0)
              endif
              if smallarea r=r*0.050+0.475
              for side=0,side<2,side++ do
                if (usesides & (1<<side))==0 continue
                if dir==0 then
                  x=edge[side*2+half][dir][hand]+tdx[side,dir]*line+d
                  y=ty0[side,dir]*r+ty1[side,dir]*(1.0-r)+tdy[side,dir]*line
                else
                  x=tx0[side,dir]*r+tx1[side,dir]*(1.0-r)+tdx[side,dir]*line
                  y=edge[side*2+half][dir][hand]+tdy[side,dir]*line+d
                endif
                Boardtotester(side,x,y,&xt,&yt)
                ht[nht].x[side]=xt
                ht[nht].y[side]=yt
              enddo
              ht[nht].hand=hand
              ht[nht].index=i
              nht++
              // I use first 10 wires, except for the linear mode or small
              // area, where I use only the first one.
              if histmode!=0 && smallarea==0 then
                line=(line+1)%10
              endif
            enddo
          enddo
        enddo
        // Shuffle tests, except for linear mode.
        if histmode!=0 then
          for i=0,i<nht,i++ do
            j=Random(nht)
            if i==j continue
            Memcpy(dummy,ht[i],Sizeof(dummy))
            Memcpy(ht[i],ht[j],Sizeof(dummy))
            Memcpy(ht[j],dummy,Sizeof(dummy))
          enddo
        endif
        // Run complete batch.
        for i=0,i<nht,i++ do
          change hinfo limits=((loop*2+half)*2+dir)*nht+i,nloop*2*2*nht
          // Send command synchronously for top and bottom.
          for side=0,side<2,side++ do
            if (usesides & (1<<side))==0 continue
            head=(side==0?railtop:railbot)*2+half
            if histmode==2 then
              // Long moves: make preliminary (max. 25 mm) X-Y movement.
              Boardtotester(side,0.0,0.0,&xt,&yt)
              xt=xt+Random(50.0)-25.0
              yt=yt+Random(50.0)-25.0
              if yt<$LAY.bottom[head/2]/1000.0+3.0                             \
                yt=$LAY.bottom[head/2]/1000.0+3.0
              if yt>$LAY.top[head/2]/1000.0-3.0                                \
                yt=$LAY.top[head/2]/1000.0-3.0
              sprintf(s,"M%s %i(%g,%gA255H%g) NOP",scmd,head,xt,yt,strokez)
              SERV.Cmdimm(32,s)
            endif
            // This is the first script that uses nanometer accuracy!
            n=sprintf(s,                                                       \
              "M%s %i:(%.6f,%.6fA%iP%iV%iH%g) %i:(%.6f,%.6fP%iV%i) ",          \
              scmd,head,ht[i].x[side],ht[i].y[side],accuracy,strokep,strokev,  \
              strokez,head^1,xref[side],yref[side],Max(strokep,50),strokev)
            // If embedded software supports resistance with current limit,
            // use it to reduce the probability of damage to the glass board.
            if userlim==2 then
              sprintf(s+n,"R(%i,%i,SIMPLE,IMAX=0.00025,LONG,FREE)",            \
              head,head^1)
            else if userlim>=1 then
              // If current is so low, we don't need to specify LONG switch.
              sprintf(s+n,"R(%i,%i,IMAX=0.00025,FREE)",head,head^1)
            else
              sprintf(s+n,"R(%i,%i)",head,head^1)
            endif
            // Send measurement.
            SYS.Killimm(side)
            SERV.Cmdimm(side,s)
          enddo
          // Wait for answers.
          t=Time()
          while err==0 do
            if Pressed(hexit) err=-1
            if Pressed(hcancel) err=3
            for side=0,side<2,side++ do
              if (usesides & (1<<side))==0 continue
              if $A[side].length==0 break
            enddo
            if side>=2 break
            if moveother Moveother(railtop,railbot,1)
            Processhistogram(0)
            wait
          enddo
          if err!=0 goto finish
          // Process answers.
          for side=0,side<2,side++ do
            if (usesides & (1<<side))==0 continue
            if $A[side].answer!=S_MOVE then
              err=4; goto finish
            endif
            r=$A[side].r; if ($A[side].status & 0x0100) r=r*1.0e-6

            //CHECK FOR BAD MEASUREMENTS???

            // Threshold is arbitrarily set to 1 MOhm.
            if r<1.0e6 then
              hstat[dir][side*2+half][ht[i].hand][ht[i].index]++
            endif
          enddo
          // Update statistics.
          done=((loop*4+half*2+dir)*nht+i)*100.0/(nht*nloop*4)
          dt=Time()-tstep
          if (done>5.0 && dt>30000) || done>15.0 then
            t=dt*(100.0-done)/done
            if t<texp-500 || t>texp+10000 texp=t
          endif
          clear hremain
          draw window=hremain
          t=Time()-tstep+500
          draw at 8,27 color=RED text="Test time:"
          draw at 120,27 text=format("%2im %02is",t/60000,(t/1000)%60)
          draw at 8,52 text="Remains:"
          if texp<0 then
            draw at 120,52 color=DARKGRAY text=" ?"
          else
            draw at 120,52 color=RED
            draw text=format("%2im %02is",texp/60000,(texp/1000)%60)
          endif
          draw show
          Processhistogram(1)
        enddo
      enddo
    enddo
  enddo
  // Move all heads in home position.
  Moveother(railtop,railbot,-1)
  for i=0,i<$LAY.nfing,i++
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,s)
    SYS.Killimm(i)
  enddo
  Processhistogram(1)
  nhtest++
  // Test finished.
  if rtfok!=0 then
    // Write results to the protocol file.
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddfmt("\nResults of histogram test #%i",nhtest)
    // Show placement and parameters.
    RFmt(RTF_TIMES,RTF_NORMAL,10)
    RTable(RTF_LEFT|RTF_NOBORDER|RTF_THINSP,0.0,6.0)
    RCell(RTF_CENTERED,70.0)
    RAddtext("\n")
    Showboardplacement()
    RCell(RTF_LEFT,89.0)
    RAddfmt("\nPosition\t\t(%.1f,%.1f)\n",(pos1x+pos2x)/2,(pos1y+pos2y)/2)
    RAddfmt("Pressure\t\t%.1f i.u.\nStroke\t\t%.1f mm/s\nHeight\t\t%.1f mm\n", \
      strokep,strokev,strokez)
    RAddfmt("Loops\t\t%i\n",nloop)
    RAddfmt("Contacts\t\t%i per bin\n",nhstat)
    RAddfmt("Movements\t%s\n",                                                 \
      histmode==0?"Linear":(histmode==1?"Random":"Long moves"))
    RAddfmt("Area\t\t%s\n",                                                    \
      smallarea==0?"4x10 mm":"0.2x0.2 mm")
    if comment[0]!='\0' then
      RFmt(RTF_TIMES,RTF_BOLD,10)
      RAddtext(comment)
    endif
    REndtable()
    // Show statistics as a table.
    for dir=0,dir<2,dir++ do
      RFmt(RTF_TIMES,RTF_BOLD,12)
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      if dir==0 then
        RAddtext("\nHorizontal (X) accuracy")
      else
        RAddtext("\nVertical (Y) accuracy")
      endif
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RAddtext("\n")
      RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP|RTF_KEEPNEXT,0.0,6.0)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,19.0)
      RAddtext("Head")
      for side=0,side<2,side++ do
        for half=0,half<2,half++ do
          RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,2*17.5)
          RAddfmt("%i%s",side==0?railtop:railbot,half==0?"L":"R")
        enddo
      enddo
      RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP|RTF_KEEPNEXT,0.0,6.0)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,19.0)
      RAddtext("Edge")
      for i=0,i<8,i++ do
        RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,17.5)
        if dir==0 then
          RAddtext(i & 1?"right":"left")
        else
          RAddtext(i & 1?"top":"bottom")
        endif
      enddo
      RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP|RTF_KEEPNEXT,0.0,5.0)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,19.0)
      for i=0,i<NHIST,i++ do
        RAddfmt("%g?s",(i-NHIST/2)*histstep,i==NHIST-1?"":"\n")
      enddo
      for side=0,side<2,side++ do
        for half=0,half<2,half++ do
          for hand=0,hand<2,hand++ do
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,17.5)
            if (usesides & (1<<side))==0 continue
            for i=0,i<NHIST,i++ do
              RAddfmt("%.1f%%%s",                                              \
              (hstat[dir][side*2+half][hand][i]*100.0)/nhstat,                 \
              i==NHIST-1?"":"\n")
            enddo
          enddo
        enddo
      enddo
      REndtable()
    enddo
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RAddtext("\n")
    RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP|RTF_KEEPNEXT,0.0,5.0)
    RFmt(RTF_ARIAL,RTF_NORMAL,15)
    if usesides==0x3 then
      r=0.45
    else
      r=0.80
    endif
    cursor=-1
    for i=0,i<4,i++ do
      if (usesides & (1<<(i/2)))==0 continue
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,88*r)
      RAddfmt("%i%s",(i & 0x2?railbot:railtop),i & 1?"R":"L")
      Painthistogram(htemp,1<<(i/2),1<<(i%2))
      RAddpiczoom(htemp,0,0,LEFTX,300,0,r)
    enddo
    REndtable()
    RFmt(RTF_TIMES,RTF_NORMAL,9)
  endif
finish:
  if err<0 return -1
  if err==0 then
    change hinfo text="Test finished"
  else
    change hinfo text="Test cancelled"
  endif
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=(err==0 || err==3?BLACK:LIGHTRED)
  if err==0 then
    draw text="Test is finished. Please check the results. Move mouse pointer "
    draw text="over the graphs to get precise values."
  else if err==1 then
    draw text="Board outside the working area!"
    draw at 6,60 color=BLACK
    draw text="You may try to change board position and repeat test."
  else if err==3 then
    draw text="Test was cancelled by user."
  else if err==4 then
    draw text="Invalid answer from tester!"
    draw at 6,60 color=BLACK
    draw text="Please check that tester is loaded."
  else
    draw text="Unknown error!"
    draw at 6,60 color=BLACK
    draw text="This error is not expected. Please report it to atg."
  endif
  draw show
  hrun=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="重复"
    help="按下可以重复测试"
  endc
  if err==1 disable hrun               // Repeat makes no sense
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="回到菜单"
    help="按下可返回主菜单"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hrun) then
      goto repeat
    else if Pressed(hcancel) then
      return 0
    endif
    Processhistogram(0)
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// MAIN LOOP ///////////////////////////////////

// Asks for the next action. Returns action code ACT_xxx.
function int Selectaction()
  int y
  handle hacc,hhist,hrepos,hopenlog,hcloselog,hcancel
  Drawboard(0)
  change hinfo limits=0,0
  change hinfo text="Select what to do"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Press one of the buttons to select action:"
  draw show
  y=80
  if rtfok==0 then
    hopenlog=control BUTTON
      window=hright
      position=20,y,RIGHTX-40,22
      name="打开协议"
      help="按下可以打开文本格式协议文件"
    endc
    hcloselog=NULL
  else
    hopenlog=NULL
    hcloselog=control BUTTON
      window=hright
      position=20,y,RIGHTX-40,22
      name="关闭协议"
      help="按下可以关闭协议文件"
      color=LIGHTRED
    endc
  endif
  y=y+50
  hacc=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="精准测试"
    help="按下即可进行准确性测试"
  endc
  y=y+35
  hhist=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="Histogram"
    help="按下可以创建精度直方图"
  endc
  y=y+35
  hrepos=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="改变位置"
    help="按下可以更改板子位置"
  endc
  hcancel=control BUTTON
    window=hright
    position=20,USERY,RIGHTX-40,22
    name="完成"
    help="按下以完成容量调整"
  endc
  while 1 do
    if Pressed(hexit) return ACT_QUIT
    if Pressed(hacc) return ACT_ACC
    if Pressed(hhist) return ACT_HIST
    if Pressed(hrepos) return ACT_REPLACE
    if Pressed(hopenlog) return ACT_OPENLOG
    if Pressed(hcloselog) return ACT_CLOSELOG
    if Pressed(hcancel) return ACT_CANCEL
    wait
  enddo
end

// Main function.
function int main()
  int i,action
  hmain=control WINDOW
    window=NULL
    position=10,10,MAINX,MAINY
    name=format("飞针测试机 v%s",VERSION)
    help=" "
    size=128
  endc
  htemp=control GRAPH
    window=hmain
    position=-1000,-1000,LEFTX,LEFTY
    color=BLACK
    bkcolor=WHITE
  endc
  hleft=control CHILD
    window=hmain
    position=5,5,LEFTX,LEFTY
    help=" "
    color=DARKGRAY
    size=16384
  endc
  hserv=control CHILD
    window=hmain
    position=SPLIT,5,RIGHTX,SERVY
    help="当前测试的状态"
    color=DARKGRAY
  endc
  hright=control CHILD
    window=hmain
    position=SPLIT,10+SERVY,RIGHTX,RIGHTY
    help=" "
    color=DARKGRAY
    size=1024
  endc
  hinfo=control PROGRESS
    window=hserv
    position=-1,-1,RIGHTX+2,SERVY+2
    text="Welcome!"
    help="当前测试的状态"
    mode=M_PERCENT
    font=MEDIUMFONT
    limits=0,0
  endc
  hexit=control BUTTON
    window=hmain
    position=MAINX-84,MAINY-SERVY,80,SERVY-3
    name="关闭"
    help="双击终止测试并关闭此窗口"
    mode=M_DBLCLICK
  endc
  draw window=hmain bitmap=0,0,1,"bkground" show
  draw window=hleft
  draw at 70,40 bitmap=0,0,0,"logo"
  draw color=DARKGRAY font=LARGEFONT mode=M_CENTERED
  draw at LEFTX/2,280 text="Accuracy test"
  draw font=MEDIUMFONT
  draw at LEFTX/2,305 text=format("Version %s",VERSION)
  draw show
  bchead=-1
  individualbc=1                       // Individual brightness and contrast
  firstscan=1
  histmode=1                           // Default is random movements
  nloop=1
  accuracy=1                           // Accuracy in micrometers
  boardtype=-1
  usec=1                               // Capacity can't destroy wires
  shuttle=-1
  pulledshuttle=-1
recheck:
  if Loadtester()!=0 goto quit         // Make sure that tester is loaded
  i=Getlayout()                        // Get actually loaded layout
  if i<0 goto quit                     // Operator interrupted the test
  if i>0 goto recheck                  // Try to reload tester
  Recognizetester()                    // Determine type of the tester
  if testertype==TT_WRONG goto quit    // Don't know how to test
  Getfeatures()                        // Get features of measurement card
  Bcgetini()                           // Get brightness and contrast
  Loadshinethrucorr()                  // Read shinethrough corrections
  Getcamerascales()                    // Get camera magnifications
  Disableautoset()                     // Disable auto brightness and contrast
reinstall:
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                   \
    ($LAY.config & LC_LDMASK)==LC_LMS2AUTO) then
    i=InstallboardLM()                 // Install board in auto L&M shuttle
  else if (testertype==TT_A7 || testertype==TT_A8) &&                          \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    i=InstallboardLM()                 // Install board in A7 split shuttle
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    i=InstallboardLM()
  else if ((testertype==TT_A4 || testertype==TT_A6 || testertype==TT_S1) &&    \
    ($LAY.config & 0x0001C040)==0x00008040) then
    i=Installboard(1)                  // Install board on A4/A6 auto
  else
    i=Installboard(0)                  // Install board on other tester
  endif
  if i<0 goto quit                     // Operator interrupted the test
  i=Locateboard()                      // Get rough board position
  if i<0 goto quit                     // Operator interrupted the test
  if i>0 goto reinstall                // Replace board
  Saveshinethrucorr()                  // Save shinethrough corrections
  Bcsetini()                           // Save brightness & contrast
  i=Scanboard()                        // Scan board position
  if i<0 goto quit                     // Operator interrupted the test
  if i>0 goto reinstall                // Replace board
  if boardtype<0 then
    i=Determinetype()                  // Determine board type
    if i<0 goto quit                   // Operator interrupted the test
    if i>0 goto reinstall              // Replace board
  endif
mainloop:
  action=Selectaction()                // Select what to do
  switch action
  case ACT_QUIT:                       // Quit test
    goto quit
  case ACT_ACC:                        // Accuracy test
    i=Accuracytest()
    if i<0 goto quit                   // Operator interrupted the script
    goto mainloop
  case ACT_HIST:                       // Histogram
    i=Histogram()
    if i<0 goto quit                   // Operator interrupted the script
    goto mainloop
  case ACT_REPLACE:                    // Change placement
    goto reinstall
  case ACT_OPENLOG:                    // Open protocol file
    i=Openprotocol()
    if i<0 goto quit                   // Operator interrupted the test
    goto mainloop
  case ACT_CLOSELOG:                   // Close protocol file
    Closeprotocol()
    goto mainloop
  case ACT_CANCEL:                     // Finish test
    goto quit
  default:                             // Internal error
    goto mainloop
  endsw
quit:
  Closeprotocol()
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8 then
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,0")
    SERV.Cmdimm(32,"OUTPORT32 ALL 0x10010003,0")
  endif
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                   \
    ($LAY.config & LC_LDMASK)==LC_LMS2AUTO ||                                  \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO) then
    Unloadboard()                      // Unload board if L&M shuttle
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    Unloadboard()                      // Unload board if S3 split shuttle
  else
    SYS.Softreset(0)
  endif
end

