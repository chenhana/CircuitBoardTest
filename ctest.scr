#include "ls.icl"                  // System definitions and functions
#include "or.icl"                // Command & error mnemonics
#include "pa.icl"                  // Rich Text Format extentions
#cmdbuff 34                            // 32+2 command buffers
#zeroid                                // Intercept tester answers with zero ID

#define VERSION        "19.02"
#define DESCRIPTION    "Adjustment of input capacities"

// 1.02: Restart if capacities are too different on second or third step.
// 1.03: Bug, capacities were checked for equal only between non-fixed heads.
// 1.04: On A5/A6, allows auto adjustment dependless on active on-heads bit.
// 1.05: Support for single-sided testers and splinogramms.
// 1.06: Repeats invalid field up to 3 times.
// 1.07: Measures and saves to layout individual capacities of needles.
// 1.08: Self-cleaning on glass fibre brushes.
// 1.09: Capacity adjustment for handicapped testers, no individual capacities.
// 1.10: Position in shuttle, avoids collisions between different rails.
// 1.11: Option to exclude rails.
// 1.12: Indicates which potentiometer is at limit.
// 1.13: Capacity and field statistics during verification.
// 1.14: Positioning is done with 5 fiducials of different size.
// 1.15: Contact always in the same point, first 4 field waves are discarded.
// 1.16: Option to test Dallas potentiometers.
// 1.17: Simple mode ("only adjust").
// 1.18: Support for A5L.
// 1.19: Small bugfix - unable to adjust Cin for second time in same session.
// 1.20: Support for truly single-sided testers.
// 1.21: Support for new on-heads with phase correction.
// 1.22: Support for head cameras.
// 1.23: Allowance for A5YL (240 mm rail height).
// 1.24: Balancing of MSD amplifiers.
// 1.25: Adjustment of MSD capacity.
// 1.26: Out-of-range capacity is considered bad.
// 1.27: Default headcam radii changed to 118 and 153 mm.
// 1.28: Better treatment of handicapped testers.
// 1.29: Option to make best possible adjustment if heads are too diferent.
// 1.30: Removed balance of MSD input capacities (obsolete feature).
// 1.31: C phase adjustment at 16 kHz.
// 1.32: Log file.
// 1.33: Serial I/O errors on A5 are considered non-critical.
// 1.34: Verification of placement checks head against all other on the line.
// 1.35: Maximal positioning error is reduced from 5 to 3 mm.
// 1.36: C phase adjust limit is increased from 0.0002 to 0.0005.
// 1.37: Measures to improve quality of C phase adjust.
// 1.38: Positioning window shows deviations instead of absolute coordinates.
// 1.39: If positioning crosses are not reachable, scans pads.
// 1.40: Support for A5 L&M automation.
// 1.41: Support for S1.
// 1.42: Support for EPCOS tester.
// 1.43: Shuttle adjustment and restoration support for A5 L&M automation.
// 1.44: Small modifications for EPCOS tester.
// 1.45: Z pressure sensor test.
// 1.46: Kelvin contact test, corrected bug with interrupted pad scan.
// 1.47: Improved CRT calibration.
// 1.48: Possibility to move L&M shuttle out while needles are contacting.
// 1.49: Adjustment of frequency-dependent capacity phase.
// 1.50: Bugfix for single-sided A5/4 (MSD and C phase adjust).
// 1.51: Bugfix for timeout during C phase adjustment.
// 1.52: Support for S2.
// 1.53: Bugfix for video after reinstalling board.
// 1.54: CHIGHMAX is increased from 50.0 to 55.0 pF.
// 1.55: Support for wide C adjust board.
// 1.56: Support for S1 (no field) on-head boards, auto CRT in simple mode.
// 1.57: Removed bug in no field mode: script started manual C adjust.
// 1.58: Corrections of MSD factors for the dielectrical quality of the board.
// 1.59: To avoid overloads, C phase adjustment voltage is reduced to 4 V.
// 1.60: Buggy antenna selection if front rails are excluded.
// 1.61: Support for A7 and A8.
// 1.62: Major redesign. Everything is updated. Test voltage is set to 4 V.
// 1.63: Basic support for A7a.
// 1.64: Basic support for A8a.
// 1.65: Reduced DADJA5S to take BEL506 into account.
// 1.66: Support for A7/20 and EL208-1.
// 1.67: Bug: touching needles in MSD calibration.
// 1.68: Auto verification for the hardware glitch that spoils potentiometers.
// 1.69: Support for S3.
// 1.70: Warning concerning simple adjust if some rails are excluded.
// 1.71: Verification of field measurements on a shortcut.
// 1.72: Support for additional layout extentions.
// 1.73: Extended field phase corrections.
// 1.74: Uses external USB temperature sensor if internal is absent.
// 1.75: Bug: extremely high C amplitude factors were not reset before test.
// 1.76: Shift of all potentiometers, if necessary.
// 1.77: C adjust on vacuum shuttle.
// 1.78: Bug with brightness and contrast when going to different camera.
// 1.79: On error restores old layout settings in tester.
// 1.80: Warning if capacity phase corrections are too high.
// 1.81: L&M shuttle settings are not restored when test is finished.
// 1.82: Thinner fiducial cross on XXL board.
// 1.83: Support for testers with split shuttle.
// 1.84: Check for no contact turned off (compatibility to A2).
// 1.85: Measurements of needle resistance for Kelvin needles.
// 1.86: Support for S3ea (split shuttle).
// 1.87: Increased size of text buffers to avoid overflows for A7/20.
// 1.88: Check for missing or zeroed main layout extention.
// 1.89: Adjustment of backdrill needle capacities.
// 1.90: Complete check of the logic, backdrill verification after adjust.
// 1.91: Support for A7/24.
// 1.92: Backdrill adjustment for testers with more than 4 rails.
// 1.93: Support for c:\atg\hardware as alternative directory.

// Used resources.
#bitmap "logo"<"guoke.bmp"               // All bitmaps are compressed
#bitmap "bkground"<"aluminum.bmp"      // Alternative: "pcb1.bmp"
#bitmap "unknown"<"unknown.bmp"
// c-rcsel is not yet available everywhere, therefore I load it dynamically.
// rcboard is not yet available everywhere, therefore I load it dynamically.
// rclarge is not yet available everywhere, therefore I load it dynamically.
// rc24 is not yet available everywhere, therefore I load it dynamically.
// a5actest is not yet available everywhere, therefore I load it dynamically.
// a5arctst is not yet available everywhere, therefore I load it dynamically.
// a7actest is not yet available everywhere, therefore I load it dynamically.
// a7arctst is not yet available everywhere, therefore I load it dynamically.

// Dimensions of test window.
#define MAINX          600
#define MAINY          400
#define SPLIT          330
#define SERVY          25
#define LEFTX          320             // (SPLIT-10)
#define LEFTY          365             // (MAINY-SERVY-10)
#define RIGHTX         265             // (MAINX-SPLIT-5)
#define RIGHTY         335             // (MAINY-SERVY-SERVY-15)
#define USERY          250

// Constants determining tester type.
#define TT_WRONG       (-1)
#define TT_UNDEF       0
#define TT_A1          1
#define TT_A2          2
#define TT_A2L         3
#define TT_A2H         4
#define TT_A3          5
#define TT_A3L         6
#define TT_A4          7
#define TT_A5          8
#define TT_A5L         9
#define TT_A6          10
#define TT_S1          11
#define TT_S2          12
#define TT_A7          13
#define TT_A8          14
#define TT_S3          15
#define TT_M2          16

// Definition of global error bits.
#define GE_BOOT        0x0001          // Tester must be rebooted
#define GE_HARDWARE    0x0002          // Pneumatics/shuttle out of order
#define GE_IOERROR     0x0004          // I/O error detected
#define GE_COMMAND     0x0008          // Command sending error
#define GE_MEAS        0x0010          // Resistance measurements impossible

// Precise needle types in $EXTLAY.needletype.
#define NT_UNKNOWN     0               // Unspecified needle type
#define NT_HARD        1               // Solid hard touch
#define NT_HARDADAPT   2               // Hard touch adapter
#define NT_SPLINO      3               // Splinogramm
#define NT_MICROMIRR   4               // Microprobe with mirror
#define NT_MICRO       5               // Microprobe with transmissive sensor
#define NT_KELVMIRR    6               // Kelvin microprobe with mirror
#define NT_KELVIN      7               // Kelvin with transmissive sensor
#define NT_LATEST      8               // Kelvin with mirror and blades
#define NT_K4SPLINO    9               // K4 splinogramm
#define NT_MICROSHLD   10              // Shielded microprobe, transmissive

// Layout configuration bits in $LAY.config.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae

// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMSPLIT     0x20000000      // L&M auto split shuttle
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_SPLITAUTO   (LC_LMSPLIT|LC_A2LOADER)
#define LC_LMAUTO      (LC_LM|LC_A2LOADER)
#define LC_LMS2AUTO    (LC_LMS2|LC_A2LOADER)
#define LC_EPCOSAUTO   (LC_EPCOS|LC_A2LOADER)

// Type of automation.
#define AUTO_UNKNOWN   (-1)            // Unknown type of automation
#define AUTO_NONE      0x00            // Manual mode
#define AUTO_ERROR     0x01            // Attempt to get type was unsuccessfull
#define AUTO_DAMAGED   0x80            // Automation out of order
#define AUTO_SHUTTLE   0x81            // Automatic A2/A4/A6 shuttle
#define AUTO_A2        0x82            // Automatic A2 loader connected
#define AUTO_A4SEMI    0x83            // A4 output unit connected
#define AUTO_A4FULL    0x84            // Full A4 automation
#define AUTO_A6SEMI    0x85            // A6 output unit connected
#define AUTO_A6FULL    0x86            // Full A6 automation
#define AUTO_A5LMMAN   0x90            // A5 L&M automation in manual mode
#define AUTO_A5LMSEMI  0x91            // A5 L&M semiautomat
#define AUTO_A5LMFULL  0x92            // Full A5 L&M automation
#define AUTO_S2LMMAN   0x98            // S2 with manual shuttle
#define AUTO_S2LMSEMI  0x99            // S2 L&M in manual load/unload mode
#define AUTO_S2LMFULL  0x9A            // Full robotic S2 L&M automation
#define AUTO_S2LMDCF   0x9B            // S2 with double CF shuttle
#define AUTO_A7LMMAN   0xB0            // A7 L&M automation in manual mode
#define AUTO_A7LMSEMI  0xB1            // A7 L&M semiautomat
#define AUTO_A7LMFULL  0xB2            // Full A7 L&M automation
#define AUTO_A7LMNONE  0xB3            // A7 L&M pure manual mode
#define AUTO_A8LMMAN   0xB4            // A8a L&M automation in manual mode
#define AUTO_A8LMSEMI  0xB5            // A8a L&M semiautomat
#define AUTO_A8LMFULL  0xB6            // Full A8a L&M automation
#define AUTO_SPLITMAN  0xB8            // Split shuttle automation, manual mode
#define AUTO_SPLIT     0xBA            // Full split shuttle automation
#define AUTO_SPLNONE   0xBB            // Split shuttle automation, pure manual

// Configuration bits in extended layout.
#define EXT_CHECKZERO  0x00000001      // Correct X-Y zero pulses on soft reset
#define EXT_CONTAIR    0x00000100      // Individual no contact capacity in air
#define EXT_CAIR       0x00000200      // Field/capacity correction in air
#define EXT_CRTAIR     0x00000400      // MSD correction in air

// Z options in extended layout.
#define HCZ_VALID      0x80000000      // Z axis type in layout valid
#define HCZ_TESTPRLD   0x40000000      // Test pressure preload
#define HCZ_TYPEMAJOR  0x0F000000      // Major part of type (algorithms)
#define   HCZ_TMAJORA  0x00000000      // Parallelogramm with magnetoresistor
#define   HCZ_TMAJORC  0x01000000      // Ceramic stepper with Hall sensors
#define HCZ_TYPEMINOR  0x00F00000      // Minor part of type (parameters)
#define HCZ_TYPEMASK   0x0FF00000      // Mask to extract type of finger
#define   HCZ_TYPEA2G  0x00000000      // A2 gray parallelogramm
#define   HCZ_TYPEA2W  0x00100000      // A2 white parallelogramm
#define   HCZ_TYPEA3   0x00200000      // A3 gray parallelogramm
#define   HCZ_TYPECER  0x01000000      // S1 ceramic stepper with air bearings
#define   HCZ_TYPENO   0x0FF00000      // Z axis completely absent
#define HCZ_PWRMASK    0x000C0000      // Mask to extract Z motor power
#define   HCZ_PWRSTD   0x00000000      // Standard motor
#define HCZ_SUBCMASK   0x00030000      // Mask to extract needle subtype
#define   HCZ_SPLK4    0x00010000      // HCZ_CONTSPL is very soft K4 needle
#define HCZ_CONTMASK   0x0000FF00      // Mask to extract type of needle
#define   HCZ_CONTDEF  0x00000000      // Default needle, no contact sensor
#define   HCZ_CONTSPL  0x00000100      // Soft splinogramm with opto sensor
#define   HCZ_CONTHSPL 0x00000200      // Hard splinogramm with opto sensor
#define   HCZ_CONTEMU  0x00000400      // Standard needle on soft touch adapter
#define   HCZ_CONTHPS  0x00000500      // Hard touch needle with opto sensor
#define   HCZ_CONTSTD  0x00000800      // Standard needle, developed by IBM
#define   HCZ_CONTSKP  0x00001000      // Soft Kelvin with two parallelogramms
#define HCZ_STRMASK    0x000000F0      // Mask to extract Z stroke type
#define   HCZ_STRNORM  0x00000000      // Normal stroke
#define   HCZ_STRSOFT  0x00000010      // Soft stroke
#define   HCZ_STRHARD  0x00000020      // Hard stroke
#define   HCZ_LEARNZ   0x00000030      // Learned Z coordinate
#define   HCZ_HIPRESS  0x00000040      // High pressure with splinogramms
#define HCZ_DMSMASK    0x0000000C      // Mask for type of pressure sensor
#define   HCZ_DMSSTD   0x00000000      // Standard or no pressure sensor
#define   HCZ_DMSREV   0x00000004      // Pressure sensor with reverse signal
#define   HCZ_DMSAUTO  0x0000000C      // Autodetect type of pressure sensor
#define HCZ_OPTMASK    0x00000003      // Mask to extract Z options
#define   HCZ_NOOPT    0x00000002      // Do not optimize Z height
#define   HCZ_PARKZ    0x00000001      // Park top Z axes in home position

// Options of measurement card.
#define HCM_HV1MA      0x00000001      // Force 1 mA during HV measurements
#define HCM_STRICT     0x00000002      // 20% stricter self-test
#define HCM_NOCTCHK    0x00000004      // Don't check contacts (except ExactR)
#define HCM_PARCONT    0x00000008      // Check influence of parallel contacting
#define HCM_NOACCEL    0x00000010      // Do not accelerate reed relays
#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements
#define HCM_CTOEXT     0x00000040      // Calibrate capacity to shuttle (extant)
#define HCM_ISOEANT    0x00000080      // External antennas isolated
#define HCM_FILTMASK   0x00000F00      // Mask to extract signal filtering
#define   HCM_FNONE    0x00000000      // No signal filtering
#define   HCM_F500K    0x00000100      // 500 kHz filter
#define   HCM_F100K    0x00000200      // 100 kHz filter
#define   HCM_F20K     0x00000300      // 20/50 kHz filter
#define HCM_FILTERC    0x00001000      // Filter C measurements over 300 pF
#define HCM_EXRLONG    0x00002000      // Long EXACTR with 300 mA source
#define HCM_AUTOEANT   0x00004000      // Automatic antenna 1 for all C
#define HCM_HVTYPE     0x000F0000      // Mask to extract type of HV elecronics
#define   HCM_HV500    0x00000000      // Card is capable of 500 V HV
#define   HCM_HV1000   0x00010000      // Card is capable of 1000 V HV
#define   HCM_HVAUTO   0x00070000      // Autodetect HV capabilities
#define HCM_DISCONN    0x00100000      // Disconnect from bus after measurement
#define HCM_EXRNOISY   0x00200000      // Accept noisy EXACTR measurements

// Features supported by crate controller.
#define CF_PRESSFACT   0x00000001      // Support for psensfact
#define CF_RETEST      0x00000002      // Instant retest (M_LIMITHI, M_LIMITLO)
#define CF_CAMINFO     0x00000004      // Support for S_DEBUG:0x48
#define CF_EXTSELF     0x00000008      // Extended self-test, D_EXTA5M/SLAVE5M
#define CF_FINECORR    0x00000010      // Support for S_LOARDUN:18/19
#define CF_FINEVAR     0x00000020      // S_LOARDUN:18/19 with variable step
#define CF_XCORR       0x00000040      // Support for S_LOADRUN:17
#define CF_3DCOR       0x00000080      // Supports 3-D calibration
#define CF_LONGLAY     0x00000100      // Supports additional layout extentions

// Features supported by measurement card.
#define MF_CONTAIR     0x00000001      // Contact check corrections supported
#define MF_CRT         0x00000002      // CRT measurements supported
#define MF_KELVSCAN    0x00000004      // Kelvin scan supported
#define MF_FIXCDC      0x00000008      // Forcing charge-discharge in FastC
#define MF_CCORR       0x00000010      // Calibration of capacitive phase
#define MF_SLAVE       0x00000020      // Supports second measurement card
#define MF_CPHASE      0x00000040      // C phase corrections from layout
#define MF_MULTIC      0x00000080      // Multiple C supported
#define MF_DSCAN       0x00000100      // Charge-discharge scan supported
#define MF_CRTCONCE    0x00000200      // Permanent CRT calibration in air
#define MF_UNIC        0x00000400      // Universal C supported
#define MF_CONCE       0x00000800      // Permanent C calibration in air
#define MF_HVINITEX    0x00001000      // Extended HV initialization (meas card)
#define MF_POSTAIR     0x00002000      // C in air after M_FASTC (meas card)
#define MF_EXTMEAS     0x00004000      // External measurement device
#define MF_DMEM        0x00008000      // Read/write from Dallas memory (meas)
#define MF_RLIM        0x00010000      // Ordinary R with limits (meas)
#define MF_DATA        0x00020000      // Supports F_DATA
#define MF_FSCALE      0x00040000      // Field scales to default voltage
#define MF_XFIELD      0x00080000      // Extended field phase corrs (meas)
// Measurement features supported by crate.
#define MF_XFLDCRATE   0x00400000      // Extended field phase corrs (crate)
#define MF_RLIMCRATE   0x00800000      // Ordinary R with limits (crate)
#define MF_EXTLAINIT   0x01000000      // Extended S_LAINIT supported
#define MF_RETEST      0x02000000      // Instant retest (M_LIMITHI, M_LIMITLO)
#define MF_HVCRATEEX   0x04000000      // Extended HV initialization (crate)
#define MF_POSTCRATE   0x08000000      // C in air after M_FASTC (crate)
#define MF_RLINIT      0x10000000      // S_RLINIT supported (crate)
#define MF_DMEMCRATE   0x20000000      // Read/write from Dallas memory (crate)
#define MF_MULTICAL    0x40000000      // M_CALIBRATE supports multiple refs
// Reserved for high-level software, not used by crate.
#define MF_VALID       0x80000000      // Features valid

// Features supported by measurement card, set 2.
#define MF2_LACONT     0x00000001      // LATEST contact power limit supported

// Constants determining capacity adjustment actions.
#define ACT_QUIT       (-1)            // Quit capacity adjustment
#define ACT_CANCEL     0               // Finish capacity adjustment
#define ACT_ADJUST     1               // Adjust input capacities
#define ACT_CPHASE     2               // Adjust C phases
#define ACT_CRTADJ     3               // Adjust MSD capacities
#define ACT_CTEST      4               // Verify input capacities
#define ACT_CSHORT     5               // Verify high capacities
#define ACT_POT        6               // Test on-head potentiometers
#define ACT_RNEEDLE    7               // Adjust needle resistance
#define ACT_ZPRESS     8               // Test Z pressure
#define ACT_BDRILL     9               // Adjust backdrill needles

#define NPOINT         14              // Number of pads in X direction
#define VSTEP          0.5             // Camera moves in 0.5 mm steps
#define MAXERR         3.0             // Maximal error in fiducial position

#define NBASE          7               // Maximal number of bases

// Random deviation, in order to prevent pads from wearing out. Pads are at
// least 4*DELTA wide and 8*DELTA high.
#define DELTA          0.25            // Random deviation, millimeters

// To allow L&M board size adjustment, set ALLOWLMADJ to 1. Better not!
#define ALLOWLMADJ     0               // Allow L&M shuttle adjustment

// On-head sine and cosine adjustment factors for A2/3/4 and A5/6, multiply by
// relative deviation to get potentiometer bits.
#define DADJA2S        12000.0
#define DADJA5S        8000.0          // Up to 16000 for EL406 MUX
#define DADJA5C        10000.0
// Requested accuracy (maximum - minimum) of automatical on-head adjustment.
#define DADJLIMIT      10
// Expected results of field measurement test. Attention, 4 Volt version!
#define SINMIN         9500            // Minimal amplitude of sine component
#define SINMAX         22000           // Maximal amplitude of sine component
#define COSMIN         (-3800)         // Minimal amplitude of cosine component
#define COSMAX         (-750)          // Maximal amplitude of cosine component
#define FNOISE         20              // Maximal field sine/cosine noise
#define CMIN           5.0             // Minimal allowed capacity
#define CMAX           10.0            // Maximal allowed capacity
#define SADJMIN        0.01            // Minimal sine adjustment factor
#define CADJMIN        0.005           // Minimal cosine adjustment from sine
#define AUTOVLIMIT     50.0            // Limit for field autoverification, bits
// Capacity phase adjustment parameters.
#define NCPA           16              // Number of measurements per head
#define CHIGHMIN       27.0            // Minimal capacity of pads against GND
#define CHIGHMAX       75.0            // Maximal capacity of pads against GND
#define CHIXLMIN       70.0            // Minimal C of pads, A7 XXL board
#define CHIXLMAX       90.0            // Maximal C of pads, A7 XXL board
#define CHI24MIN       90.0            // Minimal C of pads, A7/24 board
#define CHI24MAX       120.0           // Maximal C of pads, A7/24 board
#define CPHASE         0.0005          // Maximal allowed C phase difference
// MSD (CRT) parameters.
#define CCMIN          4.0             // Minimal capacity of dedicated C, pF
#define CCMAX          7.5             // Maximal capacity of dedicated C, pF
#define MSDU           250             // Test voltage, volts
#define MSDDMAX        50.0            // Maximal allowed MSD disbalance
#define MSDQMAX        12.0            // Maximal allowed MSD quality factor

external int SERV.Decodeanswer(char *answer,char *s,char *extra,int mask)
external int SERV.Convertfield(char *answer,float *zc,float *zr);
external int SERV.Convertfastc(char *answer,float *zc,float *zr);

typedef struct t_extlay $EXTLAY;
typedef struct t_ext0   $EXT0;         // First additional layout extention
typedef struct t_ext1   $EXT1;         // Second additional layout extention
typedef struct t_ext2   $EXT2;         // Third additional layout extention
typedef struct t_ext3   $EXT3;         // Fourth additional layout extention

char   xnamed[NPOINT][20] = {        \ // Components on dedicated board
  "BDREF  -5     0",                 \ // Pro forma, backdrill reference
  "NOCT1  -5     0",                 \ // Left no contact
  "SIG    0      0",                 \ // Signal pad (X=0 by definition)
  "C      30     0",                 \ // C adjust pad
  "BRUSH  42.5   0",                 \ // Position of cleaning brush
  "GND    50     0",                 \ // Ground pad
  "OWNC2  51.5   0",                 \ // Second point to measure own capacity
  "NOCT2  55     0",                 \ // Right no contact
  "HOLE1  55     0",                 \ // Pro forma, no hole on dedicated board
  "HOLE2  55     0",                 \ // Ditto
  "HOLE3  55     0",                 \ // Ditto
  "HOLE4  55     0",                 \ // Ditto
  "HOLE5  55     0",                 \ // Ditto
  "HOLE6  55     0" }                  // Ditto

char   xnamec[NPOINT][20] = {        \ // Components on combo R/C board
  "BDREF  -70    0",                 \ // Backdrill reference
  "NOCT1  -64    0",                 \ // Left no contact
  "SIG    -58.65 0",                 \ // Signal pad (X=0 by definition)
  "C      -39.10 0",                 \ // C adjust pad
  "BRUSH  -30    0",                 \ // Position of cleaning brush (absent)
  "GND    -19.55 0",                 \ // Ground pad
  "OWNC2  -15.55 0",                 \ // Second point to measure own capacity
  "NOCT2  -15.55 0",                 \ // Right no contact
  "HOLE1  -19.55 0",                 \ // Hole 0.5 mm for backdrill alignment
  "HOLE2  0      0",                 \ // Hole 0.6 mm for backdrill alignment
  "HOLE3  19.55  0",                 \ // Hole 0.7 mm for backdrill alignment
  "HOLE4  39.10  0",                 \ // Hole 0.8 mm for backdrill alignment
  "HOLE5  58.65  0",                 \ // Hole 0.9 mm for backdrill alignment
  "HOLE6  78.20  0" }                  // Hole 1.0 mm for backdrill alignment

char   xname[NPOINT][20]               // Components on the board

float  xpos[NPOINT]                    // Extracted X coordinate of the pad
float  value[NPOINT]                   // Extracted value associated with pad
int    scanrail=-1                     // -1: scan crosses, >=0: scan pads

float  origcrossx[2] = {             \ // X coords of crosses on dedicated board
  25.0,  25.0 }
float  origcrossy[2] = {             \ // Y coords of crosses on dedicated board
  -30.0, 340.0 }

float  crossx[2]                       // Working copy of origcrossx
float  crossy[2]                       // Working copy of origcrossy
int    crosstype                       // Crosses used for scanning
float  crossdist                       // Expected distance between crosses

handle hmain                           // Main window
handle hserv,hleft,hright              // Left and right subwindows
handle hinfo                           // Current status of test
handle hexit                           // Button "Close"
handle hgraph                          // Graph window in C adjust screen

handle hlog                            // Log file

// Individual per-camera brightness and contrast.
int    individualbc                    // Whether individual brightness/contrast
handle hbrititle                       // Brightness title
handle hbrightness                     // Brightness control
handle hctrtitle                       // Contrast title
handle hcontrast                       // Contrast control
handle hilltop                         // Top illumination control
handle hillskew                        // Skew illumination control
handle hilllong                        // Long exposition control
handle hfoctitle                       // Focus title
handle hfocusup                        // Focus up
handle hfocus                          // Z camera position
handle hfocusdn                        // Focus down

int    cameras                         // Dedicated cameras used in test
int    headcams                        // Head cameras used in test
int    illtype                         // Illumination (0x3:on,0x4:top,0x8:skew)
int    longexp                         // Long exposition
int    focus[2]                        // Focus position of dedicated camera
int    brightness[32]                  // Individual brightness settings
int    contrast[32]                    // Individual contrast settings
int    bchead                          // Head selected for individual bri/ctr
int    updatefocus[2]                  // Set focus of dedicated camera

char   crateversion[128]               // Version of loaded crate software
char   layoutversion[128]              // Version of loaded layout
char   headversion[128]                // Version of loaded head software
int    cratefeatures                   // Features of crate, set of CF_xxx
int    measfeatures                    // Features of measurement card, MF_xxx
int    measfeatures2                   // Features of measurement card, MF2_xxx
int    allowz                          // Whether phase potentiometer present
int    automationtype                  // Type of automation, AUTO_xxx
int    isauto                          // Whether half- or full-automate
int    layoutchanged                   // Layout is changed
int    loadchanged                     // Loader is closed
int    layoutdiffers                   // Layout in tester differs from backup
int    globalerr                       // Global asynchronous error recognized
int    oversurface[32]                 // No. of contacts over surface per head
int    used[32]                        // Head is allowed for adjustment
int    fixed[32]                       // Whether potentiometer is locked
float  ps[32],pc[32]                   // Settings of Dallas potis (sin & cos)
int    boardtype                       // 0: old, 1: combo, 2: A7 XXL, 3: A7/24
float  rowdist                         // Distance between rows of pads, mm
int    wideboard                       // Whether wide A5a dedicated board
float  ypos[32]                        // Y coordinate of pads (board coords)
float  yshift                          // Vertical shift of test board
int    testertype                      // Type of tester (TT_xxx)
int    testersides                     // Bit 0x1: top, 0x2: bottom rails
int    usesides                        // Bit 0x1: top, 0x2: bottom rails
int    firstrail                       // First rail on the top/only side
int    lastrail                        // Last rail on the top/only side
int    maxrail                         // Highest rail on the top/only side
int    backdrill                       // Bitmask of backdrill needles
int    simplemode                      // "Only adjust"
float  leftvlimit                      // Left X limit for video camera
float  rightvlimit                     // Right X limit for video camera
float  pos1x,pos1y                     // First ref cross (tester coordinates)
float  pos2x,pos2y                     // Second ref cross (tester coordinates)
float  linewidth                       // Expected width of cross, 200 or 300 um
float  headcamradius                   // Radius of head cameras, millimeters
float  dadjfactors                     // Adjustment factor for sine potis
float  dadjfactorc                     // Adjustment factor for cosine potis
int    stopatlimit                     // Accept alignment if limit is reached
char   lmteachin[5][256]               // Learned shuttle settings
int    nlmteachin                      // Number of valid lmteachin
int    pulledshuttle                   // Shuttle for A8eaPreparePullCalib or -1
int    loganswers=1                    // Whether to protocol answers
int    fvalid[8]                       // Whether head data is valid
float  gs[8],gc[8]                     // Mean field sine/cosine for each head
float  ss,cs                           // Mean field sine/cosine for the group
float  cc[8]                           // Capacity for the group
int    maxsin                          // Head in group with maximal sine diff
int    strokev=50                      // Stroke, mm/s
int    strokep=30                      // Pressure, gramm
float  strokez=5.0                     // Height, millimeters

float  shuttlex,shuttley               // Position of board in shuttle
float  convsfi,convcfi                 // Rotation and shrinkage of board
float  convdx,convdy                   // Offset of board

// Local backup copy of layout extentions.
struct t_extlay lx
struct t_ext0   lx0
struct t_ext1   lx1
struct t_ext2   lx2
struct t_ext3   lx3

// Interrupt handler, receives and processes asynchronous messages and errors.
function int Answerproc(char *answer,int info)
  int i
  if answer[4]==0xF0 then              // Internal OLLYTEST message
    if Stricmp(answer+5,"CHG LAY")==0 layoutchanged=1
    if Stricmp(answer+5,"CHG LOAD")==0 loadchanged=1
    return
  else if answer[4]==S_ERROR then      // Error messages, also with zero ID
    switch answer[5]
    case E_NOCRATDATA,E_NOFINGDATA:
      globalerr=globalerr|GE_BOOT
    case E_ZMOVEMENT:
      if answer[9]==2 && answer[7]!=0xFF then
        i=answer[7]*2+((answer[8] & 0x4C)==0?1:0)
        oversurface[i]++               // Count number of contacts over PCB
      endif
    case E_COMMUTATOR:
      i=$uint2(answer+10)
      if (i & 0x0300)!=0 globalerr=globalerr|GE_MEAS
    case E_TMEAS:
      if answer[9]>=2 globalerr=globalerr|GE_MEAS
    case E_IOERROR:
      // Serial I/O errors are considered non-critical for A5 and above.
      if testertype!=TT_A5 && testertype!=TT_A5L &&                            \
        testertype!=TT_A6 && testertype!=TT_S1 && testertype!=TT_S2 &&         \
        testertype!=TT_S3 && testertype!=TT_A7 && testertype!=TT_A8 then
        globalerr=globalerr|GE_IOERROR
      endif
    case E_WRONGCOORD,E_BADCOMMAND,E_BADCMDSIZE,E_TABLEOVERF,E_BADDATA:
      globalerr=globalerr|GE_COMMAND
    case E_SYNC,E_DIVBYZERO:
      globalerr=globalerr|GE_COMMAND
    case E_CONTACT,E_HISHIFT,E_SHORTCUT:
      globalerr=globalerr|GE_MEAS
    case E_INITMEAS:
      i=$uint2(answer+10)
      if (i & 0x7D)!=0 globalerr=globalerr|GE_MEAS
    case E_BOXSENS,E_PNEUMOSENS,E_PNEUMOSYS:
      globalerr=globalerr|GE_HARDWARE
    endsw
  endif
end

function int Initsigma(float disp[])
  disp[0]=0.0
  disp[1]=0.0
  disp[2]=0.0
  disp[3]=0.0
  disp[4]=0.0
end

// Function adds next measured value to array disp[5] which accumulates data
// necessary to calculate normal dispersion, mean, minimal and maximal.
function int Addsigma(float disp[],float value)
  if disp[0]<=0.0 then
    disp[0]=1.0                        // First point, data is still undefined
    disp[1]=value
    disp[2]=value*value
    disp[3]=value
    disp[4]=value
  else
    disp[0]=disp[0]+1.0
    disp[1]=disp[1]+value
    disp[2]=disp[2]+value*value
    disp[3]=Min(disp[3],value)
    disp[4]=Max(disp[4],value)
  endif
end

// Function returns number of data items gathered by Addsigma().
function int Getcount(float disp[])
  return disp[0]
end

// Function calculates mean value based on data gathered by Addsigma().
function float Getmean(float disp[])
  if disp[0]<1.0 then
    return 0.0
  else
    return disp[1]/disp[0]
  endif
end

// Function calculates mean value based on data gathered by Addsigma(). If
// number of measurements is 8 or more, minimum and maximum are not taken into
// account.
function float Getxmean(float disp[])
  if disp[0]<1.0 then
    return 0.0
  else if disp[0]>=8.0 then
    return (disp[1]-disp[3]-disp[4])/(disp[0]-2.0)
  else
    return disp[1]/disp[0]
  endif
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmin(float disp[])
  return disp[3]
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmax(float disp[])
  return disp[4]
end

// Function calculates normal dispersion based on data gathered by Addsigma().
function float Getsigma(float disp[])
  float r
  if disp[0]<2.0 then
    return 0.0
  else
    r=(disp[0]*disp[2]-disp[1]*disp[1])/disp[0]/(disp[0]-1.0)
    if r<=0 then
      return 0.0
    else
      return Sqrt(r)
    endif
  endif
end

// Calculates parabolic curve y=a*(x-x0)**2+z0 through n equidistant points
// y[-n/2],y[-n/2+1],..,y[n/2] (n must be odd integer) using best fit in the
// sense of least squares.
function int Parabint(float y[],int n,float *a,float *x0,float *z0)
  int i,j
  float sy,sxy,sxxy,sx,sxx,sx3,sx4,q1,q2,q3,p1,p2,p3,pq,b,c
  sy=0.0; sxy=0.0; sxxy=0.0; sx=0.0; sxx=0.0; sx3=0.0; sx4=0.0
  for i=0,i<n,i++ do
    j=i-n/2
    sy=sy+y[i]; sxy=sxy+j*y[i]; sxxy=sxxy+j*j*y[i]
    sx=sx+j; sxx=sxx+j*j; sx3=sx3+j*j*j
    sx4=sx4+(j*j*1.0)*j*j              // Beware of overflows
  enddo
  q1=sx3-sx*sxx/n
  q2=sxx-sx*sx/n
  q3=sxy-sx*sy/n
  p1=sx4-sxx*sxx/n
  p2=sx3-sxx*sx/n
  p3=sxxy-sy*sxx/n
  pq=p1*q2-p2*q1
  if pq==0 then
    a[0]=0.0
  else
    a[0]=(p3*q2-q3*p2)/pq
  endif
  if q2==0 then
    b=0.0
  else
    b=(q3-a[0]*q1)/q2
  endif
  c=(sy-a[0]*sxx-b*sx)/n
  if a[0]==0 then
    x0[0]=0
  else
    x0[0]=-b/2.0/a[0]
  endif
  z0[0]=c-a[0]*x0[0]*x0[0]
end

// Writes record to c:\hardware\calibrationlog.txt. Returns 0 on success and -1
// on error.
function int Addcalibrationrecord(format message)
  handle f
  char s[256]
  f=Fopen("c:\\atg\\hardware\\calibrationlog.txt","at")
  if f==NULL f=Fopen("c:\\hardware\\calibrationlog.txt","at")
  if f==NULL return -1
  Strtime(s,"%a %d-%b-%Y %H:%M",0,0)
  fprintf(f,"%s     Ctest v%s  %s\n",s,VERSION,message)
  Fclose(f)
  return 0
end

// Given video channel, returns head that carries corresponding video camera,
// or -1 if channel is invalid or not assigned.
function int Headfromchannel(int channel)
  int head,n
  if $LAY.cameras!=0 then
    if channel==0 return $LAY.nfing*2
    if channel==1 return $LAY.nfing*2+1
  else
    n=0
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      if channel==n return head
      n++
    enddo
  endif
  return -1
end

// Given head, returns associated video channel, or -1 if head is invalid or
// carries no camera.
function int Channelfromhead(int head)
  int i,channel
  if $LAY.cameras!=0 then
    if head==$LAY.nfing*2 return 0
    if head==$LAY.nfing*2+1 return 1
  else if ($LAY.headcameras & (1<<head))!=0 then
    channel=0
    for i=0,i<head,i++ do
      if ($LAY.headcameras & (1<<i))!=0 channel++
    enddo
    return channel
  endif
  return -1
end

// Given Y coordinate in millimeters, selects camera controller and
// corresponding video channel. Points on the border can be scanned by both
// rails. Returns head on success, and -1 on any error.
function int Camerafromy(float y,int *channel,int *side,float *angle)
  int head
  float h
  if $LAY.cameras!=0 then
    if ($LAY.cameras & 0x3)==0x1 then
      channel[0]=0
    else if ($LAY.cameras & 0x3)==0x2 then
      channel[0]=1
    else if ($int2($LAY+764) & 0x4000)!=0 then
      channel[0]=1
    else
      channel[0]=0
    endif
    side[0]=channel[0]
    angle[0]=0.0
    return $LAY.nfing*2+channel[0]
  else if $LAY.headcameras!=0 then
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      if ($LAY.excludedrails & (1<<(head/2)))!=0 continue
      if scanrail>=0 then
        if scanrail==head/2 break
      else
        if $LAY.top[head/2]/1000.0<y continue
        if $LAY.bottom[head/2]/1000.0>y continue
        break
      endif
    enddo
    if head>=$LAY.nfing*2 return -1
    channel[0]=Channelfromhead(head)
    side[0]=$LAY.side[head/2]
    h=y-$LAY.yoffset[head/2]/1000.0
    angle[0]=(Abs(h)>0.9*headcamradius?0.0:Asin(h/headcamradius))
    if side[0]!=0 angle[0]=-angle[0]
    if (head & 1)!=0 angle[0]=-angle[0]
    return head
  else
    return -1                          // No cameras
  endif
end

// Given Y coordinate in millimeters and side, selects camera controller and
// corresponding video channel. Returns head on success, and -1 on any error.
function int Camerafromyside(float y,int side,int *channel,float *angle)
  int j,head
  float h,headcamradius
  if $LAY.cameras!=0 then
    if ($LAY.cameras & (1<<side))==0 return -1
    channel[0]=side
    angle[0]=0.0
    return $LAY.nfing*2+side
  else if $LAY.headcameras!=0 then
    j=0
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      j++
      if ($LAY.excludedrails & (1<<(head/2)))!=0 continue
      if $LAY.side[head/2]!=side continue
      if $LAY.top[head/2]/1000.0<=y continue
      if $LAY.bottom[head/2]/1000.0>y continue
      break
    enddo
    if head>=$LAY.nfing*2 return -1
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else if $LAY.top[0]-$LAY.bottom[0]>160000 then
      headcamradius=153.0
    else
      headcamradius=118.0
    endif
    h=y-$LAY.yoffset[head/2]/1000.0
    angle[0]=(Abs(h)>0.9*headcamradius?0.0:Asin(h/headcamradius))
    if side!=0 angle[0]=-angle[0]
    if (head & 1)!=0 angle[0]=-angle[0]
    channel[0]=j-1
    return head
  else
    return -1                          // No cameras
  endif
end

// Reads individual per-camera brightness, contrast, illumination type and
// focal coordinate from .ini file.
function int Bcgetini()
  int head,bri,ctr
  char key[32]
  // Get defaults for the first run.
  illtype=0x03; longexp=0;
  getini("Video","Illumination type","%i,%i",&illtype,&longexp)
  bri=0; getini("ScrollAutoSave","Brightness","%i",&bri)
  ctr=0; getini("ScrollAutoSave","Contrast","%i",&ctr)
  focus[0]=-1000; getini("Video","Ctest focus[0]","%i",focus+0)
  focus[1]=-1000; getini("Video","Ctest focus[1]","%i",focus+1)
  for head=0,head<32,head++ do
    brightness[head]=bri
    contrast[head]=ctr
    if individualbc then
      sprintf(key,"Brightness[%i]",head)
      getini("Video",key,"%i",brightness+head)
      sprintf(key,"Contrast[%i]",head)
      getini("Video",key,"%i",contrast+head)
    endif
  enddo
end

// Saves individual per-camera brightness and contrast values to .ini file
function int Bcsetini()
  int head
  char key[32]
  setini("Video","Illumination type","%i,%i",illtype,longexp)
  setini("Video","Ctest focus[0]","%i",focus[0])
  setini("Video","Ctest focus[1]","%i",focus[1])
  if individualbc==0 then
    // No individual settings.
    setini("ScrollAutoSave","Brightness","%i",brightness[0])
    setini("ScrollAutoSave","Contrast","%i",contrast[0])
  else
    // Individual per-camera settings.
    for head=0,head<($LAY.nfing+1)*2,head++ do
      if cameras!=0 then
        if head<$LAY.nfing*2 continue
        if (cameras & (1<<(head-$LAY.nfing*2)))==0 continue
      else
        if (headcams & (1<<head))==0 continue
      endif
      sprintf(key,"Brightness[%i]",head)
      setini("Video",key,"%i",brightness[head])
      sprintf(key,"Contrast[%i]",head)
      setini("Video",key,"%i",contrast[head])
    enddo
  endif
end

// Connects brightness and contrast controls to the specified head.
function int Bcsetcam(int channel)
  int head
  if individualbc==0 return
  head=Headfromchannel(channel)
  if head==bchead then
    return
  else if head>=0 && head<32 then
    if hbrightness!=NULL change hbrightness select=brightness[head]
    if hcontrast!=NULL change hcontrast select=contrast[head]
    if hfocus!=NULL && (head==$LAY.nfing*2 || head==$LAY.nfing*2+1) then
      change hfocus text=format(" %i",focus[head-$LAY.nfing*2])
    endif
    bchead=head
  else
    bchead=-1
  endif
end

// Creates brightness, contrast and illumination or focus controls at the
// specified location (default location if x and y are -1).
function int Bccreate(handle hparent,int x,int y,int channel,int mode)
  if x<0 x=5
  if y<0 y=303
  if mode!=0 then
    if testertype==TT_S3 then
      mode=2                           // Create focus controls
    else if (testertype==TT_A7 || testertype==TT_A8) then
      mode=1                           // Create illumination controls
    else
      mode=0
    endif
  endif
  hbrititle=control TEXT
    window=hparent
    position=x,y+4,27,16
    name="明"
    help=" "
    font=INFOFONT
  endc
  hbrightness=control HSCROLL
    window=hparent
    position=x+32,y+2,(mode?120:150),21
    name=(individualbc?"":"亮度")
    help=format("调整所选相机%s",                                  \
      individualbc?" 的图像增益":"")
    limits=-100,100
  endc
  hctrtitle=control TEXT
    window=hparent
    position=x,y+31,27,16
    name="对"
    help=" "
    font=INFOFONT
  endc
  hcontrast=control HSCROLL
    window=hparent
    position=x+32,y+29,(mode?120:150),21
    name=(individualbc?"":"对比度")
    help=format("调整所选相机%s",                       \
      individualbc?" 的图像曝光时间":"")
    limits=-100,100
  endc
  if mode==1 then
    // Illumination controls.
    hilltop=control CHECKBOX
      window=hparent
      position=x+160,y,50,18
      name="顶光"
      help="打开顶部照明,对所有相机都有效"
      font=INFOFONT
      mode=((illtype & 0x0C)==0 || (illtype & 0x4)!=0?M_CHECKED:0)
    endc
    hillskew=control CHECKBOX
      window=hparent
      position=x+160,y+18,55,18
      name="偏光"
      help="打开侧面照明,对所有相机都有效"
      font=INFOFONT
      mode=((illtype & 0x08)!=0?M_CHECKED:0)
    endc
    hilllong=control CHECKBOX
      window=hparent
      position=x+160,y+36,55,18
      name="高亮"
      help="长时间曝光,仅适用于选定的相机"
      font=INFOFONT
      mode=(longexp?M_CHECKED:0)
    endc
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  else if mode==2 then
    // Focus controls.
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=control TEXT
      window=hparent
      position=x+160,y+31,45,16
      name="聚焦"
      help=" "
      font=INFOFONT
    endc
    hfocusup=control BUTTON
      window=hparent
      position=x+205,y+29,21,21
      name="-"
      help="按住可向上移动相机"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hfocus=control TEXT
      window=hparent
      position=x+225,y+29,62,21
      help="当前相机的Z坐标,微米"
      font=MEDIUMFONT
      mode=M_BORDER
      bkcolor=LIGHTYELLOW
      color=DARKGRAY
    endc
    hfocusdn=control BUTTON
      window=hparent
      position=x+286,y+29,21,21
      name="+"
      help="按住可向下移动相机"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
  else
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  endif
  bchead=-1
  Bcsetcam(channel)
end

// Checks whether user has changed brightness, contrast or illumination and
// updates data. Returns combination of 0x01 (if brightness or contrast was
// changed) and 0x02 (if illumination type was changed). Additionally, sets
// S3 focus.
function int Bcupdate()
  int head,cam,changed,n
  char s[128]
  if individualbc==0 then
    head=0
  else if bchead<0 || bchead>=32 then
    return 0
  else
    head=bchead
  endif
  changed=0
  if hbrightness!=NULL && Pressed(hbrightness) then
    brightness[head]=Status(hbrightness)
    changed=changed | 0x01
  endif
  if hcontrast!=NULL && Pressed(hcontrast) then
    contrast[head]=Status(hcontrast)
    changed=changed | 0x01
  endif
  if hilltop!=NULL && Pressed(hilltop) then
    if Status(hilltop)!=0 then
      illtype=illtype|0x04
    else
      illtype=illtype & (~0x04)
      if (illtype & 0x0C)==0 then
        illtype=0x0B
        change hillskew mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hillskew!=NULL && Pressed(hillskew) then
    if Status(hillskew)!=0 then
      illtype=illtype|0x08
    else
      illtype=illtype & (~0x08)
      if (illtype & 0x0C)==0 then
        illtype=0x07
        change hilltop mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hilllong!=NULL && Pressed(hilllong) then
    longexp=Status(hilllong)
    changed=changed | 0x01
  endif
  if hfocus!=NULL then
    n=Min(Pressed(hfocusdn),3)
    n=n-Min(Pressed(hfocusup),3)
    cam=head-$LAY.nfing*2
    if n!=0 && (cam==0 || cam==1) then
      focus[cam]=Max(-8000,Min(focus[cam]+n*20,8000))
      change hfocus text=format(" %i",focus[cam])
      updatefocus[cam]=1
    endif
  endif
  if testertype==TT_S3 then
    if ($LAY.cameras & 0x1)!=0 && updatefocus[0]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+0,focus[0])
      SERV.Cmdimm(32,s)
      updatefocus[0]=0
    endif
    if ($LAY.cameras & 0x2)!=0 && updatefocus[1]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+1,focus[1])
      SERV.Cmdimm(32,s)
      updatefocus[1]=0
    endif
  endif
  return changed
end

// Deletes brightness and contrast controls. It's not a sin to forget to call
// this function, but then better not call any Bcxxx() except Bccreate() or
// Bcdisable().
function int Bcdelete()
  if bchead<0 return
  destroy hbrititle; hbrititle=NULL
  destroy hbrightness; hbrightness=NULL
  destroy hctrtitle; hctrtitle=NULL
  destroy hcontrast; hcontrast=NULL
  bchead=-1
  if hilltop!=NULL then
    destroy hilltop; hilltop=NULL
    destroy hillskew; hillskew=NULL
    destroy hilllong; hilllong=NULL
  endif
  if hfocus!=NULL then
    destroy hfoctitle; hfoctitle=NULL
    destroy hfocusup; hfocusup=NULL
    destroy hfocus; hfocus=NULL
    destroy hfocusdn; hfocusdn=NULL
  endif
end

// Disables brightness and contrast processing in the case that corresponding
// controls were not deleted by Bcdelete()
function int Bcdisable()
  hbrititle=NULL
  hbrightness=NULL
  hctrtitle=NULL
  hcontrast=NULL
  bchead=-1
  hilltop=NULL
  hillskew=NULL
  hilllong=NULL
  hfoctitle=NULL
  hfocusup=NULL
  hfocus=NULL
  hfocusdn=NULL
end

// Returns current brightness (-100..100) for the specified channel.
function int Bcgetbri(int channel)
  int head
  if individualbc==0 then
    return brightness[0]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return brightness[head]
  endif
end

// Returns current contrast (-100..100) for the specified head.
function int Bcgetctr(int channel)
  int head
  if individualbc==0 then
    return contrast[0]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return contrast[head]
  endif
end

// Clears contact-over-surface counters
function int Clearoversurface()
  int i
  for i=0,i<32,i++
    oversurface[i]=0
  enddo
end

// Assure that tester is loaded and that debug mode does not make test void.
function int Loadtester()
  int i,j,t,err,nframes
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="软件复位"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK
  draw at 6,30 text="初始化设备, 稍等... "
  draw show
  delay 500
  SYS.Softimm(0)
  t=Time(); i=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("等待软件复位 - %i s",j)
      i=j
    endif
    if j>15 break
    wait
  enddo
  clear hright
  draw window=hright font=TIMESFONT
  if $A[0].length==0 then
    change hinfo name="机箱无应答"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is off\n"
    draw text="- Flying Debugger or Test Player is running\n"
    draw text="- Crash in embedded software\n"
    draw text="- Optocable is pulled out\n"
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    while 1 do
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      wait
    enddo
  else if $A[0].answer==S_ERROR &&                                             \
    ($A[0].subcmd==E_NOCRATDATA || $A[0].subcmd==E_NOFINGDATA) then
    change hinfo name="测试器未加载"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="The Flying Probe Tester is not loaded. Of course, it "
    draw color=LIGHTRED text="must " color=BLACK
    draw text="be loaded before you can start test. Typically, all you "
    draw text="need is to press 'Load all' in the appearing window. "
    if $GLOBAL.disabledrails!=0 then
      draw text="Please check for rails disabled in the Debug mode. "
    endif
    if ($GLOBAL.debugmode & 0x20BF)!=0 || ($GLOBAL.videomode & 0x20BF)!=0 ||   \
      $uint4($GLOBAL+280)!=0 then
      draw color=LIGHTRED
      draw text="Please also check that current Debug mode really allows you "
      draw text="to adjust capacity!"
    endif
    err=SYS.Videosize(0,&i,&j,&nframes);
    if err!=0 || nframes==0 then
      draw color=BLACK
      draw text="\nNote also that frame grabber in your system is not "
      draw text="accessible. Either it is absent, or not installed, or "
      draw text="OllyTest was unable to locate support DLLs."
    else if nframes<4 then
      draw color=BLACK
      draw text="\nNote also that amount of memory allocated to frame grabber "
      draw text="is too low which may cause problems during the test. We "
      draw text="recommend that you set frame buffer to 2 Mb."
    endif
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if $A[0].answer!=S_RESET then
    change hinfo name="软重置错误"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="Flying Probe Tester returned some unexpected answer. Normally, "
    draw text="this never happens. All I may suggest is to press Hard Reset "
    draw text="and then reboot the tester. "
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  endif
  return 0
end

function int Getlayout()
  int i,j,t,ident,err
  char buf[16]
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="获取布局"
  delay 300
  buf[0]=S_LAYOUT
  buf[1]=0x03                          // Read layout with corrected phases
  ident=SYS.Sendimm(0,2,buf)
  t=Time(); i=0; err=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("等待布局 - %i s",j)
      i=j
    endif
    if j>15 break
    wait
  enddo
  if $A[0].length==0 then
    err=2
  else if $A[0].answer!=S_LAYOUT || $A[0].length!=774 then
    err=1
  else
    // Layout received. Get layout extentions.
    Memcpy($LAY,$A[0]+6,768)
    for i=0,i<16,i++                   // Same offsets in tester & inner copy
      $LAYCORR.leftzerox[i]=$LAY.leftzerox[i]
      $LAYCORR.leftzeroy[i]=$LAY.leftzeroy[i]
      $LAYCORR.rightzerox[i]=$LAY.rightzerox[i]
      $LAYCORR.rightzeroy[i]=$LAY.rightzeroy[i]
    enddo
    if $LAY.extlay>=1 then
      buf[0]=S_LAYOUT
      buf[1]=15                        // Read main layout extention
      SYS.Sendimm(0,2,buf)
    endif
    for j=1,j<$LAY.extlay && j<5,j++ do
      buf[0]=S_LAYOUT
      buf[1]=20                        // Read additional layout extention
      $int4(buf+2)=j-1                 // Index
      SYS.Sendimm(j,6,buf)
    enddo
    i=-1
    while 1 do
      for j=0,j<$LAY.extlay && j<5,j++ do
        if $A[j].length==0 break
        if $A[j].answer!=S_LAYOUT || $A[j].length!=(j==0?774:778) then
          err=1; break                 // Invalid answer
        endif
      enddo
      if err!=0 || j>=$LAY.extlay break
      if Pressed(hexit) return -1
      j=(Time()-t)/1000
      if i!=j then
        change hinfo text=format("等待布局 - %i s",j)
        i=j
      endif
      if j>15 then
        err=2; break                   // Timeout!
      endif
      wait
    enddo
    if err==0 then
      if $LAY.extlay==0 then
        i=0
      else
        for i=0,i<768,i++ do
          if $char($A[0]+6+i)!=0 break
        enddo
      endif
      if i==768 then
        err=4
      else
        Memcpy($EXTLAY,$A[0]+6,768)
        if $LAY.extlay>=2 then
          Memcpy($EXT0,$A[1]+10,768)
        else
          Memset($EXT0,0,768)
        endif
        if $LAY.extlay>=3 then
          Memcpy($EXT1,$A[2]+10,768)
        else
          Memset($EXT1,0,768)
        endif
        if $LAY.extlay>=4 then
          Memcpy($EXT2,$A[3]+10,768)
        else
          Memset($EXT2,0,768)
        endif
        if $LAY.extlay>=5 then
          Memcpy($EXT3,$A[4]+10,768)
        else
          Memset($EXT3,0,768)
        endif
      endif
    endif
    SYS.Broadcast(8,"CHG LAY")         // Inform others that layout changed
  endif
  if err==0 then
    buf[0]=S_DUMP                      // Get version of embedded software
    buf[1]=255                         // Request to crate controller
    buf[2]=0x14                        // Get software version
    $uint2(buf+3)=0                    // Number of items
    $uint2(buf+5)=0                    // Start item
    ident=SYS.Sendimm(0,7,buf)
    change hinfo text="获取软件版本"
    delay 300
    t=Time(); i=0; err=0
    while $A[0].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as an interrupt
      if (Time()-t)>5000 break         // Timeout 5 seconds
      wait
    enddo
    if $A[0].length==0 then
      err=2
    else if $A[0].answer==S_DUMP then  // Correct answer, extract subfields
      j=5
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(crateversion,$A[0]+j)
      j=i
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(layoutversion,$A[0]+j)
      j=i
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(headversion,$A[0]+j)
    else
      err=3
    endif
  endif
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if err==1 || err==3 || err==4 then
    if err==1 then
      change hinfo text="Error getting layout"
      draw text="The script was unable to get layout correctly. "
    else if err==3 then
      change hinfo text="Error getting version"
      draw text="The script was unable to get version of loaded software. "
    else
      change hinfo text="Error getting layout"
      draw text="Main layout extention is missing or zeroed. "
    endif
    draw text="This error is absolutely unexpected here. Perharps, the best "
    draw text="way to recover is to reboot the tester. If you select this "
    draw text="option, then in the appearing window first press 'Hard reset', "
    draw text="then 'Load all'. After the tester is loaded, try again."
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以重新加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试获取布局或读取软件版本"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if err==2 then
    change hinfo text="No answer from crate"
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is off\n"
    draw text="- Flying Debugger or Test Player is running\n"
    draw text="- Crash in embedded software\n"
    draw text="- Optocable is pulled out\n"
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    while 1 do
      if Pressed(hretry) break
      if Pressed(hexit) return -1
      wait
    enddo
  else
    leftvlimit=($LAY.leftlimit+$LAY.videodeadx)/1000.0+MAXERR
    rightvlimit=($LAY.rightlimit-$LAY.videodeadx)/1000.0-MAXERR
  endif
  return err
end

// Check whether some critical error was detected, such as broken cable, absent
// measurement card, damaged locks etc. Returns 0 if test should continue, 1 if
// tester to be rebooted, or -1 if operator decided to interrupt the test.
function int Checkgloberrors()
//////////////!!! ADD (smart) SOFT RESET HERE
  int err
  handle hcont,hboot
  if globalerr==0 return 0
  change hinfo limits=0,0
  change hinfo text="侦测到错误"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED text="Critical error detected!"
  draw at 6,60 color=BLACK
  if globalerr & GE_BOOT then
    draw text="Tester is not booted. Perharps somebody pressed emergency "
    draw text="switch, or surge caused crash of embedded software. "
    err=1
  else if globalerr & GE_HARDWARE then
    draw text="Embedded software discovered some problems with shuttle. Please "
    draw text="check sensors and pneumatics. "
    err=0
  else if globalerr & GE_IOERROR then
    draw text="Embedded software detected serial transmission error. Please "
    draw text="check optical cable and connections to the ground. "
    err=2
  else if globalerr & GE_COMMAND then
    draw text="Embedded software rejected some command. Please check the "
    if $GLOBAL.a5==0 then
      draw text="version of C_PROG.BIN. "
    else
      draw text="version of realtime.zip. "
    endif
    err=2
  else if globalerr & GE_MEAS then
    draw text="Self-test has detected severe error in measurement electronics. "
    draw text="Correct measurements seem to be impossible. Please check "
    draw text="measurement hardware. "
    err=2
  else
    draw text="Some internal error occured. "
    err=2
  endif
  globalerr=0                          // Two errors at once? Hardly possible.
  hboot=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="重启"
    help="按下可以重新加载飞针测试机程序"
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="继续"
    help="按下继续测试风险自负"
  endc
  if err==0 then                       // No serious error
    draw text="Press 'Continue' to continue test."
    disable hboot
  else if err==1 then
    draw text="You must reboot the tester and begin test again."
    disable hcont
  else
    draw text="\nContinuation of test may result in strange tester behaviour. "
    draw text="Try to reboot tester or continue at your own risk!"
  endif
  draw show
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hboot) then
      return 1
    else if Pressed(hcont) then
      return 0
    endif
    wait
  enddo
end

// Gets lists of features supported by crate controller and measurement card.
// If any command fails, list is zeroed assuming only basical functionality.
function int Getfeatures()
  int t
  char buf[32]
  cratefeatures=0
  measfeatures=0
  measfeatures2=0
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return
  // Get features of Crate controller.
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10000012             // Query crate features
  SYS.Sendimm(0,6,buf)
  t=Time()
  while $A[0].length==0 do
    if Time()-t>1500 break             // Timeout
    wait
  enddo
  if $A[0].answer==S_INPORT32 then
    cratefeatures=$uint4($A[0]+5)
  endif
  // Get features of measurement card.
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x1002001F             // Query features of measurement card
  SYS.Sendimm(0,6,buf)
  t=Time()
  while $A[0].length==0 do
    if Time()-t>1500 return            // Timeout
    wait
  enddo
  if $A[0].answer==S_INPORT32 then
    measfeatures=$uint4($A[0]+5)
  endif
  // Get extended features of measurement card.
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10020021             // Query features, set 2
  SYS.Sendimm(0,6,buf)
  t=Time()
  while $A[0].length==0 do
    if Time()-t>1500 return            // Timeout
    wait
  enddo
  if $A[0].answer==S_INPORT32 then
    measfeatures2=$uint4($A[0]+5)
  endif
end

// Checks layout and sets global variables testertype and testersides. If
// tester is not recognized or not supported, function displays corresponding
// message.
function int Recognizetester()
  int i,w,h,headmask
  float ymin,ymax
  handle hok
  clear hright
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,60 wrap=RIGHTX-5
  w=($LAY.rightlimit-$LAY.leftlimit)/1000
  h=Min($LAY.top[0]-$LAY.yoffset[0],$LAY.yoffset[0]-$LAY.bottom[0])/500
  testersides=0
  backdrill=0
  headmask=0
  ymin=9.9e99
  ymax=-9.9e99
  firstrail=9999
  lastrail=-9999
  maxrail=-9999
  for i=0,i<$LAY.nfing,i++
    if $LAY.side[i]==0 then
      testersides=testersides|1
    else
      testersides=testersides|2
    endif
    headmask=headmask | (0x3<<(i*2))
    if $LAY.side[i]==$LAY.side[0] then
      maxrail=Max(maxrail,i)
      if ($LAY.excludedrails & (1<<i))==0 then
        firstrail=Min(firstrail,i)
        lastrail=Max(lastrail,i)
      endif
    endif
    ymin=Min(ymin,$LAY.top[i]/1000.0)
    ymax=Max(ymax,$LAY.bottom[i]/1000.0)
  enddo
  backdrill=$uint4($EXT0+574) & headmask
  if ($LAY.config & LC_VACUUMBOX) testersides=testersides & 0x01
  cameras=$LAY.cameras
  if ($LAY.config & LC_VACUUMBOX)!=0 cameras=cameras & 0x01
  if ($LAY.excludedrails & 0x4000)!=0 cameras=cameras & 0x02
  if ($LAY.excludedrails & 0x8000)!=0 cameras=cameras & 0x01
  headcams=0
  if $LAY.cameras==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if ($LAY.headcameras & (1<<i))==0 continue
      if ($LAY.config & LC_VACUUMBOX)!=0 && $LAY.side[i/2]!=0 continue
      if ($LAY.excludedrails & (1<<(i/2)))!=0 continue
      headcams=headcams | (1<<i)
    enddo
  endif
  if $LAY.nfing<=0 || $LAY.nfing>=16 then
    testertype=TT_WRONG                // Wrong layout
    draw text=format("Number of rails specified in the layout (%i) ",$LAY.nfing)
    draw text="is wrong. "
  else if w<=0 || h<=0 then
    testertype=TT_WRONG                // Wrong layout
    draw text="The size of the working area is wrong. "
  else if $LAY.cameras==0 && $LAY.headcameras==0 then
    testertype=TT_WRONG                // At least one camera must be present
    draw text="There are no video cameras on the tester. "
  else if ($LAY.config & 0x80)!=0 then
    if h==45 then
      testertype=TT_WRONG;             // M2 - not supported
      draw text="M2 tester is not supported by capacity adjustment script. "
    else
      testertype=TT_WRONG;             // Contradiction in layout
      draw text="The tester is declared as M2 in the layout, but the height "
      draw text=format("of the rail is %i millimeters instead of 45. ",h)
    endif
  else if testersides==2 then
    testertype=TT_WRONG                // Single-side tester
    draw text="Layout states that this tester is single-sided and that all "
    draw text="heads are from the bottom. "
  else if testersides==3 && $LAY.nfing<4 then
    testertype=TT_WRONG                // Too few rails
    draw text="Double-sided testers with less than 4 rails are not supported. "
  else if testersides==1 && $LAY.nfing<2 then
    testertype=TT_WRONG                // Too few rails
    draw text="Single-sided testers with less than 2 rails are not supported. "
/*
  else if ymax-ymin>750.5 && $LAY.software==0xB7 then
    testertype=TT_WRONG                // Board does not cover all rails
    draw text="It is impossible to place board so that it covers all "
    draw text="available rails. "
*/
  else if ymax-ymin>310.5 && $LAY.software!=0xB7 then
    testertype=TT_WRONG                // Board does not cover all rails
    draw text="It is impossible to place board so that it covers all "
    draw text="available rails. "
  else if h==155 && ($LAY.config & 3)==2 then
    if w==600 && $LAY.software==0x84 then
      testertype=TT_A2;                // A1 or A2 with linear motors
    else if w==600 && $LAY.software==0x86 then
      testertype=TT_A2;                // A1 or A2 with belts
    else if w==600 && $LAY.software==0x8A then
      testertype=TT_A2H;               // A2 (MCM modification)
    else if w==600 && $LAY.software==0x8E then
      testertype=TT_A4;                // A4
    else if testersides==0x01 && ($LAY.software==0xA7 ||                       \
      ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S1;                // S1 (A7) tester
    else if w>=310 && w<=600 && testersides==0x03 &&                           \
      ($LAY.software==0xA7 || $LAY.software==0xA8 ||                           \
      ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S2;                // S2 tester
    else if $LAY.software==0xA9 || $LAY.software==0xAA ||                      \
      ($LAY.config & LC_TYPEMASK)==LC_S3 then
      testertype=TT_S3;                // S3 tester
    else if $LAY.software==0xB8 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A8;                // A8 tester
    else if w==600 && ($LAY.software==0xA5 || $LAY.software==0xA6) then
      testertype=TT_A6;                // A6 tester
    else if w==800 && $LAY.software==0x84 then
      testertype=TT_A2L;               // A1L or A2L with linear motors
    else if w==800 && $LAY.software==0x86 then
      testertype=TT_A2L;               // A1L or A2L with belts
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 600 or 800 for A2/A4/A6 tester. "
    endif;
  else if h==215 && $LAY.software==0xA5 then
    testertype=TT_A5;                  // A5 special model
  else if h==200 then
    if w==520 && $LAY.software==0xA5 then
      testertype=TT_A5;                // A5
    else if w==450 then
      testertype=TT_A3;                // A3
    else if w==520 then
      testertype=TT_A3L;               // A3L
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 450 or 520 for A3/A5 testers. "
    endif
  else if h==225 || h==230 || h==240 then
    if w==610 && $LAY.software==0xA5 then
      testertype=TT_A5L;               // A5L
    else if w>=610 && w<=625 && $LAY.software==0xA5 &&                         \
      ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      testertype=TT_A5L;               // A5A (L&M automate)
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 610 for A5L testers. "
    endif
  else if h>=250 && h<=260 then
    if $LAY.software==0xB7 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A7;                // A7
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text="Unable to recognize the type of the tester. "
    endif
  else
    testertype=TT_WRONG;               // Tester not recognized
    draw text="Unable to recognize the type of the tester. "
    if h!=155 && h!=200 then
      draw color=BLACK text="Strange height of the rail "
      draw text=format("(%i millimeters instead of expected 155, ",h)
      draw text="200, 230, 240 or 255) is encountered. "
    endif
  endif
  if testertype==TT_WRONG || testertype==TT_UNDEF || testertype==TT_M2 then
    draw color=BLACK
    draw text="Therefore I don't know how to run the test. Please "
    if testertype!=TT_M2 && $LAY.cameras!=0 then
      draw text="check the settings in the layout and correct them, or "
    endif
    draw text="use different test procedure which supports given machine."
    draw at 6,30 color=LIGHTRED text="Unrecoverable error detected!"
    draw show
    clear hleft
    change hleft help="无法使用这种测试机"
    draw window=hleft color=DARKGRAY font=LARGEFONT mode=M_CENTERED
    draw at 95,70 bitmap=0,0,0,"unknown"
    draw show
    change hinfo limits=0,0
    change hinfo text="Unable to test"
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="！！..."
      help="按下可以终止测试"
    endc
    while Pressed(hok)==0 && Pressed(hexit)==0 do
      wait
    enddo
    testertype=TT_WRONG
  else if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||      \
    testertype==TT_A2H || testertype==TT_A4 || testertype==TT_A6 ||            \
    testertype==TT_S1 || testertype==TT_S3 ||                                  \
    (testertype==TT_S2 && maxrail>2) || (testertype==TT_A8 && maxrail>2)       \
  then
    if firstrail==0 && lastrail==0 && boardtype==1 then
      yshift=$LAY.bottom[0]/1000.0
    else if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      yshift=$LAY.bottom[0]/1000.0
    else if (testertype==TT_S1 || testertype==TT_S3) && maxrail==1 &&          \
      $LAY.rightlimit-$LAY.leftlimit<400000 then
      yshift=$LAY.bottom[0]/1000.0
    else
      yshift=$LAY.top[0]/1000.0        // Pads on the border between two rails
    endif
    for i=0,i<$LAY.nfing*2,i++ do
      if $LAY.top[i/2]/1000.0<=ymax then
        ypos[i]=$LAY.top[i/2]/1000.0-yshift
      else
        ypos[i]=$LAY.bottom[i/2]/1000.0-yshift
      endif
    enddo
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=118.0
    endif
  else if testertype==TT_S2 || testertype==TT_A8 then
    yshift=$LAY.top[0]/1000.0-155.0    // S2 or A8/8a
    for i=0,i<$LAY.nfing*2,i++ do
      ypos[i]=155.0;
    enddo
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=118.0
    endif
  else if testertype==TT_A7 && testersides==0x03 && $LAY.nfing>=6 then
    // Note: XXL A7 board needed (boardtype=2 or 3).
    if $LAY.nfing<=8 then
      yshift=$LAY.top[0]/1000.0-250.0  // Second row between rails 0 and 1
      for i=0,i<$LAY.nfing*2,i++ do
        ypos[i]=$LAY.yoffset[i/2]/1000.0-yshift+125.0
        while ypos[i]>875.0 do
          ypos[i]=ypos[i]-250.0
        enddo
      enddo
    else
      yshift=$LAY.top[0]/1000.0        // First row between rails 0 and 1
      for i=0,i<$LAY.nfing*2,i++ do
        ypos[i]=$LAY.yoffset[i/2]/1000.0-yshift+125.0
        while ypos[i]>($LAY.nfing==12?1125.0:875.0) do
          ypos[i]=ypos[i]-250.0
        enddo
      enddo
    endif
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=183.0
    endif
  else                                 // A3/A5/A7 modifications
    yshift=$LAY.top[0]/1000.0-155.0
    for i=0,i<$LAY.nfing*2,i++ do
      ypos[i]=155.0
    enddo
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else if testertype==TT_A7 then
      headcamradius=183.0
    else
      headcamradius=153.0
    endif
  endif
end

// Draws board in the shuttle.
function int Drawboard()
  int x0,x1,y,yl
  char s[256]
  clear hleft
  draw window=hleft color=WHITE bkcolor=WHITE clear
  if testertype==TT_A5L && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    if boardtype==0 then
      draw at 2,10 bitmap=0,0,0,"a5actest"
    else
      draw at 2,10 bitmap=0,0,0,"a5arctst"
    endif
  else if testertype==TT_A7 && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    if boardtype==0 then
      draw at 2,10 bitmap=0,0,0,"a7actest"
    else
      draw at 2,10 bitmap=0,0,0,"a7arctst"
    endif
  else if boardtype==2 then
    draw color=GRAY bkcolor=GRAY
    draw at 67,2 fillrect 88,318
    draw at 234,2 fillrect 254,318
    draw color=BLACK bkcolor=WHITE
    draw at 87,2 to 87,318
    draw at 87,8 fillrect 99,312
    draw at 233,2 to 233,318
    draw at 222,8 fillrect 234,312
    if $LAY.nfing<=8 then
      yl=205
      Strcpy(s,"Align with border between rails 0 and 1")
    else
      yl=294
      Strcpy(s,"Align with border between rails 0 and 1")
    endif
    draw at 98,6 bitmap=0,0,0,"rclarge"
    draw color=LIGHTRED
    draw at 92,yl to 33,yl to 33,325 to 63,325
    draw at 227,yl to 283,yl to 283,325 to 253,325
    draw font=SMALLFONT color=LIGHTRED mode=M_CENTERED at 160,332 text=s
  else if boardtype==3 then
    draw color=GRAY bkcolor=GRAY
    draw at 67,2 fillrect 88,348
    draw at 234,2 fillrect 254,348
    draw color=BLACK bkcolor=WHITE
    draw at 87,2 to 87,348
    draw at 87,8 fillrect 99,342
    draw at 233,2 to 233,348
    draw at 222,8 fillrect 234,342
    yl=331
    Strcpy(s,"Align with border between rails 0 and 1")
    draw at 98,4 bitmap=0,0,0,"rc24"
    draw color=LIGHTRED
    draw at 92,yl to 33,yl to 33,353 to 63,353
    draw at 227,yl to 283,yl to 283,353 to 253,353
    draw font=SMALLFONT color=LIGHTRED mode=M_CENTERED at 160,360 text=s
  else if testertype==TT_S3 && $LAY.nfing==2 then
    draw color=DARKGRAY bkcolor=GRAY
    draw at 70,40 fillrect 250,220
    draw at 74,44 rect 246,216
    y=38
    if boardtype==0 then
      x0=127; x1=193
      draw at x0+2,y+15 clip x1-2,y+169 at x0,y bitmap=0,0,0,"c-rcsel"
    else
      x0=100; x1=221
      draw at x0+2,y+15 clip x1-2,y+169 at x0,y bitmap=0,0,0,"rcboard"
    endif
    if yshift==$LAY.bottom[0]/1000.0 then
      // Align bottom row with the bottom of the test area.
      yl=195
      Strcpy(s,"Align with the bottom of test area")
    else if yshift==$LAY.top[0]/1000.0 then
      // Align bottom row with the border between rails 0 and 1.
      yl=153
      Strcpy(s,"Align with border between rails 0 and 1")
    else
      // Align middle row with the border between rails 0 and 1.
      yl=88
      Strcpy(s,"与轨道之间的边缘对齐")
    endif
    draw clip=NULL
    draw color=LIGHTRED
    draw at x0+10,yl to 33,yl to 33,250 to 63,250
    draw at x1-10,yl to 287,yl to 287,250 to 253,250
    draw font=SMALLFONT color=BLACK mode=M_CENTERED at 160,256 text=s
  else
    draw color=GRAY bkcolor=GRAY
    draw at 10,10 fillrect 310,288
    draw color=DARKGRAY bkcolor=WHITE
    draw at 23,22 fillrect 297,275
    if yshift==$LAY.bottom[0]/1000.0 then
      // Align bottom row with the bottom of the test area.
      y=98; yl=255
      Strcpy(s,"Align with the bottom of test area")
    else if yshift==$LAY.top[0]/1000.0 then
      // Align bottom row with the border between rails 0 and 1.
      y=56; yl=213
      Strcpy(s,"Align with border between rails 0 and 1")
    else
      // Align middle row with the border between rails 0 and 1.
      y=56; yl=148
      Strcpy(s,"与轨道之间的边缘对齐")
    endif
    if boardtype==0 then
      x0=127; x1=193
      draw at x0+2,y+2 clip x1-2,y+182 at x0,y bitmap=0,0,0,"c-rcsel"
    else
      x0=100; x1=221
      draw at x0+2,y+2 clip x1-2,y+182 at x0,y bitmap=0,0,0,"rcboard"
    endif
    draw clip=NULL
    draw color=DARKGRAY bkcolor=WHITE
    draw at x0-10,28 fillrect x0+4,270
    draw at x1-4,28 fillrect x1+10,270
    draw color=DARKGRAY bkcolor=GRAY
    draw at x0-20,13 fillrect x0-2,285
    draw at x1+2,13 fillrect x1+20,285
    draw color=LIGHTRED
    draw at x0+10,yl to 33,yl to 33,300 to 63,300
    draw at x1-10,yl to 287,yl to 287,300 to 253,300
    draw font=SMALLFONT color=BLACK mode=M_CENTERED at 160,306 text=s
  endif
  draw show
  if boardtype==0 then
    change hleft help="校验板在架板框中的位置"
  else
    change hleft help="复合电阻电容校验板在架板框中位置"
  endif
end

// Ask operator to select either simple or full-option adjust mode.
function int Simplemode()
  int i,auto
  handle hsimple,hfull
  simplemode=0
  if backdrill!=0 return 0
  clear hright
  change hinfo limits=0,0
  change hinfo text="简单化"
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="如果需要调整所有测试头的电容并保存"
  draw text="到布局文件中,按" font=MAINFONT text="精简调整" font=TIMESFONT
  draw text="。除此之外,按\n" font=MAINFONT text="所有选项"
  draw font=TIMESFONT text="。"
  if firstrail!=0 || lastrail!=maxrail then
    draw text="\n\n请注意:" color=LIGHTRED text="布局中的部分轨道已关闭.选择"
    draw text="简单化模式时只有"
    if firstrail==lastrail then
      draw text=format("轨道 %i ",firstrail)
      if testersides==0x3 then
        draw text="和对面匹配\n的轨道会被校验调整."
      endif
    else
      draw text=format("rails %i..%i ",firstrail,lastrail)
      if testersides==0x3 then
        draw text="and corresponding rails on the opposite side "
      endif
    endif
    draw text="will be adjusted!"
  endif
  draw show
  hsimple=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="精简调整"
    help="点击校正电容并保存到设置中"
  endc
  hfull=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="所有选项"
    help="点击打开所有可用选项"
  endc
  while 1 do
    if Pressed(hexit)!=0 then
      return -1
    else if Pressed(hsimple) then
      simplemode=1
      usesides=testersides
      // Set list of heads allowed for capacity adjustment.
      for i=0,i<$LAY.nfing*2,i++ do
        if i<=maxrail*2+1 && (i<firstrail*2 || i>lastrail*2+1) then
          used[i]=0
        else if i>=$LAY.nfing &&                                               \
          (i<firstrail*2+$LAY.nfing || i>lastrail*2+$LAY.nfing+1) then
          used[i]=0
        else if $LAY.side[i/2]==0 && (usesides & 0x1)!=0 then
          used[i]=1
        else if $LAY.side[i/2]!=0 && (usesides & 0x2)!=0 then
          used[i]=1
        else
          used[i]=0
        endif
      enddo
      break
    else if Pressed(hfull) then
      break
    endif
    wait
  enddo
  return 0
end

// Sets capacity alignment mode. Returns 0 on success or -1 if user interrupted
// C adjust.
function int Setmode()
  int i,checkwarn
  handle hboth,htop,hbottom,hframe,hall,hselected,hfrom,hto,hwarn,hok
  usesides=testersides
  clear hright
  change hinfo limits=0,0
  change hinfo text="轨道设置"
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="如果某些轨道被禁用或未校准"
  draw text="请屏蔽。\n选择" font=INFOFONT text="双面"
  draw font=TIMESFONT text="和" font=INFOFONT text="全部"
  draw font=TIMESFONT text="按" font=MAINFONT text="确定"
  draw font=TIMESFONT text="开始调整所有\n测试的电容值.\n"
  draw at 6,116 font=INFOFONT text="面:"
  hboth=control RADIO
    window=hright
    position=56,100,140,18
    name="双面"
    help="选择从测试机两侧调整电容(默认值)"
    font=INFOFONT
  endc
  htop=control RADIO
    window=hright
    position=56,119,140,18
    name="仅顶面"
    help="仅调整上部测试头的电容值"
    font=INFOFONT
  endc
  hbottom=control RADIO
    window=hright
    position=56,138,140,18
    name="仅底面"
    help="仅调整下部测试头的电容值"
    font=INFOFONT
  endc
  if testersides==0x1 then
    change htop mode=M_CHECKED
    disable hbottom
    disable hboth
  else if testersides==0x2 then
    change hbottom mode=M_CHECKED
    disable htop
    disable hboth
  else
    change hboth mode=M_CHECKED
  endif
  draw show
  hframe=control CHILD
    window=hright
    position=0,170,RIGHTX,50
    help=" "
    color=WHITE
    bkcolor=WHITE
    size=256
  endc
  draw window=hframe font=INFOFONT color=BLACK
  draw at 6,17 text="轨道:"
  hall=control RADIO
    window=hframe
    position=56,1,140,19
    name="全"
    help="可调整选所有轨道的电容值"
    font=INFOFONT
  endc
  hselected=control RADIO
    window=hframe
    position=56,24,48,19
    name="从"
    help="调整选定子轨道的电容值"
    font=INFOFONT
  endc
  hfrom=control COMBOLIST
    window=hframe
    position=109,21,59,90
    mode=M_VSCROLL
  endc
  draw at 172,40 text="到"
  hto=control COMBOLIST
    window=hframe
    position=189,21,59,90
    mode=M_VSCROLL
  endc
  if testersides==0x3 then
    for i=0,i<$LAY.nfing/2,i++
      add hfrom text=format(" %i (%i)",i,i+$LAY.nfing/2)
      add hto text=format(" %i (%i)",i,i+$LAY.nfing/2)
    enddo
    change hfrom help="从上部(下部)轨道开始调整"
    change hto help="调整中包含了最后一个上(下)轨"
  else
    for i=0,i<$LAY.nfing,i++
      add hfrom text=format("  %i",i)
      add hto text=format("  %i",i)
    enddo
    change hfrom help="从轨道开始调整"
    change hto help="调整中包括最后一个轨道"
  endif
  change hfrom select=firstrail
  change hto select=lastrail
  if $LAY.excludedrails==0 then
    change hall mode=M_CHECKED
  else
    change hselected mode=M_CHECKED
  endif
  draw show
  hwarn=control TEXT
    window=hright
    position=0,255,RIGHTX,20
    help=" "
    color=LIGHTRED
    mode=M_CENTERED
  endc
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+30,120,24
    name="确定"
    help="确认设置并继续进行电容调整"
  endc
  checkwarn=1
  while 1 do
    if Pressed(hexit)!=0 then
      return -1
    else if Pressed(hok) then
      break
    else if Pressed(hboth) then
      usesides=0x3
      checkwarn=1
    else if Pressed(htop) then
      usesides=0x1
      checkwarn=1
    else if Pressed(hbottom) then
      usesides=0x2
      checkwarn=1
    else if Pressed(hall) then
      checkwarn=1
    else if Pressed(hselected) then
      checkwarn=1
    else if Pressed(hfrom) then
      change hselected mode=M_CHECKED
      firstrail=Status(hfrom)
      lastrail=Status(hto)
      if lastrail<firstrail lastrail=firstrail
      change hfrom select=firstrail
      change hto select=lastrail
      checkwarn=1
    else if Pressed(hto) then
      change hselected mode=M_CHECKED
      firstrail=Status(hfrom)
      lastrail=Status(hto)
      if lastrail<firstrail firstrail=lastrail
      change hfrom select=firstrail
      change hto select=lastrail
      checkwarn=1
    endif
    if checkwarn then
      if Status(hall)==0 && lastrail-firstrail==0 && usesides!=0x3 then
        change hwarn text="Need at least 4 heads for C adjust"
        disable hok
      else
        change hwarn text=""
        enable hok
      endif
      checkwarn=0
    endif
    wait
  enddo
  if Status(hall)!=0 then
    firstrail=0
    lastrail=maxrail
  else
    firstrail=Status(hfrom)
    lastrail=Status(hto)
  endif
  if lastrail<firstrail firstrail=lastrail
  // Set list of heads allowed for capacity adjustment.
skipsetmode:
  for i=0,i<$LAY.nfing*2,i++ do
    if i<=maxrail*2+1 && (i<firstrail*2 || i>lastrail*2+1) then
      used[i]=0
    else if i>=$LAY.nfing &&                                                   \
      (i<firstrail*2+$LAY.nfing || i>lastrail*2+$LAY.nfing+1) then
      used[i]=0
    else if $LAY.side[i/2]==0 && (usesides & 0x1)!=0 then
      used[i]=1
    else if $LAY.side[i/2]!=0 && (usesides & 0x2)!=0 then
      used[i]=1
    else
      used[i]=0
    endif
  enddo
  return 0
end

// Sets type of the test board. Returns 0 on success or -1 if user interrupted
// test.
function int Selectboard()
  int x,y,x0,y0,x1,y1,redraw
  handle hchild,hdedicated,hcombined,hok
  clear hright
  change hinfo limits=0,0
  change hinfo text="选择校验板"
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="请选择校验板：专用-只能做电容校验。\n共用-可用作电容校验和低阻校验。"
  //draw text="(only capacity adjustment is possible) or combined (can be used "
  //draw text="both for capacity adjustment and low resistance test)."
  if testersides==0x1 && ($EXTLAY.extant & 1)!=0 then
    draw color=LIGHTRED text="\n\nAttention, if your tester is equipped with "
    draw text="the vacuum shuttle, don't forget to connect external antenna!"
  endif
  draw show
  clear hleft
  hchild=control GRAPH
    window=hleft
    position=5,5,LEFTX-10,250
    help=" "
    color=WHITE
    bkcolor=WHITE
  endc
  hdedicated=control RADIO
    window=hleft
    position=46,260,(LEFTX-90)/2,22
    name="专用"
    help="点击选择专用校验板 (老版本,仅电阻测试)"
    mode=(boardtype==0?M_CHECKED:0)
  endc
  hcombined=control RADIO
    window=hleft
    position=(LEFTX-90)/2+76,260,(LEFTX-90)/2,22
    name="共用"
    help="点击选择复合校验板 (新版本,电阻测试和电容校正)"
    mode=(boardtype!=0?M_CHECKED:0)
  endc
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="确定"
    help="点击确认选择"
  endc
  redraw=1
  y0=27; y1=217
  while 1 do
    if Pressed(hdedicated) then
      boardtype=0
      redraw=1
    else if Pressed(hcombined) then
      boardtype=1
      redraw=1
    else if Pressed(hok) then
      setini("Cadjust","Board type","%i,%i",wideboard,boardtype)
      Drawboard()
      return 0
    else if Pressed(hchild) then
      x=Limit0(hchild)
      y=Limit1(hchild)
      if y>=y0 && y<y1 then
        if x>=37 && x<111 then
          change hdedicated mode=M_CHECKED
          boardtype=0
          redraw=1
        else if x>=164 && x<291 then
          change hcombined mode=M_CHECKED
          boardtype=1
          redraw=1
        endif
      endif
    else if Pressed(hexit) then
      Drawboard()
      return -1
    endif
    if redraw then
      if boardtype==0 then
        x0=37; x1=111
      else
        x0=164; x1=291
      endif
      draw window=hchild color=WHITE bkcolor=WHITE clear
      draw at 40,30 bitmap=0,0,0,"c-rcsel"
      draw color=LIGHTRED bkcolor=LIGHTRED
      draw at x0-5,y0-5 fillrect x0,y1+5
      draw at x0-5,y0-5 fillrect x1+5,y0
      draw at x1,y0-5 fillrect x1+5,y1+5
      draw at x0-5,y1 fillrect x1+5,y1+5
      draw show
      redraw=0
    endif
    wait
  enddo
end

// Returns 0 on success, >0 in case of communication error or -1 if operator
// decided to interrupt the test.
function int Installboard(int isa4)
  int i,t,x,y,head,side,channel,portdata,prevdata,changed,err
  int ident,movecamera,delta,videoon,videosizex,videosizey
  float defzoom,zoom,xcoord,angle
  char s[512],buf[256]
  handle hstatus,hlock,hunlock,hvideo,hok,hl,hc,hr
  handle hview,hlivevideo,hzoom
  handle hshuttlex,hshxscr,hshuttley,hshyscr
  clear hright
  change hinfo limits=0,0
  change hinfo text="放置校验板"
  if testertype==TT_A2L then
    shuttlex=41
    shuttley=39
  else if testertype==TT_A3 then
    shuttlex=23
    shuttley=46
  else if testertype==TT_A3L || testertype==TT_A5 || testertype==TT_A5L then
    shuttlex=27
    shuttley=46
  else
    shuttlex=31
    shuttley=39
  endif
  if ($LAY.config & 0x0001C040)==0x00008040 then
    shuttlex=0.0                       // Automatical shuttle
  else if ($LAY.config & 0x0001C000)==0x0000C000 then
    shuttlex=28                        // A5 wide shuttle
  endif
  getini("Cadjust","Shuttle","%g,%g",&shuttlex,&shuttley)
  Drawboard()
  if isa4 then
    hstatus=NULL
  else
    hstatus=control TEXT
      window=hright
      name="未知架板框状态"
      position=5,180,RIGHTX-10,21
      font=MEDIUMFONT
      color=BLACK
      bkcolor=PINK
      mode=M_CENTERED|M_BORDER
    endc
  endif
  if testertype==TT_S2 then
    hlock=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY-30,120,24
      name="锁止"
      help="按下可以解锁架板框"
    endc
    hunlock=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-30,120,24
      name="解锁"
      help="点击解锁架板框"
    endc
    hvideo=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="视频"
      help="点击使用摄像头调整校验板Y位置"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="确定"
      help="校验板正确放置后点击"
    endc
  else
    hlock=NULL
    hunlock=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name=(isa4?"原位":"解锁")
      help=(isa4?"按下复位相机":"点击解锁架板框")
    endc
    hvideo=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="视频"
      help="点击使用摄像头调整校验板Y位置"
    endc
    hok=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="确定"
      help="校验板正确放置后点击"
    endc
  endif
  draw window=hleft color=BLACK font=INFOFONT
  if boardtype==3 then
    draw bkcolor=WHITE at 227,200 fillrect LEFTX-1,263
    draw at 230,223 text="X="
    draw at 230,253 text="Y="
    draw show
    hshuttlex=control EDIT
      window=hleft
      position=250,205,45,23
      text=format(" %.1f",shuttlex)
      help="校验板在架板框中X位置,架板框坐标"
      font=MEDIUMFONT
    endc
    hshxscr=control VSCROLL
      window=hleft
      position=295,205,18,23
      help="用以改变架板框中X坐标以备用"
      limits=1,-1
    endc
    hshuttley=control EDIT
      window=hleft
      position=250,235,45,23
      text=format(" %.1f",shuttley)
      help="校验板在架板框中Y位置,架板框坐标"
      font=MEDIUMFONT
    endc
    hshyscr=control VSCROLL
      window=hleft
      position=295,235,18,23
      help="用以改变架板框中Y坐标以备用"
      limits=1,-1
    endc
  else
    draw at 15,LEFTY-12 text="位置: X="
    draw at 220,LEFTY-12 text="Y="
    draw show
    hshuttlex=control EDIT
      window=hleft
      position=150,LEFTY-30,45,23
      text=format(" %.1f",shuttlex)
      help="校验板在架板框中X位置,架板框坐标"
      font=MEDIUMFONT
    endc
    hshxscr=control VSCROLL
      window=hleft
      position=195,LEFTY-30,18,23
      help="用以改变架板框中X坐标以备用"
      limits=1,-1
    endc
    hshuttley=control EDIT
      window=hleft
      position=245,LEFTY-30,45,23
      text=format(" %.1f",shuttley)
      help="校验板在架板框中Y位置,架板框坐标"
      font=MEDIUMFONT
    endc
    hshyscr=control VSCROLL
      window=hleft
      position=290,LEFTY-30,18,23
      help="用以改变架板框中Y坐标以备用"
      limits=1,-1
    endc
  endif
  if ($LAY.config & 0x0001C040)==0x00008040 then
    disable hshuttlex
    disable hshxscr
  endif
  if testertype!=TT_S3 then
    disable hvideo
    disable hok
  endif
  head=Camerafromy(yshift+rowdist,&channel,&side,&angle)
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="请安装好校验板,如左边图所示."
  draw text="\n"
  if isa4 then
    draw text="When camera is over the board, press " font=MAINFONT text="Home"
    draw font=TIMESFONT text=" before you can open shuttle. "
  else if hlock!=NULL && hunlock!=NULL then
    draw text="Press " font=MAINFONT text="Lock " font=TIMESFONT
    draw text="and " font=MAINFONT text="Unlock " font=TIMESFONT
    draw text="to move the shuttle. "
  else
    draw text="按下" font=MAINFONT text="解锁" font=TIMESFONT
    draw text="键释放出架板框."
    if head>=0 then
      draw text="当架板框已"
      draw text="经锁好,可以按下" font=MAINFONT text="视频"
      draw font=TIMESFONT text="键,配合使用调节器\n来调整Y方向的位置."
      draw text="校验板位置放置\n正确后,"
    endif
  endif
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8 then
    draw text="按" font=MAINFONT text="确定" font=TIMESFONT
    draw text="键.或者可以在不安装检验\n板的情况下,使用" font=MAINFONT
    draw text="仅微短探测" font=TIMESFONT text="功能调整微"
    draw text="短探"
    draw text="测测量.  "
  else
    draw text="Don't forget to update position of the board in shuttle; "
    draw text="this will help you to install board next time. "
    draw text="Press " font=MAINFONT text="OK " font=TIMESFONT
    draw text="when board is correctly installed."
  endif
  draw show
  t=0; err=0; videoon=0
  portdata=-1; prevdata=portdata
  while err==0 do
    if portdata!=prevdata then
      if isa4 then
        if head>=0 enable hvideo
        enable hok
      else
        i=portdata & 0x35
        if i==0x20 then                // Shuttle locked in test position
          if head>=0 || testertype==TT_S3 enable hvideo
          enable hok
          change hstatus text="架板框已锁"
        else if (i & 0x10)==0 && testertype!=TT_S1 &&                          \
          testertype!=TT_S2 then
          if testertype==TT_S3 then
            enable hvideo
            enable hok
          else
            disable hvideo
            disable hok
          endif
          change hstatus text="架板框进"
        else
          if testertype==TT_S3 then
            enable hvideo
            enable hok
          else
            disable hvideo
            disable hok
          endif
          change hstatus text="Shuttle out"
        endif
      endif
      prevdata=portdata
    endif
    if hlock!=NULL && Pressed(hlock) then
      buf[0]=S_LOCKDOOR; buf[1]=1      // Lock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else if Pressed(hunlock) then
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      if videoon!=0 then
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        videoon=0
      endif
    else if head>=0 && Pressed(hvideo) then
      if videoon==0 then
        disable hshuttlex
        disable hshxscr
        disable hshuttley
        disable hshyscr
        hl=control BUTTON
          window=hright
          position=5,USERY+30,RIGHTX/3-5,24
          name="<< 左边"
          help="向左移动相机2.5mm"
        endc
        hc=control BUTTON
          window=hright
          position=5+RIGHTX/3,USERY+30,RIGHTX/3-5,24
          name="中心"
          help="快速移动相机到中心位置"
        endc
        hr=control BUTTON
          window=hright
          position=5+2*(RIGHTX/3),USERY+30,RIGHTX/3-9,24
          name="右边 >>"
          help="向右移动相机2.5mm"
        endc
        hview=control CHILD            // Video is not yet here, create controls
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          bkcolor=VIDEOFILL
        endc
        Bccreate(hview,-1,-1,channel,1)
        hzoom=control CUSTOMBOX
          window=hview
          position=235,303,80,21
          name="放大"
          help="勾选提升放大倍数到2"
          color=BROWN
        endc
        SYS.Videosize(channel,&videosizex,&videosizey,&i)
        if videosizex==0 || videosizey==0 then
          defzoom=0.5
        else
          defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
        endif
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
          Bcgetbri(channel),Bcgetctr(channel),                                 \
          (channel<0?0:2)|(longexp?4:0),angle)
        movecamera=1; xcoord=$LAY.xoffset/1000.0
        x=(LEFTX-10)/2; y=288/2
        draw window=hlivevideo color=LIGHTRED
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        videoon=1
      else
        Bcdelete()                     // Video is already here, remove controls
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        enable hshuttlex
        enable hshxscr
        enable hshuttley
        enable hshyscr
        videoon=0
      endif
    else if Pressed(hok) && ((portdata & 0x35)==0x20 || testertype==TT_S3) then
      break
    else if Pressed(hexit) then
      err=-1
    else if Pressed(hshuttlex) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      shuttlex=Min(60.0,Max(0.0,shuttlex))
      change hshuttlex text=format(" %.1f",shuttlex)
    else if Pressed(hshxscr) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      delta=Status(hshxscr)
      shuttlex=Min(60.0,Max(0.0,shuttlex+delta*0.5))
      change hshuttlex text=format(" %.1f",shuttlex)
      change hshxscr select=0
    else if Pressed(hshuttley) then
      Text(hshuttley,s); sscanf(s,"%f",&shuttley);
      shuttley=Min(60.0,Max(0.0,shuttley))
      change hshuttley text=format(" %.1f",shuttley)
    else if Pressed(hshyscr) then
      Text(hshuttley,s); sscanf(s,"%f",&shuttley);
      delta=Status(hshyscr)
      shuttley=Min(60.0,Max(0.0,shuttley+delta*0.5))
      change hshuttley text=format(" %.1f",shuttley)
      change hshyscr select=0
    endif
    if videoon then
      changed=Bcupdate()
      if (changed & 0x01)!=0 || Pressed(hzoom) then
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      endif
      if (changed & 0x02)!=0 then
        movecamera=1
      endif
      if Pressed(hc) then
        xcoord=$LAY.xoffset/1000.0
        movecamera=1
      else if Pressed(hl) then
        xcoord=Max(xcoord-2.5,leftvlimit)
        movecamera=1
      else if Pressed(hr) then
        xcoord=Min(xcoord+2.5,rightvlimit)
        movecamera=1
      endif
      if movecamera!=0 && head>=0 then
        if $LAY.cameras!=0 then
          sprintf(buf,"M %i(%g,%g) NOP",                                       \
          $LAY.nfing*2+channel,xcoord,yshift+rowdist)
        else if $LAY.headcameras!=0 then
          SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
          sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          SERV.Cmdimm(33,buf)
          sprintf(buf,"M @%i[%g,%g] NOP",head,xcoord,yshift+rowdist)
        endif
        SERV.Cmdimm(32,buf)            // Move camera to middle row of pads
        movecamera=0
      endif
    endif
    if t==0 then                       // Send next port query
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      ident=SYS.Sendimm(0,3,buf)
      t=Time()+10000                   // Timeout 10 seconds
    else if $A[0].length>0 then
      if $A[0].answer==S_INPORT then
        portdata=$A[0].inport          // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if t<Time() then
      SYS.Killsend(ident)
      err=1                            // No answer from tester
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  if videoon!=0 then
    Bcdelete()
    destroy hview
    destroy hl
    destroy hc
    destroy hr
    enable hshxscr
    enable hshyscr
  endif
  if err>0 then
    if head>=0 then
      sprintf(buf,"M %i(Z) NOP",head)
      SERV.Cmdimm(32,buf)              // Move camera in home position
    endif
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="按下检查测试机状态"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED text="Communication error! "
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from tester within 10 seconds. "
    else
      draw text="Test procedure received unexpected answer. "
    endif
    if err!=2 draw text="Please check connection with crate controller. "
    draw text="Press " font=MAINFONT text="Retry " font=TIMESFONT
    draw text="to check tester status and, eventually, reboot it."
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  if err==0 setini("Cadjust","Shuttle","%g,%g",shuttlex,shuttley)
  return err
end

// Asks L&M for the value of the specified parameter. Sets value to the received
// string <parm>=<answer> (i.e. parm and equation sign are included). Returns 0
// on success, 1 on failure and -1 if user cancelled C adjust.
function int Getlmparameter(char *parm,char *value)
  int i,n
  char buf[768]
  SYS.Killimm(33)
  buf[0]=S_LMAUTO
  buf[1]=3                             // Get parameter
  n=2+sprintf(buf+2,"%s",parm)
  SYS.Sendimm(33,n,buf)
  while $A[33].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[33].answer!=S_LMAUTO return 1  // Bad answer
  for i=0,i<$A[33].length-6,i++ do
    value[i]=$char($A[33]+6+i)
  enddo
  value[i]='\0'
  return 0
end

// Sends text command to L&M automation and waits for answer. Returns 1 on
// success, 0 on failure, 2 on timeout and -1 if user cancelled C adjust.
function int Sendlmcommand(char *cmd,char *answer,char *error,int timeout)
  int m,n,status
  char buf[768]
  SYS.Killimm(32)
  buf[0]=S_LMAUTO
  buf[1]=4                             // Send command
  $uint2(buf+2)=timeout                // Timeout, seconds
  n=4+sprintf(buf+4,"%s\n",cmd)
  n=n+sprintf(buf+n,"%s",answer)
  SYS.Sendimm(32,n,buf)
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[32].answer!=S_LMAUTO return 0  // Bad answer
  status=$uint2($A[32]+6)
  if (status & 0x01) return 2          // Timeout
  if $char($A[32]+8)=='1' then
    n=8
    m=0                                // Success
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      error[m]=$char($A[32]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 1
  else
    n=8                                // Error
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      n++
    enddo
    if $char($A[32]+n)=='\n' && n<$A[32].length n++
    m=0
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      error[m]=$char($A[32]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 0
  endif
end

// Gets actual teachin settings for L&M hardware. Settings are saved to the
// array lmteachin[], prefix MECH.Teachin is replaced by MECH.Para. Returns 0
// on success, >0 in the case of communication error or -1 if operator decided
// to interrupt the C adjust.
function int Getteachinsettings()
  int i
  nlmteachin=0
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO return 0
  i=Getlmparameter("MECH.Teachin.ShuttleX",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  i=Getlmparameter("MECH.Teachin.ShuttleY",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  i=Getlmparameter("MECH.Para.BoardH",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  i=Getlmparameter("MECH.Para.BoardW",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  i=Getlmparameter("MECH.Para.UseCatcherOnly",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  return 0
end

// Installs C adjust board in L&M automatical shuttle. Returns 0 on success,
// >0 in case of communication error or -1 if operator decided to interrupt the
// C adjust.
function int InstallboardLM()
  int i,t,nfing,preset,prevdata,portdata,adjusting,adjusted,shuttle,delta,err
  char s[512],path[512],buf[512],errtxt[256]
  handle f,hsmall,hwide,hstatus,hload,hunload,hshuttlex,hshxscr
  handle hpreset,hadjust,hok,hyes,hno
  nfing=$LAY.nfing
  Drawboard()
  // On testers with split shuttle, board must be installed into the left
  // shuttle.
  shuttle=0
  getini("Cadjust","Shuttle","%g,%g",&shuttlex,&shuttley)
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  for i=0,i<nfing,i++
    if used[i*2]==0 continue           // Rail is excluded from calibration
    sprintf(buf,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,buf)
  enddo
  t=Time()
  while (1) do
    for i=0,i<nfing,i++
      if used[i*2]==0 continue
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=nfing break                  // All answers came
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>10000 break            // No answer within 10 s timeout
    wait
  enddo
  clear hright
  change hinfo limits=0,0
  // Check whether there is a board in the shuttle. It may happen that previous
  // C adjust was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  if $A[32].length==7 && $A[32].answer==S_INPORT then
    portdata=$A[32].inport
  else
    portdata=0
  endif
  if (portdata & 0x35)!=0x20 then
    // Set positions of L&M actuators for C adjust board.
    if boardtype==0 then
      f=Fopen("c:\\atg\\hardware\\shuttle_cadjust.txt","rb")
      if f!=NULL then
        Strcpy(s,"PS.Cmd=FileRead c:/atg/hardware/shuttle_cadjust.txt")
        Strcpy(path,"c:\\atg\\hardware\\shuttle_cadjust.txt")
      else
        f=Fopen("c:\\hardware\\shuttle_cadjust.txt","rb")
        Strcpy(s,"PS.Cmd=FileRead c:/hardware/shuttle_cadjust.txt")
        Strcpy(path,"c:\\hardware\\shuttle_cadjust.txt")
      endif
      if f!=NULL then
        Fclose(f)
        change hinfo text="Setting up shuttle..."
        i=Sendlmcommand(s,"PS.Ready.FileRead",errtxt,5)
        if i<0 return -1
        preset=(i==1)
      else
        preset=0                       // Shuttle positions not set
      endif
    else
      f=Fopen("c:\\atg\\hardware\\shuttle_comborc.txt","rb")
      if f!=NULL then
        Strcpy(s,"PS.Cmd=FileRead c:/atg/hardware/shuttle_comborc.txt")
        Strcpy(path,"c:\\atg\\hardware\\shuttle_comborc.txt")
      else
        f=Fopen("c:\\hardware\\shuttle_comborc.txt","rb")
        Strcpy(s,"PS.Cmd=FileRead c:/hardware/shuttle_comborc.txt")
        Strcpy(path,"c:\\hardware\\shuttle_comborc.txt")
      endif
      if f!=NULL then
        Fclose(f)
        change hinfo text="Setting up shuttle..."
        i=Sendlmcommand(s,"PS.Ready.FileRead",errtxt,5)
        if i<0 return -1
        preset=(i==1)
      else
        preset=0                       // Shuttle positions not set
      endif
    endif
  else
    preset=0
  endif
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    draw window=hleft color=BLACK font=INFOFONT
    draw at 15,LEFTY-12 text="Position in shuttle: X="
    draw show
    hshuttlex=control EDIT
      window=hleft
      position=150,LEFTY-30,45,23
      text=format(" %.1f",shuttlex)
      help="校验板在架板框中X位置,架板框坐标"
      font=MEDIUMFONT
    endc
    hshxscr=control VSCROLL
      window=hleft
      position=195,LEFTY-30,18,23
      help="用以改变架板框中X坐标以备用"
      limits=1,-1
    endc
  else
    hshuttlex=NULL
    hshxscr=NULL
  endif
  // Set manual automation mode.
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    change hinfo text="Setting pure manual mode..."
    if pulledshuttle<0 then
      i=Sendlmcommand("MECH.Cmd=SetMode 5","MECH.Ready.SetMode",errtxt,20)
    else
      i=0
    endif
    if i>=0 then
      if pulledshuttle<0 then
        sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i 2",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
      else
        sprintf(buf,"MECH.Cmd=A8eaRepositionPullCalib %i 2",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaRepositionPullCalib",errtxt,0xFFFF)
      endif
      if i>=0 pulledshuttle=shuttle
    endif
  else
    change hinfo text="Switching to manual mode..."
    i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,20)
  endif
  if i<0 return -1
  // Installation controls.
  change hinfo text="Install C adjust board"
  draw window=hright color=BLACK font=INFOFONT
  if boardtype==0 then
    draw at 6,120 text="Type of the C adjust board:"
    hsmall=control RADIO
      window=hright
      name="窄 (标准)"
      help="选择标准电容调整板"
      position=29,125,160,21
      font=INFOFONT
      color=BLACK
      mode=(wideboard?0:M_CHECKED)
    endc
    hwide=control RADIO
      window=hright
      name="宽"
      help="选择宽的电容调整板"
      position=29,150,160,21
      font=INFOFONT
      color=BLACK
      mode=(wideboard?M_CHECKED:0)
    endc
  else
    hsmall=NULL
    hwide=NULL
  endif
  hstatus=control TEXT
    window=hright
    name="未知架板框状态"
    position=9,190,RIGHTX-17,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  hload=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY-15,120,24
    name="加载"
    help="按下从滚动带装载电容调整板"
  endc
  hunload=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY-15,120,24
    name="卸载"
    help="按下可从架板框上卸载电容调节板"
  endc
  if preset==0 then
    hpreset=control BUTTON
      window=hright
      position=5,USERY+20,RIGHTX/3-5,24
      name="设置寸"
      help="从文件shuttle-cadjust.txt获取板子尺寸"
    endc
    hadjust=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY+20,RIGHTX/3-5,24
      name="调试"
      help="按下可以使用手动控制箱调节架板框"
    endc
    hok=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY+20,RIGHTX/3-9,24
      name="确定"
      help="正确安装了电容调节板时按下"
    endc
  else
    hadjust=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+20,120,24
      name="调试"
      help="按下可以使用手动控制箱调节架板框"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+20,120,24
      name="确定"
      help="正确安装了电容调节板时按下"
    endc
  endif
  disable hok
  if ALLOWLMADJ==0 disable hadjust
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="Now install the board. "
  if ALLOWLMADJ then
    draw text="Press " font=MAINFONT text="Adjust " font=TIMESFONT
    draw text="to adjust widht and height of the shuttle manually. "
  endif
  draw text="Press " font=MAINFONT text="OK " font=TIMESFONT
  draw text="when board is correctly locked in the shuttle."
  draw show
  // Main loop.
  prevdata=-1
  adjusting=0
  adjusted=0
  t=0
  while err==0 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if adjusting then
        change hstatus text="Adjustment mode"
        enable hload
        disable hunload
        disable hadjust
        disable hok
        if preset==0 enable hpreset
      else if i==0x20 then             // Shuttle locked in test position
        change hstatus text="Board in the shuttle"
        disable hload
        enable hunload
        disable hadjust
        enable hok
        if preset==0 disable hpreset
      else
        change hstatus text="Shuttle out"
        enable hload
        enable hunload
        if ALLOWLMADJ!=0 enable hadjust
        disable hok
        if preset==0 enable hpreset
      endif
      prevdata=portdata
    endif
    if Pressed(hsmall) then
      wideboard=0
      Drawboard()
    else if Pressed(hwide) then
      wideboard=1
      Drawboard()
    else if Pressed(hload) then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
        if pulledshuttle!=shuttle then
          pulledshuttle=shuttle
          sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i 2",shuttle)
          i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
          if i<0 return -1
        endif
      endif
      buf[0]=S_LOCKDOOR
      if testertype!=TT_S3 || ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
        buf[1]=1                       // Lock door
      else if shuttle==0 then
        buf[1]=80                      // Load board in left shuttle
      else
        buf[1]=81                      // Load board in right shuttle
      endif
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else if Pressed(hunload) then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then      ////////////////////CHECK, ALSO SEQUENCE
        sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i 2",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
        if i<0 return -1
        pulledshuttle=-1
      endif
    else if Pressed(hpreset) && preset==0 then
      if boardtype==0 then
        f=Fopen("c:\\atg\\hardware\\shuttle_cadjust.txt","rb")
        if f!=NULL then
          Strcpy(s,"PS.Cmd=FileRead c:/atg/hardware/shuttle_cadjust.txt")
          Strcpy(path,"c:\\atg\\hardware\\shuttle_cadjust.txt")
        else
          f=Fopen("c:\\hardware\\shuttle_cadjust.txt","rb")
          Strcpy(s,"PS.Cmd=FileRead c:/hardware/shuttle_cadjust.txt")
          Strcpy(path,"c:\\hardware\\shuttle_cadjust.txt")
        endif
        if f!=NULL then
          Fclose(f)
          i=Sendlmcommand(s,"PS.Ready.FileRead",errtxt,5)
          if i<0 return -1
          preset=(i==1)
        else
          preset=0                       // Shuttle positions not set
        endif
      else
        f=Fopen("c:\\atg\\hardware\\shuttle_comborc.txt","rb")
        if f!=NULL then
          Strcpy(s,"PS.Cmd=FileRead c:/atg/hardware/shuttle_comborc.txt")
          Strcpy(path,"c:\\atg\\hardware\\shuttle_comborc.txt")
        else
          f=Fopen("c:\\hardware\\shuttle_comborc.txt","rb")
          Strcpy(s,"PS.Cmd=FileRead c:/hardware/shuttle_comborc.txt")
          Strcpy(path,"c:\\hardware\\shuttle_comborc.txt")
        endif
        if f!=NULL then
          Fclose(f)
          i=Sendlmcommand(s,"PS.Ready.FileRead",errtxt,5)
          if i<0 return -1
          preset=(i==1)
        else
          preset=0                       // Shuttle positions not set
        endif
      endif
      disable hpreset
    else if Pressed(hadjust) then
      i=Sendlmcommand("MECH.Cmd=SetMode 4","MECH.Ready.SetMode",errtxt,60)
      if i<0 return -1
      i=Sendlmcommand("MECH.Para.Teachin=1","",errtxt,10)
      if i<0 return -1
      adjusting=1
      adjusted=1
      prevdata=-1
    else if hshuttlex!=NULL && Pressed(hshuttlex) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      shuttlex=Min(100.0,Max(0.0,shuttlex))
      change hshuttlex text=format(" %.1f",shuttlex)
    else if hshxscr!=NULL && Pressed(hshxscr) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      delta=Status(hshxscr)
      shuttlex=Min(100.0,Max(0.0,shuttlex+delta*0.5))
      change hshuttlex text=format(" %.1f",shuttlex)
      change hshxscr select=0
    else if Pressed(hok) then
      setini("Cadjust","Board type","%i,%i",wideboard,boardtype)
      setini("Cadjust","Shuttle","%g,%g",shuttlex,shuttley)
      if adjusted!=0 && (portdata & 0x35)==0x20 then
        // Shuttle settings were probably changed, ask to update file.
        clear hright
        change hinfo limits=0,0
        change hinfo text="Save shuttle settings"
        draw window=hright color=BLACK font=TIMESFONT
        draw at 6,30 wrap=RIGHTX-5
        draw text="Would you like to save the actual shuttle settings to the "
        draw text="disk, so that the next C adjust will automatically use "
        draw text="them?\n\n" color=GRAY text="Note: board size and catchers "
        draw text="remain unchanged; if necessary, edit them directly in the "
        draw text=format("file %s.",path)
        hyes=control BUTTON
          window=hright
          position=RIGHTX/2-124,USERY,120,24
          name="是"
          help="按下将架板框设置保存到文件"
        endc
        hno=control BUTTON
          window=hright
          position=RIGHTX/2+5,USERY,120,24
          name="否"
          help="按下可仅在当前会话中使用新的架板框设置"
        endc
        while 1 do
          if Pressed(hexit) then
            return -1
          else if Pressed(hno) then
            break
          else if Pressed(hyes) then
            Getteachinsettings()
            if nlmteachin>0 then
              if boardtype==0 then
                f=Fopen("c:\\atg\\hardware\\shuttle_cadjust.txt","wt")
                if f==NULL f=Fopen("c:\\hardware\\shuttle_cadjust.txt","wt")
              else
                f=Fopen("c:\\atg\\hardware\\shuttle_comborc.txt","wt")
                if f==NULL f=Fopen("c:\\hardware\\shuttle_comborc.txt","wt")
              endif
              if f!=NULL then
                for i=0,i<nlmteachin,i++ do
                  fprintf(f,"%s\n",lmteachin[i])
                enddo
                Fclose(f)
              endif
            endif
            break
          endif
          wait
        enddo
      endif
      break
    else if Pressed(hexit) then
      return -1
    endif
    if t==0 then                       // Send next port query
      SYS.Killimm(32)
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      SYS.Sendimm(32,3,buf)
      t=Time()                         // Timeout 5 seconds
    else if $A[32].length>0 then
      if $A[32].answer==S_INPORT then
        portdata=$A[32].inport         // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if Time()-t>5000 then
      t=0
      err=1                            // No answer from tester
    endif
    wait
  enddo
end

// Installs C adjust board in EPCOS automatical shuttle. Returns 0 on success,
// >0 in case of communication error or -1 if operator decided to interrupt the
// C adjust.
function int InstallboardEPCOS()
  int i,t,x,y,nfing,head,channel,side,movecamera,err
  int videoon,videosizex,videosizey,changed
  float angle,xcoord,zoom,defzoom
  char s[512],errtxt[256],buf[128]
  handle hvideo,hok,hl,hc,hr,hview,hlivevideo,hzoom
  nfing=$LAY.nfing
  err=0
  videoon=0
  clear hright
  change hinfo limits=0,0
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  for i=0,i<nfing,i++
    if used[i*2]==0 continue           // Head is excluded from test
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,s)
  enddo
  t=Time()
  while (1) do
    for i=0,i<nfing,i++
      if used[i*2]==0 continue
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=nfing break                  // All answers came
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>10000 break            // No answer within 10 s timeout
    wait
  enddo
  if ($GLOBAL.debugmode & 0x40)==0 then
    // Move shuttle into the test position.
    change hinfo text="Setting manual mode..."
    errtxt[2]=0
    i=Sendlmcommand("MECH.Cmd=SetMode","MECH.Ready.SetMode",errtxt,10)
    if i<0 return -1
    if errtxt[2]!='2' then
      i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,10)
      if i<0 return -1
    endif
    change hinfo text="Moving up vacuum plate..."
    i=Sendlmcommand("MECH.Cmd=LifterToTestPos",                                \
      "MECH.Ready.LifterToTestPos",errtxt,20)
    if i<0 return -1
    if i==2 err=1                      // Timeout
    if i==0 err=2                      // Unable to move plate
    // May happen that answer to Vacuum won't come. Therefore I ignore the
    // possible timeout.
    i=Sendlmcommand("MECH.Cmd=Vacuum 0",                                       \
      "MECH.Ready.Vacuum",errtxt,5)
    if i<0 return -1
    if i==0 err=2                      // Unable to turn off vacuum
  endif
  if err==0 then
    change hinfo text="放置校验板"
    hvideo=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="视频"
      help="按下可使用摄像机检查Y板位置"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="确定"
      help="当产品正确放置后按下"
    endc
    head=Camerafromy(yshift+155.0,&channel,&side,&angle)
    draw window=hright color=BLACK font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text="Please install holder and C adjust board (BEL337-1), as shown "
    draw text="on the left picture. Use video camera to check its position. "
    draw text="Press " font=MAINFONT text="OK " font=TIMESFONT text="when "
    draw text="board is correctly installed."
    draw show
  endif
  while err==0 do
    if head>=0 && Pressed(hvideo) then
      if videoon==0 then
        hl=control BUTTON
          window=hright
          position=5,USERY+30,RIGHTX/3-5,24
          name="<< 左边"
          help="向左移动相机2.5mm"
        endc
        hc=control BUTTON
          window=hright
          position=5+RIGHTX/3,USERY+30,RIGHTX/3-5,24
          name="中心"
          help="快速移动相机到中心位置"
        endc
        hr=control BUTTON
          window=hright
          position=5+2*(RIGHTX/3),USERY+30,RIGHTX/3-9,24
          name="右边 >>"
          help="向右移动相机2.5mm"
        endc
        hview=control CHILD            // Video is not yet here, create controls
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          bkcolor=VIDEOFILL
        endc
        Bccreate(hview,-1,-1,channel,0)
        hzoom=control CUSTOMBOX
          window=hview
          position=235,303,80,21
          name="放大"
          help="勾选提升放大倍数到2"
          color=BROWN
        endc
        SYS.Videosize(channel,&videosizex,&videosizey,&i)
        if videosizex==0 || videosizey==0 then
          defzoom=0.5
        else
          defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
        endif
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
          Bcgetbri(channel),Bcgetctr(channel),                                 \
          (channel<0?0:2)|(longexp?4:0),angle)
        movecamera=1; xcoord=$LAY.xoffset/1000.0
        x=(LEFTX-10)/2; y=288/2
        draw window=hlivevideo color=LIGHTRED
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        videoon=1
      else
        Bcdelete()                     // Video is already here, remove controls
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        videoon=0
      endif
    else if Pressed(hok) then
      break
    else if Pressed(hexit) then
      err=-1
    endif
    if videoon then
      changed=Bcupdate()
      if (changed & 0x01)!=0 || Pressed(hzoom) then
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      endif
      if (changed & 0x02)!=0 then
        movecamera=1
      endif
      if Pressed(hc) then
        xcoord=$LAY.xoffset/1000.0
        movecamera=1
      else if Pressed(hl) then
        xcoord=Max(xcoord-2.5,leftvlimit)
        movecamera=1
      else if Pressed(hr) then
        xcoord=Min(xcoord+2.5,rightvlimit)
        movecamera=1
      endif
      if movecamera!=0 && head>=0 then
        if $LAY.cameras!=0 then
          sprintf(buf,"M %i(%g,%g) NOP",                                       \
          $LAY.nfing*2+channel,xcoord,yshift+155.0)
        else if $LAY.headcameras!=0 then
          SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
          sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          SERV.Cmdimm(33,buf)
          sprintf(buf,"M @%i[%g,%g] NOP",head,xcoord,yshift+155.0)
        endif
        SERV.Cmdimm(32,buf)            // Move camera to middle row of pads
        movecamera=0
      endif
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  if videoon!=0 then
    Bcdelete()
    destroy hview
    destroy hl
    destroy hc
    destroy hr
  endif
  if err>0 then
    if head>=0 then
      sprintf(buf,"M %i(Z) NOP",head)
      SERV.Cmdimm(32,buf)              // Move camera in home position
    endif
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="按下检查测试机状态"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED text="Communication error! "
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from tester within expected timeout. "
    else
      draw text="Tester was unable to move up the vacuum plate. "
    endif
    if err!=2 draw text="Please check connection with crate controller. "
    draw text="Press " font=MAINFONT text="Retry " font=TIMESFONT
    draw text="to check tester status and, eventually, reboot it."
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  return err
end

// Selects crosses that will be used to scan board position. Assumes that board
// type, yshift and handicaps are already set.
function int Setcrosses()
  int i,j,channel,side
  float y0,y1,angle
  crosstype=-1
  if boardtype==0 then
    // On the dedicated (old) board we have no choice.
    Memcpy(crossx,origcrossx,Sizeof(origcrossx))
    Memcpy(crossy,origcrossy,Sizeof(origcrossy))
    crosstype=0
  else if boardtype==1 then
    // New (combo) board, try 7 combinations.
    for i=1,i<8,i++ do
      switch i
      case 1:                          // Full-length vertical base
        crossx[0]=-78.2; crossy[0]=0.0; crossx[1]=-78.2; crossy[1]=310.0
      case 2:                          // Half-length vertical base bottom
        crossx[0]=-78.2; crossy[0]=0.0; crossx[1]=-78.2; crossy[1]=155.0
      case 3:                          // Half-length vertical base top
        crossx[0]=-78.2; crossy[0]=155.0; crossx[1]=-78.2; crossy[1]=310.0
      case 4:                          // Horizontal base center (lower)
        crossx[0]=-78.2; crossy[0]=155.0; crossx[1]=0.0; crossy[1]=141.0
      case 5:                          // Horizontal base center (upper)
        crossx[0]=-78.2; crossy[0]=155.0; crossx[1]=0.0; crossy[1]=169.0
      case 6:                          // Horizontal base bottom
        crossx[0]=-78.2; crossy[0]=0.0; crossx[1]=0.0; crossy[1]=7.0
      case 7:                          // Horizontal base top
        crossx[0]=-78.2; crossy[0]=310.0; crossx[1]=0.0; crossy[1]=303.0
      endsw
      // Check whether combination is acceptable.
      y0=crossy[0]+yshift
      y1=crossy[1]+yshift
      if testertype==TT_S3 &&                                                  \
        (y0<$LAY.yoffset[0]/1000.0 || y0>$LAY.yoffset[1]/1000.0 ||             \
        y1<$LAY.yoffset[0]/1000.0 || y1>$LAY.yoffset[1]/1000.0)                \
        continue
      if $LAY.cameras!=0 && y0>=$LAY.bottom[$LAY.nfing]/1000.0 &&              \
        y1<$LAY.top[$LAY.nfing]/1000.0 then
        crosstype=i
        break
      else if $LAY.cameras==0 && $LAY.headcameras!=0 &&                        \
        Camerafromy(y0,&channel,&side,&angle)>=0 &&                            \
        Camerafromy(y1,&channel,&side,&angle)>=0 then
        crosstype=i
        break
      endif
    enddo
  else if boardtype==2 then
    // XXL board for A7.
    for i=1,i<13,i++ do
      switch i
      case 1:                          // Full-length vertical base
        crossx[0]=-78.2; crossy[0]=0.0
        crossx[1]=-78.2; crossy[1]=750.0
      case 2,3:                        // Two-third vertical base
        crossx[0]=-78.2; crossy[0]=250.0*(i-2)
        crossx[1]=-78.2; crossy[1]=250.0*(i-0)
      case 4,5,6:                      // One-third vertical base
        crossx[0]=-78.2; crossy[0]=250.0*(i-4)
        crossx[1]=-78.2; crossy[1]=250.0*(i-3)
      case 7:                          // Horizontal base (bottom)
        crossx[0]=-78.2; crossy[0]=0.0
        crossx[1]=78.2; crossy[1]=7.0
      case 8:                          // Horizontal base (top)
        crossx[0]=-78.2; crossy[0]=750.0
        crossx[1]=78.2; crossy[1]=743.0
      case 9,10:                       // Horizontal base (up-oriented)
        crossx[0]=-78.2; crossy[0]=250.0*(i-8)
        crossx[1]=78.2; crossy[1]=250.0*(i-8)+14.0
      case 11,12:                      // Horizontal base (down-oriented)
        crossx[0]=-78.2; crossy[0]=250.0*(i-10)
        crossx[1]=78.2; crossy[1]=250.0*(i-10)-14.0
      endsw
      // Check whether combination is acceptable.
      y0=crossy[0]+yshift
      y1=crossy[1]+yshift
      if $LAY.cameras!=0 && y0>=$LAY.bottom[$LAY.nfing]/1000.0 &&              \
        y1<$LAY.top[$LAY.nfing]/1000.0 then
        crosstype=i
        break
      else if $LAY.cameras==0 && $LAY.headcameras!=0 &&                        \
        Camerafromy(y0,&channel,&side,&angle)>=0 &&                            \
        Camerafromy(y1,&channel,&side,&angle)>=0 then
        crosstype=i
        break
      endif
    enddo
  else
    // XXXL board for A7/24.
    for i=1,i<13,i++ do
      switch i
      case 1:                          // Full-length vertical base
        crossx[0]=-78.2; crossy[0]=0.0
        crossx[1]=-78.2; crossy[1]=1000.0
      case 2,3:                        // Three-fourth vertical base
        crossx[0]=-78.2; crossy[0]=250.0*(i-2)
        crossx[1]=-78.2; crossy[1]=250.0*(i+1)
      case 4,5,6:                      // One-half vertical base
        crossx[0]=-78.2; crossy[0]=250.0*(i-4)
        crossx[1]=-78.2; crossy[1]=250.0*(i-2)
      case 7:                          // Horizontal base (bottom)
        crossx[0]=-78.2; crossy[0]=0.0
        crossx[1]=78.2; crossy[1]=7.0
      case 8:                          // Horizontal base (top)
        crossx[0]=-78.2; crossy[0]=1000.0
        crossx[1]=78.2; crossy[1]=993.0
      case 9,10:                       // Horizontal base (up-oriented)
        crossx[0]=-78.2; crossy[0]=250.0*(i-8)
        crossx[1]=78.2; crossy[1]=250.0*(i-8)+14.0
      case 11,12:                      // Horizontal base (down-oriented)
        crossx[0]=-78.2; crossy[0]=250.0*(i-10)
        crossx[1]=78.2; crossy[1]=250.0*(i-10)-14.0
      endsw
      // Check whether combination is acceptable.
      y0=crossy[0]+yshift
      y1=crossy[1]+yshift
      if $LAY.cameras!=0 && y0>=$LAY.bottom[$LAY.nfing]/1000.0 &&              \
        y1<$LAY.top[$LAY.nfing]/1000.0 then
        crosstype=i
        break
      else if $LAY.cameras==0 && $LAY.headcameras!=0 &&                        \
        Camerafromy(y0,&channel,&side,&angle)>=0 &&                            \
        Camerafromy(y1,&channel,&side,&angle)>=0 then
        crosstype=i
        break
      endif
    enddo
  endif
end

// Function converts board coordinates xb,yb into tester coordinates xt,yt.
// Then it adds random offset limited to (-delta,+delta). In-place conversion
// is also allowed here.
function int Convert(float *xt, float *yt,float xb,float yb,float delta)
  float x,y
  x=xb*convcfi-yb*convsfi+convdx
  y=xb*convsfi+yb*convcfi+convdy
  if delta>0.0 then
    x=x+Random(delta)+Random(delta)-delta
    y=y+Random(delta)+Random(delta)-delta
  endif
  xt[0]=x
  yt[0]=y
end

// Function calculates tester coordinates xt,yt of pad name for given head.
// Then it adds random offset limited to (-delta,+delta). Returns -1.0 if pad
// not found and non-negative related value if coordinates are calculated.
function float Convertpad(float *xt, float *yt,char *name,int head,float delta)
  int i
  float x,y
  for i=0,i<NPOINT,i++ do
    if Strcmp(name,xname[i])==0 break
  enddo
  if i>=NPOINT return -1.0
  x=xpos[i]*convcfi-ypos[head]*convsfi+convdx
  y=xpos[i]*convsfi+ypos[head]*convcfi+convdy
  if delta>0.0 then
    x=x+Random(delta)+Random(delta)-delta
    y=y+Random(delta)+Random(delta)-delta
  endif
  xt[0]=x
  yt[0]=y
  return value[i]
end

// Returns ideal X coordinate of the pad with specified name, or 0 on error.
function float Getpadx(char *name)
  int i
  for i=0,i<NPOINT,i++ do
    if Strcmp(name,xname[i])==0 then
      return xpos[i]
    endif
  enddo
  return 0.0
end

// Allows to find rough position of the board in the shuttle. Returns -1 if
// operator interrupted test, 0 if both crosses are found correctly and
// automatical scanning is requested, 1 if both crosses are found correctly and
// operator decided to omit automatical scanning and 2 if operator requested to
// change board placement.
function int Positionboard()
  int i,ret,head,prevhead,channel,side,x,y,type
  int selected,firstpos,changepos,newvideo,newlights
  int showcrosses,iscrosses,x1,y1,x2,y2,changed
  int videosizex,videosizey,reach1,reach2,maxdy
  float r1,r2,tx,ty,centerx,posx,posy,vstep,defzoom,zoom,angle
  char buf[512]
  handle hmanual,hpos1,hpos2,hpos,hok,hrepos,hu,hl,hr,hd,hx,hy
  handle hview,hlivevideo,hzoom,hcrosses
  clear hleft
  clear hright
  wait; wait; wait                     // Force redraw to avoid overlapping
  change hinfo limits=0,0
  change hinfo text="查找位置"
  ret=0
  // Get expected positions of crosses.
  Setcrosses()
  showcrosses=(boardtype!=0)
  iscrosses=-1
  // Check whether we can use crosses.
  scanrail=-1
  if Camerafromy(crossy[0]+yshift,&channel,&side,&angle)<0 ||                  \
    Camerafromy(crossy[1]+yshift,&channel,&side,&angle)<0                      \
  then
    for i=0,i<$LAY.nfing,i++ do
      if $LAY.side[i]!=0 break
      if $LAY.cameras==0 && $LAY.headcameras!=0 &&                             \
        ($LAY.headcameras & (1<<(i*2)))==0 continue
      if ($LAY.excludedrails & (1<<i))!=0 continue
      scanrail=i
      break
    enddo
  endif
  if scanrail<0 then
    pos1x=0.0; pos1y=0.0; type=-1
    getini("Cadjust","Left cross","%g,%g,%i",&pos1x,&pos1y,&type)
    pos2x=0.0; pos2y=0.0
    getini("Cadjust","Right cross","%g,%g",&pos2x,&pos2y)
    r1=Sqrt((pos2x-pos1x)*(pos2x-pos1x)+(pos2y-pos1y)*(pos2y-pos1y))
    r2=Sqrt((crossx[1]-crossx[0])*(crossx[1]-crossx[0])+                       \
      (crossy[1]-crossy[0])*(crossy[1]-crossy[0]))
    if type!=crosstype || r1>r2*1.05 || r2>r1*1.05 ||                          \
      Abs(crossy[0]+yshift-pos1y)>5.0 || Abs(crossy[1]+yshift-pos2y)>5.0       \
    then
      if testertype==TT_A5L && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
        if boardtype==0 then
          pos1x=$LAY.rightlimit/1000.0-(crossx[1]-crossx[0])/2.0-10.0
        else
          pos1x=$LAY.rightlimit/1000.0+crossx[0]-90.0
        endif
      else
        if boardtype==0 then
          pos1x=$LAY.xoffset/1000.0-(crossx[1]-crossx[0])/2.0
        else
          pos1x=$LAY.xoffset/1000.0+crossx[0]
        endif
      endif
      pos2x=pos1x+crossx[1]-crossx[0]
      pos1y=yshift+crossy[0]
      pos2y=yshift+crossy[1]
    endif
  else
    crossx[0]=Getpadx("SIG")
    if boardtype==0 then
      crossx[1]=Getpadx("GND")
    else
      crossx[1]=Getpadx("C")
    endif
    if boardtype==0 && wideboard!=0 then
      crossx[0]=crossx[0]-10.0
      crossx[1]=crossx[1]+10.0
    endif
    if boardtype==2 || boardtype==3 then
      crossy[0]=250.0*(scanrail>3?3:scanrail)
      crossy[1]=250.0*(scanrail>3?3:scanrail)
    else
      crossy[0]=155.0*(scanrail>2?2:scanrail)
      crossy[1]=155.0*(scanrail>2?2:scanrail)
    endif
    if testertype==TT_A5L && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      pos1x=$LAY.rightlimit/1000.0-70.0+crossx[0]
      pos2x=$LAY.rightlimit/1000.0-70.0+crossx[1]
    else if testertype==TT_S2 && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      pos1x=$LAY.leftlimit/1000.0+70.0+crossx[0]
      pos2x=$LAY.leftlimit/1000.0+70.0+crossx[1]
    else
      pos1x=$LAY.xoffset/1000.0+crossx[0]
      pos2x=$LAY.xoffset/1000.0+crossx[1]
    endif
    pos1y=yshift+crossy[0]
    pos2y=yshift+crossy[1]
    tx=pos1x; ty=pos1y
    if wideboard then
      getini("Cadjust","Left wide cross","%g,%g",&tx,&ty)
    else
      getini("Cadjust","Left pad","%g,%g",&tx,&ty)
    endif
    if Abs(ty-pos1y)<10.0 then
      pos1x=tx
      pos1y=ty
    endif
    tx=pos2x; ty=pos2y
    if wideboard then
      getini("Cadjust","Right wide cross","%g,%g",&tx,&ty)
    else
      getini("Cadjust","Right pad","%g,%g",&tx,&ty)
    endif
    if Abs(ty-pos2y)<10.0 then
      pos2x=tx
      pos2y=ty
    endif
  endif
  crossdist=Sqrt((crossx[1]-crossx[0])*(crossx[1]-crossx[0])+                  \
    (crossy[1]-crossy[0])*(crossy[1]-crossy[0]))
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  reach1=Camerafromy(crossy[0]+yshift,&channel,&side,&angle)
  reach2=Camerafromy(crossy[1]+yshift,&channel,&side,&angle)
  if $LAY.cameras==0 && $LAY.headcameras!=0 && (reach1<0 || reach2<0) then
    if reach1<0 && reach2<0 then
      showcrosses=0
      draw text="Fiducials (crosses on the top and bottom of the board) are "
      draw text="not reachable by head cameras. The only way to position the "
      draw text="board is by trials and errors. Press "
    else if reach1<0 then
      draw text="Bottom fiducial (cross) on the board is not reachable by "
      draw text="head camera. Use trials and errors to guess the position "
      draw text="of the top cross. Press "
    else
      draw text="Top fiducial (cross) on the board is not reachable by "
      draw text="head camera. Use trials and errors to guess the position "
      draw text="of the bottom cross. Press "
    endif
  else if scanrail<0 then
    draw text="现在找到2个基准点的大概位置,"
    if boardtype==0 then
      draw text=" (crosses on the top and bottom of the board). "
    else
      draw text="如左图\n所示."
    endif
    draw text="按" font=MAINFONT text="十字1" font=TIMESFONT
    draw text="或" font=MAINFONT text="十字2" font=TIMESFONT
    draw text="选择十字,然后"
  else if wideboard then
    draw text="Now find rough positions of two fiducials (crosses to the left "
    draw text="and right of the pads). Press " font=MAINFONT text="Cross1 "
    draw font=TIMESFONT text="or " font=MAINFONT text="Cross2 " font=TIMESFONT
    draw text="to select cross, then "
  else
    draw text="Now find rough positions of two fiducials (leftmost and "
    draw text="rightmost pads) on the board. Press " font=MAINFONT text="Pad 1 "
    draw font=TIMESFONT text="or " font=MAINFONT text="Pad 2 " font=TIMESFONT
    draw text="to select pad, then "
  endif
  draw font=MAINFONT text="按确定" font=TIMESFONT text="\n当找到基准时.如果需要弹出架板框或\n调整校验板位置,"
  draw text="按" font=MAINFONT text="重放置" font=TIMESFONT
  draw text=".\n"
  draw color=DARKGRAY font=INFOFONT at 11,USERY-81 text="当前 X="
  i=0
  getini("Cadjust","Skip autoscan","%i",&i)
  hmanual=control CUSTOMBOX
    window=hright
    position=10,USERY-130,RIGHTX-20,22
    name="无须自动扫描基准点"
    help="勾选后无需自动扫描基准点"
    mode=(i==0 && reach1>=0 && reach2>=0?0:M_CHECKED)
  endc
  hx=control TEXT
    window=hright
    position=82,USERY-100,54,22
    help="相机X轴实际坐标"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 139,USERY-81 text=", Y="
  hy=control TEXT
    window=hright
    position=168,USERY-100,54,22
    help="相机Y轴实际坐标"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 227,USERY-81 text="mm"
  draw show
  hu=control BUTTON
    window=hright
    position=60,USERY-58,40,40
    name="上"
    help="点击上移相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hl=control BUTTON
    window=hright
    position=18,USERY-15,40,40
    name="左"
    help="点击左移相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hr=control BUTTON
    window=hright
    position=102,USERY-15,40,40
    name="右"
    help="点击右移相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hd=control BUTTON
    window=hright
    position=60,USERY+27,40,40
    name="下"
    help="点击下移相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  y=(boardtype!=0?USERY-61:USERY-57)
  hpos1=control BUTTON
    window=hright
    position=166,y,RIGHTX-180,24
    name=(scanrail<0 || wideboard?"+字1":"测点1")
    help="点击寻找第一个基准点位置"
    color=LIGHTRED
    bkcolor=YELLOW
  endc
  y=y+(boardtype!=0?26:30)
  selected=1
  hpos2=control BUTTON
    window=hright
    position=166,y,RIGHTX-180,24
    name=(scanrail<0 || wideboard?"+字2":"测点2")
    help="点击寻找第二个基准点位置"
  endc
  y=y+(boardtype!=0?28:40)
  if boardtype!=0 then
    hpos=control BUTTON
      window=hright
      position=166,y,RIGHTX-180,24
      name="方案"
      help="点击显示需要用到的十字点"
    endc
    y=y+28
  endif
  hok=control BUTTON
    window=hright
    position=166,y,RIGHTX-180,24
    name="确定"
    help="校验板粗略位置找到后点击"
  endc
  disable hok
  y=y+(boardtype!=0?26:30)
  hrepos=control BUTTON
    window=hright
    position=166,y,RIGHTX-180,24
    name="重放置"
    help="需要调整校验板位置时点击"
  endc
  disable hrepos
  // Initially hidden window that displays crosses on the combo R/C board
  // used for scanning.
  hcrosses=control CHILD
    window=hleft
    position=1000,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=1024
  endc
  if boardtype==1 then
    draw window=hcrosses at 100,50 bitmap=0,0,0,"rcboard"
    switch crosstype
    case 1:                            // Full-length vertical base
      x1=9; y1=157; x2=9; y2=27
    case 2:                            // Half-length vertical base bottom
      x1=9; y1=157; x2=9; y2=92
    case 3:                            // Half-length vertical base top
      x1=9; y1=92; x2=9; y2=27
    case 4:                            // Horizontal base center (lower)
      x1=9; y1=92; x2=62; y2=105
    case 5:                            // Horizontal base center (upper)
      x1=9; y1=92; x2=62; y2=79
    case 6:                            // Horizontal base bottom
      x1=9; y1=157; x2=62; y2=150
    case 7:                            // Horizontal base top
      x1=9; y1=27; x2=62; y2=34
    endsw
    x1=x1+100; y1=y1+50; x2=x2+100; y2=y2+50
  else if boardtype==2 then
    draw window=hcrosses at 100,5 bitmap=0,0,0,"rclarge"
    x1=174.0+crossx[0]/1.80
    y=Floor(crossy[0]/250.0+0.5)*250.0
    y1=292.0-y/2.84-(crossy[0]-y)/1.80
    x2=174.0+crossx[1]/1.80
    y=Floor(crossy[1]/250.0+0.5)*250.0
    y2=292.0-y/2.84-(crossy[1]-y)/1.80
  else
    draw window=hcrosses at 100,4 bitmap=0,0,0,"rc24"
    x1=174.0+crossx[0]/1.80
    y=Floor(crossy[0]/250.0+0.5)*250.0
    y1=332.0-y/3.20-(crossy[0]-y)/1.80
    x2=174.0+crossx[1]/1.80
    y=Floor(crossy[1]/250.0+0.5)*250.0
    y2=332.0-y/3.20-(crossy[1]-y)/1.80
  endif
  draw color=LIGHTRED font=LARGEFONT
  if reach1>=0 then
    draw at x1-7,y1-7 rect x1+8,y1+8
    draw at x1-8,y1-8 rect x1+9,y1+9
    draw at x1-9,y1-9 rect x1+10,y1+10
    draw at x1+13,y1+18 text="1"
  endif
  if reach2>=0 then
    draw at x2-7,y2-7 rect x2+8,y2+8
    draw at x2-8,y2-8 rect x2+9,y2+9
    draw at x2-9,y2-9 rect x2+10,y2+10
    draw at x2+13,y2+18 text="2"
  endif
  if boardtype!=3 then
    draw font=TIMESFONT color=BLACK wrap=LEFTX-5
    draw at 10,(boardtype==2 || boardtype==3?341:300)
    draw text="+用来扫描定位,按  " font=MAINFONT
    draw text="+字1 " font=TIMESFONT text="或 " font=MAINFONT
    draw text="+字2 " font=TIMESFONT text="显示实时视频。"
  endif
  draw show
  hview=control CHILD
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    bkcolor=VIDEOFILL
    help="相机中实时影像"
  endc
  Bccreate(hview,-1,-1,channel,1)
  hzoom=control CUSTOMBOX
    window=hview
    position=235,303,80,21
    name="放大"
    help="勾选提升放大倍数到2"
    color=BROWN
  endc
  x=(LEFTX-10)/2; y=288/2
  draw window=hlivevideo color=LIGHTRED
  draw at x-20,y to x-5,y at x+6,y to x+21,y
  draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
  if scanrail>=0 && wideboard==0 then
    draw at x-20,y-40 rect x+21,y+41
  endif
  draw show
  changepos=1                          // Force camera movement
  firstpos=1                           // Change second offset simultaneously
  SYS.Killimm(32); $A[32].length=1     // Mark answer as available
  newvideo=1                           // Change camera settings
  newlights=1                          // Change illumination settings
  prevhead=-1
  SYS.Videosize(channel,&videosizex,&videosizey,&i)
  if videosizex==0 || videosizey==0 then
    defzoom=0.5
  else
    defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
  endif
  while 1 do
    changed=Bcupdate()
    if (changed & 0x01)!=0 newvideo=1
    if (changed & 0x02)!=0 then
      changepos=1
      newlights=1
    endif
    if showcrosses!=iscrosses then
      if showcrosses==1 then
        change hcrosses position=-1,-1,LEFTX,LEFTY
        change hview position=1000,-1,LEFTX,LEFTY
        change hpos2 color=BLACK
        change hpos2 bkcolor=GRAY
        change hpos1 color=BLACK
        change hpos1 bkcolor=GRAY
        change hpos color=LIGHTRED
        change hpos bkcolor=YELLOW
      else
        change hcrosses position=1000,-1,LEFTX,LEFTY
        change hview position=-1,-1,LEFTX,LEFTY
        if selected==1 then
          change hpos1 color=LIGHTRED
          change hpos1 bkcolor=YELLOW
          change hpos2 color=BLACK
          change hpos2 bkcolor=GRAY
        else
          change hpos2 color=LIGHTRED
          change hpos2 bkcolor=YELLOW
          change hpos1 color=BLACK
          change hpos1 bkcolor=GRAY
        endif
        if boardtype!=0 then
          change hpos color=BLACK
          change hpos bkcolor=GRAY
        endif
      endif
      iscrosses=showcrosses
    endif
    if showcrosses==0 && changepos==0 && $A[32].length>1 then
      enable hok
      enable hrepos
    endif
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hok) then
      if scanrail<0 then
        setini("Cadjust","Left cross","%g,%g,%i",pos1x,pos1y,crosstype)
        setini("Cadjust","Right cross","%g,%g",pos2x,pos2y)
      else if wideboard then
        setini("Cadjust","Left wide cross","%g,%g",pos1x,pos1y)
        setini("Cadjust","Right wide cross","%g,%g",pos2x,pos2y)
      else
        setini("Cadjust","Left pad","%g,%g",pos1x,pos1y)
        setini("Cadjust","Right pad","%g,%g",pos2x,pos2y)
      endif
      ret=Status(hmanual);
      setini("Cadjust","Skip autoscan","%i",ret)
      break
    else if Pressed(hrepos) then
      for head=0,head<$LAY.nfing*2,head++ do
        sprintf(buf,"M %i(Z) NOP",head)
        SERV.Cmdimm(32,buf)
      enddo
      ret=2; break
    else if Pressed(hpos1) then
      showcrosses=0
      if selected!=1 then
        change hpos1 color=LIGHTRED
        change hpos1 bkcolor=YELLOW
        change hpos2 color=BLACK
        change hpos2 bkcolor=GRAY
        if boardtype!=0 then
          change hpos color=BLACK
          change hpos bkcolor=GRAY
        endif
        selected=1; changepos=1; firstpos=0
      endif
    else if Pressed(hpos2) then
      showcrosses=0
      if selected!=2 then
        change hpos2 color=LIGHTRED
        change hpos2 bkcolor=YELLOW
        change hpos1 color=BLACK
        change hpos1 bkcolor=GRAY
        if boardtype!=0 then
          change hpos color=BLACK
          change hpos bkcolor=GRAY
        endif
        selected=2; changepos=1; firstpos=0
      endif
    else if Pressed(hpos) then
      showcrosses=1
    else if Pressed(hzoom) then
      newvideo=1
    endif
    if selected==1 then
      posx=pos1x; posy=pos1y
    else
      posx=pos2x; posy=pos2y
    endif
    vstep=VSTEP
    if Status(hmanual)==1 vstep=vstep/10.0
    if Pressed(hu) then
      if (firstpos) pos2y=pos2y+vstep
      posy=posy+vstep; changepos=1
    else if Pressed(hl) then
      if (firstpos) pos2x=pos2x-vstep
      posx=posx-vstep; changepos=1
    else if Pressed(hr) then
      if (firstpos) pos2x=pos2x+vstep
      posx=posx+vstep; changepos=1
    else if Pressed(hd) then
      if (firstpos) pos2y=pos2y-vstep
      posy=posy-vstep; changepos=1
    endif
    if changepos!=0 then
      if selected==1 then
        pos1x=posx; pos1y=posy
      else
        pos2x=posx; pos2y=posy
      endif
      if scanrail<0 then
        pos1x=Max(leftvlimit,Min(rightvlimit-(crossx[1]-crossx[0]),pos1x))
        pos1y=Max(yshift+crossy[0]-MAXERR,Min(yshift+crossy[0]+MAXERR,pos1y))
        pos2x=Max(leftvlimit+(crossx[1]-crossx[0]),Min(rightvlimit,pos2x))
        pos2y=Max(yshift+crossy[1]-MAXERR,Min(yshift+crossy[1]+MAXERR,pos2y))
      else
        centerx=$LAY.xoffset/1000.0
        pos1x=Max(centerx+crossx[0]-150.0,Min(centerx+crossx[0]+50.0,pos1x))
        pos1y=Max(yshift+crossy[0]-MAXERR,Min(yshift+crossy[0]+MAXERR,pos1y))
        pos2x=Max(centerx+crossx[1]-150.0,Min(centerx+crossx[1]+50.0,pos2x))
        pos2y=Max(yshift+crossy[1]-MAXERR,Min(yshift+crossy[1]+MAXERR,pos2y))
      endif
      if selected==1 then              // This repetition is correct
        posx=pos1x; posy=pos1y
      else
        posx=pos2x; posy=pos2y
      endif
      change hx text=format("%5.1f",posx)
      change hy text=format("%5.1f",posy)
      if $A[32].length!=0 then
        // Previous movement is finished, start new.
        if selected==1 then
          head=Camerafromy(crossy[0]+yshift,&channel,&side,&angle)
        else
          head=Camerafromy(crossy[1]+yshift,&channel,&side,&angle)
        endif
        if $LAY.cameras!=0 then        // Dedicated camera
          sprintf(buf,"M %i(%g,%g) NOP",head,posx,posy)
        else                           // Head camera, move other heads away
          if head!=prevhead || newlights then
            for i=0,i<$LAY.nfing*2,i++ do
              if i==head continue
              sprintf(buf,"M %i(Z) NOP",i)
              SERV.Cmdimm(33,buf)
            enddo
            if prevhead>=0 then
              sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,0",prevhead)
              SERV.Cmdimm(33,buf)
            endif
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
            SERV.Cmdimm(33,buf)
            prevhead=head
            newlights=0
          endif
          sprintf(buf,"M @%i[%g,%g] NOP",head,posx,posy)
          newvideo=1
        endif
        SERV.Cmdimm(32,buf)
        changepos=0
      endif
    endif
    if newvideo then
      if selected==1 then
        head=Camerafromy(crossy[0]+yshift,&channel,&side,&angle)
      else
        head=Camerafromy(crossy[1]+yshift,&channel,&side,&angle)
      endif
      zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
      Bcsetcam(channel)
      SYS.Videoangle(hlivevideo,channel,side,zoom,                             \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      newvideo=0
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  Bcdelete()
  destroy hview
  return ret
end

// Searches for the fiducial in the vicinity of the coordinates (posx,posy)
// using camera selected by idealy. Returns -1 if operator decided to interrupt
// the test, 2 if procedure was unable to define fiducial, 3 if fiducial was
// not found, 4 if camera was unable to reach the fiducial, and 0 if fiducial
// was found correctly and posx and posy are assigned corrected coordinates.
function int Searchcross(handle hlivevideo,float *posx,float *posy,float idealy)
  int i,j,t,head,active,channel,videox,videoy,side,clip
  int attempts,nfound,videosizex,videosizey,err
  float x,y,dx,dy,bestx,besty,angle,xsc,ysc,found[4][3],corrmax,zoom
  char s[512]
  handle hfid[5]
  x=posx[0]; y=posy[0]
  attempts=8; err=0
  head=Camerafromy(idealy,&channel,&side,&angle)
  if head<0 err=4
  active=-1                            // Active head is yet undefined
  SYS.Videosize(channel,&videosizex,&videosizey,&i)
  if videosizex==0 || videosizey==0 then
    zoom=0.5
  else
    zoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
  endif
  SYS.Killimm(32)                      // Recover from previous scanning
  while (attempts>0 && err==0) do
    attempts--
    Bcsetcam(channel)
    SYS.Videoangle(hlivevideo,channel,side,zoom,                               \
      Bcgetbri(channel),Bcgetctr(channel),                                     \
      (channel<0?0:2)|(longexp?4:0),angle)
    if head!=active then
      // Define fiducials for new camera, first deleting existing ones.
      for j=0,j<5,j++ do
        if hfid[j]!=NULL SYS.Deletemodel(hfid[j])
      enddo
      sprintf(s,"Video scale[%i]",side)
      xsc=6.4; ysc=6.4                 // Default video magnification
      getini("System",s,"%f,%f",&xsc,&ysc)
      xsc=Max(0.2,Min(12.0,xsc))
      ysc=Max(0.2,Min(12.0,ysc))
      for j=0,j<5,j++ do               // Different thickness (-25%,0,+25%)
        if scanrail<0 || wideboard!=0 then
          hfid[j]=SYS.Syntmodel(channel,SYNT_CROSS,                            \
          512.0/xsc,64.0*linewidth*(j+6)/xsc,0,0,0)
        else
          hfid[j]=SYS.Syntmodel(channel,SYNT_RECT,                             \
          64.0*0.9*(j+6)/xsc,64.0*1.8*(j+6)/xsc,0,0,0)
        endif
        if hfid[j]==NULL err=2         // Unable to define fiducial
      enddo
      if err!=0 break
    endif
    // Move camera into the coordinates. In case of head cameras, all other
    // heads must be moved away.
    if $LAY.cameras!=0 then            // Dedicated camera
      sprintf(s,"M %i(%g,%gA5) NOP",head,x,y)
      clip=0
    else                               // Head camera, move other heads away
      if head!=active then
        for i=0,i<$LAY.nfing*2,i++ do
          if i==head continue
          sprintf(s,"M %i(Z) NOP",i)
          SERV.Cmdimm(33,s)
        enddo
        if active>=0 then
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",active)
          SERV.Cmdimm(33,s)
        endif
        sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
        SERV.Cmdimm(33,s)
      endif
      sprintf(s,"M @%i[%g,%g] NOP",head,x,y)
      clip=((head^side) & 1?1:-1)
    endif
    SERV.Cmdimm(32,s)
    active=head
    t=Time()
    while $A[32].length==0 && err==0 do
      if Pressed(hexit) err=-1         // Operator interrupted test
      if Time()-t>10000 err=1          // Timeout
      wait
    enddo
    if err!=0 break
    if $A[32].answer!=S_NOP then
      err=4; break
    endif
    delay 200                          // Some additional delay for camera
    SYS.Nextframe(channel)
    SYS.Videosize(channel,&videox,&videoy,&j)
    corrmax=0.0
    for j=0,j<5,j++ do
      if hfid[j]==NULL continue
      nfound=SYS.Recognangle(hfid[j],0,0,videox,videoy,found,angle,clip)
      if nfound==0 continue
      if found[0,2]>corrmax then
        bestx=found[0,0]
        besty=found[0,1]
        corrmax=found[0,2]
      endif
    enddo
    dx=(bestx-videox/2)*xsc/512.0
    dy=(besty-videoy/2)*ysc/512.0
    // Offsets dx and dy are given in millimeters along the camera
    // axes. We must rotate them into the tester coordinates.
    x=x+(dx*Cos(angle)+dy*Sin(angle))*(side==0?1.0:-1.0)
    y=y-(dy*Cos(angle)-dx*Sin(angle))
    if Abs(dx)<0.1 && Abs(dy)<0.1 then
      posx[0]=x                        // Fiducial found exactly
      posy[0]=y
      break
    endif
  enddo
  if attempts<=0 err=3
  // Clean up and report result.
  for j=0,j<5,j++ do
    if hfid[j]!=NULL SYS.Deletemodel(hfid[j])
  enddo
  if err==0 then
    delay 1000                        // Let user see the cross
  endif
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  return err
end

// Gets type of attached automation (half-automate, automate etc.) into the
// global variables automationtype and isauto. As these parameters are not
// important for the calibration, there is no error processing.
function int Getautomationtype()
  int t
  char buf[32]
  buf[0]=S_DEBUG
  buf[1]=0x14                          // Query type of the automation
  SYS.Sendimm(32,2,buf)
  t=Time()
  automationtype=AUTO_UNKNOWN
  isauto=0
  while $A[32].length==0 do
    if Time()-t>2000 then
      SYS.Killimm(32)                  // Timeout, automation type is unknown
      return
    endif
    wait
  enddo
  if $A[32].answer!=S_DEBUG || $A[32].length!=9 return
  automationtype=$uint2($A[32]+5)
  if automationtype==AUTO_A2 || automationtype==AUTO_A4SEMI ||                 \
    automationtype==AUTO_A4FULL || automationtype==AUTO_A6SEMI ||              \
    automationtype==AUTO_A6FULL || automationtype==AUTO_A5LMSEMI ||            \
    automationtype==AUTO_A5LMFULL || automationtype==AUTO_S2LMMAN ||           \
    automationtype==AUTO_S2LMSEMI || automationtype==AUTO_S2LMFULL ||          \
    automationtype==AUTO_S2LMDCF || automationtype==AUTO_A7LMSEMI ||           \
    automationtype==AUTO_A7LMFULL || automationtype==AUTO_A8LMMAN ||           \
    automationtype==AUTO_A8LMSEMI || automationtype==AUTO_A8LMFULL ||          \
    automationtype==AUTO_SPLIT                                                 \
  then
    isauto=1
  else
    isauto=0
  endif
end

// Given rough fiducial coordinates, this function scans board optically and
// calculates necessary coordinate conversion coefficients.
function int Scanboard(int manualonly)
  int i,err,x,y
  float r,xsc,ysc,xmin,xmax,ymin,ymax
  char s[256]
  handle hview,hlivevideo,hreplace,hfinish
  clear hright
  change hinfo limits=0,0
  change hinfo text="Checking coordinates..."
  r=Sqrt((pos1x-pos2x)*(pos1x-pos2x)+(pos1y-pos2y)*(pos1y-pos2y))
  delay 500                            // Merchantizing...
  if (r<crossdist-MAXERR || r>crossdist+MAXERR) then
    err=1                              // Wrong distance between crosses
  endif
  if err==0 then
    hview=control CHILD
      window=hleft
      position=0,0,LEFTX,LEFTY
      help=" "
      color=BROWN
      bkcolor=LIGHTYELLOW
      size=128
    endc
    hlivevideo=control GRAPH
      window=hview
      position=5,5,LEFTX-10,288
      bkcolor=VIDEOFILL
      help="相机中实时影像"
    endc
    x=(LEFTX-10)/2; y=288/2
    draw window=hlivevideo color=LIGHTRED
    draw at x-20,y to x-5,y at x+6,y to x+21,y
    draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
    draw show
  endif
  if manualonly==0 then
    if err==0 then
      change hinfo text="寻找基准点..."
      err=Searchcross(hlivevideo,&pos1x,&pos1y,crossy[0]+yshift)
      if err<0 return -1               // Operator interrupted test
    endif
    if err==0 then
      err=Searchcross(hlivevideo,&pos2x,&pos2y,crossy[1]+yshift)
      if err<0 return -1               // Operator interrupted test
    endif
  endif
  if err==0 then
    r=Sqrt((pos1x-pos2x)*(pos1x-pos2x)+(pos1y-pos2y)*(pos1y-pos2y))
    if (r<crossdist-MAXERR/2.0 || r>crossdist+MAXERR/2.0) err=1
  endif
  // Move heads and cameras into the home positions.
  for i=0,i<$LAY.nfing*2,i++ do
    sprintf(s,"M %i(Z) NOP",i)
    SERV.Cmdimm(32,s)
  enddo
  delay 1000                           // Psychologically necessary delay
  if hview!=NULL destroy hview
  if err==0 then
    if scanrail<0 then
      setini("Cadjust","Left cross","%g,%g,%i",pos1x,pos1y,crosstype)
      setini("Cadjust","Right cross","%g,%g",pos2x,pos2y)
    else if wideboard then
      setini("Cadjust","Left wide cross","%g,%g",pos1x,pos1y)
      setini("Cadjust","Right wide cross","%g,%g",pos2x,pos2y)
    else
      setini("Cadjust","Left pad","%g,%g",pos1x,pos1y)
      setini("Cadjust","Right pad","%g,%g",pos2x,pos2y)
    endif
    r=(crossx[1]-crossx[0])*(crossx[1]-crossx[0])+                             \
      (crossy[1]-crossy[0])*(crossy[1]-crossy[0])
    convcfi=((crossx[1]-crossx[0])*(pos2x-pos1x)+                              \
      (crossy[1]-crossy[0])*(pos2y-pos1y))/r
    convsfi=((crossx[1]-crossx[0])*(pos2y-pos1y)-                              \
      (crossy[1]-crossy[0])*(pos2x-pos1x))/r
    convdx=pos1x-crossx[0]*convcfi+crossy[0]*convsfi
    convdy=pos1y-crossx[0]*convsfi-crossy[0]*convcfi
    if boardtype==0 then
      Convert(&xmin,&ymin,-5.0,-5.0,0.0);
      Convert(&xmax,&ymax,55.0,315.0,0.0);
    else if boardtype==1 then
      Convert(&xmin,&ymin,-80.0,-5.0,0.0);
      Convert(&xmax,&ymax,80.0,315.0,0.0);
    else
      Convert(&xmin,&ymin,-80.0,-5.0,0.0);
      Convert(&xmax,&ymax,80.0,755.0,0.0);
    endif
    sprintf(s,"默认板 %g,%g,%g,%g",xmin,ymin,xmax,ymax)
    SERV.Cmdimm(32,s)                  // Allow whole board
    // Adjust pressure.
    if ($EXTLAY.zheadtype & HCZ_VALID)==0 then
      strokep=50
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL ||                 \
      ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL then
      strokep=90
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
      strokep=40
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
      strokep=50
    else
      strokep=50
    endif
    sprintf(s,"STROKE %i,%i,%g",strokev,strokep,strokez)
    SERV.Cmdimm(32,s)                  // Set default stroke
    Strcpy(s,"OUTPORT 0x20F0,8")
    SERV.Cmdimm(32,s)                  // Set 4 V (default) antenna voltage
    Strcpy(s,"EXACTINIT 0,0,0")
    SERV.Cmdimm(32,s)                  // No power/current limitations
    return 0                           // No errors, pads found correctly
  endif
  change hinfo text="Scanning error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Bad distance between crosses!"
    draw at 6,60 color=BLACK
    draw text="The distance between positioning crosses on the board is "
    draw text=format("%.0f mm. However, measured distance is ",crossdist)
    draw text=format("%.1f mm.",r)
  else if err==2 then
    draw text="Unable to define fiducial!"
    draw at 6,60 color=BLACK
    draw text="Either you have no frame grabber, or some other script uses "
    draw text="all available fiducial handles, or magnification of the camera "
    draw text="in file OLLYTEST.INI is wrong. "
  else if err==3 then
    draw text="Unable to find cross!"
    draw at 6,60 color=BLACK
    draw text="Either you selected wrong place, or picture is too unclear, or "
    draw text="magnification of the camera in file OLLYTEST.INI is wrong. "
  else if err==4 then
    draw text="Unable to move camera!"
    draw at 6,60 color=BLACK
    draw text="Video camera cannot reach specified pad. "
  endif
  draw text="Please decide what to do next."
  draw show
  hreplace=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="重放置"
    help="按下可重复扫描或更换校准板"
  endc
  hfinish=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="放弃"
    help="按下即可退出测试"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1                        // Operator interrupted test
    else if Pressed(hreplace) then
      return 1                         // Change board placement or rescan
    else if Pressed(hfinish) then
      return 2                         // Operator stopped test
    endif
    wait
  enddo
end

// Checks placement of the board electrically. Returns -1 if operator
// interrupted test, 1 if it is necessary to check load status of the tester,
// 2 if it is necessary to repeat electrical test, and 0 if test is OK.
function int Electrocheck()
  int i,j,t,n1,n2,back1,back2,badr[32],sent[32],nbad,err
  char s[1024],s1[1024],s2[1024]
  float x,y,dx[32],dy[32],r
  handle hretry,hreplace,hcont
  clear hright
  change hinfo limits=0,0
  change hinfo text="检查校验板..."
  for i=0,i<$LAY.nfing*2,i++ do
    dx[i]=Random(DELTA/4.0)-Random(DELTA/4.0)
    dy[i]=Random(DELTA/4.0)-Random(DELTA/4.0)
    badr[i]=0
  enddo
  nbad=0
  // Generate measurements (one against all others on the same wire, provided
  // that there are no backdrill needles, in which case I use two-finger
  // measurements on the same side). Note that previously executed code assures
  // that we have at least two rails.
  for i=0,i<$LAY.nfing*2,i=i+2 do
    sent[i]=0
    sent[i+1]=0
    if used[i]==0 continue
    back1=(backdrill & (1<<i))!=0      // Whether i is backdrill
    back2=0                            // 0: none, 1: backdrill ref, -1: not
    n1=0; n2=0
    for j=0,j<$LAY.nfing*2,j=j+2 do
      if used[j]==0 continue
      if backdrill && $LAY.side[j/2]!=$LAY.side[i/2] continue
      Convertpad(&x,&y,"SIG",j,0.0)
      if y<$LAY.yoffset[j/2]/1000.0 then
        y=y+DELTA*2
      else
        y=y-DELTA*2
      endif
      n1=n1+sprintf(s1+n1,"%i[%.3f,%.3fH50] ",j,x+dx[j],y+dy[j])
      if j==i continue
      if (backdrill & (1<<j))!=0 then
        if back1!=0 || back2!=0 continue
        back2=1
      else
        if back2>0 continue
        back2=-1
      endif
      n2=n2+sprintf(s2+n2,",%i",j)
    enddo
    if n2==0 continue                  // If all backdrill needles
    sprintf(s,"M %s R(%i%s)",s1,i,s2)
    SYS.Killimm(i)                     // Recover from previous scanning
    SERV.Cmdimm(i,s)
    sent[i]=1
    back1=(backdrill & (1<<(i+1)))!=0  // Whether i+1 is backdrill
    back2=0                            // 0: none, 1: backdrill ref, -1: not
    n1=0; n2=0
    for j=1,j<$LAY.nfing*2,j=j+2 do
      if used[j]==0 continue
      if backdrill && $LAY.side[j/2]!=$LAY.side[i/2] continue
      Convertpad(&x,&y,"GND",j,0.0)
      if y<$LAY.yoffset[j/2]/1000.0 then
        y=y+DELTA*2
      else
        y=y-DELTA*2
      endif
      n1=n1+sprintf(s1+n1,"%i[%.3f,%.3fH50] ",j,x+dx[j],y+dy[j])
      if j==i+1 continue
      if (backdrill & (1<<j))!=0 then
        if back1!=0 || back2!=0 continue
        back2=1
      else
        if back2>0 continue
        back2=-1
      endif
      n2=n2+sprintf(s2+n2,",%i",j)
    enddo
    if n2==0 continue                  // If all backdrill needles
    sprintf(s,"M %s R(%i%s)",s1,i+1,s2)
    SYS.Killimm(i+1)                   // Recover from previous scanning
    SERV.Cmdimm(i+1,s)
    sent[i+1]=1
  enddo
  err=0
  t=Time()
  while 1 do                           // Wait till all answers come back
    if Pressed(hexit) return -1        // Operator interrupted test
    for i=0,i<$LAY.nfing*2,i++ do
      if sent[i]==0 continue
      if $A[i].length==0 break
    enddo
    if i>=$LAY.nfing*2 break           // All answers came
    if Time()-t>10000 then
      err=1; break                     // Timeout 10 seconds
    endif
    wait
  enddo
  if err==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if sent[i]==0 continue
      if $A[i].answer==S_ERROR then
        err=2; break                   // Some error
      else if $A[i].answer!=S_MOVE || $A[i].subansw!=S_RMEAS then
        err=3; break                   // Unbelievable, wrong answer
      endif
      r=$A[i].r
      if ($A[i].status & 0x0100) r=r*1.0e-6
      if r<(-3.0) || r>(backdrill?100.0:20.0) then
        badr[i]=1                      // Bad resistance (high or negative)
        nbad++
        if err==0 err=4
      endif
    enddo
  endif
  if err==0 return 0                   // Electrical check passed
  change hinfo text="接触错误"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within 10 seconds. "
  else if err==2 then
    draw text="Tester reports error!"
    draw at 6,60 color=BLACK
    draw text="Embedded software was unable to execute measurement command "
    draw text="correctly. The exact reason is displayed in red in the main "
    draw text="Ollytest window. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Embedded software returned unexpected answer. "
  else if err==4 then
    draw text="高电阻!"
    draw at 6,60 color=BLACK
    draw text="根据计算校验板上不存在20欧姆的线\n路阻值."
    draw text="但是测量"
    draw text=format("%s ",nbad==1?"头":"头")
    j=0
    for i=0,i<$LAY.nfing*2,i++ do
      if badr[i]==0 continue
      if j==nbad-1 then
        draw text=format("%i%c",i/2,i & 1?'R':'L')
      else if j==nbad-2 then
        draw text=format("%i%c 和",i/2,i & 1?'R':'L')
      else
        draw text=format("%i%c,",i/2,i & 1?'R':'L')
      endif
      j++
    enddo
    draw text="的测量"
    draw text="值超出了"
    draw text="安全区间.\n 请决定下面怎么做."
  endif
  draw show
  hretry=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="重试"
    help="按下再次测量电阻"
  endc
  hreplace=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="重放置"
    help="按下可更改电容调整板的位置"
  endc
  hcont=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="继续"
    help="继续后果自负"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hretry) return 2
    if Pressed(hreplace) return 1
    if Pressed(hcont) return 0
    wait
  enddo
end

// Reads current tester temperature (in 1/10-th of degree). If necessary, uses
// USB sensor. If operator interrupted C adjust, returns -1. if there was a
// command sending or receiving error, returns 1. Otherwise, returns
// temperature in the range 10..999, which corresponds to 1..99.9 degrees. It
// is the responsibility of caller to display and process errors.
function int Readtemperature()
  int ident,t,temp
  char s[128]
  float etemp
  if ($EXTLAY.measopt & HCM_TMEASOFF) then
    temp=220                           // Default temperature
  else
    sprintf(s,"INPORT %i",0x2011)      // Read effective (smoothed) temperature
    ident=SERV.Cmdimm(32,s)
    if ident<=0 return 1               // Unable to send command
    t=Time()                           // Timeout 5 seconds
    while $A[32].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Time()-t>5000 return 1        // Timeout exhausted
      wait
    enddo
    if $A[32].length!=7 return 1       // Bad length of answer
    if $A[32].answer!=S_INPORT return 1// Bad answer
    temp=$uint2($A[32]+5)
  endif
  if temp==220 then                    // Default temperature, try USB sensor
    if SYS.Exttemperature(&etemp)==0 then
      temp=Floor(etemp*10.0+0.5)
    endif
  endif
  return Min(999,Max(10,temp))
end

// Service function, splits line of text in two so that first line is not
// longer than nlimit characters.
function int Splittext(char *s,int nlimit,char *s1,char *s2)
  int i
  i=Strlen(s)
  if i<=nlimit then
    Strcpy(s1,s)
    s2[0]='\0'
  else
    for i=nlimit,i>1,i-- do
      if s[i]==' ' break
    enddo
    Memcpy(s1,s,i); s1[i]='\0'
    Strcpy(s2,s+i+1)
  endif
end

// If save is not 0, writes corrected layout to disk. If reload is not 0, loads
// corrected measurement parameters and layout extentions to the tester.
function int Loadlayoutmeas(int save,int reload)
  int i,j,len,err,t,nextent,maxextent,flashtime,autosave
  char s[260],buf[774]
  handle f,hlayoutname,hbrowse,hwrite,hcancel,hretry
  if save then
    change hinfo limits=0,0
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK
    draw text="成功修正布局文件中的参数,选择文件保存\n到硬盘。 "
    //draw text="file on the disk to save corrected layout."
    draw show
    hlayoutname=control COMBOEDIT
      window=hright
      position=5,USERY-130,RIGHTX-10,120
      name="布局文件"
      help="包含主测试机布局的文件"
      mode=M_VSCROLL
    endc
    hbrowse=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name="浏览"
      help="浏览布局名称"
    endc
    hwrite=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="保存"
      help="将更正的布局保存到指定文件"
    endc
    hcancel=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="取消"
      help="放弃所有对布局的更改"
    endc
    flashtime=1
    if simplemode && Text(hlayoutname,s)>0 then
      autosave=1
    else
      autosave=0
    endif
    while 1 do
      if flashtime!=0 && flashtime<Time() then
        change hinfo color=BLACK
        change hinfo text="写入布局文件"
        flashtime=0
      endif
      if Pressed(hexit) then
        return -1
      else if Pressed(hbrowse) then
        Text(hlayoutname,s)
        if SYS.Browse(hmain,s,"Specify layout name",0)!=0 then
          change hlayoutname text=s
        endif
      else if Pressed(hwrite) || autosave then
        autosave=0
        confirm hlayoutname
        Text(hlayoutname,s)
        if s[0]=='\0' then
          change hinfo color=LIGHTRED
          change hinfo text="Invalid name!"
          flashtime=Time()+1000
        else
          err=0
          f=Fopen(s,"wb")
          if f==NULL err=1
          // Save main layout.
          if err==0 && Fwrite($LAY,768,f)!=768 err=2
          // Determine number of layout extentions to save.
          nextent=0
          if err==0 then
            for i=4,i<768,i++ do       // First 4 bytes are validity marker
              if $char($EXT3+i)!=0 break
            enddo
            if i<768 nextent=5
            if nextent==0 then
              for i=4,i<768,i++ do
                if $char($EXT2+i)!=0 break
              enddo
              if i<768 nextent=4
            endif
            if nextent==0 then
              for i=4,i<768,i++ do
                if $char($EXT1+i)!=0 break
              enddo
              if i<768 nextent=3
            endif
            if nextent==0 then
              for i=4,i<768,i++ do
                if $char($EXT0+i)!=0 break
              enddo
              if i<768 nextent=2
            endif
            if nextent==0 then
              for i=0,i<768,i++
                if $char($EXTLAY+i)!=0 break
              enddo
              if i<768 nextent=1
            endif
          endif
          if err==0 && nextent>=1 then
            if Fwrite($EXTLAY,768,f)!=768 err=2
          endif
          if err==0 && nextent>=2 then
            $int4($EXT0)=0x30747845
            if Fwrite($EXT0,768,f)!=768 err=2
          endif
          if err==0 && nextent>=3 then
            $int4($EXT1)=0x31747845
            if Fwrite($EXT1,768,f)!=768 err=2
          endif
          if err==0 && nextent>=4 then
            $int4($EXT2)=0x32747845
            if Fwrite($EXT2,768,f)!=768 err=2
          endif
          if err==0 && nextent>=5 then
            $int4($EXT3)=0x33747845
            if Fwrite($EXT3,768,f)!=768 err=2
          endif
          Fclose(f)
          if err==1 then
            change hinfo color=LIGHTRED
            change hinfo text="Error saving layout to file!"
            flashtime=Time()+1000
          else if err==2 then
            change hinfo color=LIGHTRED
            change hinfo text="Unable to create file!"
            flashtime=Time()+1000
          else
            break
          endif
        endif
      else if Pressed(hcancel) then
        change hinfo color=BLACK
        return 1
      endif
      wait
    enddo
  endif
  SYS.Broadcast(8,"CHG LAY")           // Inform others that layout changed
  if reload then
    change hinfo text="重新加载布局"
    clear hright
    draw window=hright font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="重新载入修正过的布局文件。"
    draw show
    err=0
    // Reload measurement parameters. Answer indicates whether and how many
    // additional layout extentions are supported. Layout may be larger than
    // tester accepts!
    buf[0]=S_LOADRUN
    buf[1]=4                           // Reload measurement parameters
    $int4(buf+2)=0                     // Dummy zero bytes
    Memcpy(buf+6,$LAY,768)
    if SYS.Sendimm(0,774,buf)<=0 err=1 // Unable to send command
    t=Time(); i=-1
    while $A[0].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as an interrupt
      j=(Time()-t)/1000
      if i!=j then
        change hinfo text=format("重新加载布局 - %i s",j)
        i=j
      endif
      if j>=120 then
        SYS.Killimm(0)
        err=2; break                   // Timeout
      endif
      wait
    enddo
    if err==0 && $A[0].answer!=S_LOADRUN then
      err=3
    endif
    // Calculate total number of layout extentions to load.
    nextent=0
    if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&         \
      testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&           \
      testertype!=TT_A7 && testertype!=TT_A8 then
      maxextent=1
    else if $A[0].length>=7 then
      maxextent=$char($A[0]+6)
    else
      maxextent=1
    endif
    if maxextent>=5 then
      for i=4,i<768,i++ do             // First 4 bytes are validity marker
        if $char($EXT3+i)!=0 break
      enddo
      if i<768 nextent=5
    endif
    if nextent==0 && maxextent>=4 then
      for i=4,i<768,i++ do
        if $char($EXT2+i)!=0 break
      enddo
      if i<768 nextent=4
    endif
    if nextent==0 && maxextent>=3 then
      for i=4,i<768,i++ do
        if $char($EXT1+i)!=0 break
      enddo
      if i<768 nextent=3
    endif
    if nextent==0 && maxextent>=2 then
      for i=4,i<768,i++ do
        if $char($EXT0+i)!=0 break
      enddo
      if i<768 nextent=2
    endif
    if nextent==0 then
      for i=0,i<768,i++ do
        if $char($EXTLAY+i)!=0 break
      enddo
      if i<768 nextent=1
    endif
    // Send additional layout extentions. Note that main extention is sent
    // afterwards, this is the recommended order (although this does not matter
    // if tester was completely loaded before).
    for j=1,j<nextent && err==0,j++ do // Note: nextent<=5
      buf[0]=S_LOADRUN
      buf[1]=20                        // Load additional layout extention
      $int4(buf+2)=j-1                 // Index
      if j==1 then
        Memcpy(buf+6,$EXT0,768)
      else if j==2 then
        Memcpy(buf+6,$EXT1,768)
      else if j==3 then
        Memcpy(buf+6,$EXT2,768)
      else
        Memcpy(buf+6,$EXT3,768)
      endif
      if SYS.Sendimm(j,774,buf)<=0 err=1 // Unable to send command
    enddo
    // Send main layout extention.
    if err==0 && nextent>=1 then
      buf[0]=S_LOADRUN
      buf[1]=15                        // Load main layout extention
      $int4(buf+2)=0                   // Dummy zero bytes
      Memcpy(buf+6,$EXTLAY,768)
      if SYS.Sendimm(0,774,buf)<=0 err=1 // Unable to send command
    endif
    i=-1
    while err==0 do
      for j=0,j<nextent,j++ do
        if $A[j].length==0 break
        if $A[j].answer!=S_LOADRUN err=3
      enddo
      if j>=nextent break              // All answers are back
      if Pressed(hexit) return -1      // Button "Exit" works as an interrupt
      j=(Time()-t)/1000
      if i!=j then
        change hinfo text=format("重新加载布局 - %i s",j)
        i=j
      endif
      if j>=120 then
        for j=0,j<nextent,j++ do
          SYS.Killimm(j)
        enddo
        err=2; break                   // Timeout
      endif
      wait
    enddo
    i=Checkgloberrors()                // Necessary after measurement test
    if err==0 || i!=0 return i
    change hinfo text="Communication problem!"
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==1 then
      draw text="Unable to send command!"
    else if err==2 then
      draw text="No answer within 90 seconds!"
    else
      draw text="Command executed incorrectly!"
    endif
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="检查状态"
      help="按下重新检查测试机状态"
    endc
    draw text="Script was unable to load tester with corrected layout. It is "
    draw text="necessary to re-check the status of the tester."
    draw show
    while 1 do
      if Pressed(hretry) return 1      // Check tester status again
      if Pressed(hexit) return -1      // Quit script
      wait
    enddo
  endif
end

// Service function, sends main layout extention and all additional extentions
// to tester. Returns 0 on success and -1 on any error.
function int Sendextention()
  int t
  char buf[1024]
  if (cratefeatures & CF_LONGLAY)!=0 then
    // I reload extentions without checking whether it is all zero. Maybe we
    // have just edited it to all zeros?
    buf[0]=S_LOADRUN
    buf[1]=20                          // Reload layout extention
    $int4(buf+2)=0                     // First additional extention
    Memcpy(buf+6,$EXT0,768)
    SYS.Killimm(1)
    SYS.Sendimm(1,774,buf)
    buf[0]=S_LOADRUN
    buf[1]=20                          // Reload layout extention
    $int4(buf+2)=1                     // Second additional extention
    Memcpy(buf+6,$EXT0,768)
    SYS.Killimm(2)
    SYS.Sendimm(2,774,buf)
    buf[0]=S_LOADRUN
    buf[1]=20                          // Reload layout extention
    $int4(buf+2)=2                     // Third additional extention
    Memcpy(buf+6,$EXT2,768)
    SYS.Killimm(3)
    SYS.Sendimm(3,774,buf)
    buf[0]=S_LOADRUN
    buf[1]=20                          // Reload layout extention
    $int4(buf+2)=3                     // Fourth additional extention
    Memcpy(buf+6,$EXT3,768)
    SYS.Killimm(4)
    SYS.Sendimm(4,774,buf)
    t=Time()
    while $A[1].length==0 || $A[2].length==0 ||                                \
      $A[3].length==0 || $A[4].length==0 do
      if Time()-t>5000 break           // Timeout 5 seconds
      wait
    enddo
    if $A[1].answer!=S_LOADRUN || $A[2].answer!=S_LOADRUN ||                   \
      $A[3].answer!=S_LOADRUN || $A[4].answer!=S_LOADRUN                       \
    then
      return -1
    endif
  endif
  buf[0]=S_LOADRUN
  buf[1]=15                            // Reload layout extention
  $int4(buf+2)=0                       // Dummy operand
  Memcpy(buf+6,$EXTLAY,768)            // Layout extention
  SYS.Killimm(32)
  if SYS.Sendimm(32,774,buf)<=0 then
    return -1                          // Unable to send command
  endif
  t=Time()
  while Time()-t<3000 do               // Timeout 3 seconds
    wait
    if $A[32].length==0 continue
    if $A[32].answer!=S_LOADRUN then
      return -1                        // Invalid answer - execution error?
    else
      return 0                         // Success
    endif
  enddo
  return -1                            // Timeout
end

// Service function, creates backup copy of layout extentions.
function int Makelayoutcopy()
  Memcpy(lx,$EXTLAY,768)
  Memcpy(lx0,$EXT0,768)
  Memcpy(lx1,$EXT1,768)
  Memcpy(lx2,$EXT2,768)
  Memcpy(lx3,$EXT3,768)
end

// Service function, restores layout extentions from backup copy.
function int Restoreoldlayout()
  Memcpy($EXTLAY,lx,768)
  Memcpy($EXT0,lx0,768)
  Memcpy($EXT1,lx1,768)
  Memcpy($EXT2,lx2,768)
  Memcpy($EXT3,lx3,768)
end

// Service function, sets Dallas potentiometers to the specified values.
// Returns 0 on success, 1 on error and -1 if user interrupted the script. Note
// that this call changes copy of layout in the tester.
function int Setdallas(int head,int ampl,int phase)
  int t
  char s[256]
  if head<0 || head>=$LAY.nfing*2                                              \
    return 1                           // Error in input parameters
  // Correct obvious errors.
  ampl=Max(0,Min(ampl,511))
  phase=Max(0,Min(phase,511))
  // Send data to tester. It's not an error to set phase even if it is not
  sprintf(s,"OUTPORT %i,%i",0x80E0+(head/2)*0x0100+(head & 1)*0x0002,ampl)
  SYS.Killimm(32)
  if SERV.Cmdimm(32,s)<0 return -1
  if allowz then
    sprintf(s,"OUTPORT %i,%i",0x80E4+(head/2)*0x0100+(head & 1)*0x0002,phase)
    SYS.Killimm(33)
    if SERV.Cmdimm(33,s)<0 return -1
  endif
  // Wait for answers. Usually they are instant.
  t=Time()
  while $A[32].length==0 || (allowz!=0 && $A[33].length==0) do
    if Time()-t>3000 return 1          // Timeout
    if Pressed(hexit) return -1        // Operator interrupted the test
    wait
  enddo
  // Report success.
  return 0
end

// Verifies Dallas potentiometers.
function int Verifydallas()
  int i,j,k,m,n,xs,ys,dy,t,head,base,nfing,ant,ant1
  int err,firstmove,tested[32],allowz
  float x,y,xa,ya,xg,yg,xt,yt,xu,yu,deltax,deltay
  float fmin[32],fmax[32],zmin[32],zmax[32]
  char s[512],s2[512]
  handle hcancel,hcont
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) &&                                 \
    ($LAY.config & LC_OHTYPE)==LC_PHADJ                                        \
  then
    allowz=1
  else
    allowz=0
  endif
  clear hright
  change hinfo limits=0,0
  change hinfo text="电位器设置"
  change hleft position=-1000,*,*,*
  nfing=$LAY.nfing
  hcancel=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="取消"
    help="取消验证并返回主屏幕"
  endc
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="现在检查头部卡上的电位器是否可以调整"
  draw text="\n输入容量"
  if allowz draw text="和相位偏移"
  draw text=".左边窗口显示可调"
  draw text="整的"
  draw text="极限范围."
  draw text="请注意,在不同电容上测得"
  draw text="的极限值不能直接比较.\n" color=LIGHTRED text="\n注意"
  draw color=BLACK text=",此测试处于不确定"
  draw text="状态. 你 " color=LIGHTRED text="必须" color=BLACK
  draw text="重启\n测试机或后面再调整电容值!"
  draw show
  hgraph=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="电位计验证结果"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  // Display set of rails.
  draw window=hgraph color=BLACK bkcolor=WHITE clear
  draw color=BLACK mode=M_CENTERED font=MEDIUMFONT at LEFTX/2,30
  draw text="调整电场\n电位器极限"
  if $LAY.nfing>10 then
    dy=23
  else if allowz==0 then
    dy=24
  else
    dy=28
  endif
  draw mode=M_RIGHT font=SMALLFONT color=DARKGRAY
  for m=0,m<nfing,m++ do
    ys=90+m*dy
    if $LAY.side[m]!=0 ys=ys+7
    for n=0,n<2,n++ do
      xs=(n==0?15:LEFTX/2+10)+15
      if n==0 then
        draw at xs,ys text=format("%iL",m)
      else
        draw at xs,ys text=format("%iR",m)
      endif
    enddo
  enddo
  if allowz then
    draw mode=M_CENTERED
    draw at LEFTX/2,120+nfing*dy text="上面是正弦,"
    draw at LEFTX/2,130+nfing*dy text="下面是余弦"
  endif
  draw show
  err=0
  firstmove=1
  deltax=Random(DELTA)-DELTA/2.0
  deltay=Random(DELTA)-DELTA/2.0
restart:
  if lastrail-firstrail>2 then
    base=(firstrail+1)*2
  else
    base=firstrail*2
  endif
  for i=0,i<32,i++ do
    tested[i]=0
  enddo
nextbase:
  // This cycle tests group of 8 heads (4 for single-sided or handicapped
  // tester) on the same C-adjust pad.
  for head=0,head<8 && err==0,head++ do
    // K is the ID of head to test.
    if head<4 then
      k=base+head                      // Top (or, in general, first) side
    else if testersides!=0x3 then
      continue                         // Single-sided tester
    else
      k=base+nfing+(head-4)            // Opposite side
    endif
    if used[k]==0 continue             // Head is excluded from test
    if tested[k]!=0 continue           // Head was already tested
    // Decide which heads serve this time as antennas. There is a problem
    // with A3, single-sided and handicapped testers: we can't select static
    // antenna for a loop. The algorithm: take rail preceding base (top or
    // bottom side); take rail that follows group (top or bottom side); take
    // rail in the group on the opposite side; take rail in the group on the
    // same side. As we have at least two full adjacent rails, this is always
    // possible.
    if base>firstrail*2 && used[firstrail*2]!=0 then
      ant=firstrail*2                  // Top rail that precedes group
    else if base>firstrail*2 && testersides==0x3 &&                            \
      used[firstrail*2+nfing]!=0 then
      ant=firstrail*2+nfing            // Bottom rail that precedes group
    else if base+4<=lastrail*2 && used[lastrail*2]!=0 then
      ant=lastrail*2                   // Top rail that follows group
    else if base+4<=lastrail*2 && testersides==0x3 &&                        \
      used[lastrail*2+nfing]!=0 then
      ant=lastrail*2+nfing             // Bottom rail that follows group
    else if testersides==0x3 && k<nfing && used[base+nfing]!=0 then
      ant=base+nfing                   // In group on the opposite (bot) side
    else if testersides==0x3 && k>=nfing && used[base]!=0 then
      ant=base                         // In group on the opposite (top) side
    else if head<2 && used[base+2]!=0 then
      ant=base+2                       // In group on the same side
    else if head>=2 && used[base]!=0 then
      ant=base                         // In group on the same side
    else
      err=4                            // Alarm, unable to select antenna
    endif
    // Move heads in requested positions.
    for i=0,i<nfing*2 && err==0,i++ do
      if used[i]==0 continue
      if i==k then                     // Head under test
        if Convertpad(&x,&y,"C",base,0.0)<0.0 err=2
        continue
      else if i==ant then              // Antenna finger
        if Convertpad(&xa,&ya,"SIG",i,0.0)<0.0 err=2
        // Attention, may cause Bad coordinates during single-side adjustment
        // if board is rotated by more than 2*DELTA!
        if (i>=base && i<base+2) ||                                            \
          (testersides==0x3 && i>=base+nfing && i<base+nfing+2) then
          ya=ya-2*DELTA
        else
          ya=ya+2*DELTA
        endif
        continue
      else if i==ant+1 then            // Ground finger
        if Convertpad(&xg,&yg,"GND",i,0.0)<0.0 err=2
        // Attention, may cause Bad coordinates during single-side adjustment
        // if board is rotated by more than 2*DELTA!
        if (i>=base && i<base+2) ||                                            \
          (testersides==0x3 && i>=base+nfing && i<base+nfing+2) then
          yg=yg-2*DELTA
        else
          yg=yg+2*DELTA
        endif
        continue
      else if ((usesides & 0x1)!=0 && (i>=base && i<base+4)) ||                \
        ((usesides & 0x2)!=0 && (i>=base+nfing && i<base+nfing+4)) then
        // Head belongs to the set being tested.
        if Convertpad(&xt,&yt,"C",base,0.0)<0.0 err=2
        if (i & 1)==0 then xt=xt-3.0; else xt=xt+3.0; endif
        if (i>=base && i<base+2) ||                                            \
          (testersides==0x3 && i>=base+nfing && i<base+nfing+2) then
          yt=yt-3.0
        else
          yt=yt+3.0
        endif
        if firstmove then
          sprintf(s,"M %i[%g,%gH50] NOP",i,xt,yt)
        else
          sprintf(s,"M %i[%g,%g] NOP",i,xt,yt)
        endif
      else if (i & 1)==0 then          // Any remaining left head
        if Convertpad(&xt,&yt,"NOCT1",i,0.0)<0.0 err=2
        yt=$LAY.yoffset[i/2]/1000.0
        sprintf(s,"M %i[%g,%gH50] NOP",i,xt,yt)
      else                             // Any remaining right head
        if Convertpad(&xt,&yt,"NOCT2",i,0.0)<0.0 err=2
        yt=$LAY.yoffset[i/2]/1000.0
        sprintf(s,"M %i[%g,%gH50] NOP",i,xt,yt)
      endif
      if err!=0 break
      if SERV.Cmdimm(i,s)<0 err=2      // Send command
    enddo
    // Wait till all heads except those used in measurement have reached
    // requested positions.
    t=Time()
    for i=0,i<nfing*2 && err==0,i++ do
      if used[i]==0 continue
      if i==k || i==ant || i==ant+1 continue
      while err==0 do
        if Time()-t>10000 err=1
        if Pressed(hexit) err=-1
        if Pressed(hcancel) err=9
        if $A[i].length!=0 break
        wait
      enddo
      if (err==0 && $A[i].answer!=S_NOP) err=3
    enddo
    firstmove=0
    // Set potentiometer to 0 and wait for answer. Note that this will change
    // copy of layout in the tester.
    SYS.Killimm(0)
    $A[0].length=0
    sprintf(s,"OUTPORT %i,0",0x80E0+(k/2)*0x0100+(k & 1)*0x0002)
    if SERV.Cmdimm(0,s)<0 err=2        // Send command
    t=Time()
    while err==0 && $A[0].length==0 do
      if Time()-t>3000 err=1
      if Pressed(hexit) err=-1
      if Pressed(hcancel) err=9
      wait
    enddo
    if err==0 && allowz then
      $A[0].length=0
      sprintf(s,"OUTPORT %i,0",0x80E4+(k/2)*0x0100+(k & 1)*0x0002)
      if SERV.Cmdimm(0,s)<0 err=2      // Send command
      t=Time()
      while err==0 && $A[0].length==0 do
        if Time()-t>3000 err=1
        if Pressed(hexit) err=-1
        if Pressed(hcancel) err=9
        wait
      enddo
    endif
    layoutdiffers=1
    if err!=0 break
    // First field measurement. To reach stable measurements, I ignore first 4
    // fields from ant. If tester is single-sided with external antenna, I use
    // it additionally to available antennas.
    if testersides==0x1 && ($EXTLAY.extant & 1)!=0 then
      ant1=32
    else
      ant1=ant
    endif
    j=sprintf(s2,"M %i[%g:%g,%g:%g] %i[%g,%g] %i[%g,%g]",                      \
      k,x,deltax,y,deltay,ant+1,xg,yg,ant,xa,ya)
    j=j+sprintf(s2+j,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",                       \
      k,ant+1,ant1,ant,ant,ant,ant,ant,ant,ant)
    j=j+sprintf(s2+j,"%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",       \
      ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant)
    sprintf(s2+j,"%i,%i,%i,%i)",ant,ant,ant,ant) // Total of 28*ant
    if SERV.Cmdimm(0,s2)<0 err=2       // Send command
    t=Time()                           // Wait for answer
    while err==0 && $A[0].length==0 do
      if Time()-t>10000 err=1
      if Pressed(hexit) err=-1
      if Pressed(hcancel) err=9
      wait
    enddo
    if err==0 && $A[0].answer!=S_MOVE err=3
    if err!=0 break
    // Process results.
    fmin[k]=0.0; zmin[k]=0.0
    for j=0,j<24,j++ do
      fmin[k]=fmin[k]+$int2($A[0]+48+4*j)
      zmin[k]=zmin[k]+$int2($A[0]+50+4*j)
    enddo
    fmin[k]=fmin[k]/24.0
    zmin[k]=zmin[k]/24.0
    // Set sine Dallas potentiometer to 511 and wait for answer.
    sprintf(s,"OUTPORT %i,511",0x80E0+(k/2)*0x0100+(k & 1)*0x0002)
    if SERV.Cmdimm(0,s)<0 err=2        // Send command
    t=Time()
    while err==0 && $A[0].length==0 do
      if Time()-t>3000 err=1
      if Pressed(hexit) err=-1
      if Pressed(hcancel) err=9
      wait
    enddo
    if err==0 && allowz then
      sprintf(s,"OUTPORT %i,0",0x80E4+(k/2)*0x0100+(k & 1)*0x0002)
      if SERV.Cmdimm(0,s)<0 err=2      // Send command
      t=Time()
      while err==0 && $A[0].length==0 do
        if Time()-t>3000 err=1
        if Pressed(hexit) err=-1
        if Pressed(hcancel) err=9
        wait
      enddo
    endif
    layoutdiffers=1
    if err!=0 break
    // Second field measurement.
    if SERV.Cmdimm(0,s2)<0 err=2       // Send command
    t=Time()                           // Wait for answer
    while err==0 && $A[0].length==0 do
      if Time()-t>10000 err=1
      if Pressed(hexit) err=-1
      if Pressed(hcancel) err=9
      wait
    enddo
    if err==0 && $A[0].answer!=S_MOVE err=3
    if err!=0 break
    // Process results.
    fmax[k]=0.0;
    for j=0,j<24,j++ do
      fmax[k]=fmax[k]+$int2($A[0]+48+4*j)
    enddo
    fmax[k]=fmax[k]/24.0
    // Set cosine potentiometer to 511 and wait for answer.
    if allowz then
      sprintf(s,"OUTPORT %i,0",0x80E0+(k/2)*0x0100+(k & 1)*0x0002)
      if SERV.Cmdimm(0,s)<0 err=2      // Send command
      t=Time()
      while err==0 && $A[0].length==0 do
        if Time()-t>3000 err=1
        if Pressed(hexit) err=-1
        if Pressed(hcancel) err=9
        wait
      enddo
      if err==0 then
        sprintf(s,"OUTPORT %i,511",0x80E4+(k/2)*0x0100+(k & 1)*0x0002)
        if SERV.Cmdimm(0,s)<0 err=2    // Send command
        t=Time()
        while err==0 && $A[0].length==0 do
          if Time()-t>3000 err=1
          if Pressed(hexit) err=-1
          if Pressed(hcancel) err=9
          wait
        enddo
      endif
      layoutdiffers=1
      if err!=0 break
      // Third field measurement.
      if SERV.Cmdimm(0,s2)<0 err=2     // Send command
      t=Time()                         // Wait for answer
      while err==0 && $A[0].length==0 do
        if Time()-t>10000 err=1
        if Pressed(hexit) err=-1
        if Pressed(hcancel) err=9
        wait
      enddo
      if err==0 && $A[0].answer!=S_MOVE err=3
      if err!=0 break
      // Process results.
      zmax[k]=0.0
      for j=0,j<24,j++ do
        zmax[k]=zmax[k]+$int2($A[0]+50+4*j)
      enddo
      zmax[k]=zmax[k]/24.0
    endif
    tested[k]=1
    // Display data.
    draw window=hgraph
    for m=0,m<nfing,m++ do
      ys=90+m*dy
      if $LAY.side[m]!=0 ys=ys+7
      for n=0,n<2,n++ do
        xs=(n==0?15:LEFTX/2+10)
        if m*2+n==k then
          draw color=BLACK bkcolor=WHITE
          draw at xs+20,ys-dy*3/4 fillrect xs+135,ys-dy*3/4+dy
          draw mode=M_RIGHT at xs+130,ys-(allowz?5:0)
          if fmin[k]+fmax[k]>1000 then
            draw text=format("%.1f%%",(fmax[k]-fmin[k])/(fmax[k]+fmin[k])*200.0)
          else
            draw text="???"
          endif
          if fmin[k]<SINMIN || fmin[k]>SINMAX ||                               \
            fmax[k]<SINMIN || fmax[k]>SINMAX ||                                \
            fmax[k]-fmin[k]<128.0*(fmin[k]+fmax[k])/dadjfactors then
            draw color=LIGHTRED
          endif
          draw mode=M_LEFT at xs+25,ys-(allowz?5:0)
          draw text=format("%i .. %i",fmin[k],fmax[k])
          if allowz then
            draw color=BLACK mode=M_RIGHT at xs+130,ys+5
            if fmin[k]+fmax[k]>1000 then
              draw text=format("%.1f%%",                                       \
              (zmax[k]-zmin[k])/(fmax[k]+fmin[k])*200.0)
            else
              draw text="???"
            endif
            if zmin[k]<COSMIN || zmin[k]>COSMAX ||                             \
              zmax[k]<COSMIN || zmax[k]>COSMAX ||                              \
              zmax[k]-zmin[k]<48.0*(fmin[k]+fmax[k])/dadjfactorc then
              draw color=LIGHTRED
            endif
            draw mode=M_LEFT at xs+25,ys+5
            draw text=format("%i .. %i",zmin[k],zmax[k])
          endif
        else
          draw color=WHITE bkcolor=WHITE
          draw at xs+20,ys-dy*3/4 rect xs+135,ys-dy*3/4+dy
        endif
      enddo
    enddo
    draw show
  enddo
  if err==0 then
    for i=0,i<2*nfing,i++ do
      if used[i]==0 continue
      if tested[i]==0 break
    enddo
    if i>=2*nfing then
      if hlog!=NULL then
        fprintf(hlog,"\nTesting Dallas potentiometers...\n")
        for k=0,k<2*nfing,k++ do
          if used[k]==0 continue
          if allowz then
            fprintf(hlog,                                                      \
              "  Head %i%c:  fmin=%5i, fmax=%5i  zmin=%5i, zmax=%5i",          \
              k/2,k & 1?'R':'L',fmin[k],fmax[k],zmin[k],zmax[k])
            if fmin[k]<SINMIN || fmin[k]>SINMAX ||                             \
              fmax[k]<SINMIN || fmax[k]>SINMAX ||                              \
              fmax[k]-fmin[k]<128.0*(fmin[k]+fmax[k])/dadjfactors ||           \
              zmin[k]<COSMIN || zmin[k]>COSMAX ||                              \
              zmax[k]<COSMIN || zmax[k]>COSMAX ||                              \
              zmax[k]-zmin[k]<48.0*(fmin[k]+fmax[k])/dadjfactorc               \
            then
              fprintf(hlog," (bad)\n")
            else
              fprintf(hlog," (good)\n")
            endif
          else
            fprintf(hlog,"  Head %i%c:  fmin=%5i, fmax=%5i",                   \
              k/2,k & 1?'R':'L',fmin[k],fmax[k])
            if fmin[k]<SINMIN || fmin[k]>SINMAX ||                             \
              fmax[k]<SINMIN || fmax[k]>SINMAX ||                              \
              fmax[k]-fmin[k]<128.0*(fmin[k]+fmax[k])/dadjfactors              \
            then
              fprintf(hlog," (bad)\n")
            else
              fprintf(hlog," (good)\n")
            endif
          endif
        enddo
      endif
      goto restart
    else if i==firstrail*2 || i==firstrail*2+nfing then
      base=firstrail*2
    else if testersides==0x3 && i>=nfing then
      base=i-nfing-2
    else
      base=i-2
    endif
    goto nextbase
  else if err!=(-1) && err!=9 then
    clear hright
    change hinfo text="Test error"
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==1 then
      draw text="响应超时！"
      draw at 6,60 color=BLACK
      draw text="在规定时间内,测试机无应答。 "
    else if err==2 then
      draw text="Command execution error!"
      draw at 6,60 color=BLACK
      draw text="Tester or tester support routine rejected command sent by "
      draw text="this routine. "
    else if err==3 then
      draw text="Unexpected answer!"
      draw at 6,60 color=BLACK
      draw text="Answer received from crate is not a valid measurement. "
    else if err==4 then
      draw text="Internal error!"
      draw at 6,60 color=BLACK
      draw text="Script is unable to select heads that will work as antennas. "
    endif
    draw text="测试终止。"
    draw show
    hcont=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="继续"
      help="按下继续"
    endc
    while 1 do
      if Pressed(hcont) break
      if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  // Restore original settings of Dallas potentiometers.
  Restoreoldlayout()
  Sendextention()
  layoutdiffers=0
  change hleft position=4,4,LEFTX,LEFTY
  destroy hgraph
  if err<0 return -1
  return 0
end

// Measures individual resistances of the needles. They are used mainly in
// LATEST measurements to limit power dissipation on the oxydized pads. Returns
// -1 if operator decided to quit script and 0 otherwise.
function int Needleresistance()
  int i,n,t,ngood[32],status,nbad,nhigh,nlow,nvalid,ys,err
  float x,y,r,rmin[32]
  char s[512]
  handle hinterrupt,htable,hretry,hcont,hsavepartial
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || $LAY.probetype!=1 ||            \
    (measfeatures2 & MF2_LACONT)==0                                            \
  then
    return 0                           // Unsupported feature
  endif
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="Needle resistances"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now measuring the mean resistances of the needles and attached "
  draw text="wires, starting from the shortcut relay on the on-head board. "
  draw text="These resistances are used in LATEST measurements to detect "
  draw text="high-ohmical contacts that may cause damage to needle pins."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="停止测试"
    help="按下可以停止针头电阻值测量"
  endc
  for i=0,i<$LAY.nfing*2,i++ do
    ngood[i]=0
    rmin[i]=1.0e10
  enddo
  // Measurements begin here.
  err=0
  for n=0,n<20 && err==0,n++ do
    change hinfo limits=n,20
    // Generate and send commands.
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      if (i & 1)==0 then
        Convertpad(&x,&y,"SIG",i,DELTA/4.0)
      else
        Convertpad(&x,&y,"GND",i,DELTA/4.0)
      endif
      if y<$LAY.yoffset[i/2]/1000.0 then
        y=y+DELTA*2
      else
        y=y-DELTA*2
      endif
      sprintf(s,"M %i[%.3f,%.3fH%gV%gP%gA5] D(0x3E,%i,0,0,0,0,0,0,0)",         \
        i,x,y,strokez,strokev,strokep,i)
      SYS.Killimm(i)
      SERV.Cmdimm(i,s)
    enddo
    // Wait till answers are back.
    t=Time()
    while 1 do                         // Wait till all answers come back
      if Pressed(hexit) return -1      // Operator interrupted test
      if Pressed(hinterrupt) return 0
      for i=0,i<$LAY.nfing*2,i++ do
        if used[i]==0 continue
        if $A[i].length==0 break
      enddo
      if i>=$LAY.nfing*2 break         // All answers came
      if Time()-t>10000 then
        err=1; break                   // Timeout 10 seconds
      endif
      wait
    enddo
    if err!=0 break
    // Process answers.
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      if $A[i].answer==S_ERROR then
        err=2; break                   // Unsupported command?
      else if $A[i].answer!=S_DEBUG then
        err=3; break                   // Must not happen!
      else
        status=$int2($A[i]+5)
        if (status & 0x8A00)==0 then
          ngood[i]++
          r=$float4($A[i]+7)
          if (status & 0x0100) r=r*1.0e-6
          rmin[i]=Min(rmin[i],r)
        endif
      endif
    enddo
  enddo
  // Measurements finished, process results.
  n=0; nbad=0; nhigh=0; nlow=0; nvalid=0
  if err==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      n++
      if ngood[i]<10 then
        nbad++
      else if rmin[i]>=15.0 then
        nhigh++
      else if rmin[i]<=1.0 then
        nlow++
      else
        nvalid++
      endif
    enddo
  endif
  if err!=0 || nbad!=0 || nhigh!=0 || nlow!=0 then
    // Display error message.
    change hinfo text="Invalid resistance"
    change hinfo limits=0,0
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==1 then
      draw text="Timeout!"
      draw at 6,60 color=BLACK
      draw text="There is no answer from tester within 10 seconds. "
    else if err==2 then
      draw text="Tester reports error!"
      draw at 6,60 color=BLACK
      draw text="Embedded software was unable to execute measurement command "
      draw text="correctly. Most probably, the software is too old. "
    else if err==3 then
      draw text="Unexpected answer!"
      draw at 6,60 color=BLACK
      draw text="Embedded software returned unexpected answer. "
    else
      draw text="Bad or high-ohmical measurements!"
      draw at 6,60 color=BLACK
      draw text="Please consult the table below and decide what to do."
    endif
    draw show
    if err!=0 then
      htable=NULL
    else
      htable=control CHILD
        window=hright
        position=9,90,RIGHTX-18,170
        limits=RIGHTX-60,n*20+38
        mode=M_VSCROLL
        help="发现的问题"
        bkcolor=PINK
        size=4096
      endc
      ys=30
      draw window=htable font=INFOFONT color=DARKGRAY
      draw at 5,5 to 225,5
      draw at 5,5 to 5,32 at 14,26 text="Head"
      draw at 55,5 to 55,32 at 64,26 text="Minimal R, Ohm"
      draw at 170,5 to 170,33 at 178,26 text="Valid"
      draw at 225,5 to 225,33
      draw at 5,32 to 225,32
      draw font=FIXEDSYS mode=M_CENTERED
      for i=0,i<$LAY.nfing*2,i++ do
        if used[i]==0 continue         // Head is excluded from test
        ys=ys+20
        draw color=DARKGRAY
        draw at 5,ys-18 to 5,ys+2 to 225,ys+2 to 225,ys-18
        draw at 55,ys-18 to 55,ys+2
        draw at 30,ys color=BLACK
        draw text=format("%i%c",i/2,(i & 1?'R':'L'))
        if rmin[i]<=1.0 || rmin[i]>=15.0 then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 112,ys text=format("%.3f",rmin[i])
        draw at 170,ys-18 to 170,ys+2
        if ngood[i]<10 then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 197,ys text=format("%i",ngood[i])
      enddo
      draw show
      setfocus htable
    endif
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+20,120,24
      name="重试"
      help="按下再次测量电阻"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+20,120,24
      name="继续"
      help="跳过测量并继续执行脚本"
    endc
    if err!=0 || nvalid==0 then
      hsavepartial=NULL
    else
      hsavepartial=control BUTTON
        window=hright
        position=RIGHTX/2-80,USERY+53,160,24
        name="保存部分结果"
        help="将好的结果保存到布局中"
      endc
    endif
    while 1 do
      if Pressed(hexit) return -1
      if Pressed(hretry) goto repeat
      if Pressed(hcont) return 0
      if hsavepartial!=NULL && Pressed(hsavepartial) break
      wait
    enddo
  endif
  // Save (partial) results to layout.
  for i=0,i<$LAY.nfing*2,i++ do
    if used[i]==0 continue
    if ngood[i]>=10 && rmin[i]<10.0 then
      $int2($EXT0+702+2*i)=Floor(rmin[i]*1000.0+0.5)
    endif
  enddo
  layoutdiffers=1
  Makelayoutcopy()
  i=Loadlayoutmeas(1,1)
  if i==0 layoutdiffers=0
  return i
end

#define NZPOINT        120             // Number of sampling points, N*6
#define NZSTAT         16              // Number of measurements per point, even
#define PRESSMIN       47500           // Minimal signal without pressure
#define ZPINMIN        10.0            // Minimal Z pin distance, um
#define ZPINMAX        100.0           // Maximal Z pin distance, um

// Verifies Z pressure sensors. Returns -1 if operator decided to quit script
// and 0 to continue.
function int Verifyzpressure()
  int i,j,n,t,head,ref,nheads,imin,imax,select,badhead,limit[32],zn[32],err
  int ntop,nbot,toplist,botlist,xb,yb,dx,redraw,firsthead,phase,ismicro
  float x[32],y[32],z[32],zref[32],zmax[32],pprev[32],zpmax[32],zpindist[32]
  float pmean[32],zmean[32],kmean[32],cmean[32],zpmean,dyin
  float zp[32][NZPOINT],zz[32][NZPOINT],zk[32][NZPOINT],zc[32][NZPOINT]
  float zm[NZPOINT],pm[NZPOINT],zi[NZPOINT],pi[NZPOINT],zfactlo[32],zfacthi[32]
  float u,zbase,zscale,pbase,pscale,kcontact,ccontact,psensfact
  float zstep,zfactor,senslomin,senslomax,senshimin,senshimax,rangemin
  char buf[128],s[512]
  handle hview,hinterrupt,hhead[32],hok,hcont
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2  && testertype!=TT_S3 &&            \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    ($EXTLAY.zheadtype & HCZ_VALID)==0 ||                                      \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHPS &&                         \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP)                           \
    return 0                           // Pressure factors are not supported
  nheads=$LAY.nfing*2
  if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
    ismicro=1
  else
    ismicro=0
  endif
  // Set expected limits.
  if ($EXTLAY.zheadtype & HCZ_DMSMASK)==HCZ_DMSSTD then
    // Mirror (direct) sensor.
    zstep=8.0                          // Z step, micrometers
    psensfact=80.0                     // Expected bits per micrometer
    senslomin=50.0                     // Minimal low sensitivity, bits/um
    senslomax=100.0                    // Maximal low sensitivity, bits/um
    senshimin=60.0                     // Minimal high sensitivity, bits/um
    senshimax=110.0                    // Maximal high sensitivity, bits/um
    rangemin=22500.0                   // Minimal sensor range, bits
  else if ($EXTLAY.zheadtype & HCZ_DMSMASK)==HCZ_DMSREV then
    // Inverting sensor.
    zstep=4.0
    psensfact=150.0
    senslomin=90.0
    senslomax=200.0
    senshimin=120.0
    senshimax=240.0
    rangemin=43500.0
  else
    // Autodetect. We have no choice but to set wide limits.
    zstep=4.0
    psensfact=100.0
    senslomin=50.0
    senslomax=200.0
    senshimin=60.0
    senshimax=240.0
    rangemin=43500.0                   // A question of security
  endif
  if ($EXTLAY.zheadtype & HCZ_VALID)==0 then
    zfactor=1.10                       // A kind of compromise
  else if ($EXTLAY.zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA2G then
    zfactor=1.10                       // A2 gray parallelogramm
  else if ($EXTLAY.zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA2W then
    zfactor=1.10                       // A2 white parallelogramm
  else if ($EXTLAY.zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA3 then
    zfactor=1.35                       // A3 gray parallelogramm
  else
    zfactor=1.00                       // Z axis with a scale
  endif
  err=0
  if (cratefeatures & CF_PRESSFACT)==0                                         \
    err=9                           // Pressure factor is not supported
  if err!=0 goto reporterror
  // Prepare for the adjustment.
  change hinfo limits=0,0
  change hinfo text="验证压力"
  if hlog!=NULL fprintf(hlog,"Verifying pressure sensors...\n");
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="针头上的压力传感器特性,可能有明显的"
  draw text="不同.当前测试会检查感应器的质量是否"
  draw text="可以保证设备可靠运行."
  draw color=LIGHTRED text="请勿抖动校验板!" color=BLACK
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="停止测试"
    help="按下即可停止压力感应器测试"
  endc
  // Prepare for test.
  for head=0,head<32,head++ do
    limit[head]=0
  enddo
  // Select X-Y coordinates and learn Z coordinate of the board.
  for n=5,n>=0 && err==0,n-- do
    // Send movements.
    for head=0,head<nheads && err==0,head++ do
      if used[head]==0 continue
      if Convertpad(x+head,y+head,(head & 1?"GND":"SIG"),head,DELTA)<0.0 err=4
      if y[head]<$LAY.yoffset[head/2]/1000.0 then
        y[head]=y[head]+DELTA*2
      else
        y[head]=y[head]-DELTA*2
      endif
      sprintf(s,"M %i[%g,%gA10H15V15P5] Z(%i)",head,x[head],y[head],head)
      SYS.Killimm(head)
      if SERV.Cmdimm(head,s)==0 err=1
    enddo
    // Wait for answers.
    t=Time()
    while err==0 do
      for head=0,head<nheads && err==0,head++ do
        if used[head]==0 continue
        if $A[head].length==0 break
      enddo
      if head>=nheads break            // All answers are back
      if Time()-t>10000 err=3          // Timeout
      if Pressed(hinterrupt) err=5
      if Pressed(hexit) err=-1
      wait
    enddo
    // Process answers.
    for head=0,head<nheads && err==0,head++ do
      if used[head]==0 continue
      if $A[head].answer!=S_INPORT err=2
      zref[head]=$A[head].inport       // Z reference coordinate, um
    enddo
  enddo
  // Wait a bit to stop possible shaking of the board.
  if err==0 delay 2500
  // Start measurements. I test first all left teads, then all right.
  for phase=0,phase<2,phase++ do
    // Move heads up and at coordinates.
    for head=0,head<nheads && err==0,head++ do
      if used[head]==0 || (head & 1)!=phase continue
      sprintf(s,"M %i[%g,%gA10H15V15P5] UP(%i) NOP",head,x[head],y[head],head)
      SERV.Cmdimm(head,s)
      sprintf(s,"OUTPORT32 HEAD(%i),0x10010007,50",head)
      SERV.Cmdimm(32,s)
      ref=head^1
      sprintf(s,"M %i[%g,%gA5] Z(%i)",ref,x[ref],y[ref],ref)
      SERV.Cmdimm(32,s)
    enddo
    t=Time()
    while err==0 do
      for head=0,head<nheads && err==0,head++ do
        if used[head]==0 || (head & 1)!=phase continue
        if $A[head].length==0 break
      enddo
      if head>=nheads break            // All answers are back
      if Time()-t>10000 err=3          // Timeout
      if Pressed(hinterrupt) err=5
      if Pressed(hexit) err=-1
      wait
    enddo
    t=Time()
    while err==0 do                    // Wait 200 ms for stabilization
      if Pressed(hinterrupt) err=5
      if Pressed(hexit) err=-1
      if Time()-t>200 break
      wait
    enddo
    for n=-100,n<NZPOINT && err==0,n++ do
      change hinfo limits=(NZPOINT+120)*phase+n+100,(NZPOINT+120)*2
      firsthead=1
      // Set Z coordinate.
      for head=0,head<nheads && err==0,head++ do
        if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
        if firsthead then
          // Older versions of Crate controller don't prolongate Z up timeout
          // on OUTPORT 0x10010018, therefore I reprogram Dallas potentiometer
          // with the current value. As a side effect, this command prolongates
          // Z up time.
          sprintf(s,"OUTPORT32 HEAD(%i),0xE0,%i",head,$EXTLAY.sinadj[head])
          SERV.Cmdimm(32,s)
          firsthead=0
        endif
        // Negative n values correspond to fast preliminary movement.
        if n<0 then
          z[head]=zref[head]+n*40.0-(NZPOINT/2)*zstep
        else
          z[head]=zref[head]+n*zstep-(NZPOINT/2)*zstep
        endif
        sprintf(s,"OUTPORT32 HEAD(%i),0x10010018,%i",head,z[head])
        SERV.Cmdimm(head,s)
        zmax[head]=z[head]
      enddo
      // Wait for answer.
      t=Time()
      while err==0 do
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          if $A[head].length==0 break
        enddo
        if head>=nheads break
        if Time()-t>5000 err=3         // Timeout
        if Pressed(hinterrupt) err=5
        if Pressed(hexit) err=-1
        wait
      enddo
      // If preliminary movement, delay and skip the rest.
      if n<=0 && err==0 then
        while Time()-t<50 do
          if Pressed(hexit) err=-1
          wait
        enddo
        if n<0 continue
      endif
      // Make NZSTAT pressure, pin-to-pin resistance, capacity-to-reference and
      // coordinate tests. Note that there are no wait operators in the waiting
      // loops, they slow down the test significantly.
      for head=0,head<nheads,head++ do
        if (head & 1)!=phase continue
        pmean[head]=0.0
        zmean[head]=0.0
        kmean[head]=0.0
        cmean[head]=0.0
      enddo
      for j=0,j<NZSTAT && err==0,j++ do
        // Measure pressures.
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          sprintf(s,"INPORT32 HEAD(%i),0x10000107",head)
          SERV.Cmdimm(head,s)
        enddo
        t=Time()
        while err==0 do
          for head=0,head<nheads && err==0,head++ do
            if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
            if $A[head].length==0 break
          enddo
          if head>=nheads break
          if Time()-t>5000 err=3       // Timeout
          if Pressed(hinterrupt) err=5
          if Pressed(hexit) err=-1
        enddo
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          pmean[head]=pmean[head]+$A[head].inport
        enddo
        // Measure Z coordinates.
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          sprintf(s,"INPORT32 HEAD(%i),0x10000018",head)
          SERV.Cmdimm(head,s)
        enddo
        t=Time()
        while err==0 do
          for head=0,head<nheads && err==0,head++ do
            if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
            if $A[head].length==0 break
          enddo
          if head>=nheads break
          if Time()-t>5000 err=3       // Timeout
          if Pressed(hinterrupt) err=5
          if Pressed(hexit) err=-1
        enddo
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          zmean[head]=zmean[head]+$A[head].inport
        enddo
        // Measure pin-to-pin resistances (Kelvin test only).
        if $LAY.probetype==1 then
          for head=0,head<nheads && err==0,head++ do
            if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
            sprintf(s,"M %i[%g,%gA10H15V15P5] CONTKELV(%i)",                   \
              head,x[head],y[head],head)
            SERV.Cmdimm(head,s)
          enddo
          t=Time()
          while err==0 do
            for head=0,head<nheads && err==0,head++ do
              if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
              if $A[head].length==0 break
            enddo
            if head>=nheads break
            if Time()-t>5000 err=3     // Timeout
            if Pressed(hinterrupt) err=5
            if Pressed(hexit) err=-1
          enddo
          for head=0,head<nheads && err==0,head++ do
            if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
            if ($A[head].status & 0x0200)==0 kmean[head]=kmean[head]+10000.0
          enddo
        endif
        // Measure capacity.
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          ref=head^1
          sprintf(s,"M %i[%g,%gA5] %i[%g,%g] CONTCAP(%i,%i)",                  \
            head,x[head],y[head],ref,x[ref],y[ref],head,ref)
          SERV.Cmdimm(head,s)
        enddo
        t=Time()
        while err==0 do
          for head=0,head<nheads && err==0,head++ do
            if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
            if $A[head].length==0 break
          enddo
          if head>=nheads break
          if Time()-t>5000 err=3       // Timeout
          if Pressed(hinterrupt) err=5
          if Pressed(hexit) err=-1
        enddo
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          if $A[head].status & 0x1000 then
            cmean[head]=cmean[head]+10000.0
          else
            cmean[head]=cmean[head]+$int4($A[head]+8)
          endif
        enddo
      enddo
      // Process results.
      for head=0,head<nheads && err==0,head++ do
        if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
        pmean[head]=pmean[head]/NZSTAT
        zmean[head]=zmean[head]/NZSTAT
        kmean[head]=kmean[head]/NZSTAT
        cmean[head]=cmean[head]/NZSTAT
        if zmean[head]!=0 && n>NZPOINT/10 then
          if Abs(zmean[head]-z[head])>150.0 then
            limit[head]=1              // Coordinate differs from expected
          else if n>4 then
            zpmean=(zp[head][0]+zp[head][1]+zp[head][2]+zp[head][3])/4.0
            if zpmean-pmean[head]>10000 then
              limit[head]=1            // Pressure limit reached
            endif
          endif
        endif
        zz[head][n]=z[head]            // Or better zmean[]?
        zp[head][n]=pmean[head]
        zk[head][n]=kmean[head]
        zc[head][n]=cmean[head]
        zn[head]=n                     // Last point is discarded!
      enddo
    enddo
    // Measure maximal pressure that sensor can deliver. I set Z coordinate
    // 1000 (soft touch) or 700 (micro needle) micrometers under the measured
    // contact. Attention, careless use of this overpressure may destroy the
    // needle!  Currently allowed only for soft touch needles, for micro
    // needles the minimal value of 5000 bits is assumed.
    for head=0,head<nheads,head++ do
      if (head & 1)!=phase continue
      if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
        limit[head]=1                  // Skip maximal P for micro needles
        zpmax[head]=5000
      else
        limit[head]=0
        pprev[head]=100000
      endif
    enddo
    for j=0,j<=(ismicro?14:20) && err==0,j++ do
      change hinfo limits=(NZPOINT+120)*phase+NZPOINT+100+j,(NZPOINT+120)*2
      // Set Z coordinate.
      for head=0,head<nheads && err==0,head++ do
        if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
        z[head]=Max(zref[head]+j*50.0,zmax[head])
        sprintf(s,"OUTPORT32 HEAD(%i),0x10010018,%i",head,z[head])
        SERV.Cmdimm(head,s)
      enddo
      t=Time()
      while err==0 do
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          if $A[head].length==0 break
        enddo
        if head>=nheads break
        if Time()-t>5000 err=3         // Timeout
        if Pressed(hinterrupt) err=5
        if Pressed(hexit) err=-1
        wait
      enddo
      // Move down slowly!
      while Time()-t<100 do
        wait
      enddo
      // Check pressure. Single measurement is sufficient.
      for head=0,head<nheads && err==0,head++ do
        if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
        sprintf(s,"INPORT32 HEAD(%i),0x10000107",head)
        SERV.Cmdimm(head,s)
      enddo
      t=Time()
      while err==0 do
        for head=0,head<nheads && err==0,head++ do
          if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
          if $A[head].length==0 break
        enddo
        if head>=nheads break
        if Time()-t>5000 err=3         // Timeout
        if Pressed(hinterrupt) err=5
        if Pressed(hexit) err=-1
        wait
      enddo
      for head=0,head<nheads && err==0,head++ do
        if used[head]==0 || limit[head]!=0 || (head & 1)!=phase continue
        zpmax[head]=$A[head].inport
        if $A[head].inport<3500 limit[head]=1
        if $A[head].inport<32768 &&                                            \
          pprev[head]-$A[head].inport<(ismicro?1000:250) then
          limit[head]=1
        endif
        pprev[head]=$A[head].inport
      enddo
    enddo
    // Move heads up, necessary for older versions of Crate controller.
    for head=0,head<nheads,head++ do
      if used[head]==0 || (head & 1)!=phase continue
      sprintf(s,"OUTPORT32 HEAD(%i),0x10010007,0",head)
      SERV.Cmdimm(32,s)
      sprintf(s,"OUTPORT32 HEAD(%i),0x10010008,5000",head)
      SERV.Cmdimm(head,s)
    enddo
    t=Time()
    while Time()-t<1000 do
      wait
    enddo
  enddo
  // Test is finished. Restore default Z port speed and move heads up and in
  // home position.
  for head=0,head<nheads && err==0,head++ do
    if used[head]==0 continue
    sprintf(s,"OUTPORT32 HEAD(%i),0x10010007,0",head)
    SERV.Cmdimm(32,s)
    sprintf(s,"OUTPORT32 HEAD(%i),0x10010008,5000",head)
    SERV.Cmdimm(32,s)
  enddo
  delay 250
  if err<0 return -1
  for head=0,head<nheads && err==0,head++ do
    if used[head]==0 continue
    sprintf(s,"M %i(Z) NOP",head)
    SERV.Cmdimm(32,s)
  enddo
  // Approximate pressure curves with splines.
  for head=0,head<nheads && err==0,head++ do
    if used[head]==0 continue
    zpmean=(zp[head][0]+zp[head][1]+zp[head][2]+zp[head][3])/4.0
    for imin=4,imin<zn[head],imin++ do
      if zpmean-zp[head][imin]>=500 break
    enddo
    for imax=zn[head]-1,imax>=0,imax-- do
      if zpmean-zp[head][imax]>=2500 break
    enddo
    imax=imax-1
    if imax-imin>NZPOINT/16 then
      for j=0,j<imax-imin+1,j++ do
        zm[j]=j
        pm[j]=zp[head][j+imin]
        zi[j]=j
      enddo
      dyin=50.0
      SYS.Splinefit(imax-imin+1,zm,pm,&dyin,imax-imin+1,zi,pi);
      zfactlo[head]=Abs(pi[3]-pi[0])/3.0/zstep*zfactor
      zfacthi[head]=Abs(pi[imax-imin]-pi[imax-imin-3])/3.0/zstep*zfactor
    endif
  enddo
  // Determine Z pin-to-pin distance.
  if err==0 && $LAY.probetype==1 then
    for head=0,head<nheads,head++ do
      zpindist[head]=-100000.0         // Means unknown Z distance between pins
      if used[head]==0 continue
      if zn[head]<=1 continue
      if zk[head][0]>=5000.0 || zk[head][zn[head]-1]<=5000.0 continue
      if zc[head][0]>=5000.0 || zc[head][zn[head]-1]<=5000.0 continue
      kcontact=zz[head][zn[head]-1]
      ccontact=zz[head][zn[head]-1]
      for i=zn[head]-1,i>=0,i-- do
        if zk[head][i]>5000.0 kcontact=zz[head][i]
        if zc[head][i]>5000.0 ccontact=zz[head][i]
      enddo
      zpindist[head]=(kcontact-ccontact)/zfactor
    enddo
  endif
  // If error was detected, report it.
reporterror:
  if err!=0 then
    if hlog!=NULL then
      if err==5 then
        fprintf(hlog,                                                          \
        "  Verification of pressure sensors interrupted by operator\n");
      else
        fprintf(hlog,                                                          \
        "  Verification of pressure sensors was unsuccessfull (%i)\n",err);
      endif
    endif
    for head=0,head<nheads,head++ do
      if used[head]==0 continue
      SYS.Killimm(head)
    enddo
    if err==5 return 0                   // Operator interrupted adjustment
    clear hright
    change hinfo limits=0,0
    change hinfo text="Sensors not verified!"
    hcont=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="继续"
      help="按下返回主菜单"
    endc
    draw window=hright color=LIGHTRED font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text "Unable to test pressure sensors. " color=BLACK
    if err==1 then
      draw text="Script was unable to send command to the tester. Probably "
      draw text="this is an internal error. "
    else if err==2 then
      draw text="tetser returned unexpected answer. Check that tester is "
      draw text="loaded and that embedded software is actual. "
    else if err==3 then
      draw text="There was no answer from the tester within the expected "
      draw text="timeout. "
    else if err==4 then
      draw text="Script was unable to select contacting points. Probably "
      draw text="this is an internal error. "
    else if err==9 then
      draw text="Pressure sensor calibration and verification is not "
      draw text="supported. Check that embedded software is actual. "
    else
      draw text="The exact reason is unclear. "
    endif
    draw show
    while 1 do
      if Pressed(hcont) then
        return 0
      else if Pressed(hexit) then
        return -1
      endif
      wait
    enddo
  endif
  // Save results to log.
  if hlog!=NULL then
    fprintf(hlog,"  Pressure verification results:\n")
    for head=0,head<nheads,head++ do
      if used[head]==0 continue
      fprintf(hlog,"  Head %i%c: Plo = %5.1f, Phi = %5.1f bits/um, ",          \
        head/2,head & 1?'R':'L',zfactlo[head],zfacthi[head])
      fprintf(hlog,"Pmin = %5.0f, Range = %5.0f bits\n",                       \
        zp[head][0],zp[head][0]-zpmax[head])
      if $LAY.probetype==1 then
        fprintf(hlog,"         : Z pin distance = %5.1f um\n",zpindist[head])
      endif
    enddo
  endif
  // Analyse results. Script will start display with the first bad head.
  badhead=-1
  for head=0,head<nheads && badhead<0,head++ do
    if used[head]==0 continue
    if zfactlo[head]<senslomin || zfactlo[head]>senslomax badhead=head
    if zfacthi[head]<senshimin || zfacthi[head]>senshimax badhead=head
    if zp[head][0]<PRESSMIN badhead=head
    if zp[head][0]-zpmax[head]<rangemin badhead=head
    if $LAY.probetype==1 && $EXTLAY.needletype!=NT_LATEST then
      if zpindist[head]<ZPINMIN || zpindist[head]>ZPINMAX badhead=head
    endif
  enddo
  // Ask user to verify test results.
  change hinfo limits=0,0
  change hinfo text="压力测试结果"
  clear hleft
  hview=control GRAPH                  // Create pressure correction viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help="Z方向压力测试结果"
    color=BLACK
    bkcolor=WHITE
  endc
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=LIGHTRED
  if badhead<0 then
    draw text="Pressure sensors verified. "
  else
    draw text="检测到可疑参数。 "
  endif
  draw text="请检查结果。"
  draw show
  ntop=0; toplist=0
  nbot=0; botlist=0
  for head=0,head<nheads,head++ do
    if $LAY.side[head/2]==0 then
      toplist=toplist | (1<<head)
      ntop++
    else
      botlist=botlist | (1<<head)
      nbot++
    endif
  enddo
  dx=(RIGHTX-15)/Max(ntop,nbot)-5
  if dx>50 dx=50
  yb=(ntop!=0 && nbot!=0?140:170)
  draw font=INFOFONT mode=M_CENTERED
  select=badhead
  // Create buttons for top heads.
  if ntop>0 then
    if nbot>0 then
      draw at RIGHTX/2,yb+10 text="上手臂:"
      yb=yb+12
    endif
    xb=(RIGHTX-(dx+5)*ntop+5)/2
    for head=0,head<nheads,head++ do
      if (toplist & (1<<head))==0 continue
      hhead[head]=control BUTTON
        window=hright
        position=xb,yb,dx,22
        name=format("%i%c",head/2,head & 1?'R':'L')
        help=format("按此可查看测试头%i%c的数据 ",head/2,head&1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      if used[head]==0 then
        disable hhead[head]
      else if select<0 then
        select=head
      endif
      xb=xb+dx+5
    enddo
    yb=yb+30
  endif
  // Create buttons for bottom cameras.
  if nbot>0 then
    if ntop>0 then
      draw at RIGHTX/2,yb+10 text="下手臂:"
      yb=yb+12
    endif
    xb=(RIGHTX-(dx+5)*nbot+5)/2
    for head=0,head<nheads,head++ do
      if (botlist & (1<<head))==0 continue
      hhead[head]=control BUTTON
        window=hright
        position=xb,yb,dx,22
        name=format("%i%c",head/2,head & 1?'R':'L')
        help=format("按此可查看测试头%i%c的数据",head/2,head&1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      if used[head]==0 then
        disable hhead[head]
      else if select<0 then
        select=head
      endif
      xb=xb+dx+5
    enddo
  endif
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="确定"
    help="按下可返回主菜单"
  endc
  redraw=1
  while 1 do
    if redraw then
      draw window=hview color=WHITE clear
      for head=0,head<nheads,head++ do
        if head==select then
          change hhead[head] color=LIGHTRED
          change hhead[head] bkcolor=YELLOW
        else
          change hhead[head] color=BLACK
          change hhead[head] bkcolor=GRAY
        endif
      enddo
      zscale=(LEFTX-81)/(NZPOINT*zstep)
      zbase=40.0+zscale*(NZPOINT/2)*zstep
      pscale=-200.0/12000.0
      pbase=260.0+pscale*1000.0
      // Draw frame.
      draw color=GRAY at 40,60 rect LEFTX-40,261
      draw mode=M_CENTERED font=MEDIUMFONT color=DARKGRAY
      draw at LEFTX/2,34 text=format("Head %i%c",select/2,select & 1?'R':'L')
      // Draw z scale.
      draw mode=M_CENTERED font=SMALLFONT
      for u=-(NZPOINT/2)*zstep,u<=(NZPOINT/2)*zstep,u=u+(NZPOINT/6)*zstep do
        xb=zbase+u*zscale
        draw color=GRAY at xb,261 to xb,266
        draw color=BLACK at xb,278 text=format("%g",u)
      enddo
      draw at LEFTX-20,264 text="Z, um"
      // Draw pressure scale.
      draw mode=M_RIGHT font=SMALLFONT
      for u=0,u<=10000,u=u+2000 do
        yb=pbase+u*pscale
        draw color=GRAY at 36,yb to 40,yb
        draw color=BLACK at 35,yb+7 text=format("%g",u)
      enddo
      draw color=BLACK mode=M_LEFT at 17,55 text="位"
      // Draw capacity curve.
      draw color=GREEN
      draw at LEFTX-80,20 to LEFTX-52,20
      draw at LEFTX-50,27 text="探针1"
      for i=0,i<zn[select],i++ do
        xb=(zz[select][i]-zref[select])*zscale+zbase
        yb=zc[select][i]*pscale+pbase
        if i==0 then
          draw at xb,yb
        else
          draw to xb,yb
        endif
      enddo
      // Draw Kelvin contact curve.
      if $LAY.probetype==1 then
        draw color=BLUE
        draw at LEFTX-80,35 to LEFTX-52,35
        draw at LEFTX-50,42 text="Both pins"
        for i=0,i<zn[select],i++ do
          xb=(zz[select][i]-zref[select])*zscale+zbase
          yb=zk[select][i]*pscale+pbase
          if i==0 then
            draw at xb,yb
          else
            draw to xb,yb
          endif
        enddo
      endif
      // Draw pressure curve.
      draw color=LIGHTRED
      draw at LEFTX-80,50 to LEFTX-52,50
      draw at LEFTX-50,57 text="压力"
      for i=0,i<zn[select],i++ do
        xb=(zz[select][i]-zref[select])*zscale+zbase
        yb=(zp[select][0]-zp[select][i])*pscale+pbase
        if i==0 then
          draw at xb,yb
        else
          draw to xb,yb
        endif
      enddo
      yb=293
      draw mode=M_LEFT font=SMALLFONT
      // Draw factors.
      if zfactlo[select]!=0.0 then
        if zfactlo[select]<senslomin || zfactlo[select]>senslomax then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 30,yb text=format("P factor LO = %.1f bits/um",zfactlo[select])
        draw text=format(", allowed %.1f .. %.1f",senslomin,senslomax)
        yb=yb+13
      endif
      if zfacthi[select]!=0.0 then
        if zfacthi[select]<senshimin || zfacthi[select]>senshimax then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 30,yb text=format("P factor HI = %.1f bits/um",zfacthi[select])
        draw text=format(", allowed %.1f .. %.1f",senshimin,senshimax)
        yb=yb+13
      endif
      // Draw minimal pressure.
      if zp[select][0]<PRESSMIN then
        draw color=LIGHTRED
      else
        draw color=BLACK
      endif
      draw at 30,yb text=format("P min = %.0f bits",zp[select][0])
      draw text=format(", allowed >%.1f",PRESSMIN)
      yb=yb+13
      // Draw pressure range.
      if zp[select][0]-zpmax[select]<rangemin then
        draw color=LIGHTRED
      else
        draw color=BLACK
      endif
      draw at 30,yb
      draw text=format("P range = %.0f bits",zp[select][0]-zpmax[select])
      draw text=format(", allowed >%.1f",rangemin)
      yb=yb+13
      // Draw Z pin distance.
      if $LAY.probetype==1 then
        if $EXTLAY.needletype==NT_LATEST then
          draw color=BLACK
        else if zpindist[select]<ZPINMIN || zpindist[select]>ZPINMAX then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 30,yb
        draw text="Z pin dist = "
        if zpindist[select]<(-10000.0) then
          draw text="Unknown"
        else
          draw text=format("%.0f um",zpindist[select])
        endif
        if $EXTLAY.needletype!=NT_LATEST                                       \
          draw text=format(", allowed %.0f..%.0f",ZPINMIN,ZPINMAX)
        yb=yb+13
      endif
      draw show
      redraw=0
    endif
    if Pressed(hok) break
    if Pressed(hexit) return -1
    for head=0,head<nheads,head++ do
      if Pressed(hhead[head]) then
        select=head
        redraw=1
      endif
    enddo
    wait
  enddo
  return 0
end

// Service function, protocols capacity corrections factors to the log file.
function int Protocolcfactors(char *caption)
  int i,freq
  if hlog==NULL return
  fprintf(hlog,"  %s\n",caption)
  freq=4
  for i=0,i<3,i++ do
    fprintf(hlog,"  F=%2i kHz: Ampl factor %5.3f, phase %4.2f degrees\n",      \
      freq,$int2($EXTLAY+628+i*2)/10000.0,$int2($EXTLAY+620+i*2)/100.0)
    freq=freq*2
  enddo
end

// Adjusts phases of AC capacity measurements.
function int Adjustcphase()
  int i,j,m,n,t,xs,ys,dy,nfing,extcfg,measopt,ncpa,nloop
  int freq,ant[32],bad,err,ndone
  float r,ccomp[4][32][5],zcomp[4][32][5],factor[32]
  float cc,zz,badc,badz,meanc[4][5],meanz[4][5],meanph[4][5],meanfact[5]
  float x,y,xa,ya,xt,yt,deltax,deltay,d,dmax,oldfactor
  float oldphase,newphase,oldampl,newampl
  char buf[128],s[512],xtra[2048]
  handle htable,hcancel,hmessage,hcont
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8)                                    \
    return 0                           // Only A5 series support C phase adjust
  if (measfeatures & MF_CCORR)==0                                              \
    return 0                           // Feature is not yet supported
  nfing=$LAY.nfing
  clear hright
  change hinfo limits=0,0
  change hinfo text="电容相位调整"
  change hleft position=-1000,*,*,*
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="这一步修正各个头部卡之间的细微差异, "
  draw text="主要用于高频测量 (8 或 16kHz). "
  draw text=" 按" font=MAINFONT text="取消"
  draw font=TIMESFONT text="."
  draw show
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY+30,120,24
    name="取消"
    help="按下可中断交流电容调整"
  endc
  hgraph=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="C相位调整数据"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  hmessage=control LIST
    window=hright
    position=6,100,RIGHTX-12,160
    help="C相位调整数据"
    color=BLACK
    bkcolor=WHITE
    font=FIXEDSYS
    mode=M_VSCROLL
    size=8192
  endc
  draw window=hgraph color=WHITE bkcolor=WHITE
  draw at 0,0 fillrect LEFTX,LEFTY
  draw show
  err=0
  if hlog!=NULL fprintf(hlog,"\nAdjusting capacity phases...\n")
  Protocolcfactors("Old corrections:")
  // Set capacity calibration in the air to adjust zero point.
  // Set MSD and capacity calibration in the air - the best way to get rid of
  // temperature instabilities, at the price of almost doubled test time.
  extcfg=$EXTLAY.extcfg
  measopt=$int4($EXTLAY+496)
  $EXTLAY.extcfg=extcfg|EXT_CAIR
  $int4($EXTLAY+496)=measopt|HCM_NOCTCHK
  // Initialize and verify factors.
  for i=0,i<nfing*2 && err==0,i++ do
    if $int2($EXTLAY+516+i*2)<(-250) then
      $int2($EXTLAY+516+i*2)=-250      // Clip to sound limits
    else if $int2($EXTLAY+516+i*2)>250 then
      $int2($EXTLAY+516+i*2)=250       // Ditto
    endif
    factor[i]=$int2($EXTLAY+516+i*2)/10000.0
  enddo
  // Also reset capacity corrections if they exceed 15% or 5 degrees. So high
  // corrections usually mean error during the previous adjust.
  for i=0,i<3,i++ do
    if $int2($EXTLAY+620+i*2)/100.0<(-5.0) ||                                  \
      $int2($EXTLAY+620+i*2)/100.0>5.0 ||                                      \
      $int2($EXTLAY+628+i*2)/10000.0<0.85 ||                                   \
      $int2($EXTLAY+628+i*2)/10000.0>1.15                                      \
    then
      $int2($EXTLAY+620+i*2)=0
      $int2($EXTLAY+628+i*2)=10000
    endif
  enddo
  layoutdiffers=1
  // Send layout extention to tester.
  i=Sendextention()
  if i!=0 err=2                        // Unable to send extended layout
  // Find antennas for each head.
  for i=0,i<nfing*2 && err==0,i++ do
    ant[i]=-1
    if used[i]==0 continue             // Head is excluded from test
    // Decide which head serves as antenna. As we have at least two full rails,
    // this is not a problem. To reduce direct capacity, I always take right
    // head. First I look for the head on the opposite side, then for the first
    // from the same side.
    m=-1
    for j=0,j<nfing,j++ do
      if $LAY.side[i/2]==$LAY.side[j] continue
      if used[j*2+1]==0 continue
      m=j*2+1; break                   // Antenna on the opposite side found
    enddo
    if m<0 then
      for j=0,j<nfing,j++ do
        if $LAY.side[i/2]!=$LAY.side[j] continue
        if i/2==j continue
        if used[j*2+1]==0 continue
        m=j*2+1; break                 // Antenna on the same side found
      enddo
    endif
    if m<0 err=4                       // Unable to select antenna
    ant[i]=m
  enddo
  if $LAY.nfing<=10 then
    dy=28
  else
    dy=23
  endif
  // Adjustment loop.
  ncpa=Max(6,Min(NCPA,32))
  // Make measurements for 4 frequencies.
  for freq=0,freq<4 && err==0,freq++ do
    // Capacity phase adjustment makes no sense if embedded software does not
    // support it.
    if (measfeatures & MF_CPHASE)==0 && freq<3 continue
    // Display set of rails.
    draw window=hgraph color=WHITE bkcolor=WHITE
    draw at 0,0 fillrect LEFTX,LEFTY
    draw color=BLACK mode=M_CENTERED font=MEDIUMFONT at LEFTX/2,30
    draw text=format("电容相位调整, f=%i kHz",                           \
      (freq==0?2:(freq==1?4:(freq==2?8:16))))
    change hmessage color=BLACK
    add hmessage text=format("频率 %i kHz...",                            \
      (freq==0?2:(freq==1?4:(freq==2?8:16))))
    draw font=SMALLFONT color=DARKGRAY
    for n=0,n<2,n++ do
      xs=(n==0?12:LEFTX/2+7)
      draw at xs,67 mode=M_LEFT text="Hd"
      if freq==3 then
        draw at xs+85,67 mode=M_RIGHT text="C,pf/Ph,rad"
        draw at xs+100,67 mode=M_LEFT text="Corr"
      else
        draw at xs+85,67 mode=M_RIGHT text="C,pf/Z,pf"
      endif
    enddo
    draw mode=M_RIGHT font=TIMESFONT color=DARKGRAY
    for m=0,m<nfing,m++ do
      ys=90+m*dy
      if $LAY.side[m]!=0 ys=ys+7
      for n=0,n<2,n++ do
        xs=(n==0?12:LEFTX/2+7)+15
        if n==0 then
          draw at xs,ys text=format("%iL",m)
        else
          draw at xs,ys text=format("%iR",m)
        endif
      enddo
    enddo
    draw show
    // Set test frequency.
    SYS.Killimm(0)
    buf[0]=S_DEBUG
    buf[1]=0x0E                        // Set field and capacity parameters
    $float4(buf+2)=1.0e7               // Short-to-antenna threshold 10 M
    if freq==0 then
      $int2(buf+6)=2000                // Capacity frequency
    else if freq==1 then
      $int2(buf+6)=4000
    else if freq==2 then
      $int2(buf+6)=8000
    else
      $int2(buf+6)=16000
    endif
    $int2(buf+8)=0                     // Default field frequency
    $int2(buf+10)=8                    // 4 V capacity voltage (standard)
    $int2(buf+12)=0                    // Default field voltage
    $int4(buf+14)=0                    // Reserved
    SYS.Sendimm(0,18,buf)
    t=Time()
    while $A[0].length==0 do
      if Time()-t>3000 then
        err=3; break                   // Timeout!
      endif
      wait
    enddo
    if err==0 && $A[0].answer!=S_DEBUG then
      err=6                            // Unsupported command?
    endif
    nloop=0
    while err==0 do
      nloop++
      // Test loop.
      for i=0,i<nfing*2 && err==0,i++ do
        if used[i]==0 continue         // Head is excluded from test
        // Reset statistics.
        Initsigma(ccomp[freq][i])
        Initsigma(zcomp[freq][i])
        // Calculate coordinates and move heads that do not participate in
        // measurements into the requested positions.
        for j=0,j<nfing*2,j++ do
          if used[j]==0 continue
          if j==i then                 // Head under test
            if Convertpad(&x,&y,"SIG",j,0.0)<0.0 err=5
          else if j==ant[i] then       // Antenna finger
            if Convertpad(&xa,&ya,"GND",j,0.0)<0.0 err=5
          else if (j & 1)==0 then      // Any remaining left head
            if Convertpad(&xt,&yt,"NOCT1",j,0.0)<0.0 err=5
            yt=$LAY.yoffset[j/2]/1000.0
            sprintf(s,"M %i[%g,%gH50A255] NOP",j,xt,yt)
            if SERV.Cmdimm(j,s)<0 err=5
          else                         // Any remaining right head
            if Convertpad(&xt,&yt,"NOCT2",j,0.0)<0.0 err=5
            yt=$LAY.yoffset[j/2]/1000.0
            sprintf(s,"M %i[%g,%gH50A255] NOP",j,xt,yt)
            if SERV.Cmdimm(j,s)<0 err=5
          endif
        enddo
        // Attention, finger overlapping in Y may cause Bad coordinates on
        // A5/A6 during single-side adjustment if board is rotated by more than
        // 2*DELTA!
        if i<ant[i] && y>=ya then
          y=y-DELTA; ya=ya+DELTA
        else if i>ant[i] && y<=ya then
          y=y+DELTA; ya=ya-DELTA
        endif
        // Wait till free heads have reached requested positions.
        t=Time()
        for j=0,j<nfing*2 && err==0,j++ do
          if used[j]==0 continue
          if j==i || j==ant[i] continue
          while err==0 do
            if Time()-t>15000 err=3    // Timeout
            if Pressed(hexit) err=-1
            if Pressed(hcancel) err=1
            if $A[j].length!=0 break
            wait
          enddo
        enddo
        if err!=0 break
        // Update display.
        draw window=hgraph
        for j=0,j<nfing*2,j++ do
          if used[j]==0 continue         // Head is excluded from test
          xs=(j & 1)==0?12:LEFTX/2+7
          ys=90+(j/2)*dy
          if $LAY.side[j/2]!=0 ys=ys+7
          draw color=(j==i?BLACK:WHITE) bkcolor=WHITE
          draw at xs+20,ys-dy*3/4 fillrect xs+130,ys-dy*3/4+dy
          draw color=BLACK mode=M_RIGHT font=SMALLFONT
          if Getcount(ccomp[freq][j])>0 then
            draw at xs+85,ys-6 text=format("%.2f",Getmean(ccomp[freq][j]))
            if freq==3 then
              draw at xs+85,ys+5 text=format("%.5f",                           \
              Getmean(zcomp[freq][j])/Getmean(ccomp[freq][j])-                 \
              Getmean(meanph[freq]))
            else
              draw at xs+85,ys+5 text=format("%.2f",Getmean(zcomp[freq][j]))
            endif
          endif
          if freq==3 then
            draw color=BLACK mode=M_LEFT font=TIMESFONT
            draw at xs+100,ys text=format("%i",factor[j]*10000.0)
          endif
          draw show
        enddo
        // Make ncpa fast C measurements at once. To reduce noise, measurements
        // are preceded by several dummies.
        sprintf(s,"M %i[%g,%gA50] %i[%g,%gA50] A(%i,0,%i)",                    \
          i,x,y,ant[i],xa,ya,i,ant[i])
        for n=0,n<12,n++ do
          SERV.Cmdimm(32,s)              // Dummy measurements
        enddo
        for n=0,n<ncpa,n++ do
          SYS.Killimm(n)
          if SERV.Cmdimm(n,s)<0 err=5
        enddo
        // Wait for answers. I restart timeout each time another measurement
        // comes back.
        t=Time()
        ndone=0
        while err==0 do
          if Time()-t>15000 err=3        // Timeout
          if Pressed(hexit) err=-1
          if Pressed(hcancel) err=1
          m=0
          for n=0,n<ncpa && err==0,n++ do
            if $A[n].length!=0 m++
          enddo
          if m==ncpa break
          if m>ndone then
            t=Time()
            ndone=m
          endif
          wait
        enddo
        if err!=0 break
        // Get measurements and check for correctness. First two measurements
        // are discarded for better reliability.
        bad=0
        for n=2,n<ncpa,n++ do
          if loganswers!=0 && hlog!=NULL then
            SERV.Decodeanswer($A[n],s,xtra,0xFFFFFFFF)
            fprintf(hlog,"  Head %2i: %s\n",i,s)
          endif
          if $A[n].answer!=S_MOVE || $A[n].subansw!=M_FASTC then
            err=6                        // Unexpected answer
          else if $A[n].status & 0x9820 then
            bad=bad|1
          else
            SERV.Convertfastc($A[n],&cc,&zz)
            r=Sqrt(cc*cc+zz*zz)
            if (boardtype==2 && (r<CHIXLMIN || r>CHIXLMAX)) ||                 \
              (boardtype==3 && (r<CHI24MIN || r>CHI24MAX)) ||                  \
              (boardtype<2 && (r<CHIGHMIN || r>CHIGHMAX))                      \
            then
              bad=bad|2
              badc=cc
              badz=zz
            else
              Addsigma(ccomp[freq][i],cc)
              Addsigma(zcomp[freq][i],zz)
            endif
          endif
        enddo
        if freq==3 then
          // Get mean capacity and phase so far.
          Initsigma(meanc[freq])
          Initsigma(meanph[freq])
          for j=0,j<nfing*2,j++ do
            if used[j]==0 continue     // Head is excluded from test
            if Getcount(ccomp[freq][j])<=0 continue
            Addsigma(meanph[freq],                                             \
              Atan2(Getmean(zcomp[freq][j]),Getmean(ccomp[freq][j])))
            Addsigma(meanc[freq],Getmean(ccomp[freq][j]))
          enddo
        endif
        // Report bad capacities, if any.
        if bad & 1 then
          sprintf(s,"%i%c: bad measurements",i/2,i & 1?'R':'L')
          if hlog!=NULL fprintf(hlog,"  %s\n",s)
        else if bad & 2 then
          sprintf(s,"%i%c: 电容值超出范围",i/2,i & 1?'R':'L')
          if hlog!=NULL fprintf(hlog,"  %s (C=%.1f, Z=%.1f pF)\n",s,badc,badz)
        else if Getsigma(ccomp[freq][i])>0.2||Getsigma(zcomp[freq][i])>0.2 then
          sprintf(s,"%i%c: capacity too unstable",i/2,i & 1?'R':'L')
          if hlog!=NULL fprintf(hlog,"  %s (dC=%.1f, dZ=%.1f pF\n",            \
          s,Getsigma(ccomp[freq][i]),Getsigma(zcomp[freq][i]))
        else
          s[0]='\0'
        endif
        if s[0]!='\0' then
          change hmessage color=LIGHTRED
          add hmessage text=s
        endif
      enddo
      // All heads are tested.
      if err==0 then
        for i=0,i<nfing*2,i++ do
          if used[i]==0 continue         // Head is excluded from test
          if Getcount(ccomp[freq][i])<ncpa/2 break
          if Getsigma(ccomp[freq][i])>0.2 || Getsigma(zcomp[freq][i])>0.2 break
        enddo
        if i<nfing*2 continue            // Some measurements are bad
        Initsigma(meanc[freq])
        Initsigma(meanz[freq])
        Initsigma(meanph[freq])
        if freq==3 Initsigma(meanfact)
        for i=0,i<nfing*2,i++ do
          if used[i]==0 continue         // Head is excluded from test
          Addsigma(meanc[freq],Getmean(ccomp[freq][i]))
          Addsigma(meanz[freq],Getmean(zcomp[freq][i]))
          Addsigma(meanph[freq],                                               \
            Atan2(Getmean(zcomp[freq][i]),Getmean(ccomp[freq][i])))
          if freq==3 Addsigma(meanfact,factor[i])
        enddo
        if freq>0 && (measfeatures & MF_CPHASE)!=0 then
          // Calculate frequency-dependent mean phase shifts.
          if $int2($EXTLAY+628+(freq-1)*2)<4000 ||                             \
            $int2($EXTLAY+628+(freq-1)*2)>25000                                \
          then
            oldphase=0.0
            oldampl=1.0
          else
            oldphase=$int2($EXTLAY+620+(freq-1)*2)/18000.0*3.1415926535898
            oldampl=$int2($EXTLAY+628+(freq-1)*2)/10000.0
          endif
          newphase=oldphase+Getmean(meanph[freq])-Getmean(meanph[0])
          newampl=oldampl*Sqrt(Getmean(meanc[0])*Getmean(meanc[0])+            \
            Getmean(meanz[0])*Getmean(meanz[0]))/                              \
            Sqrt(Getmean(meanc[freq])*Getmean(meanc[freq])+                    \
            Getmean(meanz[freq])*Getmean(meanz[freq]))
          $int2($EXTLAY+620+(freq-1)*2)=newphase/3.1415926535898*18000.0
          $int2($EXTLAY+628+(freq-1)*2)=newampl*10000.0
          layoutdiffers=1
        endif
        if freq==3 then
          // Calculate individual head phase corrections.
          dmax=0.0
          for i=0,i<nfing*2 && err==0,i++ do
            if used[i]==0 continue     // Head is excluded from test
            d=Atan2(Getmean(zcomp[freq][i]),Getmean(ccomp[freq][i]))-          \
              Getmean(meanph[freq])
            dmax=Max(dmax,Abs(d))
            oldfactor=factor[i]
            factor[i]=factor[i]-Getmean(meanfact)-d
            $int2($EXTLAY+516+i*2)=Max(-5000.0,Min(factor[i]*10000.0,5000.0))
            layoutdiffers=1
            if hlog!=NULL then
              fprintf(hlog,                                                    \
              "  Head %i%c:  old Z factor %8.5f, new factor %8.5f\n",          \
              i/2,i & 1?'R':'L',oldfactor,factor[i])
            endif
          enddo
        endif
        // Send layout to the tester.
        if err==0 then
          i=Sendextention()
          if i!=0 err=2                // Unable to send layout extention
        endif
        // Check whether adjustment for given frequency is finished.
        if freq==0 then
          break
        else if freq<3 && nloop>=2 then
          break
        else if freq==3 && nloop>=2 &&                                         \
          dmax<(nloop<=3?CPHASE:(nloop<=6?CPHASE*3:CPHASE*10))                 \
        then
          change hmessage color=BLACK
          add hmessage text="All done."
          break
        endif
      endif
    enddo
  enddo
  // Update display once again.
  draw window=hgraph
  for j=0,j<nfing*2,j++ do
    if used[j]==0 continue             // Head is excluded from test
    xs=(j & 1)==0?12:LEFTX/2+7
    ys=90+(j/2)*dy
    if $LAY.side[j/2]!=0 ys=ys+7
    draw color=WHITE bkcolor=WHITE
    draw at xs+20,ys-dy*3/4 fillrect xs+130,ys-dy*3/4+dy
    draw color=BLACK mode=M_RIGHT font=SMALLFONT
    if Getcount(ccomp[3][j])>0 then
      draw at xs+85,ys-6 text=format("%.2f",Getmean(ccomp[3][j]))
      draw at xs+85,ys+5 text=format("%.5f",                                   \
        Atan2(Getmean(zcomp[3][j]),Getmean(ccomp[3][j]))-Getmean(meanph[3]))
      ;
    endif
    draw color=BLACK mode=M_LEFT font=TIMESFONT
    draw at xs+100,ys text=format("%i",factor[j]*10000.0)
    draw show
  enddo
  if err==0 delay 2000                 // Psychological delay
  // Check whether Z factors are sound.
  if err==0 then
    r=0.0; n=0
    for i=0,i<nfing*2,i++ do
      if used[i]==0 continue           // Head is excluded from test
      r=r+factor[i]; n++
    enddo
    if n>0 then
      r=r/n
    endif
    for i=0,i<nfing*2,i++ do
      if used[i]==0 continue           // Head is excluded from test
      if Abs(factor[i]-r)>0.050 break
    enddo
    if i<nfing*2 then
      // Z factors are too different. Probably on-heads of different types.
      if hlog!=NULL fprintf(hlog,"  Different on-head boards\n")
      clear hright
      change hinfo text="Different on-head boards"
      draw window=hright font=TIMESFONT wrap=RIGHTX-5
      draw at 6,30 color=LIGHTRED
      draw text="On-head boards have too different phase shifts. "
      draw color=BLACK text="Mixing on-head boards of different types is "
      draw text="a bad idea that may lead to lost shorts. Please "
      draw text="consult the table and check highlighted on-head boards."
      draw show
      htable=control CHILD
        window=hright
        position=15,105,RIGHTX-30,170
        limits=RIGHTX-60,n*20+38
        mode=M_VSCROLL
        help="相移为16 kHz"
        bkcolor=PINK
        size=4096
      endc
      ys=30
      draw window=htable font=INFOFONT color=DARKGRAY
      draw at 5,5 to 213,5
      draw at 5,5 to 5,32 at 29,26 text="手臂"
      draw at 85,5 to 85,32 at 100,26
      draw text="Phase shift, rad"
      draw at 213,5 to 213,33
      draw at 5,32 to 213,32
      draw font=FIXEDSYS
      for i=0,i<nfing*2,i++ do
        if used[i]==0 continue         // Head is excluded from test
        ys=ys+20
        draw color=DARKGRAY
        draw at 5,ys-18 to 5,ys+2 to 213,ys+2 to 213,ys-18
        draw at 85,ys-18 to 85,ys+2
        draw at 30,ys color=BLACK
        draw text=format("%2i%c",i/2,(i & 1?'R':'L'))
        draw at 102,ys
        if Abs(factor[i]-r)>0.075 then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw text=format("%7.4f",factor[i])
      enddo
      draw show
      setfocus htable
      hcont=control BUTTON
        window=hright
        position=RIGHTX/2-124,USERY+40,120,24
        name="接收的数据"
        help="按下接受可疑数据"
      endc
      hcancel=control BUTTON
        window=hright
        position=RIGHTX/2+5,USERY+40,120,24
        name="离散的数据"
        help="按下放弃相位校正"
      endc
      while 1 do
        if Pressed(hcont) then
          break
        else if Pressed(hcancel) then
          err=1; break
        else if Pressed(hexit) then
          err=-1; break
        endif
        wait
      enddo
    endif
  endif
  // Send layout extention to tester and, if everything was good, save layout
  // to disk.
  $EXTLAY.extcfg=extcfg
  $int4($EXTLAY+496)=measopt
  if err==0 then
    Makelayoutcopy()
    i=Loadlayoutmeas(1,1)
    if i==(-1) err=-1
    if i==0 then
      layoutdiffers=0
      Addcalibrationrecord("Capacity phases adjusted")
    endif
  else
    Restoreoldlayout()
    Sendextention()
    layoutdiffers=0
  endif
  // Restore default test frequencies and voltages.
  if err==0 || err==1 then
    SYS.Killimm(0)
    buf[0]=S_DEBUG
    buf[1]=0x0E                        // Set field and capacity parameters
    $float4(buf+2)=1.0e7               // Short-to-antenna threshold 10 M
    $int2(buf+6)=0                     // Default capacity frequency
    $int2(buf+8)=0                     // Default field frequency
    $int2(buf+10)=0                    // Default capacity voltage
    $int2(buf+12)=0                    // Default field voltage
    $int4(buf+14)=0                    // Reserved
    SYS.Sendimm(0,18,buf)
    t=Time()
    while $A[0].length==0 do
      if Time()-t>3000 then
        err=3; break                   // Timeout!
      endif
      wait
    enddo
    if err==0 && $A[0].answer!=S_DEBUG then
      err=6                            // Unsupported command?
    endif
  endif
  // Clean up.
  change hleft position=4,4,LEFTX,LEFTY
  destroy hgraph
  if err<0 then
    if hlog!=NULL fprintf(hlog,"  Script cancelled by operator\n")
    return -1                          // Operator cancelled script
  endif
  if err==0 || err==1 then             // Success or interrupted by operator
    if err==1 && hlog!=NULL fprintf(hlog,"  Interrupted by operator\n")
    Protocolcfactors("New corrections:")
    return 0
  endif
  clear hright
  change hinfo text="电容校正错误"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==2 then
    if hlog!=NULL fprintf(hlog,"  Command execution error\n")
    draw text="Command execution error!"
    draw at 6,60 color=BLACK
    draw text="Script was not able to set capacity calibration in the air. "
  else if err==3 then
    if hlog!=NULL fprintf(hlog,"  Timeout while executing command\n")
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==4 then
    if hlog!=NULL fprintf(hlog,"  Internal error detected\n")
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Script is unable to select heads that will work as antennas. "
  else if err==5 then
    if hlog!=NULL fprintf(hlog,"  Command execution error\n")
    draw text="Command execution error!"
    draw at 6,60 color=BLACK
    draw text="Tester or tester support routine rejected command sent by "
    draw text="this routine. "
  else if err==6 then
    if hlog!=NULL fprintf(hlog,"  Unexpected answer from crate\n")
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
    draw text="Probably embedded software does not support C phase adjust. "
  endif
  draw text="Adjustment interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="继续"
    help="按下继续"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Adjusts MSD measurements by aligning MSD with fast C.
function int Adjustcrt()
  int i,j,t,k,m,n,xs,ys,dy,nfing,extcfg,ant[32],modified,err
  int bad,lowmeascount,firstrun
  float x,y,xa,ya,xt,yt,deltax,deltay,zc,zr,badc,oldfactor,correct
  float astat[32][5],crtstat[32][5],factor[32],cphase[5],frphase[5]
  char s[512],buf[256]
  handle hcancel,hmessage,hcont
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || (measfeatures & MF_CRT)==0      \
    return 0                           // CRT measurements are not supported
  nfing=$LAY.nfing
  clear hright
  change hinfo limits=0,0
  change hinfo text="微短探测调整"
  change hleft position=-1000,*,*,*
  change hgraph position=5,5,*,*
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="正在微短探测模式下,对头部卡的输入\n进行调整."
  if MSDU>=48 then
    draw color=LIGHTRED text="小心!微短探测法"
    draw text=format("使用了%iV高\n压在头部卡和针头上!",MSDU)
  endif
  draw color=BLACK text="\n中断测试,按" font=MAINFONT text="取消"
  draw font=TIMESFONT text=".\n"
  draw show
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY+30,120,24
    name="取消"
    help="按下中断MSD电容调整"
  endc
  hgraph=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="MSD调整数据"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  hmessage=control LIST
    window=hright
    position=6,100,RIGHTX-12,160
    help="C相位调整数据"
    color=BLACK
    bkcolor=WHITE
    font=FIXEDSYS
    mode=M_VSCROLL
    size=8192
  endc
  if $LAY.nfing<=10 then
    dy=28
  else
    dy=23
  endif
  // Display set of rails.
  draw window=hgraph color=WHITE bkcolor=WHITE
  draw at 0,0 fillrect LEFTX,LEFTY
  draw color=BLACK mode=M_CENTERED font=MEDIUMFONT at LEFTX/2,30
  draw text="微短探测电容调整"
  draw font=SMALLFONT color=DARKGRAY
  for n=0,n<2,n++ do
    xs=(n==0?15:LEFTX/2+10)
    draw at xs,67 mode=M_LEFT text="Hd"
    draw mode=M_RIGHT
    draw at xs+75,67 text="MSD/FastC"
    draw at xs+127,67 text="N/Factor"
  enddo
  draw mode=M_RIGHT font=TIMESFONT color=DARKGRAY
  for m=0,m<nfing,m++ do
    ys=90+m*dy
    if $LAY.side[m]!=0 ys=ys+7
    for n=0,n<2,n++ do
      xs=(n==0?15:LEFTX/2+10)+15
      if n==0 then
        draw at xs,ys text=format("%iL",m)
      else
        draw at xs,ys text=format("%iR",m)
      endif
    enddo
  enddo
  draw show
  err=0
  // Set 2 kHz C frequency, necessary for the following quality measurements.
  if err==0 then
    SYS.Killimm(0)
    buf[0]=S_DEBUG
    buf[1]=0x0E                        // Set field and capacity parameters
    $float4(buf+2)=1.0e7               // Short-to-antenna threshold 10 M
    $int2(buf+6)=2000                  // Capacity frequency
    $int2(buf+8)=0                     // Default field frequency
    $int2(buf+10)=0                    // Default capacity voltage
    $int2(buf+12)=0                    // Default field voltage
    $int4(buf+14)=0                    // Reserved
    SYS.Sendimm(0,18,buf)
    t=Time()
    while $A[0].length==0 do
      if Time()-t>10000 then
        err=3; break                   // Timeout!
      endif
      wait
    enddo
  endif
  // Set MSD and capacity calibration in the air - the best way to get rid of
  // temperature instabilities, at the price of doubled test time.
  extcfg=$EXTLAY.extcfg
  if (extcfg & (EXT_CRTAIR|EXT_CAIR))!=(EXT_CRTAIR|EXT_CAIR) then
    change hmessage color=BLACK
    add hmessage text="启用空载校准..."
    $EXTLAY.extcfg=extcfg|EXT_CRTAIR|EXT_CAIR
    layoutdiffers=1
    i=Sendextention()
    if i!=0 err=2                      // Unable to set calibration in the air
  endif
  // Initialize statistics, get actual factors and find antennas for each head.
  modified=0
  for i=0,i<nfing*2 && err==0,i++ do
    ant[i]=-1
    if used[i]==0 continue             // Head is excluded from test
    // Reset statistics.
    Initsigma(astat[i])
    Initsigma(crtstat[i])
    // Get and verify factors.
    if $int2($EXTLAY+340+i*2)<(-250) then
      $int2($EXTLAY+340+i*2)=-250
      layoutdiffers=1
      modified=1
    else if $int2($EXTLAY+340+i*2)>250 then
      $int2($EXTLAY+340+i*2)=250
      layoutdiffers=1
      modified=1
    endif
    factor[i]=1.0+$int2($EXTLAY+340+i*2)/10000.0
    // Decide which head serves as antenna. As we have at least two full rails,
    // this is not a problem. To reduce direct capacity, I always take right
    // head. First I look for the head on the opposite side, then for the first
    // from the same side.
    m=-1
    for j=0,j<nfing,j++ do
      if $LAY.side[i/2]==$LAY.side[j] continue
      if used[j*2+1]==0 continue
      m=j*2+1; break                   // Antenna on the opposite side found
    enddo
    if m<0 then
      for j=0,j<nfing,j++ do
        if $LAY.side[i/2]!=$LAY.side[j] continue
        if i/2==j continue
        if used[j*2+1]==0 continue
        m=j*2+1; break                 // Antenna on the same side found
      enddo
    endif
    if m<0 err=4                       // Unable to select antenna
    ant[i]=m
  enddo
  if modified Sendextention()
  if hlog!=NULL fprintf(hlog,"\nAdjusting MSD capacities...\n")
  // Measure phase shift on soldered capacitors, used to estimate electrical
  // quality of the board's material. Some boards feature high internal
  // losses, thus shifting the calibration results. These losses manifest
  // themselves as an additional phase shift on AC measurements. Per-head
  // corrections are not necessary.
  change hmessage color=BLACK
  add hmessage text="检查校验板质量..."
  Initsigma(cphase)
  k=0
  while k<256 && err==0 do
    for i=0,i<nfing*2 && err==0,i=i+2 do
      if used[i]==0 || used[i+1]==0 continue
      // Prepare command. I move heads that do not participate in measurement
      // to safe coordinates.
      if Convertpad(&xa,&ya,"SIG",i,DELTA)<0.0 err=5
      if Convertpad(&x,&y,"C",i+1,DELTA)<0.0 err=5
      n=sprintf(s,"M %i[%g,%gA5] %i[%g,%gA5] ",i+1,x,y,i,xa,ya)
      for j=0,j<nfing*2,j=j+2 do
        if j==i || used[j]==0 || used[j+1]==0 continue
        if Convertpad(&xa,&ya,"SIG",j,0)<0.0 err=5
        if Convertpad(&x,&y,"C",j+1,0)<0.0 err=5
        if ya<$LAY.yoffset[j/2]/1000.0 then
          ya=ya+5.0; y=y+5.0
        else
          ya=ya-5.0; y=y-5.0
        endif
        n=n+sprintf(s+n,"%i(%g,%g) %i(%g,%g) " ,j+1,x,y,j,xa,ya)
      enddo
      // Send measurements (2 per rail).
      sprintf(s+n,"A(%i,0,%i)",i,i+1)
      SERV.Cmdimm(i,s)
      sprintf(s+n,"A(%i,0,%i)",i+1,i)
      SERV.Cmdimm(i+1,s)
      k=k+2
      // Wait for answers.
      t=Time()
      while err==0 do
        if Time()-t>15000 err=3        // Timeout
        if Pressed(hexit) err=-1
        if Pressed(hcancel) err=1
        if $A[i].length!=0 && $A[i+1].length!=0 break
        wait
      enddo
      // Move heads into the safe positions. Answer is not important.
      n=sprintf(s,"M ")
      for j=0,j<nfing*2,j=j+2 do
        if used[j]==0 || used[j+1]==0 continue
        if Convertpad(&xa,&ya,"SIG",j,0)<0.0 err=5
        if Convertpad(&x,&y,"C",j+1,0)<0.0 err=5
        if ya<$LAY.yoffset[j/2]/1000.0 then
          ya=ya+5.0; y=y+5.0
        else
          ya=ya-5.0; y=y-5.0
        endif
        n=n+sprintf(s+n,"%i(%g,%g) %i(%g,%g) " ,j+1,x,y,j,xa,ya)
      enddo
      sprintf(s+n,"NOP")
      SERV.Cmdimm(32,s)
      // Verify and process answers.
      if $A[i].answer!=S_MOVE || $A[i].subansw!=M_FASTC continue
      if $A[i].status & 0x9820 continue
      SERV.Convertfastc($A[i],&zc,&zr)
      if zc<CCMIN || zc>CCMAX continue // Invalid capacity
      Addsigma(cphase,zr/zc)
    enddo
    if Getcount(cphase)>=30 break
  enddo
  // Main big loop, repeated at least twice.
  Initsigma(frphase)
  firstrun=1
  while err==0 do
    // Reinitialize MSD measurements.
    SYS.Killimm(0)
    sprintf(s,"CRTINIT %i",MSDU)
    SERV.Cmdimm(0,s)
    t=Time()
    while $A[0].length==0 && err==0 do
      if Pressed(hexit) err=-1
      if Pressed(hcancel) err=1
      if Time()-t>10000 err=3          // Timeout
      wait
    enddo
    if err==0 && $A[0].answer!=S_CRTINIT then
      err=6                            // Unexpected answer
    endif
    // Test loop.
    deltax=Random(DELTA)-DELTA/2.0
    deltay=Random(DELTA)-DELTA/2.0
    lowmeascount=0
    for i=0,i<nfing*2 && err==0,i++ do
      if used[i]==0 continue           // Head is excluded from test
      // If head has made at least 30 measurements, skip it from the test.
      n=Min(Getcount(astat[i]),Getcount(crtstat[i]))
      if n>=30 continue
      lowmeascount=1
      // Calculate coordinates and move heads that do not participate in
      // measurements into the requested positions.
      for j=0,j<nfing*2,j++ do
        if used[j]==0 continue
        if j==i then                   // Head under test
          if Convertpad(&x,&y,"SIG",j,0.0)<0.0 err=5
        else if j==ant[i] then         // Antenna finger
          if Convertpad(&xa,&ya,"GND",j,0.0)<0.0 err=5
        else if (j & 1)==0 then        // Any remaining left head
          if Convertpad(&xt,&yt,"NOCT1",j,0.0)<0.0 err=5
          xt=xt-30.0                   // Minimize distortions
          yt=$LAY.yoffset[j/2]/1000.0
          sprintf(s,"M %i[%g,%gH50] NOP",j,xt,yt)
          if SERV.Cmdimm(j,s)<0 err=5
        else                           // Any remaining right head
          if Convertpad(&xt,&yt,"NOCT2",j,0.0)<0.0 err=5
          xt=xt+30.0                   // Minimize distortions
          yt=$LAY.yoffset[j/2]/1000.0
          sprintf(s,"M %i[%g,%gH50] NOP",j,xt,yt)
          if SERV.Cmdimm(j,s)<0 err=5
        endif
      enddo
      // Attention, finger overlapping in Y may cause Bad coordinates on A5/A6
      // during single-side adjustment if board is rotated by more than 2*DELTA!
      if i<ant[i] && y>=ya then
        y=y-DELTA; ya=ya+DELTA
      else if i>ant[i] && y<=ya then
        y=y+DELTA; ya=ya-DELTA
      endif
      // Wait till free heads have reached requested positions.
      t=Time()
      for j=0,j<nfing*2 && err==0,j++ do
        if used[j]==0 continue
        if j==i || j==ant[i] continue
        while err==0 do
          if Time()-t>15000 err=3      // Timeout
          if Pressed(hexit) err=-1
          if Pressed(hcancel) err=1
          if $A[j].length!=0 break
          wait
        enddo
      enddo
      if err!=0 break
      // If this is the first run, make 16 dummy measurements to learn the
      // Z coordinate. This helps to stabilize the corrections in the air.
      if firstrun then
        sprintf(s,"M %i[%g:%d,%g:%g] %i[%g,%g] A(%i,0,%i)",                    \
          i,x,deltax,y,deltay,ant[i],xa,ya,i,ant[i])
        for n=0,n<16,n++ do
          SYS.Killimm(n)
          if SERV.Cmdimm(n,s)<0 err=5
        enddo
        t=Time()
        while err==0 do
          if Time()-t>10000 err=3      // Timeout
          if Pressed(hexit) err=-1
          if Pressed(hcancel) err=1
          for n=0,n<16 && err==0,n++ do
            if $A[n].length==0 break
          enddo
          if n>=16 break
          wait
        enddo
      endif
      // Make 16 fast C and 16 MSD measurements at once.
      sprintf(s,"M %i[%g:%d,%g:%g] %i[%g,%g] A(%i,0,%i)",                      \
        i,x,deltax,y,deltay,ant[i],xa,ya,i,ant[i])
      for n=0,n<16,n++ do              // 16 fast C measurements
        SYS.Killimm(n)
        if SERV.Cmdimm(n,s)<0 err=5
      enddo
      sprintf(s,"M %i[%g:%d,%g:%g] %i[%g,%g] CRT(%i,%i)",                      \
        i,x,deltax,y,deltay,ant[i],xa,ya,i,ant[i])
      for n=16,n<32,n++ do             // 16 MSD measurements
        SYS.Killimm(n)
        if SERV.Cmdimm(n,s)<0 err=5
      enddo
      // Wait for all answers.
      t=Time()
      while err==0 do
        if Time()-t>10000 err=3        // Timeout
        if Pressed(hexit) err=-1
        if Pressed(hcancel) err=1
        for n=0,n<32 && err==0,n++ do
          if $A[n].length==0 break
        enddo
        if n>=32 break
        wait
      enddo
      if err!=0 break
      // Get measurements and check for correctness. First measurement in each
      // sequence is discarded for better reliability.
      bad=0
      for n=1,n<16,n++ do
        // Fast C measurements.
        if $A[n].answer!=S_MOVE || $A[n].subansw!=M_FASTC then
          err=6                        // Unexpected answer
        else if $A[n].status & 0x9820 then
          bad=bad|1
        else
          SERV.Convertfastc($A[n],&zc,&zr)
          zc=Sqrt(zc*zc+zr*zr)         // Rotate phase, as in Test Player
          if (boardtype==2 && (zc<CHIXLMIN || zc>CHIXLMAX)) ||                 \
            (boardtype==3 && (zc<CHI24MIN || zc>CHI24MAX)) ||                  \
            (boardtype<2 && (zc<CHIGHMIN || zc>CHIGHMAX))                      \
          then
            badc=zc
            bad=bad|2
          else
            Addsigma(astat[i],zc)
            Addsigma(frphase,zr/zc)
          endif
        endif
      enddo
      for n=17,n<32,n++ do
        // MSD measurements.
        if $A[n].answer!=S_MOVE || $A[n].subansw!=M_CRT then
          err=6                        // Unexpected answer
        else if $A[n].status & 0x8834 then
          bad=bad|1
        else if $char($A[n]+8)!=1 then
          bad=bad|4                    // Only range 1 is calibrated
        else
          zc=$float4($A[n]+9)
          if (boardtype==2 && (zc<CHIXLMIN || zc>CHIXLMAX)) ||                 \
            (boardtype==3 && (zc<CHI24MIN || zc>CHI24MAX)) ||                  \
            (boardtype<2 && (zc<CHIGHMIN || zc>CHIGHMAX))                      \
          then
            badc=zc
            bad=bad|2
          else
            Addsigma(crtstat[i],zc)
          endif
        endif
      enddo
      if bad==0 then
        s[0]='\0'
      else if bad & 1 then
        sprintf(s,"%i%c: bad measurements",i/2,i & 1?'R':'L')
        if hlog!=NULL fprintf(hlog,"  %s\n",s)
      else if bad & 2 then
        sprintf(s,"%i%c: capacity out of range",i/2,i & 1?'R':'L')
        if hlog!=NULL fprintf(hlog,"  %s (%.1f pF)\n",s,badc)
      else
        sprintf(s,"%i%c: bad MSD range",i/2,i & 1?'R':'L')
        if hlog!=NULL fprintf(hlog,"  %s\n",s)
      endif
      if s[0]!='\0' then
        change hmessage color=LIGHTRED
        add hmessage text=s
      endif
      // Update display.
      draw window=hgraph mode=M_RIGHT font=SMALLFONT
      for j=0,j<nfing*2,j++ do
        if used[j]==0 continue         // Head is excluded from test
        xs=(j & 1)==0?15:LEFTX/2+10
        ys=90+(j/2)*dy
        if $LAY.side[j/2]!=0 ys=ys+7
        draw color=(j==i?BLACK:WHITE) bkcolor=WHITE
        draw at xs+20,ys-dy*3/4 fillrect xs+130,ys-dy*3/4+dy
        draw color=BLACK
        if Getcount(astat[j])>0 then     // Mean fast capacity
          draw at xs+75,ys-6 text=format("%.3f",Getmean(astat[j]))
        endif
        if Getcount(crtstat[j])>0 then   // Mean MSD capacity
          draw at xs+75,ys+5 text=format("%.3f",Getmean(crtstat[j]))
        endif
        n=Min(Getcount(astat[j]),Getcount(crtstat[j]))
        if n>0 then                      // Number of measurements
          draw at xs+127,ys-6 text=format("%i",n)
        endif
        if n>0 then
          draw at xs+127,ys+5 color=LIGHTBLUE
          draw text=format("%.3f",                                             \
          factor[j]*Getmean(astat[j])/Getmean(crtstat[j]))
        endif
      enddo
      draw show
    enddo
    firstrun=0
    // If there are at least 30 good measurements per head, update layout and
    // finish test.
    if lowmeascount==0 break
  enddo
  // Update layout or, if adjustment was unsuccessfull, restore original one.
  if err==0 || (extcfg & (EXT_CRTAIR|EXT_CAIR))!=(EXT_CRTAIR|EXT_CAIR) then
    $EXTLAY.extcfg=extcfg
    if err==0 then
      if hlog!=NULL then
        if Getcount(cphase)>=30 then
          fprintf(hlog,"  Mean phase shift on C:   %8.5f rad\n",Getmean(cphase))
        else
          fprintf(hlog,"  Mean phase shift on C:   Unable to measure\n")
        endif
        fprintf(hlog,"  Mean phase shift on FR4: %8.5f rad\n",Getmean(frphase))
      endif
      // Totally empirical correction factor.
      correct=(Getmean(frphase)-Getmean(cphase))*0.75-0.0020
      for i=0,i<nfing*2,i++ do
        if used[i]==0 continue         // Head is excluded from test
        oldfactor=factor[i]
        factor[i]=factor[i]*Getmean(astat[i])/Getmean(crtstat[i])+correct
        $int2($EXTLAY+340+i*2)=(factor[i]-1.0)*10000.0
        if hlog!=NULL then
          fprintf(hlog,"  Head %i%c:  old CRT factor %8.5f, new %8.5f\n",      \
          i/2,i & 1?'R':'L',oldfactor,factor[i])
        endif
      enddo
      Makelayoutcopy()
      i=Loadlayoutmeas(1,1)
      if i==(-1) err=-1
      if i==0 then
        layoutdiffers=0
        Addcalibrationrecord("MSD measurements adjusted")
      endif
    else
      Restoreoldlayout()
      Sendextention()
      layoutdiffers=0
    endif
  endif
  // Clean up.
  change hleft position=4,4,LEFTX,LEFTY
  destroy hgraph
  if err<0 then
    if hlog!=NULL fprintf(hlog,"  Script cancelled by operator\n")
    return -1                          // Operator cancelled script
  endif
  if err==0 || err==1 then             // Success or interrupted by operator
    if err==1 && hlog!=NULL fprintf(hlog,"  Interrupted by operator\n")
    return 0
  endif
  clear hright
  change hinfo text="MSD adjustment error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==2 then
    if hlog!=NULL fprintf(hlog,"  Command execution error\n")
    draw text="Command execution error!"
    draw at 6,60 color=BLACK
    draw text="Script was not able to set MSD calibration in the air. "
  else if err==3 then
    if hlog!=NULL fprintf(hlog,"  Timeout while executing command\n")
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==4 then
    if hlog!=NULL fprintf(hlog,"  Internal error detected\n")
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Script is unable to select heads that will work as antennas. "
  else if err==5 then
    if hlog!=NULL fprintf(hlog,"  Command execution error\n")
    draw text="Command execution error!"
    draw at 6,60 color=BLACK
    draw text="Tester or tester support routine rejected command sent by "
    draw text="this routine. "
  else if err==6 then
    if hlog!=NULL fprintf(hlog,"  Unexpected answer from crate\n")
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
    draw text="Probably embedded software does not support MSD. "
  endif
  draw text="Adjustment interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="继续"
    help="按下继续"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Service function, given base (first head in the group) and index of head in
// the group (0..7, some may be excluded), calculates head h, antenna a, ground
// (which is always a+1, currently not contacted) and coordinates ([0] for
// head, [1] for antenna and [2] for ground). If move is 1, moves heads from
// the group that don't participate in the measurement into positions (cmdbuff
// 8). Returns 0 on success, 1 if head with given index is excluded or
// unavailable and -1 if routine can't select head or antenna.
function int Fieldxy(int base,int index,int *h,int *a,                         \
  float x[],float y[],int move)
  int i,n,nfing,head,ant,err
  float hx,hy
  char s[1024]
  nfing=$LAY.nfing
  if index<4 then
    head=base+index                    // Top (or, in general, first) side
  else if testersides!=0x3 then
    return 1                           // Single-sided tester
  else
    head=base+nfing+(index-4)          // Opposite side
  endif
  if used[head]==0 return 1            // Head is excluded from test
  // Decide which heads serve this time as antennas. There is a problem with
  // A3/A5/A7, single-sided and handicapped testers: we can't select static
  // antenna for a loop. The algorithm: take rail preceding base (top or bottom
  // side); take rail that follows group (top or bottom side); take rail in the
  // group on the opposite side; take rail in the group on the same side.
  if base>firstrail*2 && used[firstrail*2]!=0 then
    ant=firstrail*2                    // Top rail that precedes group
  else if base>firstrail*2 && testersides==0x3 &&                              \
    used[firstrail*2+nfing]!=0 then
    ant=firstrail*2+nfing              // Bottom rail that precedes group
  else if base+4<=lastrail*2 && used[lastrail*2]!=0 then
    ant=lastrail*2                     // Top rail that follows group
  else if base+4<=lastrail*2 && testersides==0x3 &&                            \
    used[lastrail*2+nfing]!=0 then
    ant=lastrail*2+nfing               // Bottom rail that follows group
  else if testersides==0x3 && head<nfing && used[base+nfing]!=0 then
    ant=base+nfing                     // In group on the opposite (bot) side
  else if testersides==0x3 && head>=nfing && used[base]!=0 then
    ant=base                           // In group on the opposite (top) side
  else if head<2 && used[base+2]!=0 then
    ant=base+2                         // In group on the same side
  else if head>=2 && used[base]!=0 then
    ant=base                           // In group on the same side
  else
    return -1                          // Alarm, unable to select antenna
  endif
  // Report heads.
  h[0]=head
  a[0]=ant
  // Calculate coordinates.
  if move n=sprintf(s,"M ")
  err=0
  for i=0,i<nfing*2 && err==0,i++ do
    if used[i]==0 then                 // Excluded from the test
      ;
    else if i==head then               // Head under test
      if Convertpad(x+0,y+0,"C",base,0.0)<0.0 err=1
    else if i==ant then                // Antenna finger
      if Convertpad(x+1,y+1,"SIG",i,0.0)<0.0 err=1
      // Attention, may cause Bad coordinates during single-side adjustment
      // if board is rotated by more than 2*DELTA!
      if (i>=base && i<base+2) ||                                              \
        (testersides==0x3 && i>=base+nfing && i<base+nfing+2) then
        y[1]=y[1]-2*DELTA
      else
        y[1]=y[1]+2*DELTA
      endif
    else if i==ant+1 then              // Ground finger
      if Convertpad(x+2,y+2,"GND",i,0.0)<0.0 err=1
      // Attention, may cause Bad coordinates during single-side adjustment
      // if board is rotated by more than 2*DELTA!
      if (i>=base && i<base+2) ||                                              \
        (testersides==0x3 && i>=base+nfing && i<base+nfing+2) then
        y[2]=y[2]-2*DELTA
      else
        y[2]=y[2]+2*DELTA
      endif
    else if move==0 then
      // Movement is not requested.
    else if ((usesides & 0x1)!=0 && (i>=base && i<base+4)) ||                  \
      ((usesides & 0x2)!=0 && (i>=base+nfing && i<base+nfing+4)) then
      // Head is free but belongs to the group being tested.
      if Convertpad(&hx,&hy,"C",base,0.0)<0.0 err=1
      if (i & 1)==0 then
        hx=hx-10.0
      else
        hx=hx+10.0
      endif
      if (i>=base && i<base+2) ||                                              \
        (testersides==0x3 && i>=base+nfing && i<base+nfing+2) then
        hy=hy-10.0
      else
        hy=hy+10.0
      endif
      n=n+sprintf(s+n,"%i[%g,%gH50] ",i,hx,hy)
    else if (i & 1)==0 then            // Any remaining left head
      if Convertpad(&hx,&hy,"NOCT1",i,0.0)<0.0 err=1
      hy=$LAY.yoffset[i/2]/1000.0
      n=n+sprintf(s+n,"%i[%g,%gH50] ",i,hx,hy)
    else                               // Any remaining right head
      if Convertpad(&hx,&hy,"NOCT2",i,0.0)<0.0 err=1
      hy=$LAY.yoffset[i/2]/1000.0
      n=n+sprintf(s+n,"%i[%g,%gH50] ",i,hx,hy)
    endif
  enddo
  // Send command for non-participating heads. Note that there is always at
  // least one free head.
  if err==0 && move!=0 then
    SYS.Killimm(8)
    sprintf(s+n,"NOP")
    if SERV.Cmdimm(8,s)<0 err=1
  endif
  // Report success (or not).
  return err
end

// Service function, displays results of preliminary test for limits of Dallas
// potentiometers.
function int Drawpredallas(int *limvalid,float *lims,float *limc,int showpot)
  int m,n,head,xs,ys,dy
  float smin,smax,cmin,cmax
  draw window=hgraph bkcolor=WHITE
  clear hgraph
  draw color=BLACK mode=M_CENTERED font=MEDIUMFONT at LEFTX/2,30
  draw text="电场调整极限"
  draw font=SMALLFONT color=DARKGRAY
  for n=0,n<2,n++ do
    xs=(n==0?12:LEFTX/2+7)
    draw at xs,67 mode=M_LEFT text="头"
    if allowz then
      draw at xs+25,67 text="正弦/余弦"
    else
      draw at xs+25,67 text="Limits"
    endif
    draw at xs+110,67 text="Pot"
  enddo
  if $LAY.nfing<=10 then
    dy=28
  else
    dy=23
  endif
  for m=0,m<$LAY.nfing,m++ do
    ys=90+m*dy
    if $LAY.side[m]!=0 ys=ys+7
    for n=0,n<2,n++ do
      draw mode=M_LEFT font=TIMESFONT color=DARKGRAY
      xs=(n==0?12:LEFTX/2+7)
      if n==0 then
        draw at xs,ys+1 text=format("%iL",m)
      else
        draw at xs,ys+1 text=format("%iR",m)
      endif
      head=m*2+n
      smin=(lims[4*head+0]+lims[4*head+2])/2.0
      smax=(lims[4*head+1]+lims[4*head+3])/2.0
      cmin=(limc[4*head+0]+limc[4*head+1])/2.0
      cmax=(limc[4*head+2]+limc[4*head+3])/2.0
      if limvalid[head] then
        draw font=SMALLFONT
        if showpot then
          draw color=(limvalid[head]>0?BLACK:LIGHTRED)
        else
          draw color=(smax-smin>smax*SADJMIN?BLACK:LIGHTRED)
        endif
        draw at xs+25,ys-(allowz?5:0)
        draw text=format("%i .. %i",smin,smax)
        if allowz then
          if showpot then
            draw color=(limvalid[head]>0?BLACK:LIGHTRED)
          else                         // Note that CADJMIN is in units of smax!
            draw color=(cmax-cmin>smax*CADJMIN?BLACK:LIGHTRED)
          endif
          draw at xs+25,ys+5
          draw text=format("%i .. %i",cmin,cmax)
        endif
        if showpot then
          draw color=(limvalid[head]>0?BLACK:LIGHTRED)
          draw at xs+110,ys-(allowz?5:0)
          draw text=format("%i",ps[head])
          if allowz then
            draw color=(limvalid[head]>0?BLACK:LIGHTRED)
            draw at xs+110,ys+5
            draw text=format("%i",pc[head])
          endif
        endif
      endif
    enddo
  enddo
  draw show
end

// Service routine, draws field differences or statistical data depending on
// stat. auto=2 assumes verification. Changes are not flushed to the screen.
// Don't forget to select window for drawing before call!
function int Drawdata(int head,int clr,int base,int auto,int allowz)
  int i,j,q,ystep,dx,yt,nrail,delta,ndispl
  float c
  if clr then
    draw color=WHITE bkcolor=WHITE
    draw at 0,0 fillrect LEFTX,225
  endif
  nrail=$LAY.nfing
  draw color=BLACK mode=M_CENTERED font=MEDIUMFONT at LEFTX/2,30
  draw text="电场差异"
  draw mode=M_LEFT font=SMALLFONT color=DARKGRAY
  dx=LEFTX/2+11
  for j=0,j<2,j++ do
    draw at 4+dx*j,63 text="头"
    draw mode=M_RIGHT
    draw at 62+dx*j,63 text="正弦"
    draw at 105+dx*j,63 text="余弦"
    draw mode=M_LEFT
    if auto==1 then
      draw at 119+dx*j,63 text="Pot"
    else
      draw at 119+dx*j,63 text="C, pF"
    endif
  enddo
  ndispl=0
  ystep=(allowz?27:22)
  for i=0,i<8,i++ do
    draw font=TIMESFONT
    if i<4 then
      q=base+i                         // Top (or, in general, first) side
      delta=0
    else if testersides!=0x3 then
      continue                         // Single-sided tester
    else
      q=base+nrail+(i-4)               // Opposite side
      delta=20
    endif
    if used[q]==0 continue             // Head is excluded from test
    yt=90+ystep*(ndispl/2)+delta
    j=i & 1
    if i==head then
      draw color=BLACK bkcolor=BLACK at 2+dx*j,yt-16
      draw fillrect 22+dx*j,yt+1
      draw color=WHITE
    else
      draw color=WHITE bkcolor=WHITE at 2+dx*j,yt-16
      draw fillrect 22+dx*j,yt+1
      draw color=DARKGRAY
    endif
    draw at 4+dx*j,yt text=format("%i%c",q/2,(i& 1?'R':'L'))
    if fvalid[i]!=0 then
      if maxsin==i then
        draw color=BLACK bkcolor=(fvalid[i]<0?PINK:WHITE)
      else if fvalid[i]<0 then
        draw color=PINK bkcolor=PINK
      else
        draw color=WHITE bkcolor=WHITE
      endif
      draw mode=M_RIGHT
      draw at 24+dx*j,yt-16 fillrect 115+dx*j,yt+1
      if gs[i]-ss<(-DADJLIMIT*0.7) then
        draw color=LIGHTBLUE
      else if gs[i]-ss>DADJLIMIT*0.7 then
        draw color=LIGHTRED
      else
        draw color=BLACK
      endif
      draw at 62+dx*j,yt text=format("%.1f",gs[i]-ss)
      if gc[i]-cs<(-DADJLIMIT*0.7) then
        draw color=LIGHTBLUE
      else if gc[i]-cs>DADJLIMIT*0.7 then
        draw color=LIGHTRED
      else
        draw color=BLACK
      endif
      draw at 105+dx*j,yt text=format("%.1f",gc[i]-cs)
      draw mode=M_LEFT
      if auto==1 then
        draw color=(fixed[q]?DARKGRAY:BLACK)
        if allowz==0 then
          draw at 117+dx*j,yt text=format("%.0f",ps[q])
        else
          draw font=SMALLFONT
          draw at 119+dx*j,yt-7 text=format("%.0f",ps[q])
          draw at 119+dx*j,yt+5 text=format("%.0f",pc[q])
        endif
      else
        c=cc[i]
        if c<CMIN || c>CMAX then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 119+dx*j,yt
        if c<0.0 then
          draw text="< 0.0"
        else if c>99.0 then
          draw text="> 99"
        else
          draw text=format("%.1f",c)
        endif
      endif
    endif
    ndispl++
  enddo
end

// Adjusts (verify=0), verifies manually (verify=1) or auto verifies (verify=2)
// input capacity of on-head boards both in manual and automatical modes. This
// code supports both single- and double-sided testers with at least 2 full
// rails.
function int Adjustfield(int verify)
  int i,j,k,m,n,t,ampl,phase,auto,nrail,head,ant,ant1,loop,err
  int base,nextbase[NBASE],nbase,limvalid[NBASE][32],ly,xs,ys,dy
  int result,valid,finished,ngood,badhead,worsthead,shortok[32]
  float x[3],y[3],xm,ym,xa,ya,xt,yt,xu,yu,deltax,deltay
  float antdx,antdy,maxbad,worstbad,sum0,sumk,factor
  float r,zc,zr,a,b,c,d,det,diffs[32][5],diffc[32][5]
  float sdata[5],cdata[5],lims[NBASE][32][4],limc[NBASE][32][4]
  float lsin,rsin,lcos,rcos,smin,smax,cmin,cmax,smean,cmean
  float fs[32],fc[32],fcap[32],fsshort[32][5],fcshort[32][5],uin,dfi
  float psmin,psmax,pcmin,pcmax,ds,dc
  char s[1024],htext[16]
  handle hmessage,hcont,hpause,hnext,haccept,hcancel
  if ($LAY.config & LC_OHTYPE)==LC_NOFIELD                                     \
    return 0                           // Field measurements not supported
  worsthead=-1
  nrail=$LAY.nfing
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) then
    auto=1                             // Always automatic adjustment
  else if ($LAY.config & LC_OHTYPE)==LC_ACTIVE ||                              \
    ($LAY.config & LC_OHTYPE)==LC_PHADJ then
    if verify==2 return 0              // Auto verification is not necessary
    auto=1                             // Automatic adjustment
  else
    if verify==2 return 0              // Auto verification is not necessary
    auto=0                             // Manual adjustment
  endif
  if verify>0 then
    auto=2                             // Verification
    if verify==2 then                  // Autoverification
      SYS.Softimm(32)
      t=Time(); i=0
      while $A[32].length==0 do
        if Pressed(hexit) return -1    // Button "Exit" works as an interrupt
        j=(Time()-t)/1000
        if i!=j then
          change hinfo text=format("等待软件复位 - %i s",j)
          i=j
        endif
        if j>15 break                  // Too long soft reset
        wait
      enddo
    endif
  endif
  stopatlimit=0
  worstbad=0.0
  if $LAY.nfing<=10 then
    dy=28
  else
    dy=23
  endif
  // If Crate supports extended field phase corrections, disable them during
  // the first two adjustment phases. Note that if measurement card software
  // is old and does not support extended corrections, we may still gather them
  // for the future.
  if verify==0 && (measfeatures & MF_XFLDCRATE)!=0 then
    k=$uint2($EXT0+260)
    $uint2($EXT0+260)=0
    Sendextention()
    layoutdiffers=1
    $uint2($EXT0+260)=k                // Just for the case, keep old value
  endif
  // Replace left pane by a graph window. Attention, destroy it and restore
  // pane before leaving this routine!
  change hleft position=-1000,*,*,*
  hgraph=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="输入电容调整的结果"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  // Calculate number and sequence of bases used in this test.
  if auto!=2 && lastrail-firstrail>4 then
    nextbase[0]=(firstrail+2)*2
    nextbase[1]=(firstrail+1)*2
    nextbase[2]=firstrail*2
    nbase=3
    i=firstrail+3
  else if auto!=2 && lastrail-firstrail>2 then
    nextbase[0]=(firstrail+1)*2
    nextbase[1]=firstrail*2
    nbase=2
    i=firstrail+2
  else
    nextbase[0]=firstrail*2
    nbase=1
    i=firstrail+1
  endif
  while i<lastrail do
    nextbase[nbase]=i*2
    nbase++
    i++
  enddo
  // Step 1: check Dallas potentiometers and determine their preliminary
  // settings.
  err=0
  for head=0,head<32,head++ do
    ps[head]=256.0
    pc[head]=256.0
  enddo
  if auto==1 then
    change hinfo text="验证极限"
    change hinfo limits=0,0
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
    draw text="脚本会检查头部卡和调整极限并决定"
    draw text="是否最佳调整可行。"
    draw show
    if hlog!=NULL then
      fprintf(hlog,"\nVerifying adjustment limits of on-head boards...\n")
    endif
    hmessage=control LIST
      window=hright
      position=6,100,RIGHTX-12,160
      help="检测到的错误"
      color=BLACK
      bkcolor=WHITE
      font=FIXEDSYS
      mode=M_VSCROLL
      size=8192
    endc
    hcancel=control BUTTON
      window=hright
      position=RIGHTX/2-60,USERY+30,120,24
      name="取消"
      help="按下中断电场调整"
    endc
    Memset(limvalid,0,Sizeof(limvalid))
    Memset(lims,0,Sizeof(lims))
    Memset(limc,0,Sizeof(limc))
    Drawpredallas(limvalid[0],lims[0],limc[0],0)
    // Walk all groups, one after another.
    for k=0,k<nbase && err==0,k++ do
      base=nextbase[k]
      // 10 attempts to make good measurements.
      for m=10,m>0 && err==0,m-- do
        antdx=Random(DELTA)-DELTA/2.0  // Shifts for antenna and ground
        antdy=Random(DELTA)-DELTA/2.0
        finished=1
        // Test all heads in the group.
        for i=0,i<8 && err==0,i++ do
          result=Fieldxy(base,i,&head,&ant,x,y,1)
          if result>0 continue         // Head unavailable
          if result<0 err=2            // Can't select antenna
          if limvalid[k][head] continue
          if testersides==0x1 && ($EXTLAY.extant & 1)!=0 then
            ant1=32
          else
            ant1=ant
          endif
          sprintf(htext,"%i%s",head/2,head & 1?"R":"L")
          // Prepare command.
          deltax=Random(DELTA)-DELTA/2.0
          deltay=Random(DELTA)-DELTA/2.0
          n=sprintf(s,"M %i[%g:%.3f,%g:%.3fV%gP%gH%g] ",                       \
            head,x[0],deltax,y[0],deltay,strokev,strokep,strokez)
          n=n+sprintf(s+n,"%i[%g:%.3f,%g:%.3fV%gP%gH%g] ",                     \
            ant,x[1],antdx,y[1],antdy,strokev,strokep,strokez)
          n=n+sprintf(s+n,"%i[%g:%.3f,%g:%.3fV%gP%gH%g] ",                     \
            ant+1,x[2],antdx,y[2],antdy,strokev,strokep,strokez)
          n=n+sprintf(s+n,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",                  \
            head,ant1,ant,ant,ant,ant,ant,ant,ant,ant)
          n=n+sprintf(s+n,"%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",  \
            ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant)
          sprintf(s+n,"%i,%i,%i,%i)",ant,ant,ant,ant) // Total of 28*ant
          // For all 4 corners of Dallas settings.
          for j=0,j<4 && err==0,j++ do
            // Set potentiometers. I set phase even if potentiometer is absent,
            // this improves statistics of the amplitude.
            if j==0 then
              ampl=0; phase=0
            else if j==1 then
              ampl=511; phase=0
            else if j==2 then
              ampl=0; phase=511
            else
              ampl=511; phase=511
            endif
            result=Setdallas(head,ampl,phase)
            if result<0 then           // Cancelled by user
              err=-1; break; endif
            if result>0 then           // Can't set Dallas potentiometers
              err=3; break; endif
            // Send command.
            if SERV.Cmdimm(0,s)<0 then
              err=4; break; endif      // Can't send command
            // Wait for answer.
            t=Time()
            while err==0 do
              if Time()-t>10000 err=1
              if Pressed(hexit) err=-1
              if Pressed(hcancel) err=10
              if $A[0].length!=0 break
              wait
            enddo
            if err!=0 break
            if $A[0].answer!=S_MOVE || $A[0].subcmd!=M_FIELD then
              err=5; break; endif      // Invalid answer
            if $A[0].status & 0x9820 then
              change hmessage color=LIGHTRED
              add hmessage text=format("%s: Bad measurement",htext)
              break
            endif
            SERV.Convertfield($A[0],&zc,&zr)
            if zc<CMIN || zc>CMAX then
              change hmessage color=LIGHTRED
              add hmessage text=format("%s: 无效电容",htext)
              break
            endif
            // Process field. I discard first 4 measurements as possibly
            // unstable and expect remaining measurements to be reproducible.
            Initsigma(sdata)
            Initsigma(cdata)
            for n=0,n<24,n++ do
              Addsigma(sdata,$int2($A[0]+48+4*n))
              Addsigma(cdata,$int2($A[0]+50+4*n))
            enddo
            if Getmin(sdata)<SINMIN || Getmax(sdata)>SINMAX ||                 \
              Getmin(cdata)<COSMIN || Getmax(cdata)>COSMAX then
              change hmessage color=LIGHTRED
              add hmessage text=format("%s: Invalid field",htext)
              break
            else if Getsigma(sdata)>FNOISE || Getsigma(cdata)>FNOISE then
              change hmessage color=LIGHTRED
              add hmessage text=format("%s: 电场干扰",htext)
              break
            endif
            lims[k][head][j]=Getxmean(sdata)
            limc[k][head][j]=Getxmean(cdata)
          enddo
          if j<4 || err!=0 then
            finished=0                 // Limits not measured
          else
            limvalid[k][head]=1
          endif
        enddo
        if finished break
      enddo
      if err==0 && finished==0 err=6
      // Limits of potentiometers are measured. Now recalculate them to the
      // common denominator with group 0 (sine only) and gather in limc[0]/
      // lims[0]/limvalid[0]. Bases are ordered in a way that they always
      // overlap with the previous.
      if err==0 && k>0 then
        sum0=0.0; sumk=0.0
        for head=0,head<32,head++ do
          if limvalid[0][head]==0 || limvalid[k][head]==0 continue
          for j=0,j<4,j++ do
            sum0=sum0+lims[0][head][j]
            sumk=sumk+lims[k][head][j]
          enddo
        enddo
        if sum0==0.0 || sumk==0.0 then
          err=7                        // No overlapping between the groups
        else
          factor=sum0/sumk
          for head=0,head<32,head++ do
            if limvalid[0][head]!=0 || limvalid[k][head]==0 continue
            for j=0,j<4,j++ do
              lims[0][head][j]=lims[k][head][j]*factor
              limc[0][head][j]=limc[k][head][j]*factor
            enddo
            limvalid[0][head]=1
          enddo
        endif
      endif
      // Draw new measured limits.
      Drawpredallas(limvalid[0],lims[0],limc[0],0)
    enddo
    // Check whether full alignment is possible. In fact, adjustment limits
    // in the sine-cosine space form parallelogramm with no side parallel to
    // axes, but to simplify my task I assume that limits are rectangular.
    if err==0 then
      // Get mean point.
      lsin=-1.0e10                     // Rightmost left sine limit
      rsin=1.0e10                      // Leftmost rigft sine limit
      lcos=-1.0e10                     // Rightmost left cosine limit
      rcos=1.0e10                      // Leftmost rigft cosine limit
      if hlog!=NULL fprintf(hlog,"  Measured adjustment limits:\n")
      for head=0,head<32,head++ do
        if limvalid[0][head]==0 continue
        smin=(lims[0,head,0]+lims[0,head,2])/2.0
        smax=(lims[0,head,1]+lims[0,head,3])/2.0
        cmin=(limc[0,head,0]+limc[0,head,1])/2.0
        cmax=(limc[0,head,2]+limc[0,head,3])/2.0
        if hlog!=NULL then
          fprintf(hlog,"  Head %i%c:  sine %5i .. %5i",                        \
            head/2,head & 1?'R':'L',smin,smax)
          if allowz fprintf(hlog,", cosine %5i .. %5i bits",                   \
            cmin,cmax)
          if smax-smin<smax*SADJMIN || (allowz && cmax-cmin<smax*CADJMIN)      \
            fprintf(hlog," (too narrow!)")
          fprintf(hlog,"\n")
        endif
        lsin=Max(lsin,smin)
        rsin=Min(rsin,smax)
        lcos=Max(lcos,cmin)
        rcos=Min(rcos,cmax)
      enddo
      smean=(lsin+rsin)/2.0
      cmean=(lcos+rcos)/2.0
      // Calculate preliminary Dallas settings.
      valid=1
      psmin=10000; psmax=-10000
      pcmin=10000; pcmax=-10000
      for head=0,head<32,head++ do
        if limvalid[0][head]==0 continue
        if allowz then
          // I attempt to approximate conversion from Dallas settings ps and pc
          // to sine and cosine field amplitudes sin and cos by the following
          // equations (forgetting that parallelogramm may be distorted):
          //   sin=sin0+ps*a+pc*b
          //   cos=cos0+ps*c+pc*d
          a=(lims[0][head][1]-lims[0][head][0])/511.0
          b=(lims[0][head][2]-lims[0][head][0])/511.0
          c=(limc[0][head][1]-limc[0][head][0])/511.0
          d=(limc[0][head][2]-limc[0][head][0])/511.0
          det=a*d-b*c
          if Abs(det)<0.01 then
            ps[head]=256.0
            pc[head]=256.0
            limvalid[0][head]=-1       // Possibly dead potentiometer
            valid=0
          else
            ps[head]=((smean-lims[0,head,0])*d-(cmean-limc[0,head,0])*b)/det
            pc[head]=((cmean-limc[0,head,0])*a-(smean-lims[0,head,0])*c)/det
          endif
        else
          // No phase potentiometer. The approximation is 1-dimensional:
          //   sin=sin0+ps*a
          smin=(lims[0,head,0]+lims[0,head,2])/2.0
          smax=(lims[0,head,1]+lims[0,head,3])/2.0
          a=(smax-smin)/511.0
          if a<0.1 then
            ps[head]=256.0
            limvalid[0][head]=-1       // Possibly dead potentiometer
            valid=0
          else
            ps[head]=(smean-smin)/a
          endif
          pc[head]=256.0
        endif
        psmin=Min(psmin,ps[head])
        psmax=Max(psmax,ps[head])
        pcmin=Min(pcmin,pc[head])
        pcmax=Max(pcmax,pc[head])
      enddo
      // If necessary, shift potentiometers.
      if psmin<10.0 && psmax<501.0 then
        ds=Min(10.0-psmin,501.0-psmax)
      else if psmin>10.0 && psmax>501.0 then
        ds=Max(501.0-psmax,10.0-psmin)
      else
        ds=0.0
      endif
      if pcmin<10.0 && pcmax<501.0 then
        dc=Min(10.0-pcmin,501.0-pcmax)
      else if pcmin>10.0 && pcmax>501.0 then
        dc=Max(501.0-pcmax,10.0-pcmin)
      else
        dc=0.0
      endif
      if ds!=0.0 || dc!=0.0 then
        for head=0,head<32,head++ do
          if limvalid[0][head]==0 continue
          ps[head]=ps[head]+ds
          pc[head]=pc[head]+dc
        enddo
      endif
      // Verify settings.
      for head=0,head<32,head++ do
        if limvalid[0][head]==0 continue
        ps[head]=Max(0.0,Min(ps[head],511.0))
        pc[head]=Max(0.0,Min(pc[head],511.0))
        if ps[head]<10 || ps[head]>501 || pc[head]<10 || pc[head]>501 then
          limvalid[0][head]=-1         // Possibly out of limits
          valid=0
        endif
      enddo
      Drawpredallas(limvalid[0],lims[0],limc[0],1)
      if valid==0 then
        // Probably good adjustment is not possible. Warn user.
        clear hright
        draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
        draw text="头部卡上的信号可能无法对齐。"
        draw text="此类测试头\n在表中标记为红色。"
        draw text="请确认下一步动作。\n请注意可以在下一步中进行"
        draw text="不太精确的\n调整（但尽可能的调好）.\n"
        draw show
        hcont=control BUTTON
          window=hright
          position=RIGHTX/2-124,USERY,120,24
          name="继续"
          help="按下继续电场调整"
        endc
        hcancel=control BUTTON
          window=hright
          position=RIGHTX/2+5,USERY,120,24
          name="取消"
          help="按下中断电场调整"
        endc
        while err==0 do
          if Pressed(hexit) then
            err=-1
          else if Pressed(hcont) then
            break
          else if Pressed(hcancel) then
            err=10
          endif
          wait
        enddo
      endif
    endif
    if err!=0 goto finish
  endif
  // Step 2: start main on-head alignment.
  if auto==0 then
    change hinfo text="Manual field adjustment"
  else if auto==1 then
    change hinfo text="自动电场调整"
  else
    change hinfo text="电场验证"
  endif
  change hinfo limits=0,0
  clear hright
  Memset(diffs,0,Sizeof(diffs))
  Memset(diffc,0,Sizeof(diffc))
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  if auto==0 || auto==2 then           // Manual adjustment or verification
    if hlog!=NULL then
      fprintf(hlog,"\nTesting input capacities of on-head boards...\n")
    endif
    draw text="正在测试头部卡的输入电容。"
    if auto==0 then
      draw text=" Please wait at least 1 full cycle before adjusting "
      draw text="any potentiometers."
    endif
    if verify==2 then
      hpause=NULL
      hnext=NULL
      hcancel=control BUTTON
        window=hright
        position=RIGHTX/2-60,USERY+40,120,24
        name="取消"
        help="中断输入电容验证"
      endc
    else if lastrail-firstrail>1 then
      draw text=" Press " font=MAINFONT text="Next" font=TIMESFONT
      draw text=" to proceed with the next group of rails."
      hpause=control BUTTON
        window=hright
        position=5,USERY+40,RIGHTX/3-5,24
        name="暂停"
        help="按下可暂停程序并在调整位置移动磁头"
      endc
      hnext=control BUTTON
        window=hright
        position=5+RIGHTX/3,USERY+40,RIGHTX/3-5,24
        name="下一个"
        help="按下可继续下一组轨道"
      endc
      hcancel=control BUTTON
        window=hright
        position=5+2*(RIGHTX/3),USERY+40,RIGHTX/3-9,24
        name="取消"
        help="中断电容调整"
      endc
    else
      hpause=control BUTTON
        window=hright
        position=RIGHTX/2-124,USERY+40,120,24
        name="暂停"
        help="按下可暂停程序并在调整位置移动磁头"
      endc
      hnext=NULL
      hcancel=control BUTTON
        window=hright
        position=RIGHTX/2+5,USERY+40,120,24
        name="取消"
        help="按下可以中断输入电容调整"
      endc
    endif
  else                                 // Automatical adjustment
    if hlog!=NULL then
      fprintf(hlog,"\nAdjusting input capacities of on-head boards...\n")
    endif
    draw text="现在调整头部卡的输入电容值.目的是\n减少任意两个测试"
    draw text="头的"
    if allowz then
      draw text="正弦和余弦"
    else
      draw text="正弦"
    endif
    draw text="值的"
    draw text="偏差,\n使其小于"
    draw text=format("%i 比特的特征值.请稍等...\n",DADJLIMIT)
    hpause=NULL
    hnext=NULL
    haccept=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+40,120,24
      name="接受偏差"
      help="如果差异太大,按此按钮接受不精确的调整"
    endc
    disable haccept
    hcancel=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+40,120,24
      name="取消"
      help="按下可以中断输入电容调整"
    endc
  endif
  // Create legend.
  ly=95
  draw at 8,ly+16 mode=M_LEFT text="说明:"
  draw mode=M_CENTERED
  draw color=BLACK bkcolor=BLACK at 70,ly fillrect 150,ly+17
  draw at 110,ly+16 font=TIMESFONT color=WHITE text="最新测量"
  draw color=PINK bkcolor=PINK at 160,ly fillrect 240,ly+17
  draw at 200,ly+16 font=TIMESFONT color=BLACK text="不良电场"
  draw color=BLACK bkcolor=WHITE at 70,ly+21 fillrect 150,ly+21+17
  draw at 110,ly+21+16 font=TIMESFONT color=LIGHTRED text="电场高"
  draw color=BLACK bkcolor=WHITE at 160,ly+21 fillrect 240,ly+21+17
  draw at 200,ly+21+16 font=TIMESFONT color=LIGHTBLUE text="电场低"
  draw show
  hmessage=control LIST
    window=hright
    position=6,150,RIGHTX-12,122
    help="检测到的错误"
    color=BLACK
    bkcolor=WHITE
    font=FIXEDSYS
    mode=M_VSCROLL
    size=8192
  endc
  Memset(fs,0,Sizeof(fs))
  Memset(fc,0,Sizeof(fc))
  Memset(fcap,0,Sizeof(fcap))
  Memset(fixed,0,Sizeof(fixed))
  // Walk all groups, one after another. In manual mode "Next" advances to
  // the next group.
  for k=0,err==0,k++ do
    if k>=nbase then
      if auto==1 break                 // Auto adjustment finished
      if verify==2 break               // Auto verification finished
      k=0                              // Restart from beginning
    endif
    base=nextbase[k]
    Memset(fvalid,0,Sizeof(fvalid))
    ngood=0
    // As many attempts as necessary to reach good adjustment, except for auto
    // verification (verify=2).
    for loop=1,err==0,loop++ do
      change hmessage color=BLACK
      add hmessage text=format("基于 %i%s 循环 %i",                            \
        base/2,base & 1?"R":"L",loop)
      antdx=Random(DELTA)-DELTA/2.0    // Shifts for antenna and ground
      antdy=Random(DELTA)-DELTA/2.0
      // Set potentiometers. This may cause reswitching of the on-head relays,
      // therefore I program all potentiometers at once at the beginning of
      // the cycle.
      if auto==1 then
        for head=0,head<nrail*2 && err==0,head++ do
          result=Setdallas(head,ps[head],pc[head])
          if result<0 then
            err=-1; goto finish        // Cancelled by user
          else if result>0 then
            err=3; goto finish         // Can't set Dallas potentiometers
          endif
        enddo
      endif
      // Test all heads in the group.
      finished=1
      for i=0,i<8 && err==0,i++ do
        // Calculate coordinates.
        result=Fieldxy(base,i,&head,&ant,x,y,1)
        if result>0 continue           // Head unavailable
        if result<0 then
          err=2; break                 // Can't select antenna - impossible?
        endif
        if testersides==0x1 && ($EXTLAY.extant & 1)!=0 then
          ant1=32
        else
          ant1=ant
        endif
        sprintf(htext,"%i%s",head/2,head & 1?"R":"L")
        fvalid[i]=-1                   // Can be corrected in the loop
        // Up to 4 attempts to make a good measurement.
        for m=0,m<4 && err==0,m++ do
          if auto!=1 && hnext!=NULL && Pressed(hnext) then
            err=101; break             // Not an error, advance to next group
          endif
          if m>0 then
            // If first measurement was unsuccessfull, try different position
            // of antennas.
            antdx=Random(DELTA)-DELTA/2.0
            antdy=Random(DELTA)-DELTA/2.0
          endif
          // Prepare command.
          deltax=Random(DELTA)-DELTA/2.0
          deltay=Random(DELTA)-DELTA/2.0
          n=sprintf(s,"M %i[%g:%.3f,%g:%.3fV%gP%gH%g] ",                       \
            head,x[0],deltax,y[0],deltay,strokev,strokep,strokez)
          n=n+sprintf(s+n,"%i[%g:%.3f,%g:%.3fV%gP%gH%g] ",                     \
            ant,x[1],antdx,y[1],antdy,strokev,strokep,strokez)
          n=n+sprintf(s+n,"%i[%g:%.3f,%g:%.3fV%gP%gH%g] ",                     \
            ant+1,x[2],antdx,y[2],antdy,strokev,strokep,strokez)
          n=n+sprintf(s+n,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",                  \
            head,ant1,ant,ant,ant,ant,ant,ant,ant,ant)
          n=n+sprintf(s+n,"%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",  \
            ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant)
          sprintf(s+n,"%i,%i,%i,%i)",ant,ant,ant,ant) // Total of 28*ant
          // Send command.
          SYS.Killimm(0)
          if SERV.Cmdimm(0,s)<0 then
            change hmessage color=LIGHTRED
            add hmessage text=format("%s: Can't send command",htext)
            continue
          endif
          // Wait for answer.
          t=Time()
          while err==0 do
            if Time()-t>10000 err=1
            if Pressed(hexit) err=-1
            if Pressed(hcancel) err=10
            if $A[0].length!=0 break
            wait
          enddo
          if err!=0 break
          if $A[0].answer!=S_MOVE || $A[0].subcmd!=M_FIELD then
            change hmessage color=LIGHTRED
            add hmessage text=format("%s: Invalid answer",htext)
            continue
          else if $A[0].status & 0x9820 then
            change hmessage color=LIGHTRED
            add hmessage text=format("%s: Bad measurement",htext)
            continue
          endif
          SERV.Convertfield($A[0],&zc,&zr)
          if zc<CMIN || zc>CMAX then
            change hmessage color=LIGHTRED
            add hmessage text=format("%s: 无效电容",htext)
            continue
          endif
          // Process field. I discard first 4 measurements as possibly
          // unstable and expect remaining measurements to be reproducible.
          Initsigma(sdata)
          Initsigma(cdata)
          for n=0,n<24,n++ do
            Addsigma(sdata,$int2($A[0]+48+4*n))
            Addsigma(cdata,$int2($A[0]+50+4*n))
          enddo
          if Getmin(sdata)<SINMIN || Getmax(sdata)>SINMAX ||                   \
            Getmin(cdata)<COSMIN || Getmax(cdata)>COSMAX then
            change hmessage color=LIGHTRED
            add hmessage text=format("%s: Invalid field",htext)
            continue
          else if Getsigma(sdata)>FNOISE || Getsigma(cdata)>FNOISE then
            change hmessage color=LIGHTRED
            add hmessage text=format("%s: 电场干扰",htext)
            continue
          endif
          // Seems to be a reliable field measurement.
          fvalid[i]=1
          gs[i]=Getxmean(sdata)
          fs[head]=gs[i]
          gc[i]=Getxmean(cdata)
          fc[head]=gc[i]
          cc[i]=zc
          fcap[head]=zc
          break
        enddo                          // End of head attempts
        if fvalid[i]<0 finished=0
        // Update table.
        draw window=hgraph color=BLACK bkcolor=WHITE clear
        // Display set of rails used on current step.
        draw at LEFTX/2,LEFTY-40 mode=M_CENTERED font=TIMESFONT
        if testersides==0x3 && used[base]!=0 && used[base+2]!=0 &&             \
          used[base+nrail]!=0 && used[base+nrail+2]!=0 then
          draw text=format("测试轨道: %i, %i, %i 和 %i",                 \
          base/2,base/2+1,(base+nrail)/2,(base+nrail)/2+1)
        else if testersides==0x3 && used[base]!=0 && used[base+2]!=0 then
          draw text=format("测试轨道: %i and %i",base/2,base/2+1)
        else if testersides==0x3 && used[base+nrail]!=0 &&                     \
          used[base+nrail+2]!=0 then
          draw text=format("测试轨道: %i and %i",                         \
          (base+nrail)/2,(base+nrail)/2+1)
        else if testersides==0x3 && used[base]!=0 && used[base+nrail]!=0 then
          draw text=format("测试轨道: %i and %i",base/2,(base+nrail)/2)
        else
          draw text=format("测试轨道: %i and %i",base/2,base/2+1)
        endif
        // Calculate mean sine and cosine.
        Initsigma(sdata)
        Initsigma(cdata)
        for n=0,n<8,n++ do
          if fvalid[n]<=0 continue
          Addsigma(sdata,gs[n])
          Addsigma(cdata,gc[n])
        enddo
        ss=Getmean(sdata)
        cs=Getmean(cdata)
        maxsin=-1
        if Getcount(sdata)>0 then
          draw at LEFTX/2,LEFTY-15 mode=M_CENTERED font=TIMESFONT
          draw text=format("平均正弦: %.1f, 余弦: %.1f 位",ss,cs)
          r=0.0
          for n=0,n<8,n++ do
            if fvalid[n]<=0 continue
            if Abs(gs[n]-ss)>r then
              maxsin=n                 // Head with highest deviation from mean
              r=Abs(gs[n]-ss)
            endif
          enddo
        endif
        Drawdata(i,0,base,auto,allowz)
        draw show
        // If there is a request to pause, move heads in pause positions and
        // wait till user allows movements.
        if auto!=1 && hpause!=NULL && Pressed(hpause) then
          change hpause text="继续"
          change hpause help="按下继续测试"
          change hpause color=LIGHTRED
          change hpause bkcolor=YELLOW
          // Move heads in pause positions.
          for n=0,n<nrail*2,n=n+2 do
            if used[n]==0 continue
            if Convertpad(&xt,&yt,"NOCT1",n,0)<0.0 err=2
            yt=$LAY.yoffset[n/2]/1000.0
            if Convertpad(&xu,&yu,"NOCT2",n+1,0)<0.0 err=2
            yu=$LAY.yoffset[n/2]/1000.0
            sprintf(s,"M %i[%g,%gH50] %i[%g,%gH50] NOP",n,xt,yt,n+1,xu,yu)
            SERV.Cmdimm(32,s)
          enddo
          while err==0 do
            if Pressed(hpause) then
              break
            else if Pressed(hnext) then
              err=101
            else if Pressed(hcancel) then
              err=10; break
            else if Pressed(hexit) then
              err=-1
            endif
            wait
          enddo
          change hpause text="暂停"
          change hpause help=                                                  \
            "Press to pause procedure and move heads in adjust positions"
          change hpause color=BLACK
          change hpause bkcolor=GRAY
        endif
        // If there is a request to accept limits, set flag.
        if auto==1 && Pressed(haccept) && stopatlimit==0 then
          stopatlimit=1
          dadjfactors=dadjfactors*0.5
          dadjfactorc=dadjfactorc*0.5
          change haccept color=LIGHTRED
          change haccept bkcolor=YELLOW
          change hmessage color=BLACK
          add hmessage text="Imprecise adjustment is allowed"
        endif
      enddo                            // End of measurements in a group
      if finished==1 && err==0 && auto==2 then
        // Gather measured differences.
        Initsigma(sdata)
        Initsigma(cdata)
        for n=0,n<8,n++ do
          if fvalid[n]<=0 continue
          if n<4 then
            head=base+n                // Top (or, in general, first) side
          else if testersides!=0x3 then
            continue                   // Single-sided tester
          else
            head=base+nrail+(n-4)      // Opposite side
          endif
          if used[head]==0 continue    // Head is excluded from test
          if k!=0 && verify!=2 && fixed[head]==0 continue
          Addsigma(sdata,gs[n])
          Addsigma(cdata,gc[n])
        enddo
        ss=Getmean(sdata)
        cs=Getmean(cdata)
        badhead=-1
        maxbad=AUTOVLIMIT              // Limit for misaligned head
        for n=0,n<8,n++ do
          if fvalid[n]<=0 continue
          if n<4 then
            head=base+n                // Top (or, in general, first) side
          else if testersides!=0x3 then
            continue                   // Single-sided tester
          else
            head=base+nrail+(n-4)      // Opposite side
          endif
          if used[head]==0 continue    // Head is excluded from test
          Addsigma(diffs[n],gs[n]-ss)
          Addsigma(diffc[n],gc[n]-cs)
          // In auto verification mode, check whether heads are aligned.
          if verify==2 && Abs(gs[n]-ss)>maxbad then
            badhead=head
            maxbad=Abs(gs[n]-ss)
          endif
        enddo
        if verify==2 then
          if badhead<0 then
            // Heads are sufficiently alighed, proceed with the next group.
            err=101                    // Request to proceed with next group
          else if loop>=5 then
            // Looks like heads are really misaligned.
            if maxbad>worstbad || worsthead<0 then
              worsthead=badhead
              worstbad=maxbad
            endif
            err=101                    // Request to proceed with next group
          endif
        endif
      endif
      if finished==1 && err==0 && auto==1 then
        // Group processed, all values are valid. Calculate mean sine and
        // cosine. If this is not the first group, I take into account only
        // fixed heads.
        Initsigma(sdata)
        Initsigma(cdata)
        for n=0,n<8,n++ do
          if fvalid[n]<=0 continue
          if n<4 then
            head=base+n                // Top (or, in general, first) side
          else if testersides!=0x3 then
            continue                   // Single-sided tester
          else
            head=base+nrail+(n-4)      // Opposite side
          endif
          if used[head]==0 continue    // Head is excluded from test
          if k!=0 && fixed[head]==0 continue
          Addsigma(sdata,gs[n])
          Addsigma(cdata,gc[n])
        enddo
        ss=Getmean(sdata)
        cs=Getmean(cdata)
        // Calculate maximal deviations and correct Dallas potentiometers
        // (only non-fixed heads).
        smax=0.0; cmax=0.0
        for n=0,n<8,n++ do
          if fvalid[n]<=0 continue
          if n<4 then
            head=base+n                // Top (or, in general, first) side
          else if testersides!=0x3 then
            continue                   // Single-sided tester
          else
            head=base+nrail+(n-4)      // Opposite side
          endif
          if used[head]==0 continue    // Head is excluded from test
          if fixed[head]!=0 continue
          // If stop at limit is requested, ignore heads where potentiometers
          // are already at limit.
          if stopatlimit==0 || (ps[head]>=2.0 && ps[head]<=509.0) then
            smax=Max(smax,Abs(gs[n]-ss))
          endif
          if stopatlimit==0 || (pc[head]>=2.0 && pc[head]<=509.0) then
            cmax=Max(cmax,Abs(gc[n]-cs))
          endif
          ps[head]=ps[head]-(gs[n]-ss)/ss*dadjfactors
          ps[head]=Max(0.0,Min(ps[head],511.0))
          pc[head]=pc[head]-(gc[n]-cs)/ss*dadjfactorc
          pc[head]=Max(0.0,Min(pc[head],511.0))
          if stopatlimit==0 && (ps[head]<2.0 || ps[head]>509.0 ||              \
            (allowz!=0 && (pc[head]<2.0 || pc[head]>509.0)))                   \
          then
            change hmessage color=LIGHTRED
            add hmessage text=format("%i%s: Limit reached",                    \
              head/2,head & 1?"R":"L")
            enable haccept
          endif
        enddo
        if smax<=DADJLIMIT*0.7 && (allowz==0 || cmax<=DADJLIMIT*0.7) then
          ngood++                      // Heads are aligned
          if smax<=DADJLIMIT*0.3 && (allowz==0 || cmax<=DADJLIMIT*0.3) then
            ngood++                    // Headds are perfectly aligned
          endif
        else
          ngood=0                      // Heads are not yet aligned
        endif
        if auto==1 && ngood>=3 then
          // Fix potentiometers and finish group.
          for n=0,n<8,n++ do
            if n<4 then
              head=base+n              // Top (or, in general, first) side
            else if testersides!=0x3 then
              continue                 // Single-sided tester
            else
              head=base+nrail+(n-4)    // Opposite side
            endif
            if used[head]==0 continue  // Head is excluded from test
            fixed[head]=1
          enddo
          err=101                      // Request to proceed with next group
        endif
      endif
    enddo                              // End of group adjustment
    if err==101 then
      // This is not an error, but a request to advance to the next group.
      err=0
    endif
  enddo                                // End of group
  if (err==0 || err==10) && auto==2 && hlog!=NULL then
    // Protocol measured differences.
    n=0
    for k=0,k<nrail*2,k++ do
      if used[k]==0 continue
      if Getcount(diffs[k])>0 n++
    enddo
    if n>0 then
      fprintf(hlog,"  Measured differences:\n")
      for k=0,k<nrail*2,k++ do
        if used[head]==0 continue
        if Getcount(diffs[k])==0 continue
        fprintf(hlog,"  Head %i%c:  dSin = %5.1f +/- %5.1f, ",                 \
          k/2,k & 1?'R':'L',Getmean(diffs[k]),Getsigma(diffs[k]))
        fprintf(hlog,"  dCos = %5.1f +/- %5.1f bits\n",                        \
          Getmean(diffc[k]),Getsigma(diffc[k]))
        ;
      enddo
      err=0
    endif
  endif
  if err==0 && auto==1 then
    // Automatic adjustment finished.
    change hinfo text="Input capacities adjusted"
    if hlog!=NULL fprintf(hlog,"  Potentiometer settings:\n")
    // Apply changes to extended layout.
    for k=0,k<nrail*2,k++ do
      if used[head]==0 continue
      $EXTLAY.sinadj[k]=ps[k]
      if hlog!=NULL then
        fprintf(hlog,"  Head %i%c:  sine = %3i",k/2,k & 1?'R':'L',ps[k])
      endif
      if allowz then
        $EXTLAY.cosadj[k]=pc[k]
        if hlog!=NULL then
          fprintf(hlog,", cosine = %3i",pc[k])
        endif
      endif
      if hlog!=NULL then
        if ps[k]<2.0 || ps[k]>509.0 || (allowz && (pc[k]<2.0 || pc[k]>509.0))  \
          fprintf(hlog,"  (on the limit)")
        fprintf(hlog,"\n")
      endif
      $int2($EXT0+260)=0
      $int2($EXT0+262+k*2)=0
      $int2($EXT0+326+k*2)=0
    enddo
    layoutdiffers=1
  endif
  // Step 3: correct extended field phase shifts.
  if err==0 && verify==0 && auto==1 && (measfeatures & MF_XFLDCRATE)!=0 then
    clear hright
    change hinfo limits=0,0
    change hinfo text="电场相位调整"
    draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
    draw text="高电容值时一些头部卡的特征相位值\n可能会有偏差."
    draw text="此程序中会得到校正.\n"
    draw show
    hmessage=control LIST
      window=hright
      position=6,100,RIGHTX-12,160
      help="检测到的错误"
      color=BLACK
      bkcolor=WHITE
      font=FIXEDSYS
      mode=M_VSCROLL
      size=8192
    endc
    hcancel=control BUTTON
      window=hright
      position=RIGHTX/2-60,USERY+30,120,24
      name="取消"
      help="按下中断电场调整"
    endc
    // Display set of rails.
    draw window=hgraph color=BLACK bkcolor=WHITE clear
    draw color=BLACK mode=M_CENTERED font=MEDIUMFONT at LEFTX/2,30
    draw text="电场测量"
    draw mode=M_LEFT font=SMALLFONT color=DARKGRAY
    draw at 15,61 text="头"
    draw at LEFTX/2+10,61 text="头"
    draw mode=M_RIGHT
    draw at 12+85,61 text="场值"
    draw at 12+122,61 text="阈"
    draw at LEFTX/2+7+85,61 text="场值"
    draw at LEFTX/2+7+122,61 text="阈"
    draw mode=M_RIGHT
    for m=0,m<nrail,m++ do
      ys=90+m*dy
      if $LAY.side[m]!=0 ys=ys+7
      for n=0,n<2,n++ do
        xs=(n==0?15:LEFTX/2+10)+15
        if n==0 then
          draw at xs,ys text=format("%iL",m)
        else
          draw at xs,ys text=format("%iR",m)
        endif
      enddo
    enddo
    draw mode=M_CENTERED
    draw at LEFTX/2,110+nrail*dy text="上面是正弦,"
    draw at LEFTX/2,120+nrail*dy text="下面是余弦"
    draw show
    for i=0,i<nrail*2 && err==0,i++ do
      Initsigma(fsshort[i])
      Initsigma(fcshort[i])
      shortok[i]=0
    enddo
    // Test loop.
    while err==0 do
      valid=1
      for i=0,i<nrail*2 && err==0,i++ do
        if used[i]==0 continue         // Head is excluded from test
        if shortok[i] continue         // Already measured
        valid=0
        // Select antenna. To reduce direct capacity, I always take right head.
        // First I look for the head on the opposite side, then for the first
        // from the same side.
        ant=-1
        for j=0,j<nrail,j++ do
          if $LAY.side[i/2]==$LAY.side[j] continue
          if used[j*2+1]==0 continue
          ant=j*2+1; break             // Antenna on the opposite side found
        enddo
        if ant<0 then
          for j=0,j<nrail,j++ do
            if $LAY.side[i/2]!=$LAY.side[j] continue
            if i/2==j continue
            if used[j*2+1]==0 continue
            ant=j*2+1; break           // Antenna on the same side found
          enddo
        endif
        if ant<0 err=2                 // Unable to select antenna
        // Calculate coordinates and move heads, including those that do not
        // participate in measurements, into the requested positions.
        n=sprintf(s,"M")
        for j=0,j<nrail*2 && err==0,j++ do
          if used[j]==0 continue
          if j==i then                 // Head under test
            if Convertpad(&xm,&ym,"GND",j,DELTA)<0.0 err=2
          else if j==ant then          // Antenna finger
            if Convertpad(&xa,&ya,"GND",j,DELTA)<0.0 err=2
          else if (j & 1)==0 then      // Any remaining left head
            if Convertpad(&xt,&yt,"NOCT1",j,0.0)<0.0 then
              err=2
            else
              yt=$LAY.yoffset[j/2]/1000.0
              n=n+sprintf(s+n," %i[%g,%gH50A255]",j,xt,yt)
            endif
          else                         // Any remaining right head
            if Convertpad(&xt,&yt,"NOCT2",j,0.0)<0.0 then
              err=2
            else
              yt=$LAY.yoffset[j/2]/1000.0
              n=n+sprintf(s+n," %i[%g,%gH50A255]",j,xt,yt)
            endif
          endif
        enddo
        // Attention, finger overlapping in Y may cause Bad coordinates on
        // A5/A6 during single-side adjustment if board is rotated by more than
        // 2*DELTA!
        if i<ant && ym>=ya then
          ym=ym-DELTA; ya=ya+DELTA
        else if i>ant && ym<=ya then
          ym=ym+DELTA; ya=ya-DELTA
        endif
        if testersides==0x1 && ($EXTLAY.extant & 1)!=0 then
          ant1=32
        else
          ant1=ant
        endif
        n=n+sprintf(s+n," %i[%g,%gA10H%gV%iP%i] %i[%g,%gA10H%gV%iP%i]",        \
          i,xm,ym,strokez,strokev,strokep,ant,xa,ya,strokez,strokev,strokep)
        n=n+sprintf(s+n," F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",    \
          i,ant1,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant)
        sprintf(s+n,"%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i)",              \
          ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant)
        sprintf(htext,"%i%s",i/2,i & 1?"R":"L")
        // Send command.
        SYS.Killimm(0)
        if SERV.Cmdimm(0,s)<0 then
          change hmessage color=LIGHTRED
          add hmessage text=format("%s: Can't send command",htext)
          continue
        endif
        // Wait for answer.
        t=Time()
        while err==0 do
          if Time()-t>10000 err=1
          if Pressed(hexit) err=-1
          if Pressed(hcancel) err=10
          if $A[0].length!=0 break
          wait
        enddo
        if err!=0 break
        if $A[0].answer!=S_MOVE || $A[0].subcmd!=M_FIELD then
          change hmessage color=LIGHTRED
          add hmessage text=format("%s: Invalid answer",htext)
          continue
        else if $A[0].status & 0x9800 then
          change hmessage color=LIGHTRED
          add hmessage text=format("%s: Bad measurement",htext)
          continue
        endif
        // Process answer. Note that shortcut bit must be set, or we have no
        // contact. I skip first 4 fields as possibly unreliable.
        if ($A[0].status & 0x0020)==0 then
          change hmessage color=LIGHTRED
          add hmessage text=format("%s: No contact",htext)
          continue
        endif
        for j=0,j<24,j++ do
          if $int2($A[0]+44+4*j)<28000 continue
          Addsigma(fsshort[i],$int2($A[0]+44+4*j))
          Addsigma(fcshort[i],$int2($A[0]+46+4*j))
        enddo
        if Getcount(fsshort[i])>=40 shortok[i]=1
        // Update display.
        draw window=hgraph font=SMALLFONT
        for j=0,j<nrail*2,j++ do
          if used[j]==0 continue       // Head is excluded from test
          xs=(j & 1)==0?12:LEFTX/2+7
          ys=90+(j/2)*dy
          if $LAY.side[j/2]!=0 ys=ys+7
          draw color=(j==i?BLACK:WHITE) bkcolor=WHITE
          draw at xs+20,ys-dy*3/4 fillrect xs+130,ys-dy*3/4+dy
          if Getcount(fsshort[j])==0 continue
          draw mode=M_RIGHT color=BLACK
          draw at xs+85,ys-6 text=format("%.1f",Getmean(fsshort[j]))
          draw at xs+85,ys+5 text=format("%.1f",Getmean(fcshort[j]))
          draw color=DARKGRAY
          draw at xs+122,ys-6 text=format("%3i",$EXTLAY.sinadj[j])
          if allowz draw at xs+122,ys+5 text=format("%3i",$EXTLAY.cosadj[j])
          draw show
        enddo
      enddo
      if valid break
    enddo
    // Process results.
    if err==0 then
      // Calculate input voltage and mean phase on a shortcut.
      uin=0.0; a=0.0; n=0
      for i=0,i<nrail*2,i++ do
        if used[i]==0 continue
        uin=uin+Getmean(fsshort[i])*Getmean(fsshort[i])+                       \
          Getmean(fcshort[i])*Getmean(fcshort[i])
        a=a+Getmean(fcshort[i])
        n++
      enddo
      if n>0 then
        // Save input voltage to layout.
        uin=Sqrt(uin/n)
        $uint2($EXT0+260)=Floor(uin+0.5)
        a=a/n
        // Save individual phase shifts to layout and calculate mean phase
        // deviation.
        b=0.0
        for i=0,i<nrail*2,i++ do
          if used[i]==0 continue
          $int2($EXT0+262+i*2)=Floor(Getmean(fcshort[i])-a+0.5)
          dfi=(Getmean(fcshort[i])-a)/uin
          b=b+fc[i]*Cos(dfi)-fs[i]*Sin(dfi)
        enddo
        b=b/n
        // Calculate individual phase corrections and save them to layout.
        for i=0,i<nrail*2,i++ do
          if used[i]==0 continue
          dfi=(Getmean(fcshort[i])-a)/uin
          c=fc[i]*Cos(dfi)-fs[i]*Sin(dfi)
          r=Sqrt(fs[i]*fs[i]+fc[i]*fc[i])
          d=(c-b)*uin*uin/r/(uin-r)
          $int2($EXT0+326+i*2)=Floor(d+0.5)
        enddo
        layoutdiffers=1
      endif
    endif
  endif
  if err==0 && auto==1 then
    // Apply current C adjust date to layout.
    Strtime(s,"%d,%m,%Y",0,0)
    sscanf(s,"%i,%i,%i",&i,&j,&k)
    $uint2($EXTLAY+586)=(i+j*32+(k-1980)*512) & 0xFFFF
    Makelayoutcopy()
    i=Loadlayoutmeas(1,1)
    if i==(-1) err=-1
    if i==0 then
      Addcalibrationrecord("Input capacities adjusted")
      layoutdiffers=0
    endif
  endif
  if err==0 && verify==2 && worsthead>=0 then
    err=9                              // Misaligned heads
  endif
finish:
  destroy hgraph
  change hleft position=4,4,LEFTX,LEFTY
  if err!=0 && verify!=1 && layoutdiffers then
    Restoreoldlayout()
    Sendextention()
    layoutdiffers=0
  endif
  if err>=0 then
    // Move heads in pause positions.
    for i=0,i<nrail*2,i=i+2 do
      if used[i]==0 continue
      if Convertpad(&xt,&yt,"NOCT1",i,0)<0.0 err=2
      yt=$LAY.yoffset[i/2]/1000.0
      if Convertpad(&xu,&yu,"NOCT2",i+1,0)<0.0 err=2
      yu=$LAY.yoffset[i/2]/1000.0
      sprintf(s,"M %i[%g,%gH50] %i[%g,%gH50] NOP",i,xt,yt,i+1,xu,yu)
      SERV.Cmdimm(32,s)
    enddo
  endif
  if err==0 then
    return 0                           // Full success
  else if err<0 then
    if hlog!=NULL fprintf(hlog,"  Script cancelled by operator\n")
    return -1                          // Operator cancelled script
  else if err==10 then
    if hlog!=NULL fprintf(hlog,"  Field adjustment interrupted by operator\n")
    return 1                           // Operator stopped adjustment
  endif
  clear hright
  change hinfo text="电容校正错误"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    if hlog!=NULL fprintf(hlog,"  Timeout while executing command\n")
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    if hlog!=NULL fprintf(hlog,"  Can't assign head or antenna\n")
    draw text="Can't assign head or antenna!"
    draw at 6,60 color=BLACK
    draw text="Probably the configuration of your tester is not supported by "
    draw text="this scropt. Please report atg. "
  else if err==3 then
    if hlog!=NULL fprintf(hlog,"  Unable to set potentiometers\n")
    draw text="Can't set potentiometers!"
    draw at 6,60 color=BLACK
    draw text="The command to set on-head potentiometers that control "
    draw text="field measurements was rejected. "
  else if err==4 then
    if hlog!=NULL fprintf(hlog,"  Unable to send command\n")
    draw text="Unable to send command!"
    draw at 6,60 color=BLACK
    draw text="Most probably, this means some internal error in the script. "
  else if err==5 then
    if hlog!=NULL fprintf(hlog,"  Unexpected answer from crate\n")
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  else if err==6 then
    if hlog!=NULL fprintf(hlog,"  Unable to measure on-head limits\n")
    draw text="无法测量极限值!"
    draw at 6,60 color=BLACK
    draw text="脚本程序无法测量测试头上电位器的调整"
    draw text="极限值.要么板件损坏,要么测试机未作零"
    draw text="点校正,或测量信噪高."
  else if err==7 then
    if hlog!=NULL fprintf(hlog,"  Internal error detected\n")
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="There is no overlapping between the head groups. Please "
    draw text="report this event to atg!"
  else if err==9 then
    if hlog!=NULL fprintf(hlog,"  Misaligned field, probably on-head glitch!\n")
    draw text="电场校正失调"
    draw at 6,60 color=BLACK
    draw text="自动校正程序显示头部值未校正。\n最差的"
    draw text=" "
    draw text=format("%i%s测试头最少偏差",worsthead/2,worsthead & 1?"R":"L")
    draw text=format("%.0f 比特值.\n可能是测试机被小的硬件故障影响,以至\n",worstbad)
    draw text="于需要软件调整"
    draw text=".\n"
  endif
  if err!=9 draw text="校正终止."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="继续"
    help="按下继续"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Verifies field measurement on a shortcut (full voltage).
function int Verifyshortcut()
  int i,j,m,n,nfing,t,xs,ys,a,ant[32],valid[32],err
  float x,y,xa,ya,xt,yt,xu,yu,dy
  float sf[32][5],cf[32][5]
  char s[1024]
  handle hpause,hcancel,hcont
  clear hright
  change hinfo limits=0,0
  change hinfo text="高电容校准"
  change hleft position=-1000,*,*,*
  nfing=$LAY.nfing
  hpause=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="暂停"
    help="按下可暂停验证并在调整位置移动测试头"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="取消"
    help="按下可取消验证"
  endc
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="脚本将会验证测试头在非常高的 "
  draw text="电容是否一致 (模拟有个短路). "
  draw show
  hgraph=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="对齐验证结果"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  // Display set of rails.
  if $LAY.nfing<=10 then
    dy=28
  else
    dy=23
  endif
  draw window=hgraph color=BLACK bkcolor=WHITE clear
  draw color=BLACK mode=M_CENTERED font=MEDIUMFONT at LEFTX/2,30
  draw text="电场测量"
  draw mode=M_LEFT font=SMALLFONT color=DARKGRAY
  draw at 15,61 text="头"
  draw at LEFTX/2+10,61 text="头"
  draw mode=M_RIGHT
  draw at 12+85,61 text="场值"
  draw at 12+122,61 text="阈"
  draw at LEFTX/2+7+85,61 text="场值"
  draw at LEFTX/2+7+122,61 text="阈"
  draw mode=M_RIGHT
  for m=0,m<nfing,m++ do
    ys=90+m*dy
    if $LAY.side[m]!=0 ys=ys+7
    for n=0,n<2,n++ do
      xs=(n==0?15:LEFTX/2+10)+15
      if n==0 then
        draw at xs,ys text=format("%iL",m)
      else
        draw at xs,ys text=format("%iR",m)
      endif
    enddo
  enddo
  draw mode=M_CENTERED
  draw at LEFTX/2,110+nfing*dy text="上面是正弦,"
  draw at LEFTX/2,120+nfing*dy text="下面是余弦"
  draw show
  err=0
  // Select antennas for each head. As we have at least two full rails, this is
  // not a problem. To reduce direct capacity, I always take right head. First
  // I look for the head on the opposite side, then for the first from the same
  // side.
  for i=0,i<nfing*2 && err==0,i++ do
    ant[i]=-1
    if used[i]==0 continue             // Head is excluded from test
    m=-1
    for j=0,j<nfing,j++ do
      if $LAY.side[i/2]==$LAY.side[j] continue
      if used[j*2+1]==0 continue
      m=j*2+1; break                   // Antenna on the opposite side found
    enddo
    if m<0 then
      for j=0,j<nfing,j++ do
        if $LAY.side[i/2]!=$LAY.side[j] continue
        if i/2==j continue
        if used[j*2+1]==0 continue
        m=j*2+1; break                 // Antenna on the same side found
      enddo
    endif
    if m<0 err=4                       // Unable to select antenna
    ant[i]=m
  enddo
  // Test loop.
  while err==0 do
    for i=0,i<nfing*2 && err==0,i++ do
      if used[i]==0 continue           // Head is excluded from test
      // Reset statistics.
      Initsigma(sf[i])
      Initsigma(cf[i])
      valid[i]=0;
      // Calculate coordinates and move heads, including those that do not
      // participate in measurements, into the requested positions.
      a=ant[i]
      n=sprintf(s,"M")
      for j=0,j<nfing*2 && err==0,j++ do
        if used[j]==0 continue
        if j==i then                   // Head under test
          if Convertpad(&x,&y,"GND",j,DELTA)<0.0 then
            err=5
          endif
        else if j==a then              // Antenna finger
          if Convertpad(&xa,&ya,"GND",j,DELTA)<0.0 then
            err=5
          endif
        else if (j & 1)==0 then        // Any remaining left head
          if Convertpad(&xt,&yt,"NOCT1",j,0.0)<0.0 then
            err=5
          else
            yt=$LAY.yoffset[j/2]/1000.0
            n=n+sprintf(s+n," %i[%g,%gH50A255]",j,xt,yt)
          endif
        else                           // Any remaining right head
          if Convertpad(&xt,&yt,"NOCT2",j,0.0)<0.0 then
            err=5
          else
            yt=$LAY.yoffset[j/2]/1000.0
            n=n+sprintf(s+n," %i[%g,%gH50A255]",j,xt,yt)
          endif
        endif
      enddo
      if err!=0 break
      // Attention, finger overlapping in Y may cause Bad coordinates on
      // A5/A6 during single-side adjustment if board is rotated by more than
      // 2*DELTA!
      if i<a && y>=ya then
        y=y-DELTA; ya=ya+DELTA
      else if i>a && y<=ya then
        y=y+DELTA; ya=ya-DELTA
      endif
      n=n+sprintf(s+n," %i[%g,%gA10H%gV%iP%i] %i[%g,%gA10H%gV%iP%i]",          \
        i,x,y,strokez,strokev,strokep,a,xa,ya,strokez,strokev,strokep)
      n=n+sprintf(s+n," F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",            \
        i,a,a,a,a,a,a,a,a,a,a,a,a)
      sprintf(s+n,"%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i)",          \
        a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a) // Total of 28*ant
      // Make a measurement.
      if SERV.Cmdimm(0,s)<0 err=2      // Send command
      t=Time()                         // Wait for answer
      while err==0 && $A[0].length==0 do
        if Time()-t>10000 err=1
        if Pressed(hexit) err=-1
        if Pressed(hcancel) err=9
        wait
      enddo
      if err==0 && ($A[0].answer!=S_MOVE || $A[0].subcmd!=M_FIELD) err=3
      if err!=0 break
      // Process answer. Note that shortcut bit must be set, or we have no
      // contact. I skip first 4 fields as possibly unreliable.
      if ($A[0].status & 0x0020)==0 then
        valid[i]=-1                    // No shortcut
      else
        for j=0,j<24,j++ do
          Addsigma(sf[i],$int2($A[0]+44+4*j))
          Addsigma(cf[i],$int2($A[0]+46+4*j))
        enddo
        valid[i]=1
      endif
      // Update display.
      draw window=hgraph
      for j=0,j<nfing*2,j++ do
        if used[j]==0 continue         // Head is excluded from test
        xs=(j & 1)==0?12:LEFTX/2+7
        ys=90+(j/2)*dy
        if $LAY.side[j/2]!=0 ys=ys+7
        draw color=(j==i?BLACK:WHITE) bkcolor=WHITE
        draw at xs+20,ys-dy*3/4 fillrect xs+130,ys-dy*3/4+dy
        if valid[j]==0 continue
        draw font=SMALLFONT
        if valid[j]<0 then
          draw mode=M_LEFT color=LIGHTRED at xs+50,ys text="No contact"
        else
          draw mode=M_RIGHT color=BLACK
          draw at xs+85,ys-6 text=format("%.1f",Getmean(sf[j]))
          draw at xs+85,ys+5 text=format("%.1f",Getmean(cf[j]))
          draw color=DARKGRAY
          draw at xs+122,ys-6 text=format("%3i",$EXTLAY.sinadj[j])
          if allowz draw at xs+122,ys+5 text=format("%3i",$EXTLAY.cosadj[j])
        endif
        draw show
      enddo
      // If there is a request to pause, move heads in pause positions and
      // wait till user allows movements.
      if Pressed(hpause) then
        change hpause text="继续"
        change hpause help="按继续验证"
        change hpause color=LIGHTRED
        change hpause bkcolor=YELLOW
        // Move heads in pause positions.
        for j=0,j<nfing*2,j=j+2 do
          if used[j]==0 continue
          if Convertpad(&xt,&yt,"NOCT1",j,0)<0.0 err=2
          yt=$LAY.yoffset[j/2]/1000.0
          if Convertpad(&xu,&yu,"NOCT2",j+1,0)<0.0 err=2
          yu=$LAY.yoffset[j/2]/1000.0
          sprintf(s,"M %i[%g,%gH50] %i[%g,%gH50] NOP",j,xt,yt,j+1,xu,yu)
          SERV.Cmdimm(32,s)
        enddo
        while err==0 do
          if Pressed(hpause) then
            break
          else if Pressed(hcancel) then
            err=9
          else if Pressed(hexit) then
            err=-1
          endif
          wait
        enddo
        change hpause text="暂停"
        change hpause help="按下可暂停验证"
        change hpause color=BLACK
        change hpause bkcolor=GRAY
      endif
    enddo
  enddo
  if err==9 err=0                      // Verification stopped
  if err<=0 goto finish
  clear hright
  change hinfo text="Alignment verification error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    if hlog!=NULL fprintf(hlog,"  Timeout while executing command\n")
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    if hlog!=NULL fprintf(hlog,"  Unable to send command\n")
    draw text="Unable to send command!"
    draw at 6,60 color=BLACK
    draw text="Most probably, this means some internal error in the script. "
  else if err==3 then
    if hlog!=NULL fprintf(hlog,"  Unexpected answer from crate\n")
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  else if err==4 then
    if hlog!=NULL fprintf(hlog,"  Can't assign head or antenna\n")
    draw text="Can't assign head or antenna!"
    draw at 6,60 color=BLACK
    draw text="Probably the configuration of your tester is not supported by "
    draw text="this scropt. Please report this event to atg. "
  else
    if hlog!=NULL fprintf(hlog,"  Internal error detected\n")
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Script was unable to determine the positions of contacts. "
    draw text="Please report this event to atg. "
  endif
  draw text="Verification interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="继续"
    help="按下继续"
  endc
  while 1 do
    if Pressed(hexit) then
      err=-1; break
    else if Pressed(hcont) then
      break
    endif
    wait
  enddo
finish:
  change hleft position=4,4,LEFTX,LEFTY
  destroy hgraph
  return err
end

// Asks for the next action. Returns action code ACT_xxx.
function int Selectaction()
  int y
  handle hadjust,hcphase,hcrtadj,htest,hshort
  handle hpot,hrneedle,hzp,hbdrill,hcancel
  clear hright
  change hinfo limits=0,0
  change hinfo text="选择项目"
  y=19
  hadjust=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="调整输入电容"
    help="按下调整电场容量并将新设置保存到布局"
  endc
  y=y+28
  if ($LAY.config & LC_OHTYPE)==LC_NOFIELD || backdrill!=0 disable hadjust
  hcphase=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="调整电容相位"
    help="按下可调整交流电容相位,对高频测试很重要"
  endc
  y=y+28
  if (measfeatures & MF_CCORR)==0 || backdrill!=0 disable hcphase
  hcrtadj=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="调整微短探测电容"
    help="按下可调整MSD容量并将新系数保存到布局"
  endc
  y=y+38
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || (measfeatures & MF_CRT)==0 ||   \
    backdrill!=0 disable hcrtadj
  htest=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="验证输入电容"
    help="按下可在不更改设置的情况下测试输入电容容量"
  endc
  y=y+28
  if ($LAY.config & LC_OHTYPE)==LC_NOFIELD || backdrill!=0 disable htest
  hshort=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="验证大电容"
    help="按下可在不更改设置的情况下测试高输入电容量"
  endc
  y=y+28
  if ($LAY.config & LC_OHTYPE)==LC_NOFIELD || backdrill!=0 disable hshort
  hpot=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="测试头部电位器"
    help="按下测试达拉斯电位计"
  endc
  y=y+38
  if ($LAY.config & LC_OHTYPE)==LC_PASSIVE || backdrill!=0 disable hpot
  hrneedle=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="调整针头电阻"
    help="主要用于LA测试过程中限制引脚的功率"
  endc
  y=y+28
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || $LAY.probetype!=1 ||            \
    (measfeatures2 & MF2_LACONT)==0 || backdrill!=0                            \
    disable hrneedle
  hzp=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="测试Z方向压力"
    help="按下测试压力传感器"
  endc
  y=y+28
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    ($EXTLAY.zheadtype & HCZ_VALID)==0 ||                                      \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHPS &&                         \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP)                           \
    disable hzp
  hbdrill=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="A调整背钻测试"
    help="按下可调整背钻针的电容量"
  endc
  y=y+28
  if (testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&           \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    testersides!=0x3 || ($EXTLAY.zheadtype & HCZ_VALID)==0 ||                  \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHSPL) || backdrill==0 ||       \
    boardtype==0 disable hbdrill
  hcancel=control BUTTON
    window=hright
    position=20,USERY+51,RIGHTX-40,22
    name="完成"
    help="按下以完成容量调整"
  endc
  while 1 do
    if Pressed(hexit) return ACT_QUIT
    if Pressed(hadjust) return ACT_ADJUST
    if Pressed(hcphase) return ACT_CPHASE
    if Pressed(hcrtadj) return ACT_CRTADJ
    if Pressed(htest) return ACT_CTEST
    if Pressed(hshort) return ACT_CSHORT
    if Pressed(hpot) return ACT_POT
    if Pressed(hrneedle) return ACT_RNEEDLE
    if Pressed(hzp) return ACT_ZPRESS
    if Pressed(hbdrill) return ACT_BDRILL
    if Pressed(hcancel) return ACT_CANCEL
    wait
  enddo
end

// Opens log file and writes header.
function int Openlogfile()
  int i,j
  char s[256],s1[128],s2[128]
  if hlog!=NULL return                 // Already open
  hlog=Fopen("ctest.txt","wt")
  if hlog==NULL return
  fprintf(hlog,                                                                \
    "\n           C A P A C I T Y   A D J U S T M E N T   L O G   F I L E")
  fprintf(hlog,"\n\n Version of script file:  %s\n",VERSION)
  Strtime(s,   "               Start on:  %a %d-%b-%Y %H:%M\n",0,0)
  fprintf(hlog,"%s",s)
  if testertype==TT_A2 then
    j=sprintf(s,"A2/%i",$LAY.nfing*2)
  else if testertype==TT_A2L then
    j=sprintf(s,"A2/%iL",$LAY.nfing*2)
  else if testertype==TT_A2H then
    j=sprintf(s,"A2/%iM",$LAY.nfing*2)
  else if testertype==TT_A3 || testertype==TT_A3L then
    j=sprintf(s,"A3/%i",$LAY.nfing*2)
  else if testertype==TT_A4 then
    j=sprintf(s,"A4/%i",$LAY.nfing*2)
  else if testertype==TT_A5 then
    if ($LAY.config & LC_TYPEMASK)==LC_NEWA1 then
      j=sprintf(s,"A1/%i",$LAY.nfing*2)
    else
      j=sprintf(s,"A5/%i",$LAY.nfing*2)
    endif
  else if testertype==TT_A5L then
    j=sprintf(s,"A5/%iL",$LAY.nfing*2)
  else if testertype==TT_A6 then
    j=sprintf(s,"A6/%i",$LAY.nfing*2)
  else if testertype==TT_S1 then
    j=sprintf(s,"S1/%i",$LAY.nfing*2)
  else if testertype==TT_S2 then
    j=sprintf(s,"S2/%i",$LAY.nfing*2)
  else if testertype==TT_S3 then
    j=sprintf(s,"S3/%i",$LAY.nfing*2)
  else if testertype==TT_A7 then
    j=sprintf(s,"A7/%i",$LAY.nfing*2)
  else if testertype==TT_A8 then
    j=sprintf(s,"A8/%i",$LAY.nfing*2)
  else
    j=sprintf(s,"Unknown")
  endif
  if $LAY.cameras==1 || $LAY.cameras==2 then
    j=j+sprintf(s+j," with 1 camera")
  else if $LAY.cameras==0 && $LAY.headcameras!=0 then
    j=j+sprintf(s+j," with head cameras")
  endif
  if testersides!=0x03 j=j+sprintf(s+j," (single-sided)")
  fprintf(hlog,"            Tester type:  %s\n",s)
  Splittext(crateversion,50,s1,s2)
  fprintf(hlog,"       Crate controller:  %s\n",s1)
  if s2[0]!='\0' fprintf(hlog,"                          %s\n",s2)
  Splittext(layoutversion,50,s1,s2)
  fprintf(hlog,"                 Layout:  %s\n",s1)
  if s2[0]!='\0' fprintf(hlog,"                          %s\n",s2)
  Splittext(headversion,50,s1,s2)
  fprintf(hlog,"        Head controller:  %s\n",s1)
  if (usesides==0x1) then
    fprintf(hlog,"        Sides to adjust:  Top\n")
    fprintf(hlog,"        Rails to adjust:  %i to %i\n",firstrail,lastrail)
  else if (usesides==0x2) then
    fprintf(hlog,"        Sides to adjust:  Bottom\n")
    fprintf(hlog,"        Rails to adjust:  %i to %i\n",                       \
    firstrail+$LAY.nfing/2,lastrail+$LAY.nfing/2)
  else if (usesides==0x3) then
    fprintf(hlog,"        Sides to adjust:  Top and bottom\n")
    fprintf(hlog,"        Rails to adjust:  %i(%i) to %i(%i)\n",               \
    firstrail,firstrail+$LAY.nfing/2,lastrail,lastrail+$LAY.nfing/2)
  else
    fprintf(hlog,"        Sides to adjust:  None\n")
  endif
  if ($GLOBAL.debugmode & 0x20BF)!=0 || ($GLOBAL.videomode & 0x20BF)!=0 ||     \
    $GLOBAL.disabledrails!=0 || $uint4($GLOBAL+280)!=0 then
    fprintf(hlog,"Debug mode bits (heads):  0x%04X\n",$GLOBAL.debugmode)
    fprintf(hlog," Debug mode bits (cams):  0x%04X\n",$GLOBAL.videomode)
    fprintf(hlog,"         Disabled rails:  0x%08X\n",$GLOBAL.disabledrails)
    fprintf(hlog,"  Disabled measurements:  0x%08X\n",$uint4($GLOBAL+280))
  endif
  fprintf(hlog,"               Z stroke:  %i mm/s\n",strokev)
  fprintf(hlog,"             Z pressure:  %i gram\n",strokep)
  fprintf(hlog,"               Z height:  %.1f mm\n",strokez)
  if simplemode then
    fprintf(hlog,"        Adjustment mode:  Simple\n")
  else
    fprintf(hlog,"        Adjustment mode:  All options\n")
  endif
  i=Readtemperature()
  fprintf(hlog,"     Tester temperature:  ")
  if i>=10 && i<990 then
    fprintf(hlog,"%.1f C\n",i/10.0)
  else
    fprintf(hlog,"Unable to measure\n")
  endif
  fprintf(hlog,"\n--------------------------------------")
  fprintf(hlog,"---------------------------------------\n\n")
end

// Closes log file.
function int Closelogfile()
  char s[256]
  if hlog==NULL return
  Strtime(s,"              Finish on:  %a %d-%b-%Y %H:%M",0,0)
  fprintf(hlog,"\n%s\n",s)
  Fclose(hlog)
  hlog=NULL
end

// Unloads board from the shuttle. Used in the case of L&M automation. Returns
// -1 if user interrupted the script and 0 in any other case.
function int UnloadboardLM()
  int i,j,t
  char buf[64],errtxt[256]
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO                                    \
    return 0                           // Does not apply
  // Check whether there is a board in the shuttle. It may happen that previous
  // test was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  Drawboard()
  // Make soft reset before sending commands to automation directly: heads may
  // still move!
  clear hright
  change hinfo limits=0,0
  change hinfo text="软件复位"
  SYS.Softimm(32)
  t=Time(); i=0
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("等待软件复位 - %i s",j)
      i=j
    endif
    if j>15 return 0                   // Too long soft reset
    wait
  enddo
  change hinfo limits=0,0
  change hinfo text="Unloading board..."
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Capacity adjustment board will be unloaded. To "
  draw text="avoid damages, please remove it from the shuttle."
  draw show
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO &&           \
    pulledshuttle>=0                                                           \
  then
    sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i 2",pulledshuttle)
    i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
    if i<0 return -1
    pulledshuttle=-1
  endif
  // For the case that tester is in the adjustment mode.
  i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,5)
  if i<0 return -1
  SYS.Killimm(32)
  buf[0]=S_LOCKDOOR
  buf[1]=0                             // Unlock door
  SYS.Sendimm(32,2,buf)
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  return 0
end

// Warns user about unloading board from the shuttle. Used in the case of EPCOS
// tester. Returns -1 if user interrupted the script and 0 in any other case.
function int UnloadboardEPCOS()
  handle hok
  if ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO then
    return 0                           // Does not apply
  endif
  change hinfo limits=0,0
  change hinfo text="Please remove holder!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please don't forget to remove capacity adjustment board and its "
  draw text="holder from the shuttle. " color=LIGHTRED text="Attempt to "
  draw text="unlock table when holder is installed may seriously damage the "
  draw text="tester!"
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="确定"
    help="按下继续"
  endc
  while 1 do
    if Pressed(hexit) return -1        // Interrupt
    if Pressed(hok) break
    wait
  enddo
  return 0
end

// Warns user that layout is not updated.
function int Warnoperator()
  handle hok
  change hinfo limits=0,0
  change hinfo text="布局更新失败!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="电容校验失败,布局文件未更新。\n"
  draw text="请解决问题后重新校验!\n"
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="再见!"
    help="点击关闭程序"
  endc
  while 1 do
    if Pressed(hexit) return -1        // Interrupt
    if Pressed(hok) break
    wait
  enddo
  return 0
end

#define NZ             41              // Number of Z points in backdrill

float bdc[16][8][NZ][5]                // C[baserail][hd][point][stat], fF
float bdcmax[16][8]                    // Maximum C [baserail][hd]
float bdzmax[16][8]                    // Maximum Z [baserail][hd]

// Service function, draws backdrill capacities in the graph window that covers
// the whole left pane. If usetop is 0, displays rails baserail and opposite,
// otherwise baserail, baserail+1 and two rails on the opposite side.
function int Drawbdc(handle hgraph,int baserail,int usetop)
  int j,n,k,head,x,y,x0,y0,first
  int color[8] = {                                                             \
    BLACK, LIGHTRED, GREEN, BLUE, MAGENTA, BROWN, DARKGRAY, STRANGE }
  float c,z,ymax,scalex,scaley
  x0=30; y0=300                        // Point (0,0), pixels
  ymax=45.0                            // Max capacity in femtofarad
  draw window=hgraph color=WHITE bkcolor=WHITE clear
  draw color=BLACK at x0-1,35 to x0-1,y0+1 to LEFTX-15,y0+1
  scalex=(LEFTX-15-x0)/4.0             // Pixel per millimeter
  scaley=(y0-35)/ymax                  // Pixel per femtofarad
  draw font=SMALLFONT mode=M_RIGHT
  draw at x0-3,35 text="C, fF"
  for c=0.0,c<=ymax,c=c+5.0 do
    y=y0-c*scaley
    draw at x0-1,y to x0-5,y
    draw at x0-6,y+7 text=format("%g",c)
  enddo
  draw at LEFTX-10,y0-1 text="Z, mm"
  draw mode=M_CENTERED
  for z=0,z<=4.0,z=z+0.5 do
    x=x0+z*scalex
    draw at x,y0+1 to x,y0+5
    draw at x+1,y0+17 text=format("%g",z)
  enddo
  n=0
  for k=0,k<8,k++ do
    if (k & 0x02)!=0 && usetop==0 continue
    head=baserail*2+(k & 0x03)
    if (k & 0x04) head=head+$LAY.nfing
    if (backdrill & (1<<head))==0 continue
    draw color=color[n] mode=M_LEFT
    draw at LEFTX-25,30+n*15
    draw text=format("%i%s",head/2,(head & 1?"R":"L"))
    first=1
    for j=0,j<NZ,j++ do
      if Getcount(bdc[baserail,k,j])==0 continue
      c=Getmean(bdc[baserail,k,j])
      z=4.0-j*0.1
      x=x0+z*scalex
      y=y0-c*scaley
      if first then
        draw at x,y
        first=0
      else
        draw to x,y
      endif
    enddo
    n++
  enddo
  draw show
end

// Adjusts capacities and Z coordinate corrections for the backdrill needles.
// Only works for testers with two top and two bottom rails, and only with the
// combo board.
function int Adjustbackdrill()
  int i,j,k,n,x,y,g,status,rail,head,prevhead,shield,ant,side,problem
  int userail[16],usenext[16],nuserail,uselist,viewed[2],verify,btndx
  int t,channel,newchannel,group,prevgroup,videosizex,videosizey,nrep
  int hole,moved,changed,movecam,halves,ntested,ntotal,jmax,ntop,nbot
  float cexp,zexp,cap,z,orgx[16],orgy[16],posx[2][16],posy[2][16],step
  float a,angle,zoom,xs,ys,xa,ya,xsc,ysc,dx,dy,limit[41],c[41],data[7]
  float meanctop,meancbot,meanztop,meanzbot,factor
  char s[1024],text[64],buf[1024],holename[8]
  handle hcexp,hzexp,hhole[2][16],hx,hy,hu,hl,hr,hd,hok,hverify,hcancel
  handle hpad[4],hgraph,hview,hlivevideo,hzoom,hinterrupt
  if (testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&           \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    testersides!=0x3 || ($EXTLAY.zheadtype & HCZ_VALID)==0 ||                  \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHSPL) || backdrill==0 ||       \
    boardtype==0 return 0
  // Ask for the expected capacity of the needle. All capacities will be
  // adjusted to this value.
  change hinfo limits=0,0
  change hinfo text="Set capacity"
  Drawboard()
  clear hright
  draw window=hright font=TIMESFONT color=BLACK wrap=RIGHTX-5 at 6,30
  draw text="Please specify expected capacity of the needle and Z coordinate "
  draw text="of the peak. They stay on the sticker attached to the board. "
  draw text="Script will attempt to adjust all needles to these values. "
  draw text="Typical capacity is 25 or 40 femtofarad and typical Z coordinate "
  draw text="is 2 mm."
  draw font=INFOFONT at 39,160 text="Capacity ="
  draw at 193,160 text="fF"
  draw font=INFOFONT at 45,190 text="Peak Z ="
  draw at 193,190 text="mm"
  draw show
  cexp=40.0
  zexp=2.0
  hole=1
  getini("Cadjust","Backdrill capacity","%f,%f,%i",&cexp,&zexp,&hole)
  hcexp=control EDIT
    window=hright
    position=105,140,80,25
    text=format("%g",cexp)
    help="背钻针头的预期电容量,fF"
    font=MEDIUMFONT
  endc
  hzexp=control EDIT
    window=hright
    position=105,170,80,25
    text=format("%g",zexp)
    help="预期最大承载力的Z坐标,mm"
    font=MEDIUMFONT
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="确定"
    help="按下接受此容量"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="取消"
    help="按下可返回主菜单"
  endc
  status=1
  while 1 do
    // This is a script. Wasting of CPU clocks is OK. Who cares?
    Text(hcexp,s); cap=0.0; sscanf(s,"%f",&cap)
    Text(hzexp,s); z=0.0; sscanf(s,"%f",&z)
    if cap<20.0 || cap>60.0 || z<1.0 || z>3.0 then
      if status==1 disable hok
      status=0
    else
      if status==0 enable hok
      status=1
    endif
    if Pressed(hok) && status!=0 then
      cexp=cap
      zexp=z
      break
    else if Pressed(hcancel) then
      return 0
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
  // Find sets of rails to be adjusted. Here userail[]=0 covers rails 0 and 1
  // on the top and their counterparts on the bottom (in this case usenext[]
  // is 1), userail[]=2 - rails 2 and 3 (usenext[] is 3), and so on. There are
  // nuserail groups in total. usenext[]=-1 means that only one rail will be
  // adjusted.
  nuserail=0
  uselist=0
  problem=0
  ntotal=0                             // Progress bar only
  for rail=0,rail<$LAY.nfing,rail++ do
    if used[rail*2]==0 continue
    if (backdrill & (0x3<<(rail*2)))==0 continue
    if nuserail>0 && $LAY.side[rail+1]!=0 break
    if nuserail>0 && used[rail*2+2]==0 break
    userail[nuserail]=rail
    usenext[nuserail]=-1
    uselist=uselist|(1<<nuserail)
    nuserail++
    if backdrill & (0x1<<(rail*2)) ntotal++
    if backdrill & (0x2<<(rail*2)) ntotal++
    if backdrill & (0x1<<(rail*2+$LAY.nfing)) ntotal++
    if backdrill & (0x2<<(rail*2+$LAY.nfing)) ntotal++
    if $LAY.side[rail+1]!=0 break
    if rail==$LAY.nfing-1 break
    if used[rail*2+2]==0 break
    if (backdrill & (0x3<<(rail*2+2)))==0 break
    usenext[nuserail-1]=rail+1
    if backdrill & (0x1<<(rail*2+2)) ntotal++
    if backdrill & (0x2<<(rail*2+2)) ntotal++
    if backdrill & (0x1<<(rail*2+2+$LAY.nfing)) ntotal++
    if backdrill & (0x2<<(rail*2+2+$LAY.nfing)) ntotal++
  enddo
  if nuserail==0 then
    problem=4
    goto report
  endif
  // Get hole to test.
  if boardtype!=2 && boardtype!=3 then
    hole=1
    Strcpy(holename,"HOLE2")
  else
    change hinfo limits=0,0
    change hinfo text="Select hole"
    clear hright
    draw window=hright font=TIMESFONT color=BLACK wrap=RIGHTX-5 at 6,30
    draw text="Select hole you are going to use for the calibration. Default "
    draw text="is hole 2 (0.6 mm)."
    draw show
    for i=0,i<4,i++ do
      hpad[i]=control RADIO
        window=hright
        position=73,90+i*24,120,20
        text=format("Hole %i (%.1f mm)",i+1,i*0.1+0.5)
        help=format("按下选择孔 %i (%.1f mm)",i+1,i*0.1+0.5)
        mode=(i==hole?M_CHECKED:0)
      endc
    enddo
    hok=control BUTTON
      window=hright
      position=RIGHTX/2-60,USERY,120,24
      name="确定"
      help="接受选择"
    endc
    while 1 do
      if Pressed(hexit) then
        return -1
      else if Pressed(hok) then
        break
      endif
      wait
    enddo
    for hole=0,hole<4,hole++ do
      if Status(hpad[hole])!=0 break
    enddo
    if hole>=4 return 0
    sprintf(holename,"HOLE%i",hole+1)
  endif
  setini("Cadjust","Backdrill capacity","%f,%f,%i",cexp,zexp,hole)
  // Scan hole positions.
  change hinfo limits=0,0
  change hinfo text="Find backdrill holes"
  clear hleft
  clear hright
  draw window=hright font=TIMESFONT color=BLACK wrap=RIGHTX-5 at 6,30
  draw text="Please find, as precisely as possible, the exact locations of "
  draw text="the backdrill holes on both sides of the board. Press "
  draw font=MAINFONT text="OK " font=TIMESFONT text="when ready."
  btndx=(RIGHTX-20-(nuserail-1)*5)/nuserail
  if btndx>120 btndx=120
  x=(RIGHTX-(nuserail-1)*5-btndx*nuserail)/2
  for i=0,i<nuserail,i++ do
    rail=userail[i]
    for j=0,j<2,j++ do
      if usenext[i]<0 then
        sprintf(s,"rail %i",rail)
        sprintf(text,"%s %i",j==0?"Top":"Bot",rail)
      else
        sprintf(s,"rails %i/%i",rail,rail+1)
        sprintf(text,"%s %i/%i",j==0?"Top":"Bot",rail,rail+1)
      endif
      hhole[j][i]=control BUTTON
        window=hright
        position=x+i*(btndx+5),74+j*32,btndx,24
        text=text
        help=format("按此按钮可定位%s的%s一侧的孔",               \
          j==0?"top":"bottom",s)
        color=BLACK
        bkcolor=LIGHTGRAY
      endc
    enddo
  enddo
  draw color=BLACK font=INFOFONT
  draw at 145,USERY-81 text="X="
  hx=control TEXT
    window=hright
    position=169,USERY-100,RIGHTX-180,24
    help="相机的实际X坐标, mm"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 145,USERY-51 text="Y="
  hy=control TEXT
    window=hright
    position=169,USERY-70,RIGHTX-180,24
    help="相机的实际Y坐标, mm"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  hu=control BUTTON
    window=hright
    position=60,USERY-78,45,45
    name="上"
    help="点击上移相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hl=control BUTTON
    window=hright
    position=13,USERY-30,45,45
    name="左"
    help="点击左移相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hr=control BUTTON
    window=hright
    position=107,USERY-30,45,45
    name="右"
    help="点击右移相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hd=control BUTTON
    window=hright
    position=60,USERY+17,45,45
    name="下"
    help="点击下移相机"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hok=control BUTTON
    window=hright
    position=169,USERY-27,RIGHTX-180,24
    name="调试"
    help="按下可调整背钻能力"
  endc
  disable hok
  hverify=control BUTTON
    window=hright
    position=169,USERY+5,RIGHTX-180,24
    name="验证"
    help="按下可以验证背钻能力"
  endc
  disable hverify
  hcancel=control BUTTON
    window=hright
    position=169,USERY+37,RIGHTX-180,24
    name="取消"
    help="按下可返回主菜单"
  endc
  draw show
  hview=control CHILD
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    bkcolor=VIDEOFILL
    help="相机中实时影像"
  endc
  Bccreate(hview,-1,-1,channel,1)
  hzoom=control CUSTOMBOX
    window=hview
    position=235,303,80,21
    name="放大"
    help="勾选提升放大倍数到2"
    color=BROWN
  endc
  // Get hole coordinates.
  for i=0,i<nuserail,i++ do
    rail=userail[i]
    Convertpad(orgx+i,orgy+i,holename,rail*2,0.0)
    sprintf(text,"Backdrill hole[%i]",rail)
    getini("Cadjust",text,"%f,%f,%f,%f",                                       \
      posx[0]+i,posy[0]+i,posx[1]+i,posy[1]+i)
    posx[0][i]=posx[0][i]+orgx[i]
    posy[0][i]=posy[0][i]+orgy[i]
    posx[1][i]=posx[1][i]+orgx[i]
    posy[1][i]=posy[1][i]+orgy[i]
  enddo
  viewed[0]=0; viewed[1]=0
  moved=1; changed=1                   // Camera moved, rail changed
  step=0.005                           // Search step
  group=0; prevgroup=-1; side=0
  channel=-1                           // As yet undefined
  change hhole[side][group] color=LIGHTRED
  change hhole[side][group] bkcolor=YELLOW
  viewed[side]=viewed[side]|(1<<group)
  SYS.Killimm(32); $A[32].length=1     // Mark answer as available
  verify=0                             // 0: correct backdrills, 1: verify
  while 1 do
    if Bcupdate()!=0 changed=1
    if Pressed(hexit) then
      return -1
    else if Pressed(hu) then
      posy[side][group]=Max(orgy[group]-3.0,                                   \
        Min(posy[side][group]+step,orgy[group]+3.0))
      moved=1
    else if Pressed(hl) then
      posx[side][group]=Max(orgx[group]-3.0,                                   \
        Min(posx[side][group]-step,orgx[group]+3.0))
      moved=1
    else if Pressed(hr) then
      posx[side][group]=Max(orgx[group]-3.0,                                   \
        Min(posx[side][group]+step,orgx[group]+3.0))
      moved=1
    else if Pressed(hd) then
      posy[side][group]=Max(orgy[group]-3.0,                                   \
        Min(posy[side][group]-step,orgy[group]+3.0))
      moved=1
    else if Pressed(hzoom) then
      changed=1
    else if Pressed(hok) && viewed[0]==uselist && viewed[1]==uselist then
      // Holes located.
      for i=0,i<nuserail,i++ do
        rail=userail[i]
        sprintf(text,"Backdrill hole[%i]",rail)
        setini("Cadjust",text,"%f,%f,%f,%f",                                   \
          posx[0][i]-orgx[i],posy[0][i]-orgy[i],                               \
          posx[1][i]-orgx[i],posy[1][i]-orgy[i])
        ;
      enddo
      break
    else if Pressed(hverify) && viewed[0]==uselist && viewed[1]==uselist then
      // Holes located, go to verification.
      for i=0,i<nuserail,i++ do
        rail=userail[i]
        sprintf(text,"Backdrill hole[%i]",rail)
        setini("Cadjust",text,"%f,%f,%f,%f",                                   \
          posx[0][i]-orgx[i],posy[0][i]-orgy[i],                               \
          posx[1][i]-orgx[i],posy[1][i]-orgy[i])
        ;
      enddo
      verify=1
      break
    else if Pressed(hcancel) then
      return 0
    endif
    for i=0,i<nuserail,i++ do
      for j=0,j<2,j++ do
        if Pressed(hhole[j][i]) then
          change hhole[j][i] color=LIGHTRED
          change hhole[j][i] bkcolor=YELLOW
          side=j
          group=i
          viewed[j]=viewed[j]|(1<<i)
          if viewed[0]==uselist && viewed[1]==uselist then
            enable hok
            enable hverify
          endif
          moved=1
        endif
      enddo
    enddo
    if moved then
      // Coordinates changed.
      change hx text=format("%7.3f",posx[side][group])
      change hy text=format("%7.3f",posy[side][group])
      head=Camerafromyside(posy[side][group],side,&newchannel,&angle)
      if newchannel!=channel then
        channel=newchannel
        changed=1
      endif
      moved=0
      movecam=1
    endif
    if movecam!=0 && $A[32].length!=0 then
      // Camera movement requested and previous movement is finished.
      if $LAY.cameras!=0 then        // Dedicated camera
        sprintf(s,"M %i(%g,%g) NOP",head,posx[side][group],posy[side][group])
      else                           // Head camera, move other heads away
        n=sprintf(s,"M")
        for i=0,i<$LAY.nfing*2,i++ do
          if i==head continue
          n=n+sprintf(s+n," %i(Z)",i)
        enddo
        sprintf(s+n," @%i[%g,%g] NOP",head,posx[side][group],posy[side][group])
      endif
      SERV.Cmdimm(32,s)
      movecam=0
    endif
    if changed then
      // Rail or illumination changed, redraw and update video viewer and
      // set new illumination.
      SYS.Videosize(channel,&videosizex,&videosizey,&i)
      if videosizex==0 || videosizey==0 then
        zoom=0.5
      else
        zoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
      endif
      if Status(hzoom)!=0 zoom=zoom*2.0
      Bcsetcam(channel)
      SYS.Videoangle(hlivevideo,channel,side,zoom,                             \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      sprintf(s,"Video scale[%i]",side)
      xsc=6.4; ysc=6.4                 // Default video magnification
      getini("System",s,"%f,%f",&xsc,&ysc)
      xsc=Max(0.2,Min(12.0,xsc))
      ysc=Max(0.2,Min(12.0,ysc))
      x=(LEFTX-10)/2; y=288/2
      draw window=hlivevideo color=VIDEOFILL bkcolor=VIDEOFILL clear
      draw color=LIGHTRED
      draw at x-20,y to x-5,y at x+6,y to x+21,y
      draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
      draw at x,y ellipse 512./xsc*zoom*(hole+5)/6.,512./ysc*zoom*(hole+5)/6.
      draw show
      if prevhead!=head && prevhead>=0 then
        sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",prevhead)
        SERV.Cmdimm(33,s)
      endif
      sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
      SERV.Cmdimm(33,s)
      prevhead=head
      changed=0
    endif
    wait
  enddo
  // Prepare for adjustment.
  nrep=8
  clear hleft
  hgraph=control GRAPH
    window=hleft
    position=0,0,LEFTX,LEFTY
    color=BLACK
    bkcolor=WHITE
    help="中间结果"
  endc
loop:
  // Adjustment/verification loop.
  Memset(bdc,0,Sizeof(bdc))
  ntested=0                            // Progress bar only
  for g=0,g<nuserail,g++ do
    clear hright
    if verify then
      change hinfo text="Verifying capacities"
    else
      change hinfo text="Measuring capacities"
    endif
    draw window=hright font=TIMESFONT color=BLACK wrap=RIGHTX-5 at 6,30
    if verify then
      draw text="Verifying capacity profiles. Please wait..."
    else
      draw text="Measuring capacity profiles. Please wait..."
    endif
    draw show
    hinterrupt=control BUTTON
      window=hright
      position=RIGHTX/2-60,USERY,120,24
      name="中断"
      help="按下可中断背钻调整"
    endc
    if g==0 then
      group=(nuserail-1)/2
      halves=0x03                      // Adjust all rails in the group
    else if g<=(nuserail-1)/2 then
      group=(nuserail-1)/2-g
      halves=0x01                      // Adjust only bottom rails in the group
    else
      group=g
      halves=0x02                      // Adjust only top rails in the group
    endif
    Drawbdc(hgraph,userail[group],usenext[group])
    for k=0,k<8,k++ do
      if (k & 0x02)!=0 && usenext[group]==0 continue
      head=userail[group]*2+(k & 0x03)
      if (k & 0x04) head=head+$LAY.nfing
      if (backdrill & (1<<head))==0 continue
      shield=head^1
      ant=head+$LAY.nfing              // This is a double-sided tester
      if ant>=$LAY.nfing*2 ant=ant-$LAY.nfing*2
      if (backdrill & (1<<ant)) ant=ant^1
      if boardtype==2 || boardtype==3 then
        if (shield & 0x01)==0 then
          Convertpad(&xs,&ys,"BDREF",shield,DELTA)
        else
          Convertpad(&xs,&ys,"HOLE6",shield,DELTA)
          xs=xs+1.25
        endif
      else
        xs=Getpadx(holename)
        if (shield & 0x01)==0 then
          xs=xs-1.25
        else
          xs=xs+1.25
        endif
        if (k & 0x02)==0 then
          ys=$LAY.top[userail[group]]/1000.0-                                  \
          (boardtype==2 || boardtype==3?250.0:155.0)+1.0-yshift
        else
          ys=$LAY.bottom[userail[group]+1]/1000.0+                             \
          (boardtype==2 || boardtype==3?250.0:155.0)-1.0-yshift
        endif
        Convert(&xs,&ys,xs,ys,0.0)
      endif
      if boardtype==2 || boardtype==3 then
        Convertpad(&xa,&ya,"BDREF",ant,DELTA)
      else
        xa=Getpadx(holename)
        if (ant & 0x01)==0 then
          xa=xa-1.25
        else
          xa=xa+1.25
        endif
        if (k & 0x02)==0 then
          ya=$LAY.top[userail[group]]/1000.0-                                  \
          (boardtype==2 || boardtype==3?250.0:155.0)+1.0-yshift
        else
          ya=$LAY.bottom[userail[group]+1]/1000.0+                             \
          (boardtype==2 || boardtype==3?250.0:155.0)-1.0-yshift
        endif
        Convert(&xa,&ya,xa,ya,0.0)
      endif
      // Move all non-participating heads in home position.
      for i=0,i<$LAY.nfing*2,i++ do
        if i==head || i==ant || i==shield continue
        sprintf(s,"M %i(Z) NOP",i)
        SERV.Cmdimm(33,s)
      enddo
      delay 250
      side=$LAY.side[head/2]
      if verify==0 then
        // Measure signal without shield. This will give us the values of no
        // contact. Good signal is at least 30-40% lower.
        for i=0,i<4,i++ do             // 4 attempts to get reliable measurement
          problem=0
          dx=Random(DELTA)-DELTA/2.0
          dy=Random(DELTA)-DELTA/2.0
          n=sprintf(s,"M %i[%g,%g,1.5H%gV%gP%gA5]",                            \
            head,posx[side][group],posy[side][group],strokez,strokev,strokep)
          n=n+sprintf(s+n," %i[%g,%gH%gV%gP%g]",                               \
            ant,xa+dx,ya+dy,strokez,strokev,strokep)
          n=n+sprintf(s+n," %i[%g,%gH%gV%gP%g]",                               \
            shield,xs+dx,ys+dy,strokez,strokev,strokep)
          n=n+sprintf(s+n," COMPX(BD(%i,%i,XL,F=4000) BZ(%i,Z=4.5,ZMIN=4)",    \
            head,ant,head)
          for j=0,j<NZ,j++ do
            n=n+sprintf(s+n," BC(%i,Z=%g)",head,4.0-j*0.1)
          enddo
          sprintf(s+n,")")
          SYS.Killimm(32)
          SERV.Cmdimm(32,s)
          t=Time()
          while $A[32].length==0 do
            if Pressed(hexit) return -1
            if Pressed(hinterrupt) return 0
            if (Time()-t)>5000 break   // Timeout 5 seconds
            wait
          enddo
          if $A[32].length==0 then
            problem=1                  // Timeout
            continue
          else if $A[32].length!=346 || $A[32].answer!=S_MOVE then
            problem=2                  // Invalid answer
            continue
          endif
          for j=0,j<NZ,j++ do
            status=$int4($A[32]+22+j*8)
            if (status & 0x000089F1)!=0 break
            cap=$float4($A[32]+18+j*8)*1.0e15
            if cap<5.0 break
          enddo
          if j<NZ then
            problem=3                  // No contact in antenna or bad meas
          endif
          if problem==0 break
        enddo
        if problem!=0 goto report
        // Get reference signal without shield for this head, reduced by 20%
        // security margin. All measurements exceeding this threshold were made
        // without proper contact in shield.
        for j=0,j<NZ,j++ do
          limit[j]=$float4($A[32]+18+j*8)*1.0e15*0.80
        enddo
      endif
      // Send nrep measurements, each time waiting for answer.
      for i=0,i<(verify?1:nrep),i++ do
        problem=0
        dx=Random(DELTA)-DELTA/2.0
        dy=Random(DELTA)-DELTA/2.0
        change hinfo limits=i+ntested*nrep,ntotal*nrep
        n=sprintf(s,"M %i[%.3f,%.3f,1.5H%gV%gP%gA5]",                          \
          head,posx[side][group],posy[side][group],strokez,strokev,strokep)
        n=n+sprintf(s+n," %i[%.3f,%.3fH%gV%gP%g]",                             \
          ant,xa+dx,ya+dy,strokez,strokev,strokep)
        n=n+sprintf(s+n," %i[%.3f,%.3fH%gV%gP%g]",                             \
          shield,xs+dx,ys+dy,strokez,strokev,strokep)
        n=n+sprintf(s+n," COMPX(BD(%i,%i,%i,XL,F=4000) BZ(%i,Z=4.5,ZMIN=4)",   \
          head,ant,shield,head)
        for j=0,j<NZ,j++ do
          n=n+sprintf(s+n," BC(%i,Z=%g)",head,4.0-j*0.1)
        enddo
        sprintf(s+n,")")
        SYS.Killimm(i)
        SERV.Cmdimm(i,s)
        t=Time()
        while $A[i].length==0 do
          if Pressed(hexit) return -1  // Operator interrupted alignment
          if Pressed(hinterrupt) return 0
          if (Time()-t)>5000 break     // Timeout 5 seconds
          wait
        enddo
        if $A[i].length==0 then
          problem=1                    // Timeout
          goto report
        else if $A[i].length!=346 || $A[i].answer!=S_MOVE then
          problem=2                    // Invalid answer
          goto report
        endif
        for j=0,j<NZ,j++ do
          status=$int4($A[i]+22+j*8)
          if (status & 0x000089F1)!=0 continue
          cap=$float4($A[i]+18+j*8)*1.0e15
          z=4.0-j*0.1
          if verify==0 && ((z>=1.0 && cap<1.0) || cap>limit[j])                \
            continue
          Addsigma(bdc[userail[group]][k][j],cap)
        enddo
        Drawbdc(hgraph,userail[group],usenext[group])
      enddo
      // Check whether data for the given head is valid and get peak values.
      if verify==0 then
        cap=0.0; jmax=-1
        for j=0,j<NZ,j++ do
          if Getcount(bdc[userail[group]][k][j])==0 break
          c[j]=Getmean(bdc[userail[group]][k][j])
          if c[j]>cap then
            cap=c[j]
            jmax=j
          endif
        enddo
        if j<NZ then
          problem=3                    // Bad measurements
          goto report
        endif
        if jmax<5 || jmax>35 then
          problem=5
          goto report
        endif
        data[0]=c[jmax-3]
        data[1]=c[jmax-2]
        data[2]=c[jmax-1]
        data[3]=c[jmax]
        data[4]=c[jmax+1]
        data[5]=c[jmax+2]
        data[6]=c[jmax+3]
        Parabint(data,7,&a,bdzmax[userail[group]]+k,bdcmax[userail[group]]+k)
        // Convert index to absolute Z coordinate in millimeters.
        bdzmax[userail[group],k]=4.0-(bdzmax[userail[group],k]+jmax)*0.1
      endif
      ntested++
    enddo
    Drawbdc(hgraph,userail[group],usenext[group])
    // Update layout.
    if verify==0 then
      ntop=0; meanctop=0.0; meanztop=0.0
      nbot=0; meancbot=0.0; meanzbot=0.0
      for k=0,k<8,k++ do
        if (k & 0x02)!=0 && usenext[group]==0 continue
        head=userail[group]*2+(k & 0x03)
        if (k & 0x04) head=head+$LAY.nfing
        if (backdrill & (1<<head))==0 continue
        if (k & 0x02)==0 then
          meancbot=meancbot+bdcmax[userail[group]][k]
          meanzbot=meanzbot+bdzmax[userail[group]][k]
          nbot++
        else
          meanctop=meanctop+bdcmax[userail[group]][k]
          meanztop=meanztop+bdzmax[userail[group]][k]
          ntop++
        endif
      enddo
      if nbot>0 then
        meancbot=meancbot/nbot
        meanzbot=meanzbot/nbot
      endif
      if ntop>0 then
        meanctop=meanctop/ntop
        meanztop=meanztop/ntop
      endif
      for k=0,k<8,k++ do
        if (k & 0x02)!=0 && usenext[group]==0 continue
        head=userail[group]*2+(k & 0x03)
        if (k & 0x04) head=head+$LAY.nfing
        if (backdrill & (1<<head))==0 continue
        if halves==0x03 then
          // First (base) hole, adjust to supplied values.
          factor=$uint2($EXT1+68+2*head)/10000.0;
          if factor==0.0 factor=1.0
          factor=factor*cexp/bdcmax[userail[group]][k]
          $uint2($EXT1+68+2*head)=Floor(factor*10000.0+0.5)
          z=$int2($EXT1+132+2*head)-bdzmax[userail[group]][k]*1000.0+          \
            zexp*1000.0
          $int2($EXT1+132+2*head)=Floor(z+0.5)
        else if halves==0x01 && meanctop!=0.0 then
          // Adjust to mean of top half.
          if (k & 0x02)!=0 continue
          factor=$uint2($EXT1+68+2*head)/10000.0;
          if factor==0.0 factor=1.0
          factor=factor*meanctop/bdcmax[userail[group]][k]
          $uint2($EXT1+68+2*head)=Floor(factor*10000.0+0.5)
          z=$int2($EXT1+132+2*head)-bdzmax[userail[group]][k]*1000.0+          \
            meanztop*1000.0
          $int2($EXT1+132+2*head)=Floor(z+0.5)
        else if halves==0x02 && meancbot!=0.0 then
          // Adjust to mean of bottom half.
          if (k & 0x02)==0 continue
          factor=$uint2($EXT1+68+2*head)/10000.0;
          if factor==0.0 factor=1.0
          factor=factor*meancbot/bdcmax[userail[group]][k]
          $uint2($EXT1+68+2*head)=Floor(factor*10000.0+0.5)
          z=$int2($EXT1+132+2*head)-bdzmax[userail[group]][k]*1000.0+          \
            meanzbot*1000.0
          $int2($EXT1+132+2*head)=Floor(z+0.5)
        endif
      enddo
      // Send layout to tester.
      Makelayoutcopy()
      Loadlayoutmeas(0,1)
    endif
  enddo
  // Save layout to disk.
  if verify==0 then
    Makelayoutcopy()
    layoutdiffers=1
    i=Loadlayoutmeas(1,1)
    if i!=0 then
      problem=6; head=-1               // Unable to send extended layout
      goto report
    endif
    layoutdiffers=0
  endif
  // Ask if user wants to verify corrected needles.
  change hinfo limits=0,0
  if verify then
    change hinfo text="Verification finished"
  else
    change hinfo text="Adjustment finished"
  endif
  clear hright
  draw window=hright font=TIMESFONT color=BLACK wrap=RIGHTX-5 at 6,30
  if verify==0 then
    draw text="Alignment of backdrill needles is finished. "
  endif
  draw text="Do you want to make a quick verification of the new corrections?"
  draw show
  x=(RIGHTX-(nuserail-1)*5-btndx*nuserail)/2
  for i=0,i<nuserail,i++ do
    rail=userail[i]
    if usenext[i]<0 then
      sprintf(s,"rail %i",rail)
      sprintf(text,"Rail %i",rail)
    else
      sprintf(s,"rails %i/%i",rail,rail+1)
      if nuserail<=3 then
        sprintf(text,"Rails %i/%i",rail,rail+1)
      else
        sprintf(text,"%i/%i",rail,rail+1)
      endif
    endif
    hhole[0][i]=control BUTTON
      window=hright
      position=x+i*(btndx+5),104,btndx,24
      text=text
      help=format("按下可查看%s和另一侧的结果",s)
      color=BLACK
      bkcolor=LIGHTGRAY
    endc
  enddo
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="验证"
    help="按下以验证针头对齐"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="完成"
    help="按下可返回主菜单"
  endc
  group=0
  Drawbdc(hgraph,userail[group],usenext[group])
  change hhole[0][group] color=LIGHTRED
  change hhole[0][group] bkcolor=YELLOW
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hok) then
      verify=1
      goto loop
    else if Pressed(hcancel) then
      break
    endif
    for i=0,i<nuserail,i++ do
      if Pressed(hhole[0][i]) && i!=group then
        change hhole[0][group] color=BLACK
        change hhole[0][group] bkcolor=LIGHTGRAY
        group=i
        Drawbdc(hgraph,userail[group],usenext[group])
        change hhole[0][group] color=LIGHTRED
        change hhole[0][group] bkcolor=YELLOW
      endif
    enddo
    wait
  enddo
  return 0
report:
  // Report error.
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT color=LIGHTRED wrap=RIGHTX-5 at 6,30
  if problem==1 then
    change hinfo text="Timeout"
    draw text="Timeout!\n\n"
    draw color=BLACK text="There were no answer from the tester within the "
    draw text="expected timeout."
  else if problem==2 then
    change hinfo text="Invalid answer"
    draw text="Invalid answer from the tester!\n\n"
    draw color=BLACK text="Please check whether tester is loaded and whether "
    draw text="embedded software supports backdrill needles."
  else if problem==3 then
    change hinfo text="Bad measurements"
    draw text="Bad measurements!\n\n"
    draw color=BLACK text="Either the contact is very unstable, or "
    draw text="measurements are very noisy, or tester is not calibrated and "
    draw text="cannot move backdrill needle inside the calibration hole."
  else if problem==4 then
    change hinfo text="Invalid configuration"
    draw text="Invalid configuration!\n\n"
    draw color=BLACK text="There are no rails that can be used for backdrill "
    draw text="adjustment. Please check layout."
  else if problem==5 then
    change hinfo text="Wrong maximum"
    draw text="Wrong maximum!\n\n"
    draw color=BLACK text="Capacity maximum is found on the wrong position. "
    draw text="Please check the needles."
  else
    change hinfo text="Unable to send layout"
    draw text="Unable to send extended layout to the tester!\n\n"
    draw color=BLACK text="Please contact atg to get updated version of "
    draw text="the script."
  endif
  draw show
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY,120,24
    name="确定"
    help="按下可以返回主菜单"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hok) then
      break
    endif
    wait
  enddo
  return 0
end

// Main routine.
function int main()
  int i,j,action
  hmain=control WINDOW
    window=NULL
    position=10,10,MAINX,MAINY
    name=format("电容校验v%s",VERSION)
    help=" "
    size=128
  endc
  hleft=control CHILD
    window=hmain
    position=5,5,LEFTX,LEFTY
    help=" "
    color=DARKGRAY
    size=8192
  endc
  hserv=control CHILD
    window=hmain
    position=SPLIT,5,RIGHTX,SERVY
    help=" "
    color=DARKGRAY
  endc
  hright=control CHILD
    window=hmain
    position=SPLIT,10+SERVY,RIGHTX,RIGHTY
    help=" "
    color=DARKGRAY
    size=1024
  endc
  hinfo=control PROGRESS
    window=hserv
    position=-1,-1,RIGHTX+2,SERVY+2
    text="欢迎使用!"
    help="电容校验当前状态"
    mode=M_PERCENT
    font=MEDIUMFONT
    limits=0,0
  endc
  hexit=control BUTTON
    window=hmain
    position=MAINX-84,MAINY-SERVY,80,SERVY-3
    name="退出"
    help="双击终止测试并关闭窗口"
    mode=M_DBLCLICK
  endc
  draw window=hmain bitmap=0,0,1,"bkground" show
  layoutchanged=0
  loadchanged=0
  globalerr=0
  simplemode=0
  pulledshuttle=-1
  individualbc=1                       // Individual brightness and contrast
  illtype=0x07                         // Top illumunation
  linewidth=0.300
  updatefocus[0]=1                     // Focus is not yet set
  updatefocus[1]=1
  Bcgetini()                           // Read brightness & contrast from .ini
  // If this script is called directly from the Test Player, default parameters
  // may be yet uninitialized.
  if $GLOBAL.defstroke==0 then
    $GLOBAL.defstroke=40
    $GLOBAL.defpressure=30
    $GLOBAL.defheight=5000
    $GLOBAL.defaccuracy=250
  endif
  Clearoversurface()                   // Clear contact-over-surface counters
  change hleft help="版权 (C) 2019 HengCe"
  draw window=hleft
  draw at 70,40 bitmap=0,0,0,"logo"
  draw color=DARKGRAY font=MEDIUMFONT mode=M_CENTERED
  draw at LEFTX/2,285 text="电容校验"
  draw at LEFTX/2,305 text=format("版本 %s",VERSION)
  draw show
  wideboard=0
  boardtype=0
  getini("Cadjust","Board type","%i,%i",&wideboard,&boardtype)
  delay 1000
  if Loadtester()!=0 goto badlayout    // Make sure that tester is loaded
reload:
  if Embedded()!=0 then
    SERV.Cmdimm(32,"$LIGHTS TESTING")  // Update state of traffic lights
  endif
  globalerr=globalerr & (~GE_BOOT)     // Tester is just loaded
  i=Checkgloberrors()                  // Check for errors except boot errors
  if i<0 goto badlayout                // Operator interrupted the test
  if i>0 goto reload                   // Try to reload tester
  i=Getlayout()                        // Get actually loaded layout
  if i<0 goto badlayout                // Operator interrupted the test
  if i>0 goto reload                   // Try to reload tester
  Makelayoutcopy()                     // Make layout copy to restore on failure
  layoutdiffers=0                      // Backup and tester layouts are same
  Getautomationtype()                  // Get type of automation
  if isauto==0 wideboard=0             // Just a precaution
  Recognizetester()                    // Determine type of the tester
  if testertype==TT_WRONG goto quit    // Don't know how to test
  Getfeatures()                        // Get features of crate & meas card
  if testertype==TT_A7 && testersides==0x03 && $LAY.nfing>=12 then
    boardtype=3                        // Only A7 XXXL board suits
    Memcpy(xname,xnamec,Sizeof(xname))
    linewidth=0.200
    rowdist=250.0                      // Distance between rows of pads
  else if testertype==TT_A7 && testersides==0x03 && $LAY.nfing>=6 then
    boardtype=2                        // Only A7 XXL board suits
    Memcpy(xname,xnamec,Sizeof(xname))
    linewidth=0.200
    rowdist=250.0                      // Distance between rows of pads
  else
    i=Selectboard()                    // Select board type
    if i<0 goto quit                   // Operator interrupted the test
    if boardtype==0 then
      Memcpy(xname,xnamed,Sizeof(xname))
    else
      Memcpy(xname,xnamec,Sizeof(xname))
    endif
    linewidth=0.300
    rowdist=155.0                      // Distance between rows of pads
  endif
  for i=0,i<NPOINT,i++ do              // Extract pad coordinates and values
    sscanf(xname[i]+7,"%f %f",xpos+i,value+i)
    for j=0,j<7,j++ do
      if xname[i][j]==' ' break
    enddo
    xname[i][j]='\0'                   // Limit pad names
  enddo
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) &&                                 \
    ($LAY.config & LC_OHTYPE)==LC_PHADJ                                        \
  then
    allowz=1                           // Phase potentiometer present
  else
    allowz=0                           // Phase potentiometer absent
  endif
  Drawboard()
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8 then
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,1")
  endif
  i=Simplemode()                       // Ask for most common task
  if i<0 goto quit                     // Operator interrupted the test
  if simplemode==0 then                // No handicaps if simple mode
    i=Setmode()                        // Set handicaps
    if i<0 goto quit                   // Operator interrupted the test
  endif
  usesides=usesides & testersides
  if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||           \
    testertype==TT_A2H || testertype==TT_A3 || testertype==TT_A3L ||           \
    testertype==TT_A4 then
    dadjfactors=DADJA2S
    dadjfactorc=0
  else
    dadjfactors=DADJA5S
    dadjfactorc=DADJA5C
  endif
reinstall:
  scanrail=-1
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    i=InstallboardLM()                 // Install board in L&M shuttle
  else if testertype==TT_S2 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO &&       \
    (automationtype==AUTO_S2LMSEMI || automationtype==AUTO_S2LMFULL) then
    i=InstallboardLM()                 // Install board in S2 shuttle
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    i=InstallboardLM()                 // Install board in split shuttle
  else if testertype==TT_A8 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO &&       \
    (automationtype==AUTO_A8LMMAN || automationtype==AUTO_A8LMSEMI ||          \
    automationtype==AUTO_A8LMFULL) then
    i=InstallboardLM()                 // Install board in A8a shuttle
  else if (testertype==TT_A7 || testertype==TT_A8) &&                          \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    i=InstallboardLM()                 // Install OlliBoard in split shuttle
  else if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    i=InstallboardEPCOS()              // Install board in EPCOS shuttle
  else if ((testertype==TT_A4 || testertype==TT_A6 || testertype==TT_S1) &&    \
    ($LAY.config & 0x0001C040)==0x00008040) then
    i=Installboard(1)                  // Install board on A4/A6 auto
  else
    i=Installboard(0)                  // Install board on other tester
  endif
  if i>0 goto reload                   // Bad or no answer, try to reload tester
  if i<0 goto quit                     // Operator interrupted the test
  i=Positionboard()                    // Manually find position of the board
  if i==2 goto reinstall               // Board position must be changed
  if i<0 goto quit                     // Operator interrupted the test
  i=Scanboard(i)                       // Find exact board position
  if i==1 goto reinstall               // Crosses not found, retry
  if i==2 goto quit                    // Operator stopped the test
  if i<0 goto quit                     // Operator interrupted the test
recheck:
  i=Electrocheck()                     // Check board presence electrically
  if i==1 goto reinstall               // Board position must be changed
  if i==2 goto recheck                 // Repeat electrical presence check
  if i<0 goto quit                     // Operator interrupted the test
  Drawboard()
  if hlog==NULL Openlogfile()          // Open log file
mainloop:
  if simplemode then                   // Simple mode: adjust C, phase, CRT
    i=Adjustfield(0)                   // If not applies, does nothing
    if i<0 goto quit
    if i!=0 then
      Warnoperator()
      goto quit
    endif
    i=Adjustfield(2)                   // If not applies, does nothing
    if i<0 goto quit
    if i!=0 then
      Warnoperator()
      goto quit
    endif
    i=Adjustcphase()                   // If not applies, does nothing
    if i<0 goto quit
    if i!=0 then
      Warnoperator()
      goto quit
    endif
    i=Adjustcrt()                      // If not applies, does nothing
    if i<0 goto quit
    if i!=0 then
      Warnoperator()
      goto quit
    endif
    i=Needleresistance()               // If not applies, does nothing
    if i<0 goto quit
    if i!=0 then
      Warnoperator()
      goto quit
    endif
    Addcalibrationrecord("Capacities, field and MSD adjusted")
  else                                 // All features: select what you want
    action=Selectaction()              // Select what to do
    switch action
    case ACT_QUIT:                     // Quit capacity adjustment
      goto quit
    case ACT_CANCEL:                   // Finish capacity adjustment
      goto quit
    case ACT_ADJUST:                   // Adjust input capacities
      i=Adjustfield(0)
      if i<0 goto quit
      if i==0 then
        i=Adjustfield(2)
        if i<0 goto quit
      endif
    case ACT_CPHASE:                   // Adjust C phases
      i=Adjustcphase()
      if i<0 goto quit
    case ACT_CRTADJ:                   // Adjust MSD capacities
      i=Adjustcrt()
      if i<0 goto quit
    case ACT_CTEST:                    // Verify input capacities
      i=Adjustfield(1)
      if i<0 goto quit
    case ACT_CSHORT:                   // Verify high input capacities
      i=Verifyshortcut()
      if i<0 goto quit
    case ACT_POT:                      // Test on-head potentiometers
      i=Verifydallas()
      if i<0 goto quit
    case ACT_RNEEDLE:                  // Adjust needle resistance
      i=Needleresistance()
      if i<0 goto quit
    case ACT_ZPRESS:                   // Test Z pressure
      i=Verifyzpressure()
      if i<0 goto quit
    case ACT_BDRILL:                   // Adjust backdrill needles
      i=Adjustbackdrill()
      if i<0 goto quit
    endsw
    Drawboard()
    goto mainloop
  endif
quit:
  // If some error was detected, restore old layout in the tester. If this
  // layout is invalid, next script (like calibration) may get it and save to
  // the disc!
  if layoutdiffers then
    Restoreoldlayout()
    Sendextention()
  endif
  Bcsetini()                           // Save brightness & contrast to .ini
badlayout:
  clear hleft
  clear hright
  change hinfo limits=0,0
  change hinfo text="完成,请稍后..."
  destroy hexit                        // Psychology...
  hexit=NULL
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,0")
  endif
  SERV.Cmdimm(32,"OUTPORT 0x20F0,8")
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                   \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO)                                   \
  then
    UnloadboardLM()                    // Unload board if L&M or split shuttle
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    UnloadboardLM()                    // Unload board if S3 split shuttle
  endif
  if Embedded()!=0 then
    SERV.Cmdimm(32,"$LIGHTS WAITING")  // Update state of traffic lights
  endif
  if hlog!=NULL Closelogfile()         // Close log file
  if (testertype!=TT_A5L && testertype!=TT_A7) ||                              \
    ($LAY.config & LC_LDMASK)!=LC_LMAUTO then
    SYS.Softreset(0)
  endif
  if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    hexit=NULL
    UnloadboardEPCOS()                 // Ask to remove board if EPCOS shuttle
  endif
end

