#include "ls.icl"
#include "or.icl"
#cmdbuff 16

#define VERSION ""
#define DESCRIPTION "Embedded software loader"

// 1.03: Doesn't attempt to read corrections file for non-existing camera.
// 1.04: Support for rails excluded from the boot sequence in layout.
// 1.05: Support for bit LC_VACUUMBOX (excludes all heads on bottom side).
// 1.06: Support for probe type (standard or Kelvin) autodetection.
// 1.07: Loading of head camera corrections.
// 1.08: Warning if correction date differs from layout.
// 1.09: After hard reset, posts CHG LOAD notification.
// 1.10: Recognizes cases when layout is loaded but heads not.
// 1.11: Test of connection to the Parameter Server.
// 1.12: Fast reload for A5-based testers.
// 1.13: Attempt to start Parameter Server before loading layout.
// 1.14: Crate reboot request.
// 1.15: Additional layout extentions.
// 1.16: Extended corrections, accelerated loading.
// 1.17: Bug: unable to load head software - too many pending commands.
// 1.18: Compatibility with A3.
// 1.19: Shuttle Y corrections.
// 1.20: Additional compatibility with A3.
// 1.21: Support for split shuttle.
// 1.22: Support for bulk corrections, fine corrections removed.
// 1.23: Longer timeout when loading layout.
// 1.24: Separate Y corrections for left and right shuttle.
// 1.25: Fast reload option is removed.

#define NLOAD          3               // Max number of head load commands
#define NCMD           16              // Max number of simultaneous commands

#define X1             10              // Placement of controls
#define X2             105
#define X3             205
#define X4             300
#define X5             395
#define Y1             10
#define Y2             80//68
#define Y3             98
#define Y4             128
#define Y5             138//158
#define Y6             193

// Layout configuration bits in $LAY.config.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae
// Alternative (old) interpretation of LC_OHTYPE bits.
#define LC_PHASEADJ    0x00000800      // On-heads with adjustable field phase
#define LC_ACTIVEONHD  0x00000400      // Active on-heads (with Dallas/R1-R4)
// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMSPLIT     0x20000000      // L&M auto split shuttle
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_LMAUTO      (LC_LM|LC_A2LOADER)
#define LC_LMS2AUTO    (LC_LMS2|LC_A2LOADER)
#define LC_EPCOSAUTO   (LC_EPCOS|LC_A2LOADER)
#define LC_LMMANUAL    (LC_LMMAN|LC_A2LOADER)
#define LC_SPLITAUTO   (LC_LMSPLIT|LC_A2LOADER)

// Features supported by crate controller.
#define CF_PRESSFACT   0x00000001      // Support for psensfact
#define CF_RETEST      0x00000002      // Instant retest (M_LIMITHI, M_LIMITLO)
#define CF_CAMINFO     0x00000004      // Support for S_DEBUG:0x48
#define CF_EXTSELF     0x00000008      // Extended self-test, D_EXTA5M/SLAVE5M
#define CF_FINECORR    0x00000010      // Support for S_LOARDUN:18/19
#define CF_FINEVAR     0x00000020      // S_LOARDUN:18/19 with variable step
#define CF_XCORR       0x00000040      // Support for S_LOADRUN:17
#define CF_3DCOR       0x00000080      // Supports 3-D calibration
#define CF_LONGLAY     0x00000100      // Supports additional layout extentions
#define CF_NANOMETER   0x00000200      // Supports sub-micrometer coordinates
#define CF_UNICKHZ     0x00000400      // M_UNIC supports kHz and ext device
#define CF_STROKEOPT   0x00000800      // Supports S_DEBUG:0x52, stroke options
#define CF_NETS        0x00001000      // Supports M_NETS
#define CF_CRATEXCOR   0x00002000      // Support for S_LOADRUN:17 to crate
#define CF_FULLCORR    0x00004000      // Support for S_LOARDUN:21

#define CORRX          31              // Number of X nodes in correction grid
#define CORRY          19              // Number of Y nodes in correction grid

typedef struct t_corr                  // Element of correction table
  $int2 dx                             // X correction, um
  $int2 dy                             // Y correction, um
ends

#define CE_VALID       0x0000001       // Correction extention valid
#define CE_QUICK       0x0000002       // Quick head adjustment is allowed
#define CE_HEADCAM     0x0000010       // Head camera corrections are valid
#define CE_FINE        0x0000020       // Fine head corrections are valid

#define CE_VALIDHCAM   (CE_VALID|CE_HEADCAM)

typedef struct t_cext                  // Extention of correction table
  int   mode                           // Set of CE_xxx
  $int2 caldate                        // Date of last calibration from layout
  $int2 corrcount                      // Number of remaining quick corrections
  $int4 optdata[4]                     // Offsets of optional corrections
  // Attention, fine corrections are obsolete! Use cartesian instead!
  $int4 finehead                       // Offset of fine head corrections or 0
  $int2 finex0                         // First col of fine corr, center-based
  $int2 finenx                         // No. of columns in fine head corrs
  $int2 finey0                         // First row of fcorr, center-based
  $int2 fineny                         // No. of rows in fine head corrections
  $int2 finedx                         // Distance between fine head columns, um
  $int2 finedy                         // Distance between fine head rows, um
  // Cartesian corrections are described here.
  $int4 carthead                       // Offset of cartesian head corrs or 0
  $int4 carthcam                       // Offset of cartesian headcam corrs or 0
  $int2 cartx0                         // First column of cartcorr, center-based
  $int2 cartnx                         // No. of columns in cartesian corrs
  $int2 carty0                         // First row of cartcorr, center-based
  $int2 cartny                         // No. of rows in cartesian corrections
  $int2 cartdx                         // Distance between cartesian columns, um
  $int2 cartdy                         // Distance between cartesian rows, um
  // Reserved data is reserved.
  char  reserved[196]                  // Reserved for the future
ends

typedef struct t_copt                  // Optional corrections, general layout
  $int4 key                            // 0: block must be ignored
  char  reserved[252]                  // Total size 256 bytes
ends

#define CSY_VALID      0x00000001      // Structure t_csy is valid

typedef struct t_csy                   // Header of corrsy.cor
  int   mode                           // Set of CSY_xxx
  $int2 caldate                        // Date of last calibration from layout
  $int2 mbz                            // Reserved for the future, must be 0
  int   shycor0                        // Offset of left t_shycor or 0
  int   shycor1                        // Offset of right t_shycor or 0
  char  reserved[240]                  // Reserved for the future
ends

typedef struct t_shycor                // Shuttle Y corrections
  int   key                            // Must be 0x00594853 or 0x00595253
  $float4 ystep                        // Distance between points in Y, um
  int   ny                             // No. of steps, total ny*2+1 points
  $float4 data[243]                    // X corr, Y corr (um), angle (rad)
ends

handle hmain                           // Main loader's window
handle hfram
handle hprog                           // Progress bar
handle hcnam,hlnam,hfnam,hrnam
handle hcbtn,hlbtn,hfbtn,hrbtn
handle hcbro,hlbro,hfbro,hrbro
handle hlall                           // Button "Load all"
handle hdmod                           // Button "Debug mode"
handle hsoft                           // Button "Soft reset"
handle hhard                           // Button "Hard reset"
handle hboot                           // Button "Restart"
handle hexit                           // Button "Exit"

int status[6]                          // Status of selected buttons
int warncaldate                        // Warn if dates of calibration differ

external int SERV.Debugmode(handle hw,handle *hq,int nq);
external int SERV.Options(int prefere);
external int SERV.Startlmauto();
external int Istrivialdebug();

// Necessary here to receive the broadcast messages.
function int Answerproc(char *answer,int info)
  if answer[4]==0xF0 then              // Broadcast message came
    if Stricmp(answer+5,"CHG LAY")==0 || Stricmp(answer+5,"CHG DBG")==0 then
      if hdmod!=NULL change hdmod color=(Istrivialdebug()?BLACK:RED)
    endif
  endif
end

// Returns 1 if trivial debug mode set (all features enabled) and 0 otherwise.
function int Istrivialdebug()
  int i,j
  if $GLOBAL.debugmode!=0 return 0
  j=$LAY.nfing
  if $LAY.cameras!=0 then
    if ($LAY.config & 0x80)!=0 then    // M2 tester
      if $GLOBAL.videomode!=0 return 0
    else                               // Not a M2 tester
      if ($GLOBAL.videomode & 0x201B)!=0 return 0
    endif
    j++
  endif
  for i=0,i<j,i++ do
    if $GLOBAL.disabledrails & (1<<i)!=0 return 0
  enddo
  return 1
end

function int Createcontrols()
  handle dummy
  hmain=control WINDOW
    window=NULL
    //position=120,120,485,228
    position=120,120,485,178
    name=format("测试机载入器 %s",VERSION)
    help=" "                           // 否则标题栏闪烁
    // bkcolor=PINK
    bkcolor=LIGHTGRAY
  endc
  hprog=control PROGRESS
    window=hmain
    position=X1,Y1,485-2*X1,24
    limits=0,0
    mode=M_PERCENT
    name="未知测试机状态"
    help="显示当前载入步骤的状态和进度"
    color=BLUE
  endc
  dummy=control TEXT
    window=hmain
    position=X1,Y2-22,150,50
    text="导入系统文件:"
    font=MEDIUMFONT
    color=DARKGRAY
  endc
//  dummy=control TEXT
//    window=hmain
//    position=X2,Y2-22,90,24
//    text="文件:"
//    font=MEDIUMFONT
//    color=DARKGRAY
//  endc
//  hcbtn=control BUTTON
//    window=hmain
//    position=X1,Y2,85,24
//    name="路径"
//    help="文件存储路径"
//  endc
//  hcnam=control COMBOEDIT
//    window=hmain
//    position=X2,Y2,305,120
//    name="内核控制文件"
//    help="包含内核控制器软件的文件"
//    mode=M_VSCROLL
//  endc
//  hcbro=control BUTTON
//    window=hmain
//    position=X2+310,Y2,60,24
//    name="浏览"
//    help="点击以浏览网络控制器文件"
//  endc
//  hlbtn=control BUTTON
//    window=hmain
//    position=X1,Y3,85,24
//    name="布局"
//    help="加载或重新加载布局"
//  endc
//  hlnam=control COMBOEDIT
//    window=hmain
//    position=X2,Y3,305,120
//    name="布局文件"
//    help="包含主测试机布局的文件"
//    mode=M_VSCROLL
//  endc
//  hlbro=control BUTTON
//    window=hmain
//    position=X2+310,Y3,60,24
//    name="浏览"
//    help="点击以浏览测试机的设置文件"
//  endc
  dummy=control TEXT
    window=hmain
    position=X1,Y2,85,24
    text="路径:"
    font=MEDIUMFONT
    color=BLACK
  endc
  hfnam=control EDIT
    window=hmain
    position=X2,Y2,305,24
    help="存储系统文件路径"
    bkcolor=WHITE
  endc
  hfbro=control BUTTON
    window=hmain
    position=X2+310,Y2,60,24
    name="浏览"
    help="点击以浏览测试头控制文件"
  endc
//  hrbtn=control BUTTON
//    window=hmain
//    position=X1,Y5,85,24
//    name="校正文件"
//    help="载入校正数据"
//  endc
//  hrnam=control COMBOEDIT
//    window=hmain
//    position=X2,Y5,305,120
//    name="校正文件"
//    help="包含更正数据的文件原型"
//    mode=M_VSCROLL
//  endc
//  hrbro=control BUTTON
//    window=hmain
//    position=X2+310,Y5,60,24
//    name="浏览"
//    help="点击以浏览校正数据文件"
//  endc
  hlall=control BUTTON
    window=hmain
    position=X1,Y5,85,24
    name="全部载入"
    help="载入所有嵌入程序，然后关闭窗口"
  endc
  hdmod=control BUTTON
    window=hmain
    position=X2,Y5,90,24
    name="器件调试"
    color=(Istrivialdebug()?BLACK:RED)
    help="设置软硬件的测试项"
  endc
  hsoft=control BUTTON
    window=hmain
    position=X3,Y5,85,24
    name="软件复位"
    help="执行测试机软复位"
  endc
  hhard=control BUTTON
    window=hmain
    position=X4,Y5,85,24
    name="硬件复位"
    help="执行测试机软复位"
  endc
  hexit=control BUTTON
    window=hmain
    position=X5,Y5,80,24
    name="退出"
    help="中断当前进程或关闭窗口"
    // miaoyu
    color=WHITE
    bkcolor=BLUE
  endc
  if $GLOBAL.a5==0 then
    hboot=NULL
  else
    hboot=control BUTTON
      window=hmain
      position=X5,Y1+30,80,22
      name="重启"
      help="双击以重新启动小电脑"
      mode=M_DBLCLICK
    endc
  endif
end

function int Enablebuttons(int running)
  if ($GLOBAL.crateloaded==1 || running==1) then
    if status[0]!=0 disable hcbtn
    status[0]=0
  else
    if status[0]!=1 enable hcbtn
    status[0]=1
  endif
  if ($GLOBAL.crateloaded==(-1) || running==1 ||                               \
    ($GLOBAL.layloaded==1 && $GLOBAL.headloaded==(-1))) then
    if status[1]!=0 disable hlbtn
    status[1]=0
  else
    if status[1]!=1 enable hlbtn
    status[1]=1
  endif
  if ($GLOBAL.crateloaded==(-1) || $GLOBAL.layloaded==(-1) ||                  \
    $GLOBAL.headloaded==1 || running==1) then
    if status[2]!=0 disable hfbtn
    status[2]=0
  else
    if status[2]!=1 enable hfbtn
    status[2]=1
  endif
  if ($GLOBAL.crateloaded==(-1) || $GLOBAL.layloaded==(-1) ||                  \
    $GLOBAL.headloaded==(-1) || running==1) then
    if status[3]!=0 disable hrbtn
    status[3]=0
  else
    if status[3]!=1 enable hrbtn
    status[3]=1
  endif
  if (running==1) then
    if status[4]!=0 then
      disable hlall
      disable hdmod
      disable hsoft
      disable hhard
    endif
    status[4]=0
  else
    if status[4]!=1 then
      enable hlall
      enable hdmod
      enable hsoft
      enable hhard
    endif
    status[4]=1
  endif
  if $GLOBAL.headloaded==1 || running==1 then
    if status[5]!=0 disable hboot
    status[5]=0
  else
    if status[5]==0 enable hboot
    status[5]=1
  endif
end

// Loads crate controller software.
function int Loadcrate(char *name)
  int i,n,t[NCMD],len,reason,cmd,next,ncmd,loadok
  char *cprog,buf[262],zero[256]
  handle f
  // Check connection to crate.
  change hprog mode=0
  change hprog limits=0,60
  change hprog name="与内核建立连接"
  t[0]=Time(); n=-1
  $A[0].length=0
  if $GLOBAL.a5==0 then
    ncmd=1
  else
    ncmd=NCMD
  endif
  while 1 do
    wait
    if $A[0].length!=0 then            // Answer to Soft Reset came
      if ($A[0].answer==S_ERROR && $A[0].length==8) then
        break                          // OK to load tester
      else if $A[0].answer==0x00 || $A[0].answer==0x0A then
        change hprog mode=M_PERCENT    // Tester already loaded
        change hprog limits=0,0
        change hprog name="Tester already loaded, press \"Hard reset\" first"
        return -1
      endif
    endif
    if (n>60 || Pressed(hexit)) then   // Button "Exit" works as an interrupt
      change hprog mode=M_PERCENT
      change hprog limits=0,0
      change hprog name="无法与内核建立连接"
      return -1
    endif
    if ((Time()-t[0])/1000==n) continue
    n=(Time()-t[0])/1000
    change hprog limits=n,60
    SYS.Softimm(0)
  enddo
  // Open file and verify its length.
  f=Fopen(name,"rb")
  change hprog limits=0,0
  change hprog mode=M_PERCENT
  if f==NULL then
    change hprog name="无法打开内核文件"
    return -1
  endif
  Fseek(f,0,2); len=Ftell(f); Fseek(f,0,0)
  n=(len+255)/256
  if (n==0 || (n*256)!=len) then
    change hprog name="内核文件长度不是N*256"
    Fclose(f); return -1
  endif
  // Read file.
  change hprog name="加载内核"
  if Alloc(cprog,len)==0 then
    Fclose(f)
    change hprog name="内存低，无法读取内核文件"
    return -1
  endif
  i=Fread(cprog,len,f)
  Fclose(f)
  if i!=len then
    Free(cprog)
    change hprog name="读取内核文件错误"
    return -1
  endif
  // Transfer data to crate controller. To spare time, I try to send up to ncmd
  // commands at once. Note that commands must be strictly sequential!
  reason=0
  next=0
  loadok=0
  for cmd=0,cmd<ncmd,cmd++ do
    t[cmd]=0
  enddo
  Memset(zero,0,256)
  while reason==0 do
    if Pressed(hexit) then
      change hprog name="内核加载进程中断"
      reason=-1; break
    endif
    i=0                                // Number of free commands
    for cmd=0,cmd<ncmd,cmd++ do
      if cmd>0 && next<n && loadok==0 break
      if t[cmd]==0 then
        // Zero-filled blocks can be safely skipped. This spares time on A2.
        while next<n && Memcmp(cprog+next*256,zero,256)==0 do
          next++
        enddo
        if next<n then                 // OK to send next block
          buf[0]=S_LOADRUN
          buf[1]=1                     // Load block into crate controller
          $uint2(buf+2)=next*16+0x100  // Segment for given block
          $uint2(buf+4)=0              // Offset is always 0
          Memcpy(buf+6,cprog+256*next,256)
          SYS.Sendimm(cmd,262,buf)
          t[cmd]=Time()                // Timeout for this command
          next++
          change hprog limits=next+1,n
        else
          i++
        endif
      else if $A[cmd].length!=0 then
        if $A[cmd].answer!=S_LOADRUN then
          change hprog limits=0,0
          change hprog name="内核报告引导错误"
          reason=-2; break
        else
          t[cmd]=0
          loadok=1
        endif
      else if Time()-t[cmd]>3000 then
        change hprog limits=0,0
        change hprog name="Timeout while loading crate"
        reason=-2; break
      endif
    enddo
    if next>=n && i==ncmd break
    if $GLOBAL.a5==0 wait              // Significantly accelerates A5 booting
  enddo
  Free(cprog)
  if reason!=0 then
    for cmd=0,cmd<ncmd,cmd++ do
      SYS.Killimm(cmd)                 // Remove remaining pending commands
    enddo
    return reason
  endif
  buf[0]=S_LOADRUN
  buf[1]=2                             // Start crate controller
  $uint2(buf+2)=0                      // Offset
  $uint2(buf+4)=0x100                  // Segment
  SYS.Sendimm(0,6,buf)
  t[0]=Time()
  while $A[0].length==0 do
    if Pressed(hexit) then
      reason=-1                        // Button "Exit" works as an interrupt
    else if Time()-t[0]>5000 then
       reason=-2                       // Timeout exhausted
    else
      reason=0
    endif
    if reason!=0 then
      SYS.Killimm(0)
      change hprog limits=0,0
      if reason==(-1) then
        change hprog name="Crate loading sequence interrupted"
      else
        change hprog name="开启内核软件超时"
      endif
      return reason
    endif
    wait
  enddo
  change hprog limits=0,0
  if $A[0].answer==S_ERROR then
    change hprog name="内核报告引导错误"
    return -1
  endif
  change hprog name="内核控制器加载完成"
  lprintf(BLACK,"内核控制器已加载")
  $GLOBAL.crateloaded=1
  delay 250
  return 0
end

// Sets debug mode, what else?
function int Setdebugmode()
  char buf[32]
  int ident1,ident2,t,reason
  change hprog limits=0,0
  change hprog name="器件调试模式"
  buf[0]=S_DEBUG
  buf[1]=0x01                          // Set debugging mode
  $uint2(buf+2)=$GLOBAL.debugmode
  $uint2(buf+4)=$GLOBAL.disabledrails
  $uint2(buf+6)=$GLOBAL.videomode
  ident1=SYS.Sendimm(0,8,buf)
  if $GLOBAL.a5 then
    buf[0]=S_DEBUG
    buf[1]=0x0F                        // Set debug mode of measurement card
    $uint4(buf+2)=$uint4($GLOBAL+280)
    $uint4(buf+6)=0
    $uint4(buf+10)=0
    $uint4(buf+14)=0
    ident2=SYS.Sendimm(1,18,buf)
  else
    $A[1].length=5
  endif
  t=Time()+3000
  while 1 do
    if $A[0].length!=0 && $A[1].length!=0 break
    if Pressed(hexit) then reason=-1;  // Button "Exit" works as an interrupt
    else if Time()>t then reason=-2;
    else reason=0; endif;
    if reason!=0 then
      if $A[0].length==0 SYS.Killsend(ident1)
      if $A[1].length==0 SYS.Killsend(ident2)
      if reason==(-1) then
        change hprog name="器件调试模式中断"
      else
        change hprog name="器件调试模式超时"
      endif
      return reason
    endif
    wait
  enddo
  // I do not check answer to S_DEBUG:0xF because this command is not supported
  // by older embedded software.
  if $A[0].answer==S_ERROR then
    change hprog name="无法器件调试模式"
    return -2
  endif
  return 0
end

// Asks L&M for the value of the specified parameter. Sets value to the received
// string <parm>=<answer> (i.e. parm and equation sign are included). Returns 0
// on success and 1 on failure.
function int Getlmparameter(char *parm,char *value)
  int i,n,t
  char buf[768]
  SYS.Killimm(0)
  buf[0]=S_LMAUTO
  buf[1]=3                             // Get parameter
  n=2+sprintf(buf+2,"%s",parm)
  SYS.Sendimm(0,n,buf)
  t=Time()
  while $A[0].length==0 do
    if Time()-t>1000 then
      SYS.Killimm(0)                   // Timeout
      return 1
    endif
    wait
  enddo
  if $A[0].answer!=S_LMAUTO return 1   // Bad answer
  for i=0,i<$A[0].length-6,i++ do
    value[i]=$char($A[0]+6+i)
  enddo
  value[i]='\0'
  return 0
end

// If reload!=0 and name[0]==0, use current layout
function int Loadlayout(char *name,int reload)
  int i,j,n,nexcl,nexclbot,len,t,reason,pson,nsent,nextra,isec,err
  char s[256],buf[774]
  handle f,hconfirm,hok,hcancel
  change hprog limits=0,0
  i=Setdebugmode()
  if i!=0 return i
  pson=0
  change hprog name=(reload==0?"加载布局":"重载布局")
  if name[0]!='\0' then                // Use layout from file
    f=Fopen(name,"rb")
    if f==NULL then
      change hprog name="无法打开内核文件";
      return -1;
    endif
    Fseek(f,0,2); len=Ftell(f); Fseek(f,0,0);
    if len!=768 && len!=1536 && len!=2304 && len!=3072 &&                      \
      len!=3840 && len!=4608 then
      change hprog name="布局文件长度无效";
      Fclose(f); return -1;
    endif
    err=0
    Memset($EXTLAY,0,768)
    Memset($EXT0,0,768)
    Memset($EXT1,0,768)
    Memset($EXT2,0,768)
    Memset($EXT3,0,768)
    n=Fread($LAY,768,f)
    if n!=768 err=1
    $LAY.extlay=0
    if err==0 && len>=1536 then
      n=Fread($EXTLAY,768,f)
      if n!=768 err=1
      $LAY.extlay=$LAY.extlay+1
    endif
    if err==0 && len>=2304 then
      n=Fread($EXT0,768,f)
      if n!=768 err=1
      $LAY.extlay=$LAY.extlay+1
    endif
    if err==0 && len>=3072 then
      n=Fread($EXT1,768,f)
      if n!=768 err=1
      $LAY.extlay=$LAY.extlay+1
    endif
    if err==0 && len>=3840 then
      n=Fread($EXT2,768,f)
      if n!=768 err=1
      $LAY.extlay=$LAY.extlay+1
    endif
    if err==0 && len>=4608 then
      n=Fread($EXT3,768,f)
      if n!=768 err=1
      $LAY.extlay=$LAY.extlay+1
    endif
    Fclose(f)
    SYS.Broadcast(8,"CHG LAY")         // Inform others that layout changed
    if err!=0 then
      change hprog name="读取内核文件错误";
      return -1;
    endif
    // If some rails are excluded from the bootstrap, ask for confirmation
    // that heads are in park position. One may avoid this annoying question
    // by setting tester name to "Emulator".
    nexcl=0; nexclbot=0; n=0
    for i=0,i<$LAY.nfing,i++ do
      if ($LAY.config & 0x4000000)!=0 && $LAY.side[i]!=0 then
        if n>0 n=n+sprintf(s+n,", ")
        n=n+sprintf(s+n,"%i",i)
        nexclbot++
      else if ($LAY.excludedrails & (1<<i))!=0 then
        if n>0 n=n+sprintf(s+n,", ")
        n=n+sprintf(s+n,"%i",i)
        nexcl++
      endif
    enddo
    if Memicmp($LAY+689,"Emulat",6)!=0 && $GLOBAL.a5!=0 &&                     \
      (nexcl!=0 || nexclbot!=0) then
      hconfirm=control WINDOW
        window=NULL
        position=10,10,350,150
        name="确认屏蔽轨道"
        bkcolor=YELLOW
        mode=M_MODAL
        size=1024
      endc
      draw window=hconfirm font=MEDIUMFONT color=BLACK
      draw at 10,30 wrap=345
      if nexcl==1 then
        draw text="Rail " color=LIGHTRED text=s color=BLACK text=" is "
        draw text="excluded in layout from the boot sequence. Please confirm "
        draw text="that both heads on this rail are in the park (leftmost) "
        draw text="position. They will not move afterwards."
      else if nexcl!=0 then
        draw text="轨道 " color=LIGHTRED text=s color=BLACK text=" 在 "
        draw text="布局中排除在外，请确定这些"
        draw text="测试头在轨道中的停留位置。"
        draw text="之后他们将不会再移动."
      else
        draw text="Rails and camera on the bottom side are excluded from the "
        draw text="boot sequence by 'vacuum box' option in layout. They will "
        draw text="not move during bootstrapping or test."
      endif
      draw show
      if nexcl>0 then
        hok=control BUTTON
          window=hconfirm
          position=45,115,120,25
          text="测试头停放"
          font=MEDIUMFONT
        endc
      else
        hok=control BUTTON
          window=hconfirm
          position=45,115,120,25
          text="确定"
          font=MEDIUMFONT
          limits=10000,0
        endc
      endif
      hcancel=control BUTTON
        window=hconfirm
        position=180,115,120,25
        text="取消引导"
        font=MEDIUMFONT
      endc
      while 1 do
        if Pressed(hok) then
          i=0; break
        else if Pressed(hcancel) then
          i=-1; break
        endif
        wait
      enddo
      destroy hconfirm
      if i!=0 then
        change hprog name="部分轨道屏蔽"
        return -1
      endif
    endif
  else                                 // Use current layout (from memory)
    len=0
    for i=4,i<768,i++ do               // First 4 bytes are validity marker
      if $char($EXT3+i)!=0 break
    enddo
    if i<768 len=4608
    if len==0 then
      for i=4,i<768,i++ do
        if $char($EXT2+i)!=0 break
      enddo
      if i<768 len=3840
    endif
    if len==0 then
      for i=4,i<768,i++ do
        if $char($EXT1+i)!=0 break
      enddo
      if i<768 len=3072
    endif
    if len==0 then
      for i=4,i<768,i++ do
        if $char($EXT0+i)!=0 break
      enddo
      if i<768 len=2304
    endif
    if len==0 then
      for i=0,i<768,i++ do
        if $char($EXTLAY+i)!=0 break
      enddo
      if i<768 len=1536
    endif
    if len==0 len=768
  endif
  if $LAY.nfing<=0 || $LAY.nfing>16 then
    change hprog name="布局错误"
    return -1
  endif
  // Load main layout and wait for answer. If additional layout extentions are
  // supported, answer will indicate this fact.
  buf[0]=S_LOADRUN
  buf[1]=(reload==0?3:2)               // Load/reload layout
  $int4(buf+2)=0                       // Dummy zero bytes
  Memcpy(buf+6,$LAY,768)
  SYS.Sendimm(0,774,buf)
  t=Time(); isec=-1
  while $A[0].length==0 do
    if (reload!=0 && (Time()-t)/1000!=isec) then
      isec=(Time()-t)/1000
      change hprog name=format("重载布局 - %i s",isec)
    endif
    if Pressed(hexit) then reason=-1;  // Button "Exit" works as an interrupt
    else if Time()>t+(reload==0?20000:90000) then reason=-2;
    else reason=0; endif;
    if reason!=0 then
      SYS.Killimm(0)
      if reason==(-1) then
        change hprog name="加载布局进程中断"
      else
        change hprog name="加载布局超时"
      endif
      return reason
    endif
    wait
  enddo
  if $A[0].answer!=S_LOADRUN then
    change hprog name="内核报告布局加载超时"
    if $A[0].answer==S_ERROR && $A[0].subansw==0x23 then
      if reload==0 then
        $GLOBAL.layloaded=1            // Layout and heads already loaded
      else
        $GLOBAL.layloaded=-1           // Layout and heads not yet loaded
        $GLOBAL.headloaded=-1
      endif
    endif
    return -1
  else
    for i=0,i<16,i++                   // Same offsets in tester & inner copy
      $LAYCORR.leftzerox[i]=$LAY.leftzerox[i]
      $LAYCORR.leftzeroy[i]=$LAY.leftzeroy[i]
      $LAYCORR.rightzerox[i]=$LAY.rightzerox[i]
      $LAYCORR.rightzeroy[i]=$LAY.rightzeroy[i]
    enddo
  endif
  if $A[0].length>=7 then
    nextra=$char($A[0]+6)
  else
    nextra=1
  endif
  // Load layout extentions. I load additional extentions first, this is the
  // standard sequence.
  nsent=0
  if len>=2304 && nextra>=2 then
    buf[0]=S_LOADRUN
    buf[1]=20                          // Load additional layout extention
    $int4(buf+2)=0                     // First additional extention
    Memcpy(buf+6,$EXT0,768)
    SYS.Sendimm(1,774,buf)
    nsent=Max(nsent,2)
  endif
  if len>=3072 && nextra>=3 then
    buf[0]=S_LOADRUN
    buf[1]=20                          // Load additional layout extention
    $int4(buf+2)=1                     // Second additional extention
    Memcpy(buf+6,$EXT1,768)
    SYS.Sendimm(2,774,buf)
    nsent=Max(nsent,3)
  endif
  if len>=3840 && nextra>=4 then
    buf[0]=S_LOADRUN
    buf[1]=20                          // Load additional layout extention
    $int4(buf+2)=2                     // Third additional extention
    Memcpy(buf+6,$EXT2,768)
    SYS.Sendimm(3,774,buf)
    nsent=Max(nsent,4)
  endif
  if len>=4608 && nextra>=5 then
    buf[0]=S_LOADRUN
    buf[1]=20                          // Load additional layout extention
    $int4(buf+2)=3                     // Fourth additional extention
    Memcpy(buf+6,$EXT3,768)
    SYS.Sendimm(4,774,buf)
    nsent=Max(nsent,5)
  endif
  if len>=1536 then
    buf[0]=S_LOADRUN
    buf[1]=15                          // Load main layout extention
    $int4(buf+2)=0                     // Dummy zero bytes
    Memcpy(buf+6,$EXTLAY,768)
    SYS.Sendimm(0,774,buf)
    nsent=Max(nsent,1)
  endif
  while 1 do
    for j=0,j<nsent,j++ do
      if $A[j].length==0 break
    enddo
    if j>=nsent break                  // All answers are back
    if (reload!=0 && (Time()-t)/1000!=isec) then
      isec=(Time()-t)/1000
      change hprog name=format("重载布局- %i s",isec)
    endif
    if Pressed(hexit) then reason=-1;  // Button "Exit" works as an interrupt
    else if Time()>t+(reload==0?20000:90000) then reason=-2;
    else reason=0; endif;
    if reason!=0 then
      for j=0,j<nsent,j++ do
        SYS.Killimm(j)
      enddo
      if reason==(-1) then
        change hprog name="加载布局进程中断"
      else
        change hprog name="加载布局超时"
      endif
      return reason
    endif
    wait
  enddo
  for j=0,j<nsent,j++ do
    if $A[j].answer!=S_LOADRUN break
  enddo
  if j<nsent then
    change hprog name="内核报告布局加载错误"
    return -1
  endif
  sprintf(buf,"%s %s加载",len==768?"布局":"扩展布局",reload==0?"":"再次")
  change hprog name=buf
  lprintf(BLACK,"%s",buf)
  $GLOBAL.layloaded=1
  delay 250
  // If necessary, start L&M Parameter Server.
  if (pson==0 &&                                                               \
    ($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                    \
    ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO ||                                 \
    ($LAY.config & LC_LDMASK)==LC_LMS2AUTO ||                                  \
    ($LAY.config & LC_LDMASK)==LC_LMMANUAL ||                                  \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO) &&                                \
    ($GLOBAL.debugmode & 0x0040)==0 then
    SERV.Startlmauto()
    // Now assure that crate is connected to the Parameter server. I try
    // simple request that can't fail.
    change hprog name="测试连接到PS"
    for i=0,i<10,i++ do
      if Getlmparameter("MECH.Ready.Reference",s)==0 break
    enddo
    if i<10 then
      change hprog name="连接到PS"
      if ($LAY.config & LC_LDMASK)==LC_LMS2AUTO ||                             \
        ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
        // Timeout to let PS restore emergency stop.
        t=Time()
        while Time()-t<8000 do
          wait
        enddo
      endif
    else
      change hprog name="没有到PS的连接"
    endif
  endif
  return 0
end

// Loads head controller software.
function int Loadheads(char *name)
  int i,n,len,reason,cmd,next,nload,t[NLOAD],loadok
  char *fprog,buf[262],zero[256]
  handle f
  i=Setdebugmode()
  if i!=0 return i
  if $GLOBAL.a5==0 then
    nload=1
  else
    nload=NLOAD
  endif
  // Open file and verify its length.
  f=Fopen(name,"rb")
  change hprog limits=0,0
  if f==NULL then
    change hprog name="无法打开测试头文件";
    return -1;
  endif
  Fseek(f,0,2); len=Ftell(f); Fseek(f,0,0);
  n=(len+255)/256;
  if (n==0 || (n*256)!=len) then
    change hprog name="头文件长度不是N*256";
    Fclose(f); return -1;
  endif
  // Read file.
  change hprog name="加载测试头"
  if Alloc(fprog,len)==0 then
    Fclose(f)
    change hprog name="低内存，无法读取头文件"
    return -1
  endif
  i=Fread(fprog,len,f)
  Fclose(f)
  if i!=len then
    Free(fprog)
    change hprog name="读取头文件出错"
    return -1
  endif
  // Transfer data to crate controller. To spare time, I try to send up to
  // nload commands at once. Note that commands must be strictly sequential!
  reason=0
  next=0
  loadok=0
  for cmd=0,cmd<nload,cmd++ do
    t[cmd]=0
  enddo
  Memset(zero,0,256)
  while reason==0 do
    if Pressed(hexit) then
      change hprog name="测试头加载进程中断"
      reason=-1; break
    endif
    i=0                                // Number of free commands
    for cmd=0,cmd<nload,cmd++ do
      if cmd>0 && next<n && loadok==0 break
      if t[cmd]==0 then
        // Zero-filled blocks can be safely skipped. This spares time on A2.
        while next<n && Memcmp(fprog+next*256,zero,256)==0 do
          next++
        enddo
        if next<n then                 // OK to send next block
          buf[0]=S_LOADRUN
          buf[1]=5                     // Load block into head controllers
          $uint2(buf+2)=next*16+0x100  // Segment for given block
          $uint2(buf+4)=0              // Offset is always 0
          Memcpy(buf+6,fprog+256*next,256)
          SYS.Sendimm(cmd,262,buf)
          t[cmd]=Time()                // Timeout for this command
          next++
          change hprog limits=next+1,n
        else
          i++
        endif
      else if $A[cmd].length!=0 then
        if $A[cmd].answer!=S_LOADRUN then
          change hprog limits=0,0
          change hprog name="内核报告引导错误"
          reason=-2; break
        else
          t[cmd]=0
          loadok=1
        endif
      else if Time()-t[cmd]>3000 then
        change hprog limits=0,0
        change hprog name="Timeout while loading heads"
        reason=-2; break
      endif
    enddo
    if next>=n && i==nload break
    if $GLOBAL.a5==0 wait              // Significantly accelerates A5 booting
  enddo
  Free(fprog)
  if reason!=0 then
    for cmd=0,cmd<nload,cmd++ do
      SYS.Killimm(cmd)                 // Remove remaining pending commands
    enddo
    return reason
  endif
  change hprog limits=0,0
  buf[0]=S_LOADRUN
  buf[1]=6                             // Start head controller
  $uint2(buf+2)=0                      // Offset
  $uint2(buf+4)=0x100                  // Segment
  SYS.Sendimm(0,6,buf)
  t[0]=Time(); i=-1
  while $A[0].length==0 do
    if (Time()-t[0])/1000!=i then
      i=(Time()-t[0])/1000
      change hprog name=format("初始化测试头 - %i s",i)
    endif
    if Pressed(hexit) then reason=-1;  // Button "Exit" works as an interrupt
    else if Time()-t[0]>120000 then reason=-2;
    else reason=0; endif;
    if reason!=0 then
      SYS.Killimm(0)
      if reason==(-1) then
        change hprog name="测试头加载进程中断"
      else
        change hprog name="启动测试头超时"
      endif
      return reason
    endif
    wait
  enddo
  if $A[0].answer==S_ERROR then
    change hprog name="Crate reports bootstrap error"
    return -1
  endif
  if $LAY.config & 0x10000000 then     // Get layout after probe type detection
    buf[0]=S_LAYOUT
    buf[1]=0x02                        // Read layout "as is"
    SYS.Sendimm(0,2,buf)
    t[0]=Time()
    while $A[0].length==0 do
      if Pressed(hexit) then reason=-1;
      else if Time()-t[0]>5000 then reason=-2;
      else reason=0; endif
      if reason!=0 then
        SYS.Killimm(0)
        if reason==(-1) then
          change hprog name="Head loading sequence interrupted"
        else
          change hprog name="读取布局超时"
        endif
        return reason
      endif
    enddo
    if $A[0].answer!=S_LAYOUT || $A[0].length!=774 then
      change hprog name="无法读取校正布局"
      return -2
    endif
    $LAY.probetype=$LAY($A[0]+6).probetype
    SYS.Broadcast(8,"CHG LAY")         // Inform others that layout changed
    SYS.Broadcast(10,"CHG PROBE")
  endif
  change hprog name="测试头控制器加载完成"
  lprintf(BLACK,"头部控制器已加载")
  $GLOBAL.headloaded=1
  delay 250
  return 0
end

function int Loadcorrs(char *name)
  int i,j,k,column,reason,cratefeatures,head,nhead
  int len,offset,attempt,patch,cmd,ncmd,nload,t[NCMD],extended,loadok
  char buf[1024],path[260],drv[3],dir[260],fna[260],ext[260],s[256]
  char *corrfile
  handle f,hconfirm,hok
  struct t_corr corr[CORRX,CORRY]      // Correction table
  struct t_cext cext                   // Correction extention
  struct t_copt copt                   // Block of optional corrections
  struct t_csy csy                     // Header of shuttle corrections file
  struct t_shycor shycor0              // Left Y shuttle corrections
  struct t_shycor shycor1              // Right Y shuttle corrections
  change hprog limits=0,0
  if $LAY.nfing<=0 || $LAY.nfing>16 then
    change hprog name="布局错误"
    return -1
  endif
  if $GLOBAL.a5==0 then
    ncmd=1
    nload=1
  else
    ncmd=NCMD
    nload=NLOAD
  endif
  // Prepare file name.
  Fnsplit(name,drv,dir,fna,ext)
  patch=Strlen(fna)-2; if (patch<0) patch=0;
  i=Toupper(fna[patch+1])
  if Isdigit(fna[patch])==0 || (i!='L' && i!='R') then
    change hprog name="校正原型名称错误"
    return -1
  endif
  nhead=2*$LAY.nfing
  if ($LAY.cameras & 2) then
    nhead=nhead+2
  else if ($LAY.cameras & 1) then
    nhead=nhead+1
  endif
  change hprog name="加载校正文件"
  loadok=0
  reason=0
  if Memicmp($LAY+689,"Emulat",6)==0 then
    warncaldate=0
  else
    warncaldate=1
  endif
  extended=0
  // Get features of Crate controller. This port indicates whether bulk and
  // optional corrections are supported.
  cratefeatures=0
  if $GLOBAL.a5!=0 then                // Unavailable for A2
    buf[0]=S_INPORT32
    buf[1]=0xFF                        // Crate controller
    $uint4(buf+2)=0x10000012           // Query crate features
    SYS.Sendimm(0,6,buf)
    i=Time()
    while $A[0].length==0 do
      if Time()-i>1500 break           // Timeout
      wait
    enddo
    if $A[0].answer==S_INPORT32 then
      cratefeatures=$uint4($A[0]+5)
    endif
  endif
  // Load corrections to all available controllers.
  for head=0,head<nhead,head++
    if head==2*$LAY.nfing && ($LAY.cameras & 1)==0 continue
    if head==2*$LAY.nfing+1 && ($LAY.cameras & 2)==0 continue
    fna[patch]=(head/2<10?head/2+'0':head/2-10+'A')
    fna[patch+1]=(head & 1)==0?'L':'R'
    fna[patch+2]='\0'
    Fnmerge(path,drv,dir,fna,ext)
    f=Fopen(path,"rb")
    if f==NULL then
      // Excluded rails may have no correction tables.
      if ($LAY.excludedrails & (1<<(head/2))) continue
      change hprog limits=0,0
      change hprog name=format("无法打开 %s",path);
      return -1;
    endif
    change hprog limits=head,nhead
    // Try to load description of correction data, may be absent if only
    // main corrections in old format are present.
    Fseek(f,CORRX*CORRY*4,0);
    len=Fread(cext,256,f)
    if len==0 then
      Memset(cext,0,256)
    else if len!=256 then
      reason=3
    else
      if (cratefeatures & CF_XCORR)==0 then
        // Additional corrections are not supported.
        cext.optdata[0]=0
        cext.optdata[1]=0
        cext.optdata[2]=0
        cext.optdata[3]=0
      endif
    endif
    // Check whether corrections are up-to-date.
    if reason==0 && (cext.mode & CE_VALID)!=0 && cext.caldate!=0 &&            \
      $LAY.caldate!=0 && cext.caldate!=$LAY.caldate &&                         \
      ($LAY.excludedrails & (1<<head/2))==0 && warncaldate!=0                  \
    then
      warncaldate=0
      hconfirm=control WINDOW
        window=NULL
        position=10,10,410,180
        name="校准日期不同"
        bkcolor=YELLOW
        mode=M_MODAL
        size=1024
      endc
      draw window=hconfirm font=MEDIUMFONT color=BLACK
      draw at 10,30 wrap=405
      draw text="根据布局文件提示，飞针测试机最近的一次校验是在 "
      Strtime(s,"%B %d, %Y",2,$LAY.caldate)
      draw color=LIGHTRED text=format("%s",s) color=BLACK
      draw text=",但是测试头" color=LIGHTRED
      draw text=format("%i%c ",head/2,(head & 1?'R':'L')) color=BLACK
      draw text="(可能还有其他测试头) 的校准是在 "
      Strtime(s,"%B %d, %Y",2,cext.caldate)
      draw color=LIGHTRED text=format("%s",s) color=BLACK
      draw text="进行的. 如果校准数据和布局文件不匹配，"
      draw text="可能会造成测试机达不到精度甚至测试头碰撞。新的校验将会解决此问题"
      draw text="."
      draw show
      hok=control BUTTON
        window=hconfirm
        position=145,145,120,25
        text="确定"
        font=MEDIUMFONT
        limits=15000,0
      endc
      while 1 do
        if Pressed(hok) break
        wait
      enddo
      destroy hconfirm
    endif
    // If Crate supports S_LOADRUN:21, we don't need to worry about interna of
    // the correction data. It's sufficient to upload the complete file.
    if reason==0 && (cratefeatures & CF_FULLCORR)!=0 then
      Fseek(f,0,2)
      len=Ftell(f)
      if Alloc(corrfile,len)==0 reason=3
      if reason==0 then
        Fseek(f,0,0)
        if Fread(corrfile,len,f)!=len reason=3
      endif
      if len>CORRX*CORRY*4+256 then
        Memcpy(cext,corrfile+CORRX*CORRY*4,256)
        if (cext.mode & CE_VALID)!=0 && (cext.carthead!=0 || cext.carthcam!=0) \
          extended=1
        ;
      endif
      attempt=0
      // On error, we must restart from the very beginning!
    retry:
      attempt++
      offset=0
      // To spare time, I try to send up to nload commands at once. Note that
      // commands must be strictly sequential!
      for cmd=0,cmd<nload,cmd++ do
        SYS.Killimm(cmd)
        t[cmd]=0
      enddo
      while reason==0 do
        if Pressed(hexit) then
          reason=-1; break
        endif
        i=0                            // Number of pending commands
        for cmd=0,cmd<nload,cmd++ do
          if t[cmd]==0 && offset<len then
            if offset>0 && loadok==0                                           \
              break                    // Load status is not yet clear
            buf[0]=S_LOADRUN
            buf[1]=21                  // Load bulk correction data
            $int2(buf+2)=head
            $int4(buf+4)=len
            $int4(buf+8)=offset
            $int4(buf+12)=0
            $int4(buf+16)=0
            j=Min(998,len-offset)
            Memcpy(buf+20,corrfile+offset,j)
            SYS.Sendimm(cmd,20+j,buf)
            t[cmd]=Time()
            offset=offset+j
          else if t[cmd]==0 then
            continue                   // Nothing to send
          else if $A[cmd].length!=0 then
            if $A[cmd].answer==S_ERROR then
              if $A[cmd].length==8 then
                // Error is reported by ROM.
                $GLOBAL.crateloaded=-1
                $GLOBAL.layloaded=-1
                $GLOBAL.headloaded=-1
                $GLOBAL.corrloaded=-1
                reason=4; break
              else
                if attempt<3 goto retry
                reason=5; break
              endif
            else if $A[cmd].answer!=S_LOADRUN then
              reason=6; break
            else
              t[cmd]=0
              loadok=1
            endif
          else if Time()-t[cmd]>3000 then
            if attempt<3 goto retry
            reason=2
            break
          else
            i++                        // Command is still pending
          endif
        enddo
        if offset>=len && i==0 break
        if $GLOBAL.a5==0 wait          // Significantly accelerates A5 booting
      enddo
      Free(corrfile)
    else
      // Load legacy head corrections.
      if reason==0 then
        Fseek(f,0,0);
        len=Fread(corr,CORRX*CORRY*4,f)
        if len!=CORRX*CORRY*4 reason=3
        column=0                       // Column to be sent next
        for cmd=0,cmd<ncmd,cmd++ do
          t[cmd]=0
        enddo
        while reason==0 do
          if Pressed(hexit) then
            reason=1; break
          endif
          i=0                          // Number of free commands
          for cmd=0,cmd<ncmd,cmd++ do
            if cmd>0 && loadok==0                                              \
              break                    // Load status is not yet clear
            if t[cmd]==0 then
              if column<CORRX then     // OK to send next column
                Memcpy(buf+6,corr[column],CORRY*4)
                buf[0]=S_LOADRUN
                $uint2(buf+2)=head/2
                if (head & 1)==0 then  // Left heads
                  buf[1]=0x07
                  $uint2(buf+4)=column
                else                   // Right heads
                  buf[1]=0x08
                  $uint2(buf+4)=CORRX-column-1
                  for j=0,j<=CORRY/2,j++
                    k=$int2(buf+6+j*4) // Swap and change signs of X corrections
                    $int2(buf+6+j*4)=-$int2(buf+6+(CORRY-j-1)*4)
                    $int2(buf+6+(CORRY-j-1)*4)=-k
                    k=$int2(buf+8+j*4) // Swap and change signs of Y corrections
                    $int2(buf+8+j*4)=-$int2(buf+8+(CORRY-j-1)*4)
                    $int2(buf+8+(CORRY-j-1)*4)=-k
                  enddo
                endif
                SYS.Sendimm(cmd,6+CORRY*4,buf)
                t[cmd]=Time()          // Timeout for this command
                column++
              else
                i++
              endif
            else if $A[cmd].length!=0 then
              if $A[cmd].answer==S_ERROR then
                if $A[cmd].length==8 then
                  // Error is reported by ROM.
                  $GLOBAL.crateloaded=-1
                  $GLOBAL.layloaded=-1
                  $GLOBAL.headloaded=-1
                  $GLOBAL.corrloaded=-1
                  reason=4; break
                else
                  reason=5; break
                endif
              else if $A[cmd].answer!=S_LOADRUN then
                reason=6; break
              else
                t[cmd]=0               // Column processed
                loadok=1
              endif
            else if Time()-t[cmd]>3000 then
              reason=2; break          // No answer within timeout
            endif
          enddo
          if column>=CORRX && i==ncmd break
          if $GLOBAL.a5==0 wait        // Significantly accelerates A5 booting
        enddo
      endif
      // Load legacy head camera corrections.
      if reason==0 && $LAY.cameras==0 && ($LAY.headcameras & (1<<head))!=0 then
        if (cext.mode & CE_VALIDHCAM)==CE_VALIDHCAM then
          Fseek(f,CORRX*CORRY*4+256,0);
          len=Fread(corr,CORRX*CORRY*4,f)
          if len!=CORRX*CORRY*4 reason=3
        else
          Memset(corr,0,CORRX*CORRY*4)
        endif
        column=0                       // Column to be sent next
        for cmd=0,cmd<ncmd,cmd++ do
          t[cmd]=0
        enddo
        while reason==0 do
          if Pressed(hexit) then
            reason=1; break
          endif
          i=0                          // Number of free commands
          for cmd=0,cmd<ncmd,cmd++ do
            if cmd>0 && loadok==0                                              \
              break                    // Load status is not yet clear
            if t[cmd]==0 then
              if column<CORRX then     // OK to send next column
                buf[0]=S_LOADRUN
                buf[1]=0x10            // Load head camera corrections
                $uint2(buf+2)=head
                $uint2(buf+4)=column
                Memcpy(buf+6,corr[column],CORRY*4)
                SYS.Sendimm(cmd,6+CORRY*4,buf)
                t[cmd]=Time()          // Timeout for this command
                column++
              else
                i++
              endif
            else if $A[cmd].length!=0 then
              if $A[cmd].answer==S_ERROR then
                if $A[cmd].length==8 then
                  $GLOBAL.crateloaded=-1 // Error reported by ROM
                  $GLOBAL.layloaded=-1
                  $GLOBAL.headloaded=-1
                  $GLOBAL.corrloaded=-1
                  reason=4; break
                else
                  reason=5; break
                endif
              else if $A[cmd].answer!=S_LOADRUN then
                reason=6; break
              else
                t[cmd]=0               // Column processed
                loadok=1
              endif
            else if Time()-t[cmd]>3000 then
              reason=2; break          // No answer within timeout
            endif
          enddo
          if column>=CORRX && i==ncmd break
          if $GLOBAL.a5==0 wait        // Significantly accelerates A5 booting
        enddo
      endif
      // Load optional corrections. Support is already verified.
      for i=0,i<4 && reason==0,i++ do
        if cext.optdata[i]==0 continue
        if cext.optdata[i]<CORRX*CORRY*8+256 then
          reason=7; break
        endif
        Fseek(f,cext.optdata[i],0)
        len=Fread(copt,256,f)
        if len!=256 then
          reason=3; break
        else
          buf[0]=S_LOADRUN
          buf[1]=17                    // Load optional correction data
          $uint2(buf+2)=head
          $uint2(buf+4)=0
          Memcpy(buf+6,copt,256)
          SYS.Sendimm(0,6+256,buf)
          t[0]=Time()
          // Note that I do not analyse the answer, only its presence. Which
          // part of the word 'optional' you don't understand?
          while $A[0].length==0 do
            if Time()-t[0]>3000 then
              reason=2; break
            else if Pressed(hexit) then
              reason=1; break
            endif
            wait
          enddo
          extended=1
        endif
      enddo
    endif
    Fclose(f)
    if reason==0 continue              // No error
    for cmd=0,cmd<ncmd,cmd++ do
      SYS.Killimm(cmd)                 // Remove remaining pending commands
    enddo
    change hprog limits=0,0
    if reason==1 then
      change hprog name="校正文件加载进程中断"
      return -1
    else if reason==2 then
      change hprog name="加载校正数据超时"
      return -2
    else if reason==3 then
      change hprog name=format("错误读取 %s",path)
      return -1
    else if reason==4 then
      change hprog name="内核未加载"
      return -2
    else if reason==5 then
      change hprog name="内核报告引导错误"
      return -1
    else if reason==6 then
      change hprog name="内核响应异常"
      return -1
    else if reason==7 then
      change hprog name=format("无效的格式 %s",path)
      return -1
    endif
  enddo
  // Load, if supported, shuttle Y corrections.
  if (cratefeatures & CF_CRATEXCOR)!=0 then
    change hprog limits=0,0
    change hprog text="Loading Y corrections"
    Memset(shycor0,0,Sizeof(shycor0))
    Memset(shycor1,0,Sizeof(shycor1))
    fna[patch]='S'
    fna[patch+1]='Y'
    fna[patch+2]='\0'
    Fnmerge(path,drv,dir,fna,ext)
    f=Fopen(path,"rb")
    if f!=NULL then
      len=Fread(csy,Sizeof(csy),f)
      if len!=Sizeof(csy) ||                                                   \
        (csy.shycor0!=0 && csy.shycor0<Sizeof(csy)) ||                         \
        (csy.shycor1!=0 && csy.shycor1<Sizeof(csy))                            \
      then
        change hprog name=format("无效的格式 %s",path)
        return -1
      else if csy.shycor0==0 && csy.shycor1==0 then
        ;                              // Shuttle Y corrections absent
      else
        if csy.caldate!=0 && $LAY.caldate!=0 &&                                \
          csy.caldate!=$LAY.caldate && warncaldate!=0                          \
        then
          warncaldate=0
          hconfirm=control WINDOW
            window=NULL
            position=10,10,410,180
            name="Y校正数据日期差异"
            bkcolor=YELLOW
            mode=M_MODAL
            size=1024
          endc
          draw window=hconfirm font=MEDIUMFONT color=BLACK
          draw at 10,30 wrap=405
          draw text="According to the layout, tester was last calibrated on "
          Strtime(s,"%B %d, %Y",2,$LAY.caldate)
          draw color=LIGHTRED text=format("%s",s) color=BLACK
          draw text=", but Y shuttle corrections were produced on "
          Strtime(s,"%B %d, %Y",2,csy.caldate)
          draw color=LIGHTRED text=format("%s",s) color=BLACK
          draw text=". If Y corrections and layout don't match, you may "
          draw text="miss pads during Y shuttle movements (component test). "
          draw text="New calibration will solve this problem."
          draw show
          hok=control BUTTON
            window=hconfirm
            position=145,145,120,25
            text="确定"
            font=MEDIUMFONT
            limits=15000,0
          endc
          while 1 do
            if Pressed(hok) break
            wait
          enddo
          destroy hconfirm
        endif
        if csy.shycor0!=0 then
          Fseek(f,csy.shycor0,0)
          len=Fread(shycor0,Sizeof(shycor0),f)
          if len<12 || shycor0.key!=0x00594853 ||                              \
            shycor0.ny<1 || shycor0.ny>40 || len<12+12*(shycor0.ny*2+1)        \
          then
            change hprog name=format("无效的格式 %s",path)
            return -1
          endif
        endif
        if csy.shycor1!=0 then
          Fseek(f,csy.shycor1,0)
          len=Fread(shycor1,Sizeof(shycor1),f)
          if len<12 || shycor1.key!=0x00595253 ||                              \
            shycor1.ny<1 || shycor1.ny>40 || len<12+12*(shycor1.ny*2+1)        \
          then
            change hprog name=format("无效的格式%s",path)
            return -1
          endif
        endif
      endif
    endif
    buf[0]=S_LOADRUN
    buf[1]=17                          // Load additional calibration data
    $uint2(buf+2)=0xFF                 // Crate controller
    $uint2(buf+4)=0                    // Reserved for the future
    if shycor0.ny==0 then
      $int4(buf+6)=0x00594853          // Left/only shuttle Y corrections
      $float4(buf+10)=10000.0          // Step
      $int4(buf+14)=1                  // Number of steps in each direction
      Memset(buf+18,0,3*12)
      SYS.Sendimm(0,18+3*12,buf)
    else
      Memcpy(buf+6,shycor0,12+(shycor0.ny*2+1)*12)
      SYS.Sendimm(0,6+12+(shycor0.ny*2+1)*12,buf)
    endif
    if shycor1.ny==0 then
      $int4(buf+6)=0x00595253          // Right shuttle Y corrections
      $float4(buf+10)=10000.0          // Step
      $int4(buf+14)=1                  // Number of steps in each direction
      Memset(buf+18,0,3*12)
      SYS.Sendimm(1,18+3*12,buf)
    else
      Memcpy(buf+6,shycor1,12+(shycor1.ny*2+1)*12)
      SYS.Sendimm(1,6+12+(shycor1.ny*2+1)*12,buf)
    endif
    t[0]=Time()
    delay 350
    while $A[0].length==0 || $A[1].length==0 do
      if Time()-t[0]>3000 then
        change hprog name="加载校正数据超时"
        return -2
      else if Pressed(hexit) then
        change hprog name="加载校正数据经常中断"
        return -1
      endif
      wait
    enddo
  endif
  change hprog limits=0,0
  if extended then
    change hprog name="扩展校正文件加载完成"
    lprintf(BLACK,"扩展校正文件已加载")
  else
    change hprog name="校正数据已加载"
    lprintf(BLACK,"校准文件已加载")
  endif
  $GLOBAL.corrloaded=1
  delay 250
  return 0
end

function int main()
  
  // add beg 240428
  int lastSlashIndex  //文件路径中最后一个\的索引
  char cname[256],lname[256],fname[256],rname[256],folder[256],temp[256] //定义四个路径的存储
  // add end
  
  
  char name[256],buf[32]
  int i,j,t,ident,loadall,err
  
  Createcontrols()
  
  warncaldate=1
  for i=0,i<6,i=i+1
    status[i]=-1
  enddo
  if $GLOBAL.headloaded!=1 then
    buf[0]=S_LAYOUT
    buf[1]=0x02                        // Read current layout "as is"
    Enablebuttons(1)
    t=Time()
    ident=SYS.Sendimm(0,2,buf)
    while $A[0].length==0 do
      j=(Time()-t)/1000
      if Pressed(hexit) || j>5 then
        SYS.Killsend(ident)
        break
      endif
      change hprog name=format("确定当前测试机状态")
      delay 100
    enddo
    if $A[0].length!=0 then
      SYS.Broadcast(8,"CHG LAY")       // Inform others that layout changed
      if $A[0].answer==S_LAYOUT && $A[0].length==774 then
        $GLOBAL.crateloaded=1          // Software loaded
        $GLOBAL.layloaded=1
        // To determine whether head controllers are loaded or not, read
        // version string.
        buf[0]=S_DUMP                  // Get version of embedded software
        buf[1]=255                     // Request to crate controller
        buf[2]=0x14                    // Get software version
        $uint2(buf+3)=0                // Number of items
        $uint2(buf+5)=0                // Start item
        ident=SYS.Sendimm(1,7,buf)
        while $A[1].length==0 do
          j=(Time()-t)/1000
          if Pressed(hexit) || j>5 then
            SYS.Killsend(ident)
            break
          endif
          change hprog name=format("确定当前测试机状态")
          delay 100
        enddo
        if $A[1].length!=0 && $A[1].answer==S_DUMP then
          j=5                          // Correct answer, extract subfields
          for i=j,i<$A[1].length,i++
            if $A[1].rawdata[i]==0x0A break
          enddo
          j=i+1
          for i=j,i<$A[1].length,i++
            if $A[1].rawdata[i]==0x0A break
          enddo
          j=i+1
          for i=j,i<$A[1].length,i++
            if $A[1].rawdata[i]==0x0A then
              $A[1].rawdata[i]='\0'; break
            endif
          enddo
          if Strnicmp($A[1]+j,"Unavailable",12)==0 then
            $GLOBAL.headloaded=0
          else
            $GLOBAL.headloaded=1
          endif
        else                           // Probably invalid but compatible way
          $GLOBAL.headloaded=1
        endif
        if $LAY.nfing<=0 || $LAY.nfing>16 then
          Memcpy($LAY,$A[0]+6,768)
          Memset($EXTLAY,0,768)
          Memset($EXT0,0,768)
          Memset($EXT1,0,768)
          Memset($EXT2,0,768)
          Memset($EXT3,0,768)
          for i=0,i<16,i++ do          // Same offsets in tester & inner copy
            $LAYCORR.leftzerox[i]=$LAY.leftzerox[i]
            $LAYCORR.leftzeroy[i]=$LAY.leftzeroy[i]
            $LAYCORR.rightzerox[i]=$LAY.rightzerox[i]
            $LAYCORR.rightzeroy[i]=$LAY.rightzeroy[i]
          enddo
          if $LAY.extlay!=0 then
            change hprog name="读取布局扩展文件"
            buf[0]=S_LAYOUT
            buf[1]=15                  // Read main layout extention
            SYS.Sendimm(0,2,buf)
            for i=1,i<$LAY.extlay && i<5,i++ do
              buf[1]=20                // Read additional layout extention
              $int4(buf+2)=i-1         // Index
              SYS.Sendimm(i,6,buf)
            enddo
            t=Time()
            while 1 do
              err=0
              for i=0,i<$LAY.extlay && i<5,i++ do
                if $A[i].length==0 then
                  err=1; break         // As yet no answer
                else if $A[i].answer!=S_LAYOUT ||                              \
                  $A[i].length!=(i==0?774:778) then
                  err=2; break         // Invalid answer
                endif
              enddo
              if err!=1 break
              if Time()-t>5000 break   // Timeout 5 seconds
              wait
            enddo
            if err==0 then
              Memcpy($EXTLAY,$A[0]+6,768)
              if $LAY.extlay>=2 Memcpy($EXT0,$A[1]+10,768)
              if $LAY.extlay>=3 Memcpy($EXT1,$A[2]+10,768)
              if $LAY.extlay>=4 Memcpy($EXT2,$A[3]+10,768)
              if $LAY.extlay>=5 Memcpy($EXT3,$A[4]+10,768)
            else
              $GLOBAL.layloaded=-1     // Incomplete layout
            endif
            $LAY.extlay=0
          endif
          change hprog name="当前测试机布局已加载"
          delay 500
        endif
      else if $A[0].answer==0x10 && $A[0].subansw==0 then
        $GLOBAL.crateloaded=-1         // Software not loaded
        $GLOBAL.layloaded=-1
        $GLOBAL.headloaded=-1
        $GLOBAL.corrloaded=-1
      else if $A[0].answer==0x10 && $A[0].subansw==1 then
        $GLOBAL.crateloaded=1          // Head controllers not loaded
        $GLOBAL.headloaded=-1
      endif
      change hprog name="准备载入"
    else
      change hprog name="无法确定测试机状态"
      $GLOBAL.crateloaded=0            // Load status is undefined
      $GLOBAL.layloaded=0
      $GLOBAL.headloaded=0
      $GLOBAL.corrloaded=-1            // Safety first!
    endif
  else
    change hprog name="准备载入"
  endif
  if Argv(name)!=0 then
    if (Stricmp(name,"CHECKONLY")==0 && $GLOBAL.headloaded==1) then
      change hprog name="测试机已经载入"
      delay 200
      return
    else if (Stricmp(name,"ALL")==0) then
      loadall=1
    endif
  endif
  while 1 do
    Enablebuttons(0)
    if Pressed(hcnam) then
      setfocus hlnam
    else if Pressed(hlnam) then
      setfocus hfnam
    else if Pressed(hfnam) then
      setfocus hrnam
    else if Pressed(hrnam) then
      setfocus hcnam
    else if Pressed(hcbro) then
      Text(hcnam,name)
      if SYS.Browse(hmain,name,"内核控制器",0)!=0 then
        change hcnam text=name
	  //提取除文件名外的路径，从后向前遍历字符串
		for i = 256 - 1, i >= 0, i-- do
			if name[i] == '\\' then  // 找到最后一个反斜杠
				lastSlashIndex = i  // 记录反斜杠的索引
				break  // 退出循环
			endif
		enddo
	  //从前往后遍历赋值
		for i=0,i<lastSlashIndex,i++ do
			//if name[i]!='\\'then
				temp[i]= name[i]
			//endif
		enddo
	  //4个文件路径	
	  sprintf(cname,"%s\\%s",temp,"F_prog.bin")
	  sprintf(lname,"%s\\%s",temp,"f_layout.bin")
	  sprintf(fname,"%s\\%s",temp,"F_prog.bin")
	  sprintf(rname,"%s\\%s",temp,"rail0L.cor")
	  
	  //查看赋值，测试
	  change hcnam text=temp//cname
	  //change hlnam text=temp//lname
	  //change hfnam text=fname
	  //change hrnam text=rname
	  //
      endif
    else if Pressed(hlbro) then
      Text(hlnam,name)
      if SYS.Browse(hmain,name,"布局",0)!=0 then
        change hlnam text=name
      endif
    else if Pressed(hfbro) then
      Text(hfnam,name)
      
      if SYS.Browse(hmain,name,"测试头控制器",0)!=0 then
        change hfnam text=name

	  //提取除文件名外的路径，从后向前遍历字符串
		for i = 256 - 1, i >= 0, i-- do
			if name[i] == '\\' then  // 找到最后一个反斜杠
				lastSlashIndex = i  // 记录反斜杠的索引
				break  // 退出循环
			endif
		enddo
        
	  //从前往后遍历赋值
		for i=0,i<lastSlashIndex,i++ do
			//if name[i]!='\\'then
				temp[i]= name[i]
			//endif
		enddo
	  //4个文件路径	
	  sprintf(cname,"%s\\%s",temp,"F_prog.bin")
	  sprintf(lname,"%s\\%s",temp,"f_layout.bin")
	  sprintf(fname,"%s\\%s",temp,"F_prog.bin")
	  sprintf(rname,"%s\\%s",temp,"rail0L.cor")
	  
	  //查看赋值，测试
	  //change hcnam text=cname//cname
	  //change hlnam text=lname//lname
	  change hfnam text=temp
	 // change hrnam text=rname
	  
        
      endif
    else if Pressed(hrbro) then
      Text(hrnam,name)
      if SYS.Browse(hmain,name,"校正数据",0)!=0 then
        change hrnam text=name
      endif
	  
	//同时更换4个load时的name
    else if Pressed(hcbtn) then
      confirm hcnam
      //Text(hcnam,name)
      Enablebuttons(1)
      Loadcrate(cname)
    else if Pressed(hlbtn) then
      if $GLOBAL.layloaded==1 then
        if $LAY.nfing>0 && $LAY.nfing<=16 then
          Loadlayout("",1)             // Reload layout from memory
        else
          confirm hlnam
          //Text(hlnam,name)
          Loadlayout(lname,1)           // Reload layout from disk
        endif
      else
        confirm hlnam
        //Text(hlnam,name)
        Enablebuttons(1)
        Loadlayout(lname,0)
      endif
    else if Pressed(hfbtn) then
      confirm hfnam
      //Text(hfnam,name)
      Enablebuttons(1)
      Loadheads(fname)
    else if Pressed(hrbtn) then
      confirm hrnam
      //Text(hrnam,name)
      Enablebuttons(1)
      Loadcorrs(rname)
    //else if Pressed(hlall) || loadall!=0 then
	else if Pressed(hlall) then
      loadall=0
      confirm hcnam
      confirm hlnam
      confirm hfnam
      confirm hrnam
      i=0
      while 1 do
        Enablebuttons(1)
        if i!=0 then
          $GLOBAL.crateloaded=0        // Load status is undefined
          $GLOBAL.layloaded=0
          $GLOBAL.headloaded=0
          $GLOBAL.corrloaded=-1        // Safety first!
          Enablebuttons(1)
          delay 1000
        endif
        i=i+1
		$GLOBAL.crateloaded = 0
        if ($GLOBAL.crateloaded!=1) then
          //Text(hcnam,name)
		  
		  
          i=Loadcrate(cname)
          if i==(-2) continue
          if i==(-1) goto quitloadall
          Enablebuttons(1)
        endif
		
		$GLOBAL.layloaded=0
        if ($GLOBAL.layloaded!=1) then
          Text(hlnam,name)
          i=Loadlayout(lname,0)
          if i==(-2) continue
          if i==(-1) goto quitloadall
          Enablebuttons(1)
        endif
		$GLOBAL.headloaded = 0
        if ($GLOBAL.headloaded!=1) then
          Text(hfnam,name)
          i=Loadheads(fname)
          if i==(-2) continue
          if i==(-1) goto quitloadall
          Enablebuttons(1)
        endif
        Text(hrnam,name)
        i=Loadcorrs(rname)
        if i==(-1) goto quitloadall
        if i==0 break
      enddo
      change hprog name="全部完成"
      lprintf(BLACK,"测试机已加载")
      Enablebuttons(1)
      delay 1000                       // Automatically close the window if
      break                            // tester is correctly loaded
    quitloadall:
      Enablebuttons(1)
    else if Pressed(hdmod) then
      //SERV.Debugmode(NULL,&hexit,0)
      //change hdmod color=(Istrivialdebug()?BLACK:RED)
      if $GLOBAL.layloaded==1 then
        if $LAY.nfing>0 && $LAY.nfing<=16 then
          Loadlayout("",1)             // Reload layout from memory
        else
          confirm hlnam
          //Text(hlnam,name)
          Loadlayout(lname,1)           // Reload layout from disk
        endif
      else
        confirm hlnam
        //Text(hlnam,name)
        Enablebuttons(1)
        Loadlayout(lname,0)
      endif
    else if Pressed(hsoft) then
      Enablebuttons(1)
      SYS.Softimm(0)
      change hprog limits=0,0
      change hprog name="软件复位..."
      while $A[0].length==0 do
        if Pressed(hexit) break        // Button "Exit" works as an interrupt
        wait
      enddo
      if $A[0].length!=0 then
        change hprog name="软复位完成"
      else
        change hprog name="不再等待软件复位"
      endif
    else if Pressed(hhard) then
      Enablebuttons(1)
      SYS.Broadcast(11,"HARD RESET")   // Inform others to stop activity
      SYS.Hardimm(0)
      change hprog limits=0,0
      change hprog name="硬件复位"
      while $A[0].length==0 do
        if Pressed(hexit) break        // Button "Exit" works as an interrupt
        wait
      enddo
      if $A[0].length!=0 then
        $GLOBAL.crateloaded=-1         // Software not loaded
        $GLOBAL.layloaded=-1
        $GLOBAL.headloaded=-1
        $GLOBAL.corrloaded=-1
        if $GLOBAL.a5==0 then
          delay 4000                   // Crate performs self-test
        else
          delay 500
        endif
        change hprog name="硬件复位完成"
        SYS.Broadcast(9,"CHG LOAD")    // Inform others to recheck load status
      else
        change hprog name="不再等待硬件复位"
      endif
    else if Pressed(hboot) then
      Enablebuttons(1)
      buf[0]=S_DEBUG
      buf[1]=0x1D                      // Reboot Crate
      $uint4(buf+2)=0x12345678         // Password
      $uint4(buf+6)=0                  // Must be zero
      $uint4(buf+10)=0
      $uint4(buf+14)=0
      SYS.Sendimm(0,18,buf)
      t=Time()
      while $A[0].length==0 do
        if Time()-t>2000 break
        if Pressed(hexit) break
        wait
      enddo
      if $A[0].length==0 || $A[0].answer!=S_DEBUG then
        change hprog name="工控机重启请求失败"
      else
        $GLOBAL.crateloaded=-1           // Software not loaded
        $GLOBAL.layloaded=-1
        $GLOBAL.headloaded=-1
        $GLOBAL.corrloaded=-1
        change hprog name="工控机引导请求已发送"
        SYS.Broadcast(9,"CHG LOAD")    // Inform others to recheck load status
      endif
      Enablebuttons(0)
    else if Pressed(hexit) then
      break
    endif
    wait
  enddo
  SYS.Broadcast(9,"CHG LOAD")          // Inform others to recheck load status
end

