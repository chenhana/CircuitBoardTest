#include "ls.icl"
#include "or.icl"
#zeroid

#define VERSION        "1.57"
#define DESCRIPTION    "Simple helpers"

// 1.11: Added support for S_RLMEAS.
// 1.12: Several new Crate controller ports.
// 1.13: Comments for OUTPORT32.
// 1.14: Minimal stroke 5 mm/s with 5 mm/s step.
// 1.15: Wide Y-only zones in random test.
// 1.16: Custom 32-bit ports, support for ALL in Portio32().
// 1.17: History viewer in Portio32().
// 1.18: Head camera support.
// 1.19: Max HV rising speed 200 V/ms for A5.
// 1.20: MSD measurements.
// 1.21: Default headcam radii changed to 118 and 153 mm.
// 1.22: LATEST initialization window.
// 1.23: Updated LATEST initialization.
// 1.24: HV initialization includes extended (10 GOhm) range.
// 1.25: LATEST initialization includes frequency.
// 1.26: Exact R measurements in Random test.
// 1.27: Field and capacity parameters.
// 1.28: LATEST initialization allows manual corrections.
// 1.29: More special features for Portio32().
// 1.30: Shuttle vacuum on/off.
// 1.31: Additional HVINIT error bits.
// 1.32: Bug in LATEST initialization.
// 1.33: Portio32() saves protocol presentation mode to .ini.
// 1.34: Move left/move right only in Random test.
// 1.35: Button for low resistance test.
// 1.36: CUSTOM command and better pasting to clipboard in Move().
// 1.37: Extended voltage and frequency ranges in FCinit().
// 1.38: Button "Play test" (starts a5mplay.scr).
// 1.39: "Long" HV initialization.
// 1.40: Support for A7/A8.
// 1.41: Support for 1000 V HV measurements.
// 1.42: Improved Random test.
// 1.43: Read-only access to head camera registers.
// 1.44: Illumination options in Find.
// 1.45: 500 V MSD voltage limit.
// 1.46: Version of measurement card software.
// 1.47: 2-um accuracy and delay in random test.
// 1.48: EXtended set of frequencies in FCinit().
// 1.49: Indicates working vacuum pump by highlighting the button.
// 1.50: Low R limit in HV measurements.
// 1.51: Unipolar HV measurements, saving of HV options to .ini file.
// 1.52: Move and Random test stop if tester is not loaded.
// 1.53: Focus for dedicated cameras.
// 1.54: Shuttle in random test.
// 1.55: Exact R retest in Random test.
// 1.56: Move allows for positions outside the working area.
// 1.57: Illumination type for S3 cameras.

#multinst
#cmdbuff 3

#define MINV           5               // Min allowed stroke, mm/s
#define MAXV           150             // Max allowed stroke, mm/s
#define VSTEP          5               // Stroke step, mm/s
#define MINP           10              // Min allowed pressure, g
#define MAXP           120             // Max allowed pressure, g
#define PSTEP          10              // Pressure step, g

#define AWM_NONE       0               // Answer to be discarded
#define AWM_MOVE       1               // Answer from Move
#define AWM_PORT       2               // Answer from Port
#define AWM_HV         3               // Answer from HVinit
#define AWM_RAND       4               // Answer from Rand
#define AWM_EXACTR     5               // Answer from Exactrinit
#define AWM_RINIT      6               // Answer from Rinit
#define AWM_PORT32     7               // Answer from Port32
#define AWM_MSDINIT    8               // Answer from Msdinit
#define AWM_LAINIT     9               // Answer from Lainit
#define AWM_RLINIT     10              // Answer from Rlinit
#define AWM_FCINIT     11              // Answer from FCinit

// Layout configuration bits.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae
// Alternative (old) interpretation of LC_OHTYPE bits.
#define LC_PHASEADJ    0x00000800      // On-heads with adjustable field phase
#define LC_ACTIVEONHD  0x00000400      // Active on-heads (with Dallas/R1-R4)
// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMSPLIT     0x20000000      // L&M auto split shuttle
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_SPLITAUTO   (LC_LMSPLIT|LC_A2LOADER)
#define LC_LMMANUAL    (LC_LMMAN|LC_A2LOADER)
#define LC_LMAUTO      (LC_LM|LC_A2LOADER)
#define LC_LMS2AUTO    (LC_LMS2|LC_A2LOADER)
#define LC_EPCOSAUTO   (LC_EPCOS|LC_A2LOADER)

// Features of the measurement card.
#define HCM_HV1MA      0x00000001      // Force 1 mA during HV measurements
#define HCM_STRICT     0x00000002      // 20% stricter self-test
#define HCM_NOCTCHK    0x00000004      // Don't check contacts (except ExactR)
#define HCM_PARCONT    0x00000008      // Check influence of parallel contacting
#define HCM_NOACCEL    0x00000010      // Do not accelerate reed relays
#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements
#define HCM_CTOEXT     0x00000040      // Calibrate capacity to shuttle (extant)
#define HCM_ISOEANT    0x00000080      // External antennas isolated
#define HCM_FILTMASK   0x00000F00      // Mask to extract signal filtering
#define   HCM_FNONE    0x00000000      // No signal filtering
#define   HCM_F500K    0x00000100      // 500 kHz filter
#define   HCM_F100K    0x00000200      // 100 kHz filter
#define   HCM_F20K     0x00000300      // 20/50 kHz filter
#define HCM_FILTERC    0x00001000      // Filter C measurements over 300 pF
#define HCM_EXRLONG    0x00002000      // Long EXACTR with 300 mA source
#define HCM_HVTYPE     0x000F0000      // Mask to extract type of HV elecronics
#define   HCM_HV500    0x00000000      // Card is capable of 500 V HV
#define   HCM_HV1000   0x00010000      // Card is capable of 1000 V HV
#define   HCM_HVAUTO   0x00070000      // Autodetect HV capabilities

external int SERV.Decodeanswer(char *answer,char *text,char *extra,int mask);
external int SERV.Options(int);

handle           hhead[4],hxcoo[4],hycoo[4],hradi[4],haccu[4]
handle           hhscr[4],hxscr[4],hyscr[4],hrscr[4],hascr[4]
handle           hansw
handle           hvaon,hvaof
int              answermode            // One of AWM_xxx
int              repeat,terminate,layoutchanged,hardreset,answinfo
char             answ[80]
int              sent[16],nansw        // Used by Random test
int              rmin,rmax             // Used by Random test
float            rvalue[7] = {                                                 \
  -9.0e99, 1, 10, 1e3, 1e6, 1e8, 9e99 }
int              stoprequest           // Stop requested by Answerproc()

function int Answerproc(char *answer,int info)
  char text[256],extra[2048]
  int i,sta,color,valid
  float r
  if answer[4]==S_SYSTEM && answer[5]==126 && $GLOBAL.a5!=0 then
    // Liveness notification. New Crate sends state of vacuum pump.
    if answer[19]==2 then
      change hvaon color=YELLOW
      change hvaon bkcolor=LIGHTRED
    else
      change hvaon color=BLACK
      change hvaon bkcolor=GRAY
    endif
  else if answer[2]==0 then            // No messages with zero ID
    ;
  else if answer[4]==0xF0 then         // Message
    if Stricmp(answer+5,"FREE MAIN")==0 terminate=1
    if Stricmp(answer+5,"CHG LAY")==0 layoutchanged=1
    if Stricmp(answer+5,"HARD RESET")==0 hardreset=1
  else if answermode==AWM_MOVE then    // Answer to command from Move
    color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
    if color==(-1) return
    change hansw color=color
    add hansw text=text
    repeat=repeat|info
    if answer[4]==S_ERROR && (answer[5]==0 || answer[5]==1) then
      stoprequest=1
    endif
  else if answermode==AWM_PORT then    // Answer to command from Port I/O
    if answer[4]==0x20 && $uint2(answ)==0 then
      Memcpy(answ,answer,80)
      answinfo=info
    endif
  else if answermode==AWM_HV then      // Answer to command from HVinit
    if answer[4]==0x0F && $uint2(answer)>=29 then
      // Extended HVINIT answer needs more compact form to be visible.
      color=BLACK
      i=sprintf(text,"HV%i",$int2(answer+9))
      sta=$uint4(answer+5)
      if sta==0 then
        i=i+sprintf(text+i," OK")
      else
        i=i+sprintf(text+i," 0x%X",sta)
        color=RED
      endif
      if ($int2(answer+11) & 0x0001) i=i+sprintf(text+i,", unipolar")
      if $float4(answer+13)!=0                                                 \
        i=i+sprintf(text+i,", %g V",$float4(answer+13))
      if $float4(answer+17)>=1.0e9 then
        i=i+sprintf(text+i,", %g G",$float4(answer+17)/1.0e9)
      else if $float4(answer+17)!=0.0 then
        i=i+sprintf(text+i,", %g M",$float4(answer+17)/1.0e6)
      endif
    else
      color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
    endif
    if color==(-1) return
    change hansw color=color
    add hansw text=text
    if answer[4]==0x0F && $long(answer+5)!=0 then
      change hansw color=DARKGRAY
      i=$long(answer+5)
      if (i & 0x00000001) add hansw text=" - high ADC offset"
      if (i & 0x00000002) add hansw text=" - high I/U convertor offset"
      if (i & 0x0000000C) add hansw text=" - high PGA offset"
      if (i & 0x00000030) add hansw text=" - bad HV supply voltage"
      if (i & 0x00000040) add hansw text=" - offset in current monitor"
      if (i & 0x00000180) add hansw text=" - bad output current"
      if (i & 0x00000200) add hansw text=" - defect in HV source"
      if (i & 0x00000400) add hansw text=" - offset in voltage ctrl"
      if (i & 0x00000800) add hansw text=" - bad or unstable voltage"
      if (i & 0x00003000) add hansw text=" - bad PGA amplification"
      if (i & 0x0000C000) add hansw text=" - high residual voltage"
      if (i & 0x003F0000) add hansw text=" - bad time constant(s)"
      if (i & 0x00400000) add hansw text=" - high PGA offset"
      if (i & 0x00800000) add hansw text=" - wrong PGA amplification"
      if (i & 0x01000000) add hansw text=" - noisy measurements"
      if (i & 0x02000000) add hansw text=" - bad sensing resistors"
      if (i & 0x04000000) add hansw text=" - shortcut to shield"
      if (i & 0x80000000) add hansw text=" - HV card absent/damaged"
    endif
  else if answermode==AWM_RAND then    // Answer to command from Random test
    valid=0
    if info>=0 && info<16 && sent[info]>0 sent[info]--
    if answer[4]==S_MOVE && (answer[5]==M_RMEAS || answer[5]==M_EXACTR) then
      r=$float4(answer+8); valid=1
      if ($uint2(answer+6) & 0x0100)!=0 r=r*1.0e-6
    else if answer[4]==S_MOVE && answer[5]==M_LAMEAS then
      r=Abs($float4(answer+8)); valid=1
    else if answer[4]==S_DEBUG then
      r=0.0; valid=1
    else if answer[4]==S_NOP then
      r=0.0; valid=1
    endif
    if r<rvalue[rmin] || r>rvalue[rmax+1] valid=0
    if (valid==1 || answer[4]==S_ERROR) then
      nansw++
      color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
      if color==(-1) return
      change hansw color=color
      if Memcmp(text,"RMEAS ",6)==0 then
        add hansw text=format("%-6i %i: %s",nansw,info,text+6)
      else
        add hansw text=format("%-6i %i: %s",nansw,info,text)
      endif
    endif
    if answer[4]==S_ERROR && (answer[5]==0 || answer[5]==1) then
      stoprequest=1
    endif
  else if answermode==AWM_EXACTR then  // Answer to command from Exactrinit
    color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
    if color==(-1) return
    change hansw color=color
    add hansw text=text
  else if answermode==AWM_RINIT then   // Answer to command from Rinit
    color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
    if color==(-1) return
    change hansw color=color
    add hansw text=text
    if answer[4]==S_RINIT && $long(answer+5)!=0 then
      change hansw color=DARKGRAY
      i=$long(answer+5)
      if (i & 0x00000001) add hansw text=" - breakdown"
      if (i & 0x00000010) add hansw text=" - low HV supply voltage"
      if (i & 0x00000800) add hansw text=" - bad or unstable voltage"
      if (i & 0x80000000) add hansw text=" - HV card absent/damaged"
    endif
  else if answermode==AWM_MSDINIT then // Answer to command from Msdinit
    color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
    if color==(-1) return
    change hansw color=color
    add hansw text=text
    if answer[4]==S_CRTINIT && $long(answer+5)!=0 then
      change hansw color=DARKGRAY
      i=$long(answer+5)
      if (i & 0x00000010) add hansw text=" - low HV supply voltage"
      if (i & 0x00000800) add hansw text=" - bad or unstable voltage"
      if (i & 0x80000000) add hansw text=" - HV card absent/damaged"
    endif
  else if answermode==AWM_LAINIT then  // Answer to command from Lainit
    color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
    if color==(-1) return
    change hansw color=color
    add hansw text=text
    if answer[4]==S_LAINIT && $long(answer+5)!=0 then
      change hansw color=DARKGRAY
      i=$long(answer+5)
      if (i & 0x00000001) add hansw text=" - damaged current source"
      if (i & 0x00000002) add hansw text=" - damaged electronics"
      if (i & 0x00000008) add hansw text=" - no calibration defect"
      if (i & 0x00000010) add hansw text=" - unable to establish base line"
      if (i & 0x00000020) add hansw text=" - unable to calibrate defect"
      if (i & 0x80000000) add hansw text=" - LATEST extention absent"
    else if answer[4]==S_MOVE && answer[5]==0x43 && $int2(answer+6)!=0 then
      change hansw color=DARKGRAY
      i=$int2(answer+6)
      if (i & 0x8000) add hansw text=" - not initialized"
      if (i & 0x0800) add hansw text=" - bad line"
      if (i & 0x0020) add hansw text=" - open"
    endif
  else if answermode==AWM_RLINIT then  // Answer to command from Rlinit
    color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
    if color==(-1) return
    change hansw color=color
    add hansw text=text
    if answer[4]==S_RLINIT && $uint2(answer+5)!=0 then
      change hansw color=DARKGRAY
      i=$long(answer+5)
      if (i & 0x8000) add hansw text=" - measurement card absent"
      if (i & 0x4000) add hansw text=" - undeclared external device"
    endif
  else if answermode==AWM_FCINIT then  // Answer to command from FCinit
    color=SERV.Decodeanswer(answer,text,extra,0x7FFFFFFF)
    if color==(-1) return
    change hansw color=color
    add hansw text=text
  endif
end

function int Initsigma(float disp[])
  disp[0]=0.0
  disp[1]=0.0
  disp[2]=0.0
  disp[3]=0.0
  disp[4]=0.0
end

// Function adds next measured value to array disp[5] which accumulates data
// necessary to calculate normal dispersion, mean, minimal and maximal.
function int Addsigma(float disp[],float value)
  if disp[0]<=0.0 then
    disp[0]=1.0                        // First point, data is still undefined
    disp[1]=value
    disp[2]=value*value
    disp[3]=value
    disp[4]=value
  else
    disp[0]=disp[0]+1.0
    disp[1]=disp[1]+value
    disp[2]=disp[2]+value*value
    disp[3]=Min(disp[3],value)
    disp[4]=Max(disp[4],value)
  endif
end

// Function returns number of data items gathered by Addsigma().
function int Getcount(float disp[])
  return disp[0]
end

// Function calculates mean value based on data gathered by Addsigma().
function float Getmean(float disp[])
  if disp[0]<1.0 then
    return 0.0
  else
    return disp[1]/disp[0]
  endif
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmin(float disp[])
  return disp[3]
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmax(float disp[])
  return disp[4]
end

// Function calculates normal dispersion based on data gathered by Addsigma().
function float Getsigma(float disp[])
  float r
  if disp[0]<2.0 then
    return 0.0
  else
    r=(disp[0]*disp[2]-disp[1]*disp[1])/disp[0]/(disp[0]-1.0)
    if r<=0 then
      return 0.0
    else
      return Sqrt(r)
    endif
  endif
end

// Get parameters from specified line l (0..3) in the MOVE window and, if
// truncation flag t is set, correct them according to the layout. Returns -1
// if parameters are invalid or 0 otherwise.
function int Getline(int l,int *h,float *x,float *y,float *r,int *a,int t)
  int j
  char s[64]
  if (l<0 || l>3) return -1
  Text(hhead[l],s); h[0]=0; sscanf(s,"%i",h)
  h[0]=Max(0,Min(31,h[0]))
  if ($LAY.nfing>0 && t!=0) then
    j=$LAY.nfing*2-1; if $LAY.cameras!=0 j=j+2
    h[0]=Max(0,Min(j,h[0]))
  endif
  Text(hxcoo[l],s);
  x[0]=((l & 1)==0?$LAY.leftlimit:$LAY.rightlimit)/1000.0
  sscanf(s,"%f",x)
  Text(hycoo[l],s);
  y[0]=($LAY.bottom[h[0]/2]+$LAY.top[h[0]/2])/2000.0
  sscanf(s,"%f",y)
  Text(hradi[l],s); r[0]=0; sscanf(s,"%f",r)
  r[0]=Max(0.0,Min(64.0,r[0]))
  Text(haccu[l],s); a[0]=100; sscanf(s,"%i",a)
  a[0]=Max(0,Min(255,a[0]))
  if ($LAY.nfing>0 && t!=0) then
    x[0]=Max($LAY.leftlimit/1000.0,Min($LAY.rightlimit/1000.0,x[0]))
    y[0]=Max($LAY.bottom[h[0]/2]/1000.0,Min(($LAY.top[h[0]/2]-1)/1000.0,y[0]))
  endif
  return 0
end

// Set specified line l (0..3) in the MOVE window.
function int Setline(int l,int h,float x,float y,float r,int a)
  if (l<0 || l>3) return -1
  change hhead[l] text=format("%i",h)
  change hxcoo[l] text=format("%.3f",x)
  change hycoo[l] text=format("%.3f",y)
  change hradi[l] text=format("%.3f",r)
  change haccu[l] text=format("%i",a)
  return 0
end

#define GDX  382                       // Size of the video viewer
#define GDY  286
#define BORD 10                        // Free border, pixels
// Alows to find the MOVE pads (or single pad if twopads is 0) using video
// cameras (either dedicated or headcams). Returns 0 if Cancel button was
// pressed or some error occured (invalid layout, tester not loaded etc.) and 1
// otherwise. Layout of pad arrays: side,x,y - in millimeters.
function int Position(float *pad1,float *pad2,int twopads,int checkxy)
  int i,j,headcams,side,mirror,lights,move,roughmode
  int izoom,pad,update,videoon,chgvideo,redraw
  int focus[2],updatefocus[2]
  int videox,videoy,ymin,ymax,dx,dy,channel,extexp
  float x,y,xsc,ysc,scale,zoom,step,miny,maxy
  float headcamradius,delta,angle,outx,outy
  char s[80]
  handle hmain,hview,hpad1,hpad2,h1to2,hquit,hdone
  handle hside,hxcoo,hycoo,hstep,hstes,hroug
  handle hbrit,hcont,hitop,hiske,hiexp,hzoom,hzoos,hmirr
  handle hfocusup,hfocus,hfocusdn
  handle hchgs,hupup,hdown,hleft,hrigh
  if $LAY.cameras!=0 then
    headcams=0
  else
    headcams=$LAY.headcameras
    miny=$LAY.bottom[0]/1000.0
    maxy=$LAY.top[0]/1000.0
    for i=1,i<$LAY.nfing,i++ do
      miny=Min(miny,$LAY.bottom[i]/1000.0)
      maxy=Max(maxy,$LAY.top[i]/1000.0)
    enddo
  endif
  if $EXTLAY.headcamradius!=0 then
    headcamradius=$EXTLAY.headcamradius/1000.0
  else if $LAY.top[0]-$LAY.bottom[0]>160000 then
    headcamradius=153.0
  else
    headcamradius=118.0
  endif
  SYS.Videosize(0,&videox,&videoy,&i);
  hmain=control WINDOW                 // Main window
    window=NULL
    position=10,10,510,355
    name="查找焊盘"
    help=" "
    bkcolor=LIGHTYELLOW
    mode=M_NOMINIMIZE
    size=256
  endc
  dy=(twopads?34:0)
  draw window=hmain color=BROWN
  draw at 6,318 text="亮"
  draw at 6,346 text="对"
  draw at 397,46+dy text="面:"
  draw at 397,71+dy text="X:"
  draw at 397,95+dy text="Y:"
  draw at 397,282 text="步距:"
  if ($LAY.config & LC_TYPEMASK)==LC_S3 then
    draw at 220,318 text="缩放"
  else
    draw at 240,318 text="缩放"
  endif
  draw show
  zoom=0.5; step=0.010; mirror=1; extexp=0
  Getini("Debug","FIND","%f,%f,%i,%i,%i",&zoom,&step,&mirror,&lights,&extexp)
  if zoom<0.15 then
    izoom=6; zoom=0.166666666
  else if zoom<0.18 then
    izoom=5; zoom=0.2;
  else if zoom<0.22 then
    izoom=4; zoom=0.25;
  else if zoom<0.35 then
    izoom=3; zoom=0.333333333
  else if zoom<0.55 then
    izoom=2; zoom=0.5
  else if izoom<1.1 then
    izoom=1; zoom=1.0
  else
    izoom=0; zoom=2.0
  endif
  if lights==0 then
    lights=0x04
  endif
  hview=control GRAPH
    window=hmain
    position=7,7,GDX,GDY
    help="单击移动相机，或使用定位按钮"
    bkcolor=VIDEOFILL
  endc
  if twopads then
    hpad1=control BUTTON
      window=hmain
      position=395,6,50,21
      name="焊盘1"
      help="按下可选择第一个焊盘的位置"
    endc
    hpad2=control BUTTON
      window=hmain
      position=450,6,50,21
      name="焊盘2"
      help="按下可选择第二个焊盘的位置"
    endc
    h1to2=control BUTTON
      window=hmain
      position=395,31,50,18
      name="复制"
      help="按下可将坐标从焊盘1复制到焊盘2"
    endc
  endif
  hside=control TEXT
    window=hmain
    position=435,28+dy,45,21
    help="搜索所选焊盘的位置"
    mode=M_BORDER|M_CENTERED
    font=MEDIUMFONT
  endc
  hchgs=control BUTTON
    window=hmain
    position=479,28+dy,21,21
    help="按下可重新切换到PCB的另一侧"
  endc
  if $LAY.cameras!=3 && $LAY.headcameras==0 disable(hchgs)
  hxcoo=control TEXT
    window=hmain
    position=420,52+dy,80,21
    help="选定焊盘的X坐标"
    mode=M_BORDER|M_RIGHT
    font=MEDIUMFONT
  endc
  hycoo=control TEXT
    window=hmain
    position=420,76+dy,80,21
    help="选定焊盘的Y坐标"
    mode=M_BORDER|M_RIGHT
    font=MEDIUMFONT
  endc
  hupup=control BUTTON
    window=hmain
    position=433,152,34,34
    name="上"
    help="按住可向上移动相机"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hleft=control BUTTON
    window=hmain
    position=399,186,34,34
    name="左"
    help="按住不放，将相机向上移动"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hrigh=control BUTTON
    window=hmain
    position=467,186,34,34
    name="右"
    help="按住不放，将相机向右移动"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hdown=control BUTTON
    window=hmain
    position=433,220,34,34
    name="下"
    help="按住可向下移动相机"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hstep=control TEXT
    window=hmain
    position=433,265,47,21
    help="定位过程中使用的步长，毫米"
    mode=M_BORDER|M_RIGHT
  endc
  hstes=control VSCROLL
    window=hmain
    position=480,265,20,21
    help="在定位过程中设置步骤"
    limits=1,-1                        
  endc
  hbrit=control HSCROLL
    window=hmain
    name="亮度"
    help="调整图像的亮度"
    position=30,300,120,21
    limits=-100,100
  endc
  hcont=control HSCROLL
    window=hmain
    name="对比度"
    help="调整图像的对比度"
    position=30,328,120,21
    limits=-100,100
  endc
  if ($LAY.config & LC_TYPEMASK)==LC_S3 then
    hiexp=NULL
    hmirr=control CHECKBOX
      window=hmain
      position=164,302,42,18
      name="镜像"
      help="镜像来自底部相机的图像"
      mode=M_RIGHT
      color=BROWN
      mode=(mirror?M_CHECKED:0)
    endc
    draw window=hmain color=BROWN at 164,346 text="Focus:" show
    hfocusup=control BUTTON
      window=hmain
      position=213,328,21,21
      name="-"
      help="按住可向上移动相机"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hfocus=control TEXT
      window=hmain
      position=233,328,61,21
      help="当前相机的Z坐标，微米"
      font=MEDIUMFONT
      mode=M_CENTERED|M_BORDER
      color=BLACK
      bkcolor=WHITE
    endc
    focus[0]=-1000; getini("Video","Camera focus[0]","%i",focus+0)
    updatefocus[0]=1
    focus[1]=-1000; getini("Video","Camera focus[1]","%i",focus+1)
    updatefocus[1]=1
    change hfocus text=format("%i",focus[side])
    hfocusdn=control BUTTON
      window=hmain
      position=293,328,21,21
      name="+"
      help="按住可向下移动相机"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hzoom=control TEXT
      window=hmain
      position=261,300,33,21
      help="视频图像放大"
      mode=M_BORDER|M_RIGHT
      font=MEDIUMFONT
    endc
    hzoos=control VSCROLL
      window=hmain
      position=294,300,20,21
      help="设置图像放大率"
      limits=-1,1
    endc
    hitop=control CHECKBOX
      window=hmain
      position=324,302,52,18
      name="顶"
      help="激活顶部照明"
      color=BROWN
      mode=(lights & 0x04?M_CHECKED:0)
    endc
    hiske=control CHECKBOX
      window=hmain
      position=324,330,52,18
      name="偏离"
      help="激活侧部照明"
      color=BROWN
      mode=(lights & 0x08?M_CHECKED:0)
    endc
  else if headcams==0 then
    hitop=NULL
    hiske=NULL
    hiexp=NULL
    hmirr=control CHECKBOX
      window=hmain
      position=164,302,65,18
      name="镜像"
      help="镜像来自底部相机的图像"
      mode=M_RIGHT
      color=BROWN
      mode=(mirror?M_CHECKED:0)
    endc
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
    hzoom=control TEXT
      window=hmain
      position=282,300,33,21
      help="视频图像放大"
      mode=M_BORDER|M_RIGHT
      font=MEDIUMFONT
    endc
    hzoos=control VSCROLL
      window=hmain
      position=315,300,20,21
      help="设置图像放大率"
      limits=-1,1
    endc
  else
    hitop=control CHECKBOX
      window=hmain
      position=164,299,65,18
      name="顶"
      help="激活顶部照明"
      color=BROWN
      mode=(lights & 0x04?M_CHECKED:0)
    endc
    hiske=control CHECKBOX
      window=hmain
      position=164,317,65,18
      name="偏离"
      help="激活侧部照明"
      color=BROWN
      mode=(lights & 0x08?M_CHECKED:0)
    endc
    hiexp=control CHECKBOX
      window=hmain
      position=164,335,65,18
      name="高清"
      help="允许扩展说明('对比')"
      color=BROWN
      mode=(extexp & 0x1?M_CHECKED:0)
    endc
    hmirr=control CHECKBOX
      window=hmain
      position=240,322,95,23
      name="自动镜像"
      help="镜像来自底部相机的图像"
      mode=M_RIGHT
      color=BROWN
      mode=(mirror?M_CHECKED:0)
    endc
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
    hzoom=control TEXT
      window=hmain
      position=282,300,33,21
      help="视频图像放大"
      mode=M_BORDER|M_RIGHT
      font=MEDIUMFONT
    endc
    hzoos=control VSCROLL
      window=hmain
      position=315,300,20,21
      help="设置图像放大率"
      limits=-1,1
    endc
  endif
  if ($LAY.config & LC_TYPEMASK)==LC_S3 then
    hroug=control BUTTON
      window=hmain
      position=380,300,120,21
      name="快速查找"
      help="按下可选择整个工作区的点"
    endc
    hdone=control BUTTON
      window=hmain
      position=380,328,55,21
      name="完成"
      help="确认所选坐标并关闭查找焊盘窗口"
    endc
    hquit=control BUTTON
      window=hmain
      position=445,328,55,21
      name="取消"
      help="放弃所有更改并关闭查找焊盘窗口"
    endc
  else
    hroug=control BUTTON
      window=hmain
      position=360,300,140,21
      name="快速查找"
      help="按下可选择整个工作区的点"
    endc
    hdone=control BUTTON
      window=hmain
      position=360,328,65,21
      name="完成"
      help="确认所选坐标并关闭查找焊盘窗口"
    endc
    hquit=control BUTTON
      window=hmain
      position=435,328,65,21
      name="取消"
      help="放弃所有更改并关闭查找焊盘窗口"
    endc
  endif
  pad=0; videoon=0; chgvideo=1;
  redraw=1; update=1; move=1; roughmode=0
  dx=0; dy=0; scale=0.0; angle=0.0; channel=0
  $A[0].length=5
  $A[1].length=5
  while 1 do
    if (Pressed(hpad1) && pad!=0) then
      pad=0; update=1; redraw=1; move=1
      if pad1[0]!=pad2[0] chgvideo=1
    else if (Pressed(hpad2) && pad!=1) then
      pad=1; update=1; redraw=1; move=1
      if pad1[0]!=pad2[0] chgvideo=1
    else if Pressed(h1to2) then
      pad2[1]=pad1[1]; pad2[2]=pad1[2]
      pad=1; update=1; redraw=1; move=1
      if pad1[0]!=pad2[0] chgvideo=1
    endif
    if pad==0 then
      side=pad1[0]; x=pad1[1]; y=pad1[2]
    else
      side=pad2[0]; x=pad2[1]; y=pad2[2]
    endif
    if Pressed(hchgs) then
      side=side^1
      update=1; move=1; chgvideo=1; redraw=1
    else if Pressed(hupup) then
      y=y+step*Max(Status(hupup)-3,1)
      update=1; redraw=1; move=1
    else if Pressed(hleft) then
      x=x-step*Max(Status(hleft)-3,1)
      update=1; redraw=1; move=1
    else if Pressed(hrigh) then
      x=x+step*Max(Status(hrigh)-3,1)
      update=1; redraw=1; move=1
    else if Pressed(hdown) then
      y=y-step*Max(Status(hdown)-3,1)
      update=1; redraw=1; move=1
    else if Pressed(hview)==1 then
      if roughmode==0 then             // Move within the video image
        sprintf(s,"Video scale[%i]",side)
        xsc=8.0; ysc=8.0               // Default video magnification
        getini("System",s,"%f,%f",&xsc,&ysc)
        if Status(hmirr)==0 && side==1 then
          x=x-(Limit0(hview)-GDX/2)/512.0/zoom*xsc
        else
          x=x+(Limit0(hview)-GDX/2)/512.0/zoom*xsc
        endif
        y=y-(Limit1(hview)-GDY/2)/512.0/zoom*ysc
      else if scale!=0.0 then          // Move thru entire working area
        x=(Limit0(hview)-dx)/scale/1000.0
        y=(dy-Limit1(hview))/scale/1000.0
      endif
      update=1; redraw=1; move=1
    else if Pressed(hbrit) then
      chgvideo=1
    else if Pressed(hcont) then
      chgvideo=1
    else if Pressed(hitop) then
      if Status(hitop)==0 then
        lights=lights & (~0x04)
      else
        lights=lights | 0x04
      endif
      move=1
    else if Pressed(hiske) then
      if Status(hiske)==0 then
        lights=lights & (~0x08)
      else
        lights=lights | 0x08
      endif
      move=1
    else if Pressed(hiexp) then
      if Status(hiexp)==0 then
        extexp=extexp & (~0x1)
      else
        extexp=extexp | 0x1
      endif
      move=1
    else if Pressed(hmirr) then
      chgvideo=1
    else if Pressed(hzoos) then
      izoom=Min(videox>=2000?6:(videox>=1000?3:2),Max(izoom+Status(hzoos),0))
      if izoom==0 then
        zoom=2.0
      else
        zoom=1.0/izoom
      endif
      change hzoos select=0
      chgvideo=1
    else if Pressed(hstes) then
      if Status(hstes)>0 then step=Min(1.000,step*10.0);
      else if Status(hstes)<0 then step=Max(0.001,step*0.1);
      endif;
      update=1
      change hstes select=0
    else if Pressed(hroug) then
      if $LAY.nfing==0 then            // Undefined layout, don't move
        roughmode=0
      else
        roughmode=(roughmode==0)
        chgvideo=1; redraw=1
      endif
      if roughmode==0 then
        change hroug text="快速查找"
        change hroug help="按下以选择工作区域中的点"
      else
        change hroug text="Viewer"
        change hroug help="按下可以选择查看区域内的点"
      endif
    else if Pressed(hquit) then
      if headcams!=0 SERV.Cmdimm(2,"OUTPORT32 ALL 0x80000002,0")
      setini("Debug","FIND","%.1f,%.3f,%i,%i,%i",                              \
        zoom,step,Status(hmirr),lights,extexp)
      destroy hmain
      return 0
    else if Pressed(hdone) then
      if headcams!=0 SERV.Cmdimm(2,"OUTPORT32 ALL 0x80000002,0")
      setini("Debug","FIND","%.1f,%.3f,%i,%i,%i",                              \
        zoom,step,Status(hmirr),lights,extexp)
      destroy hmain
      return 1
    endif
    if hfocus!=NULL then
      i=Min(Pressed(hfocusdn),3)
      i=i-Min(Pressed(hfocusup),3)
      if i!=0 then
        focus[side]=Max(-8000,Min(focus[side]+i*20,8000))
        sprintf(s,"Camera focus[%i]",side)
        setini("Video",s,"%i",focus[side])
        change hfocus text=format("%i",focus[side])
        updatefocus[side]=1
      endif
    endif
    if update!=0 then
      if checkxy!=0 then
        outx=0.0
        outy=0.0
      else if ($LAY.config & LC_TYPEMASK)==LC_S3 then
        outx=60.0
        outy=3.0
      else
        outx=5.0
        outy=3.0
      endif
      if headcams==0 then
        x=Max(($LAY.leftlimit+$LAY.videodeadx)/1000.0-outx,x)
        x=Min(($LAY.rightlimit-$LAY.videodeadx)/1000.0+outx,x)
        y=Max($LAY.bottom[$LAY.nfing]/1000.0-outy,y)
        y=Min(($LAY.top[$LAY.nfing]-1)/1000.0+outy,y)
      else
        x=Max($LAY.leftlimit/1000.0-outx,Min($LAY.rightlimit/1000.0+outx,x))
        y=Max(miny-outy,Min(maxy+outy,y))
      endif
      if pad==0 then
        pad1[0]=side; pad1[1]=x; pad1[2]=y
      else
        pad2[0]=side; pad2[1]=x; pad2[2]=y
      endif
      if pad==0 then
        change hpad1 color=YELLOW
        change hpad1 bkcolor=LIGHTRED
        change hpad2 color=BLACK
        change hpad2 bkcolor=GRAY
        side=pad1[0]; x=pad1[1]; y=pad1[2]
      else
        change hpad2 color=YELLOW
        change hpad2 bkcolor=LIGHTRED
        change hpad1 color=BLACK
        change hpad1 bkcolor=GRAY
        side=pad2[0]; x=pad2[1]; y=pad2[2]
      endif
      if ($LAY.config & 0x80)!=0 then  // M2 tester
        change hside text=(side==0?"Chip":"I/O")
      else                             // All other testers
        change hside text=(side==0?"顶":"底")
      endif
      change hfocus text=format("%i",focus[side])
      change hxcoo text=format("%8.3f ",x)
      change hycoo text=format("%8.3f ",y)
      change hstep text=format("%.3f ",step)
      update=0
    endif
    if hfocus!=NULL then
      for i=0,i<2,i++ do
        if ($LAY.cameras & (1<<i))==0 continue
        if updatefocus[i]==0 continue
        sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+i,focus[i])
        SERV.Cmdimm(2,s)
        updatefocus[i]=0
      enddo
    endif
    if move!=0 && $A[side].length!=0 then
      if headcams==0 then              // Move dedicated camera
        angle=0.0
        channel=side
        s[0]=S_MOVE;
        s[1]=(checkxy?0x81:0xC1);      // Simple movement
        s[2]=$LAY.nfing*2+side;        // Head number
        $uint2(s+3)=10000;             // Height, insignificant for camera
        s[5]=0;                        // Bending, insignificant for camera
        $int3(s+6)=x*1000.0;           // X coordiname, micrometers
        $int3(s+9)=y*1000.0;           // Y coordiname, micrometers
        $uint2(s+12)=0;                // Radius, must be zero for camera
        s[14]=10;                      // Accuracy, micrometers
        s[15]=0;                       // Stroke, insignificant for camera
        s[16]=0;                       // Pressure, insignificant for camera
        s[17]=0;                       // M_NOP
        SYS.Sendimm(side,18,s)
        if ($LAY.config & LC_TYPEMASK)==LC_S3 then
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",                        \
            $LAY.nfing*2+side,lights|3)
          SERV.Cmdimm(2,s)
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",                         \
            $LAY.nfing*2+1-side)
          SERV.Cmdimm(2,s)
        endif
      else                             // Select and move head camera
        j=0
        for i=0,i<$LAY.nfing*2,i++ do
          if (headcams & (1<<i))==0 continue
          j++
          if $LAY.side[i/2]!=side continue
          if $LAY.bottom[i/2]/1000.0>y continue
          if $LAY.top[i/2]/1000.0<=y continue
          break                        // Head with camera found
        enddo
        if i<$LAY.nfing*2 then
          channel=j-1
          delta=y-$LAY.yoffset[i/2]/1000.0
          if Abs(delta)>headcamradius*0.9 then
            angle=0.0
          else
            angle=Asin(delta/headcamradius)
            if (i & 1)!=0 angle=-angle
            if side!=0 angle=-angle
          endif
          for j=0,j<$LAY.nfing*2,j++ do
            if j==i then
              sprintf(s,"M @%i[%g,%g] NOP",j,x,y)
              SERV.Cmdimm(side,s)
              sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",j,lights|3)
              SERV.Cmdimm(2,s)
            else
              sprintf(s,"M %i(Z) NOP",j)
              SERV.Cmdimm(2,s)
              sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",j)
              SERV.Cmdimm(2,s)
            endif
          enddo
          chgvideo=1
        endif
      endif
      move=0
    endif
    if chgvideo!=0 && roughmode==0 then
      clear hview                      // Draw video image
      draw window=hview color=LIGHTRED
      draw at GDX/2-100,GDY/2 to GDX/2-5,GDY/2
      draw at GDX/2,GDY/2-100 to GDX/2,GDY/2-5
      draw at GDX/2+6,GDY/2 to GDX/2+101,GDY/2
      draw at GDX/2,GDY/2+6 to GDX/2,GDY/2+101
      xsc=8.0; ysc=8.0                 // Default video magnification
      sprintf(s,"Video scale[%i]",side)
      getini("System",s,"%f,%f",&xsc,&ysc)
      x=0.5*512.0/xsc*zoom; y=0.5*512.0/ysc*zoom;
      draw at GDX/2-x,GDY/2-y
      draw to GDX/2+x,GDY/2-y
      draw to GDX/2+x,GDY/2+y
      draw to GDX/2-x,GDY/2+y
      draw to GDX/2-x,GDY/2-y
      draw font=SMALLFONT mode=M_CENTERED
      draw at GDX/2+1,GDY/2-y text="1x1 mm"
      draw show
      change hzoom text=format("%.1f ",zoom)
      side=(pad==0?pad1[0]:pad2[0])
      mirror=(side==0?0:(Status(hmirr)==0?0:1))
      if headcams==0 then
        SYS.Video(hview,side,mirror,zoom,Status(hbrit),Status(hcont))
      else
        SYS.Videoangle(hview,channel,mirror,zoom,                              \
        Status(hbrit),Status(hcont),2|(extexp & 1?4:0),angle)
      endif
      videoon=1; chgvideo=0
    else if redraw!=0 && roughmode!=0 then
      ymin=999999999;                  // Draw shematics of working area
      ymax=-999999999
      for j=0,j<=$LAY.nfing,j++
        if j==$LAY.nfing && $LAY.cameras==0 break
        ymin=Min(ymin,$LAY.bottom[j])
        ymax=Max(ymax,$LAY.top[j])
      enddo
      scale=Min((GDX-2.0*BORD-1)/($LAY.rightlimit-$LAY.leftlimit),             \
        (GDY-2.0*BORD)/(ymax-ymin))
      dx=(GDX-scale*($LAY.rightlimit+$LAY.leftlimit))/2
      dy=(GDY+scale*(ymax+ymin))/2
      draw window=hview color=PINK bkcolor=PINK
      draw at 0,0 fillrect GDX,GDY
      draw font=INFOFONT mode=M_CENTERED
      if $LAY.cameras!=0 then          // Draw area occupied by camera
        draw color=WHITE bkcolor=WHITEBLUE
        draw at dx+($LAY.leftlimit+$LAY.videodeadx)*scale,                     \
          dy-$LAY.top[$LAY.nfing]*scale;
        draw fillrect dx+($LAY.rightlimit-$LAY.videodeadx)*scale+1,            \
          dy-$LAY.bottom[$LAY.nfing]*scale+1;
        ;
      endif
      draw color=LIGHTBLUE
      for j=0,j<$LAY.nfing,j++         // Draw areas occupied by rails
        if $LAY.side[j]!=side continue
        draw at dx+$LAY.leftlimit*scale,dy-$LAY.top[j]*scale
        draw rect dx+$LAY.rightlimit*scale+1,dy-$LAY.bottom[j]*scale+1
        draw at dx+$LAY.xoffset*scale,dy-$LAY.bottom[j]*scale
        draw text=format("Rail %i",j)
      enddo
      i=dx+x*scale*1000.0; j=dy-y*scale*1000.0
      draw color=LIGHTRED
      draw at i-5,j to i+6,j
      draw at i,j-5 to i,j+6
      draw show
      if videoon!=0 SYS.Video(NULL,0,0,1.0,0,0);
      videoon=0; redraw=0
    endif
    wait
  enddo
end

#define NMOVCMD        18
function int Move()
  char cmdlist[NMOVCMD,10] = {         /* Commands and their codes           */\
    "00显示1",   "01显示2",   "15相机", "02测量R",                          \
    "03精密R",  "05高压",  "10快速C",   "16MSD",                            \
    "06LA测试",  "11测量RL",  "04复测R", "07外部0",                        \
    "08外部1", "09测量C",   "12延时10",   "13延时50",                          \
    "14延时250", "17自定义" }
  int i,j,k,q,wy,h,h1,a,a1,v,p,sel,checkxy
  int count,initcount,request,clipcopy,head[2],delta,lighton
  float x,x1,y,y1,r,r1,scale,z,outx,outy
  float pad1[8],pad2[8]
  char s[1024],cmd[1024]
  handle hmain,hmeas[2],hcopy,hswap,hclb1,hclb2
  handle hscal,hsscr,hchck,hextn,hfin1,hfin2
  handle hvelo,hvscr,hpres,hpscr,hzcoo,hzscr
  handle hsen1,hsen2,hsenb,hcoun,hcscr,hquit
  handle dummy
  stoprequest=0
  hmain=control WINDOW                 // Main window
    window=NULL
    position=10,10,515,350
    name="移动命令"
    help=" "
    size=1000
    bkcolor=LIGHTGRAY
  endc
  draw window=hmain font=LARGEFONT color=DARKGRAY
  draw at 4,70 text="1"
  draw at 4,135 text="2"
  draw font=MEDIUMFONT
  draw at 31,20 text="测试头"
  draw at 92,20 text="X坐标"
  draw at 182,20 text="Y坐标"
  draw at 268,20 text="半径"
  draw at 345,20 text="加速"
  draw at 425,20 text="测量"
  draw font=MAINFONT color=BLACK
  draw at 25,170 text="自定义"
  draw at 25,200 text="击测"
  draw at 142,200 text="P"
  draw at 215,200 text="H"
  draw at 305,200 text="步距"
  draw at 295,340 text="重复"
  draw show
  dummy=control FRAME
    window=hmain
    position=25,20,480,56
    bkcolor=GRAY
  endc
  dummy=control FRAME
    window=hmain
    position=25,85,480,56
    bkcolor=GRAY
  endc
  do i=0,3,1
    wy=i*25+(i>1)*15+25
    hhead[i]=control EDIT
      window=hmain
      position=30,wy,25,21
      help="此处指定测试头"
      bkcolor=WHITE
    endc
    hhscr[i]=control VSCROLL
      window=hmain
      position=55,wy,20,21
      help="按下更改测试头"
      limits=1,-1
      mode=M_NOTAB
    endc
    hxcoo[i]=control EDIT
      window=hmain
      position=80,wy,65,21
      help="此处指定X坐标,以毫米为单位"
      bkcolor=WHITE
    endc
    hxscr[i]=control VSCROLL
      window=hmain
      position=145,wy,20,21
      help="按下可调整X坐标"
      limits=1,-1
      mode=M_NOTAB
    endc
    hycoo[i]=control EDIT
      window=hmain
      position=170,wy,65,21
      help="此处指定Y坐标,以毫米为单位"
      bkcolor=WHITE
    endc
    hyscr[i]=control VSCROLL
      window=hmain
      position=235,wy,20,21
      help="按下可调整Y坐标"
      limits=1,-1
      mode=M_NOTAB
    endc
    hradi[i]=control EDIT
      window=hmain
      position=260,wy,50,21
      help="此处指定半径,以毫米为单位"
      bkcolor=WHITE
    endc
    hrscr[i]=control VSCROLL
      window=hmain
      position=310,wy,20,21
      help="按调整半径"
      limits=1,-1
      mode=M_NOTAB
    endc
    haccu[i]=control EDIT
      window=hmain
      position=335,wy,30,21
      help="此处指定精度(以微米为单位)"
      bkcolor=WHITE
    endc
    hascr[i]=control VSCROLL
      window=hmain
      position=365,wy,20,21
      help="按下可调整精度"
      limits=1,-1
      mode=M_NOTAB
    endc
  enddo
  do i=0,1,1
    hmeas[i]=control COMBOLIST
      window=hmain
      position=393,24+i*65,82,400
      help="此处选择测量类型"
      mode=M_VSCROLL
      font=FIXEDSYS
    endc
    for j=0,j<NMOVCMD,j++ do
      if ($LAY.cameras!=0 || $LAY.headcameras==0) &&                           \
        Strcmp(cmdlist[j]+2,"HEADCAM")==0 continue
      add hmeas[i] text=cmdlist[j]+2
    enddo
    change hmeas[i] select=2
  enddo
  hclb1=control BUTTON
    window=hmain
    position=480,25,20,21
    name="?"
    help="将第一个命令转换为文本并放在剪贴板上"
  endc
  hcopy=control BUTTON
    window=hmain
    position=393,50,51,21
    name="复制"
    help="将所有坐标复制到第二个框架"
  endc
  hfin1=control BUTTON
    window=hmain
    position=449,50,51,21
    name="查找"
    help="使用摄像机查找第一对焊盘的坐标"
  endc
  hclb2=control BUTTON
    window=hmain
    position=480,90,20,21
    name="?"
    help="将第二个命令转换为文本并放在剪贴板上"
  endc
  hswap=control BUTTON
    window=hmain
    position=393,115,51,21
    name="交换"
    help="交换第二对中第一个和第二个测试头的坐标"
  endc
  hfin2=control BUTTON
    window=hmain
    position=449,115,51,21
    name="查找"
    help="使用摄像机查找第二对焊盘的坐标"
  endc
  hextn=control COMBOEDIT
    window=hmain
    position=81,150,424,120
    name="外部指令"
    help="为外部或自定义命令指定文本，%1和%2是测试头"
    mode=M_VSCROLL
  endc
  hvelo=control EDIT
    window=hmain
    position=81,180,35,23
    help="指定Z向下行程，毫米每秒"
    bkcolor=WHITE
  endc
  hvscr=control VSCROLL
    window=hmain
    position=116,180,20,23
    help="按下可更改行程"
    limits=1,-1
    mode=M_NOTAB
  endc
  hpres=control EDIT
    window=hmain
    position=154,180,35,23
    help="指定Z压力，克"
    bkcolor=WHITE
  endc
  hpscr=control VSCROLL
    window=hmain
    position=189,180,20,23
    help="按下可更改压力"
    limits=1,-1
    mode=M_NOTAB
  endc
  hzcoo=control EDIT
    window=hmain
    position=228,180,40,23
    help="指定Z向上距离,毫米"
    bkcolor=WHITE
  endc
  hzscr=control VSCROLL
    window=hmain
    position=268,180,20,23
    help="按可更改Z向上距离"
    limits=1,-1
    mode=M_NOTAB
  endc
  hscal=control EDIT
    window=hmain
    position=343,180,53,23
    name="1.000"
    help="指定按下滚动键时坐标会改变多少"
    bkcolor=WHITE
  endc
  hsscr=control VSCROLL
    window=hmain
    position=396,180,20,23
    help="更改坐标步长"
    limits=1,-1
    mode=M_NOTAB
  endc
  hchck=control CUSTOMBOX
    window=hmain
    position=425,181,85,21
    name="检查XY"
    help="发送时是否要限制轨道坐标"
    mode=M_CHECKED
  endc
  checkxy=1
  hansw=control LIST
    window=hmain
    position=25,210,480,101
    bkcolor=WHITE
    size=2048
    help="在这里您可以看到最近几次测量的结果"
    font=FIXEDFONT
    color=RED
    mode=M_VSCROLL|M_NOTAB
  endc
  hsen1=control BUTTON
    window=hmain
    position=25,320,80,23
    name="发送1"
    help="发送带有第一对坐标的第一条命令"
  endc
  hsen2=control BUTTON
    window=hmain
    position=115,320,80,23
    name="发送2"
    help="发送带有第二对坐标的第二条命令"
  endc
  hsenb=control BUTTON
    window=hmain
    position=205,320,80,23
    name="发送1-2"
    help="发送第一个命令,然后发送第二次'Rep'次,或停止测试"
  endc
  hcoun=control EDIT
    window=hmain
    position=325,320,50,23
    name="1"
    help="指定重复'发送 1-2'命令的次数"
    bkcolor=WHITE
  endc
  hcscr=control VSCROLL
    window=hmain
    position=375,320,20,23
    help="按下可更改重复计数"
    limits=1,-1
    mode=M_NOTAB
  endc
  hquit=control BUTTON
    window=hmain
    position=425,320,80,23
    name="退出"
    help="关闭移动窗口"
  endc
  if hquit==NULL then                  // Out of resources, no way to continue
    destroy hmain
    lprintf(LIGHTRED,"MOVE: Out of window handles")
    return
  endif
  for i=0,i<4,i++
    h=i & 1
    x=(h==0?$LAY.leftlimit:$LAY.rightlimit)/1000.0
    y=($LAY.bottom[h/2]+$LAY.top[h/2])/2000.0
    r=0.0
    a=100
    sprintf(s,"MOVE data[%i]",i)
    getini("Debug",s,"%i,%f,%f,%f,%i",&h,&x,&y,&r,&a)
    Setline(i,h,x,y,r,a)
  enddo
  i=2; j=2; initcount=1;
  v=$GLOBAL.defstroke; p=$GLOBAL.defpressure; z=$GLOBAL.defheight/1000.0;
  getini("Debug","MOVE general","%i,%i,%i,%i,%f,%i",&i,&j,&v,&p,&z,&initcount)
  change hmeas[0] select=i
  change hmeas[1] select=j
  change hvelo text=format("%i",v)
  change hpres text=format("%i",p)
  change hzcoo text=format("%.1f",z)
  initcount=Max(1,Min(10000,initcount))
  change hcoun text=format("%i",initcount)
  repeat=0; layoutchanged=1
  if $LAY.nfing<=0 then
    SYS.Compile("loader.scr",1)
    SYS.Start("loader",8,"CHECKONLY")
  endif
  answermode=AWM_MOVE
  while 1 do
    if layoutchanged!=0 then
      if $LAY.cameras==0 && $LAY.headcameras==0 then
        disable hfin1; disable hfin2
      else
        enable hfin1; enable hfin2
      endif
      layoutchanged=0
    endif
    request=0; clipcopy=0
    Text(hscal,s); scale=1.000; sscanf(s,"%f",&scale)
    if checkxy then
      outx=0.0
      outy=0.0
    else if h>=$LAY.nfing*2 && ($LAY.config & LC_TYPEMASK)==LC_S3 then
      outx=60.0
      outy=3.0
    else
      outx=5.0
      outy=3.0
    endif
    for i=0,i<4,i++
      if Pressed(hhscr[i]) || Pressed(hhead[i]) then
        delta=Status(hhscr[i])
        Text(hhead[i],s); h=0; sscanf(s,"%i",&h)
        h=h+delta
        j=$LAY.nfing*2-1; if $LAY.cameras!=0 j=j+2
        h=Max(0,Min(j,h))
        change hhead[i] text=format("%i",h)
        change hhscr[i] select=0
        if delta==0 then setfocus hxcoo[i];
        else setfocus hmain; endif
      else if Pressed(hxscr[i]) || Pressed(hxcoo[i]) then
        delta=Status(hxscr[i])
        Text(hxcoo[i],s); x=0.0; sscanf(s,"%f",&x)
        x=x+delta*scale
        if x<$LAY.leftlimit/1000.0-outx then
          x=$LAY.leftlimit/1000.0-outx
        else if x>$LAY.rightlimit/1000.0+outx then
          x=$LAY.rightlimit/1000.0+outx
        endif
        change hxcoo[i] text=format("%.3f",x)
        change hxscr[i] select=0
        if delta==0 then setfocus hycoo[i];
        else setfocus hmain; endif
      else if Pressed(hyscr[i]) || Pressed(hycoo[i]) then
        delta=Status(hyscr[i])
        Text(hhead[i],s); h=0; sscanf(s,"%i",&h)
        Text(hycoo[i],s); y=0.0; sscanf(s,"%f",&y)
        y=y+delta*scale
        if (y>=$LAY.top[h/2]/1000.0+outy) y=($LAY.top[h/2]-1)/1000.0+outy
        if (y<$LAY.bottom[h/2]/1000.0-outy) y=$LAY.bottom[h/2]/1000.0-outy
        change hycoo[i] text=format("%.3f",y)
        change hyscr[i] select=0
        if delta==0 then setfocus hradi[i];
        else setfocus hmain; endif
      else if Pressed(hrscr[i]) || Pressed(hradi[i]) then
        delta=Status(hrscr[i])
        Text(hradi[i],s); r=0.0; sscanf(s,"%f",&r)
        r=r+delta*scale
        if r<0.0 then r=0.0
        else if r>64.0 then r=64.0
        endif
        change hradi[i] text=format("%.3f",r)
        change hrscr[i] select=0
        if delta==0 then setfocus haccu[i];
        else setfocus hmain; endif
      else if Pressed(hascr[i]) || Pressed(haccu[i]) then
        delta=Status(hascr[i])
        Text(haccu[i],s); a=100; sscanf(s,"%i",&a)
        a=a+delta*10
        if a<0 then a=0
        else if a>255 then a=255
        endif
        change haccu[i] text=format("%i",a)
        change hascr[i] select=0
        if delta==0 then setfocus hhead[(i+1)%4];
        else setfocus hmain; endif
      endif
    enddo
    if Pressed(hclb1) then
      clipcopy=1
    else if Pressed(hclb2) then
      clipcopy=2
    else if Pressed(hcopy) then
      Getline(0,&h,&x,&y,&r,&a,checkxy)
      Setline(0,h,x,y,r,a)
      Setline(2,h,x,y,r,a)
      Getline(1,&h,&x,&y,&r,&a,checkxy)
      Setline(1,h,x,y,r,a)
      Setline(3,h,x,y,r,a)
    else if Pressed(hfin1) && $LAY.nfing>0 then
      Getline(0,&h,&x,&y,&r,&a,j)
      pad1[0]=$LAY.side[h/2]; pad1[1]=x; pad1[2]=y; pad1[3]=0
      Getline(1,&h1,&x1,&y1,&r1,&a1,j)
      pad2[0]=$LAY.side[h1/2]; pad2[1]=x1; pad2[2]=y1; pad2[3]=0
      disable hmain
      j=Position(pad1,pad2,1,checkxy)
      enable hmain
      if j==1 then
        x=pad1[1]; y=pad1[2];
        for j=$LAY.nfing-1,j>0,j--     // Correct the first rail
          if ($LAY.side[j]!=pad1[0]) continue
          if (y>=$LAY.bottom[j]/1000.0 && y<$LAY.top[j]/1000.0) break
        enddo
        h=(h & 1)+j*2
        x1=pad2[1]; y1=pad2[2];
        for j=$LAY.nfing-1,j>0,j--     // Correct the second rail
          if ($LAY.side[j]!=pad2[0]) continue
          if (y1>=$LAY.bottom[j]/1000.0 && y1<$LAY.top[j]/1000.0) break
        enddo
        h1=(h1 & 1)+j*2
        if (h & 0x1E)==(h1 & 0x1E) then
          if x<x1 then
            h=h & 0x1E; h1=h1 | 0x01
          else if x>x1 then
            h1=h1 & 0x1E; h=h | 0x01
          endif
        endif
      endif
      Setline(0,h,x,y,r,a)
      Setline(1,h1,x1,y1,r1,a1)
    else if Pressed(hswap) then
      Getline(2,&h,&x,&y,&r,&a,checkxy)
      Getline(3,&h1,&x1,&y1,&r1,&a1,checkxy)
      Setline(3,h,x,y,r,a)
      Setline(2,h1,x1,y1,r1,a1)
    else if Pressed(hfin2) && $LAY.nfing>0 then
      Getline(2,&h,&x,&y,&r,&a,j)
      pad1[0]=$LAY.side[h/2]; pad1[1]=x; pad1[2]=y; pad1[3]=0
      Getline(3,&h1,&x1,&y1,&r1,&a1,j)
      pad2[0]=$LAY.side[h1/2]; pad2[1]=x1; pad2[2]=y1; pad2[3]=0
      disable hmain
      j=Position(pad1,pad2,1,checkxy)
      enable hmain
      if j==1 then
        x=pad1[1]; y=pad1[2];
        for j=$LAY.nfing-1,j>0,j--     // Correct the third rail
          if ($LAY.side[j]!=pad1[0]) continue
          if (y>=$LAY.bottom[j]/1000.0 && y<$LAY.top[j]/1000.0) break
        enddo
        h=(h & 1)+j*2
        x1=pad2[1]; y1=pad2[2];
        for j=$LAY.nfing-1,j>0,j--     // Correct the fourth rail
          if ($LAY.side[j]!=pad2[0]) continue
          if (y1>=$LAY.bottom[j]/1000.0 && y1<$LAY.top[j]/1000.0) break
        enddo
        h1=(h1 & 1)+j*2
        if (h & 0x1E)==(h1 & 0x1E) then
          if x<x1 then
            h=h & 0x1E; h1=h1 | 0x01
          else if x>x1 then
            h1=h1 & 0x1E; h=h | 0x01
          endif
        endif
      endif
      Setline(2,h,x,y,r,a)
      Setline(3,h1,x1,y1,r1,a1)
    else if Pressed(hscal) || Pressed(hsscr) then
      Text(hscal,s); scale=1.000; sscanf(s,"%f",&scale)
      if Status(hsscr)>0 then
        if scale<0.00999 then scale=0.01;
        else if scale<0.0999 then scale=0.1;
        else if scale<0.999 then scale=1.0;
        else scale=10.0;
        endif
      else if Status(hsscr)<0 then
        if scale>10.01 then scale=10.0;
        else if scale>1.001 then scale=1.0;
        else if scale>0.1001 then scale=0.1;
        else scale=0.01;
        endif
      endif
      change hscal text=format("%.3f",scale)
      change hsscr select=0
      setfocus hmain
    else if Pressed(hcoun) || Pressed(hcscr) then
      Text(hcoun,s); count=1; sscanf(s,"%i",&count)
      if Status(hcscr)!=0 then
        if count<20 then count=count+Status(hcscr);
        else if count<200 then count=count+10*Status(hcscr);
        else if count<2000 then count=count+100*Status(hcscr);
        else count=count+1000*Status(hcscr);
        endif
        count=Max(1,Min(10000,count))
      endif
      initcount=count;
      change hcoun text=format("%i",count)
      change hcscr select=0
      if (repeat & 2)==0 setfocus hmain
      repeat=0
    else if Pressed(hvelo) || Pressed(hvscr) then
      delta=Status(hvscr)
      Text(hvelo,s); v=40; sscanf(s,"%i",&v)
      v=v+delta*VSTEP
      v=Max(MINV,Min(MAXV,v))
      change hvelo text=format("%i",v)
      change hvscr select=0
      if delta==0 then setfocus hpres;
      else setfocus hmain; endif
    else if Pressed(hpres) || Pressed(hpscr) then
      delta=Status(hpscr)
      Text(hpres,s); p=30; sscanf(s,"%i",&p)
      p=p+delta*PSTEP
      p=Max(MINP,Min(MAXP,p))
      change hpres text=format("%i",p)
      change hpscr select=0
      if delta==0 then setfocus hzcoo;
      else setfocus hmain; endif
    else if Pressed(hzcoo) || Pressed(hzscr) then
      delta=Status(hzscr)
      Text(hzcoo,s); z=10.0; sscanf(s,"%f",&z)
      z=z+delta*(z<3.0?0.5:(z<10.0?1.0:2.0))
      z=Max(0.5,Min(99.9,z))
      change hzcoo text=format("%.1f",z)
      change hzscr select=0
      if delta==0 then setfocus hvelo;
      else setfocus hmain; endif
    else if Pressed(hchck) then
      checkxy=Status(hchck)
    else if Pressed(hsen1) then
      request=1
    else if Pressed(hsen2) then
      request=2
    else if Pressed(hsenb) then
      if (repeat & 2)==0 then
        Text(hcoun,s); initcount=1; sscanf(s,"%i",&initcount)
        initcount=Max(1,Min(10000,initcount))
      endif
      change hcoun text=format("%i",initcount)
      repeat=(repeat & 2) ^ 2
      request=3
    else if hardreset!=0 || stoprequest!=0 then
      change hcoun text=format("%i",initcount)
      repeat=0; request=0; hardreset=0; stoprequest=0
    else if Pressed(hquit) then
      for i=0,i<4,i++
        Getline(i,&h,&x,&y,&r,&a,0)
        sprintf(s,"MOVE data[%i]",i)
        setini("Debug",s,"%i,%.3f,%.3f,%.3f,%i",h,x,y,r,a)
      enddo
      Text(hvelo,s); v=40; sscanf(s,"%i",&v)
      Text(hpres,s); p=30; sscanf(s,"%i",&p)
      Text(hzcoo,s); z=10.0; sscanf(s,"%f",&z)
      initcount=Max(1,Min(10000,initcount))
      setini("Debug","MOVE general","%i,%i,%i,%i,%.3f,%i",                     \
        Status(hmeas[0]),Status(hmeas[1]),v,p,z,initcount)
      break
    else if repeat==3 then
      request=3
    endif
    if request!=0 then                 // Some 'Send' key is pressed
      Text(hvelo,s); v=40; sscanf(s,"%i",&v)
      v=Max(MINV,Min(MAXV,v))
      change hvelo text=format("%i",v)
      Text(hpres,s); p=30; sscanf(s,"%i",&p)
      p=Max(MINP,Min(MAXP,p))
      change hpres text=format("%i",p)
      Text(hzcoo,s); z=10.0; sscanf(s,"%f",&z)
      z=Max(0.5,Min(99.9,z))
      change hzcoo text=format("%.1f",z)
      Text(hcoun,s); count=1; sscanf(s,"%i",&count)
      count=Max(1,Min(10000,count))
      for i=0,i<2,i++                  // Send 1 or 2 MOVE commands
        if (request & (0x01<<i))==0 continue
        s[0]='\0'; Text(hmeas[i],s);
        for k=0,k<NMOVCMD,k++ do
          if Strcmp(cmdlist[k]+2,s)==0 break
        enddo
        if k>=NMOVCMD break
        lighton=-1
        sel=(cmdlist[k,0]-'0')*10+cmdlist[k,1]-'0'
        // Processing of custom command.
        if sel==17 then
          j=sprintf(s,"M ")
          for k=0,k<2,k++
            Getline(i*2+k,&h,&x,&y,&r,&a,checkxy)
            Setline(i*2+k,h,x,y,r,a)
            head[k]=h
            j=j+sprintf(s+j,"%i%c%g,%g",h,(checkxy?'(':'['),x,y)
            if (r!=0.0) j=j+sprintf(s+j,",%g",r)
            if (a!=255) j=j+sprintf(s+j,"A%i",a)
            j=j+sprintf(s+j,"V%iP%iH%g",v,p,z)
            j=j+sprintf(s+j,"%c ",(checkxy?')':']'))
          enddo
          confirm hextn
          Text(hextn,cmd)
          for k=0,cmd[k]!='\0',k++ do
            if cmd[k]=='%' && cmd[k+1]=='1' then
              j=j+sprintf(s+j,"%i",head[0]); k++
            else if cmd[k]=='%' && cmd[k+1]=='2' then
              j=j+sprintf(s+j,"%i",head[1]); k++
            else
              s[j]=cmd[k]; j++
            endif
          enddo
          s[j]='\0'
          j=SERV.Parsecmd(s,cmd)
          if j<0 then
            add hansw text=format("Error in CUSTOM: %-200s",s)
          else
            SYS.Send(j,cmd,((i==1 && request==3 && count>1)?1:0))
          endif
          continue
        endif
        // Processing of all remaining commands (non-CUSTOM).
        s[0]=S_MOVE; j=1
        for k=0,k<2,k++
          if k==1 && (sel==0 || sel==15) continue
          if sel==15 then
            s[j]=0xCA;                 // Headcam movement
          else if checkxy==0 then
            s[j]=0xC9;                 // Don't check X-Y
          else
            s[j]=0x89;                 // Check X-Y
          endif
          j++
          Getline(i*2+k,&h,&x,&y,&r,&a,checkxy)
          Setline(i*2+k,h,x,y,r,a)
          head[k]=h
          s[j]=h; j++                  // Head number
          $uint2(s+j)=z*1000.0; j=j+2  // Height, micrometers
          s[j]=0; j++                  // Bending
          $int3(s+j)=x*1000.0; j=j+3   // X coordiname, micrometers
          $int3(s+j)=y*1000.0; j=j+3   // Y coordiname, micrometers
          $uint2(s+j)=r*1000.0; j=j+2  // Radius, micrometers
          s[j]=a; j++                  // Accuracy, micrometers
          s[j]=v; j++                  // Stroke, mm/s
          s[j]=p; j++                  // Pressure, gramm
          $uint2(s+j)=0; j=j+2         // X correction
          $uint2(s+j)=0; j=j+2         // Y correction
        enddo
        k=sel
        switch k
        case 0,1:                      // SHOW1,SHOW2
          s[j]=0; j++
        case 2,3,5,6,9,11:             // R,EXACTR,HV,LATEST,C,RL
          if k==2 then s[j]=0x02;
          else if k==3 then s[j]=0x18;
          else if k==5 then s[j]=0x0E;
          else if k==6 then s[j]=0x16;
          else if k==9 then s[j]=0x1B;
          else s[j]=0x2A;
          endif
          j++;
          s[j]=head[0]; j++
          s[j]=1; j++;
          s[j]=head[1]; j++
        case 4:                        // RRETEST
          s[j]=0x26; j++
          s[j]=head[0]; j++
          s[j]=head[1]; j++
          $float4(s+j)=10.0e12; j=j+4  // Threshold 10 M (in microohms)
          $int2(s+j)=0; j=j+2          // Reserved parameters
          $int2(s+j)=0; j=j+2
        case 7,8:                      // EXTERN0,EXTERN1
          k=k-7
          s[j]=0x19; j++
          s[j]=head[0]; j++
          s[j]=1; j++;
          s[j]=head[1]; j++
          q=$GLOBAL.extmode[k]
          s[j]=((q|0x40) & 0xFC)+k; j++;
          s[j]=$GLOBAL.extbaud[k]; j++;
          s[j]=$GLOBAL.extwait[k]; j++;
          if (q & 0x04)==0 then        // RS232 mode
            s[j]=$GLOBAL.extecho[k];
            s[j+1]=$GLOBAL.extanswer[k];
            s[j+2]=$GLOBAL.extprompt[k];
            s[j+3]=$GLOBAL.exterr1[k];
            s[j+4]=$GLOBAL.exterr2[k];
            s[j+5]=$GLOBAL.exterr3[k];
            s[j+6]=0; s[j+7]=0;
          else                         // IEEE mode
            s[j]=$GLOBAL.extconverter[k];
            s[j+1]=$GLOBAL.extprimary[k];
            s[j+2]=$GLOBAL.extsecondary[k];
            s[j+3]=$GLOBAL.extanswer[k];
            s[j+4]=0; s[j+5]=0;
            s[j+6]=0; s[j+7]=0;
          endif
          j=j+8
          confirm hextn
          Text(hextn,cmd)
          q=Strlen(cmd)
          if $uint1($GLOBAL+508+k) & 0x01 then
            // $GLOBAL.extopt: add CR/LF.
            q=q+Strcpy(cmd+q,"\r\n")
          endif
          if q>=255 continue           // Command is too long
          $uint2(s+j)=q+1; j=j+2;
          Strcpy(s+j,cmd); j=j+q
          s[j]=$GLOBAL.extanswer[k]; j++
        case 10:                       // FASTC
          s[j]=0x25; j++;
          s[j]=head[0]; j++;
          s[j]=0; j++;
          s[j]=1; j++;
          s[j]=head[1]; j++;
        case 12,13,14:                 // Delays by measurement card (A5 only)
          s[j]=M_DEBUG; j++;
          s[j]=0x3A; j++;
          s[j]=2; j++;
          if (k==12) then $uint2(s+j)=10;
          else if (k==13) then $uint2(s+j)=50;
          else $uint2(s+j)=250; endif
          j=j+2
        case 15:                       // HEADCAM
          lighton=h
          s[j]=0; j++
        case 16:                       // MSD
          s[j]=0x2E; j++;
          s[j]=head[0]; j++;
          s[j]=0; j++;
          s[j]=1; j++;
          s[j]=head[1]; j++;
        default:
          continue
        endsw
        SYS.Send(j,s,((i==1 && request==3 && count>1)?1:0))
        if lighton>=0 then             // Turn on camera illumination
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,1",lighton)
          SERV.Cmdimm(2,s)
        endif
      enddo
      if (request==3 && count>1) then
        if (repeat & 2)!=0 count--
        repeat=repeat & 2
        change hcoun text=format("%i",count)
      else
        repeat=0
        change hcoun text=format("%i",initcount)
      endif
    endif
    if clipcopy!=0 then                // Some copy button is pressed
      i=clipcopy-1
      s[0]='\0'; Text(hmeas[i],s);
      for k=0,k<NMOVCMD,k++ do
        if Strcmp(cmdlist[k]+2,s)==0 break
      enddo
      if k>=NMOVCMD break
      sel=(cmdlist[k,0]-'0')*10+cmdlist[k,1]-'0'
      j=sprintf(s,"M ")
      for k=0,k<2,k++
        if k==1 && (sel==0 || sel==15) break
        Getline(i*2+k,&h,&x,&y,&r,&a,checkxy)
        Setline(i*2+k,h,x,y,r,a)
        head[k]=h
        if sel==15 then
          j=j+sprintf(s+j,"@%i[%g,%g",h,x,y)
        else
          j=j+sprintf(s+j,"%i%c%g,%g",h,(checkxy?'(':'['),x,y)
        endif
        if (r!=0.0) j=j+sprintf(s+j,",%g",r)
        if (a!=255) j=j+sprintf(s+j,"A%i",a)
        j=j+sprintf(s+j,"V%iP%iH%g",v,p,z)
        j=j+sprintf(s+j,"%c ",(checkxy!=0 && sel!=15?')':']'))
      enddo
      k=sel
      switch k
      case 0,1,15:                     // SHOW1,SHOW2,HEADCAM
        j=j+sprintf(s+j,"NOP")
      case 2,3,5,6,9,11:               // R,EXACTR,HV,LATEST,C,RL
        if k==2 then s[j]='R';
        else if k==3 then s[j]='E';
        else if k==5 then s[j]='H';
        else if k==6 then s[j]='L';
        else if k==9 then s[j]='C';
        else s[j]='R'; j++; s[j]='L'; endif
        j++;
        j=j+sprintf(s+j,"(%i,%i)",head[0],head[1])
      case 4:                          // RRETEST
        j=j+sprintf(s+j,"RT(%i,%i,R1000)",head[0],head[1])
      case 10:                         // FASTC
        j=j+sprintf(s+j,"A(%i,0,%i)",head[0],head[1])
      case 16:                         // MSD
        j=j+sprintf(s+j,"CRT(%i,%i)",head[0],head[1])
      case 12:                         // DELAY10
        j=j+sprintf(s+j,"DLY(10)")
      case 13:                         // DELAY50
        j=j+sprintf(s+j,"DLY(100)")
      case 14:                         // DELAY250
        j=j+sprintf(s+j,"DLY(1000)")
      case 17:                         // CUSTOM
        confirm hextn
        Text(hextn,cmd)
        for k=0,cmd[k]!='\0',k++ do
          if cmd[k]=='%' && cmd[k+1]=='1' then
            j=j+sprintf(s+j,"%i",head[0]); k++
          else if cmd[k]=='%' && cmd[k+1]=='2' then
            j=j+sprintf(s+j,"%i",head[1]); k++
          else
            s[j]=cmd[k]; j++
          endif
        enddo
        s[j]='\0'
      endsw
      Clipcopy(s)
      clipcopy=0
    endif
    wait
  enddo
  destroy hmain
end

#define NCRA 61
#define NFIN 37
#define NDEC 10
#define HSTX 256
#define HSTY 256
function int Portio()
// Meaning of first 5 bytes: SPPMC, where S - type of port, PP - port number,
// M: 8-signed, 4-word, 2-autoout.
  char cratname[NCRA,24] = {                                                   \
    "00008P1-A (ready)",     "00108P1-B (mode)",       "00208P1-C (LEDs)",     \
    "00308P1-CW",            "00408P2-A (ant)",        "00508P2-B (mux)",      \
    "00608P2-C (range)",     "00708P2-CW",             "00C00ADC low",         \
    "00D00ADC high",         "00E00LATCH",             "00F00CONV",            \
    "0F041Hardware",         "0F802A2 hardware",       "20C09LATEST control",  \
    "20D00LATEST BCD 5/6",   "20E00LATEST BCD 3/4",    "20F00LATEST BCD 1/2",  \
    "20100Illumination",     "21040T?measured",       "21140T?effective",    \
    "10007V25 port 0",       "10808V25 port 1",        "11008V25 port 2",      \
    "13808V25 port T",       "2F020Parameter 0",       "2F120Parameter 1",     \
    "2F220Parameter 2",      "2F320Parameter 3",       "2F420Parameter 4",     \
    "2F520Parameter 5",      "2F620Parameter 6",       "2F720Parameter 7",     \
    "0C300Mux control",      "0C000Mux Status/+Sine",  "0C100Mux -Sine",       \
    "2D000Commutator 0L",    "2D100Commutator 0R",     "2D200Commutator 1L",   \
    "2D300Commutator 1R",    "2D400Commutator 2L",     "2D500Commutator 2R",   \
    "2D600Commutator 3L",    "2D700Commutator 3R",     "2D800Commutator 4L",   \
    "2D900Commutator 4R",    "2DA00Commutator 5L",     "2DB00Commutator 5R",   \
    "2DC00Commutator 6L",    "2DD00Commutator 6R",     "2DE00Commutator 7L",   \
    "2DF00Commutator 7R",    "0E228ExtIO SPS LO",      "0E328ExtIO SPS HI",    \
    "0E400ExtIO Ser 0",      "0E500ExtIO Ser 1",       "0E600ExtIO Ser 2",     \
    "0E700ExtIO Ser 3",      "0E908ExtIO Version",     "0EC08ExtIO LA stat",   \
    "0ED08ExtIO LA D1/0" };
  char fingname[NFIN,24] = {                                                   \
    "88040ADC Z left",       "88140ADC Z right",       "88200ADC Vz/Pz left",  \
    "88300ADC Vz/Pz right",  "80000Lin1 left",         "80100Lin2 left",       \
    "80200Rot1 left",        "80300Rot2 left",         "80400Lin1 right",      \
    "80500Lin2 right",       "80600Rot1 right",        "80700Rot2 right",      \
    "80820Magnet left",      "80920Magnet right",      "89004V25 port 0",      \
    "89108V25 port 1",       "89205V25 port 2",        "89306V25 port T",      \
    "89420Reduce X force",   "8C040Enc lin left",      "8C240Enc rot left",    \
    "8C440Enc lin right",    "8C640Enc rot right",     "8C840Encoder ADC",     \
    "8CA23Status/MUX",       "8E060Left C-adjust",     "8E460Left S-adjust",   \
    "8E260Right C-adjust",   "8E660Right S-adjust",    "8F020Parameter 0",     \
    "8F120Parameter 1",      "8F220Parameter 2",       "8F320Parameter 3",     \
    "8F420Parameter 4",      "8F520Parameter 5",       "8F620Parameter 6",     \
    "8F720Parameter 7"  };
  char bitname[NDEC,70] = {                                                    \
    "",                                                                        \
    "0FLockL,1FUnlL,2FLockR,3FUnlR,4FDclo,5FDopen,6F24V,7FVacuum",             \
    "00Lddn,10Ldup,20Ldout,30Ldin,40Sdoff,50Sdon,6FIRsens,7NBtns",             \
    "00LinL,10RotL,20LinR,30RotR",                                             \
    "00MovL,10DnL,20MovR,30DnR,50Blnk,60Err",                                  \
    "0FSwL,1FSwR,2UU/I,4FR-B1,5FR-B2,6FL-B1,7FL-B2",                           \
    "70XL,60XR,50FiL,40FiR,00Mode",                                            \
    "000,101,202,303,404,50Blnk,60Err",                                        \
    "000,101,202,303,404,505,606,707",                                         \
    "0FRun,1FOpen,2FGood,3FDefect,4KBase,5KCalibr" };
  int i,j,k,m,n,bit,type,rail,extend,mode,redraw,rescroll,rehist,resethystog
  int selcrat,selfing,port,repeat,reptime,repout,newminmax,imin,imax
  int hstmin[HSTX],hstmax[HSTX],hstsmp[HSTX],hsttim[HSTX]
  int hyst08[HSTX],hyst12[HSTX],hyst16[HSTX],nhyst
  int nhst,lasthst,dt,tstart,tnext,tredraw,protmode,contig,cursor,out1,out2
  int val,valoffs,offset,useoffset
  float r
  char s[80],custom[80]
  handle hmain,hlist,huser,huaddr,hcrat,hrail,hnumb,hnscr
  handle hxtnd,hbits,hidec,hihex,himin,himax,hidif
  handle hrept,hinpt,hdat1,hdat2,hscr1,hscr2
  handle hbit[8],hout1,hout2,hquit
  handle hgraf,hinfo,hou12,hmode,hxclr,hzero    // Extended controls
  handle hdelt,hdscr,hcntg                      // Extended controls
  hmain=control WINDOW
    window=NULL
    position=10,10,298,362
    name="I/O端口"
    help=" "
    bkcolor=LIGHTYELLOW
    size=256
  endc
  hlist=control LISTBOX
    window=hmain
    position=8,9,148,192
    help="选择端口"
    mode=M_VSCROLL|M_SELECTION
  endc
  huser=control CHECKBOX
    window=hmain
    position=8,210,70,21
    text="Custom:"
    help="指定自定义端口地址"
    font=INFOFONT
  endc
  huaddr=control EDIT
    window=hmain
    position=80,210,77,21
    help="此处指定自定义端口地址"
    bkcolor=LIGHTYELLOW
  endc
  disable huaddr
  hcrat=control RADIO
    window=hmain
    position=170,6,55,22
    name="机箱"
    help="选择访问内核控制器端口"
    font=INFOFONT
  endc
  hrail=control RADIO
    window=hmain
    position=170,29,55,22
    name="轨道"
    help="选择以访问测试头控制器端口"
    font=INFOFONT
  endc
  hxtnd=control BUTTON
    window=hmain
    position=230,7,60,18
    font=INFOFONT
    bkcolor=LIGHTYELLOW
  endc
  hnumb=control TEXT
    window=hmain
    position=230,28,40,22
    name="0"
    help="当前选定的测试头控制器"
    font=MEDIUMFONT
    mode=M_CENTERED|M_BORDER
  endc
  hnscr=control VSCROLL
    window=hmain
    position=270,28,20,22
    help="选择另一个测试头部控制器"
    limits=1,-1
  endc
  hbits=control CHILD
    window=hmain
    position=168,56,121,174
    help="此处可以看到解码的输入位"
  endc
  do i=0,7,1
    hbit[i]=control TEXT
      window=hbits
      position=5,i*18+7,110,16
      font=FIXEDSYS
    endc
  enddo
  draw window=hmain font=INFOFONT
  draw at 7,260 text="In:"
  hidec=control TEXT
    window=hmain
    position=34,241,61,22
    help="十进制输入值"
    font=MEDIUMFONT
    color=LIGHTRED
    mode=M_BORDER|M_CENTERED
  endc
  draw at 104,260 text="hex"
  hihex=control TEXT
    window=hmain
    position=132,241,61,22
    help="输入十六进制数"
    font=MEDIUMFONT
    color=DARKGRAY
    mode=M_BORDER|M_CENTERED
  endc
  draw at 7,284 text="Min"
  himin=control TEXT
    window=hmain
    position=34,266,61,22
    help="自上次端口/导轨更改以来的最小输入值"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
  endc
  draw at 104,284 text="max"
  himax=control TEXT
    window=hmain
    position=132,266,61,22
    help="自上次端口/导轨更改以来的最大输入值"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
  endc
  draw at 207,284 text="diff"
  hidif=control TEXT
    window=hmain
    position=229,266,61,22
    help="最小值和最大值之间的差异"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
  endc
  hrept=control CHECKBOX
    window=hmain
    position=210,240,80,24
    name="持续输入"
    help="连续重复输入"
    font=INFOFONT
  endc
  draw at 7,317 text="Out1:"
  hdat1=control EDIT
    window=hmain
    position=45,297,75,24
    help="此处指定第一个输出值"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  hscr1=control VSCROLL
    window=hmain
    position=120,297,20,24
    help="递增或递减输出 1，然后输出"
    limits=1,-1
  endc
  draw at 157,317 text="Out2:"
  hdat2=control EDIT
    window=hmain
    position=195,297,75,24
    help="此处指定第二个输出值"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  hscr2=control VSCROLL
    window=hmain
    position=270,297,20,24
    help="递增或递减输出 2，然后输出"
    limits=1,-1
  endc
  hinpt=control BUTTON
    window=hmain
    position=7,332,64,24
    name="进"
    help="按下可从所选端口输入数据"
  endc
  hout1=control BUTTON
    window=hmain
    position=80,332,64,24
    name="出1"
    help="按下可将输出1输出到所选端口"
  endc
  hout2=control BUTTON
    window=hmain
    position=152,332,64,24
    name="出2"
    help="按下可将输出2输出到所选端口"
  endc
  hquit=control BUTTON
    window=hmain
    position=226,332,64,24
    name="关闭"
    help="关闭端口I/O窗口"
  endc
  hinfo=control TEXT
    window=hmain
    position=300,HSTY+12,HSTX+2,20
    font=INFOFONT
    help="所选样本的信息"
    mode=M_BORDER
  endc
  hmode=control COMBOLIST
    window=hmain
    position=300,297,95,140
    help="选择如何显示记录的数据"
    mode=M_SELECTION
  endc
  add hmode text="8位数据"
  add hmode text="12位数据"
  add hmode text="16位数据"
  add hmode text="8输入"
  add hmode text="8位滞后"
  add hmode text="12位滞后"
  add hmode text="16位滞后"
  change hmode select=protmode
  draw at 400,317 text="dT="
  hdelt=control TEXT
    window=hmain
    position=425,297,40,24
    mode=M_CENTERED|M_BORDER
    help="采样或输出之间的间隔(不保证),秒"
    font=MEDIUMFONT
  endc
  hdscr=control VSCROLL
    window=hmain
    position=465,297,20,24
    limits=1,-1
    help="按下可更改采样或输出间隔"
  endc
  draw at 488,317 text="s"
  contig=1
  hcntg=control CHECKBOX
    window=hmain
    position=502,297,56,24
    name="滚动"
    help="启用数据滚动"
    mode=M_CHECKED
    font=INFOFONT
  endc
  hou12=control BUTTON
    window=hmain
    position=300,332,116,24
    name="持续输出1/2"
    help="按下可重复输出1，dT暂停，输出2，dT暂停，输出1…"
  endc
  hzero=control BUTTON
    window=hmain
    position=424,332,63,24
    name="置零0"
    help="按下可将当前振幅设为零电平"
  endc
  hxclr=control BUTTON
    window=hmain
    position=495,332,63,24
    name="清除"
    help="清除历史记录"
  endc
  if hxclr==NULL then                  // Check if last created control exists
    destroy hmain                      // Out of resources, no way to continue
    lprintf(LIGHTRED,"Port I/O: Out of window handles")
    return
  endif
  draw show
  i=0; rail=0; selcrat=0; selfing=0; dt=1000;
  getini("Debug","Port I/O general","%i,%i,%i,%i,%i,%s",                       \
    &i,&rail,&selcrat,&selfing,&dt,custom)
  change huaddr text=custom
  if i==0 then
    change hcrat mode=M_CHECKED
  else
    change hrail mode=M_CHECKED
  endif
  if (rail<0) then
    change hnumb text="ALL"
  else
    change hnumb text=format("%i",rail)
  endif
  s[0]='\0'; getini("Debug","Port I/O[1]",s); change hdat1 text=s
  s[0]='\0'; getini("Debug","Port I/O[2]",s); change hdat2 text=s
  extend=-1; redraw=1; rescroll=1; rehist=1;
  repeat=0; repout=0; newminmax=3; useoffset=0; offset=0;
  mode=(Status(hcrat)==0)
  answermode=AWM_PORT
  $uint2(answ)=0; cursor=-1;
  while 1 do
    out1=0; out2=0
    j=layoutchanged
    if Pressed(hnscr) || j!=0 then
      layoutchanged=0
      i=$LAY.nfing-1;
      if $LAY.cameras!=0 i++;
      if i<=0 i=15;
      rail=Max(-1,Min(rail+Status(hnscr),i))
      if (rail<0) then
        change hnumb text="ALL"
      else
        change hnumb text=format("%i",rail)
      endif
      change hnscr select=0
      if mode!=1 && j==0 then
        change hrail mode=M_CHECKED
        mode=1; redraw=1;
      endif
      nhst=0; resethystog=1; rehist=1; repout=0
      newminmax=3
    else if Pressed(hlist) then
      rescroll=1; newminmax=3; repout=0
    else if Pressed(huser) then
      rescroll=1; newminmax=3; repout=0
      if Status(huser)==0 then
        disable huaddr
        enable hlist
        change huaddr bkcolor=LIGHTYELLOW
      else
        disable hlist
        enable huaddr
        change huaddr bkcolor=WHITE
        setfocus huaddr
      endif
    else if Pressed(hxtnd) || extend<0 then
      if extend==0 then
        change hmain position=*,*,565,*
        change hxtnd name="<<<"
        change hxtnd help="按下可禁用扩展I/O功能"
        hgraf=control GRAPH
          window=hmain
          position=301,8,HSTX,HSTY
          bkcolor=WHITE
          help="端口历史记录，单击可设置光标"
        endc
        nhst=0; resethystog=1; rehist=1
      else
        change hmain position=*,*,298,*
        change hxtnd name=">>>"
        change hxtnd help="按下可启用扩展I/O功能"
        destroy hgraf
        hgraf=NULL
      endif
      extend=(extend==0)
      repout=0
    else if Pressed(hcrat) && mode!=0 then
      mode=0; redraw=1; newminmax=3; repout=0
    else if Pressed(hrail) && mode==0 then
      mode=1; redraw=1; newminmax=3; repout=0
    else if Pressed(hscr1) then
      out1=(repout==0?1:2)
    else if Pressed(hdat1) || Pressed(hout1) then
      out1=1; repout=0
    else if Pressed(hscr2) then
      out2=(repout==0?1:2)
    else if Pressed(hdat2) || Pressed(hout2) then
      out2=1; repout=0
    else if repout==1 && Time()>=reptime then
      out1=1; repout=2
      reptime=Time()+dt
    else if repout==2 && Time()>=reptime then
      out2=1; repout=1
      reptime=Time()+dt
    else if Pressed(hinpt) || repeat!=0 then
      if mode==0 && Status(huser)==0 then
        selcrat=Status(hlist); i=cratname[selcrat,3] & 0xC
        k=cratname[selcrat,4] & 0x0F
        sscanf(cratname[selcrat],"%01X%02X",&j,&port);
        port=port+j*0x1000
      else if mode==0 && Status(huser)!=0 then
        Text(huaddr,s); port=0; sscanf(s,"%i",&port)
        k=8
      else if Status(huser)==0 then
        selfing=Status(hlist); i=fingname[selfing,3] & 0xC
        k=fingname[selfing,4] & 0x0F
        sscanf(fingname[selfing]+1,"%02X",&port);
        if (rail<0) then port=port|0x9000;
        else port=(port|0x8000)+rail*0x100; endif
      else
        Text(huaddr,s); port=0; sscanf(s,"%i",&port)
        if (rail<0) then port=port|0x9000;
        else port=(port|0x8000)+rail*0x100; endif
        k=8
      endif
      s[0]=S_INPORT;                   // S_INPORT
      $uint2(s+1)=port;                // Port number
      SYS.Send(3,s,k)                  // Send command
      repeat=0
    else if Pressed(hdscr) then
      i=Status(hdscr); j=1;
      while dt>=10 do j=j*10; dt=dt/10; enddo
      if i>0 then
        if dt<2 then dt=2;
        else if dt<5 then dt=5;
        else dt=10; endif
      else if i<0 then
        j=j/10;
        if dt>=5 then dt=20;
        else if dt>=2 then dt=10;
        else dt=5; endif
      endif
      dt=dt*j; nhst=0; rehist=1
      change hdscr select=0
    else if Pressed(hzero) then
      if useoffset==0 then
        change hzero text="No 0"
        change hzero help="按下可显示无零偏移的振幅"
        offset=hstsmp[lasthst]; useoffset=1
      else
        change hzero text="Set 0"
        change hzero help="按下可将当前振幅设为零电平"
        offset=0; useoffset=0
      endif
      rehist=1
    else if Pressed(hxclr) then
      nhst=0; resethystog=1; rehist=1
    else if Pressed(hou12) then
      if repout==0 then
        repout=1; reptime=Time()
      else
        repout=0
      endif
    else if Pressed(hmode) then
      protmode=Status(hmode)
      rehist=1
    else if Pressed(hcntg) then
      contig=Status(hcntg)
    else if Pressed(hquit) then
      i=Status(hrail);
      Text(hdat1,s); setini("Debug","Port I/O[1]",s)
      Text(hdat2,s); setini("Debug","Port I/O[2]",s)
      Text(huaddr,custom)
      setini("Debug","Port I/O general","%i,%i,%i,%i,%i,%s",                   \
        i,rail,selcrat,selfing,dt,custom)
      break
    endif
    if out1!=0 then
      if mode==0 && Status(huser)==0 then
        selcrat=Status(hlist); i=cratname[selcrat,3] & 0xC
        sscanf(cratname[selcrat],"%01X%02X",&j,&port);
        port=port+j*0x1000
      else if mode==0 && Status(huser)!=0 then
        Text(huaddr,s); port=0; sscanf(s,"%i",&port)
      else if Status(huser)==0 then
        selfing=Status(hlist); i=fingname[selfing,3] & 0xC
        sscanf(fingname[selfing]+1,"%02X",&port);
        if (rail<0) then port=port|0x9000;
        else port=(port|0x8000)+rail*0x100; endif
      else
        Text(huaddr,s); port=0; sscanf(s,"%i",&port)
        if (rail<0) then port=port|0x9000;
        else port=(port|0x8000)+rail*0x100; endif
      endif
      Text(hdat1,s); j=0; sscanf(s,"%i",&j);
      if Status(hscr1)!=0 then
        j=j+Status(hscr1)
        if i==0x0 then j=Max(0,Min(255,j));
        else if i==0x4 then j=Max(0,Min(65535,j));
        else if i==0x8 then j=Max(-128,Min(127,j));
        else j=Max(-32768,Min(32767,j)); endif
        change hscr1 select=0
      endif
      i=0; while s[i]==' ' do i++; enddo
      if s[i]=='0' && Toupper(s[i+1])=='X' then
        change hdat1 text=format("0x%X",j)
      else
        change hdat1 text=format("%i",j)
      endif
      if out1==1 then
        s[0]=S_OUTPORT;                // S_OUTPORT
        $uint2(s+1)=port;              // Port number
        $uint2(s+3)=j;                 // Data
        SYS.Send(5,s,0)                // Send command and discard answer
        reptime=Time()+dt
      endif
    endif
    if out2!=0 then
      if mode==0 && Status(huser)==0 then
        selcrat=Status(hlist); i=cratname[selcrat,3] & 0xC
        sscanf(cratname[selcrat],"%01X%02X",&j,&port);
        port=port+j*0x1000
      else if mode==0 && Status(huser)!=0 then
        Text(huaddr,s); port=0; sscanf(s,"%i",&port)
      else if Status(huser)==0 then
        selfing=Status(hlist); i=fingname[selfing,3] & 0xC
        sscanf(fingname[selfing]+1,"%02X",&port);
        if (rail<0) then port=port|0x9000;
        else port=(port|0x8000)+rail*0x100; endif
      else
        Text(huaddr,s); port=0; sscanf(s,"%i",&port)
        if (rail<0) then port=port|0x9000;
        else port=(port|0x8000)+rail*0x100; endif
      endif
      Text(hdat2,s); j=0; sscanf(s,"%i",&j);
      if Status(hscr2)!=0 then
        j=j+Status(hscr2)
        if i==0x0 then j=Max(0,Min(255,j));
        else if i==0x4 then j=Max(0,Min(65535,j));
        else if i==0x8 then j=Max(-128,Min(127,j));
        else j=Max(-32768,Min(32767,j)); endif
        change hscr2 select=0
      endif
      i=0; while s[i]==' ' do i++; enddo
      if s[i]=='0' && Toupper(s[i+1])=='X' then
        change hdat2 text=format("0x%X",j)
      else
        change hdat2 text=format("%i",j)
      endif
      if out2==1 then
        s[0]=S_OUTPORT;                // S_OUTPORT
        $uint2(s+1)=port;              // Port number
        $uint2(s+3)=j;                 // Data
        SYS.Send(5,s,0)                // Send command
        reptime=Time()+dt
      endif
    endif
    if redraw!=0 then
      clear hlist
      if Status(hcrat)!=0 then         // Fill list with crate controller ports
        change hnumb color=DARKGRAY
        for i=0,i<NCRA,i++
          add hlist text=cratname[i]+5
        enddo
        change hlist select=selcrat
      else                             // Fill list with head controller ports
        change hnumb color=BLACK
        for i=0,i<NFIN,i++
          add hlist text=fingname[i]+5
        enddo
        change hlist select=selfing
      endif
      redraw=0; rescroll=1;
    endif
    if rescroll!=0 then                // Enable/disable data scrolls
      if Status(huser)!=0 then
        i=0x2
      else if mode==0 then
        selcrat=Status(hlist); i=cratname[selcrat,3]
      else
        selfing=Status(hlist); i=fingname[selfing,3]
      endif
      if (i & 0x2)!=0 then
        enable hscr1; enable hscr2
      else
        disable hscr1; disable hscr2
      endif
      rescroll=0; nhst=0; resethystog=1; rehist=1
    endif
    if extend!=0 && (Pressed(hgraf) || Status(hgraf)==1) then
      cursor=Max(-1,Min(HSTX-1,Limit0(hgraf)))
      rehist=1
    endif
    if extend!=0 && (rehist!=0 || Time()>=tredraw) then
      dt=Max(50,Min(100000,dt))
      change hdelt text=format("%g",dt/1000.0)
      draw window=hgraf color=WHITE bkcolor=WHITE font=SMALLFONT
      draw at 0,0 fillrect HSTX,HSTY
      j=lasthst-nhst; if j<0 j=j+HSTX
      if cursor>=0 then
        draw color=GRAY
        draw at cursor,0 to cursor,HSTY+1
      endif
      if useoffset!=0 then
        draw color=DARKGRAY
        draw at 5,HSTY-5 text=format("Offset %i bits",offset)
      endif
      if cursor>=0 then
        if protmode==6 then
          change hinfo text=format("I=[%i..%i] (%04X)  N=%i (%.1f%%)",         \
          cursor*256,cursor*256+255,cursor*256,hyst16[cursor],                 \
          (nhyst==0?0.0:hyst16[cursor]*100.0/nhyst))
        else if protmode==5 then
          change hinfo text=format("I=[%i..%i] (%04X)  N=%i (%.1f%%)",         \
          cursor*16,cursor*16+15,cursor*16,hyst12[cursor],                     \
          (nhyst==0?0.0:hyst12[cursor]*100.0/nhyst))
        else if protmode==4 then
          change hinfo text=format("I=%i (0x%2X) N=%i (%.1f%%)",               \
          cursor,cursor,hyst08[cursor],                                        \
          (nhyst==0?0.0:hyst08[cursor]*100.0/nhyst))
        else if protmode==3 && cursor<=nhst then
          change hinfo text=format("T=%.1fs sample=0x%X",                      \
          (hsttim[(cursor+j)%HSTX]-tstart)/1000.0,hstsmp[(cursor+j)%HSTX])
        else if protmode<3 && cursor<=nhst then
          change hinfo text=format("T=%.1fs min=%i,max=%i (%X)",               \
          (hsttim[(cursor+j)%HSTX]-tstart)/1000.0,                             \
          hstmin[(cursor+j)%HSTX],hstmax[(cursor+j)%HSTX],                     \
          hstmax[(cursor+j)%HSTX])
        else
          clear hinfo
        endif
      else
        clear hinfo
      endif
      draw color=LIGHTBLUE
      if protmode==0 then              // Display 8-bit "analog" min/max
        r=HSTY/256.0
        valoffs=(useoffset==0?0:offset-128)
        for i=1,i<nhst,i++
          val=hstmin[(i+j)%HSTX]-valoffs
          if i==1 then draw at i,HSTY-1-(val & 0xFF)*r;
          else draw to i,HSTY-1-(val & 0xFF)*r; endif
        enddo
        draw color=LIGHTRED
        for i=1,i<nhst,i++
          val=hstmax[(i+j)%HSTX]-valoffs
          if i==1 then draw at i,HSTY-1-(val & 0xFF)*r;
          else draw to i,HSTY-1-(val & 0xFF)*r; endif
        enddo
      else if protmode==1 then         // Display 12-bit "analog" min/max
        r=HSTY/4096.0
        valoffs=(useoffset==0?0:offset-2048)
        for i=1,i<nhst,i++
          val=hstmin[(i+j)%HSTX]-valoffs
          if i==1 then draw at i,HSTY-1-(val & 0xFFF)*r;
          else draw to i,HSTY-1-(val & 0xFFF)*r; endif
        enddo
        draw color=LIGHTRED
        for i=1,i<nhst,i++
          val=hstmax[(i+j)%HSTX]-valoffs
          if i==1 then draw at i,HSTY-1-(val & 0xFFF)*r;
          else draw to i,HSTY-1-(val & 0xFFF)*r; endif
        enddo
      else if protmode==2 then         // Display 16-bit "analog" min/max
        r=HSTY/65536.0
        valoffs=(useoffset==0?0:offset-32768)
        for i=1,i<nhst,i++
          val=hstmin[(i+j)%HSTX]-valoffs
          if i==1 then draw at i,HSTY-1-(val & 0xFFFF)*r;
          else draw to i,HSTY-1-(val & 0xFFFF)*r; endif
        enddo
        draw color=LIGHTRED
        for i=1,i<nhst,i++
          val=hstmax[(i+j)%HSTX]-valoffs
          if i==1 then draw at i,HSTY-1-(val & 0xFFFF)*r;
          else draw to i,HSTY-1-(val & 0xFFFF)*r; endif
        enddo
      else if protmode==3 then         // Display digital sample
        for k=0,k<8,k++
          m=0x01<<k; n=HSTY-HSTY/16+5-HSTY/8*k
          draw color=LIGHTGRAY
          draw at 0,n to HSTX,n
          draw at 0,n-10 to HSTX,n-10
          draw color=LIGHTRED
          for i=1,i<nhst,i++
            if i==1 then draw at i,n-((hstsmp[(i+j)%HSTX] & m)==0?0:10);
            else draw to i,n-((hstsmp[(i+j)%HSTX] & m)==0?0:10); endif
          enddo
          draw color=BLACK font=SMALLFONT
          draw at 3,n+2 text=format("%i",k)
        enddo
      else if protmode==4 then         // Display 8-bit hystogramm
        draw color=LIGHTRED
        j=0
        for i=0,i<HSTX,i++
          j=Max(j,hyst08[i])
        enddo
        j=j+32
        for i=0,i<HSTX,i++
          if hyst08[i]>0 then
            draw at i,HSTY-hyst08[i]*HSTY/j
            draw to i,HSTY
          endif
        enddo
      else if protmode==5 then         // Display 12-bit hystogramm
        draw color=LIGHTRED
        j=0
        for i=0,i<HSTX,i++
          j=Max(j,hyst12[i])
        enddo
        j=j+32
        for i=0,i<HSTX,i++
          if hyst12[i]>0 then
            draw at i,HSTY-hyst12[i]*HSTY/j
            draw to i,HSTY
          endif
        enddo
      else if protmode==6 then         // Display 16-bit hystogramm
        draw color=LIGHTRED
        j=0
        for i=0,i<HSTX,i++
          j=Max(j,hyst16[i])
        enddo
        j=j+32
        for i=0,i<HSTX,i++
          if hyst16[i]>0 then
            draw at i,HSTY-hyst16[i]*HSTY/j
            draw to i,HSTY
          endif
        enddo
      endif
      draw show
      rehist=0; tredraw=Time()+500     // Redraw each 0.5 seconds
    endif
    if (newminmax & 2)!=0 then
      clear himin
      clear himax
      clear hidif
    endif
    if extend!=0 && resethystog!=0 then
      for j=0,j<HSTX,j++               // Re-initialize hysteresis variables
        hyst08[j]=0; hyst12[j]=0; hyst16[j]=0;
      enddo
      nhyst=0; resethystog=0
    endif
    if $uint2(answ)!=0 && answ[4]==S_INPORT then
      i=$uint2(answ+5); k=answinfo; $uint2(answ)=0
      if newminmax!=0 then
        imin=i; imax=i; newminmax=0
      else
        imin=Min(imin,i); imax=Max(imax,i)
      endif
      change hidec text=format("%i",i)
      change hihex text=format("%X",i)
      change himin text=format("%i",imin)
      change himax text=format("%i",imax)
      change hidif text=format("%i",imax-imin)
      m=0; if (k<0 || k>=NDEC) k=0
      for j=0,j<8,j++
        if bitname[k,m]==0 then
          clear hbit[j]
        else
          bit=(bitname[k,m]>='A'?bitname[k,m]-'A'+10:bitname[k,m]-'0'); m++
          type=bitname[k,m]; m++
          for n=0,n<32,n++
            if (bitname[k,m]==',' || bitname[k,m]=='\0') break
            s[n]=bitname[k,m]; m++
          enddo
          while n<10 do s[n]=' '; n++; enddo
          if (bitname[k,m]==',') m++
          bit=(0x1<<bit) & i
          if type=='0' sprintf(s+n,"%s",bit==0?"0":"1")
          if type=='F' sprintf(s+n,"%s",bit==0?"On":"Off")
          if type=='N' sprintf(s+n,"%s",bit==0?"Off":"On")
          if type=='U' sprintf(s+n,"%s",bit==0?"I":"U")
          if type=='K' sprintf(s+n,"%s",bit==0?"Ok":"Bad")
          change hbit[j] text=s
        endif
      enddo
      if extend!=0 then
        hyst08[i & 0xFF]++
        hyst12[(i/16) & 0xFF]++
        hyst16[(i/256) & 0xFF]++
        nhyst++
      endif
      if extend!=0 && (contig==1 || nhst<HSTX) then
        if nhst==0 then                // Re-initialize history variables
          lasthst=0; tstart=Time(); tnext=tstart; tredraw=tstart
        endif
        if Time()>=tnext then          // Create new history point
          nhst=Min(HSTX,nhst+1)
          lasthst=(lasthst+1)%HSTX
          hstmin[lasthst]=i
          hstmax[lasthst]=i
          hstsmp[lasthst]=i
          hsttim[lasthst]=Time()
          tnext=tnext+dt
        else                           // Update current history point
          hstmin[lasthst]=Min(hstmin[lasthst],i)
          hstmax[lasthst]=Max(hstmax[lasthst],i)
        endif
      endif
      if Status(hrept)!=0 repeat=1
    endif
    wait
  enddo
end

#define SHORTLINE      76              // Length of line in data
#define LONGLINE       256             // Length of line in list

// List of crate controller ports.
char cratelist[43][SHORTLINE] = {                                              \
  "000000F0 硬件|0!LockL,1!UnlL,2!LockR,3!UnlR,4!Dclo,5!Dopen,6!24V,7!Vac",\
  "000000F8 架板框|0?Lddn,1?Ldup,2?Ldout,3?Ldin,4?Sdoff,5?Sdon,6?IR,7?Btn",   \
  "00002002 三色灯|+0x1: RED\n0x2: YELLOW\n0x4: GREEN",                \
  "00002004 顶部灯|+0: light OFF\n1: light ON for 15 s\n3: permanent ON",   \
  "00002005 底部灯|+0: light OFF\n1: light ON for 15 s\n3: permanent ON",\
  "00002006 好/坏 舱|+0x1: open GOOD\n0x2: open BAD",                  \
  "00002010 测量温度|+In 1/10th of degree Centigrade",                      \
  "00002011 有效温度|+In 1/10th of degree Centigrade",                     \
  "00002013 湿度|+In 1/10th of percent",                                   \
  "000020F0 参数0|+Field voltage in 0.5-V steps",                        \
  "000020F1 参数1",                                                      \
  "000020F2 参数2",                                                      \
  "000020F3 参数3",                                                      \
  "000020F4 参数4",                                                      \
  "000020F5 参数5",                                                      \
  "000020F6 参数6",                                                      \
  "000020F7 参数7|+Loop time",                                           \
  "10000001 RT计时器",                                                         \
  "10000002 火线计时器",                                                   \
  "10000010 版本",                                                          \
  "10000020 特别0|+1: Parallel HV\n2: Parallel RL\n4: Parallel MSD\n",     \
  "*        8: Same net for ExactR\n16: Ignore GROUPs\n32: Ignore Pnl/Grp/Net",\
  "*        \n64: No C/CRT cmp&up\n128: Instant LA retest",                    \
  "10000021 特别1|+1: No hard reset\n2: Disable 300 mA\n4: Disable slave", \
  "*        \n8: Don't check shuttle Y",                                       \
  "10000022 特别2|+1: Dump Avg/Median\n2: Dump retests\n4: Dump CContact", \
  "10000024 真空|+0: native\n1: emulate ON\n2: emulate OFF",             \
  "10000025 门感应器|+0: native\n1: emulate OPEN",                         \
  "10000028 立即复位|+Total number of instant retests so far",          \
  "10000029 四线重接触|+Made when pin-to-pin resistance is too high",   \
  "10010001 软着陆|+Don't change when heads are moving or down!",        \
  "1001000F 仿真|+1: Lost SHARC\n2: Bus reset\n3: Bad cmd size\n\nCARE!",\
  "10020001 元件延时|+Delay between contact\nand measurement, ms\n",    \
  "*        Only ExactR, I-U, L, LA",                                          \
  "1002001F 测量特性|0Air cal,1CRT,2Kelvin scan,3Force CDC,4C phase cal,",\
  "*        5Slave,6C phase,7MultiC",                                          \
  "12000006 模拟打印机|+0x0002:half\n0x0003:full auto\n",                 \
  "*        0x0100:split shuttle L\n0x0200:split shuttle R\n\n",               \
  "*        0x0010:Linx\n0x0030:CAB\n0x0040:Valentin APL",                     \
  "10000330 左架板框|F",                                                  \
  "10000331 右架板框|F",                                                  \
  "30000003 HS演示模式",                                                     \
  "" }
// List of head controller ports.
char headlist[53][SHORTLINE] = {                                               \
  "10000106 Z坐标|+Top 1000..11000 bits\nBottom >50000",                \
  "10000107 Z压力|+No contact: >40000 bits",                              \
  "00000008 Z马达|+Full range, bits:\n20 (top) ..150 (bot)\nPLEASE CARE!",\
  "10010008 Z马达, um|+Full range, um:\n5k (top) .. 30k (bot)\nCARE!",    \
  "10010007 Z端口速度|+For Z DC motor,\nmillimeters per second",            \
  "000000C0 X计数器|+1 count = 5 or 10 um",                                  \
  "10000100 X相位A",                                                        \
  "10000101 X相位B",                                                        \
  "10000102 X零脉冲",                                                     \
  "000000C2 Y计数器|+1 count = 65 um (A5), 50 um (A6)",                      \
  "10000103 Y相位A",                                                        \
  "10000104 Y相位B",                                                        \
  "10000105 Y零脉冲",                                                     \
  "1000010A Z计数器|+S1: 1 count = 250 um\nA7: 1 count = 50 um",             \
  "10000108 Z相位A",                                                        \
  "10000109 Z相位B",                                                        \
  "1000010E Z零脉冲|+A7 only",                                            \
  "1000010B 原X温度|+S1/A7",                                                \
  "1000010C 原Y温度|+S1 only",                                              \
  "1000010D 原Z温度|+A7 only",                                              \
  "1001010B X温度|+S1/A7, C*10",                                      \
  "1001010C Y温度|+S1 only, C*10",                                    \
  "1001010D Z温度|+A7 only, C*10",                                    \
  "80000003 编码器电源|+0: off, 1: on\n(Only if feedback is off;\n",        \
  "*        new S2/A7: PZYX)",                                                 \
  "000000CA 终点感应器|0?Sw.X=open:+closed,1?Sw.Y=open:+closed,",            \
  "*        2?Sw.Z=open:+closed",                                              \
  "10000110 断线",                                                       \
  "10000111 标志位|0?X phase A,1?X phase B,2?Y phase A,3?Y phase B",        \
  "80000002 相机灯|+0x1: light ON\n0x2: permanent",                     \
  "*        \n0x4: top light (A7)\n0x8: skew light (A7)",                      \
  "10000300 相机序号",                                                       \
  "10000001 循环计数器",                                                      \
  "10000002 火线计数器",                                                   \
  "000000E0 C校正|+0..511 bits",                                        \
  "000000E4 Z校正|+0..508 bits\nStep 4 bits",                           \
  "10010000 Z压力校正|+-10000..10000 bits",                              \
  "10010001 自动Zp校正|+On hard surface\nTcont>50 ms\nCopy Zp to layout",    \
  "1001000F 仿真|+2, 3: Lost phase X/Y\n4, 5: Encoder shift X/Y",        \
  "*        \n6, 7: Hi-accel X/Y\n16: Z encoder A off\n17: Z motor phase A ",  \
  "*        off\n18: Encoder shift Z\n32: Firewire break\nCARE!",              \
  "80000010 X步进马达|+Only S1/A7\n1 bit = 45/60 deg",                      \
  "80000012 Y步进马达|+Only S1/A7\n1 bit = 45 deg",                         \
  "80000014 Z步进马达|+Only S1/A7\n1 bit = 45/60 deg",                      \
  "000000F0 参数0",                                                      \
  "000000F1 参数1",                                                      \
  "000000F2 参数2",                                                      \
  "000000F3 参数3",                                                      \
  "000000F4 参数4",                                                      \
  "000000F5 参数5",                                                      \
  "000000F6 参数6",                                                      \
  "000000F7 参数7",                                                      \
  "" }
// List of camera controller ports.
char videolist[39][SHORTLINE] = {                                              \
  "000000C0 X counter|+1 count = 5 or 10 um",                                  \
  "10000100 X phase A",                                                        \
  "10000101 X phase B",                                                        \
  "10000102 X zero pulse",                                                     \
  "000000C2 Y counter|+1 count = 5 or 10 um",                                  \
  "10000103 Y phase A",                                                        \
  "10000104 Y phase B",                                                        \
  "10000105 Y zero pulse",                                                     \
  "1000010A Z counter|+1 count = 10 um",                                       \
  "10000108 Z phase A",                                                        \
  "10000109 Z phase B",                                                        \
  "1000010E Z zero pulse",                                                     \
  "10010008 Z coordinate, um|+-8000..8000 um",                                 \
  "1000010B 原X温度|+S3 only",                                              \
  "1000010C 原Y温度|+S3 only",                                              \
  "1000010D 原Z温度|+S3 only",                                              \
  "1001010B X温度|+S3 only, C*10",                                    \
  "1001010C Y温度|+S3 only, C*10",                                    \
  "1001010D Z温度|+S3 only, C*10",                                    \
  "000000CA End switches|0?Sw.X=open:+closed,1?Sw.Y=open:+closed,",            \
  "*        2?Sw.Z=open:+closed",                                              \
  "10000111 FLAG bits|0?X phase A,1?X phase B,2?Y phase A,3?Y phase B",        \
  "80000002 Camera light|+0: light OFF\n1: ON for 15 s\n3: permanent ON",      \
  "10000001 循环计数器",                                                      \
  "10000002 Firewire timer",                                                   \
  "1001000F Simulation|+2: Lost phase X\n3: Lost phase Y\n4: Encoder shift X", \
  "*        \n5: Encoder shift Y\nCARE!",                                      \
  "80000010 S3 X step-motor|+Only S3",                                         \
  "80000012 S3 Y step-motor|+Only S3",                                         \
  "80000014 S3 Z step-motor|+Only S3",                                         \
  "000000F0 参数0",                                                      \
  "000000F1 参数1",                                                      \
  "000000F2 参数2",                                                      \
  "000000F3 参数3",                                                      \
  "000000F4 参数4",                                                      \
  "000000F5 参数5",                                                      \
  "000000F6 参数6",                                                      \
  "000000F7 参数7",                                                      \
  "" }
// List of measurement card ports.
char measlist[27][SHORTLINE] = {                                               \
  "10000001 循环计数器",                                                      \
  "10000002 火线计数器",                                                   \
  "10000111 标志位",                                                        \
  "10010009 K31..K0开|+UTMOST CAUTION!\n0x00000001: K0\n",                    \
  "*        0x80000000: K31",                                                  \
  "1001000A K31..K0关|+UTMOST CAUTION!\n0x00000001: K0\n",                   \
  "*        0x80000000: K31",                                                  \
  "1001000B K63..K32开|+UTMOST CAUTION!\n0x00000001: K32\n",                  \
  "*        0x80000000: K63",                                                  \
  "1001000C K63..K32关|+UTMOST CAUTION!\n0x00000001: K32\n",                 \
  "*        0x80000000: K63",                                                  \
  "1001000D K80..K111开|+UTMOST CAUTION!\n0x1: K111\n0x100: K103\n",          \
  "*        0x10000: K95\n0x1000000: K87\n0x80000000: K80",                    \
  "1001000E K80..K111关|+UTMOST CAUTION!\n0x1: K111\n0x100: K103\n",         \
  "*        0x10000: K95\n0x1000000: K87\n0x80000000: K80",                    \
  "1001000F 仿真|+0x01: Self-test\n0x10: Simulate Kelvin\nCare!",        \
  "10001003 最新精密范围|+3: 30 mA\n4:10 mA\n5: 3mA\n6: 1mA\n7: 300uA\n", \
  "*        12: 9V\n13: 0.9V\n15: 100k",                                       \
  "000000F0 参数0",                                                      \
  "000000F1 参数1",                                                      \
  "000000F2 参数2",                                                      \
  "000000F3 参数3",                                                      \
  "000000F4 参数4",                                                      \
  "000000F5 参数5",                                                      \
  "000000F6 参数6",                                                      \
  "000000F7 参数7",                                                      \
  "" }
// List of SPS ports.
char spslist[26][SHORTLINE] = {                                                \
  "00000001 1 - 命令",                                                      \
  "00000002 2 - 回答",                                                       \
  "00000005 5 - 状态|0Stopper,1Pusher,2Missed,3ShPos,4Lift,5Cover, ",        \
  "*            15Vacuum, 16Bands,17ShOut",                                    \
  "00000006 6 - 打印类型",                                                 \
  "00000007 7 - 硬件",                                                     \
  "0000000A 10 - Arg 0",                                                       \
  "0000000B 11 - Arg 1",                                                       \
  "0000000C 12 - Arg 2",                                                       \
  "0000000D 13 - Arg 3",                                                       \
  "00000013 19 - 错误",                                                       \
  "00000014 20 - 数据0",                                                      \
  "00000015 21 - 数据1",                                                      \
  "00000016 22 - 数据2",                                                      \
  "00000017 23 - 数据3",                                                      \
  "00000018 24 - 数据4",                                                      \
  "00000019 25 - 数据5",                                                      \
  "000002BE 702 - 测试机类型|+0: Standalone\n1: Automate",                    \
  "000002BF 703 - 打印机类型|+0: None\n1: LINX\n2: Label printer",           \
  "000002C0 704 - 架板框类型|+0: Hand\n1: Automatical",                      \
  "00000102 0258 - 消息A6标准|+On-screen messages, A6 Standard\n0: off, 1: on", \
  "00000419 1049 - 消息A5|+On-screen messages, A5\n0: off, 1: on",             \
  "000004B5 1205 - 消息A6|+On-screen messages, A6 Automat\n0: off, 1: on", \
  "000004F6 1270 - 软件版本|+Version of SPS software",                       \
  "000007D1 2001 - 开始|0?SPS=running:+stopped",                              \
  "" }
// List of head camera registers.
char hcamlist[11][SHORTLINE] = {                                               \
  "F0F00800 明亮度|&FFF=Value",                                            \
  "F0F0081C 快门|&FFF=Value",                                               \
  "F0F00820 感光|&FFF=Value",                                                  \
  "F0F0051C 快门极限|&FFF000=Min,&FFF=Max",                              \
  "F0F00520 感光极限|&FFF000=Min,&FFF=Max",                                 \
  "F0F00080 白平衡|&FFF000=U/B,&FFF=V/R",                               \
  "F0F08008 Fmt7位置|&FFFF0000=X0,&FFFF=Y0",                                 \
  "F0F0800C Fmt7大小|&FFFF0000=dX,&FFFF=dY",                                \
  "F1000560 视窗大小|&FFFF=Size",                                           \
  "" }

function int Copylist(char *out,char *inp)
  int i,j,n,nout,ninp
  nout=0; ninp=0; j=0
  while 1 do
    i=nout*LONGLINE
    n=Strcpy(out+i,inp+j)
    if out[i]=='\0' break
    i=i+n
    while 1 do                         // Check for continuation lines
      ninp++; j=ninp*SHORTLINE
      if inp[j]!='*' break
      j++
      while inp[j]==' ' do j++; enddo
      i=i+Strcpy(out+i,inp+j)
    enddo
    nout++
  enddo
end

function int Portio32()
  int i,j,k,m,n,x,y,device,head,camera,headcam,item[6],port,negate,repeat
  int waitanswer,data,mindata,maxdata,devicechanged,itemchanged,force1,force2
  int nloop,extend,extchanged,extmode,extcursor,extpause,extset0,repout,reptype
  int reptime,dtindex,thistory,nhistory,thiststart,resethistory,redrawhistory
  int custdev,custchanged,custport,hyst8[HSTX],hyst12[HSTX],hyst16[HSTX]
  int nhyst,temp[HSTX],hyst8max,hyst12max,hyst16max,redrawinfo,bitdata,bitfield
  int oldcameras,oldheadcams
  float dt,yshift,offset,scale,history[HSTX][6],sy,syy
  char list[80][LONGLINE]
  char s[256],key[80],buf[80],out1[6][80],out2[6][80],errmsg[16]
  handle hmain,hlist,hcrat,hhead,hheadid,hheadscr
  handle hvideo,hvidid,hvidscr,hcam,hcamid,hcamscr,hmeas,hsps
  handle hextend,hcust,hbits,hinint,hinhex,hmin,hmax
  handle ho1data,ho1scr,ho2data,ho2scr,hin,hrepeat,hout1,hout2,hquit
  handle hright,hextgraph,hextinfo,hextmode,hextdelta,hextminmax
  handle hextdscr,hextrep,hextpulse,hextset0,hextclear,hextpause
  handle hcustwin,hcustslot,hcustname,hcustdelete,hcustport,hcustadd
  handle hcustclose
  float dtset[16] = {                \ // Intervals between samples, seconds
    0.020, 0.030, 0.050, 0.070, 0.100, 0.150, 0.200, 0.300,                    \
    0.500, 0.700, 1.000, 1.500, 2.000, 3.000, 5.000, 10.00 }
  answermode=AWM_PORT32
  hmain=control WINDOW
    window=NULL
    position=10,10,298,362
    name="32位端口I/O"
    help=" "
    bkcolor=LIGHTYELLOW
    size=256
  endc
  hlist=control LISTBOX
    window=hmain
    position=8,9,148,224
    help="选择端口"
    mode=M_VSCROLL|M_SELECTION
  endc
  hcrat=control RADIO
    window=hmain
    position=170,6,55,22
    name="内核"
    help="选择访问内核控制器"
    font=INFOFONT
  endc
  hhead=control RADIO
    window=hmain
    position=170,29,55,22
    name="手臂"
    help="选择访问测试头控制器"
    font=INFOFONT
  endc
  hheadid=control TEXT
    window=hmain
    position=230,28,40,20
    help="当前选中的测试头"
    font=MEDIUMFONT
    mode=M_CENTERED|M_BORDER
    color=GRAY
  endc
  hheadscr=control VSCROLL
    window=hmain
    position=270,28,20,20
    help="按下可选择其它或全部测试头"
    limits=1,-1
  endc
  hmeas=control RADIO
    window=hmain
    position=170,75,55,22
    name="测量"
    help="选择访问测量卡"
    font=INFOFONT
  endc
  hsps=control RADIO
    window=hmain
    position=170,98,55,22
    name="SPS"
    help="选择访问SPS寄存器"
    font=INFOFONT
  endc
  hextend=control BUTTON
    window=hmain
    position=240,81,50,16
    name=">>"
    help="按下可打开其它控制器"
    font=INFOFONT
    bkcolor=LIGHTYELLOW
  endc
  hcust=control BUTTON
    window=hmain
    position=240,100,50,16
    name="自定义"
    help="按下可维护自定义端口列表"
    bkcolor=LIGHTYELLOW
    font=SMALLFONT
  endc
  hbits=control CHILD
    window=hmain
    position=168,123,121,110
    help="此处可以看到解码的输入位"
    size=1024
  endc
  draw window=hmain font=INFOFONT
  draw at 7,265 text="In"
  hinint=control TEXT
    window=hmain
    position=32,246,112,22
    help="端口数据(十进制)"
    font=MEDIUMFONT
    color=LIGHTRED
    mode=M_BORDER
  endc
  draw at 150,265 text="Hex"
  hinhex=control TEXT
    window=hmain
    position=178,246,112,22
    help="端口数据(十六进制)"
    font=MEDIUMFONT
    color=BLACK
    mode=M_BORDER
  endc
  draw at 7,290 text="Min"
  hmin=control TEXT
    window=hmain
    position=32,271,112,22
    help="注册最小值"
    font=MEDIUMFONT
    color=DARKGRAY
    mode=M_BORDER
  endc
  draw at 150,290 text="Max"
  hmax=control TEXT
    window=hmain
    position=178,271,112,22
    help="注册最大值"
    font=MEDIUMFONT
    color=DARKGRAY
    mode=M_BORDER
  endc
  draw at 7,323 text="1"
  ho1data=control EDIT
    window=hmain
    position=20,303,106,23
    help="第一个输出值(INT or 0xHEX)"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  ho1scr=control VSCROLL
    window=hmain
    position=126,303,18,23
    help="按下可更改并输出第一个值"
    limits=1,-1
  endc
  draw at 150,323 text="2"
  ho2data=control EDIT
    window=hmain
    position=166,303,106,23
    help="第二个输出值(INT or 0xHEX)"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  ho2scr=control VSCROLL
    window=hmain
    position=272,303,18,23
    help="按下可更改并输出第二个值"
    limits=1,-1
  endc
  hin=control BUTTON
    window=hmain
    position=7,334,40,22
    name="入"
    help="按下可从所选端口读取数据"
  endc
  hrepeat=control BUTTON
    window=hmain
    position=52,334,54,22
    name="实时值"
    help="按下可重复从端口读取数据"
  endc
  hout1=control BUTTON
    window=hmain
    position=119,334,45,22
    name="输出1"
    help="按下可将输出1输出到所选端口"
  endc
  hout2=control BUTTON
    window=hmain
    position=170,334,45,22
    name="输出2"
    help="按下可将输出2输出到所选端口"
  endc
  hquit=control BUTTON
    window=hmain
    position=230,334,60,22
    name="关闭"
    help="关闭32位端口I/O"
  endc
  if hquit==NULL then                  // Check if last created control exists
    destroy hmain                      // Out of resources, no way to continue
    lprintf(LIGHTRED,"32-bit Port I/O: Out of window handles")
    return
  endif
  draw show
  getini("Debug","IO32 general","%i,%i,%i,%i,%i,%i,%i,%i",                     \
    &device,&head,&camera,item+0,item+1,item+2,item+3,item+4)
  getini("Debug","IO32 extended","%i,%i,%i,%i",                                \
    &dtindex,&extmode,&headcam,item+5)
  dtindex=Max(0,Min(dtindex,15))
  extmode=Max(0,Min(extmode,8))
  for i=0,i<6,i++ do
    sprintf(key,"IO32_out1[%i]",i)
    out1[i][0]='\0'; getini("Debug",key,out1[i])
    sprintf(key,"IO32_out2[%i]",i)
    out2[i][0]='\0'; getini("Debug",key,out2[i])
  enddo
  layoutchanged=1; devicechanged=1; itemchanged=1; repeat=0; waitanswer=0
  extend=0; extcursor=0; extpause=0; nloop=0
  hyst8max=-HSTX/2; hyst12max=-HSTX/2; hyst16max=-HSTX/2
  dt=dtset[dtindex]*1000.0
  oldcameras=-1; oldheadcams=-1
  while 1 do
    if layoutchanged &&                                                        \
      (oldcameras!=$LAY.cameras || oldheadcams!=$LAY.headcameras)              \
    then
      oldcameras=$LAY.cameras
      oldheadcams=$LAY.headcameras
      if $LAY.cameras==0 && $LAY.headcameras!=0 then
        if device==2 then
          device=5
          devicechanged=1
        endif
        destroy hvideo; hvideo=NULL
        destroy hvidid; hvidid=NULL
        destroy hvidscr; hvidscr=NULL
        hcam=control RADIO
          window=hmain
          position=170,52,55,22
          name="相机"
          help="选择访问火线摄像头"
          font=INFOFONT
        endc
        hcamid=control TEXT
          window=hmain
          position=230,51,40,20
          help="选定摄像机(头部或节点)"
          font=MEDIUMFONT
          mode=M_CENTERED|M_BORDER
        endc
        hcamscr=control VSCROLL
          window=hmain
          position=270,51,20,20
          help="按下可选择另一个摄像头"
          limits=1,-1
        endc
      else
        if device==5 then
          device=2
          devicechanged=1
        endif
        destroy hcam; hcam=NULL
        destroy hcamid; hcamid=NULL
        destroy hcamscr; hcamscr=NULL
        hvideo=control RADIO
          window=hmain
          position=170,52,55,22
          name="相机"
          help="选择访问摄像头控制器"
          font=INFOFONT
        endc
        hvidid=control TEXT
          window=hmain
          position=230,51,40,20
          help="当前选定的摄像机"
          font=MEDIUMFONT
          mode=M_CENTERED|M_BORDER
          color=GRAY
        endc
        hvidscr=control VSCROLL
          window=hmain
          position=270,51,20,20
          help="按下选择其它摄像头或全部"
          limits=-1,1
        endc
      endif
      if $LAY.nfing==0 then
        disable hhead
        disable hheadid
        disable hheadscr
        disable hmeas
      else
        enable hhead
        enable hheadid
        enable hheadscr
        enable hmeas
      endif
      if $LAY.cameras==0 then
        disable hvideo
        disable hvidid
        disable hvidscr
        if device==2 then
          device=0
          devicechanged=1
        endif
      else
        enable hvideo
        enable hvidid
        enable hvidscr
      endif
      layoutchanged=0
    endif
    if hardreset then
      hardreset=0
      devicechanged=1
    endif
    if devicechanged then
      change hheadid color=GRAY
      if head<0 then
        change hheadid text="ALL";
      else
        change hheadid text=format("%i",head)
      endif
      if hvidid!=NULL then
        change hvidid color=GRAY
        if camera<0 then
          change hvidid text="ALL";
        else if camera==0 then
          change hvidid text="顶"
        else
          change hvidid text="底"
        endif
      endif
      if hcamid!=NULL then
        change hcamid color=GRAY
        if headcam<0 then
          change hcamid text=format("N %i",-headcam-1)
        else
          change hcamid text=format("H %i",headcam)
        endif
      endif
      if device==1 then                // Head
        change hhead mode=M_CHECKED
        change hheadid color=BLACK
        Copylist(list,headlist)
      else if device==2 then           // Camera
        change hvideo mode=M_CHECKED
        change hvidid color=BLACK
        Copylist(list,videolist)
      else if device==3 then           // Measurement card
        change hmeas mode=M_CHECKED
        Copylist(list,measlist)
      else if device==4 then           // SPS
        change hsps mode=M_CHECKED
        Copylist(list,spslist)
      else if device==5 then           // On-head camera
        change hcam mode=M_CHECKED
        change hcamid color=BLACK
        Copylist(list,hcamlist)
      else                             // Default: crate
        device=0
        change hcrat mode=M_CHECKED
        Copylist(list,cratelist)
      endif
      // Add custom ports.
      for n=0,list[n,0]!='\0',n++ do; enddo
      for i=0,i<10,i++ do
        sprintf(key,"IO32_slot[%i][%i]",device,i)
        custport=-1; s[0]='\0'; getini("Debug",key,"%X %s",&custport,s)
        if custport!=(-1) && s[0]!='\0' then
          sprintf(list[n],"%08X %s",custport,s)
          n++
        endif
      enddo
      list[n,0]='\0'
      devicechanged=0;
      itemchanged=1
      repeat=0; repout=0; reptype=0; nloop=0
      change hrepeat color=BLACK
      change hrepeat bkcolor=GRAY
      clear hlist
      for i=0,list[i,0]!='\0',i++ do
        for j=0,list[i,j+9]!='\0' && list[i,j+9]!='|',j++ do
          key[j]=list[i,j+9]
        enddo
        key[j]='\0'
        add hlist text=key
      enddo
      change ho1data text=out1[device]
      change ho2data text=out2[device]
    endif
    if itemchanged then
      change hlist select=item[device]
      clear hinint
      clear hinhex
      clear hmin
      clear hmax
      mindata=0x7FFFFFFF
      maxdata=0x80000000
      port=0
      for i=0,i<8,i++ do
        if Isdigit(list[item[device]][i]) then
          port=port*16+list[item[device]][i]-'0'
        else
          port=port*16+Toupper(list[item[device]][i])-'A'+10
        endif
      enddo
      clear hbits
      i=item[device]
      for j=9,list[i,j]!='\0' && list[i,j]!='|',j++ do; enddo
      // Display comments, if any.
      if list[i,j]=='|' && list[i,j+1]=='+' then
        draw window=hbits color=GREEN bkcolor=WHITE font=SMALLFONT
        draw at 5,15 wrap=116 text=list[i]+j+2 show
      endif
      SYS.Killimm(0)
      waitanswer=0
      repout=0; nloop=0; extchanged=1
      itemchanged=0
      resethistory=1
    endif
    if waitanswer && $A[0].length>5 then
      if $A[0].answer==S_INPORT32 || $A[0].answer==S_DEBUG then
        if $A[0].answer==S_DEBUG && device==5 then
          i=$uint2($A[0]+5)
          if i & 0x8000 then
            Strcpy(errmsg,"BAD NODE"); goto error
          else if i & 0x0006 then
            Strcpy(errmsg,"ERROR"); goto error
          else if i & 0x0001 then
            Strcpy(errmsg,"BAD REG"); goto error
          else
            data=$int4($A[0]+7)
            errmsg[0]='\0'
          endif
        else if $A[0].answer==S_INPORT32 then
          data=$int4($A[0]+5)
          errmsg[0]='\0'
        else
          data=$int4($A[0]+7)
          errmsg[0]='\0'
        endif
        if extend && repeat>1 && extpause==0 then
          if nhistory<HSTX Addsigma(history[nhistory],data)
          hyst8[data & 0xFF]++
          hyst12[(data>>4) & 0xFF]++
          hyst16[(data>>8) & 0xFF]++
          sy=sy+data
          syy=syy+data*(data*1.0)
          nhyst++
        endif
        change hinint text=format(" %i",data)
        change hinhex text=format(" %08X",data)
        if device!=5 && data<mindata then
          mindata=data
          change hmin text=format(" %i",mindata)
        endif
        if device!=5 && data>maxdata then
          maxdata=data
          change hmax text=format(" %i",maxdata)
        endif
        // Decode bits.
        i=item[device]
        for j=9,list[i,j]!='\0' && list[i,j]!='|',j++ do; enddo
        if list[i,j]=='|' && list[i,j+1]!='+' then
          j++; y=3
          draw window=hbits clear
          draw bkcolor=WHITE font=SMALLFONT
          while list[i,j]!='\0' do
            y=y+11
            while list[i,j]==' ' do y=y+3; j++; enddo
            k=0
            if list[i,j]=='&' then
              // Bit field.
              j++
              while Isxdigit(list[i,j]) do
                if list[i,j]>='A' && list[i,j]<='F' then
                  k=k*16+list[i,j]-'A'+10
                else if list[i,j]>='a' && list[i,j]<='f' then
                  k=k*16+list[i,j]-'a'+10
                else
                  k=k*16+list[i,j]-'0'
                endif
                j++
              enddo
              if list[i,j]=='=' j++
              if k==0 then
                bitdata=0
              else
                bitdata=data & k
                while (k & 1)==0 do
                  bitdata=(bitdata>>1) & 0x7FFFFFFF; k=k>>1
                enddo
              endif
              bitfield=1
            else if list[i,j]=='F' then
              // Coordinate in 1/256th of millimeter.
              j++
              bitfield=0
              draw at 10,y text=format("%.4f mm",data/256000.0)
              break
            else
              while Isdigit(list[i,j]) do k=k*10+list[i,j]-'0'; j++; enddo
              if list[i,j]=='!' then
                negate=1; j++
              else
                negate=0
                if list[i,j]=='?' j++
              endif
              bitfield=0
            endif
            n=0
            while list[i,j]!='=' && list[i,j]!=',' && list[i,j]!='\0' do
              key[n]=list[i,j]; j++; n++
            enddo
            key[n]='\0'
            draw at 5,y color=BLACK text=key
            if list[i,j]==',' || list[i,j]=='\0' then
              // 0, 1 or bitfield.
              if list[i,j]==',' j++
              if bitfield then
                draw at 65,y text=format("%i",bitdata)
              else if negate==0 then
                draw at 65,y text=(data & (1<<k)?"1":"0")
              else
                draw at 65,y text=(data & (1<<k)?"0":"1")
              endif
            else
              // Textual explanations.
              if list[i,j]=='=' j++
              n=0
              if (data & (1<<k)) then
                if list[i,j]=='+' then
                  draw color=LIGHTRED; j++
                endif
                while list[i,j]!=':' && list[i,j]!='\0' do
                  key[n]=list[i,j]; j++; n++
                enddo
                if list[i,j]==':' j++
                while list[i,j]!=',' && list[i,j]!='\0' do j++; enddo
              else
                while list[i,j]!=':' && list[i,j]!='\0' do j++; enddo
                if list[i,j]==':' then
                  j++
                  if list[i,j]=='+' then
                    draw color=LIGHTRED; j++
                  endif
                  while list[i,j]!=',' && list[i,j]!='\0' do
                    key[n]=list[i,j]; j++; n++
                  enddo
                endif
              endif
              key[n]=0
              draw at 65,y text=key
              if list[i,j]==',' j++
            endif
          enddo
          draw show
        endif
      else
        Strcpy(errmsg,"ERROR")
      endif
    error:
      if errmsg[0]!='\0' then
        // Error, display and stop.
        change hinint text=format(" %s",errmsg)
        clear hinhex
        repeat=0
        change hrepeat color=BLACK
        change hrepeat bkcolor=GRAY
      endif
      waitanswer=0
    endif
    if repeat>0 && waitanswer==0 then
      if device==4 then                // SPS, use S_DEBUG instead of S_INPORT32
        buf[0]=S_DEBUG
        buf[1]=0x28                    // Read SPS registers multiple
        $int2(buf+2)=port              // Index of base register
        $int2(buf+4)=1                 // Number of registers to read
        SYS.Sendimm(0,6,buf)
      else if device==5 then           // Firewire camera, use S_DEBUG
        buf[0]=S_DEBUG
        buf[1]=0x44                    // Read Firewire camera register
        if headcam<0 then
          buf[2]=-headcam-1            // Request by Firewire node
        else
          buf[2]=headcam | 0x40        // Request by head
        endif
        $int4(buf+3)=port              // Register
        $int4(buf+7)=4                 // Number of bytes to read
        $int4(buf+11)=0                // Reserved, must be zero
        SYS.Sendimm(0,15,buf)
      else
        buf[0]=S_INPORT32
        if device==1 then              // Head controller
          buf[1]=(head<0?0:head)
        else if device==2 then         // Video camera
          buf[1]=(camera<0?0:camera)+$LAY.nfing*2
        else if device==3 then         // Measurement card
          buf[1]=0x80
        else                           // Crate controller
          buf[1]=0xFF
        endif
        $int4(buf+2)=port
        SYS.Sendimm(0,6,buf)
      endif
      waitanswer=1
      repeat--
      if repeat==0 then
        change hrepeat color=BLACK
        change hrepeat bkcolor=GRAY
      else
        delay 10                       // Limit rate of commands
      endif
    endif
    if Pressed(hcrat) && device!=0 then
      device=0
      devicechanged=1
    else if Pressed(hextend) then
      if extend==0 then                // Extend port I/O window
        change hmain position=*,*,565,362
        change hextend name="<<"
        change hextend help="按下可关闭其它控件"
        hright=control CHILD
          window=hmain
          position=300,0,265,362
          help=" "
          color=LIGHTYELLOW
          bkcolor=LIGHTYELLOW
          size=256
        endc
        hextgraph=control GRAPH
          window=hright
          position=1,9,HSTX,HSTY
          bkcolor=WHITE
          help="端口历史记录，单击可设置光标"
        endc
        hextinfo=control TEXT
          window=hright
          position=0,271,HSTX+2,22
          font=INFOFONT
          help="所选样本的信息"
          mode=M_BORDER
        endc
        hextmode=control COMBOLIST
          window=hright
          position=0,301,95,180
          help="选择如何显示记录的数据"
          mode=M_SELECTION
        endc
        add hextmode text="8位数据"
        add hextmode text="12位数据"
        add hextmode text="16位数据"
        add hextmode text="24位数据"
        add hextmode text="32位数据"
        add hextmode text="8输入"
        add hextmode text="8位滞后"
        add hextmode text="12位滞后"
        add hextmode text="16位滞后"
        change hextmode select=extmode
        draw window=hright color=BLACK font=INFOFONT
        draw at 100,321 text="dT="
        hextdelta=control TEXT
          window=hright
          position=125,301,40,24
          mode=M_CENTERED|M_BORDER
          help="采样或输出之间的间隔(不保证),秒"
          font=MEDIUMFONT
        endc
        hextdscr=control VSCROLL
          window=hright
          position=165,301,20,24
          limits=1,-1
          help="按下可更改采样或输出间隔"
        endc
        draw at 188,321 text="s"
        draw show
        hextminmax=control CHECKBOX
          window=hright
          position=203,301,56,24
          name="Mn/mx"
          help="选中可以绘制最小值和最大值"
          mode=M_CHECKED
          font=INFOFONT
        endc
        hextrep=control BUTTON
          window=hright
          position=0,334,58,22
          name="出1/2"
          help="按指定的时间重复输出1 / 输出2"
        endc
        if device==5 disable hextrep
        hextpulse=control BUTTON
          window=hright
          position=63,334,48,22
          name="脉冲"
          help="按此键可在指定延迟后输出1，然后输出2"
        endc
        if device==5 disable hextpulse
        hextset0=control BUTTON
          window=hright
          position=116,334,45,22
          name="置0"
          help="按此键可在最后一个采样时对齐信号"
        endc
        hextclear=control BUTTON
          window=hright
          position=166,334,35,22
          name="清空"
          help="按下可清除历史记录协议"
        endc
        hextpause=control BUTTON
          window=hright
          position=206,334,52,22
          name="暂停"
          help="按下可暂停历史协议"
        endc
        repout=0; extend=1; extchanged=1; extpause=0; extset0=0
        resethistory=1
      else                             // Restore basic I/O window
        change hmain position=*,*,298,362
        change hextend name=">>"
        change hextend help="按下可打开其它控制器"
        destroy hright
        hextrep=NULL
        hextpulse=NULL
        extend=0
      endif
    else if (Pressed(hhead) || Pressed(hheadid)) && device!=1 then
      device=1
      devicechanged=1
    else if Pressed(hheadscr) then
      if device!=1 then
        device=1
        devicechanged=1
      endif
      head=Max(-1,Min(head+Status(hheadscr),$LAY.nfing*2-1))
      change hheadscr select=0
      devicechanged=1
    else if (Pressed(hvideo) || Pressed(hvidid)) && device!=2 then
      device=2
      devicechanged=1
    else if Pressed(hvidscr) then
      if device!=2 then
        device=2
        devicechanged=1
      endif
      camera=Max(-1,Min(camera+Status(hvidscr),1))
      change hvidscr select=0
      devicechanged=1
    else if Pressed(hcust) then
      if hcustwin!=NULL then
        // Close custom port window.
        destroy hcustwin
        hcustwin=NULL
        custchanged=0
      else
        // Open custom port window.
        custdev=device
        if custdev==0 then Strcpy(s,"自定义内核I/O端口")
        else if custdev==1 then Strcpy(s,"自定义手臂I/O端口")
        else if custdev==2 then Strcpy(s,"自定义视频I/O端口")
        else if custdev==3 then Strcpy(s,"自定义测量卡I/O端口")
        else Strcpy(s,"自定义SPS I/O 注册")
        endif
        hcustwin=control WINDOW
          window=hmain
          position=10,10,248,130
          name=s
          help=" "
          bkcolor=WHITEGREEN
          mode=M_BORDER
          size=512
        endc
        draw window=hcustwin font=INFOFONT color=BLACK
        draw at 10,31 text="位置:"
        draw at 10,60 text="名称:"
        draw at 10,88 text="端口:"
        draw show
        hcustslot=control COMBOLIST
          window=hcustwin
          position=53,10,50,200
          help="为新端口选择插槽"
        endc
        for i=0,i<10,i++ do
          add hcustslot text=format("%i",i+1)
        enddo
        change hcustslot select=0
        hcustname=control EDIT
          window=hcustwin
          position=53,42,187,20
          help="输入端口名"
          bkcolor=WHITE
        endc
        hcustport=control EDIT
          window=hcustwin
          position=53,70,187,20
          help="输入十六进制端口索引"
          bkcolor=WHITE
        endc
        hcustdelete=control BUTTON
          window=hcustwin
          position=10,101,70,21
          text="删除"
          help="删除插槽"
        endc
        hcustadd=control BUTTON
          window=hcustwin
          position=90,101,70,21
          text="增加"
          help="按下可添加或更新端口"
        endc
        hcustclose=control BUTTON
          window=hcustwin
          position=170,101,70,21
          text="关闭"
          help="按下可关闭对话框"
        endc
        custchanged=1
      endif
    else if Pressed(hmeas) && device!=3 then
      device=3
      devicechanged=1
    else if Pressed(hsps) && device!=4 then
      device=4
      devicechanged=1
    else if (Pressed(hcam) || Pressed(hcamid)) && device!=5 then
      device=5
      devicechanged=1
    else if Pressed(hcamscr) then
      if device!=5 then
        device=5
        devicechanged=1
      endif
      headcam=Max(-32,Min(headcam+Status(hcamscr),$LAY.nfing*2-1))
      change hcamscr select=0
      devicechanged=1
    else if Pressed(hlist) then
      item[device]=Status(hlist)
      itemchanged=1
    else if Pressed(hin) then
      repeat=1
      change hrepeat color=BLACK
      change hrepeat bkcolor=GRAY
    else if Pressed(hrepeat) then
      if repeat<=1 then
        repeat=0x7FFFFFFF
        change hrepeat color=LIGHTRED
        change hrepeat bkcolor=YELLOW
        resethistory=1
      else
        repeat=0
        change hrepeat color=BLACK
        change hrepeat bkcolor=GRAY
      endif
    else if Pressed(hout1) || Pressed(ho1data) || Pressed(ho1scr) || force1 then
      Text(ho1data,s); i=0; j=0
      while s[j]==' ' do j++; enddo
      if s[j]=='0' && (s[j+1]=='x' || s[j+1]=='X') then
        sscanf(s+j,"%X",&i)
        j=Status(ho1scr)
        if j>0 then
          if i==0 then i=0x00000001; else i=i<<1; endif
        else if j<0 then
          if i==0 then i=0x80000000; else i=i>>1; endif
        endif
        sprintf(out1[device]," 0x%X",i)
      else
        sscanf(s+j,"%i",&i)
        i=i+Status(ho1scr)
        sprintf(out1[device]," %i",i)
      endif
      change ho1scr select=0
      change ho1data text=out1[device]
      if device==4 then                // SPS, use S_DEBUG
        buf[0]=S_DEBUG
        buf[1]=0x29                    // Write SPS registers multiple
        $int2(buf+2)=port              // Index of base register
        $int2(buf+4)=1                 // Number of registers to write
        $int4(buf+6)=i
        SYS.Sendimm(0,10,buf)
      else if device==5 then
        buf[0]=S_DEBUG
        buf[1]=0x46                    // Write Firewire camera register
        if headcam<0 then
          buf[2]=-headcam-1            // Request by Firewire node
        else
          buf[2]=headcam | 0x40        // Request by head
        endif
        $int4(buf+3)=port              // Register
        $int4(buf+7)=4                 // Number of bytes to write
        $int4(buf+11)=0                // Reserved, must be zero
        $int4(buf+15)=i                // Data
        SYS.Sendimm(0,19,buf)
      else
        buf[0]=S_OUTPORT32
        if device==1 then              // Head controller
          buf[1]=(head<0?0x7F:head)
        else if device==2 then         // Video camera
          buf[1]=(camera<0?0:camera)+$LAY.nfing*2
        else if device==3 then         // Measurement card
          buf[1]=0x80
        else                           // Crate controller
          buf[1]=0xFF
        endif
        $int4(buf+2)=port
        $int4(buf+6)=i
        SYS.Sendimm(1,10,buf)
        if device==2 && camera<0 then
          buf[1]=1+$LAY.nfing*2        // OUTPORT32 to second camera
          SYS.Sendimm(1,10,buf)
        endif
      endif
      if force1==0 then
        repout=0; extchanged=1
      endif
      force1=0
    else if Pressed(hout2) || Pressed(ho2data) || Pressed(ho2scr) || force2 then
      Text(ho2data,s); i=0; j=0
      while s[j]==' ' do j++; enddo
      if s[j]=='0' && (s[j+1]=='x' || s[j+1]=='X') then
        sscanf(s+j,"%X",&i)
        j=Status(ho2scr)
        if j>0 then
          if i==0 then i=0x00000001; else i=i<<1; endif
        else if j<0 then
          if i==0 then i=0x80000000; else i=i>>1; endif
        endif
        sprintf(out2[device]," 0x%X",i)
      else
        sscanf(s+j,"%i",&i)
        i=i+Status(ho2scr)
        sprintf(out2[device]," %i",i)
      endif
      change ho2scr select=0
      change ho2data text=out2[device]
      if device==4 then                // SPS, use S_DEBUG
        buf[0]=S_DEBUG
        buf[1]=0x29                    // Write SPS registers multiple
        $int2(buf+2)=port              // Index of base register
        $int2(buf+4)=1                 // Number of registers to read
        $int4(buf+6)=i
        SYS.Sendimm(0,10,buf)
      else if device==5 then
        buf[0]=S_DEBUG
        buf[1]=0x46                    // Write Firewire camera register
        if headcam<0 then
          buf[2]=-headcam-1            // Request by Firewire node
        else
          buf[2]=headcam | 0x40        // Request by head
        endif
        $int4(buf+3)=port              // Register
        $int4(buf+7)=4                 // Number of bytes to write
        $int4(buf+11)=0                // Reserved, must be zero
        $int4(buf+15)=i                // Data
        SYS.Sendimm(0,19,buf)
      else
        buf[0]=S_OUTPORT32
        if device==1 then              // Head controller
          buf[1]=(head<0?0x7F:head)
        else if device==2 then         // Video camera
          buf[1]=(camera<0?0:camera)+$LAY.nfing*2
        else if device==3 then         // Measurement card
          buf[1]=0x80
        else                           // Crate controller
          buf[1]=0xFF
        endif
        $int4(buf+2)=port
        $int4(buf+6)=i
        SYS.Sendimm(1,10,buf)
        if device==2 && camera<0 then
          buf[1]=1+$LAY.nfing*2        // OUTPORT32 to second camera
          SYS.Sendimm(1,10,buf)
        endif
      endif
      if force2==0 then
        repout=0; extchanged=1
      endif
      force2=0
    else if Pressed(hquit) then
      setini("Debug","IO32 general","%i,%i,%i,%i,%i,%i,%i,%i",                 \
        device,head,camera,item[0],item[1],item[2],item[3],item[4])
      setini("Debug","IO32 extended","%i,%i,%i,%i",                            \
        dtindex,extmode,headcam,item[5])
      for i=0,i<6,i++ do
        sprintf(key,"IO32_out1[%i]",i)
        setini("Debug",key,out1[i])
        sprintf(key,"IO32_out2[%i]",i)
        setini("Debug",key,out2[i])
      enddo
      break
    endif
    // Process messages from extended controls and update their state.
    if extend then
      if (Pressed(hextgraph) || Status(hextgraph)==1) then
        i=Max(-1,Min(Limit0(hextgraph),HSTX))
        if i!=extcursor then
          extcursor=i
          redrawhistory=1
        endif
      endif
      if Pressed(hextmode) then
        extmode=Status(hextmode)
        redrawhistory=1
      else if Pressed(hextdscr) then
        dtindex=Max(0,Min(dtindex+Status(hextdscr),15))
        dt=dtset[dtindex]*1000.0
        change hextdscr select=0
        extchanged=1
        resethistory=1
      else if Pressed(hextminmax) then
        redrawhistory=1
      else if Pressed(hextrep) then
        repout=!repout
        reptype=0
        reptime=Time()
        extchanged=1
        redrawinfo=1
      else if Pressed(hextpulse) then
        repout=1
        reptype=1
        reptime=Time()-dt-1
        extchanged=1
        redrawinfo=1
      else if Pressed(hextset0) then
        hyst8max=-HSTX/2; hyst12max=-HSTX/2; hyst16max=-HSTX/2
        if extset0==1 then
          extset0=0
          change hextset0 bkcolor=GRAY
          redrawhistory=1
        else if (nhistory>0 && Getcount(history[nhistory])>0) ||               \
          (nhistory>1 && Getcount(history[nhistory-1])>0) then
          if Getcount(history[nhistory])>0 then
            offset=Getmean(history[nhistory])
          else
            offset=Getmean(history[nhistory-1])
          endif
          extset0=1
          k=0
          for i=0,i<HSTX,i++ do
            if hyst8[i]>k then hyst8max=i; k=hyst8[i]; endif
          enddo
          k=0
          for i=0,i<HSTX,i++ do
            if hyst12[i]>k then hyst12max=i; k=hyst12[i]; endif
          enddo
          k=0
          for i=0,i<HSTX,i++ do
            if hyst16[i]>k then hyst16max=i; k=hyst16[i]; endif
          enddo
          change hextset0 bkcolor=YELLOW
          redrawhistory=1
        endif
      else if Pressed(hextclear) then
        resethistory=1
      else if Pressed(hextpause) then
        if extpause!=0 then
          extpause=0
          change hextpause bkcolor=GRAY
          thistory=Time()
        else
          extpause=1
          change hextpause bkcolor=YELLOW
        endif
      endif
      if repeat>1 && ((extpause==0 && Time()-thistory>dt) ||                   \
        (extpause==1 && Getcount(history[nhistory])>0)) then
        if extpause==1 extpause=2
        if nhistory>0 || Getcount(history[0])!=0 then
          nhistory++
          if nhistory>=HSTX then
            Memcpy(history[0],history[1],Sizeof(history[1]))
            nhistory=HSTX-1
          endif
          Initsigma(history[nhistory])
          history[nhistory][5]=(Time()-thiststart)/1000.0
          redrawhistory=1
        endif
        thistory=thistory+dt
      endif
      if repout then
        if Time()-reptime>=dt then
          if repout==1 then
            force1=1; repout=2
          else if reptype==0 then
            force2=1; repout=1; nloop++; redrawinfo=1
          else
            force2=1; repout=0; nloop=0; redrawinfo=1; extchanged=1
          endif
          reptime=reptime+dt
        endif
      endif
      if resethistory then
        nhistory=0; nhyst=0; sy=0.0; syy=0.0
        Memset(hyst8,0,Sizeof(hyst8))
        Memset(hyst12,0,Sizeof(hyst12))
        Memset(hyst16,0,Sizeof(hyst16))
        thiststart=Time()
        Initsigma(history[0])
        history[0][5]=0.0
        thistory=Time()
        resethistory=0
        redrawhistory=1
      endif
      if redrawhistory || redrawinfo then
        if nloop>0 then
          n=sprintf(s,"Nloop=%i ",nloop)
        else
          s[0]='\0'; n=0
        endif
        if redrawhistory then
          draw window=hextgraph bkcolor=WHITE clear
          if extcursor>=0 && extcursor<HSTX then
            draw color=DARKGRAY at extcursor,0 to extcursor,HSTY
          endif
        endif
        if extmode<5 then
          if redrawhistory then
            if nhistory>0 then
              if extset0==0 then
                offset=0.0; yshift=HSTY-1
              else
                yshift=HSTY/2
              endif
              if extmode==0 then scale=1.0
              else if extmode==1 then scale=1.0/16.0
              else if extmode==2 then scale=1.0/256.0
              else if extmode==3 then scale=1.0/65536.0
              else scale=1.0/16777216.0; endif
              if Status(hextminmax)==1 then
                y=(yshift-(Getmax(history[0])-offset)*scale) & 0xFF
                draw color=LIGHTRED at 0,y
                for i=0,i<nhistory,i++ do
                  if Getcount(history[i])==0 continue
                  y=(yshift-(Getmax(history[i])-offset)*scale) & 0xFF
                  draw to i,y
                enddo
                draw pixel i,y
                y=(yshift-(Getmin(history[0])-offset)*scale) & 0xFF
                draw color=LIGHTBLUE at 0,y
                for i=0,i<nhistory,i++ do
                  if Getcount(history[i])==0 continue
                  y=(yshift-(Getmin(history[i])-offset)*scale) & 0xFF
                  draw to i,y
                enddo
                draw pixel i,y
              endif
              y=(yshift-(Getmean(history[0])-offset)*scale) & 0xFF
              draw color=BLACK at 0,y
              for i=0,i<nhistory,i++ do
                if Getcount(history[i])==0 continue
                y=(yshift-(Getmean(history[i])-offset)*scale) & 0xFF
                draw to i,y
              enddo
              draw pixel i,y
            endif
          endif
          if extcursor>=0 && extcursor<nhistory then
            n=n+sprintf(s+n,"T=%.2f",history[extcursor][5])
            if Getcount(history[extcursor])>0 then
              n=n+sprintf(s+n,": %.1f (%.0f..%.0f)",                           \
              Getmean(history[extcursor]),Getmin(history[extcursor]),          \
              Getmax(history[extcursor]))
            endif
          endif
        else if extmode==5 then
          if redrawhistory then
            k=1
            for j=0,j<8,j++ do
              y=j*30+22
              draw at 3,y font=SMALLFONT color=GREEN text=format("Bit %i",j)
              m=Getmax(history[0])
              draw color=BLACK at 0,y+(m & k?0:10)
              for i=0,i<nhistory,i++ do
                if Getcount(history[i])==0 continue
                m=Getmax(history[i])
                draw to i,y+(m & k?0:10)
              enddo
              draw to i,y+(m & k?0:10)
              k=k<<1
            enddo
          endif
          if extcursor>=0 && extcursor<nhistory &&                             \
            Getcount(history[extcursor])>0 then
            m=Getmax(history[extcursor])
            k=1; n=n+sprintf(s+n,"0x%02X: ",m & 0xFF)
            for j=0,j<8,j++ do
              n=n+sprintf(s+n," %i=%i",j,m & k?1:0)
              k=k<<1
            enddo
          endif
        else
          if extmode==6 then
            Memcpy(temp,hyst8,Sizeof(hyst8)); j=hyst8max; m=1
          else if extmode==7 then
            Memcpy(temp,hyst12,Sizeof(hyst12)); j=hyst12max; m=16
          else
            Memcpy(temp,hyst16,Sizeof(hyst16)); j=hyst16max; m=256
          endif
          if redrawhistory then
            k=1
            for i=0,i<HSTX,i++ do
              k=Max(k,temp[i])
            enddo
            scale=(HSTY-20.0)/(k+(HSTY-20.0)/5.0)
            draw color=LIGHTGRAY at 0,HSTY-10 to HSTX,HSTY-10
            draw color=BLACK
            k=-1
            for i=0,i<HSTX,i++ do
              x=(i+HSTX+HSTX/2-j)%HSTX
              if x==extcursor k=i
              if temp[i]==0 continue
              draw at x,HSTY-10-temp[i]*scale to x,HSTY-9
            enddo
          endif
          if extcursor>=0 && extcursor<HSTX && k>=0 then
            n=n+sprintf(s+n,"Pos=%i N=%i of %i",extcursor*m,temp[k],nhyst)
            if nhyst>1 sprintf(s+n,", Sigma=%.1f",                             \
              Sqrt(Abs(nhyst*syy-sy*sy)/nhyst/(nhyst-1)))
          endif
        endif
        if redrawhistory then
          draw show
        endif
        change hextinfo text=s
        redrawhistory=0
        redrawinfo=0
      endif
      if extchanged then
        extchanged=0
        dtindex=Max(0,Min(dtindex,15))
        change hextdelta text=format("%g",dtset[dtindex])
        if repout==0 then
          change hextrep bkcolor=GRAY
          change hextpulse bkcolor=GRAY
        else if reptype==0 then
          change hextrep bkcolor=YELLOW
          change hextpulse bkcolor=GRAY
        else
          change hextrep bkcolor=GRAY
          change hextpulse bkcolor=YELLOW
        endif
      endif
    endif
    // Process messages from custom port window.
    if hcustwin!=NULL then
      if Pressed(hcustslot) then
        custchanged=1
      else if Pressed(hcustdelete) then
        i=Status(hcustslot)
        sprintf(key,"IO32_slot[%i][%i]",custdev,i)
        setini("Debug",key,"")
        custchanged=1
        devicechanged=1
      else if Pressed(hcustadd) then
        i=Status(hcustslot)
        Text(hcustport,s); custport=-1; sscanf(s,"%i",&custport)
        Text(hcustname,s)
        if s[0]!='\0' && custport!=(-1) then
          sprintf(key,"IO32_slot[%i][%i]",custdev,i)
          setini("Debug",key,"%X %s",custport,s)
          custchanged=1
          devicechanged=1
        endif
      else if Pressed(hcustclose) then
        destroy hcustwin
        hcustwin=NULL
      endif
      if custchanged then
        i=Status(hcustslot)
        sprintf(key,"IO32_slot[%i][%i]",custdev,i)
        custport=0; s[0]='\0'; getini("Debug",key,"%X %s",&custport,s)
        if s[0]=='\0' custport=0
        change hcustname text=s
        change hcustport text=format("0x%08X",custport)
        custchanged=0
      endif
    endif
    if repout==0 || dt>100 wait
  enddo
end

function int Version()
  char buf[16]
  int i,j,ident,t
  handle hmain,hexit,hcrate,hlayout,hhead,hmeas
  hmain=control WINDOW
    window=NULL
    position=10,10,360,220
    name="软件版本"
    help=" "
    bkcolor=YELLOW
    mode=M_MODAL
    size=128
  endc
  draw window=hmain font=INFOFONT
  draw at 1,27 text="内核:"
  hcrate=control TEXT
    window=hmain
    position=50,10,300,57
    help="当前加载的内核控制器软件"
    font=INFOFONT
    mode=M_BORDER
  endc
  draw at 1,90 text="布局:"
  hlayout=control TEXT
    window=hmain
    position=50,73,300,19
    help="当前加载的布局"
    font=INFOFONT
    mode=M_BORDER
  endc
  draw at 1,115 text="测试头:"
  hhead=control TEXT
    window=hmain
    position=50,98,300,38
    help="当前加载的测试头控制软件"
    font=INFOFONT
    mode=M_BORDER
  endc
  draw at 2,159 text="测量卡:"
  hmeas=control TEXT
    window=hmain
    position=50,142,300,38
    help="当前加载的测量卡软件"
    font=INFOFONT
    mode=M_BORDER
  endc
  hexit=control BUTTON
    window=hmain
    position=140,190,80,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  buf[0]=0x11                          // S_DUMP
  buf[1]=255                           // Request to crate controller
  buf[2]=0x14                          // Get software version
  $uint2(buf+3)=0                      // Number of items
  $uint2(buf+5)=0                      // Start item
  ident=SYS.Sendimm(0,7,buf)
  delay 100
  t=Time()+14999                       // Timeout 15 seconds
  while 1 do                           // Wait for some answer
    if $A[0].length>0 then             // Answer is here
      if $A[0].answer==S_ERROR && $A[0].length==8 then
        change hcrate color=LIGHTRED
        change hcrate text="Crate controller is not loaded"
      else if $A[0].answer==0x11 then  // Correct answer, extract subfields
        j=5
        for i=j,i<$A[0].length,i++
          if $A[0].rawdata[i]==0x0A then
            $A[0].rawdata[i]='\0'; i++
            break
          endif
        enddo
        change hcrate text=$A[0]+j
        j=i
        for i=j,i<$A[0].length,i++
          if $A[0].rawdata[i]==0x0A then
            $A[0].rawdata[i]='\0'; i++
            break
          endif
        enddo
        change hlayout text=$A[0]+j
        j=i
        for i=j,i<$A[0].length,i++
          if $A[0].rawdata[i]==0x0A then
            $A[0].rawdata[i]='\0'; i++
            break
          endif
        enddo
        change hhead text=$A[0]+j
        j=i
        for i=j,i<$A[0].length,i++
          if $A[0].rawdata[i]==0x0A then
            $A[0].rawdata[i]='\0'; i++
            break
          endif
        enddo
        change hmeas text=$A[0]+j
      else
        change hcrate color=LIGHTRED
        change hcrate text="Error determining software version"
      endif
      break
    else if Time()>t then              // Timeout
      SYS.Killsend(ident)
      change hcrate color=LIGHTRED
      change hcrate text="Timeout while waiting for answer"
      break
    else if Pressed(hexit) then        // Operator pressed "Close"
      SYS.Killsend(ident)
      destroy hmain
      return
    endif
    change hcrate text=format("Timeout %i s, please wait...",(t-Time())/1000+1)
    delay 100
  enddo
  while 1 do                           // Wait till user closes the window
    if Pressed(hexit) break
    wait
  enddo
  destroy hmain
end

function int HVinit()
  int t,y,newsoft,volt,cmax,acc,ttime,rise,redraw
  int rmax,imax,vrise,lowr,hvmode
  handle hmain,hinit,hexit
  handle hvolt,hvscr,haccu,hascr,htime,htscr,hfixt,hunip,hchgp,hcapa
  handle hcscr,hrise,hrscr,hextr,hrmax,hxscr,hitst,hlowr,hlscr
  char s[64]
  // Check which version of initialization we have: old or new.
  if $GLOBAL.a5==0 then
    newsoft=0
  else
    SYS.Killimm(0)
    SERV.Cmdimm(0,"INPORT32 CRATE 0x1002001F")
    t=Time()
    while $A[0].length==0 do
      if Time()-t>2000 break
      wait
    enddo
    if $A[0].length==9 && $A[0].answer==S_INPORT32 then
      newsoft=($uint4($A[0]+5) & 0x04000000)!=0
    else
      newsoft=0
    endif
  endif
  volt=250; acc=10; cmax=1000; rise=1  // Defaults (classical)
  rmax=2000; imax=1; vrise=100; lowr=0 // Defaults (new)
  hvmode=0
  getini("Debug","HVinit","%i,%i,%i,%i,%i,%i,%i,%i,%i,%i",                     \
    &volt,&acc,&cmax,&ttime,&rise,&rmax,&imax,&vrise,&lowr,&hvmode)
  hvmode=hvmode & 0x002C
  hmain=control WINDOW
    window=NULL
    position=10,10,280,394
    name="高压自检"
    help=" "
    bkcolor=WHITEBLUE
    size=256
  endc
  draw window=hmain color=BLUE font=INFOFONT
  y=10
  draw at 10,y+21 text="测试电压, V:"
  hvolt=control EDIT
    window=hmain
    position=179,y,70,25
    help="加到网络的电压"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hvscr=control VSCROLL
    window=hmain
    position=249,y,21,25
    help="按下更改测试电压"
    limits=1,-1
  endc
  y=y+30
  if newsoft then
    draw at 10,y+21 text="最大阻抗, MO:"
    hrmax=control EDIT
      window=hmain
      position=179,y,70,25
      help="最大呈报的电阻, MOhm"
      bkcolor=WHITE
      font=MEDIUMFONT
    endc
    hxscr=control VSCROLL
      window=hmain
      position=249,y,21,25
      help="按下更改最大电阻"
      limits=1,-1
    endc
    y=y+30
  else
    draw at 10,y+21 text="测试精度, %:"
    haccu=control EDIT
      window=hmain
      position=179,y,70,25
      help="测量精度"
      bkcolor=WHITE
      font=MEDIUMFONT
    endc
    hascr=control VSCROLL
      window=hmain
      position=249,y,21,25
      help="按下更改测试精度"
      limits=1,-1
    endc
    y=y+30
  endif
  draw at 10,y+21 text="维持时间, ms:"
  htime=control EDIT
    window=hmain
    position=179,y,70,25
    help="满电压下的最小时间"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  htscr=control VSCROLL
    window=hmain
    position=249,y,21,25
    help="按下可更改测试时间"
    limits=1,-1
  endc
  y=y+30
  if newsoft then
    draw at 10,y+21 text="测试电流, mA:"
    hitst=control COMBOLIST
      window=hmain
      position=179,y,91,100
      help="最大允许试验电流，mA"
      bkcolor=WHITE
      font=MAINFONT
    endc
    add hitst text="1 mA"
    add hitst text="10 mA"
    y=y+30
  else
    draw at 10,y+21 text="最大电容, nF:"
    hcapa=control EDIT
      window=hmain
      position=179,y,70,25
      help="网络间允许的电容"
      bkcolor=WHITE
      font=MEDIUMFONT
    endc
    hcscr=control VSCROLL
      window=hmain
      position=249,y,21,25
      help="按下可更改最大电容"
      limits=1,-1
    endc
    y=y+30
  endif
  if newsoft then
    draw at 10,y+21 text="提升速度, V/ms:"
    hrise=control EDIT
      window=hmain
      position=179,y,70,25
      help="最大电压上升速度，V/ms"
      bkcolor=WHITE
      font=MEDIUMFONT
    endc
    hrscr=control VSCROLL
      window=hmain
      position=249,y,21,25
      help="按下更改电压上升速度"
      limits=1,-1
    endc
    y=y+30
  else
    draw at 10,y+21 text="上升因素, ms/100 V:"
    hrise=control EDIT
      window=hmain
      position=179,y,70,25
      help="最小上升系数，ms/100v"
      bkcolor=WHITE
      font=MEDIUMFONT
    endc
    hrscr=control VSCROLL
      window=hmain
      position=249,y,21,25
      help="按下可更改上升系数"
      limits=1,-1
    endc
    y=y+30
    hextr=control CHECKBOX
      window=hmain
      position=9,y+3,227,16
      text="扩展(10 GOhm)电阻"
      help="检查扩展R范围"
      color=BLUE
      font=INFOFONT
      mode=M_RIGHT
    endc
    if $GLOBAL.a5==0 disable hextr
    y=y+30
  endif
  if newsoft then
    draw at 10,y+21 text="低阻抗, MOhm:"
    hlowr=control EDIT
      window=hmain
      position=179,y,70,25
      help="首先做低压电阻"
      bkcolor=WHITE
      font=MEDIUMFONT
    endc
    hlscr=control VSCROLL
      window=hmain
      position=249,y,21,25
      help="按下可更改低阻"
      limits=1,-1
    endc
    y=y+30
    hfixt=control CHECKBOX
      window=hmain
      position=9,y+5,93,16
      text="固定测试时间"
      help="请勿延长测试时间"
      color=BLUE
      font=INFOFONT
      mode=(hvmode & 0x0004?M_CHECKED:0)
    endc
    hunip=control CHECKBOX
      window=hmain
      position=108,y+5,72,16
      text="单极的"
      help="单极测量"
      color=BLUE
      font=INFOFONT
      mode=(hvmode & 0x0008?M_CHECKED:0)
    endc
    hchgp=control CHECKBOX
      window=hmain
      position=183,y+5,90,16
      text="自动极性"
      help="减少极化效应"
      color=BLUE
      font=INFOFONT
      mode=(hvmode & 0x0020?M_CHECKED:0)
    endc
    y=y+30
  endif
  hansw=control LIST
    window=hmain
    position=10,y,260,359-y
    help="最后几个答案"
    mode=M_VSCROLL
    size=4096
  endc
  hinit=control BUTTON
    window=hmain
    position=10,366,125,22
    name="初始化"
    help="按下可初始化高压卡"
  endc
  hexit=control BUTTON
    window=hmain
    position=145,366,125,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  redraw=1; answermode=AWM_HV
  while 1 do                           // Wait till user closes the window
    if redraw!=0 then
      if ($int4($EXTLAY+496) & HCM_HVTYPE)==HCM_HV500 then
        volt=Max(10,Min(500,volt))
      else
        volt=Max(20,Min(1000,volt))
      endif
      cmax=Max(100,Min(30000,cmax))
      ttime=Max(1,Min(60000,ttime))
      acc=Max(1,Min(20,acc))
      rmax=Max(10,Min(200000,rmax))
      imax=Max(1,Min(10,imax))
      vrise=Max(1,Min(1000,vrise))
      lowr=Max(0,Min(200,lowr))
      change hvolt text=format("%i",volt)
      change htime text=format("%i",ttime)
      if newsoft then
        change hrmax text=format("%i",rmax)
        change hitst select=(imax==10?1:0)
        change hrise text=format("%i",vrise)
        change hlowr text=format("%i",lowr)
      else
        change haccu text=format("%i",acc)
        change hcapa text=format("%i",cmax)
        if $GLOBAL.a5!=0 then
          rise=Max(0,Min(10000,rise))
          change hrise text=format("%g",(rise==0?0.5:rise))
        else
          rise=Max(1,Min(200,rise))
          change hrise text=format("%i",rise)
        endif
      endif
      redraw=0
    endif
    Text(hvolt,s); volt=0; sscanf(s,"%i",&volt)
    Text(htime,s); ttime=0; sscanf(s,"%i",&ttime)
    if newsoft then
      Text(hrmax,s); rmax=0; sscanf(s,"%i",&rmax)
      imax=(Status(hitst)==0?1:10)
      Text(hrise,s); vrise=0; sscanf(s,"%i",&vrise)
      Text(hlowr,s); lowr=0; sscanf(s,"%i",&lowr)
    else
      Text(haccu,s); acc=0; sscanf(s,"%i",&acc)
      Text(hcapa,s); cmax=0; sscanf(s,"%i",&cmax)
      Text(hrise,s); rise=0; sscanf(s,"%i",&rise)
    endif
    if Pressed(hvolt) || Pressed(hvscr) then
      volt=volt+Status(hvscr)*10
      change hvscr select=0
      redraw=1
    else if Pressed(htime) || Pressed(htscr) then
      ttime=ttime+Status(htscr)*                                               \
        (ttime>=50?(ttime>=500?(ttime>=5000?500:50):5):1)
      change htscr select=0
      redraw=1
    endif
    if newsoft then
      if Pressed(hrmax) || Pressed(hxscr) then
        if rmax>=30000 then
          rmax=rmax+Status(hxscr)*10000
        else if rmax>=3000 then
          rmax=rmax+Status(hxscr)*1000
        else if rmax>=300 then
          rmax=rmax+Status(hxscr)*100
        else
          rmax=rmax+Status(hxscr)*10
        endif
        change hxscr select=0
        redraw=1
      else if Pressed(hrise) || Pressed(hrscr) then
        if vrise>=300 then
          vrise=vrise+Status(hrscr)*100
        else if vrise>=30 then
          vrise=vrise+Status(hrscr)*10
        else
          vrise=vrise+Status(hrscr)
        endif
        change hrscr select=0
        redraw=1
      else if Pressed(hlowr) || Pressed(hlscr) then
        lowr=lowr+Status(hlscr)
        change hlscr select=0
        redraw=1
      endif
    else
      if Pressed(haccu) || Pressed(hascr) then
        acc=acc+Status(hascr)
        change hascr select=0
        redraw=1
      else if Pressed(hcapa) || Pressed(hcscr) then
        cmax=cmax+Status(hcscr)*(cmax>=2000?1000:100)
        change hcscr select=0
        redraw=1
      else if Pressed(hrise) || Pressed(hrscr) then
        if rise>=3000 then
          rise=rise+Status(hrscr)*1000
        else if rise>=300 then
          rise=rise+Status(hrscr)*100
        else if rise>=30 then
          rise=rise+Status(hrscr)*10
        else
          rise=rise+Status(hrscr)
        endif
        change hrscr select=0
        redraw=1
      endif
    endif
    if Pressed(hfixt) then
      if Status(hfixt) then
        hvmode=hvmode|0x0004
      else
        hvmode=hvmode & 0xFFFB
      endif
    else if Pressed(hunip) then
      if Status(hunip) then
        hvmode=hvmode|0x0008
      else
        hvmode=hvmode & 0xFFF7
      endif
    else if Pressed(hchgp) then
      if Status(hchgp) then
        hvmode=hvmode|0x0020
      else
        hvmode=hvmode & 0xFFDF
      endif
    endif
    if Pressed(hinit) then
      if newsoft then
        s[0]=S_HVINIT                  // S_HVINIT
        $uint2(s+1)=volt               // Test voltage
        $uint2(s+5)=imax*1000          // Test current, uA
        if rmax<=60000 then
          $uint2(s+3)=hvmode           // Mode of measurements
          $uint2(s+7)=rmax             // Max resistance, MOhm
        else
          $uint2(s+3)=hvmode|0x0010    // Mode of measurements
          $uint2(s+7)=rmax/1000        // Max resistance, GOhm
        endif
        $uint4(s+9)=ttime              // Min time under full voltage, ms
        $uint4(s+13)=vrise*1000        // Rising speed, V/s
        $uint2(s+17)=0                 // Head initialization time, ms
        $uint2(s+19)=lowr              // R limit for low voltage
        $uint2(s+21)=0                 // Reserved
        $uint4(s+23)=0                 // Reserved
        $uint4(s+27)=0                 // Reserved
        SYS.Send(31,s,0)
      else
        s[0]=S_HVINIT                  // S_HVINIT
        $uint2(s+1)=volt               // Test voltage
        $uint2(s+3)=cmax               // Max capacity between nets
        $uint2(s+5)=acc*10             // Requested accuracy, promille
        $uint2(s+7)=ttime              // Min time under full voltage, ms
        $uint2(s+9)=rise               // Min voltage rise factor, ms/100V
        if Status(hextr)==0 || $GLOBAL.a5==0 then
          SYS.Send(11,s,0)
        else
          $uint2(s+11)=0xFFFF
          $uint2(s+13)=0
          SYS.Send(15,s,0)
        endif
      endif
      redraw=1
    else if Pressed(hexit) then
      break
    endif
    wait
  enddo
  setini("Debug","HVinit","%i,%i,%i,%i,%i,%i,%i,%i,%i,%i",                     \
    volt,acc,cmax,ttime,rise,rmax,imax,vrise,lowr,hvmode)
  destroy hmain
end

function int Rinit()
  handle hmain,hinit,hexit
  handle hvolt,hvscr
  int volt,redraw
  char s[64]
  hmain=control WINDOW
    window=NULL
    position=10,10,250,180
    name="R初始化"
    help=" "
    bkcolor=WHITEBLUE
    size=256
  endc
  draw window=hmain color=BLUE font=INFOFONT
  draw at 10,31 text="Cond voltage, V:"
  hvolt=control EDIT
    window=hmain
    position=149,10,70,25
    help="加到网络的电压"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hvscr=control VSCROLL
    window=hmain
    position=219,10,21,25
    help="按下更改测试电压"
    limits=1,-1
  endc
  hansw=control LIST
    window=hmain
    position=10,43,230,102
    help="最后几个答案"
    mode=M_VSCROLL
    size=4096
  endc
  hinit=control BUTTON
    window=hmain
    position=10,152,110,22
    name="初始化"
    help="按下可初始化电阻测量"
  endc
  hexit=control BUTTON
    window=hmain
    position=130,152,110,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  volt=10;                             // Defaults
  getini("Debug","Rinit","%i",&volt)
  redraw=1; answermode=AWM_RINIT
  while 1 do                           // Wait till user closes the window
    if redraw!=0 then
      if ($int4($EXTLAY+496) & HCM_HVTYPE)==HCM_HV500 then
        volt=Max(10,Min(500,volt))
      else
        volt=Max(20,Min(1000,volt))
      endif
      change hvolt text=format("%i",volt)
      redraw=0
    endif
    Text(hvolt,s); volt=0; sscanf(s,"%i",&volt)
    if Pressed(hvolt) || Pressed(hvscr) then
      volt=volt+Status(hvscr)*10
      change hvscr select=0
      redraw=1
    else if Pressed(hinit) then
      s[0]=S_RINIT                     // S_RINIT
      $uint2(s+1)=volt                 // Test voltage
      $uint2(s+3)=0                    // Reserved for the future
      $uint2(s+5)=0                    // Reserved for the future
      $uint2(s+7)=0                    // Reserved for the future
      $uint2(s+9)=0                    // Reserved for the future
      SYS.Send(11,s,0)
      redraw=1
    else if Pressed(hexit) then
      break
    endif
    wait
  enddo
  setini("Debug","Rinit","%i",volt)
  destroy hmain
end

function int Msdinit()
  handle hmain,hinit,hexit
  handle hvolt,hvscr
  int volt,redraw
  char s[64]
  hmain=control WINDOW
    window=NULL
    position=10,10,250,180
    name="微短探测自检"
    help=" "
    bkcolor=WHITEBLUE
    size=256
  endc
  draw window=hmain color=BLUE font=INFOFONT
  draw at 10,31 text="微短探测电压, V:"
  hvolt=control EDIT
    window=hmain
    position=149,10,70,25
    help="加到网络的电压"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hvscr=control VSCROLL
    window=hmain
    position=219,10,21,25
    help="按下更改测试电压"
    limits=1,-1
  endc
  hansw=control LIST
    window=hmain
    position=10,43,230,102
    help="最后几个答案"
    mode=M_VSCROLL
    size=4096
  endc
  hinit=control BUTTON
    window=hmain
    position=10,152,110,22
    name="初始化"
    help="初始化微短探测测量"
  endc
  hexit=control BUTTON
    window=hmain
    position=130,152,110,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  volt=250                             // Defaults
  getini("Debug","Msdinit","%i",&volt)
  redraw=1; answermode=AWM_MSDINIT
  while 1 do                           // Wait till user closes the window
    if redraw!=0 then
      volt=Max(10,Min(500,volt))
      change hvolt text=format("%i",volt)
      redraw=0
    endif
    Text(hvolt,s); volt=0; sscanf(s,"%i",&volt)
    if Pressed(hvolt) || Pressed(hvscr) then
      volt=volt+Status(hvscr)*10
      change hvscr select=0
      redraw=1
    else if Pressed(hinit) then
      s[0]=S_CRTINIT                   // S_CRTINIT
      $uint2(s+1)=volt                 // Test voltage
      $uint2(s+3)=0                    // Reserved for the future
      $uint2(s+5)=0                    // Reserved for the future
      $uint2(s+7)=0                    // Reserved for the future
      $uint2(s+9)=0                    // Reserved for the future
      SYS.Send(11,s,0)
      redraw=1
    else if Pressed(hexit) then
      break
    endif
    wait
  enddo
  setini("Debug","Msdinit","%i",volt)
  destroy hmain
end

function int Exactrinit()
  handle hmain,hinit,hexit
  handle hpmax,hpscr,himax,hiscr,hfixi,hhire
  char s[64]
  float pow[9] = { 0.1, 0.3, 1.0, 3.0, 10.0, 30.0, 100.0, 300.0, 0.0 }
  float cur[9] = { 0.01, 0.03, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0, 0.0 }
  int i,redraw
  float p,c
  hmain=control WINDOW
    window=NULL
    position=10,10,230,250
    name="精密电阻自检"
    help=" "
    bkcolor=WHITEBLUE
    size=128
  endc
  draw window=hmain font=INFOFONT color=BLUE
  draw at 10,31 text="最大功率, mW:"
  draw at 10,61 text="最大电流, mA:"
  hpmax=control EDIT
    window=hmain
    position=129,10,70,25
    help="最大允许功耗，mW"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hpscr=control VSCROLL
    window=hmain
    position=199,10,21,25
    help="按下可更改允许的功率"
    limits=1,-1
  endc
  himax=control EDIT
    window=hmain
    position=129,40,70,25
    help="最大允许电流，毫安"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hiscr=control VSCROLL
    window=hmain
    position=199,40,21,25
    help="按下可更改允许电流"
    limits=1,-1
  endc
  hfixi=control CUSTOMBOX
    window=hmain
    position=10,70,210,25
    name="特殊电流测试"
    help="仅用于校准！"
    color=BLUE
    bkcolor=WHITE
    font=INFOFONT
  endc
  hhire=control CUSTOMBOX
    window=hmain
    position=10,100,210,25
    name="扩展到20G Ohm"
    help="扩大范围到20G欧姆"
    color=BLUE
    bkcolor=WHITE
    font=INFOFONT
  endc
  hansw=control LIST
    window=hmain
    position=10,133,210,82
    help="最后几个答案"
    mode=M_VSCROLL
    size=4096
  endc
  hinit=control BUTTON
    window=hmain
    position=10,222,100,22
    name="初始化"
    help="初始化精确电阻测量"
  endc
  hexit=control BUTTON
    window=hmain
    position=120,222,100,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  p=0.0; c=0.0;
  getini("Debug","ExactR","%g,%g",&p,&c)
  redraw=1; answermode=AWM_EXACTR
  while 1 do                           // Wait till user closes the window
    if redraw!=0 then
      p=Max(0.0,Min(300.0,p))
      c=Max(0.0,Min(30.0,c))
      if p==0.0 then
        change hpmax text="不限."
      else
        change hpmax text=format("%g",p)
      endif
      if c==0.0 then
        change himax text="不限."
      else
        change himax text=format("%g",c)
      endif
      redraw=0
    endif
    Text(hpmax,s); p=0; sscanf(s,"%g",&p)
    Text(himax,s); c=0; sscanf(s,"%g",&c)
    p=Max(0.0,Min(300.0,p))
    c=Max(0.0,Min(30.0,c))
    if Pressed(hpmax) then
      redraw=1
    else if Pressed(hpscr) then
      if Status(hpscr)>0 then
        for i=0,i<8,i++
          if pow[i]>=p break
        enddo
        if p==0.0 i=8
        if i<8 && pow[i]<p+0.0001 i++
      else
        for i=7,i>0,i--
          if pow[i]<=p break
        enddo
        if p==0.0 i=8
        if i>0 && pow[i]>p-0.0001 i--
      endif
      p=pow[i]
      redraw=1
      change hpscr select=0
    else if Pressed(himax) then
      redraw=1
    else if Pressed(hiscr) then
      if Status(hiscr)>0 then
        for i=0,i<8,i++
          if cur[i]>=c break
        enddo
        if c==0.0 i=8
        if i<8 && cur[i]<c+0.0001 i++
      else
        for i=7,i>0,i--
          if cur[i]<=c break
        enddo
        if c==0.0 i=8
        if i>0 && cur[i]>c-0.0001 i--
      endif
      c=cur[i]
      redraw=1
      change hiscr select=0
    else if Pressed(hinit) then
      s[0]=S_EXACTINIT
      $uint2(s+1)=p*100                // Max allowed power
      $uint2(s+3)=c*1000               // Max allowed current
      $uint2(s+5)=0                    // Must be zero
      $uint2(s+7)=Status(hfixi)+Status(hhire)*2       
      SYS.Send(9,s,0)
      redraw=1
    else if Pressed(hexit) then
      break
    endif
    wait
  enddo
  setini("Debug","ExactR","%g,%g",p,c)
  destroy hmain
end

function int Lainit()
  int n,y,defect,threshold,nretest,duration,wire,findex,redraw
  float imax
  char s[64]
  handle hmain,hinit,hexit,hbase,hline,himax,hiscr,hmode
  handle hcald,hcscr,htmax,htscr,hgood,hgscr,hnret,hnscr
  handle hwire
  hmain=control WINDOW
    window=NULL
    position=10,10,250,280
    name="潜在开路测试自检"
    help=" "
    bkcolor=WHITEBLUE
    size=256
  endc
  draw window=hmain color=BLUE font=INFOFONT
  draw at 10,31 text="峰值电流:"
  himax=control EDIT
    window=hmain
    position=149,10,70,25
    help="最大电流测试"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hiscr=control VSCROLL
    window=hmain
    position=219,10,21,25
    help="按下可更改测试电流"
    limits=1,-1
  endc
  draw at 10,61 text="测试类型&频率:"
  hmode=control COMBOLIST
    window=hmain
    position=149,39,91,250
    help="频率模式"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  add hmode text="默认"
  add hmode text="Hi-pass"
  add hmode text="1k soft"
  add hmode text="2k soft"
  add hmode text="4k soft"
  add hmode text="Pulse L"
  add hmode text="Pulse S"
  change hmode select=0
  if $GLOBAL.a5==0 then
    draw at 10,91 text="Calibration defect:"
    hcald=control EDIT
      window=hmain
      position=149,70,70,25
      help="参考缺陷值"
      bkcolor=WHITE
      font=MEDIUMFONT
    endc
    hcscr=control VSCROLL
      window=hmain
      position=219,70,21,25
      help="按下可更改缺陷值"
      limits=1,-1
    endc
    htmax=NULL
    htscr=NULL
  else
    hcald=NULL
    hcscr=NULL
    draw at 10,91 text="测试时间, ms:"
    htmax=control EDIT
      window=hmain
      position=149,70,70,25
      help="最小测试时间，毫秒"
      bkcolor=WHITE
      font=MEDIUMFONT
    endc
    htscr=control VSCROLL
      window=hmain
      position=219,70,21,25
      help="按下可更改测试时间"
      limits=1,-1
    endc
  endif
  draw at 10,121 text="良品阈值:"
  hgood=control EDIT
    window=hmain
    position=149,100,70,25
    help="自动测试阈值，LA单位"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hgscr=control VSCROLL
    window=hmain
    position=219,100,21,25
    help="按下可更改阈值"
    limits=1,-1
  endc
  draw at 10,151 text="最大重测次数:"
  hnret=control EDIT
    window=hmain
    position=149,130,70,25
    help="如果超过阈值，则重新测试"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hnscr=control VSCROLL
    window=hmain
    position=219,130,21,25
    help="按下可更改重新测试的次数"
    limits=1,-1
  endc
  if $GLOBAL.a5!=0 then
    draw at 10,181 text="线宽, um:"
    hwire=control COMBOLIST
      window=hmain
      position=149,160,91,200
      help="输入PCB上细线的典型宽度"
      font=MEDIUMFONT
    endc
    add hwire text="500+"
    add hwire text="250"
    add hwire text="100"
    add hwire text="50"
    y=193
  else
    hwire=NULL
    y=163
  endif
  if $GLOBAL.a5==0 then
    hbase=NULL; hline=NULL
  else
    draw at 10,y+15 text="用外部探针校验:"
    change hmain position=*,*,*,y+162
    y=y+18
    hbase=control BUTTON
      window=hmain
      position=10,y,110,22
      name="置零"
      help="校准零点偏移"
      color=BLUE
      bkcolor=LIGHTGRAY
      font=INFOFONT
    endc
    hline=control BUTTON
      window=hmain
      position=130,y,110,22
      name="置线"
      help="校准良好线路"
      color=BLUE
      bkcolor=LIGHTGRAY
      font=INFOFONT
    endc
    y=y+28
  endif
  hansw=control LIST
    window=hmain
    position=10,y,230,82
    help="最后几个答案"
    mode=M_VSCROLL
    size=4096
  endc
  y=y+88
  hinit=control BUTTON
    window=hmain
    position=10,y,110,22
    name="初始化"
    help="按下初始化LA测试"
  endc
  hexit=control BUTTON
    window=hmain
    position=130,y,110,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  defect=0; threshold=200; nretest=1   // Defaults
  imax=1.5
  duration=100
  findex=0
  wire=0
  getini("Debug","Latent Opens","%i,%i,%i,%f,%i,%i,%i",                        \
    &defect,&threshold,&nretest,&imax,&duration,&findex,&wire)
  if hwire!=NULL then
    change hwire select=wire
  endif
  redraw=1; answermode=AWM_LAINIT
  while 1 do                           // Wait till user closes the window
    if redraw!=0 then
      if imax<0.5 then
        imax=0.0
        change himax text="No limit"
      else
        imax=Min(2.0,imax)
        change himax text=format("%.2f",imax)
      endif
      findex=Max(0,Min(findex,6))
      change hmode select=findex
      defect=Max(0,Min(1000,defect))
      if hcald!=NULL then
        if defect==0 then
          change hcald text="默认"
        else
          change hcald text=format("%i",defect)
        endif
      endif
      duration=Max(0,Min(400,duration))
      if htmax!=NULL then
        if duration==0 then
          change htmax text="默认"
        else
          change htmax text=format("%i",duration)
        endif
      endif
      threshold=Max(0,Min(5000,threshold))
      if threshold==0 then
        change hgood text="None"
      else
        change hgood text=format("%i",threshold)
      endif
      nretest=Max(0,Min(7,nretest))
      change hnret text=format("%i",nretest)
      redraw=0
    endif
    Text(himax,s); imax=0.00; sscanf(s,"%f",&imax)
    if hcald!=NULL then
      Text(hcald,s); defect=0; sscanf(s,"%i",&defect)
    endif
    if htmax!=NULL then
      Text(htmax,s); duration=0; sscanf(s,"%i",&duration)
    endif
    Text(hgood,s); threshold=0; sscanf(s,"%i",&threshold)
    Text(hnret,s); nretest=0; sscanf(s,"%i",&nretest)
    if Pressed(himax) || Pressed(hiscr) then
      imax=imax+Status(hiscr)*0.1
      change hiscr select=0
      redraw=1
    else if Pressed(hmode) then
      findex=Status(hmode)
      redraw=1
    else if hcald!=NULL && (Pressed(hcald) || Pressed(hcscr)) then
      defect=defect+Status(hcscr)
      change hcscr select=0
      redraw=1
    else if htmax!=NULL && (Pressed(htmax) || Pressed(htscr)) then
      duration=duration+Status(htscr)*50
      change htscr select=0
      redraw=1
    else if Pressed(hgood) || Pressed(hgscr) then
      threshold=threshold+Status(hgscr)*5
      change hgscr select=0
      redraw=1
    else if Pressed(hnret) || Pressed(hnscr) then
      nretest=nretest+Status(hnscr)
      change hnscr select=0
      redraw=1
    else if Pressed(hwire) then
      wire=Status(hwire)
    else if Pressed(hinit) then
      s[0]=S_LAINIT                    // S_LAINIT
      $uint2(s+1)=defect*10            // Value of calibration defect
      if $GLOBAL.a5==0 then
        wire=0
        $uint2(s+3)=0                  // Delay
        $uint2(s+5)=threshold          // Good threshold
        s[7]=imax*50.0                 // Max current
        s[8]=nretest<<4                // Test mode
        n=9
      else
        $uint2(s+3)=duration           // Test duration, ms
        $uint2(s+5)=threshold          // Good threshold
        s[7]=imax*50.0                 // Max current
        if findex>=1 then              // Test mode
          s[8]=(findex+1)*2 | (nretest<<4)
        else
          s[8]=nretest<<4
        endif
        if wire>0 && wire<=3 then
          if wire==1 then              // Extended initialization
            $uint2(s+9)=100            // 50000.0/(width,um)-100.0
          else if wire==2 then
            $uint2(s+9)=400
          else
            $uint2(s+9)=900
          endif
          $uint2(s+11)=0
          $uint4(s+13)=0
          n=17
        else
          n=9
        endif
      endif
      SYS.Send(n,s,0)
      redraw=1
    else if Pressed(hbase) then
      n=SERV.Parsecmd("M LAMBASE",s)
      if n>0 SYS.Send(n,s,0)
    else if Pressed(hline) then
      n=SERV.Parsecmd("M LAMCAL",s)
      if n>0 SYS.Send(n,s,0)
    else if Pressed(hexit) then
      break
    endif
    wait
  enddo
  setini("Debug","Latent Opens","%i,%i,%i,%f,%i,%i,%i",                        \
    defect,threshold,nretest,imax,duration,findex,wire)
  destroy hmain
end

function int Rlinit()
  int mode,freq,u,dir,step,redraw
  char s[64]
  handle hmain,hmode,hacc,hfreq,hfscr,hvolt,hvscr,hinit,hexit
  mode=0; freq=0; u=0
  getini("Debug","LR init","%i,%i,%i",&mode,&freq,&u)
  hmain=control WINDOW
    window=NULL
    position=10,10,250,280
    name="电感自检"
    help=" "
    bkcolor=WHITEBLUE
    size=256
  endc
  draw window=hmain color=BLUE font=INFOFONT
  draw at 10,31 text="模式:"
  hmode=control COMBOLIST
    window=hmain
    position=129,10,111,150
    help="电感测试模式"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  add hmode text="自动"
  add hmode text="内部"
  add hmode text="外部"
  draw at 10,61 text="速度:"
  hacc=control COMBOLIST
    window=hmain
    position=129,40,111,150
    help="电感测试速度"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  add hacc text="默认"
  add hacc text="Fast"
  add hacc text="Medium"
  add hacc text="Slow"
  draw at 10,91 text="频率, Hz:"
  hfreq=control EDIT
    window=hmain
    position=129,70,90,25
    help="测试频率，Hz"
    mode=M_NOEDIT
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hfscr=control VSCROLL
    window=hmain
    position=219,70,21,25
    help="按下可更改测试频率"
    limits=1,-1
  endc
  draw at 10,121 text="振幅, V:"
  hvolt=control EDIT
    window=hmain
    position=129,100,90,25
    help="测试电压，伏特"
    mode=M_NOEDIT
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hvscr=control VSCROLL
    window=hmain
    position=219,100,21,25
    help="按下更改测试电压"
    limits=1,-1
  endc
  hansw=control LIST
    window=hmain
    position=10,135,230,102
    help="最后几个答案"
    mode=M_VSCROLL
    size=4096
  endc
  hinit=control BUTTON
    window=hmain
    position=10,250,110,22
    name="初始化"
    help="按下可初始化电感测量"
  endc
  hexit=control BUTTON
    window=hmain
    position=130,250,110,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  answermode=AWM_RLINIT
  redraw=1
  while 1 do                           // Wait till user closes the window
    if redraw then
      redraw=0
      if (mode & 0xC000)==0x4000 then
        change hmode select=1
      else if (mode & 0xC000)==0x8000 then
        change hmode select=2
      else
        change hmode select=0
      endif
      change hacc select=mode & 0x0003
      if (mode & 0xC000)==0x8000 then
        enable hacc
        enable hfreq
        enable hfscr
        enable hvolt
        enable hvscr
      else
        disable hacc
        disable hfreq
        disable hfscr
        disable hvolt
        disable hvscr
      endif
      if (mode & 0xC000)!=0x8000 || freq==0 then
        change hfreq text="默认"
      else
        change hfreq text=format("%i",freq)
      endif
      if (mode & 0xC000)!=0x8000 || u==0 then
        change hvolt text="默认"
      else
        change hvolt text=format("%.3f",u/1000.0)
      endif
    endif
    if Pressed(hmode) then
      mode=(mode & 0x3FFF)|(Status(hmode)<<14)
      redraw=1
    else if Pressed(hacc) then
      mode=(mode & 0xFFFC)|Status(hacc)
      redraw=1
    else if Pressed(hfscr) then
      dir=Status(hfscr)
      if freq<100 then step=5
      else if freq<200 then step=10
      else if freq<500 then step=20
      else if freq<1000 then step=50
      else if freq<2000 then step=100
      else if freq<5000 then step=200
      else if freq<10000 then step=500
      else if freq<20000 then step=1000
      else if freq<50000 then step=2000
      else if freq<100000 then step=5000
      else step=10000; endif
      if freq<=20 && dir<0 then
        freq=0
      else
        freq=Max(20,Min(freq+step*dir,200000))
      endif
      change hfscr select=0
      redraw=1
    else if Pressed(hvscr) then
      u=Max(0,Min(u+Status(hvscr)*100,1500))
      change hvscr select=0
      redraw=1
    else if Pressed(hinit) then
      s[0]=S_RLINIT                    // S_RLINIT
      $uint2(s+1)=mode
      $uint4(s+3)=freq
      $uint4(s+7)=u
      $uint4(s+11)=0
      $uint4(s+15)=0
      $uint4(s+19)=0
      $uint4(s+23)=0
      SYS.Send(27,s,0)
      redraw=1
    else if Pressed(hexit) then
      break
    endif
    wait
  enddo
  setini("Debug","LR init","%i,%i,%i",mode,freq,u)
  destroy hmain
end

function int FCinit()
  handle hmain,hinit,hexit,hcfreq,hcvolt,hcvscr,hcoffs,hcoscr
  handle hffreq,hfvolt,hfvscr,hshort,hsscr,hextr,huseac
  int d,cfreq,ffreq,short,extr,redraw
  float cvolt,fvolt,coffs
  char s[64]
  ffreq=0; fvolt=0.0; cfreq=0; cvolt=0.0; coffs=0.0
  short=0
  getini("Debug","FCinit","%i,%g,%i,%g,%i,%i,%g",                              \
    &cfreq,&cvolt,&ffreq,&fvolt,&short,&extr,&coffs)
  hmain=control WINDOW
    window=NULL
    position=10,10,250,357
    name="电场和电容参数"
    help=" "
    bkcolor=WHITEBLUE
    size=256
  endc
  draw window=hmain color=BLUE font=INFOFONT
  draw at 10,31 text="电容频率, Hz:"
  hcfreq=control COMBOLIST
    window=hmain
    position=154,10,86,200
    help="电容频率,Herz"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  add hcfreq text="布局"
  add hcfreq text="1000"
  add hcfreq text="2000"
  add hcfreq text="4000"
  add hcfreq text="8000"
  add hcfreq text="16000"
  add hcfreq text="32000"
  add hcfreq text="64000"
  draw at 10,61 text="电压电容, V:"
  hcvolt=control EDIT
    window=hmain
    position=154,41,65,25
    help="电容峰值电压，V"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hcvscr=control VSCROLL
    window=hmain
    position=219,41,21,25
    help="按下可更改电容电压"
    limits=1,-1
  endc
  draw at 10,91 text="电容补偿, V:"
  hcoffs=control EDIT
    window=hmain
    position=154,71,65,25
    help="电容电压补偿，V"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hcoscr=control VSCROLL
    window=hmain
    position=219,71,21,25
    help="按下可更改电容补偿"
    limits=1,-1
  endc
  draw at 10,121 text="电场频率, Hz:"
  hffreq=control COMBOLIST
    window=hmain
    position=154,100,86,200
    help="电场频率, Herz"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  add hffreq text="布局"
  add hffreq text="1000"
  add hffreq text="2000"
  add hffreq text="4000"
  add hffreq text="8000"
  add hffreq text="16000"
  add hffreq text="32000"
  add hffreq text="64000"
  draw at 10,151 text="电场电压, V:"
  hfvolt=control EDIT
    window=hmain
    position=154,131,65,25
    help="电场测试的峰值电压，V"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hfvscr=control VSCROLL
    window=hmain
    position=219,131,21,25
    help="按下可更改电场电压"
    limits=1,-1
  endc
  draw at 10,181 text="天线短路电阻, MOhm:"
  hshort=control EDIT
    window=hmain
    position=154,161,65,25
    help="对天线短路的阀值，MOhm"
    bkcolor=WHITE
    font=MEDIUMFONT
  endc
  hsscr=control VSCROLL
    window=hmain
    position=219,161,21,25
    help="按下可更改短阈值"
    limits=1,-1
  endc
  hextr=control CHECKBOX
    window=hmain
    position=10,192,180,22
    name="扩展电压范围"
    help="允许微调电容电压"
    font=INFOFONT
    mode=((extr & 1)!=0?M_CHECKED:0)
  endc
  huseac=control CHECKBOX
    window=hmain
    position=10,215,180,22
    name="大电容用交流"
    help="交流电桥代替C-DC"
    font=INFOFONT
    mode=((extr & 2)!=0?M_CHECKED:0)
  endc
  hansw=control LIST
    window=hmain
    position=10,243,230,82
    help="最后几个答案"
    mode=M_VSCROLL
    size=4096
  endc
  hinit=control BUTTON
    window=hmain
    position=10,329,110,22
    name="初始化"
    help="按下可设置电场和电容"
  endc
  hexit=control BUTTON
    window=hmain
    position=130,329,110,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  redraw=1; answermode=AWM_FCINIT
  while 1 do                           // Wait till user closes the window
    if redraw!=0 then
      cfreq=Max(0,Min(cfreq,7))
      change hcfreq select=cfreq
      if cvolt<((extr & 1)?0.1:4.0) then
        cvolt=0.0
        change hcvolt text="默认"
      else
        change hcvolt text=format(" %.1f",cvolt)
      endif
      if (extr & 1)==0 then
        change hcoffs text=""
        change hcoffs bkcolor=WHITEBLUE
        disable hcoffs
        disable hcoscr
        coffs=0.0
      else
        enable hcoffs
        enable hcoscr
        change hcoffs bkcolor=WHITE
        change hcoffs text=format(" %.1f",coffs)
      endif
      ffreq=Max(0,Min(ffreq,7))
      change hffreq select=ffreq
      if fvolt<((extr & 1)?0.1:0.5) then
        fvolt=0.0
        change hfvolt text="默认"
      else
        change hfvolt text=format(" %.1f",fvolt)
      endif
      if short<((extr & 1)?1:10) then
        change hshort text="默认"
      else
        change hshort text=format(" %i",short)
      endif
      redraw=0
    endif
    if Pressed(hcfreq) then
      cfreq=Status(hcfreq)
    else if Pressed(hcvolt) || Pressed(hcvscr) then
      Text(hcvolt,s); cvolt=0.0; sscanf(s,"%g",&cvolt)
      d=Status(hcvscr); change hcvscr select=0
      cvolt=cvolt+d*((extr & 1)?0.1:0.5)
      if cvolt<((extr & 1)?0.1:4.0) then
        cvolt=(d>0?((extr & 1)?0.1:4.0):0.0)
      else if cvolt>10.0 then
        cvolt=10.0
      endif
      redraw=1
    else if Pressed(hcoffs) || Pressed(hcoscr) then
      Text(hcoffs,s); coffs=0.0; sscanf(s,"%g",&coffs)
      d=Status(hcoscr); change hcoscr select=0
      coffs=coffs+d*0.1
      if coffs<(-10.0) then
        coffs=-10.0
      else if coffs>10.0 then
        coffs=10.0
      endif
      redraw=1
    else if Pressed(hffreq) then
      ffreq=Status(hffreq)
    else if Pressed(hfvolt) || Pressed(hfvscr) then
      Text(hfvolt,s); fvolt=0.0; sscanf(s,"%g",&fvolt)
      d=Status(hfvscr); change hfvscr select=0
      fvolt=fvolt+d*((extr & 1)?0.1:0.5)
      if fvolt<((extr & 1)?0.1:0.5) then
        fvolt=(d>0?((extr & 1)?0.1:0.5):0.0)
      else if fvolt>10.0 then
        fvolt=10.0
      endif
      redraw=1
    else if Pressed(hshort) || Pressed(hsscr) then
      Text(hshort,s); short=0; sscanf(s,"%i",&short)
      d=Status(hsscr); change hsscr select=0
      short=short+d
      if short<((extr & 1)?1:10) then
        short=(d>0?((extr & 1)?1:10):0)
      else if short>100 then
        short=100
      endif
      redraw=1
    else if Pressed(hextr) then
      extr=(extr & 0xFFFFFFFE) | (Status(hextr)?0x00000001:0x00000000)
      if (extr & 1)==0 cvolt=0.0
      redraw=1
    else if Pressed(huseac) then
      extr=(extr & 0xFFFFFFFD) | (Status(huseac)?0x00000002:0x00000000)
      redraw=1
    else if Pressed(hinit) then
      s[0]=S_DEBUG
      s[1]=0x0E                        // Set field and capacity parameters
      if short<((extr & 1)?1:10) short=0
      $float4(s+2)=short*1.0e6
      if      cfreq==1 then $int2(s+6)=1000;
      else if cfreq==2 then $int2(s+6)=2000;
      else if cfreq==3 then $int2(s+6)=4000;
      else if cfreq==4 then $int2(s+6)=8000;
      else if cfreq==5 then $int2(s+6)=16000;
      else if cfreq==6 then $int2(s+6)=32000;
      else if cfreq==7 then $int2(s+6)=64000;
      else                  $int2(s+6)=0; endif
      if      ffreq==1 then $int2(s+8)=1000;
      else if ffreq==2 then $int2(s+8)=2000;
      else if ffreq==3 then $int2(s+8)=4000;
      else if ffreq==4 then $int2(s+8)=8000;
      else if ffreq==5 then $int2(s+8)=16000;
      else if ffreq==6 then $int2(s+8)=32000;
      else if ffreq==7 then $int2(s+8)=64000;
      else                  $int2(s+8)=0; endif
      if cvolt<((extr & 1)?0.1:4.0) cvolt=0.0
      if (extr & 1)!=0 && (cvolt<0.5 || cvolt*2.0!=Floor(cvolt*2.0)) then
        $int2(s+10)=-cvolt*1000.0
      else
        $int2(s+10)=cvolt*2.0+0.5
      endif
      if fvolt<((extr & 1)?0.1:0.5) fvolt=0.0
      if (extr & 1)!=0 && (fvolt<0.5 || fvolt*2.0!=Floor(fvolt*2.0)) then
        $int2(s+12)=-fvolt*1000.0
      else
        $int2(s+12)=fvolt*2.0+0.5
      endif
      $int2(s+14)=(extr & 2?0x0001:0x0000)
      $int2(s+16)=coffs*1000.0
      SYS.Send(18,s,0)
      redraw=1
    else if Pressed(hexit) then
      break
    endif
    wait
  enddo
  setini("Debug","FCinit","%i,%g,%i,%g,%i,%i,%g",                              \
    cfreq,cvolt,ffreq,fvolt,short,extr,coffs)
  destroy hmain
end

// Clips x into the range [xmin..xmax] by "mirroring" the coordinate, not very
// effective.
function int Mirror(int x,int xmin,int xmax)
  if xmin>=xmax return xmin
  while 1 do
    if x<xmin then
      x=xmin+(xmin-x)
    else if x>xmax then
      x=xmax-(x-xmax)
    else
      break
    endif
  enddo
  return x
end

function int Randomtest()
  handle hmain,hstrt,hstop,hclea,hexit,hmode
  handle hshut,honly,hrail,hrscr,haccu,hascr
  handle hxdis,hlong,hshrt,hmicr,hfarm,hnear
  handle hxscr,harea,hncal,hgrid,hgsiz,hgscr
  handle hrand,hsoft,hsper,hsscr,hastp,hdlay
  handle hdscr,hfrom,htoto,hvelo,hvscr,hpres
  handle hpscr,hzcoo,hzscr
  int i,k,n,redraw,rail,accuracy,dx,srperiod,timeout
  int treset,makereset,tstart,mode,newlay,totalansw
  int run,v,p,validxy[16],xl[16],yl[16],xr[16],yr[16]
  int area,mi,sh,lo,shlim,lolim,choice,fa,ne,x,y,t
  int xminl,xmaxl,xminr,xmaxr,ymin,ymax,shuttle
  int leftlimit,rightlimit,xoffset
  float grid,z,width
  char s[80]
  stoprequest=0
  hmain=control WINDOW
    window=NULL
    position=10,10,500,408
    name="随机测试"
    help=" "
    bkcolor=WHITECYAN
    size=512
  endc
  draw window=hmain font=INFOFONT
  draw at 11,29 text="模式:"
  hmode=control COMBOLIST
    window=hmain
    position=60,9,100,200
    help="选择测量类型(NT=请勿触摸)"
  endc
  add hmode text="无接触"
  add hmode text="标准R"
  add hmode text="精密R"
  add hmode text="复测"
  add hmode text="LA测试"
  add hmode text="延时3ms"
  add hmode text="NT左"
  add hmode text="NT右"
  draw at 11,59 text="架板框:"
  hshut=control COMBOLIST
    window=hmain
    position=60,39,100,200
    help="选择架板框"
  endc
  add hshut text="默认"
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    add hshut text="Left"
    add hshut text="Right"
    if ($LAY.config & LC_TYPEMASK)!=LC_S3 add hshut text="Both"
  endif
  honly=control CUSTOMBOX
    window=hmain
    position=10,67,91,23
    name="仅用轨道"
    help="限制对指定轨道的随机测试"
    font=INFOFONT
  endc
  hrail=control EDIT
    window=hmain
    position=104,68,36,23
    help="随机测试受限的轨道"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  hrscr=control VSCROLL
    window=hmain
    position=140,68,20,23
    help="更改随机测试受限的轨道"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 11,109 text="移动:"
  hlong=control CUSTOMBOX
    window=hmain
    position=30,110,50,20
    name="长"
    help="检查以允许测试头长距离运动"
    font=INFOFONT
  endc
  hshrt=control CUSTOMBOX
    window=hmain
    position=30,130,50,20
    name="短"
    help="检查以允许测试头短距离运动"
    font=INFOFONT
  endc
  hmicr=control CUSTOMBOX
    window=hmain
    position=30,150,50,20
    name="微"
    help="检查以允许测试头极短距离运动"
    font=INFOFONT
  endc
  hfarm=control CUSTOMBOX
    window=hmain
    position=95,110,53,20
    name="远"
    help="确保两头之间的距离较长"
    font=INFOFONT
  endc
  hnear=control CUSTOMBOX
    window=hmain
    position=95,130,53,20
    name="近"
    help="使测试头保持彼此靠近"
    font=INFOFONT
  endc
  draw at 11,196 text="精度"
  haccu=control EDIT
    window=hmain
    position=69,177,50,23
    help="X-Y定位精度，微米"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  hascr=control VSCROLL
    window=hmain
    position=119,177,20,23
    help="更改X-Y定位精度"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 142,196 text="m"
  draw at 11,226 text="区域:"
  harea=control COMBOLIST
    window=hmain
    position=50,206,110,200
    help="选择接触区域"
  endc
  add harea text="整个轨道"
  add harea text="细线"
  add harea text="1mm线"
  add harea text="5mm线"
  add harea text="10x10mm"
  add harea text="30x30mm"
  add harea text="100x100mm"
  draw at 30,252 text="dX ="
  hxdis=control EDIT
    window=hmain
    position=69,233,50,23
    help="上面选定区域之间的距离"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  hxscr=control VSCROLL
    window=hmain
    position=119,233,20,23
    help="更改区域之间的距离"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 141,252 text="mm"
  hncal=control CUSTOMBOX
    window=hmain
    position=10,257,140,23
    name="测试机未校正"
    help="检查以保持手臂之间的合理距离"
    font=INFOFONT
  endc
  hgrid=control CUSTOMBOX
    window=hmain
    position=10,281,56,23
    name="网格"
    help="选中可以接触指定网格节点中的PCB"
    font=INFOFONT
  endc
  hgsiz=control EDIT
    window=hmain
    position=69,281,50,23
    help="网格点之间的距离，毫米"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  hgscr=control VSCROLL
    window=hmain
    position=119,281,20,23
    help="更改网格大小"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 141,300 text="mm"
  hrand=control CUSTOMBOX
    window=hmain
    position=10,305,140,23
    name="随机顺序"
    help="选中可更改每次按'开始'时的移动顺序"
    font=INFOFONT
  endc
  hsoft=control CUSTOMBOX
    window=hmain
    position=10,329,68,23
    name="重置"
    help="周期性软复位"
    font=INFOFONT
  endc
  hsper=control EDIT
    window=hmain
    position=84,329,46,23
    help="自动软重置的时间(秒)"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  hsscr=control VSCROLL
    window=hmain
    position=130,329,20,23
    help="更改自动软重置的周期"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 155,348 text="s"
  hastp=control CUSTOMBOX
    window=hmain
    position=10,353,60,23
    name="停止"
    help="在指定时间后自动停止测试"
    font=INFOFONT
  endc
  hdlay=control EDIT
    window=hmain
    position=84,353,46,23
    help="超时，秒，自动停止测试"
    font=MEDIUMFONT
    bkcolor=WHITE
  endc
  hdscr=control VSCROLL
    window=hmain
    position=130,353,20,23
    help="更改自动停止超时"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 155,372 text="s"
  hansw=control LIST
    window=hmain
    position=168,8,324,313
    help="这里您可以看到轨道编号和电阻测量结果"
    size=32768
    mode=M_VSCROLL
    font=FIXEDFONT
  endc
  draw color=DARKGRAY at 168,326 to 168,376
  draw color=BLACK at 200,344 text="显示电阻从"
  hfrom=control COMBOLIST
    window=hmain
    position=292,325,87,130
    help="选择最小显示电阻"
    mode=M_VSCROLL|M_SELECTION
  endc
  add hfrom text="0 Ohm"
  add hfrom text="1 Ohm"
  add hfrom text="10 Ohm"
  add hfrom text="1 k"
  add hfrom text="1 M"
  add hfrom text="100 M"
  draw at 385,344 text="到"
  htoto=control COMBOLIST
    window=hmain
    position=405,325,87,130
    help="选择最大显示电阻"
    mode=M_VSCROLL|M_SELECTION
  endc
  add htoto text="1 Ohm"
  add htoto text="10 Ohm"
  add htoto text="1 k"
  add htoto text="1 M"
  add htoto text="100 M"
  add htoto text="100 G"
  draw bkcolor=LIGHTCYAN
  draw at -1,381 fillrect 501,409
  draw at 200,372 text="击测:  V="
  hvelo=control EDIT
    window=hmain
    position=271,353,35,23
    help="指定Z向下行程，毫米每秒"
    bkcolor=WHITE
  endc
  hvscr=control VSCROLL
    window=hmain
    position=306,353,20,23
    help="按下可更改行程"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 330,372 text="P="
  hpres=control EDIT
    window=hmain
    position=349,353,35,23
    help="指定Z压力，克"
    bkcolor=WHITE
  endc
  hpscr=control VSCROLL
    window=hmain
    position=384,353,20,23
    help="按下可更改压力"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 412,372 text="H="
  hzcoo=control EDIT
    window=hmain
    position=432,353,40,23
    help="指定Z向上距离,毫米"
    bkcolor=WHITE
  endc
  hzscr=control VSCROLL
    window=hmain
    position=472,353,20,23
    help="按可更改Z向上距离"
    limits=1,-1
    mode=M_NOTAB
  endc
  hstrt=control BUTTON
    window=hmain
    position=3,384,121,22
    name="开始"
    help="按下可以开始随机测试"
  endc
  hstop=control BUTTON
    window=hmain
    position=127,384,121,22
    name="停止"
    help="按下可以停止随机测试"
  endc
  hclea=control BUTTON
    window=hmain
    position=251,384,122,22
    name="清除"
    help="按下可以清除答案列表"
  endc
  hexit=control BUTTON
    window=hmain
    position=376,384,121,22
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  if hexit==NULL then
    destroy hmain
    lprintf(LIGHTRED,"Random test: Out of window handles")
    return
  endif
  draw show
  i=0x02BC; rail=0; accuracy=100; dx=100
  srperiod=60; timeout=60; grid=1.0
  rmin=0; rmax=5; v=40; p=30; z=10.0; mode=0; area=0
  getini("Debug","Random","%X,%i,%i,%i,%g,%i,%i,%i,%i,%i,%g,%i,%i,%i,%i",      \
    &i,&rail,&accuracy,&dx,&grid,&timeout,&rmin,&rmax,&v,&p,&z,&mode,          \
    &srperiod,&area,&shuttle)
  if mode<0 || mode>7 mode=0
  change hmode select=mode
  if (i & 0x0002) change honly mode=M_CHECKED
  if ((i & 0x0004) || (i & 0x0808)==0) change hlong mode=M_CHECKED
  if (i & 0x0008) change hshrt mode=M_CHECKED
  if (i & 0x0800) change hmicr mode=M_CHECKED
  if ((i & 0x0010) || (i & 0x0020)==0) change hfarm mode=M_CHECKED
  if (i & 0x0020) change hnear mode=M_CHECKED
  if (i & 0x0080) change hncal mode=M_CHECKED
  if (i & 0x0100) change hgrid mode=M_CHECKED
  if (i & 0x0200) change hrand mode=M_CHECKED
  if (i & 0x0400) change hastp mode=M_CHECKED
  if (i & 0x2000) change hsoft mode=M_CHECKED
  change harea select=area
  if shuttle<0 || shuttle>3 || ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
    shuttle=0
  else if ($LAY.config & LC_TYPEMASK)==LC_S3 && shuttle==3 then
    shuttle=0
  endif
  change hshut select=shuttle
  answermode=AWM_RAND
  nansw=0; totalansw=0; redraw=1
  for i=0,i<16,i++
    validxy[i]=0
  enddo
  if $LAY.nfing==0 then
    change hansw color=LIGHTRED
    add hansw text="注意：布局文件不可用!"
  endif
  while 1 do
    if layoutchanged then              // Synchronize with the start of the loop
      newlay=1
      layoutchanged=0
      for i=0,i<16,i++
        validxy[i]=0
      enddo
    endif
    if Pressed(hshut) then
      newlay=1
      shuttle=Status(hshut)
      for i=0,i<16,i++
        validxy[i]=0
      enddo
    endif
    if ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO || shuttle==3 then
      leftlimit=$LAY.leftlimit
      rightlimit=$LAY.rightlimit
      xoffset=$LAY.xoffset
    else if shuttle==2 then
      leftlimit=$LAY.xoffset+$int4($EXT0+578)/2
      rightlimit=$LAY.rightlimit
      xoffset=(leftlimit+rightlimit)/2
    else
      leftlimit=$LAY.leftlimit
      rightlimit=$LAY.xoffset-$int4($EXT0+578)/2
      xoffset=(leftlimit+rightlimit)/2
    endif
    width=(rightlimit-leftlimit)/1000.0
    if redraw then
      if Status(honly)==0 then
        disable(hrail); disable(hrscr)
      else
        enable(hrail); enable(hrscr)
      endif
      if area==0 then
        disable(hxdis); disable(hxscr)
      else
        enable(hxdis); enable(hxscr)
      endif
      if Status(hgrid)==0 then
        disable(hgsiz); disable(hgscr)
      else
        enable(hgsiz); enable(hgscr)
      endif
      if Status(hastp)==0 || run!=0 then
        disable(hdlay); disable(hdscr)
      else
        enable(hdlay); enable(hdscr)
      endif
      if Status(hsoft)==0 || run!=0 then
        disable(hsper); disable(hsscr)
      else
        enable(hsper); enable(hsscr)
      endif
      change hfrom select=rmin
      change htoto select=rmax
      change hrail text=format("%i",rail)
      change haccu text=format("%i",accuracy)
      change hxdis text=format("%i",dx)
      change hgsiz text=format("%g",grid)
      if (run==0 || Status(hsoft)==0) change hsper text=format("%i",srperiod)
      if (run==0 || Status(hastp)==0) change hdlay text=format("%i",timeout)
      change hvelo text=format("%i",v)
      change hpres text=format("%i",p)
      change hzcoo text=format("%.1f",z)
      redraw=0
    endif
    if Pressed(honly) then
      redraw=1
    else if Pressed(hrail) || Pressed(hrscr) || newlay then
      Text(hrail,s); rail=0; sscanf(s,"%i",&rail)
      rail=Max(0,Min($LAY.nfing-1,rail+Status(hrscr)))
      change hrscr select=0
      redraw=1
    else if Pressed(hlong) then
      if (Status(hlong)==0 && Status(hmicr)==0) change hshrt mode=M_CHECKED
    else if Pressed(hshrt) then
      if (Status(hshrt)==0 && Status(hlong)==0) change hmicr mode=M_CHECKED
    else if Pressed(hmicr) then
      if (Status(hmicr)==0 && Status(hshrt)==0) change hlong mode=M_CHECKED
    else if Pressed(hfarm) then
      if Status(hfarm)==0 change hnear mode=M_CHECKED
    else if Pressed(hnear) then
      if Status(hnear)==0 change hfarm mode=M_CHECKED
    else if Pressed(haccu) || Pressed(hascr) then
      Text(haccu,s); accuracy=5; sscanf(s,"%i",&accuracy)
      if ($LAY.config & LC_TYPEMASK)==LC_S1 ||                                 \
        ($LAY.config & LC_TYPEMASK)==LC_S3 then
        accuracy=Max(2,Min(255,accuracy+Status(hascr)*2))
      else
        accuracy=Max(5,Min(255,accuracy+Status(hascr)*5))
      endif
      change hascr select=0
      redraw=1
    else if Pressed(harea) then
      area=Status(harea)
      if area==2 dx=Max(5,Min(dx,width-5))
      if area==3 dx=Max(15,Min(dx,width-15))
      if area==4 dx=Max(30,Min(dx,width-30))
      if area==5 dx=Max(50,Min(dx,width-50))
      if area==6 dx=Max(120,Min(dx,width-120))
      redraw=1
    else if Pressed(hxdis) || Pressed(hxscr) then
      Text(hxdis,s); dx=20; sscanf(s,"%i",&dx)
      dx=dx+Status(hxscr)*10
      i=(rightlimit-leftlimit)/1000-20
      if ($LAY.nfing==0 || i<100) i=100
      if Status(hncal)!=0 then
        dx=Max(30,Min(i,dx))
      else
        dx=Max(0,Min(i,dx))
      endif
      if area==2 dx=Max(5,Min(dx,width-5))
      if area==3 dx=Max(15,Min(dx,width-15))
      if area==4 dx=Max(30,Min(dx,width-30))
      if area==5 dx=Max(50,Min(dx,width-50))
      if area==6 dx=Max(120,Min(dx,width-120))
      change hxscr select=0
      redraw=1
    else if Pressed(hncal) then
      if Status(hncal)!=0 dx=Max(30,dx)
      redraw=1
    else if Pressed(hgrid) then
      redraw=1
    else if Pressed(hgsiz) || Pressed(hgscr) then
      Text(hgsiz,s); sscanf(s,"%f",&grid)
      if Status(hgscr)>0 then
        grid=grid*10.0
      else if Status(hgscr)<0 then
        grid=grid/10.0
      endif
      grid=Max(0.01,Min(10.0,grid))
      change hgscr select=0
      redraw=1
    else if Pressed(hastp) then
      redraw=1
    else if Pressed(hsoft) then
      redraw=1
    else if (Pressed(hsper) || Pressed(hsscr)) & run==0 then
      Text(hsper,s); sscanf(s,"%i",&srperiod)
      srperiod=Max(20,Min(9990,srperiod+Status(hsscr)*(srperiod<200?10:100)))
      change hsscr select=0
      redraw=1
    else if (Pressed(hdlay) || Pressed(hdscr)) & run==0 then
      Text(hdlay,s); sscanf(s,"%i",&timeout)
      timeout=Max(1,Min(9999,timeout+Status(hdscr)*(timeout<200?10:100)))
      change hdscr select=0
      redraw=1
    else if Pressed(hfrom) then
      rmin=Status(hfrom)
      if rmax<rmin then
        rmax=rmin
        redraw=1
      endif
    else if Pressed(htoto) then
      rmax=Status(htoto)
      if rmin>rmax then
        rmin=rmax
        redraw=1
      endif
    else if Pressed(hvelo) || Pressed(hvscr) then
      Text(hvelo,s); v=0; sscanf(s,"%i",&v)
      v=Max(MINV,Min(MAXV,v+Status(hvscr)*VSTEP))
      change hvscr select=0
      redraw=1
    else if Pressed(hpres) || Pressed(hpscr) then
      Text(hpres,s); p=0; sscanf(s,"%i",&p)
      p=Max(MINP,Min(MAXP,p+Status(hpscr)*PSTEP))
      change hpscr select=0
      redraw=1
    else if Pressed(hzcoo) || Pressed(hzscr) then
      Text(hzcoo,s); z=0.0; sscanf(s,"%f",&z)
      z=Max(0.5,Min(99.9,z+Status(hzscr)*(z<3.0?0.5:(z<10.0?1.0:2.0))))
      change hzscr select=0
      redraw=1
    else if Pressed(hstrt) then
      Text(hrail,s); rail=0; sscanf(s,"%i",&rail)
      rail=Max(0,Min($LAY.nfing-1,rail+Status(hrscr)))
      Text(haccu,s); accuracy=5; sscanf(s,"%i",&accuracy)
      accuracy=Max(2,Min(255,accuracy))
      Text(hxdis,s); dx=20; sscanf(s,"%i",&dx)
      i=(rightlimit-leftlimit)/1000-20
      if ($LAY.nfing==0 || i<100) i=100
      if Status(hncal)!=0 then
        dx=Max(30,Min(i,dx))
      else
        dx=Max(0,Min(i,dx))
      endif
      if area==2 dx=Max(5,Min(dx,width-5))
      if area==3 dx=Max(15,Min(dx,width-15))
      if area==4 dx=Max(30,Min(dx,width-30))
      if area==5 dx=Max(50,Min(dx,width-50))
      if area==6 dx=Max(120,Min(dx,width-120))
      Text(hgsiz,s); sscanf(s,"%f",&grid)
      grid=Max(0.01,Min(10.0,grid))
      if run==0 then
        Text(hsper,s); sscanf(s,"%i",&srperiod)
        srperiod=Max(20,Min(9990,srperiod+Status(hsscr)*(srperiod<200?10:100)))
        Text(hdlay,s); sscanf(s,"%i",&timeout)
        timeout=Max(1,Min(9999,timeout+Status(hdscr)*(timeout<200?10:100)))
      endif
      Text(hvelo,s); v=0; sscanf(s,"%i",&v)
      v=Max(MINV,Min(MAXV,v+Status(hvscr)*VSTEP))
      Text(hpres,s); p=0; sscanf(s,"%i",&p)
      p=Max(MINP,Min(MAXP,p+Status(hpscr)*PSTEP))
      Text(hzcoo,s); z=0.0; sscanf(s,"%f",&z)
      z=Max(0.5,Min(99.9,z+Status(hzscr)*(z<3.0?0.5:(z<10.0?1.0:2.0))))
      change hstrt bkcolor=YELLOW
      run=1; redraw=1
      for i=1,i<256,i++
        SYS.Killsend(i)                // Kill all commands sent previously
      enddo
      for i=0,i<16,i++
        sent[i]=0                      // Reset command counters
      enddo
      if Status(hrand)==0 then
        Qrandset(12345)
        for i=0,i<16,i++
          validxy[i]=0
        enddo
      else
        Qrandset(Random(10000)+Time())
      endif
      treset=Time(); makereset=0
      tstart=Time()
    else if (Pressed(hstop) || stoprequest!=0) then
      if run!=0 then
        change hstrt bkcolor=GRAY
        run=0; redraw=1;
      endif
      stoprequest=0
    else if Pressed(hclea) then
      totalansw=totalansw+nansw
      clear hansw
      if totalansw!=0 then
        change hansw color=DARKGRAY
        add hansw text=format("(Total of %i discarded answers)",totalansw)
      endif
      nansw=0
    else if Pressed(hexit) then
      break
    endif
    if run then                        // Try to send new commands
      mi=Status(hmicr); sh=Status(hshrt); lo=Status(hlong)
      fa=Status(hfarm); ne=Status(hnear)
      if mi!=0 && sh!=0 && lo!=0 then
        shlim=333; lolim=666;
      else if sh!=0 && lo!=0 then
        shlim=0; lolim=500;
      else if mi!=0 && lo!=0 then
        shlim=500; lolim=500;
      else if mi!=0 && sh!=0 then
        shlim=500; lolim=1000;
      else if mi!=0 then
        shlim=1000; lolim=1000;
      else if sh!=0 then
        shlim=0; lolim=1000;
      else if lo!=0 then
        shlim=0; lolim=0;
      endif
      mode=Status(hmode)
      for i=0,i<$LAY.nfing,i++
        if makereset continue          // Clear queue if soft reset requested
        if Status(honly)!=0 && i!=rail continue
        if sent[i]>5 continue          // Queue is full for this rail
        if validxy[i]==0 then          // New start position for these fingers
          xl[i]=(leftlimit+xoffset)/2
          yl[i]=$LAY.yoffset[i]
          xr[i]=(xoffset+rightlimit)/2
          yr[i]=$LAY.yoffset[i]
          validxy[i]=1
        endif
        // Get area.
        switch area
        case 0:                        // Whole rail
          xminl=leftlimit; xmaxl=rightlimit
          xminr=leftlimit; xmaxr=rightlimit
          ymin=$LAY.bottom[i]; ymax=$LAY.top[i]-1
        case 1:                        // Thin line
          xminl=xoffset-dx/2*1000; xmaxl=xminl
          xminr=xoffset+dx/2*1000; xmaxr=xminr
          ymin=$LAY.bottom[i]; ymax=$LAY.top[i]-1
        case 2:                        // 1 mm line
          xminl=xoffset-dx/2*1000-500; xmaxl=xminl+1000
          xminr=xoffset+dx/2*1000-500; xmaxr=xminr+1000
          ymin=$LAY.bottom[i]; ymax=$LAY.top[i]-1
        case 3:                        // 5 mm line
          xminl=xoffset-dx/2*1000-2500; xmaxl=xminl+5000
          xminr=xoffset+dx/2*1000-2500; xmaxr=xminr+5000
          ymin=$LAY.bottom[i]; ymax=$LAY.top[i]-1
        case 5:                        // 30x30 mm
          xminl=xoffset-dx/2*1000-15000; xmaxl=xminl+30000
          xminr=xoffset+dx/2*1000-15000; xmaxr=xminr+30000
          ymin=$LAY.yoffset[i]-15000; ymax=ymin+30000
        case 6:                        // 100x100 mm
          xminl=xoffset-dx/2*1000-50000; xmaxl=xminl+100000
          xminr=xoffset+dx/2*1000-50000; xmaxr=xminr+100000
          ymin=$LAY.yoffset[i]-50000; ymax=ymin+100000
        default:                       // 10x10 mm - the safest option
          xminl=xoffset-dx/2*1000-5000; xmaxl=xminl+10000
          xminr=xoffset+dx/2*1000-5000; xmaxr=xminr+10000
          ymin=$LAY.yoffset[i]-5000; ymax=ymin+10000
        endsw
        // Truncate area if necessary.
        if Status(hncal)!=0 then
          if xminl<leftlimit+30000 then
            xmaxl=Min(rightlimit,xmaxl+leftlimit+30000-xminl)
            xminl=leftlimit+30000
          endif
          if xmaxr>rightlimit-30000 then
            xminr=Max(leftlimit,xminr+rightlimit-30000-xmaxr)
            xmaxr=rightlimit-30000
          endif
          ymin=Max(ymin,$LAY.bottom[i]+20000)
          ymax=Min(ymax,$LAY.top[i]-20000)
        endif
        // Select X coordinates.
        choice=Qrand(1000)
        if area==1 then                // Thin line
          xl[i]=xminl; xr[i]=xmaxr
        else if area==2 then           // 1 mm line
          xl[i]=xminl+choice; xr[i]=xminr+choice
        else
          if fa==0 || (ne!=0 && Qrand(1000)<500) then
            x=(xl[i]+xr[i])/2          // Near movements (close fingers)
            if choice>lolim then
              x=x+Qrand(300000)+Qrand(300000)-Qrand(300000)-Qrand(300000)
            else if choice>shlim then
              x=x+Qrand(5000)+Qrand(5000)-Qrand(5000)-Qrand(5000)
            else
              x=x+Qrand(300)+Qrand(300)-Qrand(300)-Qrand(300)
            endif
            xl[i]=x+Qrand(300)+Qrand(300)-299
            xr[i]=x+Qrand(300)+Qrand(300)-299
          else                         // Far (non-correlated) movements
            if choice>lolim then
              xl[i]=xl[i]+Qrand(300000)-Qrand(300000)
              xr[i]=xr[i]+Qrand(300000)-Qrand(300000)
            else if choice>shlim then
              xl[i]=xl[i]+Qrand(5000)-Qrand(5000)
              xr[i]=xr[i]+Qrand(5000)-Qrand(5000)
            else
              xl[i]=xl[i]+Qrand(300)-Qrand(300)
              xr[i]=xr[i]+Qrand(300)-Qrand(300)
            endif
          endif
          xl[i]=Mirror(xl[i],xminl,xmaxl)
          xr[i]=Mirror(xr[i],xminr,xmaxr)
          if xl[i]>xr[i] then
            t=xl[i]; xl[i]=xr[i]; xr[i]=t
          endif
          if area==0 && Status(hncal)!=0 && xr[i]-xl[i]<20000 then
            xl[i]=xl[i]-15000
            xr[i]=xr[i]+15000
            if xl[i]<xminl then
              xl[i]=xl[i]+15000
              xr[i]=xr[i]+15000
            else if xr[i]>xmaxr then
              xl[i]=xl[i]-15000
              xr[i]=xr[i]-15000
            endif
          endif
        endif
        if Status(hgrid)!=0 then
          xl[i]=Round(xl[i],grid*1000)
          xr[i]=Round(xr[i],grid*1000)
        endif
        // Select Y coordinates.
        choice=Qrand(1000)
        if fa==0 || (ne!=0 && Qrand(1000)<500) then
          y=(yl[i]+yr[i])/2            // Near movements (close fingers)
          if choice>lolim then
            y=y+Qrand(100000)+Qrand(100000)-Qrand(100000)-Qrand(100000)
          else if choice>shlim then
            y=y+Qrand(5000)+Qrand(5000)-Qrand(5000)-Qrand(5000)
          else
            y=y+Qrand(300)+Qrand(300)-Qrand(300)-Qrand(300)
          endif
          yl[i]=y+Qrand(300)-Qrand(300)
          yr[i]=y+Qrand(300)-Qrand(300)
        else
          if choice>lolim then
            yl[i]=yl[i]+Qrand(100000)-Qrand(100000)
            yr[i]=yr[i]+Qrand(100000)-Qrand(100000)
          else if choice>shlim then
            yl[i]=yl[i]+Qrand(5000)-Qrand(5000)
            yr[i]=yr[i]+Qrand(5000)-Qrand(5000)
          else
            yl[i]=yl[i]+Qrand(300)-Qrand(300)
            yr[i]=yr[i]+Qrand(300)-Qrand(300)
          endif
        endif
        yl[i]=Mirror(yl[i],ymin,ymax)
        yr[i]=Mirror(yr[i],ymin,ymax)
        if Status(hgrid)!=0 then
          yl[i]=Round(yl[i],grid*1000)
          yr[i]=Round(yr[i],grid*1000)
        endif
        if Abs(yr[i]-yl[i])<400 then   // Probably too close
          if yr[i]>$LAY.yoffset[i] then
            yl[i]=yr[i]-400
          else
            yl[i]=yr[i]+400
          endif
        endif
        // Generate movement.
        s[0]=S_MOVE
        n=1
        if shuttle==1 then
          s[n]=0x9B                    // M_SHUTTLE
          s[n+1]=0x01
          n=n+2
        else if shuttle==2 then
          s[n]=0x9B                    // M_SHUTTLE
          s[n+1]=0x02
          n=n+2
        endif
        if mode==7 then
          // Left finger stays at home.
          s[n]=M_CHECK0;               // Stay at home
          s[n+1]=i*2;                  // First head
          n=n+2
        else
          // Left finger is moving.
          s[n]=M_MOVE;                 // Simple movement
          s[n+1]=i*2;                  // First head
          if mode==0 || mode==6 || mode==7 then
            $uint2(s+n+2)=32767;       // High Z in case of disabled Z move
          else
            $uint2(s+n+2)=z*1000;      // Height, um
          endif
          s[n+4]=0;                    // Bending
          $int3(s+n+5)=xl[i];          // Coordinates of first head, um
          $int3(s+n+8)=yl[i];
          $uint2(s+n+11)=0;            // Radius of the pad
          s[n+13]=accuracy;            // Accuracy of positioning
          s[n+14]=v;                   // Stroke, mm/s
          s[n+15]=p;                   // Pressure, gramm
          n=n+16
        endif
        if mode==6 then
          // Right finger stays at home.
          s[n]=M_CHECK0;               // Stay at home
          s[n+1]=i*2+1;                // Second head
          n=n+2
        else
          // Right finger is moving.
          s[n]=M_MOVE;                 // Simple movement
          s[n+1]=i*2+1;                // Second head
          if mode==0 || mode==6 || mode==7 then
            $uint2(s+n+2)=32767;       // High Z in case of disabled Z move
          else
            $uint2(s+n+2)=z*1000;      // Height, um
          endif
          s[n+4]=0;                    // Bending
          $int3(s+n+5)=xr[i];          // Coordinates of second head, um
          $int3(s+n+8)=yr[i];
          $uint2(s+n+11)=0;            // Radius of the pad
          s[n+13]=accuracy;            // Accuracy of positioning
          s[n+14]=v;                   // Stroke, mm/s
          s[n+15]=p;                   // Pressure, gramm
          n=n+16
        endif
        if mode==0 || mode==6 || mode==7 then
          s[n]=0x00                    // Dummy command (NOP)
          SYS.Send(n+1,s,i)
        else if mode==3 then
          s[n]=M_ERETEST               // Exact resistance with auto retest
          s[n+1]=i*2                   // First head
          s[n+2]=i*2+1                 // Second head
          $int4(s+n+3)=0x00000200      // Synchronous search close range
          $int4(s+n+7)=0               // No power limit
          $int4(s+n+11)=0              // No current limit
          $int2(s+n+15)=0              // No voltage limit
          $int2(s+n+17)=0              // Default maximal reported resistance
          $int2(s+n+19)=100            // 100 um search step for first head
          $int2(s+n+21)=100            // 100 um search step for second head
          SYS.Send(n+23,s,i)
        else if mode==5 then
          s[n]=M_DEBUG                 // Delay
          s[n+1]=0x3A
          s[n+2]=2
          $uint2(s+n+3)=3              // 3 milliseconds
          SYS.Send(n+5,s,i)
        else
          if mode==1 then
            s[n]=M_RMEAS               // Resistance measurement
          else if mode==2 then
            s[n]=M_EXACTR              // Exact resistance measurement
          else
            s[n]=M_LAMEAS              // LATEST measurement
          endif
          if Qrand(1000)<500 then
            s[n+1]=i*2                 // First head
            s[n+2]=1                   // Group of one head
            s[n+3]=i*2+1               // Second head
          else
            s[n+1]=i*2+1               // First head
            s[n+2]=1                   // Group of one head
            s[n+3]=i*2                 // Second head
          endif
          SYS.Send(n+4,s,i)
        endif
        sent[i]=sent[i]+1
      enddo
      if makereset==1 then             // Send reset when queues empty
        for i=0,i<$LAY.nfing,i++ do
          if sent[i]>0 break
        enddo
        if i>=$LAY.nfing then
          SYS.Softreset(0)
          makereset=0
        endif
      endif
      if Status(hsoft)!=0 && makereset==0 then
        t=Time()-treset
        change hsper text=format("%i",Max(srperiod-t/1000-1,0))
        if t>srperiod*1000 then
          treset=Time()
          makereset=1
          redraw=1
        endif
      endif
      if Status(hastp)!=0 then
        t=Time()-tstart
        change hdlay text=format("%i",Max(timeout-t/1000-1,0))
        if t>timeout*1000 then
          change hstrt bkcolor=GRAY
          run=0; redraw=1
        endif
      endif
    endif
    newlay=0
    wait
  enddo
  i=((Status(honly)!=0)<<1) | ((Status(hlong)!=0)<<2)
  i=i | ((Status(hshrt)!=0)<<3) | ((Status(hfarm)!=0)<<4)
  i=i | ((Status(hnear)!=0)<<5) | ((Status(hncal)!=0)<<7)
  i=i | ((Status(hgrid)!=0)<<8) | ((Status(hrand)!=0)<<9)
  i=i | ((Status(hastp)!=0)<<10)| ((Status(hmicr)!=0)<<11)
  i=i | ((Status(hsoft)!=0)<<13)
  mode=Status(hmode)
  setini("Debug","Random","%X,%i,%i,%i,%g,%i,%i,%i,%i,%i,%g,%i,%i,%i,%i",      \
    i,rail,accuracy,dx,grid,timeout,rmin,rmax,v,p,z,mode,srperiod,area,shuttle)
  destroy hmain
end

#define OSCX 397                       // X size of oscillogramm
#define OSCY 320                       // Y size of oscillogramm
#define NOSC 4096                      // Number of points in oscillogramm
function int Bustest()
  int i,j,t,xh,yh,delta,h,a,v,p,dt,redraw
  int data[NOSC],datastep,xoffset,zoomx,yoffset,zoomy
  float x,y,step,r,z,xscale,yscale,ymin,ymax,cursor
  float pad[8]
  char s[256]
  handle hmain,hgraph,hxscroll,hyscroll
  handle hvelo,hvscr,hpres,hpscr,hzcoo,hzscr
  handle hscal,hsscr,htime,htscr,hzoomx,hzoomy
  handle hnotouch,hu,hi,hd,hshot,hfind,hexit
  hmain=control WINDOW
    window=NULL
    position=10,10,OSCX+140,OSCY+91
    name="数字总线示波器"
    help=" "
    bkcolor=WHITEMAGENTA
    size=1024
  endc
  hgraph=control GRAPH
    window=hmain
    position=10,10,OSCX,OSCY
    help="波形图，单击可以设置光标"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  hxscroll=control HSCROLL
    window=hmain
    position=9,OSCY+11,OSCX+2,16
    help="滚动查看整个曲线"
    limits=0,NOSC-OSCX+40
    mode=OSCX-40
  endc
  disable hxscroll
  hyscroll=control VSCROLL
    window=hmain
    position=OSCX+11,9,16,OSCY+2
    help="滚动查看整个曲线"
    limits=-1024,1024
    mode=32
  endc
  disable hyscroll
  draw window=hmain color=DARKGRAY bkcolor=GRAY
  draw at OSCX+11,OSCY+11 fillrect OSCX+27,OSCY+27
  xh=9
  yh=OSCY+35
  draw font=INFOFONT color=MAGENTA
  draw at xh,yh+18 text="Pad: Head"
  hhead[0]=control EDIT
    window=hmain
    position=xh+65,yh,25,21
    help="此处指定测试头"
    bkcolor=WHITE
  endc
  hhscr[0]=control VSCROLL
    window=hmain
    position=xh+90,yh,20,21
    help="按下更改测试头"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at xh+117,yh+18 text="X"
  hxcoo[0]=control EDIT
    window=hmain
    position=xh+130,yh,65,21
    help="此处指定X坐标,以毫米为单位"
    bkcolor=WHITE
  endc
  hxscr[0]=control VSCROLL
    window=hmain
    position=xh+195,yh,20,21
    help="按下可调整X坐标"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at xh+222,yh+18 text="Y"
  hycoo[0]=control EDIT
    window=hmain
    position=xh+235,yh,65,21
    help="此处指定Y坐标,以毫米为单位"
    bkcolor=WHITE
  endc
  hyscr[0]=control VSCROLL
    window=hmain
    position=xh+300,yh,20,21
    help="按下可调整Y坐标"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at xh+327,yh+18 text="R"
  hradi[0]=control EDIT
    window=hmain
    position=xh+340,yh,55,21
    help="此处可指定焊盘半径以毫米为单位"
    bkcolor=WHITE
  endc
  hrscr[0]=control VSCROLL
    window=hmain
    position=xh+395,yh,20,21
    help="按下可调整半径"
    limits=1,-1
    mode=M_NOTAB
  endc
  haccu[0]=control EDIT
    window=hmain
    position=-100,-100,1,1
    name="5"
    bkcolor=WHITE
  endc
  disable haccu[0]                     // Window is outside the screen
  draw at xh,yh+45 text="Stroke:  V"
  hvelo=control EDIT
    window=hmain
    position=xh+65,yh+27,35,21
    help="指定Z向下行程，毫米每秒"
    bkcolor=WHITE
  endc
  hvscr=control VSCROLL
    window=hmain
    position=xh+100,yh+27,20,21
    help="按下可更改行程"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at xh+127,yh+45 text="P"
  hpres=control EDIT
    window=hmain
    position=xh+140,yh+27,35,21
    help="指定Z压力，克"
    bkcolor=WHITE
  endc
  hpscr=control VSCROLL
    window=hmain
    position=xh+175,yh+27,20,21
    help="按下可更改压力"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at xh+202,yh+45 text="H"
  hzcoo=control EDIT
    window=hmain
    position=xh+215,yh+27,40,21
    help="指定Z向上距离,毫米"
    bkcolor=WHITE
  endc
  hzscr=control VSCROLL
    window=hmain
    position=xh+255,yh+27,20,21
    help="按可更改Z向上距离"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at xh+307,yh+45 text="Step"
  hscal=control EDIT
    window=hmain
    position=xh+340,yh+27,55,21
    name="1.000"
    help="指定按下滚动键时坐标会改变多少"
    bkcolor=WHITE
  endc
  hsscr=control VSCROLL
    window=hmain
    position=xh+395,yh+27,20,21
    help="更改坐标步长"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at OSCX+38,30 text="On-head mode:"
  hu=control RADIO
    window=hmain
    position=OSCX+55,33,70,21
    name="场"
    help="进行电场场(电压)测量"
    font=INFOFONT
  endc
  hi=control RADIO
    window=hmain
    position=OSCX+55,55,70,21
    name="电容"
    help="进行电容(电流)测量"
    font=INFOFONT
  endc
  hd=control RADIO
    window=hmain
    position=OSCX+55,77,70,21
    name="直流"
    help="进行直接测量(不带前置放大器)"
    font=INFOFONT
  endc
  draw at OSCX+39,128 text="dT="
  htime=control TEXT
    window=hmain
    position=OSCX+63,110,36,21
    help="数据点之间的近似时间(微秒)"
    bkcolor=WHITE
    mode=M_BORDER|M_CENTERED
  endc
  htscr=control VSCROLL
    window=hmain
    position=OSCX+99,110,17,21
    help="按下更改采集速度"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at OSCX+117,128 text="s"
  hnotouch=control CUSTOMBOX
    window=hmain
    position=OSCX+39,145,91,21
    name="不接触"
    help="检查是否对测量悬而未决"
    font=INFOFONT
  endc
  hzoomx=control CUSTOMBOX
    window=hmain
    position=OSCX+39,180,91,21
    name="Zoom time"
    help="检查示波器的缩放时间刻度"
    font=INFOFONT
  endc
  hzoomy=control CUSTOMBOX
    window=hmain
    position=OSCX+39,205,91,21
    name="Zoom ampl"
    help="检查示波器的变焦幅度"
    font=INFOFONT
  endc
  hshot=control BUTTON
    window=hmain
    position=OSCX+40,yh-62,90,54
    name="开始"
    help="按下进行单次测量"
    color=RED
  endc
  hfind=control BUTTON
    window=hmain
    position=OSCX+40,yh,90,21
    name="查找"
    help="使用摄像机查找焊盘的坐标"
  endc
  hexit=control BUTTON
    window=hmain
    position=OSCX+40,yh+27,90,21
    name="关闭"
    help="按下可以关闭此窗口"
  endc
  draw show
  h=0; x=$LAY.leftlimit/1000.0; y=($LAY.bottom[0]+$LAY.top[0])/2000.0; r=0.0;
  v=$GLOBAL.defstroke; p=$GLOBAL.defpressure; z=$GLOBAL.defheight/1000.0;
  getini("Debug","BUSTEST","%i,%f,%f,%f,%i,%i,%f",&h,&x,&y,&r,&v,&p,&z)
  Setline(0,h,x,y,r,5)
  change hvelo text=format("%i",v)
  change hpres text=format("%i",p)
  change hzcoo text=format("%.1f",z)
  i=0; dt=100; j=0; step=1.000
  getini("Debug","BUSTEST setup","%i,%i,%i,%f",&i,&dt,&j,&step)
  change (i==0?hu:(i==1?hi:hd)) mode=M_CHECKED
  dt=Max(20,Min(1000,dt))
  if dt==20 then
    change htime text=">20"
  else
    change htime text=format("%i",dt)
  endif
  change hnotouch mode=(j==0?0:M_CHECKED)
  step=Max(0.001,Min(10.0,step)); change hscal text=format("%.3f",step)
  datastep=0                           // Means invalid data
  cursor=-1                            // Means cursor absent
  while 1 do
    Text(hscal,s); step=1.000; sscanf(s,"%f",&step)
    if layoutchanged!=0 then
      if $LAY.cameras==0 then disable hfind;
      else enable hfind; endif
      layoutchanged=0
    endif
    if Pressed(hhscr[0]) || Pressed(hhead[0]) then
      delta=Status(hhscr[0])
      Text(hhead[0],s); h=0; sscanf(s,"%i",&h)
      h=h+delta
      h=Max(0,Min($LAY.nfing*2-1,h))
      change hhead[0] text=format("%i",h)
      change hhscr[0] select=0
      if delta==0 then setfocus hxcoo[0];
      else setfocus hmain; endif
    else if Pressed(hxscr[0]) || Pressed(hxcoo[0]) then
      delta=Status(hxscr[0])
      Text(hxcoo[0],s); x=0.0; sscanf(s,"%f",&x)
      x=x+delta*step
      if x<$LAY.leftlimit/1000.0 then
        x=$LAY.leftlimit/1000.0
      else if x>$LAY.rightlimit/1000.0 then
        x=$LAY.rightlimit/1000.0
      endif
      change hxcoo[0] text=format("%.3f",x)
      change hxscr[0] select=0
      if delta==0 then setfocus hycoo[0];
      else setfocus hmain; endif
    else if Pressed(hyscr[0]) || Pressed(hycoo[0]) then
      delta=Status(hyscr[0])
      Text(hhead[0],s); h=0; sscanf(s,"%i",&h)
      Text(hycoo[0],s); y=0.0; sscanf(s,"%f",&y)
      y=y+delta*step
      if (y>=$LAY.top[h/2]/1000.0) y=($LAY.top[h/2]-1)/1000.0
      if (y<$LAY.bottom[h/2]/1000.0) y=$LAY.bottom[h/2]/1000.0
      change hycoo[0] text=format("%.3f",y)
      change hyscr[0] select=0
      if delta==0 then setfocus hradi[0];
      else setfocus hmain; endif
    else if Pressed(hrscr[0]) || Pressed(hradi[0]) then
      delta=Status(hrscr[0])
      Text(hradi[0],s); r=0.0; sscanf(s,"%f",&r)
      r=r+delta*step
      if r<0.0 then r=0.0
      else if r>64.0 then r=64.0
      endif
      change hradi[0] text=format("%.3f",r)
      change hrscr[0] select=0
      if delta==0 then setfocus haccu[0];
      else setfocus hmain; endif
    else if Pressed(hfind) && $LAY.nfing>0 then
      Getline(0,&h,&x,&y,&r,&a,1)
      pad[0]=$LAY.side[h/2]; pad[1]=x; pad[2]=y; pad[3]=0
      disable hmain
      j=Position(pad,pad,0,0)
      enable hmain
      if j==1 then
        x=pad[1]; y=pad[2];
        for j=$LAY.nfing-1,j>0,j--     // Correct the first rail
          if ($LAY.side[j]!=pad[0]) continue
          if (y>=$LAY.bottom[j]/1000.0 && y<$LAY.top[j]/1000.0) break
        enddo
        h=(h & 1)+j*2
      endif
      Setline(0,h,x,y,r,5)             // Fixed high accuracy
    else if Pressed(hvelo) || Pressed(hvscr) then
      delta=Status(hvscr)
      Text(hvelo,s); v=40; sscanf(s,"%i",&v)
      v=v+delta*VSTEP
      v=Max(MINV,Min(MAXV,v))
      change hvelo text=format("%i",v)
      change hvscr select=0
      if delta==0 then setfocus hpres;
      else setfocus hmain; endif
    else if Pressed(hpres) || Pressed(hpscr) then
      delta=Status(hpscr)
      Text(hpres,s); p=30; sscanf(s,"%i",&p)
      p=p+delta*PSTEP
      p=Max(MINP,Min(MAXP,p))
      change hpres text=format("%i",p)
      change hpscr select=0
      if delta==0 then setfocus hzcoo;
      else setfocus hmain; endif
    else if Pressed(hzcoo) || Pressed(hzscr) then
      delta=Status(hzscr)
      Text(hzcoo,s); z=10.0; sscanf(s,"%f",&z)
      z=z+delta*(z<3.0?0.5:(z<10.0?1.0:2.0))
      z=Max(0.5,Min(99.9,z))
      change hzcoo text=format("%.1f",z)
      change hzscr select=0
      if delta==0 then setfocus hvelo;
      else setfocus hmain; endif
    else if Pressed(hscal) || Pressed(hsscr) then
      Text(hscal,s); step=1.000; sscanf(s,"%f",&step)
      if Status(hsscr)>0 then
        if step<0.00999 then step=0.01;
        else if step<0.0999 then step=0.1;
        else if step<0.999 then step=1.0;
        else step=10.0;
        endif
      else if Status(hsscr)<0 then
        if step>10.01 then step=10.0;
        else if step>1.001 then step=1.0;
        else if step>0.1001 then step=0.1;
        else step=0.01;
        endif
      endif
      change hscal text=format("%.3f",step)
      change hsscr select=0
      setfocus hmain
    else if Pressed(htscr) then
      if Status(htscr)>0 then
        if dt==20 then dt=50;
        else if dt==50 then dt=100;
        else if dt==100 then dt=200;
        else if dt==200 then dt=500;
        else dt=1000; endif
      else if Status(htscr)<0 then
        if dt==1000 then dt=500;
        else if dt==500 then dt=200;
        else if dt==200 then dt=100;
        else if dt==100 then dt=50;
        else dt=20; endif
      endif
      if dt==20 then
        change htime text=">20"
      else
        change htime text=format("%i",dt)
      endif
      change htscr select=0
      setfocus hmain
    else if Pressed(hzoomx) || Pressed(hzoomy) then
      if Status(hzoomx)==0 then disable hxscroll;
      else enable hxscroll; endif
      if Status(hzoomy)==0 then disable hyscroll;
      else enable hyscroll; endif
      redraw=1
    else if Pressed(hxscroll) && Status(hzoomx)!=0 then
      redraw=1
    else if Pressed(hyscroll) && Status(hzoomy)!=0 then
      redraw=1
    else if Pressed(hshot) then        // Measurement itself
      SYS.Killimm(1)                   // Free easy command buffer 1
      Text(hhead[0],s); h=0; sscanf(s,"%i",&h)
      Text(hxcoo[0],s); x=0.0; sscanf(s,"%f",&x)
      Text(hycoo[0],s); y=0.0; sscanf(s,"%f",&y)
      Text(hradi[0],s); r=0.0; sscanf(s,"%f",&r)
      sprintf(s,"M %i(%f,%f,%f) %i(Z) NOP",h,x,y,r,h^1)
      SERV.Cmdimm(0,s)                 // Move finger into point
      s[0]=S_MEASUREBUS                // Old command set!
      s[1]=$LAY.side[h/2]              // Side
      $int3(s+2)=x*1000.0              // X coordinate
      $int3(s+5)=y*1000.0              // Y coordinate
      $int2(s+8)=r*1000.0              // Radius
      s[10]=255                        // Delay, not accuracy!
      s[11]=(dt-20)/4.6                // Very approximate relation!
      s[12]=0                          // Mask for port P1_A
      if Status(hu)!=0 then
        s[13]=0                        // Field mode
      else if Status(hi)!=0 then
        s[13]=255                      // Capacity mode
      else
        s[13]=128                      // Direct mode
      endif
      s[14]=0                          // No wait
      s[15]=0                          // No wait
      s[16]=NOSC/128                   // Number of measurements
      s[17]=Status(hnotouch)           // Whether to contact PCB
      SYS.Sendimm(1,18,s)              // Send easy command 1
      t=Time()+8000+(dt*NOSC)/1000     // Timeout 8 s
      while $A[1].length==0 do
        if t<Time() break              // Timeout!
        wait
      enddo
      datastep=0                       // Means invalid data
      if $A[1].length==5 && $A[1].answer==S_MEASUREBUS then
        for i=0,i<NOSC,i=i+256 do
          s[0]=S_DUMP                  // Get data
          s[1]=255                     // Request to crate controller
          s[2]=0x15                    // D_BUSDATA to dump
          $uint2(s+3)=256              // Number of items to dump
          $uint2(s+5)=i                // Offset to start from
          SYS.Sendimm(1,7,s)           // Send easy command 1
          t=Time()+5000                // Timeout 5 s
          while $A[1].length==0 do
            if t<Time() break          // Timeout!
            wait
          enddo
          if $A[1].length!=773 break   // Wrong length of answer
          for j=0,j<256,j++ do
            data[i+j]=$int2($A[1]+2*j+5)
          enddo
        enddo
        if i>=NOSC datastep=dt         // Data gathered correctly
      endif
      redraw=1
    else if Pressed(hgraph) then
      zoomx=Status(hzoomx)
      if zoomx==0 then
        xoffset=-40; xscale=OSCX/(NOSC+80.0)
      else
        xoffset=Status(hxscroll)-5; xscale=1.0
      endif
      cursor=Max(0,Min(NOSC-1,Limit0(hgraph)/xscale+xoffset))
      redraw=1
    else if Pressed(hexit) then
      Getline(0,&h,&x,&y,&r,&a,0)
      Text(hvelo,s); v=40; sscanf(s,"%i",&v)
      Text(hpres,s); p=30; sscanf(s,"%i",&p)
      Text(hzcoo,s); z=10.0; sscanf(s,"%f",&z)
      setini("Debug","BUSTEST","%i,%f,%f,%f,%i,%i,%f",h,x,y,r,v,p,z)
      i=Status(hi)+Status(hd)*2
      j=Status(hnotouch)
      Text(hscal,s); step=1.000; sscanf(s,"%f",&step)
      setini("Debug","BUSTEST setup","%i,%i,%i,%f",i,dt,j,step)
      break
    endif
    if redraw then
      draw window=hgraph color=WHITE bkcolor=WHITE
      draw at 0,0 fillrect OSCX,OSCY
      if datastep!=0 then              // Valid data
        zoomx=Status(hzoomx)
        zoomy=Status(hzoomy)
        if zoomx==0 then
          xoffset=-40; xscale=OSCX/(NOSC+80.0)
        else
          xoffset=Status(hxscroll)-5; xscale=1.0
        endif
        if zoomy==0 then
          yoffset=OSCY/2; yscale=OSCY/65536.0
        else
          yoffset=OSCY/2-Status(hyscroll)*3.2; yscale=0.1
        endif
        draw color=DARKGRAY font=SMALLFONT mode=M_CENTERED
        draw at 0,OSCY/2 to OSCX,OSCY/2
        for i=0,i<NOSC,i=i+(zoomx?100:500) do
          x=(i-xoffset)*xscale
          if x<(-40) continue
          if x>OSCX+40 break
          draw at x,OSCY/2-3 to x,OSCY/2+4
          draw at x,OSCY/2+15 text=format("%g",(i*datastep)/1000.0)
        enddo
        draw at 50,0 to 50,OSCY mode=M_LEFT
        ymin=(zoomy?-32600:-30000)
        ymax=(zoomy?32600:30000)
        for i=ymin,i<=ymax,i=i+(zoomy?200:5000) do
          y=yoffset-i*yscale
          draw at 47,y to 54,y
          draw at 56,y+7 text=format("%i",i)
        enddo
        draw color=BLACK
        draw at -xscale*xoffset,yoffset-data[0]*yscale
        for i=1,i<NOSC,i++ do
          x=(i-xoffset)*xscale
          if x<0 continue
          if x>OSCX break
          draw to x,yoffset-data[i]*yscale
        enddo
        if cursor>=0 then
          draw color=LIGHTRED
          x=(cursor-xoffset)*xscale
          draw at x,0 to x,OSCY
          x=Max(1,Min(x-32,OSCX-70))
          draw bkcolor=LIGHTYELLOW at x,1 fillrect x+64,25
          draw at x+3,14 text=format("T= %.4g",(cursor*datastep)/1000.0)
          draw at x+3,25 text=format("Y= %i",data[cursor])
        endif
      endif
      draw show
      redraw=0
    endif
    wait
  enddo
end

// Turns on (mode=1) or off (mode=0) shuttle vacuum.
function int Vacuum(int mode)
  int n
  char buf[256]
  if (($LAY.config & LC_LDMASK)==LC_LMMANUAL ||                                \
    ($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                    \
    ($LAY.config & LC_LDMASK)==LC_LMS2AUTO ||                                  \
    ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO ||                                 \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO) &&                                \
    ($GLOBAL.debugmode & 0x0040)==0                                            \
  then
    // L&M-based SPS.
    buf[0]=S_LMAUTO
    buf[1]=4                           // Send command
    $uint2(buf+2)=0                    // Timeout, seconds
    if mode==0 then
      n=5+Strcpy(buf+4,"MECH.Cmd=Vacuum 0")
    else
      n=5+Strcpy(buf+4,"MECH.Cmd=Vacuum 1")
    endif
    SYS.Sendimm(0,n,buf)
  else
    // Jetter-based SPS.
    buf[0]=S_DEBUG
    buf[1]=0x2A                        // Execute SPS command
    $long(buf+2)=62                    // Shuttle vacuum
    buf[6]=1                           // Number of arguments
    $long(buf+7)=mode & 1              // Vacuum ON/OFF
    SYS.Sendimm(0,11,buf)
  endif
end

#define MDX 72
#define MDY 24
function int main()
  char s[80],buf[16]
  int optmode
  handle hmain,hopts,hlout,hvers,hload,hsoft,hshut,hmove
  handle hptio,hlock,hopen,hxchg,hrand,hvini,fcini,hexri
  handle hlini,hmsdi,hlati,hprot,ha5pr,ha5ms,ha5mt,ha5tr
  handle ha5bt,ha5st,htest,hioex,hneed,hspst,hspdt,hmest
  handle hcadj,hbust,hplay,hphas,hrast,hlowr,hquit
  answermode=AWM_NONE
  if Argv(s)==0 then
    SYS.Broadcast(10,"FREE MAIN")      // Remove residents of the main window;
    terminate=0                        // don't remove itself. Theoretically,
    hmain=control CHILD                // there is a possibility that some
      window=NULL                      // other process can incline; but, in
      position=6,6,523,MDY*6+4         // praxis, it is hardly possible.
      help=" "
      bkcolor=LIGHTCYAN
    endc
    // First column: general functions.
    hopts=control BUTTON
      window=hmain
      position=3,3,MDX-2,MDY-2
      name="选项"
      help="按下以设置显示模式，屏蔽手臂，外部设备等."
    endc
    hlout=control BUTTON
      window=hmain
      position=3,3+MDY,MDX-2,MDY-2
      name="布局"
      help="按下以编辑测试机布局"
    endc
    hvers=control BUTTON
      window=hmain
      position=3,3+2*MDY,MDX-2,MDY-2
      name="版本"
      help="按下以询问所加载的版本"
    endc
    hquit=control BUTTON
      window=hmain
      position=3,3+5*MDY,MDX-2,MDY-2
      name="关闭"
      help="按下以关闭诊断窗口"
      color=CYAN
    endc
    // Second column: load/shutdown.
    hload=control BUTTON
      window=hmain
      position=3+MDX,3,MDX-2,MDY-2
      name="复位"
      help="按下以引导测试机启动"
    endc
    hsoft=control BUTTON
      window=hmain
      position=3+MDX,3+MDY,MDX-2,MDY-2
      name="软复位"
      help="按下以进行软件复位"
    endc
    hshut=control BUTTON
      window=hmain
      position=3+MDX,3+2*MDY,MDX-2,MDY-2
      name="硬复位"
      help="按下以关闭测试机"
    endc
    if $GLOBAL.a5!=0 then
      hvaon=control BUTTON
        window=hmain
        position=3+MDX,3+3*MDY,MDX-2,MDY-2
        name="开真空"
        bkcolor=GRAY
        help="按下以打开架板框上的真空"
      endc
      hvaof=control BUTTON
        window=hmain
        position=3+MDX,3+4*MDY,MDX-2,MDY-2
        name="关真空"
        bkcolor=GRAY
        help="按下以关闭架板框上的真空"
      endc
    endif
    // Third column: standard commands.
    hmove=control BUTTON
      window=hmain
      position=3+2*MDX,3,MDX-2,MDY-2
      name="移动"
      help="按下以打开移动窗口:两点之间的简单测试"
    endc
    hptio=control BUTTON
      window=hmain
      position=3+2*MDX,3+MDY,MDX-2,MDY-2
      name="I/O端口"
      help="按下以打开I/O端口窗口"
    endc
    hlock=control BUTTON
      window=hmain
      position=3+2*MDX,3+2*MDY,MDX-2,MDY-2
      name="锁紧"
      help="按下以锁紧架板框或放置单个PCB"
    endc
    hopen=control BUTTON
      window=hmain
      position=3+2*MDX,3+3*MDY,MDX-2,MDY-2
      name="解锁"
      help="按下以打开架板框或去除所有PCB"
    endc
    hxchg=control BUTTON
      window=hmain
      position=3+2*MDX,3+4*MDY,MDX-2,MDY-2
      name="换平台"
      help="按下以准备更换特殊架板框"
    endc
    hrand=control BUTTON
      window=hmain
      position=3+2*MDX,3+5*MDY,MDX-2,MDY-2
      name="随机"
      help="按下以打开随机测试"
    endc
    // Fourth column: initializations.
    hvini=control BUTTON
      window=hmain
      position=3+3*MDX,3,MDX-2,MDY-2
      name="HV自检"
      help="按下以打开高压初始化窗口"
    endc
    hexri=control BUTTON
      window=hmain
      position=3+3*MDX,3+MDY,MDX-2,MDY-2
      name="ExR自检"
      help="按下以打开精密电阻初始化窗口"
    endc
    if $GLOBAL.a5!=0 then
      hmsdi=control BUTTON
        window=hmain
        position=3+3*MDX,3+2*MDY,MDX-2,MDY-2
        name="MSD自检"
        help="按下以打开微短探测初始化窗口"
      endc
      hlati=control BUTTON
        window=hmain
        position=3+3*MDX,3+3*MDY,MDX-2,MDY-2
        name="LA自检"
        help="按下以打开潜在开路探测初始化窗口"
      endc
      fcini=control BUTTON
        window=hmain
        position=3+3*MDX,3+4*MDY,MDX-2,MDY-2
        name="F-C自检"
        help="按下以打开电场和电容参数窗口"
      endc
      hlini=control BUTTON
        window=hmain
        position=3+3*MDX,3+5*MDY,MDX-2,MDY-2
        name="L自检"
        help="按下以打开电感初始化窗口"
      endc
    endif
    // Fifth column: protocols, strongly tester-specific.
    if $GLOBAL.a5==0 then
      hprot=control BUTTON
        window=hmain
        position=10+4*MDX,3,MDX-2,MDY-2
        name="协议"
        help="打开运动协议窗口"
        bkcolor=WHITEBLUE
      endc
    else
      ha5pr=control BUTTON
        window=hmain
        position=10+4*MDX,3,MDX-2,MDY-2
        name="运动"
        help="按下以打开运动示波器窗口"
        bkcolor=WHITEGREEN
      endc
      ha5ms=control BUTTON
        window=hmain
        position=10+4*MDX,3+MDY,MDX-2,MDY-2
        name="测量卡"
        help="按下以打开测量示波器窗口"
        bkcolor=WHITEGREEN
      endc
      ha5mt=control BUTTON
        window=hmain
        position=10+4*MDX,3+2*MDY,MDX-2,MDY-2
        name="控制图"
        help="按下以打开测量卡测试窗口"
        bkcolor=WHITEGREEN
      endc
      ha5tr=control BUTTON
        window=hmain
        position=10+4*MDX,3+3*MDY,MDX-2,MDY-2
        name="树状图"
        help="按下以打开1394总线树状图窗口"
        bkcolor=WHITEGREEN
      endc
      ha5bt=control BUTTON
        window=hmain
        position=10+4*MDX,3+4*MDY,MDX-2,MDY-2
        name="总线"
        help="按下以打开总线流通窗口"
        bkcolor=WHITEGREEN
      endc
      ha5st=control BUTTON
        window=hmain
        position=10+4*MDX,3+5*MDY,MDX-2,MDY-2
        name="状态"
        help="按下以打开信息窗口"
        bkcolor=WHITEGREEN
      endc
    endif
    // Sixth column: tests.
    htest=control BUTTON
      window=hmain
      position=17+5*MDX,3,MDX-2,MDY-2
      name="卡片自检"
      help="按下以开始卡片自检程序"
      bkcolor=WHITEMAGENTA
    endc
    if $GLOBAL.a5==0 then
      hioex=control BUTTON
        window=hmain
        position=17+5*MDX,3+MDY,MDX-2,MDY-2
        name="I/O ext"
        help="按此开始对 I/O 扩展器进行自检"
        bkcolor=WHITEMAGENTA
      endc
    else
      hneed=control BUTTON
        window=hmain
        position=17+5*MDX,3+MDY,MDX-2,MDY-2
        name="针尖"
        help="按下以开始查看针尖"
        bkcolor=WHITEMAGENTA
      endc
    endif
    hspst=control BUTTON
      window=hmain
      position=17+5*MDX,3+2*MDY,MDX-2,MDY-2
      name="单片机"
      help="按下以开始测试自动架板框和载入器"
      bkcolor=WHITEMAGENTA
    endc
    hspdt=control BUTTON
      window=hmain
      position=17+5*MDX,3+3*MDY,MDX-2,MDY-2
      name="速度"
      help="按下以开始飞针机速度测试"
      bkcolor=WHITEMAGENTA
    endc
    hmest=control BUTTON
      window=hmain
      position=17+5*MDX,3+4*MDY,MDX-2,MDY-2
      name="年度校验"
      help="按下以开始用年度校验板开始电子测试"
      bkcolor=WHITEMAGENTA
    endc
    hcadj=control BUTTON
      window=hmain
      position=17+5*MDX,3+5*MDY,MDX-2,MDY-2
      name="电容校验"
      help="按下以开始用电容校验板调整电容"
      bkcolor=WHITEMAGENTA
    endc
    // Seventh column: tests (continued).
    if $GLOBAL.a5==0 then
      hbust=control BUTTON
        window=hmain
        position=17+6*MDX,3,MDX-2,MDY-2
        name="总线测试"
        help="按下启动总线示波器"
        bkcolor=WHITEMAGENTA
      endc
      hplay=NULL
    else
      hbust=NULL
      hplay=control BUTTON
        window=hmain
        position=17+6*MDX,3,MDX-2,MDY-2
        name="测试"
        help="按下以开始测试解释程序"
        bkcolor=WHITEMAGENTA
      endc
    endif
    hphas=control BUTTON
      window=hmain
      position=17+6*MDX,3+MDY,MDX-2,MDY-2
      name="相位"
      help="按下以测试编码器相位"
      bkcolor=WHITEMAGENTA
    endc
    hrast=control BUTTON
      window=hmain
      position=17+6*MDX,3+2*MDY,MDX-2,MDY-2
      name="针痕"
      help="按下以检查焊盘上的栅格"
      bkcolor=WHITEMAGENTA
    endc
    hlowr=control BUTTON
      window=hmain
      position=17+6*MDX,3+3*MDY,MDX-2,MDY-2
      name="四线"
      help="按下以开始用四线校验板开始低阻校验"
      bkcolor=WHITEMAGENTA
    endc
    optmode=1
    if $LAY.nfing<=0 then              // Call loader if layout unavailable
      SYS.Compile("loader.scr",1)
      //SYS.Start("loader",8,"CHECKONLY")
    endif
    while terminate==0 do
      if Pressed(hopts) then
        optmode=SERV.Options(optmode)
      else if Pressed(hlout) then
        SYS.Compile("layout.scr",1)
        SYS.Start("layout",0,"")
      else if Pressed(hvers) then
        Version()                      // Modal window, call immediately
      else if Pressed(hload) then
        SYS.Compile("loader.scr",1)
        SYS.Start("loader",0,"")
      else if Pressed(hsoft) then
        SYS.Softreset(0)
      else if Pressed(hshut) then
        buf[0]=S_LOADRUN
        buf[1]=0x00;                   // Hard reset
        buf[2]=0x55                    // Shutdown option
        $uint3(buf+3)=0
        SYS.Sendimm(0,6,buf)
      else if Pressed(hvaon) then
        Vacuum(1)                      // Vacuum ON
      else if Pressed(hvaof) then
        Vacuum(0)                      // Vacuum OFF
      else if Pressed(hmove) then
        SYS.Start("debug",5,"MOVE")    // Already compiled - I'm QUITE sure...
      else if Pressed(hptio) then
        SYS.Start("debug",7,"PORTIO")  // Here the same...
      else if Pressed(hlock) then
        s[0]=S_LOCKDOOR;
        s[1]=1;                        // Lock door
        answermode=AWM_NONE;
        SYS.Send(2,s,0)                // Discard the answer
      else if Pressed(hopen) then
        s[0]=S_LOCKDOOR;
        s[1]=0;                        // Unlock door
        answermode=AWM_NONE;
        SYS.Send(2,s,0)                // Discard the answer
      else if Pressed(hxchg) then
        s[0]=S_LOCKDOOR;
        s[1]=2;                        // Prepare to exchange S3 shuttle
        answermode=AWM_NONE;
        SYS.Send(2,s,0)                // Discard the answer
      else if Pressed(hrand) then
        SYS.Start("debug",7,"RANDOM")
      else if Pressed(hvini) then
        SYS.Start("debug",7,"HVINIT")
      else if Pressed(hexri) then
        SYS.Start("debug",8,"EXRINIT")
      else if Pressed(hmsdi) then
        SYS.Start("debug",8,"MSDINIT")
      else if Pressed(hlati) then
        SYS.Start("debug",7,"LAINIT")
      else if Pressed(fcini) then
        SYS.Start("debug",7,"FCINIT")
      else if Pressed(hlini) then
        SYS.Start("debug",7,"RLINIT")
      else if hprot!=NULL && Pressed(hprot) then
        SYS.Compile("xyzprot.scr",1)   // A2 movement protocolling
        SYS.Start("XYZPROT",0,"")
      else if ha5pr!=NULL && Pressed(ha5pr) then
        SYS.Compile("a5prot.scr",1)    // A5 movement oscilloscope
        SYS.Start("A5PROT",0,"")
      else if ha5ms!=NULL && Pressed(ha5ms) then
        SYS.Compile("a5mosc.scr",1)    // A5 measurement oscilloscope
        SYS.Start("A5MOSC",0,"")
      else if ha5mt!=NULL && Pressed(ha5mt) then
        SYS.Compile("a5meas.scr",1)    // A5 measurement card test
        SYS.Start("A5MEAS",0,"")
      else if ha5tr!=NULL && Pressed(ha5tr) then
        SYS.Compile("a5tree.scr",1)    // A5 bus tree
        SYS.Start("A5TREE",0,"")
      else if ha5bt!=NULL && Pressed(ha5bt) then
        SYS.Compile("a5bus.scr",1)     // A5 bus traffic protocol
        SYS.Start("A5BUS",0,"")
      else if ha5st!=NULL && Pressed(ha5st) then
        SYS.Compile("a5state.scr",1)   // A5 state
        SYS.Start("A5STATE",0,"")
      else if Pressed(htest) then
        if $GLOBAL.a5==0 then
          SYS.Compile("selftest.scr",1)
          SYS.Start("SELFTEST",0,"")
        else
          SYS.Compile("a5self.scr",1)
          SYS.Start("A5SELF",0,"")
        endif
      else if Pressed(hioex) then
        SYS.Compile("ioextest.scr",1)
        SYS.Start("IOEXTEST",0,"")
      else if Pressed(hneed) then
        SYS.Compile("needles.scr",1)
        SYS.Start("NEEDLES",0,"")
      else if Pressed(hspst) then
        SYS.Compile("sps.scr",1)
        SYS.Start("SPS",0,"")
      else if Pressed(hspdt) then
        SYS.Compile("speedtst.scr",1)
        SYS.Start("SPEEDTST",0,"")
      else if Pressed(hmest) then
        SYS.Compile("meastest.scr",1)
        SYS.Start("MEASTEST",0,"")
      else if Pressed(hcadj) then
        SYS.Compile("ctest.scr",1)
        SYS.Start("CTEST",0,"")
      else if Pressed(hbust) then
        SYS.Start("debug",0,"BUSTEST")
      else if Pressed(hplay) then
        SYS.Compile("a5mplay.scr",1)
        SYS.Start("A5MPLAY",0,"")
      else if Pressed(hphas) then
        SYS.Compile("a5phases.scr",1)
        SYS.Start("A5PHASES",0,"")
      else if Pressed(hrast) then
        SYS.Compile("raster.scr",1)
        SYS.Start("RASTER",0,"")
      else if Pressed(hlowr) then
        SYS.Compile("lowrtest.scr",1)
        SYS.Start("LOWRTEST",0,"")
      else if Pressed(hquit) then
        break
      endif
      wait
    enddo
  else if Stricmp(s,"MOVE")==0 then
    Move()
  else if Stricmp(s,"PORTIO")==0 then
    if $GLOBAL.a5==0 then
      Portio()
    else
      Portio32()
    endif
  else if Stricmp(s,"PORTIO16")==0 then
    Portio()
  else if Stricmp(s,"PORTIO32")==0 then
    Portio32()
  else if Stricmp(s,"VERSION")==0 then
    Version()
  else if Stricmp(s,"HVINIT")==0 then
    HVinit()
  else if Stricmp(s,"EXRINIT")==0 then
    Exactrinit()
  else if Stricmp(s,"RINIT")==0 then
    Rinit()
  else if Stricmp(s,"MSDINIT")==0 then
    Msdinit()
  else if Stricmp(s,"LAINIT")==0 then
    Lainit()
  else if Stricmp(s,"RLINIT")==0 then
    Rlinit()
  else if Stricmp(s,"FCINIT")==0 then
    FCinit()
  else if Stricmp(s,"RANDOM")==0 then
    Randomtest()
  else if Stricmp(s,"BUSTEST")==0 then
    Bustest()
  endif
end

