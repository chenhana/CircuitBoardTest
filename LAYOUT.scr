#include "ls.icl"
#include "or.icl"
#cmdbuff 6

#define DESCRIPTION "Layout editor"
#define VERSION     "2.28"

// 1.02: A5/A6 Z configuration.
// 1.03: Pressure sensors in General disabled if Z in A5/A6 config is active.
// 1.04: Displays X and Y zero phases.
// 1.05: A5/A6 external antennas.
// 1.06: Own head capacities.
// 1.07: Zero inductance correction.
// 1.08: Thermal parameters in separate pane, removed camera-based jet printer.
// 1.09: Wide top area on A6.
// 1.10: Kelvin probes added, earthquake protection removed.
// 1.11: A5 wide shuttle.
// 1.12: More detailed types of needles.
// 1.13: Inductivity correction parameters.
// 1.14: Wide bottom area on A6.
// 1.15: Separate phases for inductivity at range 0 and 1.
// 1.16: Substitution of heads on A5/A6.
// 1.17: Heads excluded from bootstrap.
// 1.18: Support for A1 (slow A5) tester.
// 1.19: Force 1 mA current in HV measurements.
// 1.20: Strict self-test.
// 1.21: A5/A6 serial connections.
// 1.22: Correction of encoder zeros.
// 1.23: Option to disable contact checks.
// 1.24: Soft landing.
// 1.25: Soft landing corrections.
// 1.26: Support for A5L.
// 1.27: Vacuum box (disables all bottom heads and camera).
// 1.28: Ceramic Z stepper.
// 1.29: Field phase adjustment bit.
// 1.30: Parallel field and capacity verification bit.
// 1.31: Head cameras, head radius.
// 1.32: New Z axis type: completely absent.
// 1.33: Automatical detection of the type of probes (standard or Kelvin).
// 1.34: View needles with the head camera.
// 1.35: Options to calibrate capacity in the air.
// 1.36: MSD corrections replace own C.
// 1.37: A5 type of traffic lights.
// 1.38: Individual C phase corrections.
// 1.39: Support for S1 (A7).
// 1.40: Support for soft Kelvin needles.
// 1.41: LATEST value adjustment factor.
// 1.42: Option to turn off relay acceleration.
// 1.43: Support for L&M automation.
// 1.44: Date of last C adjust.
// 1.45: Option to exclude dedicated cameras.
// 1.46: Learned Z coordinate.
// 1.47: Save button moved to the bottom.
// 1.48: Mains frequency.
// 1.49: Option to save layout to file as text (as yet incomplete).
// 1.50: DSP Config split in 2 separate panels: DSP meas and DSP config.
// 1.51: Encoder autodetection option.
// 1.52: Type of video illumination.
// 1.53: ttyS0 (COM1:) in the list of label printers.
// 1.54: Option to turn off temperature measurements and compensations.
// 1.55: Option to calibrate capacity to shuttle.
// 1.56: Type of Z pressure sensor.
// 1.57: Individual Z pressure corrections for micro parallelogramms.
// 1.58: Parallel LATEST contacting.
// 1.59: Support for S2 and S2a.
// 1.60: Aggressive optimization of X-Y rest time.
// 1.61: Turn off Z optimization.
// 1.62: Insulated shuttle.
// 1.63: Firewire speed.
// 1.64: X-Y accelerations and speeds.
// 1.65: Camera flashlight.
// 1.66: Support for S2 on-heads (no field).
// 1.67: Signal filtering.
// 1.68: Capacity filtering.
// 1.69: Manual L&M shuttle.
// 1.70: S1 motor temperature sensors.
// 1.71: Assume same net for all heads in EXACTR.
// 1.72: Deep Z movements.
// 1.73: Updated printout.
// 1.74: High pressure stroke type.
// 1.75: Graphical needle selection.
// 1.76: Distinction between S2 small and S2 standard (Richie).
// 1.77: Panels are tabs, panel "Experimental", external device support.
// 1.78: Parallel HV measurements.
// 1.79: Basic support for A7/A8 testers.
// 1.80: Option "Disable LUT".
// 1.81: 1000 V HV measurements.
// 1.82: Individual angle corrections for head cameras.
// 1.83: K4 needle as extra type.
// 1.84: Bug: changing filter settings cleared measurement options.
// 1.85: New experimental option "Don't try to home disabled X-Y".
// 1.86: Support for modular multiplexer (EL506).
// 1.87: Check splinogram preload force.
// 1.88: Keep X and Y motors warm to stabilize temperature.
// 1.89: Support for external TCP/IP devices (Agilent E4980A).
// 1.90: Second external device.
// 1.91: Automatic external antenna.
// 1.92: Basic support for S3 tester.
// 1.93: Direction of X encoder.
// 1.94: Z offset for the focus of dedicated camera.
// 1.95: Support for S3 temperature sensor array.
// 1.96: Option to accept noisy EXACTR measurements.
// 1.97: Option to use results of 3-D calibration.
// 1.98: Support for additional layout extentions.
// 1.99: 3-D corrections.
// 2.00: Extended field phase corrections.
// 2.01: Motor temperature monitoring of individual heads.
// 2.02: Heavy high-resolution cameras on S1/S2 testers.
// 2.03: Rearranged controls, new DSP2 & 3D pane.
// 2.04: S3 temperature stabilization parameters.
// 2.05: 32 temperature sensors, wide S3 X top unlock area.
// 2.06: Frequency for inductance measurements.
// 2.07: Password-protected saving if ollytest.ini:[System]:Protection=1.
// 2.08: Different modi for parallel HV contacting.
// 2.09: Different modi for parallel CRT contacting.
// 2.10: Accelerations and velocities for dedicated cameras.
// 2.11: Updated geometry layout, support for split shuttle.
// 2.12: New types of temperature array, up to 128 sensors.
// 2.13: High current for standard R measurements.
// 2.14: On Send extention, sends also main measurement parameters.
// 2.15: Resistance of the needle.
// 2.16: Maximal LATEST Kelvin contact power.
// 2.17: Support for Ethernet cameras.
// 2.18: Kelvin consistency, disconnected cameras.
// 2.19: Support for S3ea.
// 2.20: Dead split shuttle area.
// 2.21: Always same S3 shuttle direction.
// 2.22: Capacity amplitude and phase corrections.
// 2.23: Different levels of Kelvin consistency check.
// 2.24: Corrected possible bug where timeouted answer was accepted.
// 2.25: Backdrill Z offset.
// 2.26: Label rotation.
// 2.27: Warmup pads.
// 2.28: Z acceleration.
#bitmap "logo"<"bk2.bmp"               // miaoyu All bitmaps are compressed

#define VIX            294             // Dimensions of video viewer
#define VIY            274

// Layout configuration bits in $LAY.config.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae
// Alternative (old) interpretation of LC_OHTYPE bits.
#define LC_PHASEADJ    0x00000800      // On-heads with adjustable field phase
#define LC_ACTIVEONHD  0x00000400      // Active on-heads (with Dallas/R1-R4)
// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMSPLIT     0x20000000      // L&M auto split shuttle
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_TMASK       (LC_TYPEMASK|LC_ISM2|LC_HIGHZ|LC_LDELAY)

// Bits in t_extlay.extcfg.
#define EXT_CHECKZERO  0x00000001      // Correct X-Y zero pulses on soft reset
#define   EXT_CHECKALL 0x00000002      // Correct zero pulses of all heads
#define EXT_FASTRESET  0x00000004      // Optimize soft reset
#define EXT_NOZLIMIT   0x00000008      // Accept very deep contacts
#define EXT_YTODEFBRD  0x00000010      // Limit Y movements to DEFBOARD
#define EXT_3DCOR      0x00000020      // Use 3-D corrections
#define EXT_NOMISSPCB  0x00000040      // Don't report missing PCB
#define EXT_CONTAIR    0x00000100      // Individual no contact capacity in air
#define EXT_CAIR       0x00000200      // Field/capacity correction in the air
#define EXT_CRTAIR     0x00000400      // CRT correction in the air
#define EXT_LAPAR      0x00000800      // Parallel LATEST contacting is allowed
#define EXT_EPAR       0x00001000      // Pads in EXACTR belong to same net
#define EXT_HVPARMASK  0x00202000      // Mask to extract parallel HV contacting
#define   EXT_HVGROUP  0x00000000      // As specified by panel/group/net
#define   EXT_HVPARAL  0x00002000      // Parallel HV contacting is allowed
#define   EXT_HVNOPAR  0x00200000      // Parallel HV contacting is disabled
#define   EXT_HVPANEL  0x00202000      // No parallel HV, except diff panels
#define EXT_NOLUT      0x00004000      // Disable use of camera LUT
#define EXT_WIDEXTOP   0x00008000      // Wide top X unlock area on S3
#define EXT_S3YMASK    0x00030000      // Mask to extract disabled S3 Y motors
#define   EXT_S3YLOFF  0x00010000      // Turn off left S3 Y shuttle motor
#define   EXT_S3YROFF  0x00020000      // Turn off right S3 Y shuttle motor
#define EXT_HCAMOFF    0x00100000      // Cycle camera power on comm error
#define EXT_CRTPMASK   0x00C00000      // Mask to extract parallel CRT
#define   EXT_CRTGRP   0x00000000      // As specified by panel/group/net
#define   EXT_CRTPAR   0x00400000      // Parallel CRT contacting is allowed
#define   EXT_CRTNOP   0x00800000      // Parallel CRT contacting is disabled
#define   EXT_CRTPNL   0x00C00000      // No parallel CRT, except diff panels
#define EXT_FIXSHDIR   0x01000000      // Shuttle approach from same direction
#define EXT_ROTLABEL   0x02000000      // Rotate label
#define EXT_DEFINED    0x80000000      // (Internal) Extended layout defined

// Bits in t_extlay.xheadtype and t_config.xtype.
#define HCX_VALID      0x80000000      // X axis type in layout valid
#define HCX_TYPEMAJOR  0x0F000000      // Major part of type (algorithms)
#define   HCX_STD      0x00000000      // Standard X drive
#define   HCX_A1       0x01000000      // A1 (slower A5)
#define   HCX_LIN      0x02000000      // Linear motor with long steps
#define HCX_TYPEMINOR  0x00F00000      // Minor part of type (parameters)
#define   HCX_STDPOW   0x00000000      // Standard driver
#define   HCX_HIPOW    0x00100000      // High-power (6A) S2 driver
#define HCX_ENCTYPE    0x000000F0      // Mask to extract X encoder type
#define   HCX_ENCDEF   0x00000000      // Default X encoder for given tester
#define   HCX_ENCOPEN  0x00000010      // Open-form X encoder, 40 um step
#define   HCX_ENCAUTO  0x000000F0      // Automatic type detection
#define HCX_OPTMASK    0x0000000F      // Mask to extract X options
#define   HCX_NOHOME   0x00000008      // Don't home X-Y if both are disabled
#define   HCX_TSENS    0x00000004      // Monitor temperature of the motors
#define   HCX_POWERLIM 0x00000002      // Limit simultaneous head acceleration
#define   HCX_OPTWAIT  0x00000001      // Aggressive X-Y rest optimization

// Bits in t_extlay.yheadtype and t_config.ytype.
#define HCY_VALID      0x80000000      // Y axis type in layout valid
#define HCY_TYPEMAJOR  0x0F000000      // Major part of type (algorithms)
#define   HCY_PGRAM    0x00000000      // Machined parallelogramm
#define   HCY_STEPPER  0x01000000      // Stepper
#define   HCY_VIDEO    0x0C000000      // Standard video camera
#define HCY_TYPEMINOR  0x00F00000      // Minor part of type (parameters)
#define   HCY_PG6GRAY  0x00000000      // Gray A6 parallelogramm, radius 115 mm
#define   HCY_PG5GRAY  0x00100000      // Gray A5 parallelogramm, radius 150 mm
#define   HCY_CER7HI   0x00100000      // S1 stepper with hi-res cam, 115 mm
#define   HCY_CER7     0x00200000      // S1 ceramic stepper, radius 115 mm
#define   HCY_COMPOS   0x00300000      // A8 composite finger, radius 115 mm
#define   HCY_COMPOL   0x00400000      // A8 composite finger, radius 180 mm
#define   HCY_A6VIDEO  0x00000000      // A6 video camera
#define   HCY_A5VIDEO  0x00100000      // A5 video camera
#define HCY_TYPEMASK   0x0FF00000      // Mask to extract type of finger
#define HCY_SENSMASK   0x00000F00      // Mask to extract type of end sensor
#define   HCY_SENSBOT  0x00000000      // Sensor in the direction of low Y
#define   HCY_SENSTOP  0x00000100      // Sensor in the direction of high Y
#define HCY_OPTMASK    0x0000000F      // Mask to extract Y options
#define   HCY_MINPRINT 0x00000001      // Attempt to minimize witness marks

// Bits in t_extlay.zheadtype, t_extlay.zheadbot and t_config.ztype.
#define HCZ_VALID      0x80000000      // Z axis type in layout valid
#define HCZ_TESTPRLD   0x40000000      // Test pressure preload
#define HCZ_TYPEMAJOR  0x0F000000      // Major part of type (algorithms)
#define   HCZ_TMAJORA  0x00000000      // Parallelogramm with magnetoresistor
#define   HCZ_TMAJORC  0x01000000      // Ceramic stepper with Hall sensors
#define   HCZ_TMAJORL  0x02000000      // Linear motor with encoder
#define HCZ_TYPEMINOR  0x00F00000      // Minor part of type (parameters)
#define HCZ_TYPEMASK   0x0FF00000      // Mask to extract type of finger
#define   HCZ_TYPEA2G  0x00000000      // A2 gray parallelogramm
#define   HCZ_TYPEA2W  0x00100000      // A2 white parallelogramm
#define   HCZ_TYPEA3   0x00200000      // A3 gray parallelogramm
#define   HCZ_TYPECER  0x01000000      // S1 ceramic stepper with air bearings
#define   HCZ_TYPELIN  0x02000000      // A8 linear motor
#define   HCZ_TYPENO   0x0FF00000      // Z axis completely absent
#define HCZ_PWRMASK    0x000C0000      // Mask to extract Z motor power
#define   HCZ_PWRSTD   0x00000000      // Standard motor
#define HCZ_SUBCMASK   0x00030000      // Mask to extract needle subtype
#define   HCZ_SPLK4    0x00010000      // HCZ_CONTSPL is very soft K4 needle
#define HCZ_CONTMASK   0x0000FF00      // Mask to extract type of needle
#define   HCZ_CONTDEF  0x00000000      // Default needle, no contact sensor
#define   HCZ_CONTSPL  0x00000100      // Soft splinogramm with opto sensor
#define   HCZ_CONTHSPL 0x00000200      // Hard splinogramm with opto sensor
#define   HCZ_CONTEMU  0x00000400      // Standard needle on soft touch adapter
#define   HCZ_CONTHPS  0x00000500      // Hard touch needle with opto sensor
#define   HCZ_CONTSTD  0x00000800      // Standard needle, developed by IBM
#define   HCZ_CONTSKP  0x00001000      // Soft Kelvin with two parallelogramms
#define HCZ_STRMASK    0x000000F0      // Mask to extract Z stroke type
#define   HCZ_STRNORM  0x00000000      // Normal stroke
#define   HCZ_STRSOFT  0x00000010      // Soft stroke
#define   HCZ_STRHARD  0x00000020      // Hard stroke
#define   HCZ_LEARNZ   0x00000030      // Learned Z coordinate
#define   HCZ_HIPRESS  0x00000040      // High pressure with splinogramms
#define HCZ_DMSMASK    0x0000000C      // Mask for type of pressure sensor
#define   HCZ_DMSSTD   0x00000000      // Standard or no pressure sensor
#define   HCZ_DMSREV   0x00000004      // Pressure sensor with reverse signal
#define   HCZ_DMSAUTO  0x0000000C      // Autodetect type of pressure sensor
#define HCZ_OPTMASK    0x00000003      // Mask to extract Z options
#define   HCZ_NOOPT    0x00000002      // Do not optimize Z height
#define   HCZ_PARKZ    0x00000001      // Park top Z axes in home position

#define HCZ_XCONTMASK  (HCZ_CONTMASK|HCZ_SUBCMASK)

#define HCM_HV1MA      0x00000001      // Force 1 mA during HV measurements
#define HCM_STRICT     0x00000002      // 20% stricter self-test
#define HCM_NOCTCHK    0x00000004      // Don't check contacts (except ExactR)
#define HCM_PARCONT    0x00000008      // Check influence of parallel contacting
#define HCM_NOACCEL    0x00000010      // Do not accelerate reed relays
#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements
#define HCM_CTOEXT     0x00000040      // Calibrate capacity to shuttle (extant)
#define HCM_ISOEANT    0x00000080      // External antennas isolated
#define HCM_FILTMASK   0x00000F00      // Mask to extract signal filtering
#define   HCM_FNONE    0x00000000      // No signal filtering
#define   HCM_F500K    0x00000100      // 500 kHz filter
#define   HCM_F100K    0x00000200      // 100 kHz filter
#define   HCM_F20K     0x00000300      // 20/50 kHz filter
#define HCM_FILTERC    0x00001000      // Filter C measurements over 300 pF
#define HCM_EXRLONG    0x00002000      // Long EXACTR with 300 mA source
#define HCM_AUTOEANT   0x00004000      // Automatic antenna 0 for all C
#define HCM_HVTYPE     0x000F0000      // Mask to extract type of HV elecronics
#define   HCM_HV500    0x00000000      // Card is capable of 500 V HV
#define   HCM_HV1000   0x00010000      // Card is capable of 1000 V HV
#define   HCM_HVAUTO   0x00070000      // Autodetect HV capabilities
#define HCM_DISCONN    0x00100000      // Disconnect from bus after measurement
#define HCM_EXRNOISY   0x00200000      // Accept noisy EXACTR measurements
#define HCM_TFILTOFF   0x00400000      // Turn off temperature history filtering
#define HCM_HIGHIR     0x00800000      // High current in M_RMEAS
#define HCM_DETAILS    0x01000000      // Report details of measurements
#define HCM_CONSMASK   0x06000000      // Mask to extract Kelvin consistency
#define   HCM_CSNONE   0x00000000      // No Kelvin consistency checks
#define   HCM_CSLOW    0x02000000      // Check consistency of Kelvin meas
#define   HCM_CSMED    0x04000000      // Medium Kelvin consistency
#define   HCM_CSHIGH   0x06000000      // Paranoidal Kelvin consistency check

#define HCF_VALID      0x80000000      // Firewire options in layout valid
#define HCF_ISPEED     0x000000F0      // Mask to extract isochronous speed
#define   HCF_I800     0x00000030      // 800 MBit/s isochronous speed
#define   HCF_I400     0x00000020      // 400 MBit/s isochronous speed
#define   HCF_I200     0x00000010      // 200 MBit/s isochronous speed
#define   HCF_I100     0x00000000      // 100 MBit/s isochronous speed
#define HCF_ASPEED     0x0000000F      // Mask to extract asynchronous speed
#define   HCF_A400     0x00000002      // 400 MBit/s asynchronous speed
#define   HCF_A200     0x00000001      // 200 MBit/s asynchronous speed
#define   HCF_A100     0x00000000      // 100 MBit/s asynchronous speed

#define HCA_TARRAY     0xF0000000      // Mask for array of temperature sensors
#define   HCA_TANONE   0x00000000      // Temperature array absent
#define   HCA_TADEF    0x10000000      // Array on /dev/atgtarray
#define   HCA_TAUSB0   0x20000000      // Array on /dev/ttyUSB0
#define   HCA_TAUSB1   0x30000000      // Array on /dev/ttyUSB1
#define   HCA_TAUSB2   0x40000000      // Array on /dev/ttyUSB2
#define   HCA_TAUSB3   0x50000000      // Array on /dev/ttyUSB3
#define   HCA_TAS1     0x60000000      // Array on /dev/ttyS1
#define   HCA_TAS0     0x70000000      // Array on /dev/ttyS0
#define HCA_EXTDEV1    0x0F000000      // Mask for external device port 1
#define   HCA_E1NONE   0x00000000      // No external device
#define   HCA_E1DEF    0x01000000      // Device on /dev/atgext
#define   HCA_E1USB0   0x02000000      // Device on /dev/ttyUSB0
#define   HCA_E1USB1   0x03000000      // Device on /dev/ttyUSB1
#define   HCA_E1USB2   0x04000000      // Device on /dev/ttyUSB2
#define   HCA_E1USB3   0x05000000      // Device on /dev/ttyUSB3
#define   HCA_E1S1     0x06000000      // Device on /dev/ttyS1
#define   HCA_E1S0     0x07000000      // Device on /dev/ttyS0
#define   HCA_E1TCP0   0x08000000      // Device on network location 0
#define   HCA_E1TCP1   0x09000000      // Device on network location 1
#define HCA_TAMASK     0x00C00000      // Mask to extract type of T array
#define   HCA_TAACTIVE 0x00000000      // Active (sends data without request)
#define   HCA_TATYPE1  0x00400000      // Must be asked to send data
#define   HCA_TATYPE2  0x00800000      // Not yet defined
#define   HCA_TATYPE3  0x00C00000      // Not yet defined
#define HCA_BARGOOD    0x00200000      // Move barcodes to good pile
#define HCA_NOBARCODE  0x00100000      // Turn off A5a input barcode reading
#define HCA_TRAFFIC    0x00070000      // Mask for type of traffic lights
#define   HCA_TRSTD    0x00000000      // Standard traffic lights
#define   HCA_TRALLIED 0x00010000      // Allied-style traffic lights
#define   HCA_TREPCOS  0x00020000      // EPCOS-style traffic lights
#define   HCA_TRATS    0x00030000      // AT&S-style traffic lights
#define HCA_EXTDEV0    0x0000F000      // Mask for external device port 0
#define   HCA_E0NONE   0x00000000      // No external device
#define   HCA_E0DEF    0x00001000      // Device on /dev/atgext
#define   HCA_E0USB0   0x00002000      // Device on /dev/ttyUSB0
#define   HCA_E0USB1   0x00003000      // Device on /dev/ttyUSB1
#define   HCA_E0USB2   0x00004000      // Device on /dev/ttyUSB2
#define   HCA_E0USB3   0x00005000      // Device on /dev/ttyUSB3
#define   HCA_E0S1     0x00006000      // Device on /dev/ttyS1
#define   HCA_E0S0     0x00007000      // Device on /dev/ttyS0
#define   HCA_E0TMC0   0x00008000      // Device on /dev/usbtmc0
#define   HCA_E0TMC1   0x00009000      // Device on /dev/usbtmc1
#define HCA_LABEL      0x00000F00      // Mask for LINX or label printer port
#define   HCA_LNONE    0x00000000      // Printer absent
#define   HCA_LDEF     0x00000100      // Printer on /dev/atglabel
#define   HCA_LUSB0    0x00000200      // Printer on /dev/ttyUSB0
#define   HCA_LUSB1    0x00000300      // Printer on /dev/ttyUSB1
#define   HCA_LUSB2    0x00000400      // Printer on /dev/ttyUSB2
#define   HCA_LUSB3    0x00000500      // Printer on /dev/ttyUSB3
#define   HCA_LS1      0x00000600      // Printer on /dev/ttyS1
#define   HCA_LS0      0x00000700      // Printer on /dev/ttyS0
#define HCA_BAR1       0x000000F0      // Mask for bar code scanner 1
#define   HCA_B1NONE   0x00000000      // Bar code scanner 1 absent
#define   HCA_B1DEF    0x00000010      // Scanner 1 on /dev/atgscan1
#define   HCA_B1USB0   0x00000020      // Scanner 1 on /dev/ttyUSB0
#define   HCA_B1USB1   0x00000030      // Scanner 1 on /dev/ttyUSB1
#define   HCA_B1USB2   0x00000040      // Scanner 1 on /dev/ttyUSB2
#define   HCA_B1USB3   0x00000050      // Scanner 1 on /dev/ttyUSB3
#define HCA_BAR0       0x0000000F      // Mask for bar code scanner 0
#define   HCA_B0NONE   0x00000000      // Bar code scanner 0 absent
#define   HCA_B0DEF    0x00000001      // Scanner 0 on /dev/atgscan0
#define   HCA_B0USB0   0x00000002      // Scanner 0 on /dev/ttyUSB0
#define   HCA_B0USB1   0x00000003      // Scanner 0 on /dev/ttyUSB1
#define   HCA_B0USB2   0x00000004      // Scanner 0 on /dev/ttyUSB2
#define   HCA_B0USB3   0x00000005      // Scanner 0 on /dev/ttyUSB3

#define HCS_YMASK      0x00000003      // Mask to extract Y motor type
#define   HCS_YMDEF    0x00000000      // Default Y motor
#define   HCS_YMDBL    0x00000001      // Double Y motor

// Type and layout of multiplexer.
#define MUX_TYPEMASK   0xF0000000      // Mask to extract type of multiplexer
#define   MUX_TYPE406  0x00000000      // EL406 (16 outputs)
#define   MUX_TYPE506  0x10000000      // EL506 (modular)
#define MUX_MODCOUNT   0x0F000000      // Mask to extract number of modules
#define MUX_EXTERN5    0x00038000      // Mask for Card2:Ext2, MUXEXT_xxx
#define MUX_EXTERN4    0x00007000      // Mask for Card2:Ext1, MUXEXT_xxx
#define MUX_EXTERN3    0x00000E00      // Mask for Card1:Ext2, MUXEXT_xxx
#define MUX_EXTERN2    0x000001C0      // Mask for Card1:Ext1, MUXEXT_xxx
#define MUX_EXTERN1    0x00000038      // Mask for Card0:Ext2, MUXEXT_xxx
#define MUX_EXTERN0    0x00000007      // Mask for Card0:Ext1, MUXEXT_xxx

#define MUXEXT_NONE    0               // External output is unassigned
#define MUXEXT_TSENS   1               // External output is temperature sensor
#define MUXEXT_ANT1    2               // External output is antenna 1
#define MUXEXT_ANT2    3               // External output is antenna 2
#define MUXEXT_EXTDEV  4               // External output is external device
#define MUXEXT_SHORT   5               // External output is shortcut
#define MUXEXT_UCONN   6               // External output connects to U sources

// Permanent debugging options in t_extlay.debugopt.
#define DBO_DUMPLABEL  0x00000100      // Dump communication with label printer
#define DBO_DUMPRESET  0x00000200      // Dump bus resets

#define ILL_DEFAULT    0x00            // Default (camera) illumination
#define ILL_EXTERN     0x01            // External (LED stripes)
#define ILL_MIXED      0x02            // Cameras and LED stripes
#define ILL_EXTON      0x03            // External, permanently on
#define ILL_FLASH      0x04            // Camera flashlight
#define ILL_FLASHMIX   0x05            // Camera flashlight and LED stripes on

#define EXTS_EXACTR    0x00000001      // Redirect EXACTR to external device
#define EXTS_UNIC      0x00000010      // Redirect UNIC to external device
#define EXTS_RLMEAS    0x00000100      // Redirect RLMEAS to external device
#define EXTS_CAL       0x1000          // Calibrate external device

#define EXTD_NONE      0               // No external device attached
#define EXTD_HM8118    1               // Hameg HM8118 bridge
#define EXTD_AG4980    2               // Agilent E4980A meter

#define HO_CAMOFF      0x04            // Headcam installed but disconnected
#define HO_HIRES       0x01            // Heavy high-resolution S2 camera

#define NT_UNKNOWN     0               // Unspecified needle type
#define NT_HARD        1               // Solid hard touch
#define NT_HARDADAPT   2               // Hard touch adapter
#define NT_SPLINO      3               // Splinogramm
#define NT_MICROMIRR   4               // Microprobe with mirror
#define NT_MICRO       5               // Microprobe with transmissive sensor
#define NT_KELVMIRR    6               // Kelvin microprobe with mirror
#define NT_KELVIN      7               // Kelvin with transmissive sensor
#define NT_LATEST      8               // Kelvin with mirror and blades
#define NT_K4SPLINO    9               // K4 splinogramm
#define NT_MICROSHLD   10              // Shielded microprobe, transmissive
#define NT_HARDPS      11              // Hard touch needle with pressure sensor

#define NNEEDLE        11              // Number of different needle types
#define NEEDLEX        280             // Width of needle image, pixels
#define NEEDLEY        280             // Height of needle image, pixels
#define NEEDLEBX       8               // X border between needles
#define NEEDLEBY       6               // Y border around needles

typedef struct t_layout $LAY;          // Create compatible layout types
typedef struct t_extlay $EXTLAY;
typedef struct t_ext0   $EXT0;         // First additional layout extention
typedef struct t_ext1   $EXT1;         // Second additional layout extention
typedef struct t_ext2   $EXT2;         // Third additional layout extention
typedef struct t_ext3   $EXT3;         // Fourth additional layout extention

// Handles of controls in the main window or in multiple panes.
handle hmain,hparm,hcard,hwrite,hprint,hsendext,hexit,hquit
handle hgeneral,hhead[16][2],hshuttle,hallon,halloff
// Handles of controls in the General window.
handle htype,hrails,hrscroll,hcameras,hcscroll,hsernumb,hlabel,hrotlabel
handle hantennas,hshtype,hipaddr,hsocket,hshant,htraffic,hvacuumbox,hfingtype
handle hpress,hhardcontact,hnooversurf,hantx,haxscroll,hanty,hayscroll
handle hget,hread,hpassword,hinform,hpassive,hampl,hphase,hnofield
handle hsplit,hautosplit,hslow,hfastreset,hcheckzero,hcheckall,haltlights
handle hautolights,hautodeadlock,hwidetop,hwidebot,hlayoutname,hbrowse
// Handles of controls in the Geometry window.
handle hgeochild,hleftlimit,hrightlimit,hcenterx,hradius,hcamradius
handle hvideodead,hdeadsplit,henable,hside,hchgside,hxenc,hchgxenc
handle hysens,hchgysens,hbackdrill,htoplimit,hcentery,hbottomlimit
handle hwarmupx,hwarmupy,hwarmupdx,hwarmupdy,hheadcamera,hcether,hcmac,hcangle
handle hxshift,hyshift,hzshift,hyshuttle,hyunlock,hyauto,hyoffset
handle hybase[2],hshuttlel,hshuttler,hup,hdown,hleft,hright,hshow
handle hsetdef,hdeftester,hviewer,htouch,hviewfing,hbrightness,hcontrast
handle hmirror,hzoom
// Handles of controls in the Thermic window.
handle hcaldate,hcaltemp,hcadjdate,htmeason,hthermexp,hpresscor
handle hchecktemp,htfiltoff,htemphead[32],hallthon,hallthoff,haclient
handle harraypos[128],htemphtop,htemphbot,htempvtop,htempvbot
handle hsetcurdate,hsetcadjdate
// Handles of controls in the Measurements window.
handle hi300ma,hcurrent[9],hvoltage[6],hr100k,hrzero,hkelvzero,hmainsf
handle hlzero,hlrshift,hlphase0,hlphase1,hlfreq,hfrequency,hclowest
handle hradj,hrneedle,hsinadj,hcosadj,hcphadj,hpfactor,hcrtadj,hpcorr
handle hbdccorr,hbdcfact,hbdczofs,hvcard,hvmax,hcrtumax,hdefaults
handle hlaadj,hlapower,hcshlimit
// Handles of controls in DSP measurement config 1 window.
handle hmuxtype,hmuxaux[6],hsubston[4],hsubsthead[4],hsubstpos[4]
handle hparcont,h1mahv,hnoaccel,hstrict,hdisconn,hnocont,hcontair,hcair
handle hcrtair,hcshuttle,hcfilter,hhvpar,hcrtpar,hlapar,hexactrpar,hexrlong
handle hexrnoisy,hkelvcons,hextant1,hextant2,hisoeant,hautoeant,hfilter
// Handles of controls in DSP measurement config 2 window.
handle hcphase[4],hcfact[4],huin,hfphcorr,hfccorr,husetd
handle h3dxy,h3dyy,h3dxz,h3dyz,hextdev0,hcal0,hsubstr0,hsubstc0,hsubstl0
handle hextdev1,hcal1,hsubstr1,hsubstc1,hsubstl1
handle hconntype[4],huout[4],hconnvalue[4],hconnpreset,hcptype
// Handles of controls in A5/A6 hardware config window.
handle husezparm,hselectneedle,hactuator,hstroke,hneedle,hsensor
handle hdiffbot,hselectbottom,hneedlebot,hsensorbot,hpreload,hnozlim
handle hxdriver,hxstep,hlimitx,hyshmotor,hprinter,hprintprot
handle hscaner0,hscaner1,hconfig,hillum,hbritop,hbriskew,hignorebcode
handle hbargood,hserdev0,hserdev1,htarray,htatype,htcpaddr0,htcpport0
handle htcpaddr1,htcpport1,hneedlesel,hneedleband,hneedlename
handle hneedlesens,hneedlepins,hneedlepart,hneedleset
// Handles of controls in Experimental config window.
handle hxaccel,hxvelo,hyaccel,hyvelo,hcamxa,hcamxv,hcamya,hcamyv
handle hzaccel,hzaccels,hreducea,hreduceas,hwidextop,hlimtodef
handle hignorexy,hyoff,hnoopt,hlimitfw,hfwiso,hfwasync,hwarmx,hwarmy
handle hparkz,hoptprint,haggressive,hnolut,hcamoff,hhighir,hdetails
handle hresets,hnomiss,hshdir,hreinit,hdelayslow

// Default measurement parameters and corresponding multiplicators.
float  currfactor[9] = { 1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6,                    \
  1.0e3, 1.0e3, 1.0e3, 1.0e3 }
float  voltfactor[6] = { 1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e3, 1.0e3 }
int    defcurr[9] = { 100000000, 30000000, 10000000, 3000000,                  \
  1000000, 300000, 100000, 30000, 10000 }
int    defvolt[6] = {  9000000, 900000, 10000000, 1000000, 100000, 10000 }

// Local working copy of tester layout.
struct t_layout l
struct t_extlay lx
struct t_ext0   lx0
struct t_ext1   lx1
struct t_ext2   lx2
struct t_ext3   lx3

// Needle data:
// FFFFFFFF III P K N T U X PPP             AAA..., where:
// +00 FFF - name of the bitmap file
// +09 III - index, unique number describing type of the needle
// +13 P   - type of pressure sensor (N-none, D-direct, M-mirror, I-inverted)
// +15 K   - S for single-pin needles and K for Kelvin
// +17 N   - B for blades and P for pins
// +19 T   - basic type (H-hardtouch, A-adapter, S-splinogram, M-micro,
//           P-hard with pressure sensor)
// +21 U   - needle subtype, digit equal to HCZ_SUBCMASK in layout
// +25 PPP - atg part number
// +41 AAA - name of the needle type
char   nddata[NNEEDLE,80] = {                                                  \
  "ndhard   001 N S P H     G111K0012       Hard touch",                       \
  "ndhadapt 002 N S P A     G111K0011       硬针转接头",                     \
  "ndsplino 003 D S P S 0   G111K0001       标准软针",              \
  "ndsplk4  009 D S P S 1   G111K0002       特殊软针",                    \
  "ndmicmir 004 M S P M     G111K0003       微针",                      \
  "ndmicro  005 I S P M     G111K0004       微针",                      \
  "ndmicro  010 I S P M     G111K0005       微屏蔽针",                   \
  "ndkelmir 006 M K P M     G111K0006       开尔文",                           \
  "ndkelvin 007 I K P M     G111K0007       开尔文",                           \
  "ndkblmir 008 M K B M     G111K0010       硬针",                           \
  "ndhardps 011 D S P P     G111K0009       带感应器硬针" }

char busname[4][8] =  { "U/I", "MINUS", "PLUS", "GND" }
// Other global variables.
int    layoutchanged                   // 1: $LAY structure changed externally
int    probetypechanged                // 1: $LAY.probetype changed externally
int    showgeneral                     // General information selected
int    showshuttle                     // Shuttle selected
int    rail,finger                     // Currently selected head/camera/printer
int    railbtn                         // Currently selected row of buttons
int    deftester                       // Currently selected default tester
int    step
int    videoon                         // Video is present on the screen
int    viewfing                        // View fingers with camera, if nonzero
int    mirror                          // Mirror video on back side, if nonzero
float  zoom                            // Video zoom (0.5 or 1)
char   layoutname[260]                 // Layout name
int    selectneedle                    // 1: needle selection mode
int    needlesel                       // Index of selected needle type
int    needledraw                      // Redraw needle selection panel
int    needlescroll                    // Requested needle selection position
int    runscroll                       // Needle selector movement active
int    prevbuttons                     // Previous state of mouse buttons
char   wordofwisdom[64]                // Never mind
int    cptype                          // Type of connection preset
int    scanshift                       // Shift of positioning cross, mm
int    touchmode                       // Touching mode


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// SERVICE ROUTINES ///////////////////////////////

// Necessary here to receive the broadcast messages.
function int Answerproc(char *answer,int info)
  if answer[4]==0xF0 then              // Broadcast message came
    if (Stricmp(answer+5,"CHG LAY")==0 && l.nfing==0) layoutchanged=1
    if (Stricmp(answer+5,"CHG PROBE")==0) probetypechanged=1
  endif
end

// Display modal "dialog box" with error message.
function int Error(char *s1,char *s2)
  handle herr,hdummy,hok
  herr=control WINDOW
    window=hmain
    position=0,0,250,135
    name="提示"
    mode=M_MODAL
    bkcolor=WHITEBLUE
  endc
  hok=control WINBUTTON
    window=herr
    position=85,90,80,24
    name="确定"
    help="按下可以确认错误消息"
  endc
 // hdummy=control ICON
 //   window=herr
 //   position=5,30,36,36
 //   name="EXCLAM"
 //   bkcolor=WHITEBLUE
 // endc
  hdummy=control TEXT
    window=herr
    position=35,40,200,24
    name=s1
    bkcolor=WHITEBLUE
    mode=M_CENTERED
  endc
 //hdummy=control TEXT
 //  window=herr
 //  position=41,45,200,54
 //  name=s2
 //  bkcolor=WHITEBLUE
 //  mode=M_CENTERED
 //endc
  while Pressed(hok)==0 do; enddo
  destroy herr
end

// Create internal copy of tester layout.
function int Makelayoutcopy(char *s,char *exts,                                \
  char *e0,char *e1,char *e2,char *e3)
  Memcpy(l,s,Sizeof(l))
  Memcpy(lx,exts,Sizeof(lx))
  Memcpy(lx0,e0,Sizeof(lx0))
  Memcpy(lx1,e1,Sizeof(lx1))
  Memcpy(lx2,e2,Sizeof(lx2))
  Memcpy(lx3,e3,Sizeof(lx3))
end

// Copyback internal copy of layout.
function int Updatelayout(char *s,char *exts,                                  \
  char *e0,char *e1,char *e2,char *e3)
  Memcpy(s,l,Sizeof(l))
  Memcpy(exts,lx,Sizeof(lx))
  Memcpy(e0,lx0,Sizeof(lx0))
  Memcpy(e1,lx1,Sizeof(lx1))
  Memcpy(e2,lx2,Sizeof(lx2))
  Memcpy(e3,lx3,Sizeof(lx3))
end

// Sends layout extensions (lx and lx0) to tester.
function int Sendextention()
  int t,cratefeatures
  char buf[1024]
  // Check whether additional layout extentions are suppored.
  cratefeatures=0
  if $GLOBAL.a5!=0 then                // Unavailable for A2
    SYS.Killimm(1)
    buf[0]=S_INPORT32
    buf[1]=0xFF                        // Crate controller
    $uint4(buf+2)=0x10000012           // Query crate features
    SYS.Sendimm(1,6,buf)
    t=Time()
    while $A[1].length==0 do
      if Time()-t>2000 break           // Timeout
      wait
    enddo
    if $A[1].answer!=S_INPORT32 then
      Error("校验板无响应","")
      return
    endif
    cratefeatures=$uint4($A[1]+5)
  endif
  SYS.Killimm(1)
  if cratefeatures & 0x100 then
    // I reload extention without checking whether it is all zero. Maybe we
    // have just edited it to all zeros?
    buf[0]=S_LOADRUN
    buf[1]=20                          // Reload layout extention
    $int4(buf+2)=0                     // First additional extention
    Memcpy(buf+6,lx0,Sizeof(lx0))
    SYS.Sendimm(1,6+Sizeof(lx0),buf)
    buf[0]=S_LOADRUN
    buf[1]=20                          // Reload layout extention
    $int4(buf+2)=1                     // Second additional extention
    Memcpy(buf+6,lx1,Sizeof(lx1))
    SYS.Sendimm(2,6+Sizeof(lx1),buf)
    t=Time()
    while $A[1].length==0 || $A[2].length==0 do
      if Time()-t>5000 break           // Timeout 5 seconds
      wait
    enddo
    if $A[1].answer!=S_LOADRUN || $A[2].answer!=S_LOADRUN then
      Error("发送文件失败，请先读取资料数据","to tester")
      return
    endif
  endif
  buf[0]=S_LOADRUN
  buf[1]=15                            // Reload layout extention
  $int4(buf+2)=0                       // Dummy operand
  Memcpy(buf+6,lx,Sizeof(lx))          // Layout extention
  SYS.Sendimm(1,6+Sizeof(lx),buf)
  if $GLOBAL.a5!=0 then                // Unavailable for A2
    SYS.Killimm(2)
    buf[0]=S_LOADRUN
    buf[1]=4                           // Reload measurement parameters
    $int4(buf+2)=0                     // Dummy operand
    Memcpy(buf+6,l,Sizeof(l))          // Layout extention
    SYS.Sendimm(2,6+Sizeof(l),buf)
  endif
  t=Time()
  while $A[1].length==0 do
    if Time()-t>5000 break             // Timeout 5 seconds
    wait
  enddo
  if $GLOBAL.a5!=0 then
    while $A[2].length==0 do
      if Time()-t>5000 break           // Total timeout 5 seconds
      wait
    enddo
  endif
  if $A[1].answer!=S_LOADRUN ||                                                \
    ($GLOBAL.a5!=0 && $A[2].answer!=S_LOADRUN)                                 \
  then
    Error("发送文件失败","to tester")
    return
  endif
end

// Given head, returns associated video channel, or -1 if head is invalid or
// carries no camera.
function int Channelfromhead(int head)
  int i,channel
  if l.cameras!=0 then                                                          // CHECK FOR THE CASE OF S3!!!!!!!
    if head==l.nfing*2 return 0
    if head==l.nfing*2+1 return 1
  else if (l.headcameras & (1<<head))!=0 then
    channel=0
    for i=0,i<head,i++ do
      if (l.headcameras & (1<<i))!=0 channel++
    enddo
    return channel
  endif
  return -1
end



////////////////////////////////////////////////////////////////////////////////
////////////////////////////// MAIN SCRIPT WINDOW //////////////////////////////
#define BUTTONY        5
// Create main window.
function int Createmain()
  
  int maxx,maxy
  
  maxx = 860 // 610
  maxy = 700 // 479
  hmain=control WINDOW
    window=NULL
    position=10,10,maxx, maxy//610,400//479
    name=format("参数设置")
    help=" "
    bkcolor=WHITE // miaoyu GRAY
  endc

  // miaoyu added 06-06
  hparm=control CHILD
    window=hmain
    position=2,46,850,620//421
    help=" "
    color=WHITE
    //bkcolor=LIGHTGRAY // miaoyu WHITEGREEN
    size=4096
    
      //mode=M_VSCROLL|M_HSCROLL
      limits=maxx,maxy 
  endc

  // miaoyu added 06-06
//  hcard=control CARD
//    window=hmain
//    position=2,46,850,620  // 0,1,610,450
//    help="选择要配置的内容"
//    mode=M_NOTAB                       // Replaces tabs by buttons
//  endc
  
  add hcard text="常规"
  add hcard text="坐标"
  add hcard text="温度"
  add hcard text="测量"
  add hcard text="功能1"
  add hcard text="功能2"
  add hcard text="配置"
  add hcard text="试验"
  
  
  // 700/550 -> 610/479
  int nButtonx = 2
  hwrite=control WINBUTTON
    window=hparm
    position=2,BUTTONY,125,22
    name="保存布局"
    help="双击可将编辑的布局写入磁盘"
    mode=M_DBLCLICK
    bkcolor=WHITEBLUE
  endc
  hprint=control WINBUTTON
    window=hparm
    position=129,BUTTONY,105,22
    name="打印"
    help="将布局另存为ASCII文本文件到磁盘"
    bkcolor=WHITEBLUE
  endc
  hsendext=control WINBUTTON
    window=hparm
    position=236,BUTTONY,145,22
    name="发送到文件"
    help="双击将布局扩展发送到测试机"
    mode=M_DBLCLICK
    bkcolor=WHITEBLUE
  endc
  
  
  hexit=control WINBUTTON
    window=hparm
    position=460,BUTTONY,68,22
    name="确定"
    help="更改布局并关闭此窗口"
    bkcolor=WHITEBLUE
  endc
  hquit=control WINBUTTON
    window=hparm
    position=540,BUTTONY,68,22
    name="取消"
    help="按下可关闭窗口而不更改布局"
    bkcolor=WHITEBLUE
  endc
 
// hparm=control CHILD
  //  window=hcard
    //position=2,26,605,421
    //help=" "
    //color=BLACK
    //bkcolor=WHITEGREEN
    //size=4096
  //endc
  
    // miaoyu added backgroud bmp 06-06
  draw window=hparm
  draw at 1,1 bitmap=0,0,0,"logo"
  
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// GENERAL PANEL /////////////////////////////////

#define GX0            15
#define GX1            115
#define GX2            410
#define GY0            38 // miaoyu 13
#define GY1            106//86
#define GDY            30
#define GCY            20
#define GY2            340
#define GY3            9               // Top Y coordinate of checkbox controls
#define GY4            194


function int fpt_test_infos()

    int ax0,ay0,adx,ady, xdx
    ax0 = 400
    ay0 = 300
    adx = 100
    ady = 50
    xdx = 207
    
  hoptprint=control CHECKBOX
    window=hparm
    position=ax0,ay0,200,19
    name="优化针痕"
    help="优化动作减少划伤，慢！"
    font=TIMESFONT
   // mode=(($int4(lx+8) & HCY_MINPRINT)!=0?M_CHECKED:0)
  endc
  
    if (l.config & LC_TYPEMASK)==LC_S1 then
    haggressive=control CHECKBOX
      window=hparm
      position=ax0,ay0+30,200,19
      name="优化X-Y-Z运动条件"
      help="对在HS1和HS2测试机上的测试平整的产品时优化移动"
      font=TIMESFONT
      mode=(($int4(lx+4) & HCX_OPTWAIT)!=0?M_CHECKED:0)
    endc
  else
    haggressive=control CHECKBOX
      window=hparm
      position=ax0,ay0+30,200,19
      name="优化X-Y运动条件"
      help="考虑X-Y之后Z轴移动的持续时间"
      font=TIMESFONT
      mode=(($int4(lx+4) & HCX_OPTWAIT)!=0?M_CHECKED:0)
    endc
  endif
  
end

function int fpt_config_infos()

    int ax0,ay0,adx,ady, xdx
    ax0 = 400
    ay0 = 38
    adx = 100
    ady = 50
    xdx = 207
    
    int zheadtype,zheadbot
    zheadtype=lx.zheadtype
  zheadbot=$int4(lx+460)
  
  husezparm=control CHECKBOX
    window=hparm
    position=ax0,ay0,100,20
    name="Z 参数:"
    help="强制指定Z测试头参数如下"
    font=TIMESFONT
    //mode=(zheadtype & HCZ_VALID?M_CHECKED:0)
  endc
  
 hselectneedle=control WINBUTTON
   window=hparm
   position=ax0+100,ay0,108,20
   name="设置针头 ->"
   help="从图片中选择针头"
   font=TIMESFONT
   bkcolor=WHITEGREEN
 endc
 draw at ax0+15,ay0+45 text="驱动:"
 hactuator=control COMBOLIST
   window=hparm
   position=ax0+70,ay0+25,xdx-70,160
   help="Z执行机构的类型"
   mode=M_VSCROLL
 endc
 add hactuator text="支架1"
 add hactuator text="支架2"
 add hactuator text="步进电机"
 add hactuator text="线性电机"
 add hactuator text="无Z轴"

// if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA3 then
//   change hactuator select=0
// else if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA2G then
//   change hactuator select=1
// else if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPECER then
//   change hactuator select=2
// else if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPELIN then
//   change hactuator select=3
// else if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPENO then
//   change hactuator select=4
// endif
// if (zheadtype & HCZ_VALID)==0 disable hactuator


 draw at ax0+15,ay0+71 text="击测:"
 hstroke=control COMBOLIST
   window=hparm
   position=ax0+70,ay0+51,xdx-70,160
   help="Z行程类型(学习的Z仅适用于HS1，高压适用于H5)"
   mode=M_VSCROLL
 endc
 add hstroke text="标准"
 add hstroke text="软着陆"
 add hstroke text="硬针"
 add hstroke text="学习Z"
 add hstroke text="高压"
// if (zheadtype & HCZ_VALID)==0 disable hstroke


 draw at ax0+15,ay0+97 text="针头:"
 hneedle=control COMBOLIST
   window=hparm
   position=ax0+70,ay0+77,xdx-70,160
   help="接触针的类型('标准'表示重的白色支架)"
   mode=M_VSCROLL
 endc
 add hneedle text="默认"
 add hneedle text="标准"
 add hneedle text="软针"
 add hneedle text="特殊软针"
 add hneedle text="硬针"
 add hneedle text="软针转接头"
 add hneedle text="微针"
 add hneedle text="带感应器硬针"
 //if (zheadtype & HCZ_VALID)==0 disable hneedle
 

 draw at ax0+15,ay0+123 text="感应器:"
 hsensor=control COMBOLIST
   window=hparm
   position=ax0+70,ay0+103,xdx-70,160
   help="Z压力传感器的类型(如果不存在，则设置为默认值)"
   mode=M_VSCROLL
 endc
 add hsensor text="默认"
 add hsensor text="倒置"
 add hsensor text="自动探测"
// if (zheadtype & HCZ_VALID)==0 disable hsensor


 hdiffbot=control CHECKBOX
   window=hparm
   position=ax0,ay0+131,100,20
   name="底部:"
   help="指定底部的不同针"
   font=TIMESFONT
   mode=(zheadbot & HCZ_VALID?M_CHECKED:0)
 endc
// if (zheadtype & HCZ_VALID)==0 disable hdiffbot
 hselectbottom=control WINBUTTON
   window=hparm
   position=ax0+100,ay0+131,108,20
   name="设置背面 ->"
   help="从图片集中选择底部针头"
   font=TIMESFONT
   bkcolor=WHITEGREEN
 endc
// if (zheadtype & zheadbot & HCZ_VALID)==0 disable hselectbottom
 draw at ax0+15,ay0+173 text="针头:"
 hneedlebot=control COMBOLIST
   window=hparm
   position=ax0+70,ay0+153,xdx-70,160
   help="底部针头的类型('标准'表示重的白色支架)"
   mode=M_VSCROLL
 endc
 add hneedlebot text="默认"
 add hneedlebot text="标准"
 add hneedlebot text="软针"
 add hneedlebot text="特殊软针"
 add hneedlebot text="硬针"
 add hneedlebot text="软针转接头"
 add hneedlebot text="微针"
 add hneedlebot text="带感应器硬针"
// if (zheadtype & zheadbot & HCZ_VALID)==0 disable hneedlebot

 draw at ax0+15,ay0+199 text="感应器:"
 hsensorbot=control COMBOLIST
   window=hparm
   position=ax0+70,ay0+179,xdx-70,160
   help="底部Z压力传感器的类型(如果不存在，则设置为默认)"
   mode=M_VSCROLL
 endc
 add hsensorbot text="默认"
 add hsensorbot text="倒置"
 add hsensorbot text="自动探测"
// if (zheadtype & zheadbot & HCZ_VALID)==0 disable hsensorbot

 hpreload=control CHECKBOX
   window=hparm
   position=ax0+15,ay0+210,xdx-40,19
   name="检查预压力"
   help="检查柱状图是否已充分预加载"
   font=TIMESFONT
   mode=(zheadtype & HCZ_TESTPRLD?M_CHECKED:0)
 endc
// if (zheadtype & HCZ_VALID)==0 disable hpreload
 hnozlim=control CHECKBOX
   window=hparm
   position=ax0+15,ay0+230,xdx-40,19
   name="允许深Z方向运动"
   help="如果测试没有大孔却弯曲的大板，则激活"
   font=TIMESFONT
   mode=((lx.extcfg & EXT_NOZLIMIT)!=0?M_CHECKED:0)
 endc

    draw show
end

function int fpt_meature_infos()

    int ax0,ay0,adx,ady
    ax0 = 20
    ay0 = 300
    adx = 100
    ady = 50
  draw at ax0,ay0 text="高压卡"
  hvcard=control COMBOLIST
    window=hparm
    position=ax0+50,ay0-15,80,100
    help="在测量卡上指定高压电子设备的类型"
    bkcolor=WHITE
  endc
  add hvcard text="500 V"
  add hvcard text="1 kV"
  add hvcard text="Auto"

  draw at ax0+140,ay0 text="电感补偿"
  hlzero=control EDIT
    window=hparm
    position=ax0+adx+135,ay0-15,66,22
    help="指定剩余电感,微亨"
    bkcolor=WHITE
  endc



  draw at ax0,ay0+30 text="电阻补偿"
  hrzero=control EDIT
    window=hparm
    position=ax0+65,ay0+15,66,22
    help="指定短路针之间的最小电阻，欧姆"
    bkcolor=WHITE
    mode=M_HSCROLL
  endc
  
  draw at ax0+140,ay0+30 text="4线补偿"
  hkelvzero=control EDIT
    window=hparm
    position=ax0+adx+135,ay0+15,66,22
    help="指定短路的开尔文针之间的最小电阻，欧姆"
    bkcolor=WHITE
    mode=M_HSCROLL
  endc



  draw at ax0, ay0+60 text="微短探测校正"
  hcrtadj=control EDIT
    window=hparm
    position=ax0+85,ay0+40,100,22
    help="指定单个MSD电容修正，以1/10000为单位"
    bkcolor=WHITE
  endc
  
  draw at ax0, ay0+90 text="背钻补偿"
  hbdccorr=control EDIT
    window=hparm
    position=ax0 + 65,ay0+70,66,22
    help="指定背钻针的电容补偿，femtofarad"
    //bkcolor=WHITEBLUE
  endc
  
  draw at ax0+140, ay0+90 text="背钻因素"
 hbdcfact=control EDIT
   window=hparm
   position=ax0 + 210,ay0+70,66,22
   help="指定背钻针的电容系数0.5..2.0"
   //bkcolor=WHITEBLUE
 endc
  
  draw at ax0+280, ay0+90 text="背钻校正"
 hbdczofs=control EDIT
   window=hparm
   position=ax0 + 340,ay0+70,66,22
   help="指定背钻针的Z偏移,微米"
   bkcolor=WHITE
 endc  
  
    draw show

end


function int Creategeneral()
  
    // miaoyu   modified 06-06
  //clear hparm
  
  
  draw window=hparm font=INFOFONT color=BLACK
  draw at GX0,GY0+20 font=TIMESFONT text="机型:" 
  draw at GX0,GY0+GDY+20 font=TIMESFONT text="轨道数量:"
  
  // miaoyu beg
  draw at GX1+60,GY0+GDY+20 text="摄像头:" font=TIMESFONT
  draw at GX0,GY1+320 text="序列号:"
  //draw at GX0,GY1+GDY+20 text="打印标签:"
  //draw at GX0,GY1+2*GDY+20 text="天线:"
  //draw at GX1+85,GY1+2*GDY+20 text="平行线图:"
  //draw at GX0,GY1+3*GDY+20 text="天线网格:"
  //draw at GX1,GY1+3*GDY+20 text="垂直 ="
  //draw at GX1+120,GY1+3*GDY+20 text="水平 ="
  //draw at GX0,GY1+4*GDY+20 text="架板框:"
  //draw at GX1+111,GY1+4*GDY+20 text="架板框天线 ="
  //draw at GX0,GY1+5*GDY+20 text=""
  //draw at GX1+1,GY1+5*GDY+20 text="地址: ="
  //draw at GX1+165,GY1+5*GDY+20 text="端口 ="
  //draw at GX0,GY1+6*GDY+20 text="信号灯:"
  //draw at GX0,GY1+7*GDY+20 text="真空:"
  //draw at GX1+36,GY1+7*GDY+20 text="(屏蔽底部测试头和摄像头)"
  
  //draw at GX0,GY2+20 text="路径:"
  draw at GX0,GY1+20 text="路径:" font=TIMESFONT
  //draw at GX2,GY3+3*GCY+23 text="头部:"
  
  // miaoyu end
  
  
  draw show
  htype=control COMBOLIST
    window=hparm
    position=GX1,GY0,250,250
    help="选择测试机类型"
    mode=M_VSCROLL
  endc
  add htype text="A2, A3, A4, A5, A5L, A6, old A1"
  add htype text="PPE tester"
  add htype text="Old high-Z A1 tester"
  add htype text="B1 (backpanel) tester"
  add htype text="M2 tester"
  add htype text="New A1 tester"
  add htype text="HS1"
  add htype text="HP"
  add htype text="HS2"
 
 hrails=control EDIT
    window=hparm
    position=GX1,GY0+GDY,33,24
    help="测试轨道数量(不包括摄像机)"
    font=MEDIUMFONT
    bkcolor=WHITE
    mode=M_NOEDIT
  endc

  hrscroll=control VSCROLL
    window=hparm
    position=GX1+33,GY0+GDY,20,24
    help="更改测试轨道的数量(不包括摄像机)"
    mode=M_NOTAB
    limits=1,-1
  endc
  hcameras=control EDIT
    window=hparm
    position=GX1+162,GY0+GDY,68,24
    help="可用的摄像机"
    bkcolor=WHITE
    mode=M_NOEDIT
  endc
  hcscroll=control VSCROLL
    window=hparm
    position=GX1+230,GY0+GDY,20,24
    help="更改可用的摄像机"
    mode=M_NOTAB
    limits=1,-1
  endc
 

 hsernumb=control EDIT
    window=hparm
    position=GX0+65,GY1+300,250,24
//    help="任何文本都可以标识此测试机"
    bkcolor=WHITE
    mode=M_HSCROLL
  endc
  
  
 //hlabel=control EDIT
 //  window=hparm
 //  position=GX1,GY1+GDY,142,24
 //  help="文本,将出现在打印标签上，最多8个字符"
 //  bkcolor=WHITE
 //endc
  
  hrotlabel=control CUSTOMBOX
    window=hparm
  //  position=GX1+157,GY1+GDY+1,93,20
    text="旋转标签"
    help="旋转附加标签，仅由Valentin标签打印机支持"
    font=INFOFONT
  endc
  
 
 hantennas=control COMBOLIST
    window=hparm
    //position=GX1,GY1+2*GDY,77,75
    help="选择电场天线类型"
  endc
  
  //add hantennas text="网格"
  //add hantennas text="内部"
  //add hantennas text="测试头"
  
 //hfingtype=control COMBOLIST
 //  window=hparm
 //  position=GX1+187,GY1+2*GDY,63,65
 //  help="选择测试针的类型(仅限A2测试仪)"
 //endc
  
  //add hfingtype text="白"
  //add hfingtype text="灰"
  
 hantx=control EDIT
   window=hparm
//   position=GX1+59,GY1+3*GDY,30,24
   help="指定垂直(跨越所有轨道)外部天线的数量"
   bkcolor=WHITE
 endc
  
  
  haxscroll=control VSCROLL
    window=hparm
//    position=GX1+89,GY1+3*GDY,20,24
    help="更改垂直(跨越所有轨道)外部天线的数量"
    bkcolor=WHITE
    mode=M_NOTAB
    limits=1,-1
  endc                                                               
  hanty=control EDIT
    window=hparm
//    position=GX1+200,GY1+3*GDY,30,24
    help="指定水平(与轨道平行)外部天线的数量"
    bkcolor=WHITE
  endc
  hayscroll=control VSCROLL
    window=hparm
//    position=GX1+230,GY1+3*GDY,20,24
    help="更改水平(与轨道平行)外部天线的数量"
    bkcolor=WHITE
    mode=M_NOTAB
    limits=1,-1
  endc


 // hshtype=control COMBOLIST
 //   window=hparm
 //   position=GX1,GY1+4*GDY,106,240
 //   help="选择架板框类型"
 // endc
  
 //add hshtype text="Generic"
 //add hshtype text="手动2"
 //add hshtype text="手动2X"
 //add hshtype text="自动"
 //add hshtype text="手动5"
 //add hshtype text="自动5"
 //add hshtype text="手动"
 //add hshtype text="手动HS"
 //add hshtype text="通用机手动"
 //add hshtype text="手动分离"
  
  
  //hshant=control EDIT
  //  window=hparm
  //  position=GX1+220,GY1+4*GDY,30,24
  //  help="指定连接到架板框天线的多路卡输出，如果没有，则为0"
  //  bkcolor=WHITE
  //endc
  hipaddr=control EDIT
    window=hparm
    //position=GX1+43,GY1+5*GDY,117,24
    help="指定L&M自动化的IP地址，0从主通道使用IP"
    bkcolor=WHITE
  endc
  hsocket=control EDIT
    window=hparm
  //  position=GX1+205,GY1+5*GDY,45,24
  //  help="指定L&M自动化的插口，0使用默认值"
    bkcolor=WHITE
  endc
  htraffic=control COMBOLIST
    window=hparm
  //  position=GX1,GY1+6*GDY,110,160
  //  help="信号灯控制方式"
    mode=M_VSCROLL
  endc
  
  //add htraffic text="标准"
  //add htraffic text="1"
  //add htraffic text="2"
  //add htraffic text="3"
  
  //change htraffic select=($int4(lx+512) & HCA_TRAFFIC)>>16
  //haltlights=control CUSTOMBOX
  //  window=hparm
  //  position=GX1+124,GY1+6*GDY+2,130,20
  //  name="静态信号灯"
  //  help="检查是否需要静态(非闪烁)信号灯"
  //  font=INFOFONT
  //endc
  
  //hvacuumbox=control CUSTOMBOX
  //  window=hparm
  //  position=GX1,GY1+7*GDY+4,16,16
  //  name=" "
  //  help="禁用所有底部测试头和摄像头"
  //endc
  
// miaoyu add
  //hpress=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY3,165,20
  //  font=INFOFONT
  //endc
  //hhardcontact=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY3+GCY,160,20
  //  name="硬接触"
  //  help="测试氧化板(产生划痕)"
  //  font=INFOFONT
  //endc

  //hnooversurf=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY3+2*GCY,180,20
  //  name="隐藏表面接触"
  //  help="选中此项仅显示每个测试头的第一次 表面上接触"
  //  font=INFOFONT
  //endc
  //hpassive=control RADIO
  //  window=hparm
  //  position=GX2+20,GY3+4*GCY+7,160,20
  //  name="手动"
  //  help="带手动电容调整的头部卡"
  //  font=INFOFONT
  //endc
  //hampl=control RADIO
  //  window=hparm
  //  position=GX2+20,GY3+5*GCY+7,160,20
  //  name="起作用"
  //  help="带电子的电容调整的头部卡"
  //  font=INFOFONT
  //endc
  //hphase=control RADIO
  //  window=hparm
  //  position=GX2+20,GY3+6*GCY+7,160,20
  //  name="相位激活"
  //  help="带电子的电容调整和相位调整的头部卡"
  //  font=INFOFONT
  //endc
  //hnofield=control RADIO
  //  window=hparm
  //  position=GX2+20,GY3+7*GCY+7,160,20
  //  name="优化电容"
  //  help="针对电容测量优化的头部卡"
  //  font=INFOFONT
  //endc
// miaoyu end  
  
  //hsplit=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY4,160,20
  //  name="4线针头"
  //  help="检查测试机是否配备了开尔文探针"
  //  font=INFOFONT
  //endc
  //hautosplit=control CUSTOMBOX
  //  window=hparm
  //  position=GX2+20,GY4+GCY,140,20
  //  name="自动探测针头"
  //  help="自动确定探头类型(标准或开尔文)"
  //  font=INFOFONT
  //endc
  //hslow=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY4+2*GCY,160,20
  //  name="缓慢继电器"
  //  help=($GLOBAL.a5==0?                                                       \
  //    "Check in case tester is equipped with slow LATEST-compatible relays":   \
  //    "Check in teh case on-heads are equipped with slow (4-ms) NAIS relays")
  //  font=INFOFONT
  //endc
  //hfastreset=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY4+3*GCY,160,20
  //  name="快速软件复位"
  //  help="优化软复位，测试头可留在工作区"
  //  font=INFOFONT
  //  mode=((lx.extcfg & EXT_FASTRESET)!=0?M_CHECKED:0)
  //endc
  //hcheckzero=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY4+4*GCY,172,20
  //  name="复位校正编码器"
  //  help="测试并自动校正X-Y编码器的零脉冲"
  //  font=INFOFONT
  //  mode=((lx.extcfg & EXT_CHECKZERO)!=0?M_CHECKED:0)
  //endc
  //hcheckall=control CUSTOMBOX
  //  window=hparm
  //  position=GX2+20,GY4+5*GCY,160,20
  //  name="校正所有测试头"
  //  help="校正所有测试头上的零脉冲，而不仅仅是移动"
  //  font=INFOFONT
  //  mode=((lx.extcfg & EXT_CHECKALL)!=0?M_CHECKED:0)
  //endc
  //if (lx.extcfg & EXT_CHECKZERO)==0 disable hcheckall
  //hautolights=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY4+6*GCY,160,20
  //  name="摄像头灯"
  //  help="摄像机是否配备(热)发红灯"
  //  font=INFOFONT
  //endc
  //hautodeadlock=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY4+7*GCY,160,20
  //  name="自动解决死机问题"
  //  help="检查测试机是否自行解决可能的自我死锁"
  //  font=INFOFONT
  //endc
  //hwidetop=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY4+8*GCY+8,160,20
  //  name="上面针头到中间"
  //  help="检查可以将测试头向后移动并移出上部工作区"
  //  font=INFOFONT
  //endc
  //hwidebot=control CUSTOMBOX
  //  window=hparm
  //  position=GX2,GY4+9*GCY+8,160,20
  //  name="下面针头到中间"
  //  help="检查可以将测试头向后移动并移出下部工作区"
  //  font=INFOFONT
  //endc
// miaoyu end

  hlayoutname=control COMBOEDIT
    window=hparm
    position=GX0+35,GY1,250,120
    name="布局文件"
    help="包含主测试机布局的文件"
    mode=M_VSCROLL
  endc
  hbrowse=control WINBUTTON
    window=hparm
    position=GX0+290,GY1,60,24
    name="浏览"
    help="按下浏览布局文件的名称"
    bkcolor=WHITEBLUE
    font=TIMESFONT
  endc
  hread=control WINBUTTON
    window=hparm
    position=GX0,GY1+35,170,24
    name="从资料中读取"
    help="按下可从磁盘读取布局"
    bkcolor=WHITEBLUE
    font=TIMESFONT
  endc
  hget=control WINBUTTON
    window=hparm
    position=GX0+180,GY1+35,170,24
    name="获取实际布局"
    help="按下可从加载的测试机中获取布局"
    bkcolor=WHITEBLUE
    font=TIMESFONT
  endc



    // miaoyu beg
    
    // 
    int ax0,ay0
    ax0 = 20
    ay0 = 180
      draw at ax0,ay0+20 text="多路卡和输出:"
  hmuxtype=control COMBOLIST
    window=hparm
    position=ax0+100,ay0,144,200
    help="模拟多路卡类型"
    bkcolor=WHITEBLUE
  endc
  add hmuxtype text="DL406"
  add hmuxtype text="DL506（M1）"
  add hmuxtype text="DL506（M2）"
  add hmuxtype text="DL506（M3）"
  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
    change hmuxtype select=($int4(lx+674)>>24) & 0x0000000F
  else
    change hmuxtype select=0
  endif

    // 多路卡替代通道 
  int i,j,subst
  int taby, taby1, taby2
  taby  = 45
  taby1 = 5
  taby2 = 25
  draw at ax0,ay0+taby text="多路卡替代通道:"
  // miaoyu for i=0,i<4,i++ do
  char substname[4][12] = {"first", "second", "third", "fourth" }
  for i=0,i<2,i++ do
    subst=$int2(lx+488+2*i)
    hsubston[i]=control CHECKBOX
      window=hparm
      position=ax0+10,ay0+taby+taby1+i*27,70,20
      name="测试头:"
      help=format("选中可以启用%s替换",substname[i])
      font=TIMESFONT
      mode=(subst & 0x8000?M_CHECKED:0)
      bkcolor=WHITE
    endc
    hsubsthead[i]=control COMBOLIST
      window=hparm
      position=ax0+80,ay0+taby+taby1+i*27,50,200
      help="选择测试头代替"
      mode=M_VSCROLL
      font=FIXEDSYS
      bkcolor=WHITE
    endc
    for j=0,j<24,j++ do
      add hsubsthead[i] text=format("%i%c",j/2,j & 1?'R':'L')
    enddo
    if subst!=0 change hsubsthead[i] select=subst & 0x001F
    if (subst & 0x8000)==0 disable hsubsthead[i]
    
    draw at ax0+135,ay0+taby+taby2 - 2 +i*27 text="接头:"
    hsubstpos[i]=control COMBOLIST
      window=hparm
      position=ax0+179,ay0+taby+taby2 - 20 +i*27,140,200
      help="选择模拟多路卡上的连接器"
      mode=M_VSCROLL
      font=FIXEDSYS
      bkcolor=WHITEBLUE
    endc
  enddo


    fpt_meature_infos()
    
    fpt_config_infos()
    
    
    fpt_test_infos()
    // miaoyu end

end

// Display general tester parameters on the screen. This procedure also tries
// to correct some obvious errors.
function int Showgeneral()
  char acamera[4][7] = { "无","顶部","底部","上下" }
  char mcamera[4][7] = { "NONE","CHIP"," I/O","BOTH" }
  char s[64]
  int i,mcm
  if (l.config & LC_ISM2)!=0 mcm=1     // M2 tester
  i=(l.config>>2) & 0x03               // Type of tester, as in old Debugger
  if (l.config & LC_TYPEMASK)==LC_NEWA1 then
    i=5; mcm=0; l.config=l.config & (~(LC_ISM2|LC_HIGHZ|LC_LDELAY))
  else if (l.config & LC_TYPEMASK)==LC_S1 then
    i=6; mcm=0; l.config=l.config & (~(LC_ISM2|LC_HIGHZ|LC_LDELAY))
  else if (l.config & LC_TYPEMASK)==LC_A8 then
    i=7; mcm=0; l.config=l.config & (~(LC_ISM2|LC_HIGHZ|LC_LDELAY))
  else if (l.config & LC_TYPEMASK)==LC_S3 then
    i=8; mcm=0; l.config=l.config & (~(LC_ISM2|LC_HIGHZ|LC_LDELAY))
  else if mcm!=0 then
    i=4
  endif
  change htype select=i
  l.nfing=Max(0,Min((l.cameras==0?16:15),l.nfing))
  change hrails text=format("%2i",l.nfing)
  l.cameras=l.cameras & 0x03
  if mcm==0 && l.cameras==0 && l.headcameras!=0 then
    change hcameras text="头部"
  else
    change hcameras text=(mcm==0?acamera[l.cameras]:mcamera[l.cameras])
  endif
  change hsernumb text=format("%.31s",l.serialid)
  change hlabel text=format("%.8s",lx+700)
  i=l.config & LC_AMASK
  if i==LC_AMASK then
    i=LC_FINGANT; l.config=(l.config & (~LC_AMASK))|i
  endif
  change hantennas select=i
  if (l.config & LC_A2LOADER)==0 then i=0;
  else if (l.config & LC_SMASK)==LC_A2SHUT then i=1;
  else if (l.config & LC_SMASK)==LC_A2XSHUT then i=2;
  else if (l.config & LC_SMASK)==LC_AUTOMATE then i=3;
  else if (l.config & LC_SMASK)==LC_A5WIDE then i=4;
  else if (l.config & LC_SMASK)==LC_LM then i=5;
  else if (l.config & LC_SMASK)==LC_EPCOS then i=6;
  else if (l.config & LC_SMASK)==LC_LMS2 then i=7;
  else if (l.config & LC_SMASK)==LC_LMMAN then i=8;
  else if (l.config & LC_SMASK)==LC_LMSPLIT then i=9;
  else i=0; endif
  change hshtype select=i
  change hipaddr text=format("%i.%i.%i.%i",                                    \
    $uint1(lx+585),$uint1(lx+584),$uint1(lx+583),$uint1(lx+582))
  change hsocket text=format("%i",$uint2(lx+580))
  if i==5 || i==6 || i==7 || i==8 then
    enable hipaddr
    enable hsocket
  else
    disable hipaddr
    disable hsocket
  endif
  l.shuttle=Max(0,Min(31,l.shuttle))
  if l.shuttle==0 then
    change hshant text="  --"
  else
    change hshant text=format("%i",l.shuttle)
  endif
  l.zaxis=Max(0,Min(1,l.zaxis))
  change hfingtype select=l.zaxis
  if mcm==0 then
    if ($uint4(lx+12) & 0x80000000)!=0 then
      change hpress name="(参考DSP配置)"
      disable hpress
    else
      change hpress name="压力感应器"
      change hpress help="检查手臂是否配备压力传感器"
    endif
  else
    change hpress name="低速率 (9600)"
    change hpress help="请检查是否AFMCU不支持207K波特率"
  endif
  change hpress mode=((l.config & LC_ZSENSORS)==0?0:M_CHECKED)
  if ($uint4(lx+12) & 0x80000000)!=0 then
    change hhardcontact name="(参考DSP配置)"
    disable hhardcontact
  endif
  if (l.config & LC_AMASK)==0 then
    enable hantx
    enable haxscroll
    enable hanty
    enable hayscroll
  else
    disable hantx
    disable haxscroll
    disable hanty
    disable hayscroll
  endif
  l.xantennas=Max(0,Min(64,l.xantennas))
  change hantx name=format("%i",l.xantennas)
  l.yantennas=Max(0,Min(64,l.yantennas))
  change hanty name=format("%i",l.yantennas)
  if (l.config & LC_OHTYPE)==LC_ACTIVE then
    change hampl mode=M_CHECKED
  else if (l.config & LC_OHTYPE)==LC_PHADJ then
    change hphase mode=M_CHECKED
  else if (l.config & LC_OHTYPE)==LC_NOFIELD then
    change hnofield mode=M_CHECKED
  else
    change hpassive mode=M_CHECKED
  endif
  change hsplit mode=((l.probetype & 0x1)==0?0:M_CHECKED)
  change hautosplit mode=((l.config & LC_AUTOPROBE)==0?0:M_CHECKED)
  if (l.config & LC_AUTOPROBE)==0 then
    enable hsplit
  else
    disable hsplit
  endif
  change hslow mode=((l.config & LC_RELAYS)==0?0:M_CHECKED)
  change hrotlabel mode=((lx.extcfg & EXT_ROTLABEL)==0?0:M_CHECKED)
  change haltlights mode=((l.config & LC_TRAFFICS)==0?0:M_CHECKED)
  change hautolights mode=((l.config & LC_ILLUM)==0?0:M_CHECKED)
  change hautodeadlock mode=((l.config & LC_DEADLOCKS)==0?0:M_CHECKED)
  change hwidetop mode=((l.config & LC_MORETOP)==0?0:M_CHECKED)
  change hwidebot mode=((l.config & LC_MOREBOT)==0?0:M_CHECKED)
  change hhardcontact mode=((l.config & LC_HARDZ)==0?0:M_CHECKED)
  change hnooversurf mode=((l.config & 0x80000)==0?0:M_CHECKED)
  change hvacuumbox mode=((l.config & LC_VACUUMBOX)==0?0:M_CHECKED)
end

// Get settings of those controls which are not automatically updated.
function int Getgeneral()
  int i,j,k,m
  float f
  char s[64]
  Memset(s,0,64); Text(hsernumb,s); Memcpy(l.serialid,s,31)
  Memset(s,0,64); Text(hlabel,s); Memcpy(lx+700,s,8)
  Text(hshant,s); i=0; sscanf(s,"%i",&i); l.shuttle=i
  Text(hantx,s); i=64; sscanf(s,"%i",&i); l.xantennas=i
  Text(hanty,s); i=48; sscanf(s,"%i",&i); l.yantennas=i
  Text(hipaddr,s); i=0; j=0; k=0; m=0; sscanf(s,"%i.%i.%i.%i",&i,&j,&k,&m);
  $uint1(lx+585)=i; $uint1(lx+584)=j; $uint1(lx+583)=k; $uint1(lx+582)=m;
  Text(hsocket,s); i=0; sscanf(s,"%i",&i); $uint2(lx+580)=i
  Text(hlayoutname,layoutname)
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// GEOMETRY PANEL ////////////////////////////////

#define EX0            10
#define EX1            115
#define EX2            205
#define EY0            10
#define EY1            10
#define EY3            10
#define EY4            312
#define ESY            21
#define EDY            23

#define BORD           15

function int Creategeometryhead()
  int y
  clear hgeochild
  draw window=hgeochild color=BLACK bkcolor=WHITEGREEN font=INFOFONT
  y=EY1
  if showgeneral then
    // Rail-independent parameters.
    draw at 0,y+19 text="左极限:"
    hleftlimit=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定工作区左边框的X坐标，mm"
      bkcolor=LIGHTYELLOW
    endc
    y=y+EDY
    draw at 0,y+19 text="右极限:"
    hrightlimit=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定工作区右边框的X坐标，mm"
      bkcolor=LIGHTYELLOW
    endc
    y=y+EDY
    draw at 0,y+19 text="X中心点:"
    hcenterx=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定工作区中心的X坐标，mm"
      bkcolor=LIGHTYELLOW
    endc
    y=y+EDY+8
    draw at 0,y+19 text="X无视频:"
    hvideodead=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定摄像机的X盲区，mm"
      bkcolor=WHITE
    endc
    if l.cameras==0 disable hvideodead
    y=y+EDY+8
    draw at 0,y+19 text="测试头半径:"
    hradius=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定测试头的(理想)半径，mm,或以0设置默认值"
      bkcolor=WHITE
    endc
    y=y+EDY
    draw at 0,y+19 text="摄像头半径:"
    hcamradius=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定摄像机的(理想)半径，mm"
      bkcolor=WHITE
    endc
    if l.cameras!=0 && (l.config & LC_TYPEMASK)!=LC_S3 disable hcamradius
  else
    hleftlimit=NULL
    hrightlimit=NULL
    hcenterx=NULL
    hradius=NULL
    hcamradius=NULL
    hvideodead=NULL
  endif
  if showshuttle then
    // Shuttle.
    draw at 0,y+19 text="Y补偿:"
    hdeadsplit=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定分离架板框中间的X死区，mm"
      bkcolor=WHITE
    endc
    if (l.config & LC_SMASK)!=LC_LMSPLIT disable hdeadsplit
    y=y+EDY+8
    draw at 0,y+19 text="架板框零点:"
    hyshuttle=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="HS3或分离架板框的Y原点位置修正，mm"
      bkcolor=WHITECYAN
    endc
    y=y+EDY
    draw at 0,y+19 text="架板框零点:"
    hyunlock=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="HS3架板框Y卸载位置的修正，mm"
      bkcolor=WHITECYAN
    endc
    y=y+EDY
    draw at 0,y+19 text="自动化:"
    hyauto=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="HS3.V8自动架板框Y卸载位置的修正，mm"
      bkcolor=WHITECYAN
    endc
    y=y+EDY
    draw at 0,y+19 text="扫描补偿值:"
    hyoffset=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="扫描位置摄像机中心的架板框Y坐标，mm"
      bkcolor=WHITECYAN
    endc
    y=y+EDY+4
    draw at 0,y+19 text="Y编码左基准:"
    hybase[0]=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="校准过程中左边架板框的Y编码器坐标，mm"
      bkcolor=WHITE
    endc
    y=y+EDY
    draw at 0,y+19 text="Y编码右基准:"
    hybase[1]=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="校准过程中右边架板框的Y编码器坐标，mm"
      bkcolor=WHITE
    endc
    y=y+EDY
  else if rail<l.nfing then
    // Heads.
    hdeadsplit=NULL
    hyshuttle=NULL
    hyunlock=NULL
    hyauto=NULL
    hyoffset=NULL
    hybase[0]=NULL
    hybase[1]=NULL
  else if rail==l.nfing then
    // Dedicated head cameras.
    hdeadsplit=NULL
    hyshuttle=NULL
    hyunlock=NULL
    hyauto=NULL
    hyoffset=NULL
    hybase[0]=NULL
    hybase[1]=NULL
  endif
  // Rail-dependent options.
  if showgeneral || showshuttle then
    henable=NULL
    hside=NULL
    hchgside=NULL
  else
    henable=control CUSTOMBOX
      window=hgeochild
      position=0,y,70,ESY-1
      name="轨道"
      help="允许选定的导轨或摄像头进行引导和测量"
      font=INFOFONT
    endc
    hside=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="这根轨道的面属于"
      bkcolor=WHITE
      mode=M_NOEDIT
    endc
    if rail<l.nfing then
      hchgside=control WINBUTTON
        window=hgeochild
        position=EX2-EX1+68,y,17,ESY
        help="按下可更改此轨道所属的一侧"
      endc
    else
      hchgside=NULL
    endif
    y=y+EDY
  endif
  if showgeneral==0 && showshuttle==0 && (l.config & LC_ISM2)==0 then
    draw at 0,y+19 text="X编码器:"
    hxenc=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="按下可更改所选轨道上编码器的方向。小心！"
      bkcolor=WHITE
      mode=M_NOEDIT
    endc
    hchgxenc=control WINBUTTON
      window=hgeochild
      position=EX2-EX1+68,y,17,ESY
      help="按下可更改所选轨道上X编码器的方向"
    endc
    y=y+EDY
  else
    hxenc=NULL
    hchgxenc=NULL
  endif
  if showgeneral || showshuttle then
    hysens=NULL
    hchgysens=NULL
  else if (l.config & LC_ISM2)!=0 then
    draw at 0,y+19 text="AFMCU id:"
    hysens=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="控制此测试头的AFMCU标识符"
      bkcolor=WHITE
      mode=M_NOEDIT
    endc
    hchgysens=control WINBUTTON
      window=hgeochild
      help="按住可更改AFMCU标识符"
      position=EX2-EX1+68,y,17,ESY
      mode=M_REPEAT
    endc
    y=y+EDY
  else if rail<l.nfing then
    draw at 0,y+19 text="Y感应器:"
    hysens=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="Y零感应器方向"
      bkcolor=WHITE
      mode=M_NOEDIT
    endc
    hchgysens=control WINBUTTON
      window=hgeochild
      help="更改Y零感应器方向"
      position=EX2-EX1+68,y,17,ESY
      mode=M_REPEAT
    endc
    y=y+EDY
  else
    draw at 0,y+19 text="Z encoder:"
    hysens=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="Z(聚焦)摄像机编码器的方向"
      bkcolor=WHITE
      mode=M_NOEDIT
    endc
    hchgysens=control WINBUTTON
      window=hgeochild
      help="更改Z(聚焦)摄像机编码器的方向"
      position=EX2-EX1+68,y,17,ESY
      mode=M_REPEAT
    endc
    y=y+EDY
  endif
  if rail<l.nfing && showgeneral==0 && showshuttle==0 then
    hbackdrill=control CUSTOMBOX
      window=hgeochild
      position=EX2-EX1,EY1+3*EDY,86,EDY-2
      name="背钻"
      help="检查是否安装了背钻针"
      font=INFOFONT
    endc
  else
    hbackdrill=NULL
  endif
  // Rail geometry.
  y=EY1+4*EDY
  if showgeneral==0 && showshuttle==0 then
    draw at 0,y+19 text="顶部极限:"
    htoplimit=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="给定轨道上边框的Y坐标，mm"
      bkcolor=LIGHTYELLOW
    endc
    y=y+EDY
    draw at 0,y+19 text="Y中心:"
    hcentery=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="给定轨道中心的Y坐标，mm"
      bkcolor=LIGHTYELLOW
    endc
    y=y+EDY
    draw at 0,y+19 text="低部极限:"
    hbottomlimit=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="给定轨道下边框的Y坐标，mm"
      bkcolor=LIGHTYELLOW
    endc
    y=y+EDY+8
  else
    htoplimit=NULL
    hcentery=NULL
    hbottomlimit=NULL
  endif
  // Warmup plates.
  if showgeneral==0 && showshuttle==0 && rail!=l.nfing then
    draw at 0,y+19 text="暖机dX:"
    hwarmupdx=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定预热焊盘X尺寸的一半，毫米，或0以关闭热身"
      bkcolor=WHITECYAN
    endc
    y=y+EDY
    draw at 0,y+19 text="暖机dY:"
    hwarmupdy=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定预热焊盘Y尺寸的一半，毫米，或0以关闭热身"
      bkcolor=WHITECYAN
    endc
    y=y+EDY
    draw at 0,y+19 text="暖机X:"
    hwarmupx=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定预热焊盘的X坐标，mm"
      bkcolor=WHITECYAN
    endc
    y=y+EDY
    draw at 0,y+19 text="暖机Y:"
    hwarmupy=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定预热焊盘的Y坐标，mm"
      bkcolor=WHITECYAN
    endc
    y=y+EDY+8
  else
    hwarmupdx=NULL
    hwarmupdy=NULL
    hwarmupx=NULL
    hwarmupy=NULL
  endif
  // Head-dependent settings.
  if showgeneral==0 && showshuttle==0 && rail<l.nfing &&                       \
    (l.cameras==0 || (l.config & LC_TYPEMASK)==LC_S3)                          \
  then
    draw at 0,y+19 text="头部摄像头:"
    hheadcamera=control COMBOLIST
      window=hgeochild
      position=EX2-EX1,y,85,200
      help="摄像头类型(断开-已安装，但不在总线上)"
    endc
    add hheadcamera text="无"
    add hheadcamera text="头部"
    add hheadcamera text="头部右"
    add hheadcamera text="高清"
    add hheadcamera text="高清右"
    add hheadcamera text="定制"
    add hheadcamera text="定制右"
    y=y+EDY+8
  else
    hheadcamera=NULL
  endif
  if showgeneral==0 && showshuttle==0 &&                                       \
    (rail==l.nfing || l.cameras==0 || (l.config & LC_TYPEMASK)==LC_S3)         \
  then
    hcether=control CUSTOMBOX
      window=hgeochild
      position=0,y,70,ESY-1
      name="MAC:"
      help="检查摄像头是否通过以太网连接"
      font=INFOFONT
    endc
    hcmac=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="摄像机MAC地址的最后3个字节，XX:XX:XX"
      bkcolor=WHITE
    endc
    y=y+EDY
    draw at 0,y+19 text="相机角度:"
    hcangle=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="指定所选测试头上相机的角度校正，度"
      bkcolor=WHITE
    endc
    y=y+EDY
  else
    hcether=NULL
    hcmac=NULL
    hcangle=NULL
  endif
  if showgeneral==0 && showshuttle==0 then
    y=y+4
    draw at 0,y+19 text="X补偿:"
    hxshift=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="对指定测试头的X方向布局中心修正，mm"
      bkcolor=WHITE
    endc
    y=y+EDY
    draw at 0,y+19 text="Y补偿:"
    hyshift=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="对指定测试头的Y方向布局中心修正，mm"
      bkcolor=WHITE
    endc
    y=y+EDY
  else
    hxshift=NULL
    hyshift=NULL
  endif
  if showgeneral==0 && showshuttle==0 && rail==l.nfing then
    draw at 1,y+19 text="Z补偿:"
    hzshift=control EDIT
      window=hgeochild
      position=EX2-EX1,y,69,ESY
      help="摄像机焦距校正，mm"
      bkcolor=WHITE
    endc
    y=y+EDY
  else
    hzshift=NULL
  endif
  draw show
end

function int Creategeometry()
  int i,j,n
  clear hparm
  draw window=hparm font=INFOFONT color=BLACK bkcolor=LIGHTYELLOW
  draw at EX0,EY0 fillrect EX0+91,EY0+403
  hgeneral=control WINBUTTON
    window=hparm
    position=EX0+5,EY0+4,81,18
    name="通用"
    help="按下可显示适用于所有测试头的数据"
  endc





  for j=0,j<l.nfing,j++
    do i=0,1,1
      hhead[j,i]=control WINBUTTON
        window=hparm                   // Position will be specified later
        name=format("%i%c",j,(i==0?'L':'R'))
        help=format("按下可选择%s测试头上轨道%i",i==0?"left":"right",j)
      endc
    enddo
  enddo
  hallon=control WINBUTTON
    window=hparm
    position=EX0+5,EY0+381,40,18
    name="全开"
    help="包括所有轨道"
    font=SMALLFONT
  endc
  halloff=control WINBUTTON
    window=hparm
    position=EX0+46,EY0+381,40,18
    name="全关"
    help="排除所有轨道"
    font=SMALLFONT
  endc
  if (l.cameras & 1)!=0 then
    hhead[l.nfing,0]=control WINBUTTON
      window=hparm                     // Position will be specified later
      name=format("%iL",l.nfing)
      help=format("按下可选择%s摄像机",                                 \
      (l.config & LC_ISM2)==0?"top":"chip")
    endc
  endif
  if (l.cameras & 2)!=0 then
    hhead[l.nfing,1]=control WINBUTTON
      window=hparm                     // Position will be specified later
      name=format("%iR",l.nfing)
      help=format("按下可选择%s摄像机",                                 \
      (l.config & LC_ISM2)==0?"bottom":"I/O")
    endc
  endif
  hshuttle=control WINBUTTON
    window=hparm                       // Position will be specified later
    name="架板框"
    help="按下可编辑架板框参数"
  endc
  hgeochild=control CHILD              // Keeps geometry information
    window=hparm
    position=EX1,0,180,420
    help=" "
    color=WHITEGREEN
    bkcolor=WHITEGREEN
    size=2048
  endc
  if (l.config & LC_SMASK)==LC_LMSPLIT then
    hshuttlel=control WINBUTTON
      window=hparm
      position=EX2+96,EY4+11,17,17
      name="<"
      help="从中心向左突出显示使用十字"
      font=SMALLFONT
      color=BLACK
      bkcolor=LIGHTGRAY
    endc
    hshuttler=control WINBUTTON
      window=hparm
      position=EX2+154+13,EY4+11,17,17
      name=">"
      help="从中心向右突出显示使用十字"
      font=SMALLFONT
      color=BLACK
      bkcolor=LIGHTGRAY
    endc
  else
    hshuttlel=NULL
    hshuttlel=NULL
    scanshift=0
  endif
  hup=control WINBUTTON
    window=hparm
    position=EX2+125,EY4+10,30,30
    name="上"
    help="按住可向上移动选定的手臂或摄影机"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hleft=control WINBUTTON
    window=hparm
    position=EX2+95,EY4+40,30,30
    name="左"
    help="按住可向左移动选定的手臂或摄影机"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hright=control WINBUTTON
    window=hparm
    position=EX2+155,EY4+40,30,30
    name="右"
    help="按住可向右移动选定的手臂或摄影机"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hdown=control WINBUTTON
    window=hparm
    position=EX2+125,EY4+70,30,30
    name="下"
    help="按住可向下移动选定的手臂或摄影机"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hshow=control WINBUTTON
    window=hparm
    position=EX2+128,EY4+43,24,24
    name="?"
    help="按下可移动到所选手臂或相机的实际中心位置"
    font=MEDIUMFONT
  endc
  hsetdef=control WINBUTTON
    window=hparm
    position=299,EY3,110,24
    name="预设:"
    help="双击可以计算标准几何参数"
    mode=M_DBLCLICK
    bkcolor=WHITEGREEN
    font=INFOFONT
  endc
  hdeftester=control COMBOLIST
    window=hparm
    position=417,EY3,105,250
    help="此处选择标准手臂测试机的类型"
  endc
  add hdeftester text="HP1001"
  add hdeftester text="HP1002"
  add hdeftester text="HP1003"
  add hdeftester text="HP1004"
  add hdeftester text="HP1005"
  add hdeftester text="HP1006"
  add hdeftester text="HP1007"
  add hdeftester text="HP1008"
  add hdeftester text="S2"
  add hdeftester text="HP1009"   // Richie added
  add hdeftester text="HP1201"
  add hdeftester text="HP1217"
  hviewer=control GRAPH
    window=hparm
    position=300,EY3+30,VIX,VIY
    help="此处可以看到布局，或者看到实时视频"
    bkcolor=LIGHTGRAY
  endc
  draw window=hparm font=INFOFONT      // Creation of hviewer spoils settings
  htouch=control COMBOLIST
    window=hparm
    position=EX2+201,EY4+10,90,120
    help="选择接触模式"
    font=SMALLFONT
  endc
  add htouch text="无接触"
  add htouch text="接触"
  add htouch text="电阻-外部天线"
  add htouch text="电容-地"
  change htouch select=touchmode
  hviewfing=control CUSTOMBOX
    window=hparm
    position=EX2+200,EY4+EDY+10,80,22
    name="查看测试头"
    help="激活头部摄像头"
    font=INFOFONT
    mode=(viewfing==0?0:M_CHECKED)
  endc
  hmirror=control CUSTOMBOX
    window=hparm
    position=EX2+283,EY4+EDY+10,55,22
    name="镜像"
    help="镜像下面摄像机的图像"
    font=INFOFONT
    mode=(mirror==0?0:M_CHECKED)
  endc
  hzoom=control CUSTOMBOX
    window=hparm
    position=EX2+339,EY4+EDY+10,55,22
    name="缩放"
    help="选中可放大x2视频图像"
    font=INFOFONT
    mode=(zoom<0.75?0:M_CHECKED)
  endc
  draw at EX2+200,EY4+2*22+32 text="明亮度:"
  hbrightness=control HSCROLL
    window=hparm
    position=EX2+270,EY4+2*22+13,120,19
    name="明亮度"
    help="调整图像的亮度"
    limits=-100,100
  endc
  draw at EX2+200,EY4+3*22+34 text="对比度:"
  hcontrast=control HSCROLL
    window=hparm
    position=EX2+270,EY4+3*22+15,120,19
    name="对比度"
    help="调整图像的对比度"
    limits=-100,100
  endc
  draw show
end

// Draw tester layout in the GRAPH window hw of size dx*dy.
function int Plotgeometry(handle hw,int dx,int dy)
  int i,j,n,sides,ofsx,ofsy,issplit
  float cx,cy,xmin,xmax,ymin,ymax,scale,x,y,hx,hy,x0,y0,x1,y1,xs0,xs1
  draw window=hw
  if videoon!=0 return                 // Video on the screen
  draw color=LIGHTYELLOW bkcolor=LIGHTYELLOW
  draw at 0,0 fillrect dx,dy
  n=(l.cameras==0?l.nfing:l.nfing+1)
  ymin=1.0e99; ymax=-1.0e99
  for i=0,i<n,i++
    ymin=Min(ymin,l.top[i],l.bottom[i])
    ymax=Max(ymax,l.top[i],l.bottom[i])
    if l.side[i]!=0 then
      ofsx=30; ofsy=17
    endif
  enddo
  if n<=0 || l.leftlimit>=l.rightlimit || ymin>=ymax then
    draw show                          // Layout is not yet defined
    return
  endif
  xmin=l.leftlimit
  xmax=l.rightlimit
  if $uint2(lx1+196)>0 || $uint2(lx1+198)>0 then
    sides=0
    for i=0,i<l.nfing,i++ do
      if l.side[i]==0 then
        sides=sides | 0x01
      else
        sides=sides | 0x02
      endif
    enddo
    if sides & 0x1 then
      xmin=Min(xmin,$int4(lx1+200),$int4(lx1+204))
      xmax=Max(xmax,$int4(lx1+200),$int4(lx1+204))
    endif
    if sides & 0x2 then
      xmin=Min(xmin,$int4(lx1+208),$int4(lx1+212))
      xmax=Max(xmax,$int4(lx1+208),$int4(lx1+212))
    endif
  endif
  cx=(dx-2.0*BORD-ofsx)/(xmax-xmin)
  cy=(dy-2.0*BORD-ofsy)/(ymax-ymin)
  scale=Min(cx,cy)
  cx=BORD-xmin*scale                   // Recalculation: pixelX=x*scale+cx
  cy=dy-BORD+ymin*scale                // Recalculation: pixely=cy-y*scale
  cx=cx+(dx-(xmax-xmin)*scale-2*BORD-ofsx)/2.0
  cy=cy-(dy-(ymax-ymin)*scale-2*BORD-ofsy)/2.0
  x0=l.leftlimit*scale+cx
  x1=l.rightlimit*scale+cx
  if (l.config & LC_SMASK)==LC_LMSPLIT then
    xs0=(l.xoffset-Max(4000,$int4(lx0+578)/2))*scale+cx
    xs1=(l.xoffset+Max(4000,$int4(lx0+578)/2))*scale+cx
    issplit=1
  else
    issplit=0
  endif
  y0=cy-ymin*scale
  y1=cy-ymax*scale
  hx=$uint2(lx1+196)*scale+1.5         // Halfsize of warmup pads
  hy=$uint2(lx1+198)*scale+1.5
  draw color=RED bkcolor=PINK
  draw at x0+ofsx,y1-ofsy rect x1+ofsx,y0-ofsy+1
  for i=0,i<l.nfing,i++                // Draw bottom rails
    if l.side[i]==0 continue
    y0=cy-l.bottom[i]*scale
    y1=cy-l.top[i]*scale
    draw color=RED bkcolor=PINK
    if issplit then
      draw at x0+ofsx,y1-ofsy rect x1+ofsx,y0-ofsy+1
      draw at x0+ofsx,y1-ofsy fillrect xs0+ofsx,y0-ofsy+1
      draw at xs1+ofsx,y1-ofsy fillrect x1+ofsx,y0-ofsy+1
    else
      draw at x0+ofsx,y1-ofsy fillrect x1+ofsx,y0-ofsy+1
    endif
    if ($int2(l+764) & (1<<i))!=0 then
      draw color=LIGHTRED              // Rail is excluded from bootstrap
      draw at x0+ofsx,y1-ofsy to x1+ofsx,y0-ofsy
      draw at x0+ofsx,y0-ofsy to x1+ofsx,y1-ofsy
    endif
    if $uint2(lx1+196)>0 || $uint2(lx1+198)>0 then
      draw bkcolor=WHITEBLUE              // Warmup pads
      y=cy-$int4(lx1+216+4*i)*scale-ofsy
      x=cx+$int4(lx1+208)*scale+ofsx
      draw color=(rail==i && finger==0?LIGHTRED:BLACK)
      draw at x-hx,y-hy fillrect x+hx,y+hy
      x=cx+$int4(lx1+212)*scale+ofsx
      draw color=(rail==i && finger==1?LIGHTRED:BLACK)
      draw at x-hx,y-hy fillrect x+hx,y+hy
    endif
  enddo
  for i=0,i<l.nfing,i++                // Draw top rails
    if l.side[i]!=0 continue
    draw bkcolor=WHITECYAN color=BLUE
    y0=cy-l.bottom[i]*scale
    y1=cy-l.top[i]*scale
    if issplit then
      draw at x0,y1 rect x1,y0+1
      draw at x0,y1 fillrect xs0,y0+1
      draw at xs1,y1 fillrect x1,y0+1
    else
      draw at x0,y1 fillrect x1,y0+1
    endif
    if $uint2(lx1+196)>0 || $uint2(lx1+198)>0 then
      draw bkcolor=WHITEBLUE              // Warmup pads
      y=cy-$int4(lx1+216+4*i)*scale
      x=cx+$int4(lx1+200)*scale
      draw color=(rail==i && finger==0?LIGHTRED:BLACK)
      draw at x-hx,y-hy fillrect x+hx,y+hy
      x=cx+$int4(lx1+204)*scale
      draw color=(rail==i && finger==1?LIGHTRED:BLACK)
      draw at x-hx,y-hy fillrect x+hx,y+hy
    endif
  enddo
  y0=cy-ymin*scale
  y1=cy-ymax*scale
  for j=0,j<2,j++ do
    if j==0 then
      draw at x0,y1 clip (issplit?xs0:x1),y0
    else
      if issplit==0 break
      draw at xs1,y1 clip x1,y0
    endif
    draw color=PINK
    draw at x0+ofsx,y1-ofsy rect x1+ofsx,y0-ofsy+1
    for i=0,i<l.nfing,i++              // Redraw bottom frames (clipped!)
      if l.side[i]==0 continue
      y0=cy-l.bottom[i]*scale
      y1=cy-l.top[i]*scale
      draw color=PINK at x0+ofsx,y1-ofsy rect x1+ofsx,y0-ofsy+1
      if ($int2(l+764) & (1<<i))!=0 then
        draw color=PINK                // Rail is excluded from bootstrap
        draw at x0+ofsx,y1-ofsy to x1+ofsx,y0-ofsy
        draw at x0+ofsx,y0-ofsy to x1+ofsx,y1-ofsy
      endif
      if $uint2(lx1+196)>0 || $uint2(lx1+198)>0 then
        y=cy-$int4(lx1+216+4*i)*scale-ofsy
        x=cx+$int4(lx1+208)*scale+ofsx
        draw color=(rail==i && finger==0?LIGHTRED:PINK)
        draw at x-hx,y-hy rect x+hx,y+hy
        x=cx+$int4(lx1+212)*scale+ofsx
        draw color=(rail==i && finger==1?LIGHTRED:PINK)
        draw at x-hx,y-hy rect x+hx,y+hy
      endif
    enddo
    draw clip=NULL
  enddo
  for i=0,i<l.nfing,i++                // Redraw excluded top rails
    if l.side[i]!=0 continue
    y0=cy-l.bottom[i]*scale
    y1=cy-l.top[i]*scale
    if ($int2(l+764) & (1<<i))!=0 then
      draw color=LIGHTBLUE             // Rail is excluded from bootstrap
      draw at x0,y1 to x1,y0
      draw at x0,y0 to x1,y1
    endif
  enddo
  draw color=BLUE
  y0=cy-ymin*scale
  y1=cy-ymax*scale
  draw at x0,y1 rect x1,y0+1
  draw font=SMALLFONT mode=M_LEFT
  for i=0,i<l.nfing,i++                // Redraw top frames and draw names
    y0=cy-l.bottom[i]*scale
    y1=cy-l.top[i]*scale
    if l.side[i]==0 then
      if i==rail then
        draw color=LIGHTRED bkcolor=WHITEBLUE
        if finger==0 draw at x0+10,y0-9 fillellipse 19,19
        if finger==1 draw at x1-14,y0-9 fillellipse 19,19
      endif
      draw color=BLUE mode=M_LEFT
      draw at x0,y1 rect x1,y0+1
      draw at x0+5,y0-2 text=format("%iL",i)
      if (l.headcameras & (1<<2*i))!=0 &&                                      \
        (l.cameras==0 || (l.config & LC_TYPEMASK)==LC_S3) then
        draw at x0+22,y0-2 mode=M_LEFT
        draw text=(scale<0.0003?"Hcam":"头相机")
      endif
      draw at x1-20,y0-2 text=format("%iR",i)
      if (l.headcameras & (2<<2*i))!=0 &&                                      \
        (l.cameras==0 || (l.config & LC_TYPEMASK)==LC_S3) then
        draw at x1-24,y0-2 mode=M_RIGHT
        draw text=(scale<0.0003?"Hcam":"头相机")
      endif
    else
      if i==rail then
        draw color=LIGHTRED bkcolor=WHITEBLUE
        if finger==0 draw at x0+ofsx+10,y0-ofsy-9 fillellipse 19,19
        if finger==1 draw at x1+ofsx-14,y0-ofsy-9 fillellipse 19,19
      endif
      draw color=RED mode=M_LEFT
      draw at x0+ofsx+5,y0-ofsy-2 text=format("%iL",i)
      if (l.headcameras & (1<<2*i))!=0 &&                                      \
        (l.cameras==0 || (l.config & LC_TYPEMASK)==LC_S3) then
        draw at x0+ofsx+22,y0-ofsy-2 mode=M_LEFT
        draw text=(scale<0.0003?"Hcam":"头相机")
      endif
      draw at x1+ofsx-20,y0-ofsy-2 text=format("%iR",i)
      if (l.headcameras & (2<<2*i))!=0 &&                                      \
        (l.cameras==0 || (l.config & LC_TYPEMASK)==LC_S3) then
        draw at x1+ofsx-24,y0-ofsy-2 mode=M_RIGHT
        draw text=(scale<0.0003?"Hcam":"头相机")
      endif
    endif
  enddo
  if scanshift!=0 then
    draw color=LIGHTRED mode=M_CENTERED font=MEDIUMFONT
    draw at VIX/2,VIY-5
    if scanshift<0 then
      draw text=format("<< Use cross %i mm to the left",-scanshift)
    else
      draw text=format("Use cross %i mm to the right >>",scanshift)
    endif
  endif
  draw show
end

function int Showgeometry()
  int i,j,head,y,dy,delta,yoffs
  if l.nfing<=10 then
    dy=24; delta=7
  else if l.nfing<=12 then
    dy=22; delta=5
  else if l.nfing==15 && l.cameras!=0 then
    dy=19; delta=1
  else
    dy=20; delta=2
  endif
  y=EY0+4
  change hgeneral position=EX0+5,y,81,dy
  y=y+dy+delta
  yoffs=0
  if showgeneral!=0 then
    change hgeneral color=LIGHTRED
    change hgeneral bkcolor=WHITEBLUE
  else
    change hgeneral color=BLACK
    change hgeneral bkcolor=GRAY
  endif
  for j=0,j<=l.nfing,j++
    if j==l.nfing && l.cameras==0 break
    if j<=15 then
      if j<l.nfing && l.side[j]!=0 yoffs=delta
      if j==l.nfing yoffs=yoffs+delta
    endif
    for i=0,i<2,i++ do
      if j==l.nfing && (l.cameras & (1<<i))==0 continue
      change hhead[j][i] position=EX0+5+i*41,y+dy*j+yoffs,40,dy-1
      if showgeneral==0 && showshuttle==0 && j==railbtn && i==finger then
        change hhead[j][i] color=LIGHTRED
        change hhead[j][i] bkcolor=WHITEBLUE
      else if (j<l.nfing && ($int2(l+764) & (1<<j))!=0) ||                     \
        (j==l.nfing && ($int2(l+764) & (0x4000<<i))!=0) then
        change hhead[j][i] color=DARKGRAY
        change hhead[j][i] bkcolor=GRAY
      else
        change hhead[j][i] color=BLACK
        change hhead[j][i] bkcolor=GRAY
      endif
    enddo
  enddo
  change hshuttle position=EX0+5,y+yoffs+dy*j+delta,81,dy-1
  if showshuttle!=0 then
    change hshuttle color=LIGHTRED
    change hshuttle bkcolor=WHITEBLUE
  else
    change hshuttle color=BLACK
    change hshuttle bkcolor=GRAY
  endif
  if hleftlimit!=NULL then
    change hleftlimit text=format("%.3f",l.leftlimit/1000.0)
    change hrightlimit text=format("%.3f",l.rightlimit/1000.0)
    change hcenterx text=format("%.3f",l.xoffset/1000.0)
  endif
  if hradius!=NULL then
    if $int4(lx+424)==0 then
      change hradius text="默认"
    else
      change hradius text=format("%.3f",$int4(lx+424)/1000.0)
    endif
  endif
  if hcamradius!=NULL then
    if l.cameras!=0 && (l.config & LC_TYPEMASK)!=LC_S3 then
      change hcamradius text="无"
    else
      change hcamradius text=format("%.3f",$int4(lx+428)/1000.0)
    endif
  endif
  head=rail*2+finger
  if hvideodead!=NULL then
    change hvideodead text=format("%.3f",l.videodeadx/1000.0)
  endif
  if hdeadsplit!=NULL then
    change hdeadsplit text=format("%.3f",$int4(lx0+578)/1000.0)
  endif
  if henable!=NULL then
    if rail==l.nfing && finger==0 then
      change henable text=format("Top:")
    else if rail==l.nfing && finger==1 then
      change henable text=format("Bottom:")
    else
      change henable text=format("轨道 %i:",railbtn)
    endif
  endif
  if hside!=NULL then
    if rail>16 then
      change hside text=""
    else if rail==l.nfing then
      change hside text="VIDEO"
    else if (l.config & LC_ISM2)!=0 then
      change hside text=(l.side[rail]==0?"CHIP":"I/O")
    else
      change hside text=(l.side[rail]==0?"顶部":"底部")
    endif
  endif
  if hysens!=NULL then
    if (l.config & LC_ISM2)!=0 then
      if rail==l.nfing && finger==1 then
        i=(l.sensorpos[rail]>>4) & 0x0F;
      else
        i=l.sensorpos[rail] & 0x0F; endif
      change hysens text=format(" %i",i)
    else if rail==l.nfing then
      change hysens text=((l.sensorpos[rail] & 8)==0?"默认":"反向")
    else
      change hysens text=((l.sensorpos[rail] & 1)==0?"低":"高")
    endif
  endif
  if hheadcamera!=NULL then
    if ($char(lx+736+head) & (HO_CAMOFF|HO_HIRES))==(HO_CAMOFF|HO_HIRES) then
      change hheadcamera select=6
    else if ($char(lx+736+head) & (HO_CAMOFF|HO_HIRES))==HO_CAMOFF then
      change hheadcamera select=5
    else if (l.headcameras & (1<<head))==0 then
      change hheadcamera select=0
    else if ($int4(lx+432) & (1<<head))==0 then
      if ($char(lx+736+head) & HO_HIRES)==0 then
        change hheadcamera select=1    // Ordinary head camera
      else
        change hheadcamera select=3    // High-resolution heavy head camera
      endif
    else
      if ($char(lx+736+head) & HO_HIRES)==0 then
        change hheadcamera select=2    // Head camera with rotated chip
      else
        change hheadcamera select=4    // Hi-res head camera with rotated chip
      endif
    endif
  endif
  if showshuttle || (rail<l.nfing && ($int2(l+764) & (1<<rail))!=0) ||         \
    (rail==l.nfing && ($int2(l+764) & (0x4000<<finger))!=0)                    \
  then
    // Disabled rail or dedicated camera.
    if henable!=NULL change henable mode=0
    if hside!=NULL then
      change hside text="Excluded"
      disable hside
    endif
    if hchgside!=NULL disable hchgside
    if hxenc!=NULL then
      change hxenc text=""
      disable hxenc
      disable hchgxenc
    endif
    if hysens!=NULL then
      change hysens text=""
      disable hysens
      disable hchgysens
    endif
    if hbackdrill!=NULL then
      disable hbackdrill
    endif
    if htoplimit!=NULL then
      disable htoplimit
      disable hcentery
      disable hbottomlimit
    endif
    if hwarmupdx!=NULL then
      disable hwarmupdx
      disable hwarmupdy
      disable hwarmupx
      disable hwarmupy
    endif
    if hxshift!=NULL then
      change hxshift text=""
      disable hxshift
      change hyshift text=""
      disable hyshift
    endif
    disable hup
    disable hdown
    disable hleft
    disable hright
    disable hshow
  else
    // Enabled rail or dedicated camera.
    if henable!=NULL then
      enable hside
      change henable mode=M_CHECKED
    endif
    if hchgside!=NULL enable hchgside
    if hxenc!=NULL then
      enable hxenc
      enable hchgxenc
      change hxenc text=((l.sensorpos[rail] & 2)==0?"默认":"反向")
    endif
    if hysens!=NULL then
      enable hysens
      enable hchgysens
    endif
    if hbackdrill!=NULL then
      enable hbackdrill
    endif
    if htoplimit!=NULL then
      enable htoplimit
      enable hcentery
      enable hbottomlimit
    endif
    if hwarmupdx!=NULL then
      enable hwarmupdx
      enable hwarmupdy
      enable hwarmupx
      enable hwarmupy
    endif
    if hxshift!=NULL then
      if finger==0 then
        enable hxshift
        change hxshift text=format("%.3f",l.leftzerox[rail]/1000.0)
        enable hyshift
        change hyshift text=format("%.3f",l.leftzeroy[rail]/1000.0)
      else
        enable hxshift
        change hxshift text=format("%.3f",l.rightzerox[rail]/1000.0)
        enable hyshift
        change hyshift text=format("%.3f",l.rightzeroy[rail]/1000.0)
      endif
    endif
    enable hup
    enable hdown
    enable hleft
    enable hright
    enable hshow
  endif
  if hbackdrill!=NULL then
    change hbackdrill mode=($uint4(lx0+574) & (1<<head))==0?0:M_CHECKED
  endif
  if htoplimit!=NULL then
    change htoplimit text=format("%.3f",l.top[rail]/1000.0)
    change hcentery text=format("%.3f",l.yoffset[rail]/1000.0)
    change hbottomlimit text=format("%.3f",l.bottom[rail]/1000.0)
  endif
  if hwarmupdx!=NULL then
    change hwarmupdx text=format("%.3f",$uint2(lx1+196)/1000.0)
    change hwarmupdy text=format("%.3f",$uint2(lx1+198)/1000.0)
    if l.side[rail]!=0 then            // Rail on the bottom side
      change hwarmupx text=format("%.3f",$int4(lx1+208+4*finger)/1000.0)
    else                               // Rail on the top side
      change hwarmupx text=format("%.3f",$int4(lx1+200+4*finger)/1000.0)
    endif
    change hwarmupy text=format("%.3f",$int4(lx1+216+4*rail)/1000.0)
  endif
  if hcether!=NULL then
    if rail==l.nfing || (l.headcameras & (1<<head))!=0 then
      enable hcether
    else
      disable hcether
    endif
    change hcether mode=($int1(lx0+390+head*4) & 0x80?M_CHECKED:0)
    if (rail==l.nfing || (l.headcameras & (1<<head))!=0) &&                    \
      ($int1(lx0+390+head*4) & 0x80)!=0                                        \
    then
      change hcmac text=format("%02X:%02X:%02X",                               \
        $uint1(lx0+391+head*4),$uint1(lx0+392+head*4),$uint1(lx0+393+head*4))
      enable hcmac
    else
      change hcmac text=""
      disable hcmac
    endif
    if rail==l.nfing || (l.headcameras & (1<<head))!=0 then
      change hcangle text=format("%.2f",                                       \
        $int1(lx+638+head)*0.02864789)
      enable hcangle
    else
      change hcangle text=""
      disable hcangle
    endif
  endif
  if hzshift!=NULL then
    if rail<l.nfing || ($int2(l+764) & (0x4000<<finger))!=0 then
      change hzshift text=""
      disable hzshift
    else
      enable hzshift
      change hzshift text=format("%.3f",$int2(lx+272+rail*4+finger*2)/1000.0)
    endif
  endif
  if hyshuttle!=NULL then
    if (l.config & LC_TYPEMASK)==LC_S3 || (l.config & LC_SMASK)==LC_LMSPLIT then
      enable hyshuttle
      change hyshuttle text=format("%.3f",$int4(lx+728)/1000.0)
    else
      change hyshuttle text=""
      disable hyshuttle
    endif
    if (l.config & LC_TYPEMASK)==LC_S3 then
      enable hyunlock
      change hyunlock text=format("%.3f",$int4(lx+732)/1000.0)
      enable hyauto
      change hyauto text=format("%.3f",$int4(lx+724)/1000.0)
    else
      change hyunlock text=""
      disable hyunlock
      change hyauto text=""
      disable hyauto
    endif
    if (l.config & LC_TYPEMASK)==LC_S3 && (l.config & LC_SMASK)==LC_LMSPLIT then
      enable hyoffset
      change hyoffset text=format("%.3f",$int4(lx+720)/1000.0)
      enable hybase[0]
      change hybase[0] text=format("%.4f",$int4(lx0+582)/256000.0)
      enable hybase[1]
      change hybase[1] text=format("%.4f",$int4(lx0+586)/256000.0)
    else
      change hyoffset text=""
      disable hyoffset
      change hybase[0] text=""
      disable hybase[0]
      change hybase[1] text=""
      disable hybase[1]
    endif
  endif
  if hshuttlel!=NULL then
    if scanshift<0 then
      change hshuttlel color=YELLOW
      change hshuttlel bkcolor=LIGHTRED
    else
      change hshuttlel color=BLACK
      change hshuttlel bkcolor=LIGHTGRAY
    endif
    if scanshift>0 then
      change hshuttler color=YELLOW
      change hshuttler bkcolor=LIGHTRED
    else
      change hshuttler color=BLACK
      change hshuttler bkcolor=LIGHTGRAY
    endif
  endif
  change hdeftester select=deftester
  Plotgeometry(hviewer,VIX,VIY)
end

function int Getgeometry()
  int i,mac3,mac4,mac5,head
  char s[64]
  float r
  head=rail*2+finger
  if hleftlimit!=NULL then
    Text(hleftlimit,s); r=0; sscanf(s,"%f",&r)
    l.leftlimit=Floor(r*1000.0+0.5)
    Text(hrightlimit,s); r=0; sscanf(s,"%f",&r)
    l.rightlimit=Floor(r*1000.0+0.5)
    Text(hcenterx,s); r=0; sscanf(s,"%f",&r)
    l.xoffset=Floor(r*1000.0+0.5)
  endif
  if hradius!=NULL then
    Text(hradius,s); r=0; sscanf(s,"%f",&r)
    $int4(lx+424)=Floor(r*1000.0+0.5)
  endif
  if hcamradius!=NULL then
    Text(hcamradius,s)
    if Toupper(s[0])!='N' then
      r=0; sscanf(s,"%f",&r)
      $int4(lx+428)=Floor(r*1000.0+0.5)
    endif
  endif
  if hvideodead!=NULL then
    Text(hvideodead,s); r=0; sscanf(s,"%f",&r)
    l.videodeadx=Floor(r*1000.0+0.5)
  endif
  if hdeadsplit!=NULL then
    Text(hdeadsplit,s); r=0; sscanf(s,"%f",&r)
    $int4(lx0+578)=Max(0.0,Floor(r*1000.0+0.5))
  endif
  if hbackdrill!=NULL then
    if Status(hbackdrill)==0 then
      $uint4(lx0+574)=$uint4(lx0+574) & (~(1<<head))
    else
      $uint4(lx0+574)=$uint4(lx0+574) | (1<<head)
    endif
  endif
  if (rail<l.nfing && ($int2(l+764) & (1<<rail))==0) ||                        \
    (rail==l.nfing && ($int2(l+764) & (0x4000<<finger))==0)                    \
  then
    if htoplimit!=NULL then
      Text(htoplimit,s); r=0; sscanf(s,"%f",&r)
      l.top[rail]=Floor(r*1000.0+0.5)
      Text(hcentery,s); r=0; sscanf(s,"%f",&r)
      l.yoffset[rail]=Floor(r*1000.0+0.5)
      Text(hbottomlimit,s); r=0; sscanf(s,"%f",&r)
      l.bottom[rail]=Floor(r*1000.0+0.5)
    endif
    if hcangle!=NULL then
      Text(hcangle,s); r=0.0; sscanf(s,"%f",&r)
      i=Floor(r/0.02864789+0.5)
      i=Max(-127,Min(i,127))
      $int1(lx+638+head)=i
    endif
    if hxshift!=NULL then
      Text(hxshift,s); r=0; sscanf(s,"%f",&r);
      if finger==0 then
        l.leftzerox[rail]=Floor(r*1000.0+0.5)
      else
        l.rightzerox[rail]=Floor(r*1000.0+0.5)
      endif
      Text(hyshift,s); r=0; sscanf(s,"%f",&r);
      if finger==0 then
        l.leftzeroy[rail]=Floor(r*1000.0+0.5)
      else
        l.rightzeroy[rail]=Floor(r*1000.0+0.5)
      endif
    endif
  endif
  if hwarmupdx!=NULL then
    Text(hwarmupdx,s); r=0; sscanf(s,"%f",&r)
    r=Max(0.0,Min(r,10.0))
    $uint2(lx1+196)=Floor(r*1000.0+0.5)
    Text(hwarmupdy,s); r=0; sscanf(s,"%f",&r)
    r=Max(0.0,Min(r,10.0))
    $uint2(lx1+198)=Floor(r*1000.0+0.5)
    Text(hwarmupx,s); r=0; sscanf(s,"%f",&r)
    r=Max(-8000.0,Min(r,8000.0))
    if l.side[rail]!=0 then            // Rail on the bottom side
      $int4(lx1+208+4*finger)=Floor(r*1000.0+0.5)
    else                               // Rail on the top side
      $int4(lx1+200+4*finger)=Floor(r*1000.0+0.5)
    endif
    Text(hwarmupy,s); r=0; sscanf(s,"%f",&r)
    r=Max(-8000.0,Min(r,8000.0))
    $int4(lx1+216+4*rail)=Floor(r*1000.0+0.5)
  endif
  if hcmac!=NULL && (rail==l.nfing || (l.headcameras & (1<<head))!=0) &&       \
    ($int1(lx0+390+head*4) & 0x80)!=0                                          \
  then
    Text(hcmac,s); mac3=0; mac4=0; mac5=0
    sscanf(s,"%X:%X:%X",&mac3,&mac4,&mac5)
    $int1(lx0+391+head*4)=mac3
    $int1(lx0+392+head*4)=mac4
    $int1(lx0+393+head*4)=mac5
  endif
  if hzshift!=NULL && rail==l.nfing && ($int2(l+764) & (0x4000<<finger))==0 then
    Text(hzshift,s); r=0; sscanf(s,"%f",&r);
    lx.pfactor[head]=Floor(r*1000.0+0.5)
  endif
  if hyshuttle!=NULL &&                                                        \
    ((l.config & LC_TYPEMASK)==LC_S3 || (l.config & LC_SMASK)==LC_LMSPLIT)     \
  then
    Text(hyshuttle,s); r=0; sscanf(s,"%f",&r)
    $int4(lx+728)=Floor(r*1000.0+0.5)
  endif
  if hyunlock!=NULL && (l.config & LC_TYPEMASK)==LC_S3 then
    Text(hyunlock,s); r=0; sscanf(s,"%f",&r)
    $int4(lx+732)=Floor(r*1000.0+0.5)
  endif
  if hyauto!=NULL && (l.config & LC_TYPEMASK)==LC_S3 then
    Text(hyauto,s); r=0; sscanf(s,"%f",&r)
    $int4(lx+724)=Floor(r*1000.0+0.5)
  endif
  if hyoffset!=NULL &&                                                         \
    (l.config & LC_TYPEMASK)==LC_S3 && (l.config & LC_SMASK)==LC_LMSPLIT       \
  then
    Text(hyoffset,s); r=0; sscanf(s,"%f",&r)
    $int4(lx+720)=Floor(r*1000.0+0.5)
    Text(hybase[0],s); r=0; sscanf(s,"%f",&r)
    $int4(lx0+582)=Floor(r*256000.0+0.5)
    Text(hybase[1],s); r=0; sscanf(s,"%f",&r)
    $int4(lx0+586)=Floor(r*256000.0+0.5)
  endif
  deftester=Status(hdeftester)
end

// Calculate layout for the given tester (A1, A2, A2L, A3, A3L, A4, A5, A5L,
// A6, S1, S2, M2).
function int Presetgeometry(int type)
  int i,n,y,ystep,radius
  if type==0 || type==7 then
    n=l.nfing                          // All fingers on the top side
  else
    n=(l.nfing+1)/2                    // Half of fingers on the bottom side
  endif
  l.leftlimit=0
  if (type==0 || type==1) then         // A1,A2,A4,A6
    l.rightlimit=600000; ystep=155000; l.videodeadx=70000; radius=115000
  else if type==2 then                 // A2L
    l.rightlimit=800000; ystep=155000; l.videodeadx=100000; radius=115000
  else if type==3 then                 // A3
    l.rightlimit=450000; ystep=200000; l.videodeadx=25000; radius=150000
  else if type==4 then                 // A3L,A5,new A1
    l.rightlimit=520000; ystep=200000; l.videodeadx=25000; radius=150000
  else if type==5 then                 // A5L
    l.rightlimit=610000; ystep=225000; l.videodeadx=85000; radius=150000
  else if type==6 then                 // M2
    l.rightlimit=300000; ystep=45000; l.videodeadx=10000; radius=65000
  else if type==7 then                 // S1
    l.rightlimit=600000; ystep=155000; l.videodeadx=0; radius=115000
  else if type==8 then                 // S2           [Richie modified]
    l.rightlimit=600000; ystep=155000; l.videodeadx=0; radius=115000
  else if type==9 then                 // S2 small     [Richie Added]
    l.rightlimit=310000; ystep=155000; l.videodeadx=0; radius=115000
  else if type==10 then                // A7
    l.rightlimit=610000; ystep=250000; l.videodeadx=0; radius=180000
  else if type==11 then                // A8
    l.rightlimit=600000; ystep=155000; l.videodeadx=0; radius=115000
  endif
  l.xoffset=(l.leftlimit+l.rightlimit)/2
  $int4(lx+424)=radius
  y=0
  for i=0,i<n,i++
    l.side[i]=0
    if (type==0) then
      l.sensorpos[i]=0x01
    else if (type!=6) then
      l.sensorpos[i]=0x00
    endif
    l.bottom[i]=y; y=y+ystep; l.top[i]=y
    l.yoffset[i]=(l.top[i]+l.bottom[i])/2
    if type==5 && i==0 then
      l.top[i]=l.top[i]+5000
      l.yoffset[i]=l.yoffset[i]+5000
      y=y+5000
    else if type==5 && i==n-1 then
      l.top[i]=l.top[i]+5000
    endif
  enddo
  y=0
  for i=n,i<l.nfing,i++
    l.side[i]=1
    if (type==0) then
      l.sensorpos[i]=0x01
    else if (type!=6) then
      l.sensorpos[i]=0x00
    endif
    l.bottom[i]=y; y=y+ystep; l.top[i]=y
    l.yoffset[i]=(l.top[i]+l.bottom[i])/2
    if type==5 && i==n then
      l.top[i]=l.top[i]+5000
      l.yoffset[i]=l.yoffset[i]+5000
      y=y+5000
    else if type==5 && i==l.nfing-1 then
      l.top[i]=l.top[i]+5000
    endif
  enddo
  if l.cameras!=0 then
    l.side[l.nfing]=0
    if (type!=6) l.sensorpos[i]=0
    l.bottom[l.nfing]=0; l.top[l.nfing]=n*ystep
    if type==5 then
      l.bottom[l.nfing]=l.bottom[l.nfing]+35000
      l.top[l.nfing]=l.top[l.nfing]+10000-10000
      l.yoffset[l.nfing]=(l.yoffset[0]+l.yoffset[n-1])/2
    else
      l.yoffset[l.nfing]=(l.top[l.nfing]+l.bottom[l.nfing])/2
    endif
  endif
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// THERMIC PANEL /////////////////////////////////

#define TX1            20
#define TX2            120
#define TX3            320
#define TX4            360
#define TY0            10
#define TY1            18
#define TY2            74
#define TY3            219
#define TY4            362
#define TDY            26
#define TCY            25

function int Createthermal()
  int i,j,k,m,n,x,y,nsensor
  char s[32]
  clear hparm
  draw window=hparm font=INFOFONT color=BLACK bkcolor=LIGHTGREEN
  // Calibration date controls.
  draw at TX1,TY1+20 text="校验日期:"
  draw at TX2+98,TY1+20 text="在"
  draw at TX2+165,TY1+20 text="度"
  draw at TX1,TY1+TDY+20 text="电容校验:"
  hcaldate=control EDIT
    window=hparm
    position=TX2,TY1,93,22
    help="上次(成功)校准的日期"
    bkcolor=WHITE
    mode=M_NOEDIT
  endc
  hcaltemp=control EDIT
    window=hparm
    position=TX2+120,TY1,38,22
    help="上次(成功)校准期间的温度"
    bkcolor=WHITE
  endc
  hcadjdate=control EDIT
    window=hparm
    position=TX2,TY1+TDY,93,22
    help="上次(成功)电容校正的日期"
    bkcolor=WHITE
    mode=M_NOEDIT
  endc
  hsetcurdate=control WINBUTTON
    window=hparm
    position=TX3+1,TY1,150,22
    name="更新校验日期"
    help="双击可将上次校准的日期设置为当前日期"
    mode=M_DBLCLICK
    bkcolor=WHITEGREEN
    font=INFOFONT
  endc
  hsetcadjdate=control WINBUTTON
    window=hparm
    position=TX3+1,TY1+TDY,150,22
    name="更新电容校验日期"
    help="双击可将上次电容校准的日期设置为当前日期"
    mode=M_DBLCLICK
    bkcolor=WHITEGREEN
    font=INFOFONT
  endc
  // Thermic controls.
  draw at TX1+110,TY2+43 text="热延伸 ="
  draw at TX1+237,TY2+43 text="um/100度, 压力因素 ="
  draw at TX1+468,TY2+43 text="um/100 单位"
  htmeason=control CHECKBOX
    window=hparm
    position=TX1,TY2,260,22
    text="打开温度测量"
    help="测量空气温度并启用温度校正"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_TMEASOFF)==0?M_CHECKED:0)
  endc
  hthermexp=control EDIT
    window=hparm
    position=TX2+80,TY2+24,48,22
    help="设置手臂长度的增加，当加热到100度"
    bkcolor=WHITE
  endc
  hpresscor=control EDIT
    window=hparm
    position=TX2+310,TY2+24,48,22
    help="设置手臂长度的增加，压力为100单位"
    bkcolor=WHITE
  endc
  hchecktemp=control CHECKBOX
    window=hparm
    position=TX1,TY2+TDY+28,200,19
    name="监测马达温度"
    help="监控电机温度，如果电机过热则降低电流"
    font=INFOFONT
    mode=(($int4(lx+4) & HCX_TSENS)!=0?M_CHECKED:0)
  endc
  htfiltoff=control CHECKBOX
    window=hparm
    position=TX3,TY2+TDY+28,220,19
    name="过滤温度数据"
    help="过滤器温度测量数分钟"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_TFILTOFF)==0?M_CHECKED:0)
  endc
  for i=0,i<24,i++ do
    htemphead[i]=control CHECKBOX
      window=hparm
      position=TX1+20+(i%8)*40+(i%8/2)*16,TY2+2*TDY+(i/8)*20+26,39,19
      name=format("%i%s",i/2,i & 1?"R":"L")
      help=format("检查启用测试头%i%s上的电机温度监控", \
        i/2,i & 1?"R":"L")
      font=INFOFONT
      mode=(($int4(lx+712) & (1<<i))==0?M_CHECKED:0)
    endc
  enddo
  hallthon=control WINBUTTON
    window=hparm
    position=TX1+415,TY2+2*TDY+33,40,18
    name="全开"
    help="激活所有测试头的温度测量"
    bkcolor=WHITEGREEN
    font=SMALLFONT
  endc
  hallthoff=control WINBUTTON
    window=hparm
    position=TX1+415,TY2+2*TDY+57,40,18
    name="全关"
    help="停用所有测试头的温度测量"
    bkcolor=WHITEGREEN
    font=SMALLFONT
  endc
  // Temperature array.
  draw at TX1,TY3+16 text="温度感应器阵列。备注： "
  draw text="底部轨道的数字从0开始。"
  if ($int4(lx+512) & HCA_TAMASK)==HCA_TATYPE1 then
    nsensor=128
  else
    nsensor=32
  endif
  haclient=control CHILD
    window=hparm
    position=TX1+20,TY3+22,520,115
    help=" "
    bkcolor=WHITECYAN
    mode=M_VSCROLL
    size=4096
    limits=TX1-24,(nsensor==32?235:955)
  endc
  draw window=haclient mode=M_RIGHT font=INFOFONT
  for i=0,i<128,i++ do
    if i>=nsensor then
      harraypos[i]=NULL
      continue
    endif
    x=(i%4)*120+20
    y=(i/4)*27+5
    y=y+(i/16)*12
    draw at x+15,y+20 text=format("%i:",i)
    harraypos[i]=control COMBOLIST
      window=haclient
      position=x+18,y,90,400
      help=format("温度传感器%i的位置",i)
      mode=M_VSCROLL
    endc
    add harraypos[i] text="无"
    for j=0,j<2,j++ do
      for k=0,k<8,k++ do
        for m=0,m<3,m++ do
          if k==7 && j==0 then
            n=sprintf(s,"V top ")
          else if k==7 && j==1 then
            n=sprintf(s,"V bot ")
          else
            n=sprintf(s,"%s ",j==0?"Top":"Bot")
            n=n+sprintf(s+n,"%i ",k)
          endif
          if m==0 then
            sprintf(s+n,"L")
          else if m==1 then
            sprintf(s+n,"M")
          else
            sprintf(s+n,"R")
          endif
          add harraypos[i] text=s
        enddo
      enddo
    enddo
    add harraypos[i] text="Stone top"
    add harraypos[i] text="Stone bot"
    add harraypos[i] text="Air top"
    add harraypos[i] text="Air bot"
    add harraypos[i] text="Front top"
    add harraypos[i] text="Front bot"
    add harraypos[i] text="Outside"
    add harraypos[i] text="Heater L0"
    add harraypos[i] text="Heater R0"
    add harraypos[i] text="Heater L1"
    add harraypos[i] text="Heater R1"
    add harraypos[i] text="Heater L2"
    add harraypos[i] text="Heater R2"
    add harraypos[i] text="Heater L3"
    add harraypos[i] text="Heater R3"
    if i<32 then
      j=$char(lx0+518+i)
    else
      j=$char(lx0+606+(i-32))
    endif
    if j==0x87 then
      k=49                             // Stone top
    else if j==0xC7 then
      k=50                             // Stone bottom
    else if j==0x08 then
      k=51                             // Air temperature top
    else if j==0x48 then
      k=52                             // Air temperature bottom
    else if j==0x09 then
      k=53                             // Front air temperature top
    else if j==0x49 then
      k=54                             // Front air temperature bottom
    else if j==0x0A then
      k=55                             // Air temperature outside the tester
    else if j==0x0B then
      k=56                             // Air temperature of left heater 0
    else if j==0x0C then
      k=57                             // Air temperature of right heater 0
    else if j==0x0D then
      k=58                             // Air temperature of left heater 1
    else if j==0x0E then
      k=59                             // Air temperature of right heater 1
    else if j==0x0F then
      k=60                             // Air temperature of left heater 2
    else if j==0x10 then
      k=61                             // Air temperature of right heater 2
    else if j==0x11 then
      k=62                             // Air temperature of left heater 3
    else if j==0x12 then
      k=63                             // Air temperature of right heater 3
    else if (j & 0x87)==0x80 then
      k=((j>>3) & 0x0F)*3+1
    else if (j & 0x87)==0x82 then
      k=((j>>3) & 0x0F)*3+2
    else if (j & 0x87)==0x84 then
      k=((j>>3) & 0x0F)*3+3
    else
      k=0                              // Unknown sensor location
    endif
    change harraypos[i] select=k
  enddo
  draw show
  // Temperature stabilization.
  draw window=hparm font=INFOFONT
  draw mode=M_LEFT at TX1,TY4+16 text="稳定温度至:"
  draw at TX1+20,TY4+40 text="上水平面"
  draw at TX1+140,TY4+40 text=",下水平面"
  draw at TX1+265,TY4+40 text=",上垂直面"
  draw at TX1+380,TY4+40 text=",下垂直面"
  draw at TX1+503,TY4+40 text="度"
  htemphtop=control EDIT
    window=hparm
    position=TX1+90,TY4+21,50,22
    help="设定上部测试头的平均温度"
    bkcolor=WHITE
  endc
  htemphbot=control EDIT
    window=hparm
    position=TX1+212,TY4+21,50,22
    help="设定底部测试头的平均温度"
    bkcolor=WHITE
  endc
  htempvtop=control EDIT
    window=hparm
    position=TX1+336,TY4+21,50,22
    help="设置上部专用摄像机的平均温度"
    bkcolor=WHITE
  endc
  htempvbot=control EDIT
    window=hparm
    position=TX1+452,TY4+21,50,22
    help="设置底部专用摄像机的平均温度"
    bkcolor=WHITE
  endc
  draw show
end

// Display thermal parameters on the screen. This procedure also tries to
// correct some obvious errors.
function int Showthermal()
  int head,hmax
  char s[64]
  if l.caldate==0 then
    change hcaldate text="    (No date)"
  else
    Strtime(s,"%d-%b-%Y",2,l.caldate & 0xFFFF)
    change hcaldate text=s
  endif
  if (l.caltemp<=0 || l.caltemp>500) l.caltemp=220
  change hcaltemp text=format("%2i.%i",l.caltemp/10,l.caltemp%10)
  if $uint2(lx+586)==0 then
    change hcadjdate text="    (No date)"
  else
    Strtime(s,"%d-%b-%Y",2,$uint2(lx+586))
    change hcadjdate text=s
  endif
  l.thermexp=Max(-1000,Min(5000,l.thermexp))
  change hthermexp text=format("%i",l.thermexp)
  l.presscor=Max(-500,Min(500,l.presscor))
  change hpresscor text=format("%i",l.presscor)
  if ($int4(lx+496) & HCM_TMEASOFF)!=0 then
    disable hthermexp; change hthermexp bkcolor=LIGHTGRAY
  else
    enable hthermexp; change hthermexp bkcolor=WHITE
  endif
  hmax=l.nfing*2
  if (l.cameras & 2)!=0 then
    hmax=hmax+2
  else if (l.cameras & 1)!=0 then
    hmax++
  endif
  for head=0,head<32,head++ do
    if head>=hmax || ($int4(lx+4) & HCX_TSENS)==0 then
      disable htemphead[head]
    else
      enable htemphead[head]
    endif
    change htemphead[head] mode=(($int4(lx+712) & (1<<head))==0?M_CHECKED:0)
  enddo
  change htemphtop text=format("%.2f",$int2(lx0+550)/100.0)
  change htemphbot text=format("%.2f",$int2(lx0+552)/100.0)
  change htempvtop text=format("%.2f",$int2(lx0+554)/100.0)
  change htempvbot text=format("%.2f",$int2(lx0+556)/100.0)
end

// Get settings of those controls which are not automatically updated.
function int Getthermal()
  int i
  float f
  char s[64]
  Text(hcaltemp,s); f=0; sscanf(s,"%f",&f); l.caltemp=Floor(f*10.0+0.5)
  Text(hthermexp,s); i=0; sscanf(s,"%i",&i); l.thermexp=i
  Text(hpresscor,s); i=0; sscanf(s,"%i",&i); l.presscor=i
  Text(htemphtop,s); f=0; sscanf(s,"%f",&f); $int2(lx0+550)=Floor(f*100.0+0.5)
  Text(htemphbot,s); f=0; sscanf(s,"%f",&f); $int2(lx0+552)=Floor(f*100.0+0.5)
  Text(htempvtop,s); f=0; sscanf(s,"%f",&f); $int2(lx0+554)=Floor(f*100.0+0.5)
  Text(htempvbot,s); f=0; sscanf(s,"%f",&f); $int2(lx0+556)=Floor(f*100.0+0.5)
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// MEAS PANEL //////////////////////////////////

#define MX0            10
#define MX1            125
#define MY0            10
#define MY1            85
#define MDX            160
#define MDY            25

function int Createmeas()
  char currname[9][10] = { "100 mA DC", "30 mA DC", "10 mA DC", "3 mA DC",     \
    "1 mA DC", "300 uA DC", "100 uA DC", "30 uA DC", "10 uA DC" };
  char voltname[6][10] = { "9 V DC", "0.9 V DC", "10 V AC", "1 V AC",          \
    "100 mV AC", "10 mV AC" };
  int i,j,yoffs,delta,dy
  clear hparm
  draw window=hparm font=INFOFONT color=BLACK bkcolor=LIGHTYELLOW
  draw at MX0,MY0 fillrect MX0+91,MY0+403
  if l.nfing<=10 then dy=24; delta=7
  else if l.nfing<=12 then dy=22; delta=5
  else if l.nfing==15 && l.cameras!=0 then dy=19; delta=1
  else dy=20; delta=2; endif
  yoffs=0
  if rail>=l.nfing then
    rail=0; railbtn=0
  endif
  showshuttle=0
  for j=0,j<l.nfing,j++
    if l.side[j]!=0 yoffs=delta
    do i=0,1,1
      hhead[j,i]=control WINBUTTON
        window=hparm
        position=MX0+5+i*41,MY0+4+dy*j+yoffs,40,dy-1
        name=format("%i%c",j,(i==0?'L':'R'))
        help=format("按下可选择%s测试头上轨道%i",i==0?"left":"right",j)
      endc
      if j==rail && i==finger then
        change hhead[j][i] color=LIGHTRED
        change hhead[j][i] bkcolor=WHITEBLUE
      else if ($int2(l+764) & (1<<j))!=0 then
        change hhead[j][i] color=DARKGRAY
        change hhead[j][i] bkcolor=GRAY
      endif
    enddo
  enddo
  draw window=hparm font=INFOFONT
  draw at MX1,MY0+19 text="300 mA DC"
  hi300ma=control EDIT
    window=hparm
    position=MX1+75,MY0,66,22
    help="指定300毫安的准确电流"
    bkcolor=WHITE
  endc
  do i=0,8,1
    draw at MX1,MY0+19+i*MDY+MDY text=currname[i]
    hcurrent[i]=control EDIT
      window=hparm
      position=MX1+75,MY0+i*MDY+MDY,66,22
      help=format("指定与%s对应的精确电流",currname[i])
      bkcolor=WHITE
    endc
  enddo
  do i=0,5,1
    draw at MX1+MDX,MY0+19+i*MDY text=voltname[i]
    hvoltage[i]=control EDIT
      window=hparm
      position=MX1+MDX+75,MY0+i*MDY,66,22
      help=format("指定与%s对应的精确电压",voltname[i])
      bkcolor=WHITE
    endc
  enddo
  draw at MX1+MDX,MY0+19+6*MDY text="100 kOhm"
  hr100k=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+6*MDY,66,22
    help="指定头部卡反馈电阻的标称值，千欧"
    bkcolor=WHITE
  endc
  draw at MX1+MDX,MY0+19+7*MDY text="电容阈值"
  hclowest=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+7*MDY,66,22
    help="指定焊盘的最低可能容量， bits (1 bit ~ 1 fF)"
    bkcolor=WHITE
  endc
  draw at MX1+MDX-13,MY0+19+8*MDY text="电容架板框"
  hcshlimit=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+8*MDY,66,22
    help="架板框在外部天线0处的最低自身电容量，pF"
    bkcolor=WHITE
  endc
  if ($int4(lx+336) & 1)==0 disable hcshlimit
  draw at MX1+MDX,MY0+19+9*MDY text="交流频率"
  hfrequency=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+9*MDY,66,22
    help="指定电场和电容测量的默认频率，Hz"
    bkcolor=WHITE
  endc
  draw at MX1+MDX,MY0+19+11*MDY text="电感补偿"
  hlzero=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+11*MDY,66,22
    help="指定剩余电感,微亨"
    bkcolor=WHITE
  endc
  draw at MX1+MDX,MY0+19+12*MDY text="感抗"
  hlrshift=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+12*MDY,66,22
    help="指定通过电感测量的电阻的校正，欧姆"
    bkcolor=WHITEBLUE
  endc
  draw at MX1+MDX,MY0+19+13*MDY text="电感相位0"
  hlphase0=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+13*MDY,66,22
    help="指定0范围内感应系数的相位校正，微亨利/欧姆"
    bkcolor=WHITEBLUE
  endc
  draw at MX1+MDX,MY0+19+14*MDY text="电感相位1"
  hlphase1=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+14*MDY,66,22
    help="指定1范围内感应系数的相位校正，微亨利/欧姆"
    bkcolor=WHITEBLUE
  endc
  draw at MX1+MDX,MY0+19+15*MDY text="电感频率"
  hlfreq=control EDIT
    window=hparm
    position=MX1+MDX+75,MY0+15*MDY,66,22
    help="电感测量的频率，Hz-风险自负！"
    bkcolor=WHITEBLUE
  endc
  draw at MX1+2*MDX,MY0+19 text="电阻补偿"
  hrzero=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY0,66,22
    help="指定短路针之间的最小电阻，欧姆"
    bkcolor=WHITE
    mode=M_HSCROLL
  endc
  draw at MX1+2*MDX,MY0+19+MDY text="4线补偿"
  hkelvzero=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY0+MDY,66,22
    help="指定短路的开尔文针之间的最小电阻，欧姆"
    bkcolor=WHITE
    mode=M_HSCROLL
  endc
  draw at MX1+2*MDX,MY0+19+2*MDY text="主频"
  hmainsf=control COMBOLIST
    window=hparm
    position=MX1+2*MDX+75,MY0+2*MDY,66,100
    help="指定主频率，Hz"
    bkcolor=WHITE
  endc
  add hmainsf text="50 Hz"
  add hmainsf text="60 Hz"
  draw at MX1+2*MDX,MY1+21 text="单个参数:"
  draw at MX1+2*MDX,MY1+19+MDY text="电阻校正"
  hradj=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+MDY,66,22
    help="指定单个测试头电阻校正，欧姆"
    bkcolor=LIGHTYELLOW
  endc
  draw at MX1+2*MDX,MY1+19+2*MDY text="针头电阻"
  hrneedle=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+2*MDY,66,22
    help="从头部卡到LA 针头的回路电阻，欧姆"
    bkcolor=LIGHTYELLOW
  endc
  if (l.probetype & 0x1)==0 disable hrneedle
  draw at MX1+2*MDX,MY1+19+3*MDY text="正弦校正"
  hsinadj=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+3*MDY,66,22
    help="指定单个头部卡的正弦校正，位"
    bkcolor=LIGHTYELLOW
  endc
  draw at MX1+2*MDX,MY1+19+4*MDY text="余弦校正"
  hcosadj=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+4*MDY,66,22
    help="指定单个头部卡的余弦校正，位"
    bkcolor=LIGHTYELLOW
  endc
  if (l.config & LC_OHTYPE)!=LC_ACTIVE && (l.config & LC_OHTYPE)!=LC_PHADJ then
    disable hsinadj                    // on-heads are specified in layout
    disable hcosadj
  endif
  draw at MX1+2*MDX-21,MY1+19+5*MDY text="电容相位校正"
  hcphadj=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+5*MDY,66,22
    help="指定单个头部卡电容相位校正，rad*0.00001"
    bkcolor=LIGHTYELLOW
  endc
  draw at MX1+2*MDX-21,MY1+19+6*MDY text="微短探测校正"
  hcrtadj=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+6*MDY,66,22
    help="指定单个MSD电容修正，以1/10000为单位"
    bkcolor=LIGHTYELLOW
  endc
  if $GLOBAL.a5==0 then
    draw at MX1+2*MDX,MY1+19+7*MDY text="Pz因素"
  else
    draw at MX1+2*MDX,MY1+19+7*MDY text="软着陆"
  endif
  hpfactor=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+7*MDY,66,22
    help=($GLOBAL.a5==0?                                                       \
      "Specify the individual pressure sensor sensitivity, in 1/1000th":       \
      "Specify the individual soft landing correction, -1000..1000 units")
    bkcolor=LIGHTYELLOW
  endc
  // Enable soft landing corrections only when pressure sensors are enabled.
  if (($uint4(lx+12) & HCZ_VALID)==0 && (l.config & LC_ZSENSORS)==0) ||        \
    (($uint4(lx+12) & HCZ_VALID)!=0 &&                                         \
    ($uint4(lx+12) & HCZ_CONTMASK)!=HCZ_CONTSPL &&                             \
    ($uint4(lx+12) & HCZ_CONTMASK)!=HCZ_CONTHSPL &&                            \
    ($uint4(lx+12) & HCZ_CONTMASK)!=HCZ_CONTSKP) then
    disable hpfactor
  endif
  draw at MX1+2*MDX,MY1+19+8*MDY text="功率校正"
  hpcorr=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+8*MDY,66,22
    help="指定单个压力传感器校正系数，0.2..5.1"
    bkcolor=LIGHTYELLOW
  endc
  draw at MX1+2*MDX,MY1+19+9*MDY text="背钻补偿"
  hbdccorr=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+9*MDY,66,22
    help="指定背钻针的电容补偿，femtofarad"
    bkcolor=LIGHTYELLOW
  endc
  draw at MX1+2*MDX,MY1+19+10*MDY text="背钻因素"
  hbdcfact=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+10*MDY,66,22
    help="指定背钻针的电容系数0.5..2.0"
    bkcolor=LIGHTYELLOW
  endc
  draw at MX1+2*MDX,MY1+19+11*MDY text="背钻校正"
  hbdczofs=control EDIT
    window=hparm
    position=MX1+2*MDX+75,MY1+11*MDY,66,22
    help="指定背钻针的Z偏移,微米"
    bkcolor=LIGHTYELLOW
  endc
  // Enable pressure sensor corrections only for micro parallelogramms.
  if ($uint4(lx+12) & HCZ_VALID)==0 ||                                         \
    ($uint4(lx+12) & HCZ_CONTMASK)!=HCZ_CONTSKP then
    disable hpcorr
  endif
  // HV options.
  draw at MX1,MY0+19+11*MDY text="高压卡"
  hvcard=control COMBOLIST
    window=hparm
    position=MX1+75,MY0+11*MDY-2,66,100
    help="在测量卡上指定高压电子设备的类型"
    bkcolor=PINK
  endc
  add hvcard text="500 V"
  add hvcard text="1 kV"
  add hvcard text="Auto"
  draw at MX1,MY0+19+12*MDY text="最大电压"
  hvmax=control EDIT
    window=hparm
    position=MX1+75,MY0+12*MDY,66,22
    help="用于HV测量的最大电压，伏特"
    bkcolor=PINK
  endc
  draw at MX1-23,MY0+19+13*MDY text="微短探测电压"
  hcrtumax=control EDIT
    window=hparm
    position=MX1+75,MY0+13*MDY,66,22
    help="MSD测量的最大电压，伏特"
    bkcolor=PINK
  endc
  // LATEST options.
  draw at MX1,MY0+19+14*MDY text="LA因素"
  hlaadj=control EDIT
    window=hparm
    position=MX1+75,MY0+14*MDY,66,22
    help="指定最新测量的校正系数(0.5 .. 2.0)"
    bkcolor=WHITECYAN
  endc
  draw at MX1,MY0+19+15*MDY text="LA功率"
  hlapower=control EDIT
    window=hparm
    position=MX1+75,MY0+15*MDY,66,22
    help="指定允许的最大开尔文接触功率，毫瓦(200..3000)"
    bkcolor=WHITECYAN
  endc
  hdefaults=control WINBUTTON
    window=hparm
    position=MX1+MDX+176,MY0+381,135,22
    name="设置为默认值"
    help="双击可将所有测量参数设置为默认值"
    mode=M_DBLCLICK
    bkcolor=WHITEGREEN
    font=INFOFONT
  endc
  draw show
end

function int Setmeasdefaults()
  int i
  $int4(lx+708)=300000000
  do i=0,8,1
    l.current[i]=defcurr[i]; enddo
  do i=0,5,1
    l.voltage[i]=defvolt[i]; enddo
  l.r100k=100000; l.frequency=1953; l.rzero=0;
  do i=0,31,1
    lx.radj[i]=0
  enddo
  $float4(lx+404)=0.0                  // Zero shortcut inductivity
  $int4(lx+408)=0                      // Zero RL resistance shift
  $float4(lx+412)=0.0                  // Zero inductivity phase corrections
  $float4(lx+416)=0.0
  $uint2(lx+508)=0                     // Zero maximal high voltage
  $uint2(lx+442)=0                     // Zero maximal CRT voltage
  $uint2(lx+440)=10000                 // No LATEST correction
  $uint2(lx0+766)=0                    // Default LATEST contact power
end

function int Showmeas()
  char s[64]
  int i,umax; float r
  change hi300ma text=format("%.2f",$int4(lx+708)*1.0e-6)
  do i=0,8,1
    r=l.current[i]/currfactor[i]
    if (Abs(r)>=100.0) then sprintf(s,"%.2f",r);
    else if (Abs(r)>=10.0) then sprintf(s,"%.3f",r);
    else sprintf(s,"%.4f",r); endif;
    change hcurrent[i] text=s
  enddo
  do i=0,5,1
    r=l.voltage[i]/voltfactor[i]
    if (Abs(r)>=100.0) then sprintf(s,"%.2f",r);
    else if (Abs(r)>=10.0) then sprintf(s,"%.3f",r);
    else sprintf(s,"%.4f",r); endif;
    change hvoltage[i] text=s
  enddo
  change hr100k text=format("%.2f",l.r100k/1000.0)
  change hrzero text=format("%.6g",l.rzero/1.0e6)
  change hkelvzero text=format("%.6g",$int4(lx+670)/1.0e6)
  if $uint2(lx+716)==0 then
    change hcshlimit text="关"
  else
    change hcshlimit text=format("%i",$uint2(lx+716))
  endif
  if $uint1(lx+448)>55 && $uint1(lx+448)<65 then
    change hmainsf select=1
  else
    change hmainsf select=0
  endif
  change hlzero text=format("%.3f",$float4(lx+404)/1.0e3)
  change hlrshift text=format("%.3f",$int4(lx+408)/1.0e6)
  change hlphase0 text=format("%.4f",$float4(lx+412))
  change hlphase1 text=format("%.4f",$float4(lx+416))
  if lx.lfrequency==0 then
    change hlfreq text="默认"
  else
    change hlfreq text=format("%i",lx.lfrequency)
  endif
  change hlaadj text=format("%.3f",$uint2(lx+440)/10000.0)
  if $uint2(lx0+766)==0 then
    change hlapower text="默认"
  else
    change hlapower text=format("%i",$uint2(lx0+766))
  endif
  change hfrequency text=format("%i",l.frequency)
  change hclowest text=format("%i",l.clowest)
  change hradj text=format("%.3f",lx.radj[rail*2+finger]/1.0e6)
  change hrneedle text=format("%.3f",$int2(lx0+702+rail*4+finger*2)/1.0e3)
  change hsinadj text=format("%i",lx.sinadj[rail*2+finger])
  change hcosadj text=format("%i",lx.cosadj[rail*2+finger])
  change hcphadj text=format("%i",$int2(lx+516+(rail*2+finger)*2))
  i=lx.pfactor[rail*2+finger]
  if $GLOBAL.a5!=0 then                // Interprete as signed
    if (i & 0x8000) i=i|0xFFFF0000
  endif
  change hpfactor text=format("%i",i)
  change hcrtadj text=format("%i",$int2(lx+340+rail*4+finger*2))
  change hpcorr text=format("%.2f",$uint1(lx+588+rail*2+finger)/50.0)
  change hbdccorr text=format("%.2f",$uint2(lx1+4+rail*4+finger*2)/100.0)
  change hbdcfact text=format("%.4f",$uint2(lx1+68+rail*4+finger*2)/10000.0)
  change hbdczofs text=format("%i",$int2(lx1+132+rail*4+finger*2))
  if ($int4(lx+496) & HCM_HVTYPE)==HCM_HV500 then
    change hvcard select=0
  else if ($int4(lx+496) & HCM_HVTYPE)==HCM_HV1000 then
    change hvcard select=1
  else if ($int4(lx+496) & HCM_HVTYPE)==HCM_HVAUTO then
    change hvcard select=2
  else
    change hvcard select=0
  endif
  umax=$uint2(lx+508)
  if umax==0 then
    change hvmax text="最大"
  else
    change hvmax text=format("%i",umax)
  endif
  umax=$uint2(lx+442)
  if umax==0 then
    change hcrtumax text="默认"
  else
    change hcrtumax text=format("%i",umax)
  endif
end

function int Getmeas()
  char s[64]
  int i,j; float r
  Text(hi300ma,s); r=300000000/1.0e6;
  sscanf(s,"%f",&r); $int4(lx+708)=Floor(r*1.0e6+0.5)
  do i=0,8,1
    Text(hcurrent[i],s); r=defcurr[i]/currfactor[i];
    sscanf(s,"%f",&r); l.current[i]=Floor(r*currfactor[i]+0.5)
  enddo
  do i=0,5,1
    Text(hvoltage[i],s); r=defvolt[i]/voltfactor[i];
    sscanf(s,"%f",&r); l.voltage[i]=Floor(r*voltfactor[i]+0.5)
  enddo
  Text(hr100k,s); r=100.0; sscanf(s,"%f",&r); l.r100k=Floor(r*1000.0+0.5)
  Text(hrzero,s); r=0.0; sscanf(s,"%f",&r); l.rzero=Floor(r*1.0e6+0.5)
  Text(hkelvzero,s); r=0.0; sscanf(s,"%f",&r); $int4(lx+670)=Floor(r*1.0e6+0.5)
  Text(hcshlimit,s); i=0; sscanf(s,"%i",&i); $uint2(lx+716)=Min(i,65535)
  if Status(hmainsf)==1 then
    $uint1(lx+448)=60
  else
    $uint1(lx+448)=50
  endif
  Text(hlzero,s); r=0.0; sscanf(s,"%f",&r); $float4(lx+404)=r*1.0e3
  Text(hlrshift,s); r=0.0; sscanf(s,"%f",&r); $int4(lx+408)=Floor(r*1.0e6+0.5)
  Text(hlphase0,s); r=0.0; sscanf(s,"%f",&r); $float4(lx+412)=r
  Text(hlphase1,s); r=0.0; sscanf(s,"%f",&r); $float4(lx+416)=r
  Text(hlfreq,s); r=0.0; sscanf(s,"%f",&r); lx.lfrequency=r
  Text(hlaadj,s); r=0.0; sscanf(s,"%f",&r);
  $uint2(lx+440)=Floor(Max(0.0,Min(r,3.0))*10000.0+0.5)
  Text(hlapower,s); r=0.0; sscanf(s,"%f",&r);
  $uint2(lx0+766)=Floor(Max(0.0,Min(r,3000.0))+0.5)
  if $uint2(lx0+766)>0 && $uint2(lx0+766)<200 $uint2(lx0+766)=200
  Text(hfrequency,s); i=1953; sscanf(s,"%i",&i); l.frequency=i
  Text(hclowest,s); i=160; sscanf(s,"%i",&i); l.clowest=i
  j=rail*2+finger;
  Text(hradj,s); r=0.0; sscanf(s,"%f",&r); lx.radj[j]=Floor(r*1.0e6+0.5)
  Text(hrneedle,s); r=0.0; sscanf(s,"%f",&r)
  $int2(lx0+702+j*2)=Floor(r*1.0e3+0.5)
  Text(hsinadj,s); i=0; sscanf(s,"%i",&i); lx.sinadj[j]=Max(0,Min(511,i))
  Text(hcosadj,s); i=0; sscanf(s,"%i",&i); lx.cosadj[j]=Max(0,Min(511,i))
  Text(hcphadj,s); i=0; sscanf(s,"%i",&i);
  $int2(lx+516+j*2)=Max(-10000,Min(10000,i))
  Text(hpfactor,s); i=0; sscanf(s,"%i",&i);
  if $GLOBAL.a5==0 then
    lx.pfactor[j]=Max(0,Min(4095,i))
  else
    lx.pfactor[j]=Max(-1000,Min(1000,i))
  endif
  Text(hpcorr,s); r=0.0; sscanf(s,"%f",&r); i=Floor(r*50.0+0.5)
  if i<10 then
    i=0
  else if i>255 then
    i=255
  endif
  $uint1(lx+588+rail*2+finger)=i
  Text(hbdccorr,s); r=0.0; sscanf(s,"%f",&r)
  r=Max(-100.0,Min(r,100.0))
  $uint2(lx1+4+rail*4+finger*2)=Floor(r*100.0+0.5)
  Text(hbdcfact,s); r=0.0; sscanf(s,"%f",&r)
  if r<0.1 then
    r=0.0
  else
    r=Max(0.5,Min(r,2.0))
  endif
  $uint2(lx1+68+rail*4+finger*2)=Floor(r*10000.0+0.5)
  Text(hbdczofs,s); i=0; sscanf(s,"%i",&i)
  $int2(lx1+132+rail*4+finger*2)=Max(-1000,Min(1000,i))
  Text(hcrtadj,s); i=0; sscanf(s,"%i",&i)
  $int2(lx+340+j*2)=Max(-4095,Min(4095,i))
  if Status(hvcard)==1 then
    $int4(lx+496)=($int4(lx+496) & (~HCM_HVTYPE))|HCM_HV1000
  else if Status(hvcard)==2 then
    $int4(lx+496)=($int4(lx+496) & (~HCM_HVTYPE))|HCM_HVAUTO
  else
    $int4(lx+496)=($int4(lx+496) & (~HCM_HVTYPE))|HCM_HV500
  endif
  Text(hvmax,s); i=0; sscanf(s,"%i",&i);
  if ($int4($EXTLAY+496) & HCM_HVTYPE)==HCM_HV500 then
    $uint2(lx+508)=Max(0,Min(i,500))
  else
    $uint2(lx+508)=Max(0,Min(i,1000))
  endif
  Text(hcrtumax,s); i=0; sscanf(s,"%i",&i);
  if ($int4($EXTLAY+496) & HCM_HVTYPE)==HCM_HV500 then
    $uint2(lx+442)=Max(0,Min(i,500))
  else
    $uint2(lx+442)=Max(0,Min(i,1000))
  endif
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// DSP1 PANEL //////////////////////////////////

#define AX0            20
#define AX1            380
#define AX2            300
#define AY0            5
#define AY1            59
#define AY2            214

// Service function, marks repeating aux outputs in red.
function int Checkmuxoutputs()
  int i,j
  for i=0,i<6,i++ do
    for j=0,j<6,j++ do
      if i==j continue
      if (($int4(lx+674)>>(i*3)) & 0x7)==MUXEXT_NONE continue
      if (($int4(lx+674)>>(i*3)) & 0x7)==MUXEXT_SHORT continue
      if (($int4(lx+674)>>(i*3)) & 0x7)==(($int4(lx+674)>>(j*3)) & 0x7) break
    enddo
    if j<6 then
      change hmuxaux[i] color=LIGHTRED
      change hmuxaux[i] bkcolor=PINK
    else
      change hmuxaux[i] color=BLACK
      change hmuxaux[i] bkcolor=WHITE
    endif
  enddo
end

// Service function, sets names of connectors for substitution and selects
// correct entries.
function int Setsubstnames()
  int i,j,nmod,subst
  for i=0,i<4,i++ do
    clear hsubstpos[i]
    subst=$int2(lx+488+2*i)
    if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
      // Modular multiplexer (EL506), up to 3 modules are supported.
      nmod=Min(3,($int4(lx+674)>>24) & 0x0000000F)
      for j=0,j<8*nmod,j++ do
        add hsubstpos[i] text=format("Mux%i:JP%i (%i%s)",                      \
        j/8,j & 7,(j>>1) & 3,j & 1?"R":"L")
      enddo
    else
      // Multiplexer card with 16 outputs (EL406).
      for j=0,j<16,j++ do
        add hsubstpos[i] text=format("JP%i (J%i-J%i)",j,j*2+1,j*2+2)
      enddo
    endif
    if subst!=0 change hsubstpos[i] select=(subst>>8) & 0x001F
    if (subst & 0x8000)==0 disable hsubstpos[i]
  enddo
end

function int Createdspmeas1()
  int i,j,extant,subst
  char substname[4][12] = {                                                    \
    "first", "second", "third", "fourth" }
  clear hparm
  draw window=hparm font=INFOFONT color=BLACK bkcolor=LIGHTGREEN
  // Type of multiplexer and external connectors.
  draw at AX0,AY0+20 text="多路卡和输出:"
  hmuxtype=control COMBOLIST
    window=hparm
    position=AX0+20,AY0+25,144,200
    help="模拟多路卡类型"
  endc
  add hmuxtype text="DL406"
  add hmuxtype text="DL506（M1）"
  add hmuxtype text="DL506（M2）"
  add hmuxtype text="DL506（M3）"
  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
    change hmuxtype select=($int4(lx+674)>>24) & 0x0000000F
  else
    change hmuxtype select=0
  endif
  for i=0,i<6,i++ do
    draw at AX0+182+65*i,AY0+20 text=format("M%i:%i",i/2+1,(i & 1)+1)
    hmuxaux[i]=control COMBOLIST
      window=hparm
      position=AX0+180+65*i,AY0+25,61,200
      help=format("卡%i上的外部输出%i的功能",(i & 1)+1,i/2)
    endc
    add hmuxaux[i] text="无"
    add hmuxaux[i] text="温度"
    add hmuxaux[i] text="天线 0"
    add hmuxaux[i] text="天线 1"
    add hmuxaux[i] text="偏差"
    add hmuxaux[i] text="短接"
    add hmuxaux[i] text="联合"
    change hmuxaux[i] select=($int4(lx+674)>>(i*3)) & 0x00000007
    if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE406 ||                          \
      i>=(($int4(lx+674)>>24) & 0xF)*2 then
      disable hmuxaux[i]
    endif
  enddo
  Checkmuxoutputs()
  // Head substitutions are not yet in OT, access directly.
  draw at AX0,AY1+20 text="多路卡替代通道:"
  for i=0,i<4,i++ do
    subst=$int2(lx+488+2*i)
    hsubston[i]=control CHECKBOX
      window=hparm
      position=AX0+5,AY1+29+i*27,70,20
      name="测试头"
      help=format("选中可以启用%s替换",substname[i])
      font=INFOFONT
      mode=(subst & 0x8000?M_CHECKED:0)
    endc
    hsubsthead[i]=control COMBOLIST
      window=hparm
      position=AX0+76,AY1+27+i*27,50,200
      help="选择测试头代替"
      mode=M_VSCROLL
      font=FIXEDSYS
    endc
    for j=0,j<24,j++ do
      add hsubsthead[i] text=format("%i%c",j/2,j & 1?'R':'L')
    enddo
    if subst!=0 change hsubsthead[i] select=subst & 0x001F
    if (subst & 0x8000)==0 disable hsubsthead[i]
    draw at AX0+130,AY1+46+i*27 text="接头."
    hsubstpos[i]=control COMBOLIST
      window=hparm
      position=AX0+179,AY1+27+i*27,140,200
      help="选择模拟多路卡上的连接器"
      mode=M_VSCROLL
      font=FIXEDSYS
    endc
  enddo
  Setsubstnames()
  // Measurement options, including HV limit.
  draw at AX0,AY2 text="测试选项:"
  // First half.
  hparcont=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+6,260,19
    name="检验平行接触的影响"
    help="验证平行接触不会干扰快速电容和电场"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_PARCONT)!=0?M_CHECKED:0)
  endc
  h1mahv=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+25,260,19
    name="高压测试时，加1mA电流"
    help="如果测量卡上的300 V DC-DC输出低至10 mA，则使用"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_HV1MA)!=0?M_CHECKED:0)
  endc
  hnoaccel=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+44,260,19
    name="不需要加速继电器"
    help="关闭加速测量卡和多路卡上的红色继电器"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_NOACCEL)!=0?M_CHECKED:0)
  endc
  hstrict=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+63,260,19
    name="自检时严格限制20%"
    help="检查以确保测量卡比预期的要好"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_STRICT)!=0?M_CHECKED:0)
  endc
  hdisconn=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+82,260,19
    name="测量后断开链接"
    help="每次测量完成后，从模拟总线上断开测试头"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_DISCONN)!=0?M_CHECKED:0)
  endc
  hnocont=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+101,260,19
    name="无需验证接触性(不含精密电阻)"
    help="禁用大多数测量中的触点检查"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_NOCTCHK)!=0?M_CHECKED:0)
  endc
  hcontair=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+120,260,19
    name="校准无触点容量"
    help="分别校准PCB上每个焊盘的无触点电容量"
    font=INFOFONT
    mode=((lx.extcfg & EXT_CONTAIR)!=0?M_CHECKED:0)
  endc
  if (l.probetype & 0x1)!=0 disable hcontair
  hcair=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+139,260,19
    name="校准电场/快速电容的容量"
    help="校准PCB上每个焊盘的电场和快速电容量"
    font=INFOFONT
    mode=((lx.extcfg & EXT_CAIR)!=0?M_CHECKED:0)
  endc
  hcrtair=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+158,260,19
    name="校正微短探测功能"
    help="校准PCB上每个焊盘的微短路检测"
    font=INFOFONT
    mode=((lx.extcfg & EXT_CRTAIR)!=0?M_CHECKED:0)
  endc
  hcshuttle=control CHECKBOX
    window=hparm
    position=AX0+20,AY2+177,260,19
    name="校正与架板框之间的电容"
    help="校准外部天线的电场和快速电容量"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_CTOEXT)!=0?M_CHECKED:0)
  endc
  // Second half.
  hcfilter=control CHECKBOX
    window=hparm
    position=AX2+20,AY2+6,260,19
    name="过滤容量测量值超过300pF"
    help="在噪音环境中使用，减慢受影响的测量"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_FILTERC)!=0?M_CHECKED:0)
  endc
  hlapar=control CHECKBOX
    window=hparm
    position=AX2+20,AY2+25,260,19
    name="允许平行潜在开路测试接触"
    help="允许空闲的测试头在LA测量期间接触PCB"
    font=INFOFONT
    mode=((lx.extcfg & EXT_LAPAR)!=0?M_CHECKED:0)
  endc
  hexactrpar=control CHECKBOX
    window=hparm
    position=AX2+20,AY2+44,260,19
    name="对双测量卡优化精密电阻"
    help="假设所有负责人都属于同一个网，请加速EXACTR"
    font=INFOFONT
    mode=((lx.extcfg & EXT_EPAR)!=0?M_CHECKED:0)
  endc
  hexrlong=control CHECKBOX
    window=hparm
    position=AX2+20,AY2+63,260,19
    name="用300mA电源测试精密电阻"
    help="如果存在可选的300 mA电源，请不要优化EXACTR速度"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_EXRLONG)!=0?M_CHECKED:0)
  endc
  hexrnoisy=control CHECKBOX
    window=hparm
    position=AX2+20,AY2+82,260,19
    name="接受噪声测量"
    help="当前影响EXACTR和电感测量"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_EXRNOISY)!=0?M_CHECKED:0)
  endc
  draw at AX2+20,AY2+125 text="开尔文一致性:"
  hkelvcons=control COMBOLIST
    window=hparm
    position=AX2+165,AY2+106,128,200
    help="设置低欧姆开尔文和4线测量的精度"
  endc
  add hkelvcons text="关"
  add hkelvcons text="基础"
  add hkelvcons text="中等"
  add hkelvcons text="高等"
  if ($int4(lx+496) & HCM_CONSMASK)==HCM_CSLOW then
    change hkelvcons select=1
  else if ($int4(lx+496) & HCM_CONSMASK)==HCM_CSMED then
    change hkelvcons select=2
  else if ($int4(lx+496) & HCM_CONSMASK)==HCM_CSHIGH then
    change hkelvcons select=3
  else
    change hkelvcons select=0
  endif
  draw at AX2+20,AY2+153 text="平行高压接触:"
  hhvpar=control COMBOLIST
    window=hparm
    position=AX2+165,AY2+134,128,200
    help="在HV期间允许空闲测试头接触PCB，可能会使旧的测量卡崩溃！"
  endc
  add hhvpar text="飞针测试软件"
  add hhvpar text="总是"
  add hhvpar text="从不"
  add hhvpar text="不同排版"
  if (lx.extcfg & EXT_HVPARMASK)==EXT_HVGROUP then
    change hhvpar select=0
  else if (lx.extcfg & EXT_HVPARMASK)==EXT_HVPARAL then
    change hhvpar select=1
  else if (lx.extcfg & EXT_HVPARMASK)==EXT_HVNOPAR then
    change hhvpar select=2
  else
    change hhvpar select=3
  endif
  draw at AX2+20,AY2+181 text="平行微短探测接触:"
  hcrtpar=control COMBOLIST
    window=hparm
    position=AX2+165,AY2+162,128,200
    help="在CRT(MSD)测量期间允许空闲测试头与PCB接触"
  endc
  add hcrtpar text="飞针测试软件"
  add hcrtpar text="总是"
  add hcrtpar text="从不"
  add hcrtpar text="不同排版"
  if (lx.extcfg & EXT_CRTPMASK)==EXT_CRTGRP then
    change hcrtpar select=0
  else if (lx.extcfg & EXT_CRTPMASK)==EXT_CRTPAR then
    change hcrtpar select=1
  else if (lx.extcfg & EXT_CRTPMASK)==EXT_CRTNOP then
    change hcrtpar select=2
  else
    change hcrtpar select=3
  endif
  // External antenna descriptors are not yet in OT, access directly.
  extant=$int4(lx+336)
  draw at AX1,AY1+20 text="外部天线:"
  hextant1=control CHECKBOX
    window=hparm
    position=AX1+25,AY1+25,100,18
    name="天线0"
    help="检查以启用第一个外部天线"
    font=INFOFONT
    mode=(extant & 1?M_CHECKED:0)
  endc
  hautoeant=control CHECKBOX
    window=hparm
    position=AX1+45,AY1+43,110,18
    name="屏蔽作用"
    help="将外部天线0自动添加到所有电容测量中"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_AUTOEANT)!=0?M_CHECKED:0)
  endc
  if (extant & 1)==0 then
    disable hautoeant
  endif
  hextant2=control CHECKBOX
    window=hparm
    position=AX1+25,AY1+61,100,18
    name="天线1"
    help="检查以启用第二个外部天线(然后，没有第二个设备)"
    font=INFOFONT
    mode=(extant & 2?M_CHECKED:0)
  endc
  hisoeant=control CHECKBOX
    window=hparm
    position=AX1+25,AY1+79,130,18
    name="绝缘架板框"
    help="外部天线与PCB没有欧姆接触"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_ISOEANT)!=0?M_CHECKED:0)
  endc
  // Signal filtering.
  draw at AX1,AY1+118 text="信号滤波:"
  hfilter=control COMBOLIST
    window=hparm
    position=AX1+25,AY1+122,150,200
    help="为硬件支持的信号过滤选择截止频率"
    mode=M_VSCROLL
  endc
  add hfilter text="无"
  add hfilter text="低(500 kHz)"
  add hfilter text="中(100 kHz)"
  add hfilter text="高(20/50 kHz)"
  if ($int4(lx+496) & HCM_FILTMASK)==HCM_F500K then
    change hfilter select=1
  else if ($int4(lx+496) & HCM_FILTMASK)==HCM_F100K then
    change hfilter select=2
  else if ($int4(lx+496) & HCM_FILTMASK)==HCM_F20K then
    change hfilter select=3
  else
    change hfilter select=0
  endif
  draw show
end


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// DSP2 & 3D PANEL ////////////////////////////////

#define QX0            10
#define QX1            120
#define QX2            350
#define QY0            10
#define QY1            18
#define QY2            158
#define QY3            272
#define QY4            35
#define QY5            203

function int Createdspmeas2()
  int i,j,y,dy,delta,yoffs
  char fname[4][8] = { "4 kHz", "8 kHz", "16 kHz", "预留" }
  clear hparm
  // Head selection controls.
  draw window=hparm font=INFOFONT color=BLACK bkcolor=LIGHTYELLOW
  draw at QX0,QY0 fillrect QX0+91,QY0+403
  if l.nfing<=10 then dy=24; delta=7
  else if l.nfing<=12 then dy=22; delta=5
  else if l.nfing==15 && l.cameras!=0 then dy=19; delta=1
  else dy=20; delta=2; endif
  yoffs=0
  if rail>=l.nfing then
    rail=0; railbtn=0
  endif
  showshuttle=0
  for j=0,j<l.nfing,j++
    if l.side[j]!=0 yoffs=delta
    do i=0,1,1
      hhead[j,i]=control WINBUTTON
        window=hparm
        position=QX0+5+i*41,QY0+4+dy*j+yoffs,40,dy-1
        name=format("%i%c",j,(i==0?'L':'R'))
        help=format("按下可选择%s测试头上轨道%i",i==0?"left":"right",j)
      endc
      if j==rail && i==finger then
        change hhead[j][i] color=LIGHTRED
        change hhead[j][i] bkcolor=WHITEBLUE
      else if ($int2(l+764) & (1<<j))!=0 then
        change hhead[j][i] color=DARKGRAY
        change hhead[j][i] bkcolor=GRAY
      endif
    enddo
  enddo
  // Capacity corrections.
  draw at QX1,QY1+17 text="电容校正:"
  for i=0,i<4,i++ do
    y=QY1+21+i*28
    draw at QX1+20,y+18 text=format("%s:",fname[i])
    hcphase[i]=control EDIT
      window=hparm
      position=QX1+66,y,50,22
      help=format("频率%s的电容量相位校正，度 ",       \
        fname[i])
      bkcolor=WHITE
    endc
    draw at QX1+117,y+18 text="? k="
    hcfact[i]=control EDIT
      window=hparm
      position=QX1+148,y,55,22
      help=format("频率%s的电容量校正系数",fname[i])
      bkcolor=WHITE
    endc
  enddo
  // Field phase correction controls.
  draw at QX1,QY2+17 text="扩展电场相位校正:"
  draw at QX1+20,QY2+45 text="最大电压:"
  draw at QX1+172,QY2+45 text="位"
  draw at QX1+20,QY2+45+TDY text="相位偏移:"
  draw at QX1+172,QY2+45+TDY text="位"
  draw at QX1+20,QY2+45+2*TDY text="弦校正:"
  draw at QX1+172,QY2+45+2*TDY text="单位"
  huin=control EDIT
    window=hparm
    position=QX1+98,QY2+26,68,22
    help="短路时电场测量的全电压，位，0 关闭"
    bkcolor=WHITE
  endc
  hfphcorr=control EDIT
    window=hparm
    position=QX1+98,QY2+26+TDY,68,22
    help="在短路下的电场相移，位"
    bkcolor=WHITE
  endc
  hfccorr=control EDIT
    window=hparm
    position=QX1+98,QY2+26+2*TDY,68,22
    help="电场余弦校正，任意单位"
    bkcolor=WHITE
  endc
  // 3-D calibration controls.
  draw at QX1+5,QY3+45 text="Y的X倾斜:"
  draw at QX1+158,QY3+45 text="um/mm"
  draw at QX1+5,QY3+TDY+45 text="Y的Y倾斜:"
  draw at QX1+158,QY3+TDY+45 text="um/mm"
  draw at QX1+5,QY3+2*TDY+45 text="Z的X倾斜:"
  draw at QX1+158,QY3+2*TDY+45 text="um/mm"
  draw at QX1+5,QY3+3*TDY+45 text="Z的Y倾斜:"
  draw at QX1+158,QY3+3*TDY+45 text="um/mm"
  draw show
  husetd=control CHECKBOX
    window=hparm
    position=QX1,QY3,130,19
    name="3-D校正:"
    help="如果要使用3-D校准结果，请激活"
    font=INFOFONT
    mode=((lx.extcfg & EXT_3DCOR)!=0?M_CHECKED:0)
  endc
  h3dxy=control EDIT
    window=hparm
    position=QX1+85,QY3+26,68,22
    help="Y轴的X倾斜，微米/毫米Z"
    bkcolor=WHITE
  endc
  h3dyy=control EDIT
    window=hparm
    position=QX1+85,QY3+TDY+26,68,22
    help="Y轴的Y倾斜，微米/毫米Z"
    bkcolor=WHITE
  endc
  h3dxz=control EDIT
    window=hparm
    position=QX1+85,QY3+2*TDY+26,68,22
    help="X轴的Z倾斜，微米/毫米Z"
    bkcolor=WHITE
  endc
  h3dyz=control EDIT
    window=hparm
    position=QX1+85,QY3+3*TDY+26,68,22
    help="Y轴的Z倾斜，微米/毫米Z"
    bkcolor=WHITE
  endc
  // External measurements.
  draw at QX2,QY4 text="外部设备0:"
  hextdev0=control COMBOLIST
    window=hparm
    position=QX2+25,QY4+8,200,200
    help="连接到测量卡的外部设备0的类型"
    mode=M_VSCROLL
  endc
  add hextdev0 text="无"             // EXTD_NONE
  add hextdev0 text="Hameg HM8118"     // EXTD_HM8118
  add hextdev0 text="Agilent E4980A"   // EXTD_AG4980
  change hextdev0 select=$uint2(lx+468)
  draw at QX2+25,QY4+57 text="重定向:"
  hcal0=control CHECKBOX
    window=hparm
    position=QX2+155,QY4-17,70,19
    name="校正"
    help="软复位后，检查外部设备0的零点校准"
    font=INFOFONT
    mode=(($int2(lx+464) & EXTS_CAL)!=0?M_CHECKED:0)
  endc
  hsubstr0=control CHECKBOX
    window=hparm
    position=QX2+95,QY4+40,45,19
    name="ExR"
    help="将精确的电阻测量值重定向到外部设备0"
    font=INFOFONT
    mode=(($int2(lx+464) & EXTS_EXACTR)!=0?M_CHECKED:0)
  endc
  hsubstc0=control CHECKBOX
    window=hparm
    position=QX2+145,QY4+40,45,19
    name="UniC"
    help="将通用电容测量重定向到外部设备0"
    font=INFOFONT
    mode=(($int2(lx+464) & EXTS_UNIC)!=0?M_CHECKED:0)
  endc
  hsubstl0=control CHECKBOX
    window=hparm
    position=QX2+195,QY4+40,40,19
    name="RL"
    help="将电感测量重定向到外部设备0"
    font=INFOFONT
    mode=(($int2(lx+464) & EXTS_RLMEAS)!=0?M_CHECKED:0)
  endc
  if $uint2(lx+468)==EXTD_NONE then
    disable hcal0
    disable hsubstr0
    disable hsubstc0
    disable hsubstl0
  endif
  draw at QX2,QY4+83 text="外部设备1:"
  hextdev1=control COMBOLIST
    window=hparm
    position=QX2+25,QY4+91,200,200
    help="连接到测量卡的外部设备1的类型"
    mode=M_VSCROLL
  endc
  add hextdev1 text="无"             // EXTD_NONE
  add hextdev1 text="Hameg HM8118"     // EXTD_HM8118
  add hextdev1 text="Agilent E4980A"   // EXTD_AG4980
  change hextdev1 select=$uint2(lx+470)
  draw at QX2+25,QY4+140 text="重定向:"
  hcal1=control CHECKBOX
    window=hparm
    position=QX2+155,QY4+66,70,19
    name="校正"
    help="软复位后，检查外部设备1的零点校准"
    font=INFOFONT
    mode=(($int2(lx+466) & EXTS_CAL)!=0?M_CHECKED:0)
  endc
  hsubstr1=control CHECKBOX
    window=hparm
    position=QX2+95,QY4+123,45,19
    name="ExR"
    help="将精确的电阻测量值重定向到外部设备1"
    font=INFOFONT
    mode=(($int2(lx+466) & EXTS_EXACTR)!=0?M_CHECKED:0)
  endc
  hsubstc1=control CHECKBOX
    window=hparm
    position=QX2+145,QY4+123,45,19
    name="UniC"
    help="将通用电容测量重定向到外部设备1"
    font=INFOFONT
    mode=(($int2(lx+466) & EXTS_UNIC)!=0?M_CHECKED:0)
  endc
  hsubstl1=control CHECKBOX
    window=hparm
    position=QX2+195,QY4+123,40,19
    name="RL"
    help="将电感测量重定向到外部设备1"
    font=INFOFONT
    mode=(($int2(lx+466) & EXTS_RLMEAS)!=0?M_CHECKED:0)
  endc
  if $uint2(lx+470)==EXTD_NONE then
    disable hcal1
    disable hsubstr1
    disable hsubstc1
    disable hsubstl1
  endif
  // Voltage outputs connected back to analog bus.
  draw at QX2,QY5 text="连接到电压输出端:"
  for i=0,i<4,i++ do
    y=QY5+27+i*28
    draw at QX2,y text=format("%s:",busname[i])
    hconntype[i]=control COMBOLIST
      window=hparm
      position=QX2+48,y-20,64,140
      help="选择连接类型"
    endc
    add hconntype[i] text="无"
    add hconntype[i] text="U+R"
    add hconntype[i] text="Ulim"
    add hconntype[i] text="Ilim"
    add hconntype[i] text="Rgnd"
    add hconntype[i] text="IUin"
    add hconntype[i] text="IUout"
    huout[i]=control COMBOLIST
      window=hparm
      position=QX2+115,y-20,42,140
      help="选择多路卡上的电压输出"
    endc
    add huout[i] text="U1"
    add huout[i] text="U2"
    add huout[i] text="U3"
    add huout[i] text="U4"
    hconnvalue[i]=control EDIT
      window=hparm
      position=QX2+160,y-20,83,24
      help="选定连接类型的值或系数"
      bkcolor=WHITE
    endc
  enddo
  y=QY5+27+4*28
  hconnpreset=control WINBUTTON
    window=hparm
    position=QX2+1,y-18,111,24
    text="预设:"
    help="双击可将连接预设为预定义状态"
    bkcolor=WHITEGREEN
    font=INFOFONT
    mode=M_DBLCLICK
  endc
  hcptype=control COMBOLIST
    window=hparm
    position=QX2+115,y-18,128,140
    help="选择预定义的连接类型"
  endc
  add hcptype text="无"
  add hcptype text="EL505"
  add hcptype text="EL508-1"
  change hcptype select=cptype
  draw show
end

function int Getmeas2()
  int i,j,head
  float f
  char s[256]
  head=rail*2+finger
  for j=0,j<4,j++ do
    Text(hcphase[j],s); f=0.0; sscanf(s,"%f",&f); i=Floor(f*100.0+0.5)
    $int2(lx+620+j*2)=Max(-9000,Min(i,9000))
    Text(hcfact[j],s); f=0.0; sscanf(s,"%f",&f); i=Floor(f*10000.0+0.5)
    if i!=0 i=Max(4000,Min(i,25000))
    $int2(lx+628+j*2)=i
  enddo
  Text(huin,s); i=0; sscanf(s,"%i",&i); $uint2(lx0+260)=i
  Text(hfphcorr,s); i=0; sscanf(s,"%i",&i); $int2(lx0+262+head*2)=i
  Text(hfccorr,s); i=0; sscanf(s,"%i",&i); $int2(lx0+326+head*2)=i
  Text(h3dxy,s); f=0.0; sscanf(s,"%f",&f); i=Floor(f*100.0+0.5)
  lx0.ytiltx[head]=Max(-5000,Min(i,5000))
  Text(h3dyy,s); f=0.0; sscanf(s,"%f",&f); i=Floor(f*100.0+0.5)
  lx0.ytilty[head]=Max(-5000,Min(i,5000))
  Text(h3dxz,s); f=0.0; sscanf(s,"%f",&f); i=Floor(f*100.0+0.5)
  lx0.ztiltx[head]=Max(-5000,Min(i,5000))
  Text(h3dyz,s); f=0.0; sscanf(s,"%f",&f); i=Floor(f*100.0+0.5)
  lx0.ztilty[head]=Max(-5000,Min(i,5000))
end

function int Showmeas2()
  int i,head,conn,enableconn
  head=rail*2+finger
  for i=0,i<4,i++ do
    change hcphase[i] name=format("%.2f",$int2(lx+620+i*2)/100.0)
    change hcfact[i] name=format("%.4f",$int2(lx+628+i*2)/10000.0)
  enddo
  change huin name=format("%i",$uint2(lx0+260))
  change hfphcorr name=format("%i",$int2(lx0+262+head*2))
  change hfccorr name=format("%i",$int2(lx0+326+head*2))
  change h3dxy name=format("%.2f",lx0.ytiltx[head]/100.0)
  change h3dyy name=format("%.2f",lx0.ytilty[head]/100.0)
  change h3dxz name=format("%.2f",lx0.ztiltx[head]/100.0)
  change h3dyz name=format("%.2f",lx0.ztilty[head]/100.0)
  if (lx.extcfg & EXT_3DCOR)==0 then
    disable h3dxy; change h3dxy bkcolor=LIGHTGRAY
    disable h3dyy; change h3dyy bkcolor=LIGHTGRAY
    disable h3dxz; change h3dxz bkcolor=LIGHTGRAY
    disable h3dyz; change h3dyz bkcolor=LIGHTGRAY
  else
    enable h3dxy; change h3dxy bkcolor=WHITE
    enable h3dyy; change h3dyy bkcolor=WHITE
    enable h3dxz; change h3dxz bkcolor=WHITE
    enable h3dyz; change h3dyz bkcolor=WHITE
  endif
  enableconn=0
  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
    for i=0,i<(($int4(lx+674)>>24) & 0xF)*2,i++ do
      if (($int4(lx+674)>>(i*3)) & 0x00000007)==6 enableconn=1
    enddo
  endif
  for i=0,i<4,i++ do
    conn=$int4(lx0+558+i*4)
    change hconntype[i] select=(conn>>24) & 0x1F
    if enableconn==0 disable hconntype[i]
    change huout[i] select=(conn>>29) & 0x7
    if enableconn==0 || (conn & 0x1F000000)==0 disable huout[i]
    change hconnvalue[i] text=format("%g",conn & 0x00FFFFFF)
    if enableconn==0 || (conn & 0x1F000000)==0 disable hconnvalue[i]
  enddo
  if enableconn==0 disable hconnpreset
  if enableconn==0 disable hcptype
end


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// DSP CONFIG PANEL ///////////////////////////////

#define XX0            20
#define XDX            207
#define XC1            30
#define XX1            (270-XC1)
#define XY0            9
#define XY1            282
#define XY3            9
#define XY4            79
#define XY5            185

function int Createdspconfig()
  int i,j,zheadtype,zheadbot
  selectneedle=0
  // Head type descriptors are not yet in OT, access directly.
  zheadtype=lx.zheadtype
  zheadbot=$int4(lx+460)
  clear hparm
  draw window=hparm font=TIMESFONT color=BLACK bkcolor=LIGHTGREEN
  husezparm=control CHECKBOX
    window=hparm
    position=XX0,XY0+3,100,20
    name="Z 参数:"
    help="强制指定Z测试头参数如下"
    font=TIMESFONT
    mode=(zheadtype & HCZ_VALID?M_CHECKED:0)
  endc
  hselectneedle=control WINBUTTON
    window=hparm
    position=XX0+110,XY0+3,97,18
    name="设置针头 ->"
    help="从图片中选择针头"
    font=TIMESFONT
    bkcolor=WHITEGREEN
  endc
  draw at XX0+15,XY0+45 text="驱动:"
  hactuator=control COMBOLIST
    window=hparm
    position=XX0+70,XY0+25,XDX-70,160
    help="Z执行机构的类型"
    mode=M_VSCROLL
  endc
  add hactuator text="支架1"
  add hactuator text="支架2"
  add hactuator text="步进电机"
  add hactuator text="线性电机"
  add hactuator text="无Z轴"
  if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA3 then
    change hactuator select=0
  else if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA2G then
    change hactuator select=1
  else if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPECER then
    change hactuator select=2
  else if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPELIN then
    change hactuator select=3
  else if (zheadtype & HCZ_TYPEMASK)==HCZ_TYPENO then
    change hactuator select=4
  endif
  if (zheadtype & HCZ_VALID)==0 disable hactuator
  draw at XX0+15,XY0+71 text="击测:"
  hstroke=control COMBOLIST
    window=hparm
    position=XX0+70,XY0+51,XDX-70,160
    help="Z行程类型(学习的Z仅适用于HS1，高压适用于H5)"
    mode=M_VSCROLL
  endc
  add hstroke text="标准"
  add hstroke text="软着陆"
  add hstroke text="硬针"
  add hstroke text="学习Z"
  add hstroke text="高压"
  if (zheadtype & HCZ_VALID)==0 disable hstroke
  draw at XX0+15,XY0+97 text="针头:"
  hneedle=control COMBOLIST
    window=hparm
    position=XX0+70,XY0+77,XDX-70,160
    help="接触针的类型('标准'表示重的白色支架)"
    mode=M_VSCROLL
  endc
  add hneedle text="默认"
  add hneedle text="标准"
  add hneedle text="软针"
  add hneedle text="特殊软针"
  add hneedle text="硬针"
  add hneedle text="软针转接头"
  add hneedle text="微针"
  add hneedle text="带感应器硬针"
  if (zheadtype & HCZ_VALID)==0 disable hneedle
  draw at XX0+15,XY0+123 text="感应器:"
  hsensor=control COMBOLIST
    window=hparm
    position=XX0+70,XY0+103,XDX-70,160
    help="Z压力传感器的类型(如果不存在，则设置为默认值)"
    mode=M_VSCROLL
  endc
  add hsensor text="默认"
  add hsensor text="倒置"
  add hsensor text="自动探测"
  if (zheadtype & HCZ_VALID)==0 disable hsensor
  hdiffbot=control CHECKBOX
    window=hparm
    position=XX0,XY0+131,100,20
    name="底部:"
    help="指定底部的不同针"
    font=TIMESFONT
    mode=(zheadbot & HCZ_VALID?M_CHECKED:0)
  endc
  if (zheadtype & HCZ_VALID)==0 disable hdiffbot
  hselectbottom=control WINBUTTON
    window=hparm
    position=XX0+110,XY0+131,97,18
    name="设置背面 ->"
    help="从图片集中选择底部针头"
    font=TIMESFONT
    bkcolor=WHITEGREEN
  endc
  if (zheadtype & zheadbot & HCZ_VALID)==0 disable hselectbottom
  draw at XX0+15,XY0+173 text="针头:"
  hneedlebot=control COMBOLIST
    window=hparm
    position=XX0+70,XY0+153,XDX-70,160
    help="底部针头的类型('标准'表示重的白色支架)"
    mode=M_VSCROLL
  endc
  add hneedlebot text="默认"
  add hneedlebot text="标准"
  add hneedlebot text="软针"
  add hneedlebot text="特殊软针"
  add hneedlebot text="硬针"
  add hneedlebot text="软针转接头"
  add hneedlebot text="微针"
  add hneedlebot text="带感应器硬针"
  if (zheadtype & zheadbot & HCZ_VALID)==0 disable hneedlebot
  draw at XX0+15,XY0+199 text="感应器:"
  hsensorbot=control COMBOLIST
    window=hparm
    position=XX0+70,XY0+179,XDX-70,160
    help="底部Z压力传感器的类型(如果不存在，则设置为默认)"
    mode=M_VSCROLL
  endc
  add hsensorbot text="默认"
  add hsensorbot text="倒置"
  add hsensorbot text="自动探测"
  if (zheadtype & zheadbot & HCZ_VALID)==0 disable hsensorbot
  hpreload=control CHECKBOX
    window=hparm
    position=XX0+15,XY0+210,XDX-40,19
    name="检查预压力"
    help="检查柱状图是否已充分预加载"
    font=TIMESFONT
    mode=(zheadtype & HCZ_TESTPRLD?M_CHECKED:0)
  endc
  if (zheadtype & HCZ_VALID)==0 disable hpreload
  hnozlim=control CHECKBOX
    window=hparm
    position=XX0+15,XY0+230,XDX-40,19
    name="允许深Z方向运动"
    help="如果测试没有大孔却弯曲的大板，则激活"
    font=TIMESFONT
    mode=((lx.extcfg & EXT_NOZLIMIT)!=0?M_CHECKED:0)
  endc
  // X parameters.
  draw at XX0,XY1 text="X参数:"
  draw at XX0+15,XY1+25 text="驱动:"
  hxdriver=control COMBOLIST
    window=hparm
    position=XX0+70,XY1+5,XDX-70,160
    help="X-Y马达驱动的类型"
    mode=M_VSCROLL
  endc
  add hxdriver text="标准"
  add hxdriver text="大功率"
  i=$int4(lx+4) & HCX_TYPEMINOR
  if i==HCX_HIPOW then
    change hxdriver select=1
  else
    change hxdriver select=0
  endif
  draw at XX0+15,XY1+51 text="编码器:"
  hxstep=control COMBOLIST
    window=hparm
    position=XX0+70,XY1+31,XDX-70,160
    help="X编码器的全步幅,微米"
    mode=M_VSCROLL
  endc
  add hxstep text="默认"
  add hxstep text="40um（开放）"
  add hxstep text="自动探测"
  i=$int4(lx+4) & HCX_ENCTYPE
  if i==HCX_ENCOPEN then
    change hxstep select=1
  else if i==HCX_ENCAUTO then
    change hxstep select=2
  else
    change hxstep select=0
  endif
  hlimitx=control CHECKBOX
    window=hparm
    position=XX0+15,XY1+60,150,20
    name="限制X方向动力"
    help="如果所有测试头同时运动，请检查是否限制加速度"
    font=TIMESFONT
    mode=(($int4(lx+4) & HCX_POWERLIM)!=0?M_CHECKED:0)
  endc
  draw at XX0,XY1+100 text="架板框Y参数:"
  draw at XX0+15,XY1+125 text="马达:"
  hyshmotor=control COMBOLIST
    window=hparm
    position=XX0+70,XY1+105,XDX-70,160
    help="Y架板框电机的类型"
    mode=M_VSCROLL
  endc
  add hyshmotor text="默认"
  add hyshmotor text="Double"
  i=$int4(lx+504) & HCS_YMASK
  if i==HCS_YMDBL then
    change hyshmotor select=1
  else
    change hyshmotor select=0
  endif
  if (l.config & LC_TYPEMASK)!=LC_S3 disable hyshmotor
  draw show
  // Right side control are placed into the separate child window. This allows
  // to hide them all at once, giving way to the needle selection dialog.
  hconfig=control CHILD
    window=hparm
    position=XX1,0,344+XC1,423
    help=" "
    color=WHITEGREEN
    bkcolor=WHITEGREEN
    size=4096
  endc
  draw window=hconfig color=BLACK font=TIMESFONT
  // Special options.
  draw at XC1,XY3+20 text="特殊选项:"
  hignorebcode=control CHECKBOX
    window=hconfig
    position=XC1+15,XY3+25,200,19
    name="不检查自动机的条形码"
    help="假设所有电路板都是同一类型"
    font=TIMESFONT
    mode=(($int4(lx+512) & HCA_NOBARCODE)!=0?M_CHECKED:0)
  endc
  hbargood=control CHECKBOX
    window=hconfig
    position=XC1+15,XY3+45,200,19
    name="将条形码移至良品区"
    help="将带有条形码的中间板移动到A5a/A7a良品堆中"
    mode=(($int4(lx+512) & HCA_BARGOOD)!=0?M_CHECKED:0)
    font=TIMESFONT
  endc
  // Illumination options.
  draw at XC1,XY4+20 text="照明选项:"
  draw at XC1+14,XY4+47 text="类型:"
  hillum=control COMBOLIST
    window=hconfig
    position=XC1+95,XY4+26,XDX-80,160
    help="照明(摄像头、外部LED、两个、外部亮起、闪烁…)"
    mode=M_VSCROLL
  endc
  add hillum text="默认相机"
  add hillum text="外部"
  add hillum text="混合"
  add hillum text="外开"
  add hillum text="闪光灯"
  add hillum text="混合闪"
  change hillum select=$int1(lx+449)
  draw at XC1+15,XY4+75 text="当前顶部"
  hbritop=control COMBOLIST
    window=hconfig
    position=XC1+95,XY4+55,54,260
    help="上部照明强度，百分比"
    mode=M_VSCROLL
  endc
  for i=20,i<150,i=i+10 do
    add hbritop text=format("%i",i)
  enddo
  j=$uint1(lx+680)
  if j==0 j=100
  j=Max(0,Min((j-15)/10,13))
  change hbritop select=j
  draw at XC1+152,XY4+75 text=", 偏离"
  hbriskew=control COMBOLIST
    window=hconfig
    position=XC1+200,XY4+55,54,260
    help="偏斜照明强度，百分比"
    mode=M_VSCROLL
  endc
  for i=20,i<150,i=i+10 do
    add hbriskew text=format("%i",i)
  enddo
  j=$uint1(lx+681)
  if j==0 j=100
  j=Max(0,Min((j-15)/10,13))
  change hbriskew select=j
  draw at XC1+257,XY4+78 text="%"
  // Serial and TCP/IP connections.
  draw at XC1,XY5 text="串行和TCP/IP 连接:"
  draw at XC1+15,XY5+25 text="标签:"
  hprinter=control COMBOLIST
    window=hconfig
    position=XC1+95,XY5+5,XDX-80,250
    help="串行端口连接到喷墨打印机或标签打印机"
    mode=M_VSCROLL
  endc
  add hprinter text="无"
  add hprinter text="/dev/atglabel"
  add hprinter text="USB适配器0"
  add hprinter text="USB适配器1"
  add hprinter text="USB适配器2"
  add hprinter text="USB适配器3"
  add hprinter text="串口2"
  add hprinter text="串口1"
  change hprinter select=($int4(lx+512)>>8) & 0xF
  if (l.config & LC_SMASK)!=LC_AUTOMATE &&                                     \
    (l.config & LC_SMASK)!=LC_LM &&                                            \
    (l.config & LC_SMASK)!=LC_EPCOS &&                                         \
    (l.config & LC_SMASK)!=LC_LMS2 disable hprinter
  hprintprot=control CHECKBOX
    window=hconfig
    position=XC1+XDX+24,XY5+8,76,20
    name="协议"
    help="检查与标签打印机连接的转储串行通信"
    font=INFOFONT
    mode=($int4(lx+682) & DBO_DUMPLABEL?M_CHECKED:0)
  endc
  draw at XC1+15,XY5+52 text="条码0:"
  hscaner0=control COMBOLIST
    window=hconfig
    position=XC1+95,XY5+32,XDX-80,250
    help="串行端口连接到条形码读取器0"
    mode=M_VSCROLL
  endc
  add hscaner0 text="无"
  add hscaner0 text="/dev/atgscan0"
  add hscaner0 text="USB适配器0"
  add hscaner0 text="USB适配器1"
  add hscaner0 text="USB适配器2"
  add hscaner0 text="USB适配器3"
  change hscaner0 select=$int4(lx+512) & 0xF
  if (l.config & LC_SMASK)!=LC_AUTOMATE &&                                     \
    (l.config & LC_SMASK)!=LC_LM &&                                            \
    (l.config & LC_SMASK)!=LC_EPCOS &&                                         \
    (l.config & LC_SMASK)!=LC_LMS2 disable hscaner0
  draw at XC1+15,XY5+79 text="条码1:"
  hscaner1=control COMBOLIST
    window=hconfig
    position=XC1+95,XY5+59,XDX-80,250
    help="串行端口连接到条形码读取器1"
    mode=M_VSCROLL
  endc
  add hscaner1 text="无"
  add hscaner1 text="/dev/atgscan1"
  add hscaner1 text="USB适配器0"
  add hscaner1 text="USB适配器1"
  add hscaner1 text="USB适配器2"
  add hscaner1 text="USB适配器3"
  change hscaner1 select=($int4(lx+512)>>4) & 0xF
  if (l.config & LC_SMASK)!=LC_AUTOMATE &&                                     \
    (l.config & LC_SMASK)!=LC_LM &&                                            \
    (l.config & LC_SMASK)!=LC_EPCOS &&                                         \
    (l.config & LC_SMASK)!=LC_LMS2 disable hscaner1
  draw at XC1+15,XY5+106 text="外设0:"
  hserdev0=control COMBOLIST
    window=hconfig
    position=XC1+95,XY5+86,XDX-80,250
    help="串行端口连接到外部测量设备0"
    mode=M_VSCROLL
  endc
  add hserdev0 text="无"
  add hserdev0 text="/dev/HCext"
  add hserdev0 text="USB适配器0"
  add hserdev0 text="USB适配器1"
  add hserdev0 text="USB适配器2"
  add hserdev0 text="USB适配器3"
  add hserdev0 text="串口2"
  add hserdev0 text="串口1"
  add hserdev0 text="TCP/IP 0"
  add hserdev0 text="TCP/IP 1"
  change hserdev0 select=($int4(lx+512)>>12) & 0xF
  draw at XC1+15,XY5+133 text="外设1:"
  hserdev1=control COMBOLIST
    window=hconfig
    position=XC1+95,XY5+113,XDX-80,250
    help="串行端口连接到外部测量设备1"
    mode=M_VSCROLL
  endc
  add hserdev1 text="无"
  add hserdev1 text="/dev/HCext"
  add hserdev1 text="USB适配器0"
  add hserdev1 text="USB适配器1"
  add hserdev1 text="USB适配器2"
  add hserdev1 text="USB适配器3"
  add hserdev1 text="串口2"
  add hserdev1 text="串口1"
  add hserdev1 text="TCP/IP 0"
  add hserdev1 text="TCP/IP 1"
  change hserdev1 select=($int4(lx+512)>>24) & 0xF
  draw at XC1+15,XY5+160 text="排列:"
  htarray=control COMBOLIST
    window=hconfig
    position=XC1+95,XY5+140,XDX-80,250
    help="连接到HS3温度传感器阵列的串行端口"
    mode=M_VSCROLL
  endc
  add htarray text="无"
  add htarray text="/dev/HCarray"
  add htarray text="USB适配器0"
  add htarray text="USB适配器1"
  add htarray text="USB适配器2"
  add htarray text="USB适配器3"
  add htarray text="串口2"
  add htarray text="串口1"
  change htarray select=($int4(lx+512)>>28) & 0xF
  draw at XC1+XDX+18,XY5+160 font=MAINFONT text=","
  htatype=control COMBOLIST
    window=hconfig
    position=XC1+XDX+25,XY5+140,95,200
    help="温度阵列类型"
    mode=M_VSCROLL
  endc
  add htatype text="标准"
  add htatype text="卡片1"
  add htatype text="类型2"
  add htatype text="类型3"
  change htatype select=($int4(lx+512)>>22) & 0x3
  if (($int4(lx+512)>>28) & 0xF)==0 disable htatype
  // Serial connections: TCP/IP addresses
  draw at XC1+15,XY5+192 font=INFOFONT text="TCP/IP0 ="
  htcpaddr0=control EDIT
    window=hconfig
    position=XC1+95,XY5+172,XDX-80,24
    help="设备TCP/IP 0的网络地址(IP4)"
    bkcolor=WHITE
  endc
  draw at XC1+XDX+18,XY5+192 font=MAINFONT text=":"
  htcpport0=control EDIT
    window=hconfig
    position=XC1+XDX+25,XY5+172,60,24
    help="设备TCP/IP 0的网络端口"
    bkcolor=WHITE
  endc
  draw at XC1+15,XY5+219 font=INFOFONT text="TCP/IP1 ="
  htcpaddr1=control EDIT
    window=hconfig
    position=XC1+95,XY5+199,XDX-80,24
    help="设备TCP/IP 1的网络地址(IP4)"
    bkcolor=WHITE
  endc
  draw at XC1+XDX+18,XY5+219 font=MAINFONT text=":"
  htcpport1=control EDIT
    window=hconfig
    position=XC1+XDX+25,XY5+199,60,24
    help="设备TCP/IP 1的网络端口"
    bkcolor=WHITE
  endc
  draw show
end

function int Showdspconfig()
  int zheadtype,zheadbot
  zheadtype=lx.zheadtype
  zheadbot=$int4(lx+460)
  if (zheadtype & HCZ_STRMASK)==HCZ_STRSOFT then
    change hstroke select=1
  else if (zheadtype & HCZ_STRMASK)==HCZ_STRHARD then
    change hstroke select=2
  else if (zheadtype & HCZ_STRMASK)==HCZ_LEARNZ then
    change hstroke select=3
  else if (zheadtype & HCZ_STRMASK)==HCZ_HIPRESS then
    change hstroke select=4
  else
    change hstroke select=0
  endif
  if (zheadtype & HCZ_CONTMASK)==HCZ_CONTDEF then
    change hneedle select=0
  else if (zheadtype & HCZ_CONTMASK)==HCZ_CONTSTD then
    change hneedle select=1
  else if (zheadtype & HCZ_XCONTMASK)==(HCZ_SPLK4|HCZ_CONTSPL) then
    change hneedle select=3
  else if (zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL then
    change hneedle select=2
  else if (zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL then
    change hneedle select=4
  else if (zheadtype & HCZ_CONTMASK)==HCZ_CONTEMU then
    change hneedle select=5
  else if (zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
    change hneedle select=6
  else if (zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
    change hneedle select=7
  endif
  if (zheadtype & HCZ_DMSMASK)==HCZ_DMSREV then
    change hsensor select=1
  else if (zheadtype & HCZ_DMSMASK)==HCZ_DMSAUTO then
    change hsensor select=2
  else
    change hsensor select=0
  endif
  if (zheadbot & HCZ_CONTMASK)==HCZ_CONTDEF then
    change hneedlebot select=0
  else if (zheadbot & HCZ_CONTMASK)==HCZ_CONTSTD then
    change hneedlebot select=1
  else if (zheadbot & HCZ_XCONTMASK)==(HCZ_SPLK4|HCZ_CONTSPL) then
    change hneedlebot select=3
  else if (zheadbot & HCZ_CONTMASK)==HCZ_CONTSPL then
    change hneedlebot select=2
  else if (zheadbot & HCZ_CONTMASK)==HCZ_CONTHSPL then
    change hneedlebot select=4
  else if (zheadbot & HCZ_CONTMASK)==HCZ_CONTEMU then
    change hneedlebot select=5
  else if (zheadbot & HCZ_CONTMASK)==HCZ_CONTSKP then
    change hneedlebot select=6
  else if (zheadbot & HCZ_CONTMASK)==HCZ_CONTHPS then
    change hneedlebot select=7
  endif
  if (zheadbot & HCZ_DMSMASK)==HCZ_DMSREV then
    change hsensorbot select=1
  else if (zheadbot & HCZ_DMSMASK)==HCZ_DMSAUTO then
    change hsensorbot select=2
  else
    change hsensorbot select=0
  endif
  change htcpaddr0 text=format("%i.%i.%i.%i",                                  \
    $uint1(lx+691),$uint1(lx+690),$uint1(lx+689),$uint1(lx+688))
  change htcpport0 text=format("%i",$uint2(lx+692))
  change htcpaddr1 text=format("%i.%i.%i.%i",                                  \
    $uint1(lx+697),$uint1(lx+696),$uint1(lx+695),$uint1(lx+694))
  change htcpport1 text=format("%i",$uint2(lx+698))
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// EXPERIMENTAL PANEL //////////////////////////////

#define SX0            20
#define SX1            330
#define SY0            50
#define SY1            375
#define SY2            300
#define SY4            352

function int Createspecial()
  int i,n
  clear hparm
  draw window=hparm color=LIGHTRED bkcolor=LIGHTGREEN
  draw font=MEDIUMFONT mode=M_CENTERED at 595/2,25
  draw text="请谨慎对以下参数进行设置！"
  // Movement options.
  draw color=BLACK mode=M_LEFT font=INFOFONT
  draw at SX0,SY0 text="运动选项:"
  draw at SX0+25,SY0+27 text="X 加速 ="
  hxaccel=control EDIT
    window=hparm
    position=SX0+83,SY0+8,60,22
    help="最大X头加速度，m / s / s，或0以使用默认值"
    bkcolor=WHITE
  endc
  draw at SX0+147,SY0+27 text=", 速度 ="
  hxvelo=control EDIT
    window=hparm
    position=SX0+206,SY0+8,60,22
    help="最大X测试头速度，m / s ，或0以使用默认值"
    bkcolor=WHITE
  endc
  draw at SX0+25,SY0+54 text="Y 加速 = "
  hyaccel=control EDIT
    window=hparm
    position=SX0+83,SY0+35,60,22
    help="最大Y测试头加速度，m/s/s ，或0以使用默认值"
    bkcolor=WHITE
  endc
  draw at SX0+147,SY0+54 text=", 速度 ="
  hyvelo=control EDIT
    window=hparm
    position=SX0+206,SY0+35,60,22
    help="最大Y测试头速度，m / s ，或0以使用默认值"
    bkcolor=WHITE
  endc
  draw at SX0+25,SY0+81 text="相机Xa ="
  hcamxa=control EDIT
    window=hparm
    position=SX0+83,SY0+62,60,22
    help="最大X摄像头加速度，m / s / s，或0以使用默认值"
    bkcolor=WHITE
  endc
  if l.cameras==0 disable hcamxa
  draw at SX0+147,SY0+81 text=", 速度 ="
  hcamxv=control EDIT
    window=hparm
    position=SX0+206,SY0+62,60,22
    help="最大X摄像头速度，m/s，或0以使用默认值"
    bkcolor=WHITE
  endc
  if l.cameras==0 disable hcamxv
  draw at SX0+25,SY0+108 text="相机Ya = "
  hcamya=control EDIT
    window=hparm
    position=SX0+83,SY0+89,60,22
    help="最大Y摄像头加速度，m/s/s ，或0以使用默认值"
    bkcolor=WHITE
  endc
  if l.cameras==0 disable hcamya
  draw at SX0+147,SY0+108 text=", 速度 ="
  hcamyv=control EDIT
    window=hparm
    position=SX0+206,SY0+89,60,22
    help="最大Y摄像头速度，m / s ，或0以使用默认值"
    bkcolor=WHITE
  endc
  if l.cameras==0 disable hcamyv
  draw at SX0+25,SY0+135 text="Z 加速 ="
  hzaccel=control EDIT
    window=hparm
    position=SX0+83,SY0+116,40,24
    help="Z加速度，默认加速度的百分比"
    bkcolor=WHITE
    mode=M_NOEDIT
  endc
  hzaccels=control VSCROLL
    window=hparm
    position=SX0+123,SY0+116,20,24
    help="更改Z加速度"
    mode=M_NOTAB
    limits=1,-1
  endc
  draw at SX0+149,SY0+135 text="% 默认值"
  draw at SX0+100,SY0+170 text="PCB外加速"
  hreducea=control EDIT
    window=hparm
    position=SX0+187,SY0+151,40,24
    help="PCB外部X-Y移动的速度，最大值的百分比"
    bkcolor=WHITE
    mode=M_NOEDIT
  endc
  hreduceas=control VSCROLL
    window=hparm
    position=SX0+227,SY0+151,20,24
    help="更改PCB外部X-Y移动的速度"
    mode=M_NOTAB
    limits=1,-1
  endc
  draw at SX0+253,SY0+170 text="%"
  hwidextop=control CHECKBOX
    window=hparm
    position=SX0+25,SY0+177,240,19
    name="使上面区域开阔"
    help="这是HS3测试机，上部有Z轴停放宽度限制"
    font=INFOFONT
    mode=((lx.extcfg & EXT_WIDEXTOP)!=0?M_CHECKED:0)
  endc
  hlimtodef=control CHECKBOX
    window=hparm
    position=SX0+25,SY0+202,240,19
    name="限制Y方向移动到缺陷板处"
    help="假设在DEFBOARD区域之外有探头或组件"
    font=INFOFONT
    mode=((lx.extcfg & EXT_YTODEFBRD)!=0?M_CHECKED:0)
  endc
  hignorexy=control CHECKBOX
    window=hparm
    position=SX0+25,SY0+222,240,19
    name="不禁止X-Y轴归零"
    help="如果X和Y都被禁用，假设它们丢失"
    font=INFOFONT
    mode=(($int4(lx+4) & HCX_NOHOME)!=0?M_CHECKED:0)
  endc
  draw at SX0,SY0+266 text="打开架板框Y马达:"
  hyoff=control COMBOLIST
    window=hparm
    position=SX0+25,SY0+273,185,150
    help="启用或禁用HS3上的Y架板框电机，可能会影响精度！"
  endc
  add hyoff text="全"
  add hyoff text="仅左面"
  add hyoff text="仅右面"
  if (lx.extcfg & EXT_S3YMASK)==EXT_S3YROFF then
    change hyoff select=1
  else if (lx.extcfg & EXT_S3YMASK)==EXT_S3YLOFF then
    change hyoff select=2
  else
    change hyoff select=0
  endif
  // Keep mean power options.
  draw at SX0,SY1 text="保持平均电机功率至少在:"
  draw at SX0+25,SY1+26 text="Px ="
  hwarmx=control COMBOLIST
    window=hparm
    position=SX0+59,SY1+6,50,250
    help="X电机功率，最大百分比"
    mode=M_VSCROLL
  endc
  for i=0,i<=50,i++ do
    add hwarmx text=format("%i",i)
  enddo
  change hwarmx select=$uint1(lx+678)
  draw at SX0+113,SY1+26 text="%, Py ="
  hwarmy=control COMBOLIST
    window=hparm
    position=SX0+173,SY1+6,50,250
    help="Y电机功率，最大百分比"
    mode=M_VSCROLL
  endc
  for i=0,i<=50,i++ do
    add hwarmy text=format("%i",i)
  enddo
  change hwarmy select=$uint1(lx+679)
  draw at SX0+227,SY1+26 text="%"
  // Miscellaneous options.
  draw at SX1,SY0 text="其它选项:"
  hnoopt=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+6,170,20
    name="关闭Z方向优化"
    help="在短距离移动时禁用较低的Z值"
    font=INFOFONT
    mode=(lx.zheadtype & HCZ_NOOPT?M_CHECKED:0)
  endc
  if (lx.zheadtype & HCZ_VALID)==0 disable hnoopt
  hparkz=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+26,170,19
    name="使Z马达停在零点位置"
    help="将上部测试头停放在原位(向下移动)"
    font=INFOFONT
    mode=(lx.zheadtype & HCZ_PARKZ?M_CHECKED:0)
  endc
  if (lx.zheadtype & HCZ_VALID)==0 disable hparkz
  hoptprint=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+46,200,19
    name="优化针痕"
    help="优化动作减少划伤，慢！"
    font=INFOFONT
    mode=(($int4(lx+8) & HCY_MINPRINT)!=0?M_CHECKED:0)
  endc
  if (l.config & LC_TYPEMASK)==LC_S1 then
    haggressive=control CHECKBOX
      window=hparm
      position=SX1+25,SY0+66,200,19
      name="优化X-Y-Z运动条件"
      help="对在HS1和HS2测试机上的测试平整的产品时优化移动"
      font=INFOFONT
      mode=(($int4(lx+4) & HCX_OPTWAIT)!=0?M_CHECKED:0)
    endc
  else
    haggressive=control CHECKBOX
      window=hparm
      position=SX1+25,SY0+66,200,19
      name="优化X-Y运动条件"
      help="考虑X-Y之后Z轴移动的持续时间"
      font=INFOFONT
      mode=(($int4(lx+4) & HCX_OPTWAIT)!=0?M_CHECKED:0)
    endc
  endif
  if ($int4(lx+8) & HCY_MINPRINT)!=0 disable haggressive
  hnolut=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+86,190,19
    name="屏蔽相机LUT功能"
    help="禁用相机查找表，用作附加放大"
    font=INFOFONT
    mode=((lx.extcfg & EXT_NOLUT)!=0?M_CHECKED:0)
  endc
  hcamoff=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+106,190,19
    name="相机电源发生错误，关闭"
    help="即当通信中断时，需要硬件支持"
    font=INFOFONT
    mode=((lx.extcfg & EXT_HCAMOFF)!=0?M_CHECKED:0)
  endc
  hhighir=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+126,190,19
    name="使用高电流复测"
    help="标准电阻测量最高100毫安"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_HIGHIR)!=0?M_CHECKED:0)
  endc
  hdetails=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+146,190,19
    name="报告详细测量结果"
    help="比如电阻测量的精确电压和电流"
    font=INFOFONT
    mode=(($int4(lx+496) & HCM_DETAILS)!=0?M_CHECKED:0)
  endc
  hresets=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+166,190,19
    name="协议总线重置"
    help="转储重置Firewire总线"
    font=INFOFONT
    mode=(($int4(lx+682) & DBO_DUMPRESET)!=0?M_CHECKED:0)
  endc
  hnomiss=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+186,190,19
    name="无PCB丢失"
    help="警告用户！不对损坏的测试头负责！"
    font=INFOFONT
    mode=((lx.extcfg & EXT_NOMISSPCB)!=0?M_CHECKED:0)
  endc
  hshdir=control CHECKBOX
    window=hparm
    position=SX1+25,SY0+206,190,19
    name="始终相同方向往返"
    help="使HS3架板框从同一方向接近Y坐标"
    font=INFOFONT
    mode=((lx.extcfg & EXT_FIXSHDIR)!=0?M_CHECKED:0)
  endc
  // Time between reinitializations.
  draw at SX1,SY2 text="初始化时间间隔"
  hreinit=control COMBOEDIT
    window=hparm
    position=SX1+173,SY2-19,80,200
    help="测量卡重新校准之间的最短时间，分钟"
    mode=M_VSCROLL
  endc
  add hreinit text="无"
  add hreinit text="1 min"
  add hreinit text="3 min"
  add hreinit text="5 min"
  add hreinit text="10 min"
  add hreinit text="15 min"
  add hreinit text="20 min"
  add hreinit text="30 min"
  if $uint1(lx+451)==0 then
    change hreinit text="无"
  else
    change hreinit text=format("%i min",$uint1(lx+451))
  endif
  // Additional delay for slow on-head relays.
  draw at SX1,SY2+35 text="延迟低速头部继电器"
  hdelayslow=control COMBOEDIT
    window=hparm
    position=SX1+173,SY2+16,55,300
    help="稍等头部慢速继电器重新切换，毫秒"
    mode=M_VSCROLL
  endc
  draw at SX1+233,SY2+35 text="ms"
  n=0
  for i=0,i<=250,i++ do
    if i>=20 && (i%5)!=0 continue
    if i>=50 && (i%10)!=0 continue
    add hdelayslow text=format("%.1f",i/10.0)
    if i<$uint1(lx+687) n++
  enddo
  change hdelayslow select=n
  // Firewire speed.
  hlimitfw=control CHECKBOX
    window=hparm
    position=SX1,SY4,150,19
    name="限制火线速度:"
    help="激活火线总线上的速度限制"
    font=INFOFONT
    mode=(($int4(lx+500) & HCF_VALID)!=0?M_CHECKED:0)
  endc
  draw at SX1+25,SY4+42 text="Iso ="
  hfwiso=control COMBOLIST
    window=hparm
    position=SX1+59,SY4+22,50,160
    help="同步(视频)火线传输速度，MBit/s"
  endc
  add hfwiso text="100"
  add hfwiso text="200"
  add hfwiso text="400"
  add hfwiso text="800"
  change hfwiso select=($int4(lx+500) & HCF_ISPEED)>>4
  draw at SX1+113,SY4+42 text=", Async ="
  hfwasync=control COMBOLIST
    window=hparm
    position=SX1+173,SY4+22,50,160
    help="异步(命令)火线传输的速度，MBit / s"
  endc
  add hfwasync text="100"
  add hfwasync text="200"
  add hfwasync text="400"
  change hfwasync select=$int4(lx+500) & HCF_ASPEED
  draw at SX1+227,SY4+42 text="MBit/s"
  if ($int4(lx+500) & HCF_VALID)==0 then
    disable hfwiso
    disable hfwasync
  endif
  draw show
end

function int Showspecialstuff()
  if ($float4(lx+472)==0.0) then
    change hxaccel text="默认"
  else
    change hxaccel text=format("%.2f",$float4(lx+472))
  endif
  if ($float4(lx+476)==0.0) then
    change hxvelo text="默认"
  else
    change hxvelo text=format("%.2f",$float4(lx+476))
  endif
  if ($float4(lx+480)==0.0) then
    change hyaccel text="默认"
  else
    change hyaccel text=format("%.2f",$float4(lx+480))
  endif
  if ($float4(lx+484)==0.0) then
    change hyvelo text="默认"
  else
    change hyvelo text=format("%.2f",$float4(lx+484))
  endif
  if ($float4(lx0+590)==0.0) then
    change hcamxa text="默认"
  else
    change hcamxa text=format("%.2f",$float4(lx0+590))
  endif
  if ($float4(lx0+594)==0.0) then
    change hcamxv text="默认"
  else
    change hcamxv text=format("%.2f",$float4(lx0+594))
  endif
  if ($float4(lx0+598)==0.0) then
    change hcamya text="默认"
  else
    change hcamya text=format("%.2f",$float4(lx0+598))
  endif
  if ($float4(lx0+602)==0.0) then
    change hcamyv text="默认"
  else
    change hcamyv text=format("%.2f",$float4(lx0+602))
  endif
  if ($uint1(lx+450)==0 || $uint1(lx+450)>100) $uint1(lx+450)=100
  change hzaccel text=format(" %i",$uint1(lx+686))
  change hreducea text=format(" %i",$uint1(lx+450))
end

function int Getspecialstuff()
  int i
  float r
  char s[64]
  Text(hxaccel,s); r=0.0; sscanf(s,"%g",&r)
  $float4(lx+472)=r
  Text(hxvelo,s); r=0.0; sscanf(s,"%g",&r)
  $float4(lx+476)=r
  Text(hyaccel,s); r=0.0; sscanf(s,"%g",&r)
  $float4(lx+480)=r
  Text(hyvelo,s); r=0.0; sscanf(s,"%g",&r)
  $float4(lx+484)=r
  Text(hcamxa,s); r=0.0; sscanf(s,"%g",&r)
  $float4(lx0+590)=r
  Text(hcamxv,s); r=0.0; sscanf(s,"%g",&r)
  $float4(lx0+594)=r
  Text(hcamya,s); r=0.0; sscanf(s,"%g",&r)
  $float4(lx0+598)=r
  Text(hcamyv,s); r=0.0; sscanf(s,"%g",&r)
  $float4(lx0+602)=r
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// NEEDLE SELECTION CHILD ////////////////////////////

// Creates needle selection child window inside the A5 stuff panel. If mode is
// 1, bottom/only needle is set. If mode is 2, bottom needle type is set.
function int Createneedleselect(int mode)
  int i,j,type,dms,needletype,zheadtype,valid
  hneedlesel=control CHILD
    window=hparm
    position=XX1,3,341+XC1,423-5
    help=" "
    color=BLACK
    bkcolor=LIGHTYELLOW
    size=4096
  endc
  hneedleband=control CHILD
    window=hneedlesel
    position=0,0,335+XC1,NEEDLEY+2*NEEDLEBY+16
    help="选择针头"
    limits=NNEEDLE*(NEEDLEX+NEEDLEBX)+NEEDLEBX,NEEDLEY+2*NEEDLEBY
    mode=M_HSCROLL
    size=1024
  endc
  draw window=hneedlesel font=INFOFONT color=BLACK mode=M_RIGHT
  draw at 60,NEEDLEY+2*NEEDLEBY+36 text="类型:"
  draw at 60,NEEDLEY+2*NEEDLEBY+55 text="感应器:"
  draw at 60,NEEDLEY+2*NEEDLEBY+74 text="针头:"
  draw at 60,NEEDLEY+2*NEEDLEBY+93 text="料号:"
  draw show
  hneedlename=control TEXT
    window=hneedlesel
    position=65,NEEDLEY+2*NEEDLEBY+20,180,16
    help="针头类型"
    font=MAINFONT
  endc
  hneedlesens=control TEXT
    window=hneedlesel
    position=65,NEEDLEY+2*NEEDLEBY+39,180,16
    help="针头类型"
    font=MAINFONT
  endc
  hneedlepins=control TEXT
    window=hneedlesel
    position=65,NEEDLEY+2*NEEDLEBY+58,180,16
    help="针头类型"
    font=MAINFONT
  endc
  hneedlepart=control TEXT
    window=hneedlesel
    position=65,NEEDLEY+2*NEEDLEBY+77,180,16
    help="针头类型"
    font=MAINFONT
  endc
  hneedleset=control WINBUTTON
    window=hneedlesel
    position=285,NEEDLEY+2*NEEDLEBY+23,70,24
    text="设置"
    help="设置新针头类型"
  endc
  // Get needle type.
  needlesel=-1
  if mode==2 then
    needletype=$uint2(lx+718)          // Bottom needle type
    zheadtype=$uint4(lx+460)
  else
    needletype=$uint2(lx+636)          // Top or only needle type
    zheadtype=lx.zheadtype
  endif
  // Check whether precise type is declared in layout.
  if needletype>0 then
    for i=0,i<NNEEDLE,i++ do
      j=(nddata[i][9]-'0')*100+(nddata[i][10]-'0')*10+(nddata[i][11]-'0')
      if j==needletype then
        needlesel=i; break
      endif
    enddo
  endif
  // If not, try to locate type in the table using features from layout.
  if needlesel<0 && (zheadtype & HCZ_VALID)!=0 then
    type=zheadtype & HCZ_CONTMASK
    dms=zheadtype & HCZ_DMSMASK
    for i=0,i<NNEEDLE,i++ do
      if (type==HCZ_CONTSTD || type==HCZ_CONTDEF) && nddata[i,19]!='H' continue
      if type==HCZ_CONTEMU && nddata[i,19]!='A' continue
      if (type==HCZ_CONTSPL || type==HCZ_CONTHSPL) && nddata[i,19]!='S'        \
        continue
      if type==HCZ_CONTSKP && nddata[i,19]!='M' continue
      if type==HCZ_CONTHPS && nddata[i,19]!='P' continue
      if Isdigit(nddata[i,21]) && ((zheadtype>>16) & 0x3)!=nddata[i,21]-'0'    \
        continue
      if (l.probetype & 1)==0 && nddata[i,15]!='S' continue
      if (l.probetype & 1)!=0 && nddata[i,15]!='K' continue
      if nddata[i,13]=='N' && dms==HCZ_DMSSTD break
      if nddata[i,13]=='D' && dms==HCZ_DMSSTD break
      if nddata[i,13]=='D' && dms==HCZ_DMSAUTO then
        needlesel=i; continue; endif
      if nddata[i,13]=='M' && dms==HCZ_DMSSTD break
      if nddata[i,13]=='M' && dms==HCZ_DMSAUTO then
        needlesel=i; continue; endif
      if nddata[i,13]=='I' && dms==HCZ_DMSREV break
      if nddata[i,13]=='I' && dms==HCZ_DMSAUTO then
        needlesel=i; continue
      endif
    enddo
    if i<NNEEDLE needlesel=i
  endif
  if needlesel<0 needlesel=0
  needlescroll=needlesel*(NEEDLEX+NEEDLEBX)-(341+XC1-NEEDLEX)/2+NEEDLEBX
  change hneedleband offset=needlescroll,0
  runscroll=1
  prevbuttons=0
  needledraw=1
  // Check whether needle type is compatible with other layout settings.
  // If not, zero type.
  if needletype!=0 then
    for i=0,i<NNEEDLE,i++ do
      j=(nddata[i][9]-'0')*100+(nddata[i][10]-'0')*10+(nddata[i][11]-'0')
      if j==needletype break
    enddo
    if i>=NNEEDLE then
      valid=0
    else
      valid=1
      if (l.config & LC_AUTOPROBE)!=0 then
        if nddata[i][15]=='S' && l.probetype!=0 valid=0
        if nddata[i][15]=='K' && l.probetype!=1 valid=0
      endif
      type=zheadtype & HCZ_CONTMASK
      if nddata[i][19]=='H' && type!=HCZ_CONTSTD valid=0
      if nddata[i][19]=='A' && type!=HCZ_CONTEMU valid=0
      if nddata[i][19]=='S' && type!=HCZ_CONTSPL valid=0
      if nddata[i][19]=='M' && type!=HCZ_CONTSKP valid=0
      if nddata[i][19]=='P' && type!=HCZ_CONTHPS valid=0
      if (zheadtype & HCZ_DMSMASK)!=HCZ_DMSAUTO then
        dms=zheadtype & HCZ_DMSMASK
        if nddata[i][13]=='N' && dms!=HCZ_DMSSTD valid=0
        if nddata[i][13]=='D' && dms!=HCZ_DMSSTD valid=0
        if nddata[i][13]=='M' && dms!=HCZ_DMSSTD valid=0
        if nddata[i][13]=='I' && dms!=HCZ_DMSREV valid=0
      endif
    endif
    if valid==0 then
      if mode==2 then
        $uint2(lx+718)=0               // Bottom needle type
      else
        $uint2(lx+636)=0               // Top or only needle type
      endif
    endif
  endif
end


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LAYOUT PRINTING ////////////////////////////////

#define NL             32              // Positions in left text file column
#define NR             44              // Positions in right text file column

// Service function, formats and writes single row to text file.
function int Printline(handle f,char *s1,format s2)
  int i,j,k,n,nl,nr,sp
  char l[8,NL],r[8,NR]
  for i=0,i<8,i++ do
    l[i,0]='\0'
    r[i,0]='\0'
  enddo
  // Format left text.
  n=Strlen(s1)
  k=0; nl=0
  while k<n && nl<8 do                 // Process left lines, one by one
    // Skip spaces.
    while k<n && s1[k]==' ' do
      k++
    enddo
    // Fill next left line.
    sp=0
    for j=k,j<n && j-k<NL-1,j++ do
      if s1[j]==' ' sp=j-k
      l[nl,j-k]=s1[j]
    enddo
    if j-k==NL-1 && sp>0 then
      j=k+sp
    endif
    for i=j-k,i<NL-1,i++ do
      l[nl,i]=' '
    enddo
    l[nl,NL-1]='\0'
    k=j
    nl++
  enddo
  // Format right text.
  n=Strlen(s2)
  k=0; nr=0
  while k<n && nr<8 do                 // Process right lines, one by one
    // Skip spaces.
    while k<n && s2[k]==' ' do
      k++
    enddo
    // Fill next right line.
    sp=0
    for j=k,j<n && j-k<NR-1,j++ do
      if s2[j]==' ' sp=j-k
      r[nr,j-k]=s2[j]
    enddo
    if j-k==NR-1 && sp>0 then
      j=k+sp
    endif
    r[nr,j-k]='\0'
    k=j
    nr++
  enddo
  // Print lines.
  for i=0,i<Max(nl,nr),i++ do
    fprintf(f,"  %s   %s\n",l[i],r[i])
  enddo
end

// Saves layout as plain ASCII text to file.
function int Printlayout()
  int rail,head,nhead,left
  char s[256],printname[260],drv[4],dir[260],nam[260],ext[260]
  handle f
  // Ask for file name.
  Fnsplit(layoutname,drv,dir,nam,ext)
  Fnmerge(printname,drv,dir,nam,".txt")
  if SYS.Browse(hmain,printname,"Specify text file to print layout",0)==0 then
    return
  endif
  f=Fopen(printname,"wt")
  if f==NULL then
    Error("Unable to create file",printname)
    return
  endif
  // General parameters.
  fprintf(f,"\nGENERAL PARAMETERS\n\n")
  if (l.config & LC_TMASK)==0 then
    Printline(f,"Type of tester","A2, A3, A4, A5, A5L, A6, old A1")
  else if (l.config & LC_TMASK)==LC_LDELAY then
    Printline(f,"Type of tester","PPE tester")
  else if (l.config & LC_TMASK)==LC_HIGHZ then
    Printline(f,"Type of tester","Old high-Z A1 tester")
  else if (l.config & LC_TMASK)==(LC_LDELAY|LC_HIGHZ) then
    Printline(f,"Type of tester","B1 (backpanel) tester")
  else if (l.config & LC_TMASK)==LC_ISM2 then
    Printline(f,"Type of tester","M2 tester")
  else if (l.config & LC_TMASK)==LC_NEWA1 then
    Printline(f,"Type of tester","New A1 tester")
  else if (l.config & LC_TMASK)==LC_S1 then
    Printline(f,"Type of tester","S1 tester")
  else if (l.config & LC_TMASK)==LC_A8 then
    Printline(f,"Type of tester","A7, A8 tester")
  else if (l.config & LC_TMASK)==LC_S3 then
    Printline(f,"Type of tester","S3 tester")
  else
    Printline(f,"Type of tester","%08X",l.config & LC_TMASK)
  endif
  Printline(f,"Number of rails","%i",l.nfing)
  if (l.cameras & 0x03)==0x00 && l.headcameras!=0 then                          //CHECK FOR THE CASE OF S3!!!!
    Printline(f,"Video cameras","On-head")
  else if (l.cameras & 0x03)==0x00 then
    Printline(f,"Dedicated cameras","None")
  else if (l.cameras & 0x03)==0x01 then
    Printline(f,"Dedicated cameras","Top")
  else if (l.cameras & 0x03)==0x02 then
    Printline(f,"Dedicated cameras","Bottom")
  else
    Printline(f,"Dedicated cameras","Top and bottom")
  endif
  Printline(f,"Serial number","%32s",l.serialid)
  Printline(f,"label","%8s",lx+700)
  if (l.config & LC_AMASK)==LC_EXTANT then
    Printline(f,"Field antennas","Grid")
  else if (l.config & LC_AMASK)==LC_INTANT then
    Printline(f,"Field antennas","Internal")
  else if (l.config & LC_AMASK)==LC_FINGANT then
    Printline(f,"Field antennas","Finger")
  else
    Printline(f,"Field antennas","Type 3")
  endif
  if (lx.zheadtype & HCZ_VALID)==0 then
    Printline(f,"Type of Z axis","%s",                                         \
    l.zaxis==0?"White parallelogramm":"Gray parallelogramm")
  endif
  if (l.config & LC_A2LOADER)==0 then
    Printline(f,"Product shuttle","Generic")
  else if (l.config & LC_SMASK)==LC_A2SHUT then
    Printline(f,"Product shuttle","A2")
  else if (l.config & LC_SMASK)==LC_A2XSHUT then
    Printline(f,"Product shuttle","A2X")
  else if (l.config & LC_SMASK)==LC_AUTOMATE then
    Printline(f,"Product shuttle","Automate")
  else if (l.config & LC_SMASK)==LC_A5WIDE then
    Printline(f,"Product shuttle","A1/A5 wide")
  else if (l.config & LC_SMASK)==LC_LM then
    Printline(f,"Product shuttle","L&M A5a")
  else if (l.config & LC_SMASK)==LC_EPCOS then
    Printline(f,"Product shuttle","L&M EPCOS")
  else if (l.config & LC_SMASK)==LC_LMS2 then
    Printline(f,"Product shuttle","L&M S2a")
  else if (l.config & LC_SMASK)==LC_LMMAN then
    Printline(f,"Product shuttle","L&M Manual")
  else
    Printline(f,"Product shuttle","Unknown")
  endif
  if (l.config & LC_LDMASK)==(LC_LM|LC_A2LOADER) ||                            \
    (l.config & LC_LDMASK)==(LC_EPCOS|LC_A2LOADER)                             \
  then
    Printline(f,"Parameter server address","%i.%i.%i.%i",                      \
      $uint1(lx+585),$uint1(lx+584),$uint1(lx+583),$uint1(lx+582))
    Printline(f,"Parameter server port","%i",$uint2(lx+580))
  endif
  Printline(f,"Vacuum box","%s",l.config & LC_VACUUMBOX?"Yes":"No")
  if (l.config & LC_A2LOADER)==0 then
    Printline(f,"Pressure sensors","%s",l.config & LC_ZSENSORS?"Yes":"No")
    Printline(f,"Hard contacting","%s",l.config & LC_HARDZ?"Yes":"No")
  endif
  Printline(f,"Hide contacts over surface","%s",l.config & 0x80000?"Yes":"No")
  if (l.config & LC_OHTYPE)==LC_PASSIVE then
    Printline(f,"On-heads","Manual adjust")
  else if (l.config & LC_OHTYPE)==LC_ACTIVE then
    Printline(f,"On-heads","Active (1 potentiometer)")
  else if (l.config & LC_OHTYPE)==LC_PHADJ then
    Printline(f,"On-heads","Active (C and phase)")
  else if (l.config & LC_OHTYPE)==LC_NOFIELD then
    Printline(f,"On-heads","Optimized for C")
  else
    Printline(f,"On-heads","%08X",l.config & LC_OHTYPE)
  endif
  Printline(f,"Probe type","%s",l.probetype & 1?"Kelvin":"Solid")
  Printline(f,"Autodetect probes","%s",l.config & LC_AUTOPROBE?"Yes":"No")
  Printline(f,"Slow relays","%s",l.config & LC_RELAYS?"Yes":"No")
  Printline(f,"Autoresolve deadlocks","%s",l.config & LC_DEADLOCKS?"Yes":"No")
  if (l.config & LC_MOREMASK)==0 then
    Printline(f,"Wide area","No")
  else if (l.config & LC_MOREMASK)==LC_MORETOP then
    Printline(f,"Wide area","Top side only")
  else if (l.config & LC_MOREMASK)==LC_MOREBOT then
    Printline(f,"Wide area","Bottom side only")
  else
    Printline(f,"Wide area","Both sides")
  endif
  // Geometrical parameters.
  fprintf(f,"\nGEOMETRICAL PARAMETERS\n\n")
  Printline(f,"Left working area limit","%.3f mm",l.leftlimit/1000.0)
  Printline(f,"Right working area limit","%.3f mm",l.rightlimit/1000.0)
  Printline(f,"X center coordinate","%.3f mm",l.xoffset/1000.0)
  Printline(f,"Video dead X area","%.3f mm",l.videodeadx/1000.0)
  if $int4(lx+424)==0 then
    Printline(f,"Head radius","Default")
  else
    Printline(f,"Head radius","%.3f mm",$int4(lx+424)/1000.0)
  endif
  if $int4(lx+428)==0 then
    Printline(f,"Headcam radius","Default")
  else
    Printline(f,"Headcam radius","%.3f mm",$int4(lx+428)/1000.0)
  endif
  // Head-specific data.
  nhead=2*l.nfing
  if l.cameras!=0 nhead=nhead+2
  for head=0,head<nhead,head++ do
    rail=head/2
    left=((head & 1)==0)
    // From main layout.
    if head<2*l.nfing then
      fprintf(f,"\nINDIVIDUAL DATA OF HEAD %i (%i%c)\n\n",                     \
        head,head/2,head & 1?'R':'L')
      Printline(f,"Side","%s",l.side[rail] & 1?"Bottom":"Top")
      Printline(f,"X encoder direction","%s",                                  \
        l.sensorpos[rail] & 2?"Inverted":"Standard")
      Printline(f,"Sensor position","%s",l.sensorpos[rail] & 1?"Up":"Down")
    else
      if (l.cameras & (1<<(head & 1)))==0 continue
      fprintf(f,"\nINDIVIDUAL DATA OF %s DEDICATED CAMERA\n\n",                \
      head & 1?"底部":"顶部")
    endif
    Printline(f,"Top rail limit","%.3f mm",l.top[rail]/1000.0)
    Printline(f,"Bottom rail limit","%.3f mm",l.bottom[rail]/1000.0)
    Printline(f,"Y center coordinate","%.3f mm",l.yoffset[rail]/1000.0)
    Printline(f,"X center correction","%.3f mm",                               \
      (left?l.leftzerox[rail]:l.rightzerox[rail])/1000.0)
    Printline(f,"Y center correction","%.3f mm",                               \
      (left?l.leftzeroy[rail]:l.rightzeroy[rail])/1000.0)
    Printline(f,"X motor phase at 0 sensor","%i",                              \
      left?l.leftphro[rail]:l.rightphro[rail])
    Printline(f,"Y motor phase at 0 sensor","%i",                              \
      left?l.leftphfi[rail]:l.rightphfi[rail])
    if (l.cameras==0 || (l.config & LC_TYPEMASK)==LC_S3) &&                    \
      l.headcameras!=0 then
      Printline(f,"Head camera","%s",l.headcameras & (1<<head)?"Present":"No")
    endif
    // From extended layout.
    Printline(f,"Individual R correction","%.4f Ohm",lx.radj[head]/1000000.0)
    Printline(f,"C phase correction at 16 kHz","%.4f rad (%i bits)",           \
      $int2(lx+516+2*head)/10000.0,$int2(lx+516+2*head))
    Printline(f,"Z pressure factor","%.4f (%i bits)",                          \
      $int2(lx+272+2*head)/1024.0,$int2(lx+272+2*head))
    Printline(f,"CRT correction factor","%.4f (%i bits)",                      \
      lx.crtcorr[head]/10000.0,lx.crtcorr[head])
    Printline(f,"Sine potentiometer","%i bits",lx.sinadj[head])
    Printline(f,"Cosine potentiometer","%i bits",lx.cosadj[head])
    // From additional extention 0.
    if lx0.valid!=0 then
      Printline(f,"Tilt of Y axis in X dir","%.6f",lx0.ytiltx[head]/100000.0)
      Printline(f,"Tilt of Y axis in Y dir","%.6f",lx0.ytilty[head]/100000.0)
      Printline(f,"Tilt of Z axis in X dir","%.6f",lx0.ztiltx[head]/100000.0)
      Printline(f,"Tilt of Z axis in Y dir","%.6f",lx0.ztilty[head]/100000.0)
    endif
  enddo
  // Thermal parameters.
  fprintf(f,"\nTHERMAL PARAMETERS\n\n")
  if l.caldate==0 then
    Printline(f,"Calibrated on","(No date)")
  else
    Strtime(s,"%d-%b-%Y",2,l.caldate)
    Printline(f,"Calibrated on","%s",s)
  endif
  Printline(f,"Calibration temperature","%.1f C",l.caltemp/10.0)
  if $uint2(lx+586)==0 then
    Printline(f,"C adjust on","(No date)")
  else
    Strtime(s,"%d-%b-%Y",2,$uint2(lx+586))
    Printline(f,"C adjust on","%s",s)
  endif
  if ($int4(lx+496) & HCM_TMEASOFF)!=0 then
    Printline(f,"Temperature measurements","Disabled")
  else
    Printline(f,"Temperature measurements","Enabled")
  endif
  Printline(f,"Temperature extention","%i um/100 C",l.thermexp)
  Printline(f,"Pressure deformation","%i um/100 g",l.presscor)
  // Measurement parameters.
  fprintf(f,"\nMEASUREMENT PARAMETERS\n\n")
  Printline(f,"100 mA DC current","%7g mA",l.i100ma/1.0e6)
  Printline(f,"30 mA DC current","%7g mA",l.i30ma/1.0e6)
  Printline(f,"10 mA DC current","%7g mA",l.i10ma/1.0e6)
  Printline(f,"3 mA DC current","%7g mA",l.i3ma/1.0e6)
  Printline(f,"1 mA DC current","%7g mA",l.i1ma/1.0e6)
  Printline(f,"300 uA DC current","%7g uA",l.i300ua/1.0e3)
  Printline(f,"100 uA DC current","%7g uA",l.i100ua/1.0e3)
  Printline(f,"30 uA DC current","%7g uA",l.i30ua/1.0e3)
  Printline(f,"10 uA DC current","%7g uA",l.i10ua/1.0e3)
  if $uint2(lx+508)==0 then
    Printline(f,"HV Umax","Maximal possible")
  else
    Printline(f,"HV Umax","%i V",$uint2(lx+508))
  endif
  if $uint2(lx+442)==0 then
    Printline(f,"MSD Umax","Default")
  else
    Printline(f,"MSD Umax","%i V",$uint2(lx+442))
  endif
  Printline(f,"9 V DC voltage","%7g V",l.dc9v/1.0e6)
  Printline(f,"0.9 V DC voltage","%7g V",l.dc0v9/1.0e6)
  Printline(f,"10 V AC voltage","%7g V",l.ac10v/1.0e6)
  Printline(f,"1 V AC voltage","%7g V",l.ac1v/1.0e6)
  Printline(f,"100 mV AC voltage","%7g mV",l.ac0v1/1.0e3)
  Printline(f,"10 mV AC voltage","%7g mV",l.ac10mv/1.0e3)
  Printline(f,"Resistor in I-U converter","%7.3g kOhm",l.r100k/1000.0)
  Printline(f,"Default AC frequency","%i Hz",l.frequency)
  Printline(f,"Shortcut resistance","%.5f Ohm",l.rzero/1.0e6)
  if $uint1(lx+448)>55 && $uint1(lx+448)<65 then
    Printline(f,"Mains frequency","60 Hz")
  else
    Printline(f,"Mains frequency","50 Hz")
  endif
  Printline(f,"C phase correction at 4 kHz","%.2f deg (%i bits)",              \
    $int2(lx+620)/100.0,$int2(lx+620))
  Printline(f,"C phase correction at 8 kHz","%.2f deg (%i bits)",              \
    $int2(lx+622)/100.0,$int2(lx+622))
  Printline(f,"C phase correction at 16 kHz","%.2f deg (%i bits)",             \
    $int2(lx+624)/100.0,$int2(lx+624))
  Printline(f,"C phase correction at X kHz","%.2f deg (%i bits)",              \
    $int2(lx+626)/100.0,$int2(lx+626))
  Printline(f,"C amplitude factor at 4 kHz","%.4f (%i bits)",                  \
    $int2(lx+628)/10000.0,$int2(lx+628))
  Printline(f,"C amplitude factor at 8 kHz","%.4f (%i bits)",                  \
    $int2(lx+630)/10000.0,$int2(lx+630))
  Printline(f,"C amplitude factor at 16 kHz","%.4f (%i bits)",                 \
    $int2(lx+632)/10000.0,$int2(lx+632))
  Printline(f,"C amplitude factor at X kHz","%.4f (%i bits)",                  \
    $int2(lx+634)/10000.0,$int2(lx+634))
  // DSP parameters.
  fprintf(f,"\nDSP PARAMETERS\n\n")
  if (lx.zheadtype & HCZ_VALID) then
    if (lx.zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA3 then
      Printline(f,"Type of Z axis","A1/A5 gray finger")
    else if (lx.zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA2G then
      Printline(f,"Type of Z axis","A6 gray finger")
    else if (lx.zheadtype & HCZ_TYPEMASK)==HCZ_TYPECER then
      Printline(f,"Type of Z axis","Ceramic stepper")
    else if (lx.zheadtype & HCZ_TYPEMASK)==HCZ_TYPELIN then
      Printline(f,"Type of Z axis","A7/A8 linear motor")
    else if (lx.zheadtype & HCZ_TYPEMASK)==HCZ_TYPENO then
      Printline(f,"Type of Z axis","Absent")
    else
      Printline(f,"Type of Z axis","%08X",lx.zheadtype)
    endif
    if (lx.zheadtype & HCZ_CONTMASK)==HCZ_CONTDEF then
      Printline(f,"Type of needle","Default")
    else if (lx.zheadtype & HCZ_CONTMASK)==HCZ_CONTSTD then
      Printline(f,"Type of needle","Standard")
    else if (lx.zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL then
      Printline(f,"Type of needle","Soft splinogram")
    else if (lx.zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL then
      Printline(f,"Type of needle","Hard splinogram")
    else if (lx.zheadtype & HCZ_CONTMASK)==HCZ_CONTEMU then
      Printline(f,"Type of needle","Splino adapter")
    else if (lx.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
      Printline(f,"Type of needle","Micro probe (micro-parallelogramm)")
    else
      Printline(f,"Type of needle","%08X",lx.zheadtype)
    endif
    if (lx.zheadtype & HCZ_STRMASK)==HCZ_STRNORM then
      Printline(f,"Type of stroke","Standard")
    else if (lx.zheadtype & HCZ_STRMASK)==HCZ_STRSOFT then
      Printline(f,"Type of stroke","Soft Landing")
    else if (lx.zheadtype & HCZ_STRMASK)==HCZ_STRHARD then
      Printline(f,"Type of stroke","Hard (scratching)")
    else if (lx.zheadtype & HCZ_STRMASK)==HCZ_LEARNZ then
      Printline(f,"Type of stroke","Learned Z")
    else
      Printline(f,"Type of stroke","%08X",lx.zheadtype)
    endif
  endif
  if $uint2(lx+636)==NT_UNKNOWN then
    Printline(f,"Extended probe type","0 (None)")
  else if $uint2(lx+636)==NT_HARD then
    Printline(f,"Extended probe type","1 (Solid hard touch)")
  else if $uint2(lx+636)==NT_HARDADAPT then
    Printline(f,"Extended probe type","2 (Hard touch adapter)")
  else if $uint2(lx+636)==NT_SPLINO then
    Printline(f,"Extended probe type","3 (Splinogramm)")
  else if $uint2(lx+636)==NT_MICROMIRR then
    Printline(f,"Extended probe type","4 (Microprobe with mirror)")
  else if $uint2(lx+636)==NT_MICRO then
    Printline(f,"Extended probe type","5 (Microprobe with transmissive sensor)")
  else if $uint2(lx+636)==NT_KELVMIRR then
    Printline(f,"Extended probe type","6 (Kelvin microprobe with mirror)")
  else if $uint2(lx+636)==NT_LATEST then
    Printline(f,"Extended probe type","8 (Kelvin with mirror and blades)")
  else
    Printline(f,"Extended probe type","%i (Unknown)",$uint2(lx+636))
  endif
  Printline(f,"Z optimization","%s",                                           \
    (lx.zheadtype & HCZ_NOOPT)?"Turned off":"Turned on")
  Printline(f,"Deep Z movements","%s",                                         \
    (lx.extcfg & EXT_NOZLIMIT)?"Allowed":"Not allowed")
  if lx.extant==0 then
    Printline(f,"External antennas","None")
  else if lx.extant==1 then
    Printline(f,"External antennas","Antenna 0")
  else if lx.extant==3 then
    Printline(f,"External antennas","0 and 1")
  else
    Printline(f,"External antennas","%08X",lx.extant)
  endif
  Printline(f,"Insulated shuttle","%s",                                        \
    ($int4(lx+496) & HCM_ISOEANT)?"Yes":"No")
  Printline(f,"Correct encoders on reset","%s",                                \
    (lx.extcfg & EXT_CHECKZERO)?"Yes":"No")
  Printline(f,"Aggressive optimization","%s",                                  \
    ($int4(lx+4) & HCX_OPTWAIT)?"Yes":"No")
  Printline(f,"Limit total X power","%s",                                      \
    ($int4(lx+4) & HCX_POWERLIM)?"Yes":"No")
  Printline(f,"Monitor motor temperature","%s",                                \
    ($int4(lx+4) & HCX_TSENS)?"Yes":"No")
  Printline(f,"Park Z in home position","%s",                                  \
    (lx.zheadtype & HCZ_PARKZ)?"Yes":"No")
  Printline(f,"Verify parallel contacting","%s",                               \
    ($int4(lx+496) & HCM_PARCONT)?"Yes":"No")
  Printline(f,"Force 1 mA HV current","%s",                                    \
    ($int4(lx+496) & HCM_HV1MA)?"Yes":"No")
  Printline(f,"Don't accelerate relays","%s",                                  \
    ($int4(lx+496) & HCM_NOACCEL)?"Yes":"No")
  Printline(f,"20% stricter self-test limits","%s",                            \
    ($int4(lx+496) & HCM_STRICT)?"Yes":"No")
  Printline(f,"Don't verify contacts","%s",                                    \
    ($int4(lx+496) & HCM_NOCTCHK)?"Yes":"No")
  Printline(f,"Calibrate nocontact in the air","%s",                           \
    (lx.extcfg & EXT_CONTAIR)?"Yes":"No")
  Printline(f,"Calibrate field/C in the air","%s",                             \
    (lx.extcfg & EXT_CAIR)?"Yes":"No")
  Printline(f,"Calibrate MSD in the air","%s",                                 \
    (lx.extcfg & EXT_CRTAIR)?"Yes":"No")
  Printline(f,"Calibrate capacity to shuttle","%s",                            \
    ($int4(lx+496) & HCM_CTOEXT)?"Yes":"No")
  if ($int4(lx+496) & HCM_FILTMASK)==HCM_FNONE then
    Printline(f,"Signal filtering","None")
  else if ($int4(lx+496) & HCM_FILTMASK)==HCM_F500K then
    Printline(f,"Signal filtering","Low (500 kHz)")
  else if ($int4(lx+496) & HCM_FILTMASK)==HCM_F100K then
    Printline(f,"Signal filtering","中等 (100 kHz)")
  else
    Printline(f,"Signal filtering","High (20/50 kHz)")
  endif
  Printline(f,"Filter capacity over 300 pF","%s",                              \
    ($int4(lx+496) & HCM_FILTERC)?"Yes":"No")
  Printline(f,"Allow parallel LATEST","%s",                                    \
    (lx.extcfg & EXT_LAPAR)?"Yes":"No")
  Printline(f,"Optimize EXACTR dor dual card","%s",                            \
    (lx.extcfg & EXT_EPAR)?"Yes":"No")
  if $int1(lx+449)==ILL_DEFAULT then
    Printline(f,"Illumination","Default (cameras)")
  else if $int1(lx+449)==ILL_EXTERN then
    Printline(f,"Illumination","External")
  else if $int1(lx+449)==ILL_MIXED then
    Printline(f,"Illumination","Mixed")
  else if $int1(lx+449)==ILL_EXTON then
    Printline(f,"Illumination","External, permanently ON")
  else if $int1(lx+449)==ILL_FLASH then
    Printline(f,"Illumination","Flashlight")
  else if $int1(lx+449)==ILL_FLASHMIX then
    Printline(f,"Illumination","Flash and external")
  else
    Printline(f,"Illumination","%i",$int1(lx+449))
  endif
  Fclose(f)
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// MAIN PROGRAM /////////////////////////////////

function int fpt_show_all_views()

    Getgeometry()
    
    
    // Tab 2
    Getthermal()
    Showthermal()
    
    
    // Tab 3
    Getmeas()
    Showmeas()
    
    
    // Tab 5
    Getmeas2()
    Showmeas2()
    
    // Tab 6/7
    Showdspconfig()
    Showspecialstuff()
end

function int serv_log_layout(char *vlog)
    handle f_log_layout
    if f_log_layout==NULL f_log_layout=Fopen("fpt_layout_log.log","at")
    if f_log_layout!=NULL fprintf(f_log_layout, "%s \n", vlog)
end

function int main()
  int i,j,k,m,n,x,y,t,buttons,selection,newsel,redraw,reoffs,move,hdopt,err
  int pending,zheadtype,zheadbot,dms,extant,subst,infield[32],nextra
  int videochanged,videoside,channel,videox,videoy,dummy,dontsave
  char s[768],exts[768],e0[768],e1[768],e2[768],e3[768],buf[1024], tmp[50]
  float temp,cx,cy
  handle f
  handle hmessage,hsave,hcancel
  int nReadFlag
  
  nReadFlag=0
  
  // Extended layout is no longer optional. If it's missing or all zeros, warn
  // user.
  for i=0,i<768,i++ do
    if $char($LAY+i)!=0 then
        tmp[0] = $char($LAY+i)
        tmp[1] = 0
        serv_log_layout(tmp)
        break
    endif
  enddo
  
  // miaoyu 此处有校验，需要仔细研究
  if i<768 then
    for j=0,j<768,j++ do
      if $char($EXTLAY+j)!=0 break
    enddo
    if j==768 then
      Error("Extended layout is missing!",                                     \
      "Do not save layout unless absolutely sure!")
    endif
  endif
  
  
  Makelayoutcopy($LAY,$EXTLAY,$EXT0,$EXT1,$EXT2,$EXT3)
  
  Createmain()
  Creategeneral()
  Showgeneral()
  
  selection=0; redraw=1; reoffs=1; rail=0; finger=0; railbtn=0
  showgeneral=1; showshuttle=0
  deftester=1; move=0; pending=0; step=10
  videoon=0; videochanged=0; viewfing=0
  zoom=0.5; scanshift=0; touchmode=0
  while 1 do
    if selection==0 then               // General layout settings
      Getgeneral()
      if Pressed(htype) then           // Changed type of tester
        i=Status(htype)
        if i<4 then
          l.config=(l.config & (~LC_TMASK))+i*4
        else if i==4 then
          l.config=(l.config & (~LC_TMASK)) | LC_ISM2
        else if i==5 then              // A1
          l.config=(l.config & (~LC_TMASK)) | LC_NEWA1
        else if i==6 then              // S1/S2
          l.config=(l.config & (~LC_TMASK)) | LC_S1
        else if i==7 then              // A7/A8
          l.config=(l.config & (~LC_TMASK)) | LC_A8
        else                           // S3
          l.config=(l.config & (~LC_TMASK)) | LC_S3
        endif
        redraw=1
      else if Pressed(hrscroll) then
        l.nfing=Max(0,Min((l.cameras==0?16:15),l.nfing+Status(hrscroll)))
        change hrscroll select=0
        redraw=1
      else if Pressed(hcscroll) then
        l.cameras=Max(0,Min(3,l.cameras+Status(hcscroll)))
        change hcscroll select=0
        redraw=1
      else if Pressed(hantennas) then
        i=Status(hantennas)
        l.config=(l.config & (~LC_AMASK))+i
        redraw=1
      else if Pressed(hfingtype) then
        l.zaxis=Status(hfingtype)
        redraw=1
      else if Pressed(hshtype) then
        i=Status(hshtype)
        l.config=l.config & (~LC_LDMASK)
        if i==1 l.config=l.config|LC_A2SHUT|LC_A2LOADER
        if i==2 l.config=l.config|LC_A2XSHUT|LC_A2LOADER
        if i==3 l.config=l.config|LC_AUTOMATE|LC_A2LOADER
        if i==4 l.config=l.config|LC_A5WIDE|LC_A2LOADER
        if i==5 l.config=l.config|LC_LM|LC_A2LOADER
        if i==6 l.config=l.config|LC_EPCOS|LC_A2LOADER
        if i==7 l.config=l.config|LC_LMS2|LC_A2LOADER
        if i==8 l.config=l.config|LC_LMMAN|LC_A2LOADER
        if i==9 l.config=l.config|LC_LMSPLIT|LC_A2LOADER
        redraw=1
      else if Pressed(hpress) then
        if Status(hpress)==0 then l.config=l.config & (~LC_ZSENSORS);
        else l.config=l.config | LC_ZSENSORS; endif;
        redraw=1
      else if Pressed(haxscroll) then
        l.xantennas=Max(0,Min(64,l.xantennas+Status(haxscroll)))
        change haxscroll select=0
        redraw=1
      else if Pressed(hayscroll) then
        l.yantennas=Max(0,Min(64,l.yantennas+Status(hayscroll)))
        change hayscroll select=0
        redraw=1
      else if Pressed(hpassive) then
        l.config=(l.config & (~LC_OHTYPE))|LC_PASSIVE
        redraw=1
      else if Pressed(hampl) then
        l.config=(l.config & (~LC_OHTYPE))|LC_ACTIVE
        redraw=1
      else if Pressed(hphase) then
        l.config=(l.config & (~LC_OHTYPE))|LC_PHADJ
        redraw=1
      else if Pressed(hnofield) then
        l.config=(l.config & (~LC_OHTYPE))|LC_NOFIELD
        redraw=1
      else if Pressed(hsplit) then
        if Status(hsplit)==0 then l.probetype=l.probetype & (~0x1);
        else l.probetype=l.probetype | 0x1; endif;
        redraw=1
      else if Pressed(hautosplit) then
        if Status(hautosplit)==0 then l.config=l.config & (~LC_AUTOPROBE);
        else l.config=l.config | LC_AUTOPROBE; endif;
        redraw=1
      else if Pressed(hslow) then
        if Status(hslow)==0 then l.config=l.config & (~LC_RELAYS);
        else l.config=l.config | LC_RELAYS; endif;
        redraw=1
      else if Pressed(hfastreset) then
        lx.extcfg=(lx.extcfg & (~EXT_FASTRESET)) | (Status(hfastreset)<<2)
      else if Pressed(hcheckzero) then
        if Status(hcheckzero)!=0 then
          lx.extcfg=lx.extcfg | EXT_CHECKZERO
          enable hcheckall
        else
          lx.extcfg=lx.extcfg & (~EXT_CHECKZERO)
          disable hcheckall
        endif
      else if Pressed(hcheckall) then
        if Status(hcheckall)!=0 then
          lx.extcfg=lx.extcfg | EXT_CHECKALL
        else
          lx.extcfg=lx.extcfg & (~EXT_CHECKALL)
        endif
      else if Pressed(hrotlabel) then
        if Status(hrotlabel)==0 then lx.extcfg=lx.extcfg & (~EXT_ROTLABEL);
        else lx.extcfg=lx.extcfg | EXT_ROTLABEL; endif;
        redraw=1
      else if Pressed(haltlights) then
        if Status(haltlights)==0 then l.config=l.config & (~LC_TRAFFICS);
        else l.config=l.config | LC_TRAFFICS; endif;
        redraw=1
      else if Pressed(hautolights) then
        if Status(hautolights)==0 then l.config=l.config & (~LC_ILLUM);
        else l.config=l.config | LC_ILLUM; endif;
        redraw=1
      else if Pressed(hautodeadlock) then
        if Status(hautodeadlock)==0 then l.config=l.config & (~LC_DEADLOCKS);
        else l.config=l.config | LC_DEADLOCKS; endif;
        redraw=1
      else if Pressed(hwidetop) then
        if Status(hwidetop)==0 then l.config=l.config & (~LC_MORETOP);
        else l.config=l.config | LC_MORETOP; endif;
        redraw=1
      else if Pressed(hwidebot) then
        if Status(hwidebot)==0 then l.config=l.config & (~LC_MOREBOT);
        else l.config=l.config | LC_MOREBOT; endif;
        redraw=1
      else if Pressed(hhardcontact) then
        if Status(hhardcontact)==0 then l.config=l.config & (~LC_HARDZ);
        else l.config=l.config | LC_HARDZ; endif;
        redraw=1
      else if Pressed(hnooversurf) then
        if Status(hnooversurf)==0 then l.config=l.config & (~0x80000);
        else l.config=l.config | 0x80000; endif;
        redraw=1
      else if Pressed(htraffic) then
        $int4(lx+512)=($int4(lx+512) & (~HCA_TRAFFIC)) | (Status(htraffic)<<16)
      else if Pressed(hvacuumbox) then
        if Status(hvacuumbox)==0 then l.config=l.config & (~LC_VACUUMBOX);
        else l.config=l.config | LC_VACUUMBOX; endif;
        redraw=1
      else if Pressed(hbrowse) then
        Text(hlayoutname,layoutname)
        if SYS.Browse(hmain,layoutname,"Specify layout name",0)!=0 then
          change hlayoutname text=layoutname
        endif
      else if Pressed(hget) then
        buf[0]=S_LAYOUT
        buf[1]=0x03                    // Read layout with corrected phases
        SYS.Sendimm(0,2,buf)
        t=Time()
        while $A[0].length==0 do
          if Time()-t>5000 break       // Timeout 5 seconds
          wait
        enddo
        if $A[0].answer==S_LAYOUT && $A[0].length==774 then
          Memcpy(s,$A[0]+6,768)
          Memset(exts,0,768)
          Memset(e0,0,768)
          Memset(e1,0,768)
          Memset(e2,0,768)
          Memset(e3,0,768)
          if $LAY(s).extlay!=0 then
            buf[0]=S_LAYOUT
            buf[1]=15                  // Read main layout extention
            SYS.Sendimm(0,2,buf)
            for i=1,i<$LAY(s).extlay && i<5,i++ do
              buf[1]=20                // Read additional layout extention
              $int4(buf+2)=i-1         // Index
              SYS.Sendimm(i,6,buf)
            enddo
            t=Time()
            while 1 do
              err=0
              for i=0,i<$LAY(s).extlay && i<5,i++ do
                if $A[i].length==0 then
                  err=1; break         // As yet no answer
                else if $A[i].answer!=S_LAYOUT ||                              \
                  $A[i].length!=(i==0?774:778) then
                  err=2; break         // Invalid answer
                endif
              enddo
              if err!=1 break
              if Time()-t>5000 then
                err=1; break           // Timeout 5 seconds
              endif
              wait
            enddo
            if err==0 then
              Memcpy(exts,$A[0]+6,768)
              for i=0,i<768,i++ do
                if exts[i]!=0 break
              enddo
              if i==768 then
                Error("Extended layout is missing!",                           \
                "Do not save layout unless absolutely sure!")
              endif
              if $LAY(s).extlay>=2 Memcpy(e0,$A[1]+10,768)
              if $LAY(s).extlay>=3 Memcpy(e1,$A[2]+10,768)
              if $LAY(s).extlay>=4 Memcpy(e2,$A[3]+10,768)
              if $LAY(s).extlay>=5 Memcpy(e3,$A[4]+10,768)
            else
              Error("Unable to get extended layout","")
            endif
            $LAY(s).extlay=0
          endif
          Makelayoutcopy(s,exts,e0,e1,e2,e3)
          redraw=1
        else
          Error("Unable to get layout","")
        endif

      // miaoyu beg put component to pages 
      else if Pressed(hmuxtype) then
       i=$int4(lx+674) & (~(MUX_TYPEMASK|MUX_MODCOUNT))
       if Status(hmuxtype)==1 then
         $int4(lx+674)=i | MUX_TYPE506 | 0x01000000
       else if Status(hmuxtype)==2 then
         $int4(lx+674)=i | MUX_TYPE506 | 0x02000000
       else if Status(hmuxtype)==3 then
         $int4(lx+674)=i | MUX_TYPE506 | 0x03000000
       else
         $int4(lx+674)=i | MUX_TYPE406
       endif
       if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE406 then
         disable hmuxaux[0]
         disable hmuxaux[1]
       else
         enable hmuxaux[0]
         enable hmuxaux[1]
       endif
       if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE406 ||                      \
         (($int4(lx+674)>>24) & 0x3)<=1 then
         disable hmuxaux[2]
         disable hmuxaux[3]
       else
         enable hmuxaux[2]
         enable hmuxaux[3]
       endif
       if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE406 ||                      \
         (($int4(lx+674)>>24) & 0x3)<=2 then
         disable hmuxaux[4]
         disable hmuxaux[5]
       else
         enable hmuxaux[4]
         enable hmuxaux[5]
       endif
       Setsubstnames()
     
      // miaoyu end

      else if Pressed(hread) then
        nReadFlag = 1
        if selection==0 then
          confirm hlayoutname
          Text(hlayoutname,layoutname)
        endif
        
        if layoutname[0]!='\0' then
          f=Fopen(layoutname,"rb")
          if f==NULL then
            Error("Unable to open layout file",layoutname)
          else
            Fseek(f,0,2); i=Ftell(f); Fseek(f,0,0);
            if i!=768 && i!=1536 && i!=2304 && i!=3072 &&                      \
              i!=3840 && i!=4608 then
              Error(s,"Invalid length of layout file")
              Fclose(f)
            else
              err=0
              Memset(exts,0,768)
              Memset(e0,0,768)
              Memset(e1,0,768)
              Memset(e2,0,768)
              Memset(e3,0,768)
              j=Fread(s,768,f)
              if j!=768 err=1
              if err==0 && i>=1536 then
                j=Fread(exts,768,f)
                if j!=768 err=1
              endif
              if err==0 && i>=2304 then
                j=Fread(e0,768,f)
                if j!=768 err=1
              endif
              if err==0 && i>=3072 then
                j=Fread(e1,768,f)
                if j!=768 err=1
              endif
              if err==0 && i>=3840 then
                j=Fread(e2,768,f)
                if j!=768 err=1
              endif
              if err==0 && i>=4608 then
                j=Fread(e3,768,f)
                if j!=768 err=1
              endif
              Fclose(f)
              if err!=0 then
                Error("Error reading layout file",layoutname)
              else if $LAY(s).nfing<0 || $LAY(s).nfing>16 then
                Error("Wrong layout",layoutname)
              else
                Makelayoutcopy(s,exts,e0,e1,e2,e3)
                redraw=1
              endif
            endif
          endif
          
          fpt_show_all_views()
        endif
      else if Pressed(hsernumb) || Pressed(hlabel) || Pressed(hshant) then
        redraw=1
      else if Pressed(hantx) || Pressed(hanty) then
        redraw=1
      else if Pressed(hipaddr) || Pressed(hsocket) then
        redraw=1
      endif
    else if selection==1 then          // Tester's geometry
      Getgeometry()
      do j=0,l.nfing,1
        do i=0,1,1
          if j==l.nfing && (l.cameras & (1<<i))==0 continue
          if Pressed(hhead[j][i]) then
            railbtn=j; rail=Min(l.nfing,railbtn);
            showgeneral=0; showshuttle=0
            finger=i; redraw=1; videochanged=1
          endif
        enddo
      enddo
      if Pressed(hgeneral) then
        if showgeneral==0 then
          showgeneral=1; showshuttle=0
          redraw=1
        endif
        videochanged=1
      else if Pressed(hshuttle) then
        if showshuttle==0 then
          showgeneral=0; showshuttle=1
          redraw=1
        endif
        videochanged=1
      else if Pressed(halloff) then
        for i=0,i<=l.nfing,i++ do
          if i<l.nfing then
            $int2(l+764)=$int2(l+764)|(1<<i)
          else if l.cameras!=0 then
            $int2(l+764)=$int2(l+764)|0xC000
          endif
        enddo
        redraw=1
      else if Pressed(hallon) then
        $int2(l+764)=0
        redraw=1
      else if henable!=NULL && Pressed(henable) then
        if rail<l.nfing then           // Head
          if Status(henable)==0 then
            $int2(l+764)=$int2(l+764)|(1<<rail)
          else
            $int2(l+764)=$int2(l+764)&(~(1<<rail))
          endif
        else                           // Dedicated camera
          if Status(henable)==0 then
            $int2(l+764)=$int2(l+764)|(0x4000<<finger)
            if (l.config & LC_TYPEMASK)==LC_S3 then
              $int2(l+764)=$int2(l+764)|(0x4000<<(finger^1))
            endif
          else
            $int2(l+764)=$int2(l+764)&(~(0x4000<<finger))
            if (l.config & LC_TYPEMASK)==LC_S3 then
            $int2(l+764)=$int2(l+764)&(~(0x4000<<(finger^1)))
            endif
          endif
        endif
        redraw=1
      else if hchgside!=NULL && Pressed(hchgside) then
        if rail<l.nfing then
          l.side[rail]=!l.side[rail]
          redraw=1; videochanged=1
        endif
      else if hchgxenc!=NULL && Pressed(hchgxenc) then
        l.sensorpos[rail]=l.sensorpos[rail] ^ 0x02
        redraw=1
      else if hchgysens!=NULL && Pressed(hchgysens) then
        if (l.config & LC_ISM2)==0 then
          if rail==l.nfing then
            l.sensorpos[rail]=l.sensorpos[rail] ^ 0x08
            redraw=1
          else
            l.sensorpos[rail]=l.sensorpos[rail] ^ 0x01
          endif
        else if (rail!=l.nfing || finger==0) then
          i=l.sensorpos[rail]
          l.sensorpos[rail]=(i & 0xF0) | ((i+1) & 0x0F)
        else
          l.sensorpos[rail]=(l.sensorpos[rail]+0x10) & 0xFF
        endif
        redraw=1
      else if hcether!=NULL && Pressed(hcether) then
        $int1(lx0+390+(rail*2+finger)*4)=                                      \
          ($int1(lx0+390+(rail*2+finger)*4) & 0x7f)|(Status(hcether)?0x80:0x00)
        redraw=1
      else if Pressed(htoplimit) || Pressed(hcentery) ||                       \
        Pressed(hbottomlimit) || Pressed(hwarmupdx) ||                         \
        Pressed(hwarmupdy) || Pressed(hwarmupx) || Pressed(hwarmupy)           \
      then
        redraw=1
      else if hheadcamera!=NULL && Pressed(hheadcamera) then
        hdopt=$char(lx+736+rail*2+finger) & (~(HO_CAMOFF|HO_HIRES))
        if Status(hheadcamera)==0 then
          l.headcameras=l.headcameras & (~(1<<(rail*2+finger)))
          $int4(lx+432)=$int4(lx+432) & (~(1<<(rail*2+finger)))
        else if Status(hheadcamera)==1 then
          l.headcameras=l.headcameras|(1<<(rail*2+finger))
          $int4(lx+432)=$int4(lx+432) & (~(1<<(rail*2+finger)))
        else if Status(hheadcamera)==2 then
          l.headcameras=l.headcameras|(1<<(rail*2+finger))
          $int4(lx+432)=$int4(lx+432)|(1<<(rail*2+finger))
        else if Status(hheadcamera)==3 then
          l.headcameras=l.headcameras|(1<<(rail*2+finger))
          $int4(lx+432)=$int4(lx+432) & (~(1<<(rail*2+finger)))
          hdopt=hdopt | HO_HIRES
        else if Status(hheadcamera)==4 then
          l.headcameras=l.headcameras|(1<<(rail*2+finger))
          $int4(lx+432)=$int4(lx+432)|(1<<(rail*2+finger))
          hdopt=hdopt | HO_HIRES
        else if Status(hheadcamera)==5 then
          l.headcameras=l.headcameras & (~(1<<(rail*2+finger)))
          $int4(lx+432)=$int4(lx+432) & (~(1<<(rail*2+finger)))
          hdopt=hdopt | HO_CAMOFF
        else if Status(hheadcamera)==6 then
          l.headcameras=l.headcameras & (~(1<<(rail*2+finger)))
          $int4(lx+432)=$int4(lx+432) & (~(1<<(rail*2+finger)))
          hdopt=hdopt | (HO_CAMOFF|HO_HIRES)
        endif
        $char(lx+736+rail*2+finger)=hdopt
        redraw=1
      else if Pressed(hcangle) || Pressed(hxshift) then
        redraw=1
      else if Pressed(hshuttlel) then
        scanshift=Max(-100,scanshift-5)
        redraw=1
      else if Pressed(hshuttler) then
        scanshift=Min(100,scanshift+5)
        redraw=1
      else if Pressed(hleft) then
        i=(Status(hleft)+1)*step
        if finger==0 then l.leftzerox[rail]=l.leftzerox[rail]-i;
        else l.rightzerox[rail]=l.rightzerox[rail]-i; endif
        move=1; reoffs=1
      else if Pressed(hright) then
        i=(Status(hright)+1)*step
        if finger==0 then l.leftzerox[rail]=l.leftzerox[rail]+i;
        else l.rightzerox[rail]=l.rightzerox[rail]+i; endif
        move=1; reoffs=1
      else if Pressed(hup) then
        i=(Status(hup)+1)*step
        if finger==0 then l.leftzeroy[rail]=l.leftzeroy[rail]+i;
        else l.rightzeroy[rail]=l.rightzeroy[rail]+i; endif
        move=1; reoffs=1
      else if Pressed(hdown) then
        i=(Status(hdown)+1)*step
        if finger==0 then l.leftzeroy[rail]=l.leftzeroy[rail]-i;
        else l.rightzeroy[rail]=l.rightzeroy[rail]-i; endif
        move=1; reoffs=1
      else if Pressed(hshow) then
        move=1; reoffs=1
      else if Pressed(hsetdef) then
        deftester=Status(hdeftester)
        Presetgeometry(deftester)
        redraw=1; videochanged=1
      else if Pressed(hleftlimit) || Pressed(hrightlimit) ||                   \
        Pressed(hcenterx) || Pressed(hvideodead) || Pressed(hdeadsplit) ||     \
        Pressed(hradius) || Pressed(hcamradius) || Pressed(hyshift) then
        redraw=1
      else if Pressed(htouch) then
        touchmode=Status(htouch)
      else if Pressed(hviewfing) then
        viewfing=Status(hviewfing)
        videochanged=1
      else if Pressed(hbrightness) then
        videochanged=1
      else if Pressed(hcontrast) then
        videochanged=1
      else if Pressed(hmirror) then
        mirror=Status(hmirror)
        videochanged=1
      else if Pressed(hzoom) then
        videochanged=1
      endif
      if reoffs!=0 && hxshift!=NULL then
        if finger==0 then
          enable hxshift
          change hxshift text=format("%.3f",l.leftzerox[rail]/1000.0)
          enable hyshift
          change hyshift text=format("%.3f",l.leftzeroy[rail]/1000.0)
        else
          enable hxshift
          change hxshift text=format("%.3f",l.rightzerox[rail]/1000.0)
          enable hyshift
          change hyshift text=format("%.3f",l.rightzeroy[rail]/1000.0)
        endif
        reoffs=0
      endif
      if videochanged!=0 then
        if rail==l.nfing && showshuttle==0 then
          videoside=finger; videoon=1
        else
          if l.cameras!=0 then
            videoside=(l.side[rail]==0?1:0)
          else
            videoside=l.side[rail]
          endif
          videoon=(viewfing!=0 && showshuttle==0)
        endif
        channel=Channelfromhead(rail*2+finger)
        if channel<0 videoon=0
        if videoon==0 then
          zoom=(Status(hzoom)==0?0.5:1.0)
          SYS.Videoex(hviewer,channel,videoside==0?0:mirror,                   \
          zoom,Status(hbrightness),Status(hcontrast),0)
        else
          videox=768; videoy=576       // Safe defaults
          SYS.Videosize(channel,&videox,&videoy,&dummy)
          if videox==0 || videoy==0 then
            zoom=1.0
          else if l.cameras!=0 then
            zoom=Max((VIX+2.0)/videox,(VIY+2.0)/videoy)
          else
            zoom=Min((VIX+2.0)/videox,(VIY+2.0)/videoy)
          endif
          if Status(hzoom)!=0 zoom=zoom*2.0
          draw window=hviewer
          draw color=VIDEOFILL bkcolor=VIDEOFILL
          draw at 0,0 fillrect VIX,VIY
          draw color=LIGHTRED font=SMALLFONT mode=M_CENTERED
          if l.cameras!=0 then
            draw at VIX/2-50,VIY/2 to VIX/2-4,VIY/2
            draw at VIX/2,VIY/2-50 to VIX/2,VIY/2-4
            draw at VIX/2+5,VIY/2 to VIX/2+51,VIY/2
            draw at VIX/2,VIY/2+5 to VIX/2,VIY/2+51
          else if l.headcameras!=0 then
            draw color=STRANGE bkcolor=STRANGE
            if (VIX-videox*zoom)/2+1>0 then
              draw at 0,0 fillrect (VIX-videox*zoom)/2+1,VIY; endif
            if (VIX+videox*zoom)/2<VIX then
              draw at (VIX+videox*zoom)/2,0 fillrect VIX,VIY; endif
            if (VIY-videoy*zoom)/2+1>0 then
              draw at 0,0 fillrect VIX,(VIY-videoy*zoom)/2+1; endif
            if (VIY+videoy*zoom)/2<VIY then
              draw at 0,(VIY+videoy*zoom)/2 fillrect VIX,VIY; endif
            draw color=YELLOW bkcolor=WHITEBLUE at 70,VIY-18 fillrect VIX-70,VIY-5
            draw color=BLACK
            draw at VIX/2,VIY-5 text="Place needle tip on the cross"
            draw color=LIGHTRED
          endif
          cx=8.0; cy=8.0               // Default video magnification
          sprintf(s,"Video scale[%i]",videoside)
          getini("System",s,"%f,%f",&cx,&cy)
          cx=0.5*512.0/cx*zoom; cy=0.5*512.0/cy*zoom;
          draw at VIX/2-cx,VIY/2-cy
          draw to VIX/2+cx,VIY/2-cy
          draw to VIX/2+cx,VIY/2+cy
          draw to VIX/2-cx,VIY/2+cy
          draw to VIX/2-cx,VIY/2-cy
          draw at VIX/2+1,VIY/2-cy text="1x1 mm"
          SYS.Videoangle(hviewer,channel,videoside==0?0:mirror,                \
            zoom,Status(hbrightness),Status(hcontrast),2,0.0)
          draw show
        endif
        videochanged=0
      endif
      if move!=0 && pending==0 && $GLOBAL.headloaded>=0 then
        for i=0,i<l.nfing*2+2 && i<32,i++
          if i==rail*2+finger then     // Move finger or camera to point
            if finger==0 then
              x=l.xoffset+l.leftzerox[rail]-$LAYCORR.leftzerox[rail]
              y=l.yoffset[rail]+l.leftzeroy[rail]-$LAYCORR.leftzeroy[rail]
            else
              x=l.xoffset+l.rightzerox[rail]-$LAYCORR.rightzerox[rail]
              y=l.yoffset[rail]+l.rightzeroy[rail]-$LAYCORR.rightzeroy[rail]
            endif
            x=x+scanshift*1000
            if rail<l.nfing && x>l.leftlimit+10000 && x<l.rightlimit-10000 &&  \
              y>l.bottom[rail]+5000 && y<l.top[rail]-5000                      \
            then
              n=sprintf(s,"M %i(%.3f,%.3fH10) ",i,x/1000.0,y/1000.0)
              if touchmode==1 then
                sprintf(s+n,"Z(%i)",i)
              else if touchmode==2 then
                sprintf(s+n,"R(%i,32)",i)
              else if touchmode==3 then
                sprintf(s+n,"UC(%i,32,CO)",i)
              else
                sprintf(s+n,"NOP")
              endif
              pending=SERV.Cmdimm(0,s)
              infield[i]=1
              if viewfing!=0 then      // Move opposite camera to view finger
                k=(l.side[rail]==0)
                if (l.cameras & (0x1<<k))!=0 then
                  if k==0 then
                    x=l.xoffset+l.leftzerox[l.nfing]-                          \
                    $LAYCORR.leftzerox[l.nfing]
                    y=l.yoffset[rail]+l.leftzeroy[l.nfing]-                    \
                    $LAYCORR.leftzeroy[l.nfing]
                  else
                    x=l.xoffset+l.rightzerox[l.nfing]-                         \
                    $LAYCORR.rightzerox[l.nfing]
                    y=l.yoffset[rail]+l.rightzeroy[l.nfing]-                   \
                    $LAYCORR.rightzeroy[l.nfing]
                  endif
                  sprintf(s,"M %i(%.3f,%.3f) N",l.nfing*2+k,x/1000.0,y/1000.0)
                  SERV.Cmdimm(1,s)
                endif
              endif
            else if rail==l.nfing && (l.cameras & (0x1<<finger))!=0 &&         \
              x>l.leftlimit+l.videodeadx+10000 &&                              \
              x<l.rightlimit-l.videodeadx-10000 &&                             \
              y>l.bottom[rail]+10000 && y<l.top[rail]-10000 then
              sprintf(s,"M %i(%.3f,%.3f) N",i,x/1000.0,y/1000.0)
              pending=SERV.Cmdimm(0,s)
            endif
          else if rail<l.nfing && infield[i]!=0 then
            sprintf(s,"M %i(Z) N",i)   // Move finger into the home position
            SERV.Cmdimm(1,s)
            infield[i]=0
          endif
        enddo
        move=0
      endif
      if pending>0 then
        if $A[0].length>0 pending=0
      endif
    else if selection==2 then          // Thermical parameters
      Getthermal()
      if Pressed(hsetcurdate) then
        Strtime(s,"%d,%m,%Y",0,0)
        sscanf(s,"%i,%i,%i",&i,&j,&k)
        l.caldate=(i+j*32+(k-1980)*512) & 0xFFFF
        redraw=1
      else if Pressed(hsetcadjdate) then
        Strtime(s,"%d,%m,%Y",0,0)
        sscanf(s,"%i,%i,%i",&i,&j,&k)
        $uint2(lx+586)=(i+j*32+(k-1980)*512) & 0xFFFF
        redraw=1
      else if Pressed(htmeason) then
        if Status(htmeason)==0 then
          $int4(lx+496)=$int4(lx+496) | HCM_TMEASOFF
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_TMEASOFF)
        endif
        redraw=1
      else if Pressed(hcaltemp) || Pressed(hthermexp) ||                       \
        Pressed(hpresscor) || Pressed(htemphtop) || Pressed(htemphbot) ||      \
        Pressed(htempvtop) || Pressed(htempvbot) then
        redraw=1
      else if Pressed(hchecktemp) then
        if Status(hchecktemp)!=0 then
          $int4(lx+4)=$int4(lx+4) | HCX_TSENS
        else
          $int4(lx+4)=$int4(lx+4) & (~HCX_TSENS)
        endif
        redraw=1
      else if Pressed(htfiltoff) then
        if Status(htfiltoff)==0 then
          $int4(lx+496)=$int4(lx+496) | HCM_TFILTOFF
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_TFILTOFF)
        endif
      else if Pressed(hallthon) then
        i=~((1<<(l.nfing*2))-1)
        if (l.cameras & 1)!=0 i=i ^ (1<<l.nfing*2)
        if (l.cameras & 2)!=0 i=i ^ (1<<(l.nfing*2+1))
        if i==$int4(lx+712) i=0
        $int4(lx+712)=i
        redraw=1
      else if Pressed(hallthoff) then
        $int4(lx+712)=0xFFFFFFFF
        redraw=1
      endif
      for i=0,i<128,i++ do
        if harraypos[i]==NULL break
        if Pressed(harraypos[i]) then
          k=Status(harraypos[i])-1
          if k<0 then
            j=0
          else if k==48 then
            j=0x87
          else if k==49 then
            j=0xC7
          else if k==50 then
            j=0x08
          else if k==51 then
            j=0x48
          else if k==52 then
            j=0x09
          else if k==53 then
            j=0x49
          else if k==54 then
            j=0x0A
          else if k==55 then
            j=0x0B
          else if k==56 then
            j=0x0C
          else if k==57 then
            j=0x0D
          else if k==58 then
            j=0x0E
          else if k==59 then
            j=0x0F
          else if k==60 then
            j=0x10
          else if k==61 then
            j=0x11
          else if k==62 then
            j=0x12
          else
            j=0x80+((k/3)<<3)+(k%3)*2
          endif
          if i<32 then
            $char(lx0+518+i)=j
          else
            $char(lx0+606+(i-32))=j
          endif
        endif
      enddo
      for i=0,i<32,i++ do
        if Pressed(htemphead[i]) then
          if Status(htemphead[i])!=0 then
            $int4(lx+712)=$int4(lx+712) & (~(1<<i))
          else
            $int4(lx+712)=$int4(lx+712) | (1<<i)
          endif
        endif
      enddo
    else if selection==3 then          // Measurement parameters
      Getmeas()
      for j=0,j<l.nfing,j++
        do i=0,1,1
          if Pressed(hhead[j][i]) then
            if ($int2(l+764) & (1<<rail))!=0 then
              change hhead[rail][finger] color=DARKGRAY
            else
              change hhead[rail][finger] color=BLACK
            endif
            change hhead[rail][finger] bkcolor=GRAY
            rail=j; railbtn=j; finger=i
            change hhead[rail][finger] color=LIGHTRED
            change hhead[rail][finger] bkcolor=WHITEBLUE
            redraw=1
          endif
        enddo
      enddo
      if Pressed(hdefaults) then
        Setmeasdefaults(); redraw=1
      endif
      for i=0,i<9,i++
        if Pressed(hcurrent[i]) redraw=1
      enddo
      for i=0,i<6,i++
        if Pressed(hvoltage[i]) redraw=1
      enddo
      if Pressed(hr100k) || Pressed(hrzero) || Pressed(hkelvzero) redraw=1
      if Pressed(hlzero) || Pressed(hlrshift) || Pressed(hlphase0) redraw=1
      if Pressed(hlphase1) || Pressed(hlfreq) || Pressed(hlaadj) redraw=1
      if Pressed(hlapower) || Pressed(hvmax) || Pressed(hfrequency) redraw=1
      if Pressed(hclowest) || Pressed(hradj) || Pressed(hrneedle) redraw=1
      if Pressed(hsinadj) || Pressed(hcosadj) || Pressed(hcphadj) redraw=1
      if Pressed(hpfactor) || Pressed(hcrtadj) || Pressed(hpcorr) redraw=1
      if Pressed(hcrtumax) redraw=1
    else if selection==4 then          // A5 measurement options
      extant=$int4(lx+336)
      if Pressed(hparcont) then
        if Status(hparcont)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_PARCONT
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_PARCONT)
        endif
      else if Pressed(h1mahv) then
        if Status(h1mahv)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_HV1MA
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_HV1MA)
        endif
      else if Pressed(hnoaccel) then
        if Status(hnoaccel)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_NOACCEL
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_NOACCEL)
        endif
      else if Pressed(hstrict) then
        if Status(hstrict)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_STRICT
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_STRICT)
        endif
      else if Pressed(hdisconn) then
        if Status(hdisconn)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_DISCONN
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_DISCONN)
        endif
      else if Pressed(hnocont) then
        if Status(hnocont)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_NOCTCHK
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_NOCTCHK)
        endif
      else if Pressed(hcontair) then
        if Status(hcontair)!=0 then
          lx.extcfg=lx.extcfg | EXT_CONTAIR
        else
          lx.extcfg=lx.extcfg & (~EXT_CONTAIR)
        endif
      else if Pressed(hcair) then
        if Status(hcair)!=0 then
          lx.extcfg=lx.extcfg | EXT_CAIR
        else
          lx.extcfg=lx.extcfg & (~EXT_CAIR)
        endif
      else if Pressed(hcrtair) then
        if Status(hcrtair)!=0 then
          lx.extcfg=lx.extcfg | EXT_CRTAIR
        else
          lx.extcfg=lx.extcfg & (~EXT_CRTAIR)
        endif
      else if Pressed(hcshuttle) then
        if Status(hcshuttle)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_CTOEXT
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_CTOEXT)
        endif
      else if Pressed(hcfilter) then
        if Status(hcfilter)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_FILTERC
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_FILTERC)
        endif
      else if Pressed(hlapar) then
        if Status(hlapar)!=0 then
          lx.extcfg=lx.extcfg | EXT_LAPAR
        else
          lx.extcfg=lx.extcfg & (~EXT_LAPAR)
        endif
      else if Pressed(hexactrpar) then
        if Status(hexactrpar)!=0 then
          lx.extcfg=lx.extcfg | EXT_EPAR
        else
          lx.extcfg=lx.extcfg & (~EXT_EPAR)
        endif
      else if Pressed(hexrlong) then
        if Status(hexrlong)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_EXRLONG
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_EXRLONG)
        endif
      else if Pressed(hexrnoisy) then
        if Status(hexrnoisy)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_EXRNOISY
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_EXRNOISY)
        endif
      else if Pressed(hkelvcons) then
        if Status(hkelvcons)==0 then
          $int4(lx+496)=($int4(lx+496) & (~HCM_CONSMASK)) | HCM_CSNONE
        else if Status(hkelvcons)==1 then
          $int4(lx+496)=($int4(lx+496) & (~HCM_CONSMASK)) | HCM_CSLOW
        else if Status(hkelvcons)==2 then
          $int4(lx+496)=($int4(lx+496) & (~HCM_CONSMASK)) | HCM_CSMED
        else
          $int4(lx+496)=($int4(lx+496) & (~HCM_CONSMASK)) | HCM_CSHIGH
        endif
      else if Pressed(hhvpar) then
        if Status(hhvpar)==0 then
          lx.extcfg=(lx.extcfg & (~EXT_HVPARMASK)) | EXT_HVGROUP
        else if Status(hhvpar)==1 then
          lx.extcfg=(lx.extcfg & (~EXT_HVPARMASK)) | EXT_HVPARAL
        else if Status(hhvpar)==2 then
          lx.extcfg=(lx.extcfg & (~EXT_HVPARMASK)) | EXT_HVNOPAR
        else
          lx.extcfg=(lx.extcfg & (~EXT_HVPARMASK)) | EXT_HVPANEL
        endif
      else if Pressed(hcrtpar) then
        if Status(hcrtpar)==0 then
          lx.extcfg=(lx.extcfg & (~EXT_CRTPMASK)) | EXT_CRTGRP
        else if Status(hcrtpar)==1 then
          lx.extcfg=(lx.extcfg & (~EXT_CRTPMASK)) | EXT_CRTPAR
        else if Status(hcrtpar)==2 then
          lx.extcfg=(lx.extcfg & (~EXT_CRTPMASK)) | EXT_CRTNOP
        else
          lx.extcfg=(lx.extcfg & (~EXT_CRTPMASK)) | EXT_CRTPNL
        endif
      else if Pressed(hextant1) then
        if Status(hextant1)!=0 then
          extant=extant|1
          enable hautoeant
        else
          extant=extant & 0xFFFFFFFE
          disable hautoeant
        endif
      else if Pressed(hextant2) then
        if Status(hextant2)!=0 then
          extant=extant|2
        else
          extant=extant & 0xFFFFFFFD
        endif
      else if Pressed(hisoeant) then
        if Status(hisoeant)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_ISOEANT
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_ISOEANT)
        endif
      else if Pressed(hautoeant) then
        if Status(hautoeant)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_AUTOEANT
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_AUTOEANT)
        endif
      else if Pressed(hfilter) then
        if Status(hfilter)==1 then
          $int4(lx+496)=($int4(lx+496) & (~HCM_FILTMASK)) | HCM_F500K
        else if Status(hfilter)==2 then
          $int4(lx+496)=($int4(lx+496) & (~HCM_FILTMASK)) | HCM_F100K
        else if Status(hfilter)==3 then
          $int4(lx+496)=($int4(lx+496) & (~HCM_FILTMASK)) | HCM_F20K
        else
          $int4(lx+496)=($int4(lx+496) & (~HCM_FILTMASK)) | HCM_FNONE
        endif
      else if Pressed(hmuxtype) then
        i=$int4(lx+674) & (~(MUX_TYPEMASK|MUX_MODCOUNT))
        if Status(hmuxtype)==1 then
          $int4(lx+674)=i | MUX_TYPE506 | 0x01000000
        else if Status(hmuxtype)==2 then
          $int4(lx+674)=i | MUX_TYPE506 | 0x02000000
        else if Status(hmuxtype)==3 then
          $int4(lx+674)=i | MUX_TYPE506 | 0x03000000
        else
          $int4(lx+674)=i | MUX_TYPE406
        endif
        if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE406 then
          disable hmuxaux[0]
          disable hmuxaux[1]
        else
          enable hmuxaux[0]
          enable hmuxaux[1]
        endif
        if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE406 ||                      \
          (($int4(lx+674)>>24) & 0x3)<=1 then
          disable hmuxaux[2]
          disable hmuxaux[3]
        else
          enable hmuxaux[2]
          enable hmuxaux[3]
        endif
        if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE406 ||                      \
          (($int4(lx+674)>>24) & 0x3)<=2 then
          disable hmuxaux[4]
          disable hmuxaux[5]
        else
          enable hmuxaux[4]
          enable hmuxaux[5]
        endif
        Setsubstnames()
      endif
      for i=0,i<6,i++ do
        if Pressed(hmuxaux[i]) then
          $int4(lx+674)=$int4(lx+674) & (~(0x7<<(3*i)))
          $int4(lx+674)=$int4(lx+674) | (Status(hmuxaux[i])<<(3*i))
          Checkmuxoutputs()
        endif
      enddo
      for i=0,i<4,i++ do
        subst=$int2(lx+488+2*i)
        if Pressed(hsubston[i]) then
          if Status(hsubston[i])!=0 then
            enable hsubsthead[i]
            change hsubsthead[i] select=subst & 0x001F
            enable hsubstpos[i]
            change hsubstpos[i] select=(subst>>8) & 0x001F
            $int2(lx+488+2*i)=subst | 0x8000
          else
            disable hsubsthead[i]
            disable hsubstpos[i]
            $int2(lx+488+2*i)=subst & 0x7FFF
          endif
        else if Pressed(hsubsthead[i]) then
          $int2(lx+488+2*i)=(subst & 0xFFE0) | Status(hsubsthead[i])
        else if Pressed(hsubstpos[i]) then
          $int2(lx+488+2*i)=(subst & 0xE0FF) | (Status(hsubstpos[i])<<8)
        endif
      enddo
      $int4(lx+336)=extant
    else if selection==5 then          // DSP measurements config 2
      Getmeas2()
      for j=0,j<l.nfing,j++
        do i=0,1,1
          if Pressed(hhead[j][i]) then
            if ($int2(l+764) & (1<<rail))!=0 then
              change hhead[rail][finger] color=DARKGRAY
            else
              change hhead[rail][finger] color=BLACK
            endif
            change hhead[rail][finger] bkcolor=GRAY
            rail=j; railbtn=j; finger=i
            change hhead[rail][finger] color=LIGHTRED
            change hhead[rail][finger] bkcolor=WHITEBLUE
            redraw=1
          endif
        enddo
      enddo
      if Pressed(huin) || Pressed(hfphcorr) || Pressed(hfccorr) then
        redraw=1
      else if Pressed(husetd) then
        if Status(husetd)!=0 then
          lx.extcfg=lx.extcfg | EXT_3DCOR
        else
          lx.extcfg=lx.extcfg & (~EXT_3DCOR)
        endif
        redraw=1
      else if Pressed(h3dxy) || Pressed(h3dyy) || Pressed(h3dxz) ||            \
        Pressed(h3dyz) then
        redraw=1
      else if Pressed(hextdev0) then
        $uint2(lx+468)=Status(hextdev0)
        if $uint2(lx+468)==EXTD_NONE then
          disable hcal0
          disable hsubstr0
          disable hsubstc0
          disable hsubstl0
        else
          enable hcal0
          enable hsubstr0
          enable hsubstc0
          enable hsubstl0
        endif
      else if Pressed(hcal0) then
        if Status(hcal0)!=0 then
          $int2(lx+464)=$int2(lx+464) | EXTS_CAL
        else
          $int2(lx+464)=$int2(lx+464) & (~EXTS_CAL)
        endif
      else if Pressed(hsubstr0) then
        if Status(hsubstr0)!=0 then
          $int2(lx+464)=$int2(lx+464) | EXTS_EXACTR
        else
          $int2(lx+464)=$int2(lx+464) & (~EXTS_EXACTR)
        endif
      else if Pressed(hsubstc0) then
        if Status(hsubstc0)!=0 then
          $int2(lx+464)=$int2(lx+464) | EXTS_UNIC
        else
          $int2(lx+464)=$int2(lx+464) & (~EXTS_UNIC)
        endif
      else if Pressed(hsubstl0) then
        if Status(hsubstl0)!=0 then
          $int2(lx+464)=$int2(lx+464) | EXTS_RLMEAS
        else
          $int2(lx+464)=$int2(lx+464) & (~EXTS_RLMEAS)
        endif
      else if Pressed(hextdev1) then
        $uint2(lx+470)=Status(hextdev1)
        if $uint2(lx+470)==EXTD_NONE then
          disable hcal1
          disable hsubstr1
          disable hsubstc1
          disable hsubstl1
        else
          enable hcal1
          enable hsubstr1
          enable hsubstc1
          enable hsubstl1
        endif
      else if Pressed(hcal1) then
        if Status(hcal1)!=0 then
          $int2(lx+466)=$int2(lx+466) | EXTS_CAL
        else
          $int2(lx+466)=$int2(lx+466) & (~EXTS_CAL)
        endif
      else if Pressed(hsubstr1) then
        if Status(hsubstr1)!=0 then
          $int2(lx+466)=$int2(lx+466) | EXTS_EXACTR
        else
          $int2(lx+466)=$int2(lx+466) & (~EXTS_EXACTR)
        endif
      else if Pressed(hsubstc1) then
        if Status(hsubstc1)!=0 then
          $int2(lx+466)=$int2(lx+466) | EXTS_UNIC
        else
          $int2(lx+466)=$int2(lx+466) & (~EXTS_UNIC)
        endif
      else if Pressed(hsubstl1) then
        if Status(hsubstl1)!=0 then
          $int2(lx+466)=$int2(lx+466) | EXTS_RLMEAS
        else
          $int2(lx+466)=$int2(lx+466) & (~EXTS_RLMEAS)
        endif
      else if Pressed(hconnpreset) then
        cptype=Status(hcptype)
        if cptype==1 then              // EL505
          $int4(lx0+558+0)=0x040003E8
          $int4(lx0+558+4)=0x22000064
          $int4(lx0+558+8)=0x22000000
          $int4(lx0+558+12)=0x03000030
        else if cptype==2 then         // EL508-1
          $int4(lx0+558+0)=0
          $int4(lx0+558+4)=0
          $int4(lx0+558+8)=0x05000064
          $int4(lx0+558+12)=0x06000000
        else
          $int4(lx0+558+0)=0
          $int4(lx0+558+4)=0
          $int4(lx0+558+8)=0
          $int4(lx0+558+12)=0
        endif
        redraw=1
      else
        for i=0,i<4,i++ do
          if Pressed(hconntype[i]) then
            k=Status(hconntype[i])
            $int4(lx0+558+i*4)=($int4(lx0+558+i*4) & 0xE0FFFFFF) | (k<<24)
            if k==0 then
              disable huout[i]
              disable hconnvalue[i]
            else
              enable huout[i]
              enable hconnvalue[i]
            endif
          else if Pressed(huout[i]) then
            k=Status(huout[i])
            $int4(lx0+558+i*4)=($int4(lx0+558+i*4) & 0x1FFFFFFF) | (k<<29)
          endif
          Text(hconnvalue[i],s); temp=0.0
          sscanf(s,"%g",&temp)
          if temp>=0 && temp<=0x00FFFFFF then
            k=temp; k=Max(0,Min(k,0x00FFFFFF))
            $int4(lx0+558+i*4)=($int4(lx0+558+i*4) & 0xFF000000) | k
          endif
        enddo
      endif
    else if selection==6 then          // A5 stuff
      Text(htcpaddr0,s); i=0; j=0; k=0; m=0;
      sscanf(s,"%i.%i.%i.%i",&i,&j,&k,&m);
      $uint1(lx+691)=i; $uint1(lx+690)=j; $uint1(lx+689)=k; $uint1(lx+688)=m
      Text(htcpport0,s); i=0; sscanf(s,"%i",&i); $uint2(lx+692)=i
      Text(htcpaddr1,s); i=0; j=0; k=0; m=0;
      sscanf(s,"%i.%i.%i.%i",&i,&j,&k,&m);
      $uint1(lx+697)=i; $uint1(lx+696)=j; $uint1(lx+695)=k; $uint1(lx+694)=m
      Text(htcpport1,s); i=0; sscanf(s,"%i",&i); $uint2(lx+698)=i
      zheadtype=lx.zheadtype
      zheadbot=$int4(lx+460)
      if Pressed(husezparm) then
        $int4(lx+8)=0                  // Invalidate Y type
        if (Status(husezparm)==0) then zheadtype=zheadtype & (~HCZ_VALID);
        else zheadtype=zheadtype | HCZ_VALID; endif
        if (zheadtype & HCZ_VALID)==0 then
          disable hactuator
          disable hneedle
          disable hstroke
          disable hsensor
          disable hdiffbot
          disable hselectbottom
          disable hneedlebot
          disable hsensorbot
          disable hpreload
        else
          enable hactuator
          enable hneedle
          enable hstroke
          enable hsensor
          enable hdiffbot
          if (zheadbot & HCZ_VALID)==0 then
            disable hselectbottom
            disable hneedlebot
            disable hsensorbot
          else
            enable hselectbottom
            enable hneedlebot
            enable hsensorbot
          endif
          enable hpreload
        endif
      else if Pressed(hselectneedle) then
        if selectneedle==0 then
          change hselectneedle bkcolor=LIGHTYELLOW
          change hselectneedle text="设置针头 <-"
          change hselectbottom bkcolor=WHITEGREEN
          change hselectbottom text="设置背面 ->"
          change hconfig position=2000,0,344+XC1,423
          Createneedleselect(1)
          selectneedle=1
        else if selectneedle==1 then
          change hselectneedle bkcolor=WHITEGREEN
          change hselectneedle text="设置针头 ->"
          change hselectbottom bkcolor=WHITEGREEN
          change hselectbottom text="设置背面 ->"
          destroy hneedlesel
          change hconfig position=XX1-1,-1,344+XC1,423
          selectneedle=0
        endif
      else if Pressed(hactuator) then
        $int4(lx+8)=0                  // Invalidate Y type
        zheadtype=zheadtype & (~HCZ_TYPEMASK)
        if Status(hactuator)==0 then
          zheadtype=zheadtype | HCZ_TYPEA3
        else if Status(hactuator)==1 then
          zheadtype=zheadtype | HCZ_TYPEA2G
        else if Status(hactuator)==2 then
          zheadtype=zheadtype | HCZ_TYPECER
        else if Status(hactuator)==3 then
          zheadtype=zheadtype | HCZ_TYPELIN
        else if Status(hactuator)==4 then
          zheadtype=zheadtype | HCZ_TYPENO
        endif
      else if Pressed(hstroke) then
        zheadtype=zheadtype & (~HCZ_STRMASK)
        if Status(hstroke)==1 then
          zheadtype=zheadtype | HCZ_STRSOFT
        else if Status(hstroke)==2 then
          zheadtype=zheadtype | HCZ_STRHARD
        else if Status(hstroke)==3 then
          zheadtype=zheadtype | HCZ_LEARNZ
        else if Status(hstroke)==4 then
          zheadtype=zheadtype | HCZ_HIPRESS
        else
          zheadtype=zheadtype | HCZ_STRNORM
        endif
      else if Pressed(hneedle) then
        zheadtype=zheadtype & (~HCZ_XCONTMASK)
        if Status(hneedle)==0 then
          zheadtype=zheadtype | HCZ_CONTDEF
        else if Status(hneedle)==1 then
          zheadtype=zheadtype | HCZ_CONTSTD
        else if Status(hneedle)==2 then
          zheadtype=zheadtype | HCZ_CONTSPL
        else if Status(hneedle)==3 then
          zheadtype=zheadtype | HCZ_CONTSPL|HCZ_SPLK4
        else if Status(hneedle)==4 then
          zheadtype=zheadtype | HCZ_CONTHSPL
        else if Status(hneedle)==5 then
          zheadtype=zheadtype | HCZ_CONTEMU
        else if Status(hneedle)==6 then
          zheadtype=zheadtype | HCZ_CONTSKP
        else if Status(hneedle)==7 then
          zheadtype=zheadtype | HCZ_CONTHPS
        endif
      else if Pressed(hsensor) then
        zheadtype=zheadtype & (~HCZ_DMSMASK)
        if Status(hsensor)==1 then
          zheadtype=zheadtype | HCZ_DMSREV
        else if Status(hsensor)==2 then
          zheadtype=zheadtype | HCZ_DMSAUTO
        else
          zheadtype=zheadtype | HCZ_DMSSTD
        endif
      else if Pressed(hdiffbot) then
        if (Status(hdiffbot)==0) then
          zheadbot=zheadbot & (~HCZ_VALID)
        else
          zheadbot=zheadbot | HCZ_VALID
        endif
        if (zheadtype & zheadbot & HCZ_VALID)==0 then
          disable hselectbottom
          disable hneedlebot
          disable hsensorbot
        else
          enable hselectbottom
          enable hneedlebot
          enable hsensorbot
        endif
      else if Pressed(hselectbottom) then
        if selectneedle==0 then
          change hselectbottom bkcolor=LIGHTYELLOW
          change hselectbottom text="设置背面 <-"
          change hselectneedle bkcolor=WHITEGREEN
          change hselectneedle text="设置针头 ->"
          change hconfig position=2000,0,344+XC1,423
          Createneedleselect(2)
          selectneedle=2
        else if selectneedle==2 then
          change hselectbottom bkcolor=WHITEGREEN
          change hselectbottom text="设置背面 ->"
          change hselectneedle bkcolor=WHITEGREEN
          change hselectneedle text="设置针头 ->"
          destroy hneedlesel
          change hconfig position=XX1-1,-1,344+XC1,423
          selectneedle=0
        endif
      else if Pressed(hneedlebot) then
        zheadbot=zheadbot & (~HCZ_XCONTMASK)
        if Status(hneedlebot)==0 then
          zheadbot=zheadbot | HCZ_CONTDEF
        else if Status(hneedlebot)==1 then
          zheadbot=zheadbot | HCZ_CONTSTD
        else if Status(hneedlebot)==2 then
          zheadbot=zheadbot | HCZ_CONTSPL
        else if Status(hneedlebot)==3 then
          zheadbot=zheadbot | HCZ_CONTSPL|HCZ_SPLK4
        else if Status(hneedlebot)==4 then
          zheadbot=zheadbot | HCZ_CONTHSPL
        else if Status(hneedlebot)==5 then
          zheadbot=zheadbot | HCZ_CONTEMU
        else if Status(hneedlebot)==6 then
          zheadbot=zheadbot | HCZ_CONTSKP
        else if Status(hneedlebot)==7 then
          zheadbot=zheadbot | HCZ_CONTHPS
        endif
      else if Pressed(hsensorbot) then
        zheadbot=zheadbot & (~HCZ_DMSMASK)
        if Status(hsensorbot)==1 then
          zheadbot=zheadbot | HCZ_DMSREV
        else if Status(hsensorbot)==2 then
          zheadbot=zheadbot | HCZ_DMSAUTO
        else
          zheadbot=zheadbot | HCZ_DMSSTD
        endif
      else if Pressed(hpreload) then
        if Status(hpreload)!=0 then
          zheadtype=zheadtype | HCZ_TESTPRLD
        else
          zheadtype=zheadtype & (~HCZ_TESTPRLD)
        endif
      else if Pressed(hnozlim) then
        if Status(hnozlim)!=0 then
          lx.extcfg=lx.extcfg | EXT_NOZLIMIT
        else
          lx.extcfg=lx.extcfg & (~EXT_NOZLIMIT)
        endif
      else if Pressed(hxdriver) then
        $int4(lx+4)=$int4(lx+4) & (~HCX_TYPEMINOR)
        i=Status(hxdriver)
        if i==1 then
          $int4(lx+4)=$int4(lx+4) | HCX_HIPOW
        else
          $int4(lx+4)=$int4(lx+4) | HCX_STDPOW
        endif
      else if Pressed(hxstep) then
        $int4(lx+4)=$int4(lx+4) & (~HCX_ENCTYPE)
        i=Status(hxstep)
        if i==1 then
          $int4(lx+4)=$int4(lx+4) | HCX_ENCOPEN
        else if i==2 then
          $int4(lx+4)=$int4(lx+4) | HCX_ENCAUTO
        else
          $int4(lx+4)=$int4(lx+4) | HCX_ENCDEF
        endif
      else if Pressed(hlimitx) then
        if Status(hlimitx)!=0 then
          $int4(lx+4)=$int4(lx+4) | HCX_POWERLIM
        else
          $int4(lx+4)=$int4(lx+4) & (~HCX_POWERLIM)
        endif
      else if Pressed(hyshmotor) then
        $int4(lx+504)=$int4(lx+504) & (~HCS_YMASK)
        i=Status(hyshmotor)
        if i==1 then
          $int4(lx+504)=$int4(lx+504) | HCS_YMDBL
        else
          $int4(lx+504)=$int4(lx+504) | HCS_YMDEF
        endif
      else if Pressed(hprinter) then
        $int4(lx+512)=($int4(lx+512) & (~HCA_LABEL)) | (Status(hprinter)<<8)
      else if Pressed(hprintprot) then
        if Status(hprintprot)!=0 then
          $int4(lx+682)=$int4(lx+682) | DBO_DUMPLABEL
        else
          $int4(lx+682)=$int4(lx+682) & (~DBO_DUMPLABEL)
        endif
      else if Pressed(hscaner0) then
        $int4(lx+512)=($int4(lx+512) & (~HCA_BAR0)) | Status(hscaner0)
      else if Pressed(hscaner1) then
        $int4(lx+512)=($int4(lx+512) & (~HCA_BAR1)) | (Status(hscaner1)<<4)
      else if Pressed(hserdev0) then
        $int4(lx+512)=($int4(lx+512) & (~HCA_EXTDEV0)) | (Status(hserdev0)<<12)
      else if Pressed(hserdev1) then
        $int4(lx+512)=($int4(lx+512) & (~HCA_EXTDEV1)) | (Status(hserdev1)<<24)
      else if Pressed(htarray) then
        i=Status(htarray)
        $int4(lx+512)=($int4(lx+512) & (~HCA_TARRAY)) | (i<<28)
        if i==0 then
          disable htatype
        else
          enable htatype
        endif
      else if Pressed(htatype) then
        $int4(lx+512)=($int4(lx+512) & (~HCA_TAMASK)) | (Status(htatype)<<22)
      else if Pressed(hillum) then
        $int1(lx+449)=Status(hillum)
      else if Pressed(hbritop) then
        $uint1(lx+680)=Status(hbritop)*10+20
      else if Pressed(hbriskew) then
        $uint1(lx+681)=Status(hbriskew)*10+20
      else if Pressed(hignorebcode) then
        if Status(hignorebcode)!=0 then
          $int4(lx+512)=$int4(lx+512) | HCA_NOBARCODE
        else
          $int4(lx+512)=$int4(lx+512) & (~HCA_NOBARCODE)
        endif
      else if Pressed(hbargood) then
        if Status(hbargood)!=0 then
          $int4(lx+512)=$int4(lx+512) | HCA_BARGOOD
        else
          $int4(lx+512)=$int4(lx+512) & (~HCA_BARGOOD)
        endif
      endif
      lx.zheadtype=zheadtype
      $int4(lx+460)=zheadbot
      if selectneedle then
        // Check for mouse actions.
        if Mousexy(hneedleband,&x,&y,&buttons)==1 then
          x=x+Limit2(hneedleband)
          if y>=NEEDLEBY && y<NEEDLEY+NEEDLEBY then
            i=(x-NEEDLEBX)/(NEEDLEX+NEEDLEBX)
            if x>=i*NEEDLEX+(i+1)*NEEDLEBX && x<(i+1)*(NEEDLEX+NEEDLEBX) then
              if (buttons & 1)!=0 && (prevbuttons & 1)==0 && i!=needlesel then
                needlesel=i
                needlescroll=needlesel*(NEEDLEX+NEEDLEBX)-                     \
                  (341+XC1-NEEDLEX)/2+NEEDLEBX
                runscroll=1
                needledraw=1
              endif
            endif
          endif
          prevbuttons=buttons
        endif
        // Redraw panel.
        if needledraw then
          draw window=hneedleband bkcolor=WHITE clear
          for i=0,i<NNEEDLE,i++ do
            for j=0,j<8 && nddata[i][j]!=' ',j++ do
              s[j]=nddata[i][j]
            enddo
            s[j]='\0'
            if i==needlesel then
              draw color=LIGHTRED bkcolor=LIGHTRED
              draw at i*NEEDLEX+(i+1)*NEEDLEBX-NEEDLEBY,0
              draw fillrect=(i+1)*(NEEDLEX+NEEDLEBX)+6,NEEDLEY+2*NEEDLEBY
            endif
            draw at i*NEEDLEX+(i+1)*NEEDLEBX,NEEDLEBY
            draw bitmap=0,0,0,s
            j=(nddata[i,9]-'0')*100+(nddata[i,10]-'0')*10+(nddata[i,11]-'0')
            draw color=YELLOW font=MAINFONT mode=M_LEFT
            draw at i*NEEDLEX+(i+1)*NEEDLEBX+8,NEEDLEBY+20
            draw text=format("[%i]",j)
            change hneedlename text=nddata[needlesel]+41
            if nddata[needlesel,13]=='N' then
              change hneedlesens text="无"
            else if nddata[needlesel,13]=='D' then
              change hneedlesens text="透射式"
            else if nddata[needlesel,13]=='M' then
              change hneedlesens text="反射式"
            else if nddata[needlesel,13]=='I' then
              change hneedlesens text="透射式"
            else
              change hneedlesens text="Unknown"
            endif
            if nddata[needlesel,15]=='K' && nddata[needlesel,17]=='B' then
              change hneedlepins text="单针"
            else if nddata[needlesel,15]=='K' && nddata[needlesel,17]=='P' then
              change hneedlepins text="4线尖针"
            else if nddata[needlesel,15]=='S' && nddata[needlesel,17]=='B' then
              change hneedlepins text="Single blade"
            else if nddata[needlesel,15]=='S' && nddata[needlesel,17]=='P' then
              change hneedlepins text="单针"
            else
              change hneedlepins text="Unknown"
            endif
            change hneedlepart text=format("%.15s",nddata[needlesel]+25)
          enddo
          draw show
          needledraw=0
        endif
        // Scroll panel.
        if needlescroll<0 then
          needlescroll=0
        else if needlescroll>NNEEDLE*(NEEDLEX+NEEDLEBX)+NEEDLEBX-(341+XC1) then
          needlescroll=NNEEDLE*(NEEDLEX+NEEDLEBX)+NEEDLEBX-(341+XC1)
        endif
        j=needlescroll-Limit2(hneedleband)
        if j==0 then
          runscroll=0
        else if runscroll!=0 && (buttons & 1)==0 then
          j=Max(-10,Min(j,10))
          change hneedleband offset=Limit2(hneedleband)+j,0
        endif
        // Check buttons.
        if Pressed(hneedleset) then
          // Update layout.
          j=(nddata[needlesel,9]-'0')*100+(nddata[needlesel,10]-'0')*10+       \
            (nddata[needlesel,11]-'0')
          if selectneedle==2 then
            $uint2(lx+718)=j           // Bottom needle type
            zheadtype=$uint4(lx+460)
          else
            $uint2(lx+636)=j           // Top or only needle type
            zheadtype=lx.zheadtype
          endif
          if (l.config & LC_AUTOPROBE)==0 then
            if nddata[needlesel][15]=='K' then
              l.probetype=1
            else
              l.probetype=0
            endif
          endif
          if nddata[needlesel][21]>='0' && nddata[needlesel][21]<='3' then
            zheadtype=(zheadtype & (~HCZ_SUBCMASK)) |                          \
            ((nddata[needlesel][21]-'0')<<16)
          endif
          zheadtype=zheadtype & (~HCZ_CONTMASK)
          if nddata[needlesel][19]=='H' then
            zheadtype=zheadtype|HCZ_CONTSTD
          else if nddata[needlesel][19]=='A' then
            zheadtype=zheadtype|HCZ_CONTEMU
          else if nddata[needlesel][19]=='S' then
            zheadtype=zheadtype|HCZ_CONTSPL
          else if nddata[needlesel][19]=='M' then
            zheadtype=zheadtype|HCZ_CONTSKP
          else if nddata[needlesel][19]=='P' then
            zheadtype=zheadtype|HCZ_CONTHPS
          endif
          if (zheadtype & HCZ_DMSMASK)!=HCZ_DMSAUTO then
            dms=zheadtype & (~HCZ_DMSMASK)
            if nddata[needlesel][13]=='N' || nddata[needlesel][13]=='D' then
              zheadtype=dms|HCZ_DMSSTD
            else if nddata[needlesel][13]=='M' then
              zheadtype=dms|HCZ_DMSSTD
            else if nddata[needlesel][13]=='I' then
              zheadtype=dms|HCZ_DMSREV
            endif
          endif
          if selectneedle==2 then
            $uint4(lx+460)=zheadtype
          else
            lx.zheadtype=zheadtype
          endif
          redraw=1
        endif
      endif
    else                               // Experimental options
      Getspecialstuff()
      Text(hreinit,s); i=0; sscanf(s,"%i",&i)
      $uint1(lx+451)=Max(0,Min(i,255))
      Text(hdelayslow,s); i=0; j=0; sscanf(s,"%i.%i",&i,&j)
      $uint1(lx+687)=i*10+j
      zheadtype=lx.zheadtype
      if Pressed(hzaccels) then
        if $uint1(lx+686)==0 then
          $uint1(lx+686)=100
        else
          $uint1(lx+686)=Max(20,Min(100,$uint1(lx+686)+Status(hzaccels)))
        endif
        change hzaccels select=0
        redraw=1
      else if Pressed(hreduceas) then
        $uint1(lx+450)=Max(0,Min(100,$uint1(lx+450)+Status(hreduceas)))
        change hreduceas select=0
        redraw=1
      else if Pressed(hwidextop) then
        if Status(hwidextop)==0 then
          lx.extcfg=lx.extcfg & (~EXT_WIDEXTOP)
        else
          lx.extcfg=lx.extcfg | EXT_WIDEXTOP
        endif
      else if Pressed(hlimtodef) then
        if Status(hlimtodef)==0 then
          lx.extcfg=lx.extcfg & (~EXT_YTODEFBRD)
        else
          lx.extcfg=lx.extcfg | EXT_YTODEFBRD
        endif
      else if Pressed(hignorexy) then
        if Status(hignorexy)==0 then
          $int4(lx+4)=$int4(lx+4) & (~HCX_NOHOME)
        else
          $int4(lx+4)=$int4(lx+4) | HCX_NOHOME
        endif
      else if Pressed(hnoopt) then
        if Status(hnoopt)!=0 then
          zheadtype=zheadtype | HCZ_NOOPT
        else
          zheadtype=zheadtype & (~HCZ_NOOPT)
        endif
      else if Pressed(hlimitfw) then
        if Status(hlimitfw)!=0 then
          $int4(lx+500)=$int4(lx+500) | HCF_VALID
          enable hfwiso
          enable hfwasync
        else
          $int4(lx+500)=$int4(lx+500) & (~HCF_VALID)
          disable hfwiso
          disable hfwasync
        endif
      else if Pressed(hyoff) then
        lx.extcfg=lx.extcfg & (~EXT_S3YMASK)
        if Status(hyoff)==1 then
          lx.extcfg=lx.extcfg|EXT_S3YROFF
        else if Status(hyoff)==2 then
          lx.extcfg=lx.extcfg|EXT_S3YLOFF
        endif
      else if Pressed(hfwiso) then
        $int4(lx+500)=($int4(lx+500) & (~HCF_ISPEED)) | (Status(hfwiso)<<4)
      else if Pressed(hfwasync) then
        $int4(lx+500)=($int4(lx+500) & (~HCF_ASPEED)) | Status(hfwasync)
      else if Pressed(hwarmx) then
        $uint1(lx+678)=Status(hwarmx)
      else if Pressed(hwarmy) then
        $uint1(lx+679)=Status(hwarmy)
      else if Pressed(hparkz) then
        if Status(hparkz)!=0 then
          zheadtype=zheadtype | HCZ_PARKZ
        else
          zheadtype=zheadtype & (~HCZ_PARKZ)
        endif
      else if Pressed(hoptprint) then
        if Status(hoptprint)!=0 then
          $int4(lx+8)=$int4(lx+8) | HCY_MINPRINT
          disable haggressive
        else
          $int4(lx+8)=$int4(lx+8) & (~HCY_MINPRINT)
          enable haggressive
        endif
      else if Pressed(haggressive) then
        if Status(haggressive)!=0 then
          $int4(lx+4)=$int4(lx+4) | HCX_OPTWAIT
        else
          $int4(lx+4)=$int4(lx+4) & (~HCX_OPTWAIT)
        endif
      else if Pressed(hnolut) then
        if Status(hnolut)!=0 then
          lx.extcfg=lx.extcfg | EXT_NOLUT
        else
          lx.extcfg=lx.extcfg & (~EXT_NOLUT)
        endif
      else if Pressed(hcamoff) then
        if Status(hcamoff)!=0 then
          lx.extcfg=lx.extcfg | EXT_HCAMOFF
        else
          lx.extcfg=lx.extcfg & (~EXT_HCAMOFF)
        endif
      else if Pressed(hhighir) then
        if Status(hhighir)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_HIGHIR
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_HIGHIR)
        endif
      else if Pressed(hdetails) then
        if Status(hdetails)!=0 then
          $int4(lx+496)=$int4(lx+496) | HCM_DETAILS
        else
          $int4(lx+496)=$int4(lx+496) & (~HCM_DETAILS)
        endif
      else if Pressed(hresets) then
        if Status(hresets)!=0 then
          $int4(lx+682)=$int4(lx+682) | DBO_DUMPRESET
        else
          $int4(lx+682)=$int4(lx+682) & (~DBO_DUMPRESET)
        endif
      else if Pressed(hnomiss) then
        if Status(hnomiss)!=0 then
          lx.extcfg=lx.extcfg | EXT_NOMISSPCB
        else
          lx.extcfg=lx.extcfg & (~EXT_NOMISSPCB)
        endif
      else if Pressed(hshdir) then
        if Status(hshdir)!=0 then
          lx.extcfg=lx.extcfg | EXT_FIXSHDIR
        else
          lx.extcfg=lx.extcfg & (~EXT_FIXSHDIR)
        endif
      else if Pressed(hreinit) then
        if $uint1(lx+451)==0 then
          change hreinit text="无"
        else
          change hreinit text=format("%i min",$uint1(lx+451))
        endif
      endif
      lx.zheadtype=zheadtype
    endif
    newsel=Status(hcard)
    if l.nfing==0 then
      if newsel!=0 change hcard select=0
      newsel=0
    endif
    if newsel==0 && selection!=0 then
      Creategeneral()
      redraw=1; selection=0
    else if newsel==1 && selection!=1 then
      if selection==0 confirm hlayoutname
      videoon=0
      if railbtn>l.nfing railbtn=l.nfing
      Creategeometry()
      redraw=1; selection=1;
      videochanged=1; move=0
    else if newsel==2 && selection!=2 then
      if selection==0 confirm hlayoutname
      Createthermal()
      redraw=1; selection=2;
    else if newsel==3 && selection!=3 then
      if selection==0 confirm hlayoutname
      Createmeas()
      redraw=1; selection=3
    else if newsel==4 && selection!=4 then
      if selection==0 confirm hlayoutname
      Createdspmeas1()
      redraw=1; selection=4
    else if newsel==5 && selection!=5 then
      if selection==0 confirm hlayoutname
      Createdspmeas2()
      redraw=1; selection=5
    else if newsel==6 && selection!=6 then
      if selection==0 confirm hlayoutname
      Createdspconfig()
      redraw=1; selection=6
    else if newsel==7 && selection!=7 then
      if selection==0 confirm hlayoutname
      Createspecial()
      redraw=1; selection=7
    else if Pressed(hquit) then
      break
    else if Pressed(hwrite) then
    
    if 0 != nReadFlag then 
      if l.nfing==0 then
        Error("请先读取资料数据","Number of rails is 0")
      else
        if selection==0 then
          confirm hlayoutname
          Text(hlayoutname,layoutname)
        endif
        if layoutname[0]!='\0' then
          dontsave=-1; getini("System","Protection","%i",&dontsave)
          if dontsave<0 then
            dontsave=0
            setini("System","Protection","0")
          endif
          if dontsave!=0 then
            // Protection is on, ask for password.
            hinform=control WINDOW
              window=hmain
              position=0,0,250,125
              name="访问密码"
              help=" "
              mode=M_MODAL
              bkcolor=WHITEBLUE
            endc
            hmessage=control TEXT
              window=hinform
              position=10,10,230,20
              text="To save layout, please enter password:"
              help=" "
              font=INFOFONT
              color=BLACK
              mode=M_CENTERED
            endc
            hpassword=control EDIT
              window=hinform
              position=75,45,100,24
              text=wordofwisdom
              help="输入密码保存布局到硬盘"
              mode=M_BORDER|M_PASSWORD
            endc
            hsave=control WINBUTTON
              window=hinform
              position=10,90,100,25
              text="保存"
              help="保存布局"
            endc
            hcancel=control WINBUTTON
              window=hinform
              position=140,90,100,25
              text="Cancel"
              help="按下保持硬盘中的布局不变"
            endc
            while 1 do
              if Pressed(hsave) then
                // Hmm, this security is really unique!
                Text(hpassword,wordofwisdom)
                j=0
                for i=0,i<100 && wordofwisdom[i]!='\0',i++ do
                  j=((j<<3)|(j>>29)) ^ wordofwisdom[i]
                enddo
                if j==0x003D4FB0 then
                  dontsave=0; break
                else
                  change hmessage color=LIGHTRED
                  change hmessage text="Invalid password, please retry:"
                endif
              else if Pressed(hcancel) then
                break
              endif
              wait
            enddo
            destroy hinform
          endif
          if dontsave==0 then
            f=Fopen(layoutname,"wb")
            if f==NULL then
              Error("Unable to create layout file",layoutname)
            else
              Updatelayout(s,exts,e0,e1,e2,e3)
              hinform=control WINDOW
                window=hmain
                position=0,0,150,50
                mode=M_MODAL
                bkcolor=WHITEBLUE
                size=100
              endc
              draw window=hinform font=MEDIUMFONT color=BLUE  mode=M_CENTERED
              draw at 75,30 text="保存布局中" bkcolor=WHITEBLUE
              draw show
              err=0
              if Fwrite(s,768,f)!=768 err=1
              nextra=0
              if err==0 then
                // Check if layout extentions are not zero.
                for i=4,i<768,i++ do   // First 4 bytes are validity marker
                  if e3[i]!=0 break
                enddo
                if i<768 nextra=5
                if nextra==0 then
                  for i=4,i<768,i++ do
                    if e2[i]!=0 break
                  enddo
                  if i<768 nextra=4
                endif
                if nextra==0 then
                  for i=4,i<768,i++ do
                    if e1[i]!=0 break
                  enddo
                  if i<768 nextra=3
                endif
                if nextra==0 then
                  for i=4,i<768,i++ do
                    if e0[i]!=0 break
                  enddo
                  if i<768 nextra=2
                endif
                if nextra==0 then
                  for i=0,i<768,i++
                    if exts[i]!=0 break
                  enddo
                  if i<768 nextra=1
                endif
              endif
              if err==0 && nextra>=1 then
                if Fwrite(exts,768,f)!=768 err=1
              endif
              if err==0 && nextra>=2 then
                $int4(e0)=0x30747845
                if Fwrite(e0,768,f)!=768 err=1
              endif
              if err==0 && nextra>=3 then
                $int4(e1)=0x31747845
                if Fwrite(e1,768,f)!=768 err=1
              endif
              if err==0 && nextra>=4 then
                $int4(e2)=0x32747845
                if Fwrite(e2,768,f)!=768 err=1
              endif
              if err==0 && nextra>=5 then
                $int4(e3)=0x33747845
                if Fwrite(e3,768,f)!=768 err=1
              endif
              delay 250
              destroy hinform
              Fclose(f)
              if err!=0 then
                Error("Error writing layout to",layoutname)
              endif
            endif
          endif
        endif
      endif
      else
        Error("请先读取资料",layoutname)
      endif
    else if Pressed(hprint) then
      if selection==0 then
        confirm hlayoutname
        Text(hlayoutname,layoutname)
      endif
      Printlayout()
    else if Pressed(hsendext) then
      Sendextention()
    else if Pressed(hexit) then
      if nReadFlag == 1 then
        Updatelayout($LAY,$EXTLAY,$EXT0,$EXT1,$EXT2,$EXT3)
        SYS.Broadcast(8,"CHG LAY")       // Inform others that layout changed
        //SYS.Broadcast(1,"CHG LAY")       // Inform others that layout changed
        break
      endif
      Error("请先读取资料数据","必备操作")
    endif
    if probetypechanged then
      l.probetype=$LAY.probetype
      redraw=1
      probetypechanged=0
    endif
    if layoutchanged!=0 then
      // Attention, all changes are discarded!
      Makelayoutcopy($LAY,$EXTLAY,$EXT0,$EXT1,$EXT2,$EXT3)
      redraw=1
      layoutchanged=0
    endif
    if redraw!=0 then
      if selection==0 Showgeneral()
      if selection==1 then
        Creategeometryhead()
        Showgeometry()
      endif
      if selection==2 Showthermal()
      if selection==3 Showmeas()
      if selection==5 Showmeas2()
      if selection==6 Showdspconfig()
      if selection==7 Showspecialstuff()
      redraw=0
    endif
    wait
  enddo
  destroy hmain
end

