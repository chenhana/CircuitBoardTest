#include "ls.icl"
#include "or.icl"
#cmdbuff 64

#define DESCRIPTION "Temperature viewer"
#define VERSION     "1.08"

// 1.00: Original version.
// 1.01: Motor temperatures, redesign of user interface.
// 1.02: Reference.
// 1.03: Absolute time.
// 1.04: Default sample time 1 minute instead of 5.
// 1.05: Additional sensor types.
// 1.06: New 32-channel board with humidity input and temperature stabilization.
// 1.07: Accelerating reading of data, requires new Crate, backward-compatible.
// 1.08: Support for up to 4 cards (BEL112K2).

#define VX             650             // Width of data viewer, pixels
#define VY             580             // Height of data viewer, pixels
#define BORDER         5               // Border between the controls
#define MSGDY          24              // Height of message string
#define BTNDX          160             // Width of buttons
#define BTNDY          24              // Height of buttons
#define SCROLLDX       18              // Scroll thickness

#define CHHEIGHT       145             // Height per channel in pixels

#define NSHOW          12              // Number of channels to display
#define NARR           32              // Max. number of sensors per card
#define NCHAN          256             // Number of supported channels
#define NACARD         4               // Max. number of supported cards
#define NAHIST         10080           // Number of T history items per sensor
#define NSCALE         6               // Number of time scales

#define NREGDATA       128             // Max size of temperature control data
#define NREG           12              // Max number of regulation controls

#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3

#define HCA_TAMASK     0x00C00000      // Mask to extract type of T array
#define   HCA_TAACTIVE 0x00000000      // Active (sends data without request)
#define   HCA_TATYPE1  0x00400000      // Must be asked to send data
#define   HCA_TATYPE2  0x00800000      // Not yet defined
#define   HCA_TATYPE3  0x00C00000      // Not yet defined

#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements

char   scaletxt[NSCALE][32] = {      \ // Scales as text
  "5 min/div", "10 min/div", "30 min/div", "1 hr/div", "2 hr/div", "6 hr/div" }

float  scalefact[NSCALE] = {         \ // Scales, minutes per 20-pixel division
  5.0, 10.0, 30.0, 60.0, 120.0, 360.0 }

handle hmain                           // Main window
handle hmsg                            // Message string
handle hview                           // Data viewer
handle hchlist[NSHOW]                  // Fast channel on/off
handle hchan[NSHOW]                    // Channels to display
handle hnamed                          // Display only named channels
handle hscale                          // Horizontal scale
handle hformat                         // Time format (1: absolute)
handle hsetref                         // Set reference position
handle hreread                         // Re-read data
handle hsave                           // Save data to file
handle hsetreg                         // Set regulation parameters
handle hreg                            // Regulation parameters
handle hcard[NACARD]                   // Card seection buttons
handle hregold[NREG]                   // Old control parameters
handle hregact[NREG]                   // Actual value of regulated parameter
handle hregnew[NREG]                   // New control parameters
handle hregminus[NREG]                 // Decrease parameter
handle hregplus[NREG]                  // Increase parameter
handle hexit                           // Close window

int    ncard                           // Number of supported array cards
int    alist[NCHAN]                    // List of available channels
int    nalist                          // Number of channels in alist[]
float  data[NCHAN][NAHIST]             // Temperature history
int    datatime                        // Time when data was read as time_t
float  tsample                         // Time between samples, minutes
int    onlynamed                       // Display only named channels
int    scaleindex                      // Index in scalefact[] and scaletxt[]
int    chan[NSHOW]                     // Channels to display
int    chlist                          // Fast channel on/off
int    redraw                          // Redraw data
int    cursor                          // X click position in window
int    reference                       // X reference position in window
int    nhead                           // Number of heads and dedicated cameras
int    abstime                         // Show absolute time
int    regon                           // 0: graphs, 1: regulation parameters

int    prevarraytype                   // Previous type of sensor array
int    arraytype                       // Type of sensor array
int    prevcard                        // Previously selected card
int    card                            // Currently selected card
char   regdata[NREGDATA]               // Temperature control data
char   newregdata[NREGDATA]            // Temperature control data to send
int    nregdata                        // Length of regdata
int    nreg                            // Number of regulation controls
int    requestwrite                    // 1: Write data to card, 2: write now
int    requesttime                     // Time when request was posted

// Service function, displays message.
function int Message(int color,format s)
  change hmsg color=color
  change hmsg text=format(" %s",s)
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// TEMPERATURE VIEWER //////////////////////////////

// Service function, decodes channel index to assigned position in text form.
function int Channelname(int index,int extend,char *s)
  int k,n,head,ichan
  if (index>=0 && index<NARR) || (index>=160 && index<256) then
    // Sensor in array.
    if index<NARR then
      k=$char($EXT0+518+index)
      ichan=index
    else
      k=$char($EXT0+606+(index-160))
      ichan=index-160+NARR
    endif
    if extend then
      n=sprintf(s,"%i - ",ichan)
    else
      n=0
    endif
    if k==0x08 then
      n=n+sprintf(s+n,"Air top")
    else if k==0x48 then
      n=n+sprintf(s+n,"Air bottom")
    else if k==0x09 then
      n=n+sprintf(s+n,"Front top")
    else if k==0x49 then
      n=n+sprintf(s+n,"Front bottom")
    else if k==0x0A then
      n=n+sprintf(s+n,"Outside")
    else if k==0x0B then
      n=n+sprintf(s+n,"Heater L0")
    else if k==0x0C then
      n=n+sprintf(s+n,"Heater R0")
    else if k==0x0D then
      n=n+sprintf(s+n,"Heater L1")
    else if k==0x0E then
      n=n+sprintf(s+n,"Heater R1")
    else if k==0x0F then
      n=n+sprintf(s+n,"Heater L2")
    else if k==0x10 then
      n=n+sprintf(s+n,"Heater R2")
    else if k==0x11 then
      n=n+sprintf(s+n,"Heater L3")
    else if k==0x12 then
      n=n+sprintf(s+n,"Heater R3")
    else if k==0x87 then
      n=n+sprintf(s+n,"Stone top")
    else if k==0xC7 then
      n=n+sprintf(s+n,"Stone bottom")
    else if (k & 0x80)==0x00 then
      n=sprintf(s,"<%i>",ichan)
    else if (k & 0x07)!=0x00 && (k & 0x07)!=0x02 &&(k & 0x07)!=0x04 then
      n=sprintf(s,"<%i>",ichan)
    else
      if (k & 0x78)==0x38 then
        n=n+sprintf(s+n,"V top")
      else if (k & 0x78)==0x78 then
        n=n+sprintf(s+n,"V bot")
      else
        n=n+sprintf(s+n,"%s %i",(k & 0x40?"Bot":"Top"),(k>>3) & 0x7)
      endif
      if (k & 0x07)==0x00 then
        n=n+sprintf(s+n," L")
      else if (k & 0x07)==0x02 then
        n=n+sprintf(s+n," M")
      else if (k & 0x07)==0x04 then
        n=n+sprintf(s+n," R")
      endif
    endif
  else if index>=NARR && index<NARR+nhead then
    head=index-NARR
    if head<$LAY.nfing*2 then
      n=sprintf(s,"Head %i%s X",head/2,(head & 1?"R":"L"))
    else if head==$LAY.nfing*2 then
      n=sprintf(s,"Video top X")
    else
      n=sprintf(s,"Video bot X")
    endif
  else if index==NARR+31 then
    n=sprintf(s,"T meas")
  else if index>=NARR+32 && index<NARR+32+nhead then
    head=index-NARR-32
    if head<$LAY.nfing*2 then
      n=sprintf(s,"Head %i%s Y",head/2,(head & 1?"R":"L"))
    else if head==$LAY.nfing*2 then
      n=sprintf(s,"Video top Y")
    else
      n=sprintf(s,"Video bot Y")
    endif
  else if index>=NARR+64 && index<NARR+64+nhead then
    head=index-NARR-64
    if head<$LAY.nfing*2 then
      n=sprintf(s,"Head %i%s Z",head/2,(head & 1?"R":"L"))
    else if head==$LAY.nfing*2 then
      n=sprintf(s,"Video top Z")
    else
      n=sprintf(s,"Video bot Z")
    endif
  else if index>=128 && index<132 then
    n=sprintf(s,"Humidity %i",index-128)
  else
    n=sprintf(s,"Index %i",index)
  endif
  return n
end

// Given year, determines number of days in the year.
function int Daysinyear(int year)
  if (year & 3)!=0 return 365
  if (year %100)!=0 return 366
  if (year %400)!=0 return 365
  return 366
end

// Calculates actual time in time_t format. Sorry, function Timet() is not yet
// common!
function int Gettimet()
  int t1,t2,i,year,month,day,hour,minute,sec,days
  int daysinmonth[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 }
  char s[64]
  Strtime(s,"%Y %m %d %H %M %S",0,0)
  // Yes, scanning 08 returns 8 and not octal error!
  sscanf(s,"%04i %02i %02i %02i %02i %02i",&year,&month,&day,&hour,&minute,&sec)
  t1=0
  for i=1970,i<year,i++ do
    t1=t1+Daysinyear(i)
  enddo
  month--
  days=Daysinyear(year)
  for i=0,i<month,i++ do
    t1=t1+daysinmonth[i]
    if i==1 && days==366 t1++
  enddo
  t1=(t1+day-1)*86400+hour*3600+minute*60+sec
  // time_t assumes GMT. Let's determine and apply the difference between the
  // local time and Greenwich. Oh, what a kludge!
  Strtime(s,"%Y %m %d %H %M %S",1,t1)
  sscanf(s,"%04i %02i %02i %02i %02i %02i",&year,&month,&day,&hour,&minute,&sec)
  t2=0
  for i=1970,i<year,i++ do
    t2=t2+Daysinyear(i)
  enddo
  month--
  days=Daysinyear(year)
  for i=0,i<month,i++ do
    t2=t2+daysinmonth[i]
    if i==1 && days==366 t2++
  enddo
  t2=(t2+day-1)*86400+hour*3600+minute*60+sec
  return 2*t1-t2
end

// Service function, converts time in minutes to text, assuming that t is back
// in time. If mode is 0, time is relative to the moment of acquiring. If mode
// is 1, time is absolute (month day hr:min).
function int Timetotext(int mode,int t,char *s)
  int d,h,m
  char sign[2]
  if mode then
    return Strtime(s,"%d %b %H:%M",1,datatime-t*60)
  else
    if t<0 then
      t=-t
      Strcpy(sign,"")
    else
      Strcpy(sign,"-")
    endif
    d=t/1440; t=t-d*1440
    h=t/60; m=t%60
    if d==0 && h==0 && m==0 then
      return sprintf(s,"0:00")
    else if d==0 then
      return sprintf(s,"%s%i:%02i",sign,h,m)
    else if m==0 && h==0 then
      return sprintf(s,"%s%id",sign,d)
    else if m==0 then
      return sprintf(s,"%s%id%ih",sign,d,h)
    else
      return sprintf(s,"%s%id%i:%02i",sign,d,h,m)
    endif
  endif
end

// Redraws data window and sets scrolls.
function int Redraw()
  int i,j,k,m,cindex,rindex,cx,rx,x,y,x0,x1,y0,olddx,newdx,oldcx,newcx
  float t,xscale,chmin[NSHOW],chmax[NSHOW],dmax1,dmax2,dmax3
  float yscale1,yscale2,yscale3,yscale,dt1,dt2,dt3,dt
  char s[64]
  if tsample==0.0 tsample=1.0
  xscale=scalefact[scaleindex]/20.0    // Minutes per pixel
  // Calculate min/max temperature per channel.
  dmax1=2.0
  dmax2=2.0
  dmax3=2.0
  for m=0,m<NSHOW,m++ do
    if (chlist & (1<<m))==0 continue
    k=chan[m]
    chmin[m]=+100000.0
    chmax[m]=-100000.0
    for i=0,i<NAHIST,i++ do
      if data[k][i]==0.0 continue      // Skip missing points
      chmin[m]=Min(chmin[m],data[k][i])
      chmax[m]=Max(chmax[m],data[k][i])
    enddo
    if chmax[m]<chmin[m] then
      chmin[m]=0.0
      chmax[m]=5.0
    endif
    if k<NARR || (k>=160 && k<256) then
      dmax1=Max(dmax1,chmax[m]-chmin[m])
    else if k<128 then
      dmax2=Max(dmax2,chmax[m]-chmin[m])
    else
      dmax3=Max(dmax3,chmax[m]-chmin[m])
    endif
  enddo
  yscale1=dmax1/(CHHEIGHT-50.0)        // Degrees per pixel
  if dmax1>20.0 then
    dt1=5.0
  else if dmax1>8.0 then
    dt1=2.0
  else if dmax1>4.0 then
    dt1=1.0
  else
    dt1=0.5
  endif
  yscale2=dmax2/(CHHEIGHT-50.0)        // Degrees per pixel
  if dmax2>20.0 then
    dt2=5.0
  else if dmax2>8.0 then
    dt2=2.0
  else if dmax2>4.0 then
    dt2=1.0
  else
    dt2=0.5
  endif
  yscale3=dmax3/(CHHEIGHT-50.0)        // Percent per pixel
  if dmax3>50.0 then
    dt3=10.0
  else if dmax3>20.0 then
    dt3=5.0
  else if dmax3>8.0 then
    dt3=2.0
  else if dmax3>4.0 then
    dt3=1.0
  else
    dt3=0.5
  endif
  x0=10
  x1=x0+NAHIST*tsample/xscale
  y0=10
  // Calculate precise cursor and reference positions (nearest data point).
  if cursor>=x0 then
    cindex=Max(0,Min(Floor((x1-cursor)*xscale/tsample+0.5),NAHIST-1))
    cx=x1-cindex*tsample/xscale
  else
    cindex=-1
    cx=-1
  endif
  if reference>=x0 && cursor>=0 then
    rindex=Max(0,Min(Floor((x1-reference)*xscale/tsample+0.5),NAHIST-1))
    rx=x1-rindex*tsample/xscale
  else
    rindex=-1
    rx=-1
  endif
  // Redraw window.
  draw window=hview bkcolor=WHITE clear
  for m=0,m<NSHOW,m++ do
    if (chlist & (1<<m))==0 continue
    k=chan[m]
    if k<NARR || (k>=160 && k<256) then
      yscale=yscale1; dt=dt1
    else if k<128 then
      yscale=yscale2; dt=dt2
    else
      yscale=yscale3; dt=dt3
    endif
    // Draw background.
    draw font=SMALLFONT mode=M_CENTERED
    j=-1
    for t=0,t<NAHIST*tsample,t=t+20*xscale do
      x=x1-t/xscale; j++
      draw color=GRAY at x,y0+24 to x,y0+CHHEIGHT-16
      if j%(scalefact[scaleindex]>=360.0?4:6)==0 then
        draw color=BLACK to x,y0+CHHEIGHT-11
        Timetotext(abstime,t,s)
        draw at x,y0+CHHEIGHT text=s
      endif
    enddo
    draw font=SMALLFONT mode=M_LEFT
    for t=-10.0,t<=120.0,t=t+dt do
      y=Max(-1000.0,Min((t-chmin[m]+0.5)/yscale,1000.0))
      if y<0 || y>=CHHEIGHT-38 continue
      y=y0+CHHEIGHT-16-y
      draw color=GRAY at x0,y to x1+5,y
      draw color=BLACK at x1+8,y+7
      if k>=128 && k<132 then
        draw text=format("%g%%",t)
      else
        draw text=format("%g°C",t)
      endif
    enddo
    Channelname(k,ncard>1,s)
    draw color=LIGHTBLUE font=LARGEFONT mode=M_CENTERED
    draw at x1-(VX-18)/2,y0+90 text=s
    draw color=DARKGRAY at x1,y0+24 to x1,y0+CHHEIGHT-16
    draw to x0-1,y0+CHHEIGHT-16
    // Draw reference, cursor and value at cursor.
    if rindex>=0 then
      draw color=STRANGE at rx,y0+20 to rx,y0+CHHEIGHT-1
      draw to cx,y0+CHHEIGHT-1 to cx,y0+CHHEIGHT-16
    endif
    if cindex>=0 then
      draw color=BLACK mode=M_RIGHT font=MAINFONT
      if rindex>=0 then
        Timetotext(0,(cindex-rindex)*tsample,s)
      else
        Timetotext(abstime,cindex*tsample,s)
      endif
      draw at cx-5,y0+25 text=s
      draw color=STRANGE at cx,y0+10 to cx,y0+CHHEIGHT-16
      draw color=BLACK mode=M_LEFT
      draw at cx+6,y0+25
      if k>=128 && k<132 then
        if rindex>=0 then
          draw text=format("dH=%.2f %%",data[k][cindex]-data[k][rindex])
        else
          draw text=format("%.2f %%",data[k][cindex])
        endif
      else
        if rindex>=0 then
          draw text=format("dT=%.2f °C",data[k][cindex]-data[k][rindex])
        else
          draw text=format("%.2f °C",data[k][cindex])
        endif
      endif
    endif
    // Draw data.
    draw color=LIGHTRED
    for j=0,j<NAHIST,j++ do
      x=x1-j*tsample/xscale
      y=Max(0.0,Min((data[k][j]-chmin[m]+0.5)/yscale,CHHEIGHT-22))
      y=y0+CHHEIGHT-16-y
      if j==0 then
        draw at x,y
      else
        draw to x,y
      endif
    enddo
    y0=y0+CHHEIGHT
  enddo
  draw show
  // If horizontal scale was changed, try to keep rightmost time on the same
  // position.
  y=Limit3(hview)                      // Old and new Y offset
  olddx=Limit0(hview)                  // Old logical width
  newdx=x1+50                          // New logical width
  oldcx=Limit2(hview)+VX-22-x0         // Logical coordinate of old right side
  change hview limits=newdx,y0+10
  if olddx!=newdx then
    newcx=(oldcx*(newdx-x0-10.0))/(olddx-x0-10.0)
    change hview offset=Max(0,newcx-VX+22+x0),y
  endif
  redraw=0
end

// Reads temperature array data from crate. Returns 0 on success and -1 if user
// cancelled script.
function int Readdata()
  int i,j,t,warn,sensor,offset,count,alldone
  int choffset[NCHAN],chpending[NCHAN],bufpending[64]
  char buf[64]
  Memset(data,0,Sizeof(data))
  for sensor=0,sensor<NCHAN,sensor++ do
    choffset[sensor]=0                 // Offset in channel
    chpending[sensor]=-1               // Index of buffer
  enddo
  for i=0,i<64,i++ do
    bufpending[i]=-1                   // Index of sensor
    SYS.Killimm(i)
  enddo
  Message(BLACK,"Reading data...")
  warn=0
  t=Time()
  while 1 do
    // Check for timeout.
    if Time()-t>6000 then
      Message(LIGHTRED,"Can't read temperatures: Timeout")
      warn=1; break
    endif
    // Check for incoming data.
    for i=0,i<64,i++ do
      if bufpending[i]<0 continue      // Inactive buffer
      if $A[i].length==0 continue      // As yet no answer
      sensor=bufpending[i]
      bufpending[i]=-1
      if $A[i].answer!=S_DEBUG then
        Message(LIGHTRED,"Can't read temperatures: Unsupported function")
        choffset[sensor]=NAHIST
        warn=1; continue               // Invalid answer, skip this channel
      endif
      offset=$int4($A[i]+7)
      if offset<0 || offset>=NAHIST then
        choffset[sensor]=NAHIST        // Bad offset or channel finished
        continue
      endif
      count=($A[i].length-13)/4
      if $int2($A[i]+11)!=0 tsample=$int2($A[i]+11)/60.0
      for j=0,j<count,j++ do
        if offset+j>=NAHIST break
        data[sensor][offset+j]=$float4($A[i]+13+j*4)
      enddo
      choffset[sensor]=offset+j
      chpending[sensor]=-1
    enddo
    // Check whether we need to send next command.
    alldone=1
    for sensor=0,sensor<NCHAN,sensor++ do
      if choffset[sensor]>=NAHIST continue
      alldone=0
      if chpending[sensor]>=0 continue
      for i=0,i<64,i++ do
        if bufpending[i]<0 break
      enddo
      if i>=64 break                   // All buffers are busy, wait
      count=Min(NAHIST-choffset[sensor],250)
      buf[0]=S_DEBUG
      buf[1]=0x4B                      // Get temperature history
      $int2(buf+2)=sensor
      $int4(buf+4)=choffset[sensor]
      $int4(buf+8)=count
      $int4(buf+12)=0
      SYS.Sendimm(i,16,buf)
      chpending[sensor]=i
      bufpending[i]=sensor
    enddo
    if alldone break
    wait
  enddo
  datatime=Gettimet()
  Redraw()
  if warn==0 Message(BLACK,"")
end

// Saves temperature data as a text to the specified file.
function int Savedata(char *savefile)
  int k,m,t,validdata
  char s[64]
  handle f
  f=Fopen(savefile,"wt")
  if f==NULL then
    Message(RED,"Can't open file '%s'",savefile)
    return -1
  endif
  fprintf(f,"Temperature measurements\n")
  Strtime(s,"%d-%b-%Y %H:%M",1,datatime)
  fprintf(f,"Time 0 corresponds to %s\n\n",s)
  fprintf(f,"Time, min")
  for m=0,m<NSHOW,m++ do
    if (chlist & (1<<m))==0 continue
    k=chan[m]
    Channelname(k,ncard>1,s)
    fprintf(f,"\t%s",s)
  enddo
  fprintf(f,"\n")
  validdata=0
  for t=NAHIST-1,t>=0,t-- do
    if validdata==0 then
      for m=0,m<NSHOW,m++ do
        if (chlist & (1<<m))==0 continue
        k=chan[m]
        if data[k][t]!=0.0 then
          validdata=1; break
        endif
      enddo
    endif
    if validdata==0 continue
    fprintf(f,"%8i",-t*tsample)
    for m=0,m<NSHOW,m++ do
      if (chlist & (1<<m))==0 continue
      k=chan[m]
      fprintf(f,"\t%.2f",data[k][t])
    enddo
    fprintf(f,"\n")
  enddo
  Fclose(f)
  Message(BLACK,"Data saved")
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// TEMPERATURE CONTROL //////////////////////////////

#define NCTR           64

// XX.LL FFF MASK CHNG AA Text; '.' means extra distance preceding this row
char title1[7][NCTR] = {               /* For arraytype 0200                */ \
  "06 02 256 FFF0 0.5  14 Left temperature",                                   \
  "08 02 001 FFFF 5.0%    Left proportional feedback",                         \
  "10 02 001 FFFF 1.0     Left integral feedback",                             \
  "00.02 256 FFF0 0.5  12 Right temperature",                                  \
  "02 02 001 FFFF 5.0%    Right proportional feedback",                        \
  "04 02 001 FFFF 1.0     Right integral feedback",                            \
  "" }

// Service function, creates temperature regulation controls.
function int Createregcontrols(char *p)
  int i,y
  char s[NCTR]
  draw window=hreg font=INFOFONT mode=M_RIGHT
  if ncard==1 then
    for i=0,i<NACARD,i++ do
      hcard[i]=NULL
    enddo
    y=100
  else
    draw at 220,120 text="Selected card"
    for i=0,i<NACARD,i++ do
      hcard[i]=control BUTTON
        window=hreg
        position=235+i*90,100,80,24
        text=format("Card %i",i)
        help=format("按下可编辑卡%i上的调节参数",i)
        color=(i==card?YELLOW:BLACK)
        bkcolor=(i==card?LIGHTRED:LIGHTGRAY)
      endc
    enddo
    y=150
  endif
  i=0
  for nreg=0,nreg<NREG,nreg++ do
    if p[i]=='\0' break
    if p[i+2]=='.' y=y+12
    Strcpy(s,p+i+23)
    draw at 220,y+20 text=s
    s[0]=Tolower(s[0])
    hregold[nreg]=control EDIT
      window=hreg
      position=235,y,80,24
      help=format("卡上的%s值",s)
      font=MEDIUMFONT
      color=DARKGRAY
      mode=M_NOEDIT
    endc
    if Isdigit(p[i+20]) then
      hregact[nreg]=control EDIT
        window=hreg
        position=325,y,80,24
        help=format("%s的测量值",s)
        font=MEDIUMFONT
        color=DARKGRAY
        mode=M_NOEDIT
      endc
    else
      hregact[nreg]=NULL
    endif
    hregnew[nreg]=control EDIT
      window=hreg
      position=415,y,80,24
      help=format("%s的新值",s)
      font=MEDIUMFONT
    endc
    hregminus[nreg]=control BUTTON
      window=hreg
      position=505,y,24,24
      text="C"
      help=format("减少%s%4.4s",s,p+i+15)
      bkcolor=LIGHTGRAY
      font=MEDIUMFONT
    endc
    hregplus[nreg]=control BUTTON
      window=hreg
      position=535,y,24,24
      text="+"
      help=format("增加%s%4.4s",s,p+i+15)
      bkcolor=LIGHTGRAY
      font=MEDIUMFONT
    endc
    i=i+NCTR
    y=y+32
  enddo
  draw show
end

// Service function, updates old temperature regulation controls. If updatenew
// is 1, copies values to the new controls, too.
function int Updateregcontrols(char *p,int updatenew)
  int i,j,k,offset,length,mask,act
  float factor
  char s[NCTR]
  i=0
  for j=0,j<nreg,j++ do
    if p[i]=='\0' break
    offset=(p[i]-'0')*10+(p[i+1]-'0')
    length=(p[i+3]-'0')*10+(p[i+4]-'0')
    factor=(p[i+6]-'0')*100.0+(p[i+7]-'0')*10.0+(p[i+8]-'0')
    if length==4 then
      mask=0xFFFFFFFF
    else
      mask=0
      for k=0,k<4,k++ do
        mask=mask*16
        if p[i+10+k]>='0' && p[i+10+k]<='9' then
          mask=mask+p[i+10+k]-'0'
        else if p[i+10+k]>='A' && p[i+10+k]<='F' then
          mask=mask+p[i+10+k]-'A'+10
        endif
      enddo
      if mask==0 mask=0xFFFF
    endif
    if Isdigit(p[i+20]) then
      act=(p[i+20]-'0')*10+(p[i+21]-'0')
    else
      act=-1
    endif
    if offset+length>nregdata then
      Strcpy(s," ---")
    else
      if length==1 then
        k=regdata[offset]
      else if length==2 then
        k=$xint2(regdata+offset)
      else
        k=$xint4(regdata+offset)
      endif
      k=k & mask
      if factor==1 then
        sprintf(s," %g",k/factor)
      else
        sprintf(s," %.1f",k/factor)
      endif
    endif
    change hregold[j] text=s
    if updatenew change hregnew[j] text=s
    if hregact[j]!=NULL then
      if act<0 || act+length>nregdata then
        Strcpy(s," ---")
      else
        if length==1 then
          k=regdata[act]
        else if length==2 then
          k=$xint2(regdata+act)
        else
          k=$xint4(regdata+act)
        endif
        k=k & mask
        if factor==1 then
          sprintf(s," %g",k/factor)
        else
          sprintf(s," %.1f",k/factor)
        endif
      endif
      change hregact[j] text=s
    endif
    i=i+NCTR
  enddo
end

// Fills hreg with the controls corresponding to the type of the array card.
function int Updateregwindow()
  if arraytype==0x0200 then
    if prevarraytype!=arraytype || prevcard!=card then
      // First call or array type changed, create new controls.
      clear hreg
      draw window=hreg bkcolor=LIGHTYELLOW at -1,-1 fillrect VX+1,VY+1
      draw mode=M_CENTERED font=MEDIUMFONT color=BLACK
      draw at VX/2,40 text="Temperature control parameters"
      draw font=INFOFONT
      draw at VX/2,63 text="Board type: 02.00"
      draw show
      Createregcontrols(title1)
      Updateregcontrols(title1,1)
    else
      Updateregcontrols(title1,0)
    endif
  else
    // Temperature control is not supported.
    if prevarraytype!=arraytype then
      // First call or array type changed, create new controls.
      clear hreg
      draw window=hreg mode=M_CENTERED font=LARGEFONT color=LIGHTRED
      draw at VX/2,VY/2 text="Temperature control is not supported"
      draw show
    endif
  endif
  prevarraytype=arraytype
  prevcard=card
end

// Reads temperature control parameters from crate. Returns 0 on success and -1
// if user cancelled script.
function int Readparameters(int showmessage)
  int t,warn
  char buf[64]
  if showmessage then
    Message(BLACK,"Reading data...")
    delay 10
  endif
  warn=0
  // Send request.
  buf[0]=S_DEBUG
  buf[1]=0x4C                          // Read control parameters
  $int4(buf+2)=card
  SYS.Killimm(0)
  SYS.Sendimm(0,6,buf)
  // Wait till answer is here.
  t=Time()
  while 1 do
    if $A[0].length!=0 break
    if Time()-t>5000 then
      Message(LIGHTRED,"Can't read control parameters: Timeout")
      warn=1; break
    endif
    if Pressed(hexit) return -1
    wait
  enddo
  if $A[0].answer!=S_DEBUG then
    Message(LIGHTRED,"Can't read control parameters: Not supported")
    arraytype=0
    nregdata=0
    warn=1
  else if $A[0].length<9 then
    Message(LIGHTRED,"Can't read control parameters: Invalid answer")
    warn=1
  else if ($uint2($A[0]+7) & 0x000F)!=card then
    Message(LIGHTRED,"Can't read control parameters: Invalid card")
    warn=1
  else
    arraytype=$uint2($A[0]+5)
    nregdata=Min($A[0].length-9,NREGDATA)
    Memcpy(regdata,$A[0]+9,nregdata)
  endif
  if warn==0 Message(BLACK,"")
  return 0
end

// Service function, processes user actions in control parameters window.
function int Processupdate(char *p)
  int i,j,k,v,offset,length,mask,changed,forcewrite
  float value,delta,factor
  char s[NCTR]
  forcewrite=0
  if ncard>0 then
    for j=0,j<ncard,j++ do
      if Pressed(hcard[j]) && j!=card then
        card=j
        for i=0,i<ncard,i++ do
          change hcard[i] color=(i==card?YELLOW:BLACK)
          change hcard[i] bkcolor=(i==card?LIGHTRED:LIGHTGRAY)
        enddo
        for i=0,i<nreg,i++ do
          if hregold[i]!=NULL change hregold[i] text=""
          if hregact[i]!=NULL change hregact[i] text=""
          if hregnew[i]!=NULL change hregnew[i] text=""
        enddo
      endif
    enddo
  endif
  for j=0,j<nreg,j++ do
    i=j*NCTR
    changed=0
    value=0.0; Text(hregnew[j],s)
    if sscanf(s,"%g",&value)!=1 continue
    if Pressed(hregnew[j]) then
      forcewrite=1
    else if Pressed(hregminus[j]) then
      Memcpy(s,p+i+15,3); s[3]='\0'
      delta=0.0; sscanf(s,"%g",&delta)
      if p[i+18]=='%' then
        value=value/(1.0+delta/100.0)
      else
        value=value-delta
      endif
    else if Pressed(hregplus[j]) then
      Memcpy(s,p+i+15,3); s[3]='\0'
      delta=0.0; sscanf(s,"%g",&delta)
      if p[i+18]=='%' then
        value=value*(1.0+delta/100.0)
      else
        value=value+delta
      endif
    else
      continue                         // Nothing to update
    endif
    factor=(p[i+6]-'0')*100.0+(p[i+7]-'0')*10.0+(p[i+8]-'0')
    v=Floor(value*factor+0.5)
    offset=(p[i]-'0')*10+(p[i+1]-'0')
    length=(p[i+3]-'0')*10+(p[i+4]-'0')
    if length==1 then
      v=Min(v,255)
    else if length==2 then
      v=Min(v,65535)
    endif
    if length==4 then
      mask=0xFFFFFFFF
    else
      mask=0
      for k=0,k<4,k++ do
        mask=mask*16
        if p[i+10+k]>='0' && p[i+10+k]<='9' then
          mask=mask+p[i+10+k]-'0'
        else if p[i+10+k]>='A' && p[i+10+k]<='F' then
          mask=mask+p[i+10+k]-'A'+10
        endif
      enddo
      if mask==0 mask=0xFFFF
    endif
    v=v & mask
    if length==1 then
      if $char(newregdata+offset)!=v then
        $char(newregdata+offset)=v
        changed=1
      endif
    else if length==2 then
      if $xint2(newregdata+offset)!=v then
        $xint2(newregdata+offset)=v
        changed=1
      endif
    else
      if $xint4(newregdata+offset)!=v then
        $xint4(newregdata+offset)=v
        changed=1
      endif
    endif
    if changed then
      if factor==1 then
        sprintf(s," %g",v)
      else
        sprintf(s," %.1f",v/factor)
      endif
      change hregnew[j] text=s
      requestwrite=1+forcewrite
      requesttime=Time()
    endif
  enddo
end

// Processes user actions in control parameters window. If writenow is 1 and
// data was changed, writes it immediately, without delay.
function int Updateparameters(int writenow)
  int length
  char buf[64]
  if arraytype==0x0200 then
    Processupdate(title1)
    length=12
  else
    return
  endif
  if requestwrite!=0 &&                                                        \
    (requestwrite==2 || writenow!=0 || Time()-requesttime>=1000) then
    // Send request.
    buf[0]=S_DEBUG
    buf[1]=0x4D                        // Write control parameters
    $int2(buf+2)=arraytype
    $int4(buf+4)=card
    Memcpy(buf+8,newregdata,length)
    SYS.Killimm(1)
    SYS.Sendimm(1,8+length,buf)
    requestwrite=0
  endif
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// MAIN PROGRAM /////////////////////////////////

// Service function, creates list of channels that must be available in the
// channel selection combolists and fills them.
function int Listchannels()
  int i,j,k,type,ichan
  char s[64]
  nalist=0
  // Add array channels.
  for i=0,i<ncard*NARR,i++ do
    if i<NARR then
      k=$char($EXT0+518+i)
      ichan=i
    else
      k=$char($EXT0+606+(i-NARR))
      ichan=i+128
    endif
    if onlynamed!=0 && k==0 continue   // Skip unnamed array channel
    alist[nalist]=ichan
    nalist++
  enddo
  // Add humidity sensors.
  for i=0,i<ncard,i++ do
    alist[nalist]=i+128
    nalist++
  enddo
  // Add X, Y and Z motors. A7/A8 have only X and Z sensors; S testers have
  // only X and Y sensors.
  type=$LAY.config & LC_TYPEMASK
  for i=0,i<nhead,i++ do
    if onlynamed==0 || type==LC_A8 || type==LC_S1 || type==LC_S3 then
      alist[nalist]=NARR+i             // X temperature sensor
      nalist++
    endif
    if onlynamed==0 || type==LC_S1 || type==LC_S3 then
      alist[nalist]=2*NARR+i           // Y temperature sensor
      nalist++
    endif
    if onlynamed==0 || type==LC_A8 then
      alist[nalist]=3*NARR+i           // Z temperature sensor
      nalist++
    endif
  enddo
  // Add temperature sensor connected to the measurement card.
  if onlynamed==0 || ($int4($EXTLAY+496) & HCM_TMEASOFF)==0 then
    alist[nalist]=NARR+31
    nalist++
  endif
  // List is complete. Fill selection controls.
  for j=0,j<NSHOW,j++ do
    clear hchan[j]
    k=0
    for i=0,i<nalist,i++ do
      if alist[i]==chan[j] k=i
      Channelname(alist[i],0,s)
      add hchan[j] text=s
    enddo
    chan[j]=alist[k]
    change hchan[j] select=k
  enddo
end

// Main program.
function int main()
  int i,j,x,y,buttons,xoffset,yoffset,captured,move
  int tregrefresh
  char savefile[260]
  if ($LAY.cameras & 0x2)==0x2 then
    nhead=$LAY.nfing*2+2
  else if ($LAY.cameras & 0x1)==0x1 then
    nhead=$LAY.nfing*2+1
  else
    nhead=$LAY.nfing*2
  endif
  nhead=Max(0,Min(nhead,32))
  if ($EXTLAY.autoopt & HCA_TAMASK)==HCA_TATYPE1 then
    ncard=4                            // Supports up to 4 cards
  else
    ncard=1                            // Only one logical card is available
  endif
  card=0
  chlist=0x03FF; onlynamed=0; scaleindex=2; abstime=0
  getini("Temperatures","Parms","%x,%i,%i,%i",                                 \
    &chlist,&scaleindex,&abstime,&onlynamed)
  for i=0,i<NSHOW,i++ do
    chan[i]=i
  enddo
  getini("Temperatures","Channels","%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i",      \
    chan+0,chan+1,chan+2,chan+3,chan+4,chan+5,                                 \
    chan+6,chan+7,chan+8,chan+9,chan+10,chan+11)
  for i=0,i<NSHOW,i++ do
    if chan[i]<0 || chan[i]>=NCHAN chan[i]=i
  enddo
  if scaleindex<0 || scaleindex>=NSCALE scaleindex=2
  Strcpy(savefile,"temperatures.txt")
  getini("Temperatures","Protocol","%s",savefile)
  hmain=control WINDOW
    window=NULL
    position=10,10,VX+BTNDX+4*BORDER,VY+MSGDY+3*BORDER
    name=format("%s %s",DESCRIPTION,VERSION)
    color=BLACK
    bkcolor=PINK
    help=" "
    size=1024
  endc
  hmsg=control TEXT
    window=hmain
    position=BORDER,BORDER,VX,MSGDY
    name=""
    help="信息"
    font=MEDIUMFONT
    mode=M_BORDER
  endc
  hview=control CHILD
    window=hmain
    position=BORDER+1,MSGDY+2*BORDER+1,VX-2,VY-2
    help=                                                                      \
      "Temperature data. Left-click and drag to move, right-click sets cursor"
    color=BLACK
    bkcolor=WHITE
    size=4194304                       // Oh, yes!..
    limits=VX+1,VY+1
    offset=100,0
    mode=M_HSCROLL|M_VSCROLL
  endc
  hreg=control CHILD
    window=hmain
    position=BORDER+1+5000,MSGDY+2*BORDER+1,VX-2,VY-2
    help=" "
    color=BLACK
    bkcolor=WHITE
    size=2048
  endc
  draw window=hmain font=INFOFONT mode=M_LEFT color=BLACK
  draw at VX+2*BORDER,20 text="Channels to view:"
  for i=0,i<NSHOW,i++ do
    y=BORDER+i*(BTNDY+BORDER)+20
    hchlist[i]=control CHECKBOX
      window=hmain
      position=VX+4*BORDER,y+5,50,18
      name=format("Ch%i",i+1)
      help=format("选中以启用通道%i",i+1)
      font=INFOFONT
      mode=(chlist & (1<<i)?M_CHECKED:0)
    endc
    hchan[i]=control COMBOLIST
      window=hmain
      position=VX+4*BORDER+50,y,BTNDX-BORDER-50,800
      help=format("选择要在绘图%i上显示的数据",i+1)
      mode=M_VSCROLL|M_REPEAT
    endc
    if (chlist & (1<<i))==0 then
      disable hchan[i]
      change hchan[i] bkcolor=LIGHTGRAY
    endif
  enddo
  Listchannels()
  y=y+BTNDY+BORDER
  hnamed=control CHECKBOX
    window=hmain
    position=VX+4*BORDER,y+5,180,18
    name="只命名输入"
    help="隐藏不可用通道或布局中未命名的通道"
    font=INFOFONT
    mode=(onlynamed==0?0:M_CHECKED)
  endc
  y=y+BTNDY+2*BORDER
  draw mode=M_LEFT at VX+2*BORDER,y+21 text="Time scale"
  hscale=control COMBOLIST
    window=hmain
    position=VX+3*BORDER+65,y,BTNDX-65,200
    help="设置水平比例"
  endc
  for i=0,i<NSCALE,i++ do
    add hscale text=scaletxt[i]
  enddo
  change hscale select=scaleindex
  y=y+BTNDY+BORDER
  hformat=control CHECKBOX
    window=hmain
    position=VX+4*BORDER,y+5,100,18
    name="绝对时间"
    help="显示绝对时间而不是时差"
    font=INFOFONT
    mode=(abstime?M_CHECKED:0)
  endc
  y=y+BTNDY+2*BORDER
  hsetref=control BUTTON
    window=hmain
    position=VX+2*BORDER,y,BTNDX+BORDER,BTNDY
    text="Reference"
    help="按下可以设置或删除引用(或使用鼠标中键)"
    color=BLACK
    bkcolor=GRAY
  endc
  cursor=-1
  reference=-1
  disable hsetref
  y=y+BTNDY+BORDER
  hreread=control BUTTON
    window=hmain
    position=VX+2*BORDER,y,(BTNDX-BORDER)/2,BTNDY
    text="Refresh"
    help="从测试机里重新读取温度"
  endc
  hsave=control BUTTON
    window=hmain
    position=VX+4*BORDER+(BTNDX-BORDER)/2,y,BTNDX-BORDER-(BTNDX-BORDER)/2,BTNDY
    text="保存"
    help="将温度数据作为表格保存到文件中"
  endc
  y=y+BTNDY+3*BORDER
  hsetreg=control BUTTON
    window=hmain
    position=VX+2*BORDER,y,BTNDX+BORDER,BTNDY
    text="Set parameters"
    help="按此查看和修改温度调节参数"
    color=BLACK
    bkcolor=GRAY
  endc
  if chlist==0 disable hsave
  draw show
  hexit=control BUTTON
    window=hmain
    position=VX+2*BORDER,VY+MSGDY+2*BORDER-BTNDY,BTNDX+BORDER,BTNDY
    name="关闭"
    help="关闭此窗口"
  endc
  regon=0                              // Graph is active
  tsample=1.0                          // Default time bewteen samples 1 min
  Readdata()                           // Also calls Redraw()
  while 1 do
    i=Mousexy(hview,&x,&y,&buttons)
    if (buttons & 0x4)!=0 && cursor>=0 then
      if reference<0 then
        change hsetref color=LIGHTRED
        change hsetref bkcolor=YELLOW
      endif
      reference=x+xoffset
      redraw=1
    endif
    if i==1 && (buttons & 2)!=0 then
      captured=1
    else if (buttons & 2)==0 then
      captured=0
    endif
    if captured then
      xoffset=Limit2(hview)
      yoffset=Limit3(hview)
      move=0
      if x<0 then
        xoffset=xoffset+x; move=1
      else if x>VX-18 then
        xoffset=xoffset+x-VX+18; move=1
      endif
      if y<0 then
        yoffset=yoffset+y; move=1
      else if y>VY-18 then
        yoffset=yoffset+y-VY+18; move=1
      endif
      if move then
        change hview offset=xoffset,yoffset
      endif
      x=x+xoffset
      if x!=cursor then
        cursor=x
        enable hsetref
        redraw=1
      endif
    else if (buttons & 2)==0 then
      captured=0
    endif
    for i=0,i<NSHOW,i++ do
      if Pressed(hchlist[i]) then
        if Status(hchlist[i])==0 then
          chlist=chlist & (~(1<<i))
          disable hchan[i]
          change hchan[i] bkcolor=LIGHTGRAY
        else
          chlist=chlist | (1<<i)
          enable hchan[i]
          change hchan[i] bkcolor=WHITE
        endif
        if chlist==0 then
          disable hsave
        else
          enable hsave
        endif
        redraw=1
      else if Pressed(hchan[i]) then
        j=Status(hchan[i])
        if j<0 || j>=nalist j=0
        chan[i]=alist[j]
        redraw=1
      endif
    enddo
    if Pressed(hnamed) then
      onlynamed=Status(hnamed)
      Listchannels()
    else if Pressed(hscale) then
      scaleindex=Status(hscale)
      cursor=-1
      reference=-1
      change hsetref color=BLACK
      change hsetref bkcolor=GRAY
      disable hsetref
      redraw=1
    else if Pressed(hformat) then
      abstime=Status(hformat)
      redraw=1
    else if Pressed(hsetref) && cursor>=0 then
      if reference<0 then
        reference=cursor
        change hsetref color=LIGHTRED
        change hsetref bkcolor=YELLOW
      else
        reference=-1
        change hsetref color=BLACK
        change hsetref bkcolor=GRAY
      endif
      redraw=1
    else if Pressed(hreread) then
      Readdata()                       // Also calls Redraw()
    else if Pressed(hsave) then
      if SYS.Browse(hmain,savefile,"Specify text file to save data",0)!=0 then
        Savedata(savefile)
      endif
    else if Pressed(hsetreg) then
      if regon==0 then
        change hview position=BORDER+5000,MSGDY+2*BORDER,VX-2,VY-2
        change hreg position=BORDER,MSGDY+2*BORDER,VX-2,VY-2
        disable hreread
        disable hsave
        reference=-1
        change hsetref color=BLACK
        change hsetref bkcolor=GRAY
        disable hsetref
        change hsetreg text="View temperatures"
        regon=1
        prevarraytype=-1
        Readparameters(1)
        Memcpy(newregdata,regdata,NREGDATA)
        Updateregwindow()
        tregrefresh=Time()
      else
        Updateparameters(1)            // If parameters changed, wtite to card
        change hview position=BORDER,MSGDY+2*BORDER,VX-2,VY-2
        change hreg position=BORDER+5000,MSGDY+2*BORDER,VX-2,VY-2
        enable hreread
        enable hsave
        change hsetreg text="Set parameters"
        clear hreg
        regon=0
        redraw=1
      endif
    else if Pressed(hexit) then
      break
    endif
    if redraw then
      Redraw()
    endif
    if regon then
      if Time()-tregrefresh>2000 then
        Readparameters(0)
        Updateregwindow()
        tregrefresh=Time()
      endif
      Updateparameters(0)
    endif
    wait
  enddo
  setini("Temperatures","Parms","%x,%i,%i,%i",                                 \
    chlist,scaleindex,abstime,onlynamed)
  setini("Temperatures","Channels","%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i",      \
    chan[0],chan[1],chan[2],chan[3],chan[4],chan[5],                           \
    chan[6],chan[7],chan[8],chan[9],chan[10],chan[11])
  setini("Temperatures","Protocol","%s",savefile)
end

