#include "stddef.inc"
#include "commands.inc"
#include "rtfadd.inc"                  // Rich Text Format extentions

#cmdbuff 64
#zeroid                                // Process answers with zero command ID

<<<<<<< CALIBR.SCR
#define VERSION        "3.10"          // Version of calibration procedure
=======
#define VERSION        "3.12"          // Version of calibration procedure
>>>>>>> 1.202
#define DESCRIPTION    "Calibration and verification"

// 1.01: Distinguishing between A5 and A6.
// 1.02: Bugfixes, operator away.
// 1.03: Shinethrough calibration.
// 1.04: Camera can calibrate leftmost line on MCM glass.
// 1.05: Shinethrough was not correctly supported in Manualcenters().
// 1.06: More realistic predefined parameters.
// 1.07: Calibration parameters readjusted.
// 1.08: Verification of existing calibration.
// 1.09: New bitmaps.
// 1.10: Soft reset before reloading layout.
// 1.11: Doesn't load corrections to non-existing cameras.
// 1.12: Log file.
// 1.13: Position of calibration board in shuttle, extended verification.
// 1.14: Improved data display, demo mode.
// 1.15: Waveness measurements.
// 1.16: Manual radius correction.
// 1.17: Correct treatment of single-sided testers and testers without cameras.
// 1.18: Head spline viewer.
// 1.19: Correct removing of bad points in video calibration.
// 1.20: Cleaned calculation of head corrections, smoothing.
// 1.21: A5 glass support.
// 1.22: Better extrapolation of measured corrections.
// 1.23: Internal data displays simultaneously X and Y corrections.
// 1.24: Shuttle release works when changing position of board in shuttle.
// 1.25: Three-line calibration.
// 1.26: First head calibration, then camera.
// 1.27: A6 glass support.
// 1.28: Single-side calibration of two-sided testers.
// 1.29: Separate request to save X-Y coordinates of board in shuttle.
// 1.30: Writes date of calibration and temperature to layout.
// 1.31: Support for A5 wide shuttle.
// 1.32: Updating temperature before scanning centers, pause if precise video.
// 1.33: Warning when corrections and layout don't match or not loaded.
// 1.34: Support (cosmetical) for new A1 (slower A5).
// 1.35: Optical scanning removes double fiducials.
// 1.36: It was not possible to calibrate single-sided tester with glass.
// 1.37: Camera-only calibration.
// 1.38: Support for external scanner (all emulated heads).
// 1.39: Soft landing, automatical pressure corrections.
// 1.40: A5L support, A5L calibration with A5 board.
// 1.41: Bugfix for A5L calibration with A5 board.
// 1.42: Check for no contact to shield in splinogramm holder.
// 1.43: Option to measure and correct top-to-bottom shift.
// 1.44: Quick head correction.
// 1.45: Large A5L calibration board.
// 1.46: Movement statistics in log file.
// 1.47: Soft landing for A5 and A5L is allowed.
// 1.48: Top-to-bottom shift on the glass (simplified, with rotation).
// 1.49: Camera can calibrate columns next to the border on MCM glass.
// 1.50: Online adjustment of the shinethrough offset.
// 1.51: Central column is scanned if throwaway = 2 or 4.
// 1.52: Script takes into account vacuum box and rails excluded in layout.
// 1.53: Measurements of camera hysteresis.
// 1.54: 2x search for fiducials in precise camera mode.
// 1.55: Head camera support.
// 1.56: Small bugfix in Fillcalibrators().
// 1.57: Bugfix: radius of head was set to 0 in custom preset.
// 1.58: Allowance for A5XXL (sorry, A5Y - 240 mm rail height).
// 1.59: Warning about invalid head camera declaration (HdCam/HdCam R).
// 1.60: Default headcam radii changed to 118 and 153 mm.
// 1.61: Kelvin scanning.
// 1.62: Manual adjustment of headcam-to-opposite offset in shinethrough mode.
// 1.63: Check for ohmical connection to shuttle.
// 1.64: Extended waveness test, extended waveness protocol.
// 1.65: Reference point on line, parameters for Kelvin scan adjusted.
// 1.66: No error if needle is too close to the border of headcam's picture.
// 1.67: Support for soft Kelvin needles.
// 1.68: Serial errors are considered non-critical for A5/A6.
// 1.69: Opposite head searches best position during headcam shinethrough.
// 1.70: Increased shield check capacity limit for soft Kelvin needles.
// 1.71: Automatical continuation on non-critical errors.
// 1.72: Checks that border points are physically reachable.
// 1.73: Option to verify border points only (in verification).
// 1.74: Verification of placement checks head against all other on the side.
// 1.75: Another round of glass calibration with head cameras.
// 1.76: Ditto.
// 1.77: Basic S1 support.
// 1.78: When installing calibration board, viewer uses old headcam corrections.
// 1.79: Shield capacity for soft Kelvin is 2.5x normal, to account for blades.
// 1.80: No Unlock button if automatical/semi-automatical tester.
// 1.81: Support for A5 L&M automation.
// 1.82: External antenna as reference.
// 1.83: Verification of limits is now optional.
// 1.84: Support for EPCOS tester.
// 1.85: A5L calibration on glass (small and standard).
// 1.86: Improved calibration of old testers (A2-A4).
// 1.87: Low accelerations during the main part of the calibration.
// 1.88: Special big glass calibration board for S1.
// 1.89: Shuttle adjustment and restoration support for A5 L&M automation.
// 1.90: Small modifications for EPCOS tester.
// 1.91: External antenna as reference for all A5/S1 needle types.
// 1.92: C adjustment on the A6 FR4 calibration board.
// 1.93: 1 gramm (10 units) pressure for S1 microprobes.
// 1.94: Calibration of pressure sensors for microprobes.
// 1.95: Check for shortcut between analog shield ("blue cable") and ground.
// 1.96: Calibration of Z microstep for S1.
// 1.97: Contact check for Kelvin; intermediate shuttle position in A5a.
// 1.98: Bugfix: invalid brightness and contrast in headcam verification.
// 1.99: Support for S2.
// 2.00: Glass calibration on S2.
// 2.01: Support for unsymmetric rails (different top and bottom).
// 2.02: Support for S2 automatic shuttle.
// 2.03: Higher Z movements on the border for L&M automates.
// 2.04: Adjustments for S2.
// 2.05: No contacts on glass during placement check are ignored.
// 2.06: Check for false multiplexer connections.
// 2.07: Individual per-camera brightness and contrast.
// 2.08: Charge-discharge scanning of reference lines if no Kelvin.
// 2.09: List of errors during scale and center verification with headcams.
// 2.10: Minor adjustment for S2 headcams.
// 2.11: Visualization of Z pressure factors for micro/Kelvin probes.
// 2.12: Extended info when fiducial is not found by headcam in main run.
// 2.13: Glass calibration on full-sized S2 with A6 board.
// 2.14: Shinethrough illumination with flashlight.
// 2.15: No clipping in glass camera calibration.
// 2.16: Manual verification of calibration.
// 2.17: S2/16 DCF movements, no clipping on request.
// 2.18: In verification mode, camera position is not corrected by old corrs.
// 2.19: Improved diagnostics during camera verification on A2/A3/A4.
// 2.20: Needle type selection.
// 2.21: Verification of Kelvin needle parameters.
// 2.22: Standard calibration on S2/8.
// 2.23: Disables atomatic brightness and contrast.
// 2.24: Improved manual verification.
// 2.25: Bug in the coordinates of shinethrough illumination.
// 2.26: Automatic verification of Z alignment.
// 2.27: Automatic Z alignment on 3 Z levels.
// 2.28: S2/8 small calibration board on S2/8 large tester.
// 2.29: Z alignment on A6.
// 2.30: Automatic calculation of the thickness of Z correcting sheets.
// 2.31: Initial support for A7 and A8 testers.
// 2.32: Z alignment on S2.
// 2.33: Takes into account dedicated cameras disabled in layout.
// 2.34: Lock/unlock buttons for the old A2/A3 automates.
// 2.35: Contact check for single-pin micro needles in Z pressure verification.
// 2.36: Precise glass (not MCM) calibration on S2 scans each second cross.
// 2.37: Z pressure test corrects Z, distinguishes direct & inverting sensors.
// 2.38: Option to make stand-alone Z pressure test.
// 2.39: Skew illumination for A7/A8.
// 2.40: Modified verification of limits.
// 2.41: Calibration of A7 with A5 small glass board.
// 2.42: Bug preventing fast calibration.
// 2.43: Basic support for A7a.
// 2.44: Native A7 glass calibration board.
// 2.45: Glass calibration with A5a.
// 2.46: Another bug in limit check on A7a.
// 2.47: Replay of old calibration.
// 2.48: Bug that removed perfectly valid points.
// 2.49: Support for A8a.
// 2.50: Calibration of A8a with S2 small glass.
// 2.51: Calibration of A7a with A5 glass board.
// 2.52: Preload force check for splinogramms.
// 2.53: Takes into account bad contact in antenna during shield checks.
// 2.54: Reduced or no high movements near borders.
// 2.55: Optional all-references mode (now turned off, unclear whether helps).
// 2.56: Verification of end marks on A7/A8 Z encoders.
// 2.57: Long exposition, corrected skew light in shinethrough.
// 2.58: Explanations to Z end marks, beam-to-beam distance on old testers.
// 2.59: Better diagnostics in electrical calibration.
// 2.60: Basic support for S3.
// 2.61: Support for high resolution dedicated cameras.
// 2.62: S3 autofocus.
// 2.63: Y profile instead of 3-line calibration for S3.
// 2.64: Support for fine corrections (currently limited to S3 heads).
// 2.65: Support for A7/20 and EL208-1.
// 2.66: Improved limit check.
// 2.67: Correct presentation of A7/20 calibration board.
// 2.68: Replay of verification, corrected calculation of shift.
// 2.69: Y profile for all S-based testers.
// 2.70: 3-D calibration.
// 2.71: Corrected processing of verification results.
// 2.72: Long CAL mode if first attempt failed.
// 2.73: Bug: 2-line headcam calibration on S1/S2 if Y profile is selected.
// 2.74: Check for correct line width.
// 2.75: Uses external USB temperature sensor if internal is absent.
// 2.76: Remembers non-standard line width.
// 2.77: Warning if offset of central point in corrections is too large.
// 2.78: Support for S3/8 (double-sided).
// 2.79: Partial calibration of A7/16 etc. with A5 board.
// 2.80: Manual verification with dedicated camera.
// 2.81: Verification of camera stability.
// 2.82: Z-related hysteresis and tilt of S3 cameras.
// 2.83: Verification of all available crosses, view raw verification data.
// 2.84: Correct existing corrections using verification data.
// 2.85: Display of estimated residual deviations after correction adjustment.
// 2.86: Verification and correction adjustment near the center on S3.
// 2.87: Support for glass calibration on A8a (double shuttle).
// 2.88: Automatic adjustment of shinethrough camera.
// 2.89: Separate brightness and contrast for top, middle and bottom lines.
// 2.90: Y encoder corrections for S3 shuttle.
// 2.91: Correction from verification for testers with head cameras.
// 2.92: Variable Y step of S3 camera corrections.
// 2.93: Camera stability check for head cameras.
// 2.94: Extended camera stability check.
// 2.95: Board accuracy down to 100 nm, nanometers for camera movements.
// 2.96: L&M shuttle settings are not restored when calibration is finished.
// 2.97: Support for new type of glass fiducials.
// 2.98: Bugs concerning choice of SYNT_LEFT/SYNT_RIGHT.
// 2.99: Custom stroke for predefined calibration modes, V and P in commands.
// 3.00: Shuttle-related Y corrections for heads and on-head cameras.
// 3.01: Support for A7a with additional left/right board cathchers.
// 3.02: Basic support for split shuttle.
// 3.03: Neutral message if tilt or hysteresis on S3 is too high.
// 3.04: Support for mixed camera types.
// 3.05: Duration of calibration individually for each head.
// 3.06: Options to keep calibration board in the tester.
// 3.07: Two-step calibration of A8 tester with split shuttle.
// 3.08: Measurements of loop resistance for Kelvin needles.
// 3.09: Two-board calibration of A8 tester with split shuttle.
// 3.10: Special fiducials for the new glass boards (without circles).
<<<<<<< CALIBR.SCR
=======
// 3.11: Support for cartesian correction, enlarged calibration grid.
// 3.12: Support for S3ea with split shuttle.
>>>>>>> 1.202

#bitmap "logo"<"atg.bmp"               // All bitmaps are compressed
#bitmap "bkground"<"aluminum.bmp"      // Alternative: "pcb1.bmp"
#bitmap "a2"<"a2.bmp"
#bitmap "a3"<"a3.bmp"
#bitmap "a4"<"a4.bmp"
#bitmap "a5"<"a5.bmp"
#bitmap "a6"<"a6.bmp"
#bitmap "s3"<"s3.bmp"

// As the size of the compiled script nears the limit of older OllyTest, I do
// not pack all bitmaps into the object module. They will be loaded, if
// necessary, directly from the disk.

//#bitmap "ndhard"<"ndhard.bmp"
//#bitmap "ndhadapt"<"ndhadapt.bmp"
//#bitmap "ndsplino"<"ndsplino.bmp"
//#bitmap "ndsplk4"<"ndsplk4.bmp"
//#bitmap "ndmicmir"<"ndmicmir.bmp"
//#bitmap "ndmicro"<"ndmicro.bmp"
//#bitmap "ndkelmir"<"ndkelmir.bmp"
//#bitmap "ndkelvin"<"ndkelvin.bmp"
//#bitmap "ndkblmir"<"ndkblmir.bmp"
//#bitmap "demobk"<"demobk.bmp"
//#bitmap "m2"<"m2.bmp"
//#bitmap "unknown"<"unknown.bmp"
//#bitmap "splcont"<"splcont.bmp"

// Permanent options.
#define ALLREF         0               // 1: use all references in R-scan, slow!
#define AUTOTHRU       1               // 1: Auto move opp camera in shinethru
#define USEHVCOND      0               // 1: use HV conditioning on glass

// Dimensions of calibration window.
#define MAINX          600
#define MAINY          400
#define SPLIT          330
#define SERVY          25
#define LEFTX          320             // (SPLIT-10)
#define LEFTY          365             // (MAINY-SERVY-10)
#define RIGHTX         265             // (MAINX-SPLIT-5)
#define RIGHTY         335             // (MAINY-SERVY-SERVY-15)
#define USERY          280

// Number of nodes in correction table (same for all testers).
#define CORRX          31              // Number of correction points along X
#define CORRY          19              // Number of correction points along Y
#define CENTERX        15              // (CORRX/2)
#define CENTERY        9               // (CORRY/2)
#define FINEX          128             // Number of fine corr points along Ro
#define FINEY          128             // Number of fine corr points along Fi
#define FINECX         64              // (FINEX/2)
#define FINECY         64              // (FINEY/2)
#define FINEDX         10.0            // Step of fine corrections along Ro, mm
#define FINEDY         10.0            // Step of fine corrections along Fi, mm
#define MAXCORR        32.767          // Maximal allowed correction amplitude
#define NCALIBR        512             // Max number of points to scan
#define NFID           3               // Maximal number of found fiducials
#define WAVEDX         50.0            // Expected wave period, mm
#define NWAVE          50              // Number of standard wave test points
#define NWAVEL         150             // Max number of wave test points
#define NSUBWAVE       5               // Number of points between crosses
#define PI             3.14159265359
#define TWOPI          6.28318530718

// Maximal allowed individual corrections.
#define MAXCORRX       5.0             // Maximal allowed X correction, mm
#define MAXCORRY       3.0             // Maximal allowed Y correction, mm

// Allowed temperature limits.
#define TMIN           210             // Minimal allowed temperature, x10
#define TMAX           310             // Maximal allowed temperature, x10

// Maximal allowed own capacity of the needle (contacting between the crosses).
// Note that micros are veeeeeeery open!
#define CMAXSHLD       0.050           // Max capacity 50 fF, shielded needles
#define CMAXSTD        0.200           // Max capacity 200 fF, std/soft needles
#define CMAXSKP        0.450           // Max capacity 450 fF, micro needles
#define CMAXKELV       0.750           // Max capacity 750 fF, micro Kelvins

// Automatical on-head adjustment.
#define DADJLIMIT      10              // Accuracy of on-head adjustment
#define FNOISE         75              // Maximal allowed sine/cosine noise
#define SINMIN         8000            // Minimal amplitude of sine component
#define SINMAX         12500           // Maximal amplitude of sine component
#define COSMIN         (-2000)         // Minimal amplitude of cosine component
#define COSMAX         (-800)          // Maximal amplitude of cosine component
#define CMIN           3.5             // Minimal allowed capacity
#define CMAX           8.0             // Maximal allowed capacity
#define DELTA          0.25            // Random deviation, millimeters
#define DADJA5S        16000.0
#define DADJA5C        10000.0

// Parameters of S3 camera.
#define MAXTILT        0.020           // Maximal camera tilt, mm/mm

// Constants that describe tester type.
#define TT_WRONG       (-1)
#define TT_UNDEF       0
#define TT_A1          1
#define TT_A2          2
#define TT_A2L         3
#define TT_A2H         4
#define TT_A3          5
#define TT_A3L         6
#define TT_A4          7
#define TT_A5          8               // A5 or new A1
#define TT_A5L         9
#define TT_A6          10
#define TT_S1          11
#define TT_S2          12
#define TT_A7          13
#define TT_A8          14
#define TT_S3          15
#define TT_M2          16

// General types of calibration.
#define MODE_CAL       0               // Calibration
#define MODE_3DCAL     1               // 3-D calibration
#define MODE_VER       2               // Verification
#define MODE_CADJ      3               // Only C adjust

// Definition of global error bits.
#define GE_BOOT        0x0001          // Tester must be rebooted
#define GE_HARDWARE    0x0002          // Pneumatics/shuttle out of order
#define GE_IOERROR     0x0004          // I/O error detected
#define GE_COMMAND     0x0008          // Command sending error
#define GE_MEAS        0x0010          // Resistance measurements impossible

// Definition of calibrator mode bits.
#define CM_LOWACC      0x0001          // Raw scan (with low accuracy)
#define CM_CORRX       0x0002          // Correct remaining crosses in X dir
#define CM_CORRYTOP    0x0004          // Correct remaining top crosses in Y dir
#define CM_CORRYBOT    0x0008          // Correct remaining bottom crosses in Y
#define CM_CORRECT     0x0010          // Correct remaining crosses for video
#define CM_CORRXY      0x0020          // Correct remaining crosses in X-Y

// Types of data to be filled by Fillcalibrators().
#define FILL_MECH      0x01            // Fill head calibrators
#define FILL_VIDEO     0x02            // Fill video calibrators
#define FILL_BOTH      0x03            // Fill both head and video calibrators
#define FILL_HCAM      0x04            // Fill head camera calibrators

// Modes used by Fillcalibrators().
#define C_CENTER       0               // Central crosses
#define C_CORNER       1               // Board position or corners
#define C_CALIBR       2               // Main calibration
#define C_VER3         3               // Verification, 3 rows
#define C_VER5         4               // Verification, 5 rows/all
#define C_VERAREA      5               // Verification, whole area/all
#define C_VERALL       6               // Verification, all/all
#define C_VERHALF      7               // Verification, half/all
#define C_PRECAL       8               // Precalibration & center
#define C_CENTER2      9               // Central crosses/2x center
#define C_MVERIFY      10              // As requested by mverifyxx
#define C_9N           11              // 9N crosses (mverifyxx)
#define C_SHY          12              // Crosses for shuttle Y calibration

// Types of calibration points displayed by Drawcalboard().
#define DR_HEAD        0x0001          // Display head crosses
#define DR_VIDEO       0x0002          // Display video fiducials
#define DR_ROTATE      0x0004          // Display request to rotate board
#define DR_EMPTY       0x0010          // Display empty shuttle
#define DR_SELECT      0x0020          // Emphasize crosses
#define DR_DIFFCTR     0x0040          // Different central crosses
#define DR_WAVENESS    0x0080          // Display waveness test region
#define DR_Z           0x0100          // Warn different Z if MODE_3DCAL
#define DR_RAIL        0x0200          // Emphasize mverifyrail

// Bits in t_extlay.extcfg.
#define EXT_CHECKZERO  0x00000001      // Correct X-Y zero pulses on soft reset
#define   EXT_CHECKALL 0x00000002      // Correct zero pulses of all heads
#define EXT_FASTRESET  0x00000004      // Optimize soft reset
#define EXT_NOZLIMIT   0x00000008      // Accept very deep contacts
#define EXT_YTODEFBRD  0x00000010      // Limit Y movements to DEFBOARD
#define EXT_3DCOR      0x00000020      // Use 3-D corrections
#define EXT_CONTAIR    0x00000100      // Individual no contact capacity in air
#define EXT_CAIR       0x00000200      // Field/capacity correction in the air
#define EXT_CRTAIR     0x00000400      // CRT correction in the air
#define EXT_LAPAR      0x00000800      // Parallel LATEST contacting is allowed
#define EXT_EPAR       0x00001000      // Pads in EXACTR belong to same net
#define EXT_HVPARMASK  0x00202000      // Mask to extract parallel HV contacting
#define   EXT_HVGROUP  0x00000000      // As specified by panel/group/net
#define   EXT_HVPARAL  0x00002000      // Parallel HV contacting is allowed
#define   EXT_HVNOPAR  0x00200000      // Parallel HV contacting is disabled
#define   EXT_HVPANEL  0x00202000      // No parallel HV, except diff panels
#define EXT_NOLUT      0x00004000      // Disable use of camera LUT
#define EXT_WIDEXTOP   0x00008000      // Wide top X unlock area on S3
#define EXT_S3YMASK    0x00030000      // Mask to extract disabled S3 Y motors
#define   EXT_S3YLOFF  0x00010000      // Turn off left S3 Y shuttle motor
#define   EXT_S3YROFF  0x00020000      // Turn off right S3 Y shuttle motor
#define EXT_HCAMOFF    0x00100000      // Cycle camera power on comm error
#define EXT_DEFINED    0x80000000      // (Internal) Extended layout defined

// Extract from header of extended layout.
#define HCZ_VALID      0x80000000      // Z axis type in layout valid
#define HCZ_TESTPRLD   0x40000000      // Test pressure preload
#define HCZ_TYPEMAJOR  0x0F000000      // Major part of type (algorithms)
#define   HCZ_TMAJORA  0x00000000      // Parallelogramm with magnetoresistor
#define   HCZ_TMAJORC  0x01000000      // Ceramic stepper with Hall sensors
#define HCZ_TYPEMINOR  0x00F00000      // Minor part of type (parameters)
#define HCZ_TYPEMASK   0x0FF00000      // Mask to extract type of finger
#define   HCZ_TYPEA2G  0x00000000      // A2 gray parallelogramm
#define   HCZ_TYPEA2W  0x00100000      // A2 white parallelogramm
#define   HCZ_TYPEA3   0x00200000      // A3 gray parallelogramm
#define   HCZ_TYPECER  0x01000000      // S1 ceramic stepper with air bearings
#define   HCZ_TYPENO   0x0FF00000      // Z axis completely absent
#define HCZ_PWRMASK    0x000C0000      // Mask to extract Z motor power
#define   HCZ_PWRSTD   0x00000000      // Standard motor
#define HCZ_SUBCMASK   0x00030000      // Mask to extract needle subtype
#define   HCZ_SPLK4    0x00010000      // HCZ_CONTSPL is very soft K4 needle
#define HCZ_CONTMASK   0x0000FF00      // Mask to extract type of needle
#define   HCZ_CONTDEF  0x00000000      // Default needle, no contact sensor
#define   HCZ_CONTSPL  0x00000100      // Soft splinogramm with opto sensor
#define   HCZ_CONTHSPL 0x00000200      // Hard splinogramm with opto sensor
#define   HCZ_CONTEMU  0x00000400      // Standard needle on soft touch adapter
#define   HCZ_CONTHPS  0x00000500      // Hard touch needle with opto sensor
#define   HCZ_CONTSTD  0x00000800      // Standard needle, developed by IBM
#define   HCZ_CONTSKP  0x00001000      // Soft Kelvin with two parallelogramms
#define HCZ_STRMASK    0x000000F0      // Mask to extract Z stroke type
#define   HCZ_STRNORM  0x00000000      // Normal stroke
#define   HCZ_STRSOFT  0x00000010      // Soft stroke
#define   HCZ_STRHARD  0x00000020      // Hard stroke
#define   HCZ_LEARNZ   0x00000030      // Learned Z coordinate
#define   HCZ_HIPRESS  0x00000040      // High pressure with splinogramms
#define HCZ_DMSMASK    0x0000000C      // Mask for type of pressure sensor
#define   HCZ_DMSSTD   0x00000000      // Standard or no pressure sensor
#define   HCZ_DMSREV   0x00000004      // Pressure sensor with reverse signal
#define   HCZ_DMSAUTO  0x0000000C      // Autodetect type of pressure sensor
#define HCZ_OPTMASK    0x00000003      // Mask to extract Z options
#define   HCZ_NOOPT    0x00000002      // Do not optimize Z height
#define   HCZ_PARKZ    0x00000001      // Park top Z axes in home position

// Options of measurement card.
#define HCM_HV1MA      0x00000001      // Force 1 mA during HV measurements
#define HCM_STRICT     0x00000002      // 20% stricter self-test
#define HCM_NOCTCHK    0x00000004      // Don't check contacts (except ExactR)
#define HCM_PARCONT    0x00000008      // Check influence of parallel contacting
#define HCM_NOACCEL    0x00000010      // Do not accelerate reed relays
#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements
#define HCM_CTOEXT     0x00000040      // Calibrate capacity to shuttle (extant)
#define HCM_ISOEANT    0x00000080      // External antennas isolated
#define HCM_FILTMASK   0x00000F00      // Mask to extract signal filtering
#define   HCM_FNONE    0x00000000      // No signal filtering
#define   HCM_F500K    0x00000100      // 500 kHz filter
#define   HCM_F100K    0x00000200      // 100 kHz filter
#define   HCM_F20K     0x00000300      // 20/50 kHz filter
#define HCM_FILTERC    0x00001000      // Filter C measurements over 300 pF
#define HCM_EXRLONG    0x00002000      // Long EXACTR with 300 mA source
#define HCM_AUTOEANT   0x00004000      // Automatic antenna 1 for all C
#define HCM_HVTYPE     0x000F0000      // Mask to extract type of HV elecronics
#define   HCM_HV500    0x00000000      // Card is capable of 500 V HV
#define   HCM_HV1000   0x00010000      // Card is capable of 1000 V HV
#define   HCM_HVAUTO   0x00070000      // Autodetect HV capabilities
#define HCM_DISCONN    0x00100000      // Disconnect from bus after measurement
#define HCM_EXRNOISY   0x00200000      // Accept noisy EXACTR measurements

// Precise needle types in $EXTLAY.needletype.
#define NT_UNKNOWN     0               // Unspecified needle type
#define NT_HARD        1               // Solid hard touch
#define NT_HARDADAPT   2               // Hard touch adapter
#define NT_SPLINO      3               // Splinogramm
#define NT_MICROMIRR   4               // Microprobe with mirror
#define NT_MICRO       5               // Microprobe with transmissive sensor
#define NT_KELVMIRR    6               // Kelvin microprobe with mirror
#define NT_KELVIN      7               // Kelvin with transmissive sensor
#define NT_LATEST      8               // Kelvin with mirror and blades
#define NT_K4SPLINO    9               // K4 splinogramm
#define NT_MICROSHLD   10              // Shielded microprobe, transmissive

// Layout configuration bits in $LAY.config.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae

// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMSPLIT     0x20000000      // L&M auto split shuttle
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_SPLITAUTO   (LC_LMSPLIT|LC_A2LOADER)
#define LC_LMAUTO      (LC_LM|LC_A2LOADER)
#define LC_LMS2AUTO    (LC_LMS2|LC_A2LOADER)
#define LC_EPCOSAUTO   (LC_EPCOS|LC_A2LOADER)

// Features supported by crate controller.
#define CF_PRESSFACT   0x00000001      // Support for psensfact
#define CF_RETEST      0x00000002      // Instant retest (M_LIMITHI, M_LIMITLO)
#define CF_CAMINFO     0x00000004      // Support for S_DEBUG:0x48
#define CF_EXTSELF     0x00000008      // Extended self-test, D_EXTA5M/SLAVE5M
#define CF_FINECORR    0x00000010      // Support for S_LOARDUN:18/19
#define CF_FINEVAR     0x00000020      // S_LOARDUN:18/19 with variable step
#define CF_XCORR       0x00000040      // Support for S_LOADRUN:17
#define CF_3DCOR       0x00000080      // Supports 3-D calibration
#define CF_LONGLAY     0x00000100      // Supports additional layout extentions
#define CF_NANOMETER   0x00000200      // Supports sub-micrometer coordinates
#define CF_UNICKHZ     0x00000400      // M_UNIC supports kHz and ext device
#define CF_STROKEOPT   0x00000800      // Supports S_DEBUG:0x52, stroke options
#define CF_NETS        0x00001000      // Supports M_NETS
#define CF_CRATEXCOR   0x00002000      // Support for S_LOADRUN:17 to crate
<<<<<<< CALIBR.SCR
=======
#define CF_FULLCORR    0x00004000      // Support for S_LOADRUN:21
>>>>>>> 1.202

// Features supported by measurement card, set 1.
#define MF_CONTAIR     0x00000001      // Contact check corrections supported
#define MF_CRT         0x00000002      // CRT measurements supported
#define MF_KELVSCAN    0x00000004      // Kelvin scan supported
#define MF_FIXCDC      0x00000008      // Forcing charge-discharge in FastC
#define MF_CCORR       0x00000010      // Calibration of capacitive phase
#define MF_SLAVE       0x00000020      // Supports second measurement card
#define MF_CPHASE      0x00000040      // C phase corrections from layout
#define MF_MULTIC      0x00000080      // Multiple C supported
#define MF_DSCAN       0x00000100      // Charge-discharge scan supported
#define MF_CRTCONCE    0x00000200      // Permanent CRT calibration in air
#define MF_UNIC        0x00000400      // Universal C supported
#define MF_CONCE       0x00000800      // Permanent C calibration in air
#define MF_HVINITEX    0x00001000      // Extended HV initialization (meas card)
#define MF_POSTAIR     0x00002000      // C in air after M_FASTC (meas card)
#define MF_EXTMEAS     0x00004000      // External measurement device
#define MF_DMEM        0x00008000      // Read/write from Dallas memory (meas)
#define MF_RLIM        0x00010000      // Ordinary R with limits (meas)
#define MF_DATA        0x00020000      // Supports F_DATA
#define MF_FSCALE      0x00040000      // Field scales to default voltage
#define MF_XFIELD      0x00080000      // Extended field phase corrs (meas)
// Measurement features supported by crate.
#define MF_XFLDCRATE   0x00400000      // Extended field phase corrs (crate)
#define MF_RLIMCRATE   0x00800000      // Ordinary R with limits (crate)
#define MF_EXTLAINIT   0x01000000      // Extended S_LAINIT supported
#define MF_RETEST      0x02000000      // Instant retest (M_LIMITHI, M_LIMITLO)
#define MF_HVCRATEEX   0x04000000      // Extended HV initialization (crate)
#define MF_POSTCRATE   0x08000000      // C in air after M_FASTC (crate)
#define MF_RLINIT      0x10000000      // S_RLINIT supported (crate)
#define MF_DMEMCRATE   0x20000000      // Read/write from Dallas memory (crate)
#define MF_MULTICAL    0x40000000      // M_CALIBRATE supports multiple refs

// Features supported by measurement card, set 2.
#define MF2_LACONT     0x00000001      // LATEST contact power limit supported

// Type of automation.
#define AUTO_UNKNOWN   (-1)            // Unknown type of automation
#define AUTO_NONE      0x00            // Manual mode
#define AUTO_ERROR     0x01            // Attempt to get type was unsuccessfull
#define AUTO_DAMAGED   0x80            // Automation out of order
#define AUTO_SHUTTLE   0x81            // Automatic A2/A4/A6 shuttle
#define AUTO_A2        0x82            // Automatic A2 loader connected
#define AUTO_A4SEMI    0x83            // A4 output unit connected
#define AUTO_A4FULL    0x84            // Full A4 automation
#define AUTO_A6SEMI    0x85            // A6 output unit connected
#define AUTO_A6FULL    0x86            // Full A6 automation
#define AUTO_A5LMMAN   0x90            // A5 L&M automation in manual mode
#define AUTO_A5LMSEMI  0x91            // A5 L&M semiautomat
#define AUTO_A5LMFULL  0x92            // Full A5 L&M automation
#define AUTO_S2LMMAN   0x98            // S2 with manual shuttle
#define AUTO_S2LMSEMI  0x99            // S2 L&M in manual load/unload mode
#define AUTO_S2LMFULL  0x9A            // Full robotic S2 L&M automation
#define AUTO_S2LMDCF   0x9B            // S2 with double CF shuttle
#define AUTO_A7LMMAN   0xB0            // A7 L&M automation in manual mode
#define AUTO_A7LMSEMI  0xB1            // A7 L&M semiautomat
#define AUTO_A7LMFULL  0xB2            // Full A7 L&M automation
#define AUTO_A7LMNONE  0xB3            // A7 L&M pure manual mode
#define AUTO_A8LMMAN   0xB4            // A8a L&M automation in manual mode
#define AUTO_A8LMSEMI  0xB5            // A8a L&M semiautomat
#define AUTO_A8LMFULL  0xB6            // Full A8a L&M automation
#define AUTO_SPLITMAN  0xB8            // Split shuttle automation, manual mode
#define AUTO_SPLIT     0xBA            // Full split shuttle automation
#define AUTO_SPLNONE   0xBB            // Split shuttle automation, pure manual

// Illumination types ($EXTLAY.illumination).
#define ILL_DEFAULT    0x00            // Default (camera) illumination
#define ILL_EXTERN     0x01            // External (LED stripes)
#define ILL_MIXED      0x02            // Cameras and LED stripes
#define ILL_EXTON      0x03            // External, permanently on
#define ILL_FLASH      0x04            // Camera flashlight
#define ILL_FLASHMIX   0x05            // Camera flashlight and LED stripes on

// Manual verification modes.
#define MVM_SINGLE     0               // Verify single cross
#define MVM_X3         1               // Verify single cross 3 times
#define MVM_X10        2               // Verify single cross 10 times
#define MVM_1X3        3               // Verify 1x3 crosses
#define MVM_2X3        4               // Verify 2x3 crosses
#define MVM_3X3        5               // Verify 3x3 crosses
#define MVM_1X5        6               // Verify 1x5 crosses
#define MVM_2X5        7               // Verify 2x5 crosses
#define MVM_3X5        8               // Verify 3x5 crosses
#define MVM_MULTI      9               // Verify single cross from diff starts

#define MULTISTEP      0.1             // Step in MVM_MULTI mode, millimeters

// Manual verification groups.
#define MVG_SINGLE     0               // Verify single group
#define MVG_2X175      1               // Verify two groups at 175 mm
#define MVG_3X75       2               // Verify three groups at 75 mm
#define MVG_3X100      3               // Verify three groups at 100 mm
#define MVG_3X150      4               // Verify three groups at 150 mm

// Verification of limits.
#define NOSCDATA       32              // Length of oscillogramm
#define NLIMSTEP       100             // Number of steps

typedef struct t_calibr                // Calibrator structure
  int   mode                           // CM_xxx bits
  int   type                           // FILL_MECH, FILL_VIDEO or FILL_HCAM
  int   asymmetric                     // Asymmetric calibration (2 lines only)
  float refx0,refy0                    // Ideal reference point, mm
  float refx,refy                      // Actual reference point, mm
  int   hvcondok                       // (hvcondx0,hvcondy0) defined
  float hvcondx0,hvcondy0              // HV conditioning point, mm
  int   searchref                      // 1: request for search, 2: searching
  int   centralcross                   // SYNT_LEFT, SYNT_RIGHT or SYNT_CROSS
  int   forcekelvin                    // >0: starting from pad, Kelvin scan
  float widthx,widthy                  // Current width of calibration lines, mm
  float wstatx[5],wstaty[5]            // Width statistics
  float xa[NCALIBR],ya[NCALIBR]        // Absolute coordinates of point, mm
  float xm[NCALIBR],ym[NCALIBR]        // First approach and scan results, mm
  float wx[NCALIBR],wy[NCALIBR]        // Width of cross, electro scan only
  float z[NCALIBR]                     // Z coordinate of the cross
  int   scandir[NCALIBR]               // Direction of movements (0: direct)
  float scandist                       // Distance of movements, mm
  char  group[NCALIBR]                 // Group this cross belongs to
  char  err[NCALIBR]                   // 0 - ok, 1 - scan error, 2 - removed
  int   ncal                           // Number of points to calibrate
  int   next                           // Number of point being calibrated
  int   step                           // Step for the current point (0..3)
  float xt,yt                          // Intermediate scanning results
  int   z0,z1,z2,z3                    // Intermediate scanning results
  int   pending                        // Waiting for answer if non-zero
  int   autoclean                      // Attempt to clean Kelvin needles
  int   infield                        // Head or camera near some cross
  int   current                        // Cross being scanned by camera
  int   attempt                        // Number of attempts to scan given step
  int   rescan                         // Number of attempts to reduce shift
  int   timer                          // Used to make delay for video camera
  int   usesref                        // Reference which this finger uses
  float shrink                         // Calculated shrinkage of PCB
  float encdist                        // Distance from the central line, mm
  float radius                         // Length of ideal finger/headcam, mm
  float bottomliney                    // Y coordinate of bottom scan line
  float centerliney                    // Y coordinate of auxiliary scan line
  float topliney                       // Y coordinate of top scan line
  float centercamy                     // Y coordinate of central headcam line
  float leftprofilex                   // X coordinate of left profile line
  float rightprofilex                  // X coordinate of right profile line
  int   corrok                         // Correction table calculated
  float dpx[CORRX],dpy[CORRX]          // Splined corrections
  float dmx[CORRX],dmy[CORRX]          // Splined corrections
  float dr                             // Calculated deviation of length, mm
  float dteta                          // Calculated deviation of angle, rad
  int   excludefromfit                 // Exclude head from fitting
  float fit                            // Results of fitting
  float dx,dy,dfi                      // Best individual fit
  float sigmax,sigmay                  // Standard mean fitting deviations
  float wavexa[NWAVEL],waveya[NWAVEL]  // Points to measure waveness
  float wavedy[NWAVEL]                 // Measured Y deviations
  int   waveerr[NWAVEL]                // 0 - ok, 1 - scan error
  int   nwave                          // Number of test points in waveness
  float wavea                          // Wave half-amplitude, mm
  float wavefi                         // Wave phase on the middle point
  int   waveok                         // Parameters wavea and wavefi defined
  int   tstart                         // Time, ms, when calibration started
  int   tend                           // Time, ms, when calibration ended
  char  errmsg[80]                     // Error message
ends

typedef struct t_corr                  // Element of correction table
  $int2 dx                             // X correction, um
  $int2 dy                             // Y correction, um
ends

typedef struct t_fcorr                 // Element of fine correction table
  $float4 dx                           // X correction, um
  $float4 dy                           // Y correction, um
ends

typedef struct t_shycor                // Shuttle Y corrections
  int   key                            // 0x00594853 (L) or 0x00595253 (R)
  $float4 ystep                        // Distance between points in Y, um
  int   ny                             // No. of steps, total ny*2+1 points
  $float4 data[243]                    // X corr, Y corr (um), angle (rad)
ends

// Bits that control loading of corrections in Readoldcorr().
#define RC_ZERO        0x01            // Allow to zero corrections
#define RC_ZEROASK     0x02            // Allow to zero corrections if sure
#define RC_KEEP        0x04            // Allow to keep corrections
#define RC_AUTOLOAD    0x40            // Load corrections without asking
#define RC_ADJUST      0x80            // Adjustment of corrections is possible

#define CE_VALID       0x0000001       // Correction extention valid
#define CE_QUICK       0x0000002       // Quick head adjustment is allowed
#define CE_HEADCAM     0x0000010       // Head camera corrections are valid
#define CE_FINE        0x0000020       // Fine head corrections are valid

#define CE_VALIDHCAM   (CE_VALID|CE_HEADCAM)
#define CE_VALIDFINE   (CE_VALID|CE_FINE)

typedef struct t_cext                  // Extention of correction table
  int   mode                           // Set of CE_xxx
  $int2 caldate                        // Date of last calibration from layout
  $int2 corrcount                      // Number of remaining quick corrections
  $int4 optdata[4]                     // Offsets of optional corrections
  $int4 finehead                       // Offset of fine head corrections or 0
  $int2 finex0                         // First column of fcorr, center-based
  $int2 finenx                         // No. of columns in fine head corrs
  $int2 finey0                         // First row of fcorr, center-based
  $int2 fineny                         // No. of rows in fine head corrections
  $int2 finedx                         // Distance between fine head columns, um
  $int2 finedy                         // Distance between fine head rows, um
<<<<<<< CALIBR.SCR
  char  reserved[216]                  // Reserved for the future
=======
  // Cartesian corrections are described here.
  $int4 carthead                       // Offset of cartesian head corrs or 0
  $int4 carthcam                       // Offset of cartesian headcam corrs or 0
  $int2 cartx0                         // First column of cartcorr, center-based
  $int2 cartnx                         // No. of columns in cartesian corrs
  $int2 carty0                         // First row of cartcorr, center-based
  $int2 cartny                         // No. of rows in cartesian corrections
  $int2 cartdx                         // Distance between cartesian columns, um
  $int2 cartdy                         // Distance between cartesian rows, um
  $int4 carthead2                      // Offset of corrs for right shuttle or 0
  // Reserved data is reserved.
  char  reserved[192]                  // Reserved for the future
>>>>>>> 1.202
ends

#define CSY_VALID      0x00000001      // Structure t_csy is valid

typedef struct t_csy                   // Header of corrsy.cor
  int   mode                           // Set of CSY_xxx
  $int2 caldate                        // Date of last calibration from layout
  $int2 mbz                            // Reserved for the future, must be 0
  int   shycor0                        // Offset of t_shycor (left/only) or 0
  int   shycor1                        // Offset of t_shycor for right shuttle
  char  reserved[240]                  // Reserved for the future
ends

// Type of optional corrections.
#define COPT_IGNORE    0x00000000      // Block must be ignored
#define COPT_3D        0x00004433      // 3-D position of calibration board

#define MIN3DDIST      1000.0          // Min distance in 3-D calibration, um

typedef struct t_copt                  // Optional corrections, general layout
  $int4 key                            // One of COPT_xxx
  char  reserved[252]                  // Total size 256 bytes
ends

typedef struct t_3dcorr                // 3-D position of calibration board
  $int4 key                            // 0x00004433: 3-D board position
  $int4 date                           // Date of calibration
  $int4 mode                           // 0x0000001: 3-D data valid
  $float4 zcenter                      // Z of central point, um
  $float4 zfactorx                     // Z tilt of calibration board in X
  $float4 zfactory                     // Z tilt of calibration board in Y
  char  reserved[232]                  // Total size 256 bytes
ends

handle hmain                           // Main calibration window
handle hexit                           // Button "Close"
handle hserv,hleft,hright              // Left and right subwindows
handle hinfo                           // Current status of calibration
handle hlog                            // Log file

handle hfidgraph                       // Invisible window to create fiducials
int    fidgraphsize                    // X-Y size of hfidgraph

// Global events.
int    layoutchanged                   // Layout is changed
int    loadchanged                     // Loader is closed
int    globalerr                       // Global asynchronous error recognized
int    oversurface[32]                 // Number of contacts over surface
int    notreached[32]                  // Number of points not reached
int    demo                            // Run calibration in demo mode
int    startlayout                     // Start layout on finish
int    warnradius                      // Warn about non-standard radius
char   lmteachin[5][256]               // Learned shuttle settings
int    nlmteachin                      // Number of valid lmteachin
int    isglassboard                    // IsGlassBoard was set
float  oscmean[32][4]                  // Mean values from oscilloscope
int    oscvalid[32][4]                 // Whether oscmean[][] valid

// Values of variable verifymode.
#define VERIFY_ACC     0               // Verify accuracy
#define VERIFY_WAVE    1               // Verify wave
#define VERIFY_LIMITS  2               // Verify limits
#define VERIFY_MANUAL  3               // Verify manually
#define VERIFY_ZALIGN  4               // Verify Z alignment
#define VERIFY_CAMSTAB 5               // Verify camera stability
#define VERIFY_NEEDLES 6               // Verify micro needles
#define VERIFY_ZMARKS  7               // Verify Z end marks
#define VERIFY_REPLAY  8               // Replay calibration or verification

// Type of Y calibration.
#define PRY_STD        0               // Two-line calibration
#define PRY_3LINE      1               // Three-line calibration
#define PRY_YPROF      2               // Two-line plus two vertical lines

// State of corrections in tester.
#define CS_OLD         1               // Old corrections
#define CS_ZEROED      2               // Corrections are zeroed
#define CS_FILE        3               // Corrections from file

// Parameters used in both finger and camera calibration.
int    calmode                         // Main calibration mode, MODE_xxx
int    verifymode                      // Verification mode, one of VERIFY_xxx
int    wavenessdir                     // 0: horizontal line, 1: vertical
int    wavenesstype                    // 0: middle area, 1: full rail
float  wavenessvdist                   // Vertical distance from rail center
float  wavenesshdist                   // Horizontal distance from rail center
int    testertype                      // Type of tester (TT_xxx)
int    testersides                     // Bit 0x1: top, 0x2: bottom rails
int    topmask                         // Bitmask of top heads
int    bottommask                      // Bitmask of bottom heads
int    topmin,topmax                   // Top min/max rails
int    botmin,botmax                   // Bottom min/max rails
int    laytopmin,laytopmax             // Top min/max rails enabled in layout
int    laybotmin,laybotmax             // Bottom min/max rails enabled in layout
int    siderail                        // Rails per side
float  centerx,centery                 // Rotation center to fit verification
int    boardtype                       // 0: FR4, 1: glass, 2: MCM glass
int    twostep                         // 0: standard, 1: two-step, 2: two-board
int    largeboard                      // 1: A7W board in A7W
int    smallboard                      // 1: A5 in A5L, S2/8S in S2/8L etc.
int    smallfirst                      // First rail for small board or -1
int    smalllast                       // Last rail for small board or -1
int    unloadboard                     // Whether to unload board after test
float  boardshift                      // X shift of board center, millimeters
float  calxmin,calxmax                 // Board extent in X direction
float  calymin,calymax                 // Board extent in Y direction
float  calystep                        // Vertical step between fiducials
int    idealboard                      // 1: assume board ideal
int    operator                        // 1: don't confirm data saving
int    autoconfirm                     // 1: autoconfirm non-critical errors
int    tstart                          // Moment when calibration started
int    autoverify                      // Check reproducibility of scanning
int    autoverified                    // Reproducibility checked
int    measureoffset                   // Measure top-to-bottom offset
int    lowspeed                        // Reduce accelerations
int    usehvconditioning               // Use HV conditioning if no contact
float  linewidth                       // Width of lines, millimeters
float  accuracy                        // Calibration accuracy, millimeters
int    acc                             // Positioning accuracy, micrometers
int    videoonly                       // 1: fingers are completely excluded
float  fromx,tox                       // Full X area to be calibrated, mm
float  fromxloc,toxloc                 // Board X area to be calibrated, mm
int    verification                    // 1: verification, 2: system data
float  boardx                          // X coordinate of board in shuttle
float  boardy                          // Y coordinate of board in shuttle
float  boardxcorr                      // X correction of board position
float  boardycorr                      // Y correction of board position
int    layvalid                        // Layout in tester is same as on disk
int    corrvalid                       // Corrections in tester same as on disk
int    corrsource                      // Correction source, one of CS_xxx
int    diskvalid                       // Layout and corrections on disk match
int    cratefeatures                   // Features of crate, set of CF_xxx
int    measfeatures                    // Features of measurement card, MF_xxx
int    measfeatures2                   // Features of measurement card, MF2_xxx
int    automationtype                  // Type of automation, AUTO_xxx
int    isauto                          // Whether half- or full-automate
float  fillshy                         // Shuttle Y coordinate for C_SHY
int    mverifyrail                     // Rail in manual verification
int    mverifyx                        // X manual cross index (center-based)
int    mverifyy                        // Y manual cross index (center-based)
int    mverifymode                     // Manual verification mode, MVM_xxx
int    mverifygroups                   // Manual verification groups, MVG_xxx
float  mverifyxpos                     // X coordinate, mm
float  mverifyypos                     // Y coordinate, mm
int    mverifycount                    // Repeat count for mode 11
int    mverifydir                      // Allowed move directions, bits BTLR
int    preloadok                       // Splino preload force was confirmed
int    disable3d                       // 3-D calibration not possible
int    adjustcorr                      // Adjust existing corrections
float  axhead,ayhead                   // X-Y accelerations of the heads
float  axcam,aycam                     // X-Y accelerations of dedicated cameras
int    pulledshuttle                   // Shuttle for A8eaPreparePullCalib or -1

// Parameters used in finger calibration.
int    firsttop,lasttop                // Set of involved top rails
int    firstbot,lastbot                // Set of involved bottom rails
int    usesides                        // Sides to calibrate (0x1:top, 0x2:bot)
int    throwaway                       // Calibrate each throwaway-th point
int    interlace                       // 1: interlaced scanning
int    precisey                        // Y calibration, one of PRY_xxx
int    singleref                       // 1: use 1 reference finger per side
int    softland                        // 1: activate soft landing
int    kelvinscan                      // 1: no ref, 2: on line, 3: ext ant
int    globref[2]                      // Head selected as reference on side
int    warmuptime                      // Warmup time, seconds
int    softtouch                       // A5/A6 with soft touch needles
float  xstep,ystep                     // Correction grid, millimeters
float  radius                          // Length of ideal finger, millimeters
float  encdist                         // Distance from the central line, mm
float  extralen                        // Correction of finger radius, mm
float  distance                        // Distance from the cross, mm
float  refsizex                        // X size of reference points, mm
float  refsizey                        // Y size of reference points, mm
int    v                               // Z stroke during calibration
int    p                               // Z pressure during calibration
float  z                               // Z height set by operator
float  zscan                           // Z height used during calibration
int    exactfit=0                      // Use exact splines, no looseness
int    hverifytype                     // Type of finger verification
int    quickcorrdisabled               // 1: quick corrections disabled
int    quickcorrected[32]              // 1: this head is already corrected
int    assumeemptyshuttle              // 1: assume that shuttle is empty
int    cleankelvin                     // Head to clean in Kelvin calibration

// Parameters used in video calibration.
int    cameras                         // Dedicated cameras used in calibration
int    headcams                        // Head cameras used in calibration
int    symmetricheadcams               // Shinethrough with head cams allowed
int    cameramode                      // 0: precise, 1: standard, 2: quick
int    noclip                          // 0: clip, 1: don't clip out needles
int    illumination                    // 0: direct, 1: shinethru
int    flashthru                       // 1: OllyTest supports flash shinethru
float  oppdx                           // Specified X offset of opposite camera
float  oppdy                           // Y offset for head cameras
float  throughdx,throughdy             // Offset of second camera in shinethru
float  videoy                          // Y grid of video camera, millimeters
float  videoyfromcrate                 // Y grid of S3 camera reported by crate
float  videofromx,videotox             // X area to be calibrated, mm
float  videofromy,videotoy             // Y area to be calibrated, mm
float  videosafedist                   // Safe distance between cameras, mm
float  maxdelta                        // Max allowed deviation from the cross
int    vverifytype                     // Type of video verification

// Individual per-camera brightness and contrast.
int    individualbc                    // Whether individual brightness/contrast
handle hbrititle                       // Brightness title
handle hbrightness                     // Brightness control
handle hctrtitle                       // Contrast title
handle hcontrast                       // Contrast control
handle hilltop                         // Top illumination control
handle hillskew                        // Skew illumination control
handle hilllong                        // Long exposition control
handle hfoctitle                       // Focus title
handle hfocusup                        // Focus up
handle hfocus                          // Z camera position
handle hfocusdn                        // Focus down

int    illtype                         // Illumination (0x3:on,0x4:top,0x8:skew)
int    longexp                         // Long exposition
int    brightness[32][3]               // Individual brightness settings
int    contrast[32][3]                 // Individual contrast settings
int    bchead                          // Head selected for individual bri/ctr
int    bcindex                         // Position index for bchead
int    focus[2]                        // Focus position of dedicated camera
int    updatefocus[2]                  // Set focus of dedicated camera

// Items specific to calibration of dedicated cameras.
float  videocorrectx[2]                // Corrections of X camera centers, mm
float  videocorrecty[2]                // Corrections of Y camera centers, mm
float  videocenterx[2]                 // X offset of camera centers, mm
float  videocentery[2]                 // Y offset of camera centers, mm
float  videohysteresisx[2]             // X hysteresis of camera, mm
float  videohysteresisy[2]             // Y hysteresis of camera, mm
float  videolength                     // Y coordinate of X camera encoder
int    videoheight[2]                  // Height of CCD, pixels
int    videowidth[2]                   // Width of CCD, pixels
float  videofactor[2]                  // Multiplier for line width
handle videomodel[2]                   // Video models used for scanning
handle videoaltmodel[2]                // Alternative models used for scanning
float  mminpixelx[2]                   // Camera millimeters per pixel X
float  mminpixely[2]                   // Camera millimeters per pixel Y
int    zoomin                          // Zoom x2, quick head correction only

// Items specific to calibration of head cameras.
float  headcamradius                   // Radius of head cameras, millimeters
float  headcamscale[32]                // Camera millimeters per pixel X & Y
float  headcamwfactor[32]              // Multiplier for line width
float  headcamsfactor[32]              // Multiplier for distance
handle headcammodel[32]                // Fiducial models for head cameras
handle headaltmodel[32]                // Alternative models for head cameras
float  headthrudx[32][3]               // Throughshine dX, mm (bot/ctr/top)
float  headthrudy[32][3]               // Throughshine dY, mm (bot/ctr/top)
float  headcamolddx[32]                // Old X head camera offset, mm
float  headcamolddy[32]                // Old Y head camera offset,mm
int    headcamfidtype                  // 0,1: SYNT_LEFT, 2: SYNT_RIGHT
int    headcamtypevalid                // 1: headcamfidtype is valid
int    rotateimage                     // 1: rotate image from the head camera

// Local structures necessary for calibration.
struct t_calibr c[32]                  // Array of calibrator structures
struct t_calibr cfing[32]              // Backup for heads and dedicated cameras
struct t_calibr chcam[32]              // Backup for head cameras
struct t_corr   corr[32][CORRX,CORRY]  // Correction tables
struct t_corr   cnew[32][CORRX,CORRY]  // Corrected correction tables
struct t_cext   cext[32]               // Correction extention
struct t_copt   copt[32][4]            // Old optional correction data
struct t_3dcorr c3dold[32]             // Old position of calibration board
struct t_3dcorr c3dnew[32]             // New position of calibration board
<<<<<<< CALIBR.SCR
struct t_corr   hcam[32][CORRX,CORRY]  // Corrections of head cameras
struct t_fcorr  fcorr[32][FINEX,FINEY] // Fine correction tables
struct t_corr   corrl[32][CORRX,CORRY] // Correction tables left for two-step
struct t_corr   hcaml[32][CORRX,CORRY] // Corrections of head cameras left
struct t_shycor shycor                 // Shuttle Y corrections, valid if ny>0
=======
struct t_corr   hcam[32][GRIDX,GRIDY]  // Corrections of head cameras
struct t_corr   corrl[32][GRIDX,GRIDY] // Correction tables left for two-step
struct t_corr   hcaml[32][GRIDX,GRIDY] // Corrections of head cameras left
struct t_fcorr  camr[2][GRIDX,GRIDY]   // Corr of camera for right shuttle
int             camrvalid[2]           // Validity of camr[]
struct t_shycor shycor[2]              // Shuttle Y corrections (left/right)
>>>>>>> 1.202

// Rotational nonidealities measured in Y profile calibration.
int    diffvalid[32][CORRY]            // Validity of rdiff[] and fidiff[]
float  rdiff[32][CORRY]                // Radius differences, micrometers
float  fidiff[32][CORRY]               // Angle differences, um at needle tip

// Parameters used in capacity adjust.
float  cadjax,cadjbx                   // Linear regression factors for X
float  cadjay,cadjby                   // Linear regression factors for Y

external int SERV.Ohmsshort(float r,int status,char *s);
external int SERV.Decodeanswer(char *answer,char *text,char *extra,int mask);
external int SERV.Convertfield(char *answer,float *zc,float *zr);
external int SERV.Convertfastc(char *answer,float *zc,float *zr);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// INTERRUPT HANDLER ///////////////////////////////

// Interrupt handler, receives and processes asynchronous messages and errors.
function int Answerproc(char *answer,int info)
  int i,head,n,channel,sum
  char s[512],extra[2048]
  if answer[4]==0xF0 then
    // Internal OLLYTEST message.
    if Stricmp(answer+5,"CHG LAY")==0 layoutchanged=1
    if Stricmp(answer+5,"CHG LOAD")==0 loadchanged=1
    return
  else if answer[4]==S_ERROR then
    // Error messages, also with zero ID.
    if hlog!=NULL then
      SERV.Decodeanswer(answer,s,extra,0x7FFFFFFF)
      fprintf(hlog,"ERROR: %s\n",s)
    endif
    switch answer[5]
    case E_NOCRATDATA,E_NOFINGDATA:
      globalerr=globalerr|GE_BOOT
    case E_ZMOVEMENT:
      if answer[9]==2 && answer[7]!=0xFF then
        i=answer[7]*2+((answer[8] & 0x4C)==0?0:1)
        oversurface[i]++               // Count number of contacts over PCB
      endif
    case E_COMMUTATOR:
      i=$uint2(answer+10)
      if (i & 0x0300)!=0 globalerr=globalerr|GE_MEAS
    case E_TMEAS:
      if answer[9]>=2 globalerr=globalerr|GE_MEAS
    case E_TIMEOUT:
      if answer[9]==3 && answer[7]!=0xFF then
        i=answer[7]*2+((answer[8] & 0x4C)==0?0:1)
        notreached[i]++                // Count number of not reached points
      endif
    case E_IOERROR:
      // Serial I/O errors are considered non-critical for A5/S1.
      if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&       \
        testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&         \
        testertype!=TT_A7 && testertype!=TT_A8 then
        globalerr=globalerr|GE_IOERROR
      endif
    case E_WRONGCOORD,E_BADCOMMAND,E_BADCMDSIZE,E_TABLEOVERF,E_BADDATA:
      globalerr=globalerr|GE_COMMAND
    case E_SYNC,E_DIVBYZERO:
      globalerr=globalerr|GE_COMMAND
    case E_CONTACT,E_HISHIFT,E_SHORTCUT:
      globalerr=globalerr|GE_MEAS
    case E_INITMEAS:
      i=$uint2(answer+10)
      if (i & 0x7D)!=0 globalerr=globalerr|GE_MEAS
    case E_BOXSENS,E_PNEUMOSENS,E_PNEUMOSYS:
      globalerr=globalerr|GE_HARDWARE
    endsw
  else if answer[4]==S_TEST && answer[5]==0x03 && $uint2(answer+2)==0 &&       \
    $uint2(answer+8)==NOSCDATA && $uint2(answer+10)==0 then
    // Oscilloscope data.
    head=answer[6] & 0x1F
    channel=answer[7] & 0x03
    sum=0
    for i=0,i<NOSCDATA,i++ do
      sum=sum+$float4(answer+14+i*4)
    enddo
    oscmean[head][channel]=sum/NOSCDATA
    oscvalid[head][channel]=1
  endif
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// MATHEMATICAL ROUTINES /////////////////////////////

// Prepares array disp[5] to accumulate statistical data.
function int Initsigma(float disp[])
  disp[0]=0.0
  disp[1]=0.0
  disp[2]=0.0
  disp[3]=0.0
  disp[4]=0.0
end

// Function adds next measured value to array disp[5] which accumulates data
// necessary to calculate normal dispersion, mean, minimal and maximal.
function int Addsigma(float disp[],float value)
  if disp[0]<=0.0 then
    disp[0]=1.0                        // First point, data is still undefined
    disp[1]=value
    disp[2]=value*value
    disp[3]=value
    disp[4]=value
  else
    disp[0]=disp[0]+1.0
    disp[1]=disp[1]+value
    disp[2]=disp[2]+value*value
    disp[3]=Min(disp[3],value)
    disp[4]=Max(disp[4],value)
  endif
end

// Function returns number of data items gathered by Addsigma().
function int Getcount(float disp[])
  return disp[0]
end

// Function calculates mean value based on data gathered by Addsigma().
function float Getmean(float disp[])
  if disp[0]<1.0 then
    return 0.0
  else
    return disp[1]/disp[0]
  endif
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmin(float disp[])
  return disp[3]
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmax(float disp[])
  return disp[4]
end

// Function calculates normal dispersion based on data gathered by Addsigma().
function float Getsigma(float disp[])
  float r
  if disp[0]<2.0 then
    return 0.0
  else
    r=(disp[0]*disp[2]-disp[1]*disp[1])/disp[0]/(disp[0]-1.0)
    if r<=0 then                       // Possible due to rounding errors
      return 0.0
    else
      return Sqrt(r)
    endif
  endif
end

// Smoothes set of equidistant data points of length n using polinomial
// approximation of 3rd order over 5 points.
function int Smooth35(float *y,int n)
  int i
  float a,b,c,d
  if n<5 return
  b=y[0]; c=y[1]
  for i=5,i<=n,i++ do
    a=b; b=c; c=y[i-3]
    d=c-b-y[i-2]
    d=d+d+c
    d=d+d+a+y[i-1]
    if i==5 then
      y[0]=a-0.01428571428*d
      y[1]=b+0.05714285714*d
    endif
    y[i-3]=c-0.08571428571*d
  enddo
  y[n-2]=y[n-2]+0.05714285714*d
  y[n-1]=y[n-1]-0.01428571428*d
end

// Calculates value of data point that has "index" p. Uses simple linear
// interpolation between precalculated adjacent points.
function float Interpolate(float data[],int n,float p)
  int i
  float d
  i=Floor(p)
  i=Max(0,Min(i,n-2))
  d=p-i
  return data[i]*(1.0-d)+data[i+1]*d
end

// Calculates parabolic curve y=a*(x-x0)**2+z0 through n equidistant points
// y[-n/2],y[-n/2+1],..,y[n/2] (n must be odd integer) using best fit in the
// sense of least squares.
function int Parabint(float y[],int n,float *a,float *x0,float *z0)
  int i,j
  float sy,sxy,sxxy,sx,sxx,sx3,sx4,q1,q2,q3,p1,p2,p3,pq,b,c
  sy=0.0; sxy=0.0; sxxy=0.0; sx=0.0; sxx=0.0; sx3=0.0; sx4=0.0
  for i=0,i<n,i++ do
    j=i-n/2
    sy=sy+y[i]; sxy=sxy+j*y[i]; sxxy=sxxy+j*j*y[i]
    sx=sx+j; sxx=sxx+j*j; sx3=sx3+j*j*j
    sx4=sx4+(j*j*1.0)*j*j              // Beware of overflows
  enddo
  q1=sx3-sx*sxx/n
  q2=sxx-sx*sx/n
  q3=sxy-sx*sy/n
  p1=sx4-sxx*sxx/n
  p2=sx3-sxx*sx/n
  p3=sxxy-sy*sxx/n
  pq=p1*q2-p2*q1
  if pq==0 then
    a[0]=0.0
  else
    a[0]=(p3*q2-q3*p2)/pq
  endif
  if q2==0 then
    b=0.0
  else
    b=(q3-a[0]*q1)/q2
  endif
  c=(sy-a[0]*sxx-b*sx)/n
  if a[0]==0 then
    x0[0]=0
  else
    x0[0]=-b/2.0/a[0]
  endif
  z0[0]=c-a[0]*x0[0]*x0[0]
end

// Solves a well-defined system of linear equations in form A*X=B using
// Gaussian elimination. Vector X[N] is returned in b. Matrix A[N,N] remains
// unchanged. N is limited to 24. Returns 0 on success and -1 on error or if
// there is no single solution.
function int Solvelinear(float a[],float b[],int n)
  int i,ii,j,ipivot
  float aa[24,24],pivot,r
  if n<1 || n>24 return -1             // Error in input parameters
  // To preserve input matrix, copy it into a. Ollytest passes matrices as
  // linear arrays.
  for i=0,i<n,i++ do
    for j=0,j<n,j++ do
      aa[i][j]=a[i*n+j]
    enddo
  enddo
  // Bring matrix to the echelon form.
  for i=0,i<n-1,i++ do
    // Find pivot in column i.
    pivot=0.0
    for ii=i,ii<n,ii++ do
      if Abs(aa[ii][i])>Abs(pivot) then
        pivot=aa[ii][i]
        ipivot=ii
      endif
    enddo
    if Abs(pivot)<1.0e-99 return -1    // No definite solution
    // Exchange rows i and ipivot.
    if i!=ipivot then
      for j=i,j<n,j++ do
        r=aa[i][j]; aa[i][j]=aa[ipivot][j]; aa[ipivot][j]=r
      enddo
      r=b[i]; b[i]=b[ipivot]; b[ipivot]=r
    endif
    // Eliminate rest of column i.
    for ii=i+1,ii<n,ii++ do
      r=aa[ii][i]/pivot
      for j=i+1,j<n,j++ do
        aa[ii][j]=aa[ii][j]-aa[i][j]*r
      enddo
      b[ii]=b[ii]-b[i]*r
    enddo
  enddo
  // Check last remaining pivot.
  if Abs(aa[i][i])<1.0e-99 return -1   // No definite solution
  // Backtrack the solution.
  for i=n-1,i>=0,i-- do
    b[i]=b[i]/aa[i][i]
    for ii=0,ii<i,ii++ do
      b[ii]=b[ii]-b[i]*aa[ii][i]
    enddo
  enddo
  // Report success.
  return 0
end


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// SERVICE ROUTINES ///////////////////////////////

// Writes record to c:\hardware\calibrationlog.txt. Returns 0 on success and -1
// on error.
function int Addcalibrationrecord(format message)
  handle f
  char s[256]
  f=Fopen("c:\\hardware\\calibrationlog.txt","at")
  if f==NULL return -1
  Strtime(s,"%a %d-%b-%Y %H:%M",0,0)
  fprintf(f,"%s    Calibr v%s  %s\n",s,VERSION,message)
  Fclose(f)
  return 0
end

// Gives user chance to skip unimportant calibration step within 2.5 seconds.
// Returns 1 if step is skipped, -1 if user cancelled calibration and 0 if step
// should continue.
function int Waitcancel(handle hcancel)
  int t
  t=Time()
  while Time()-t<2500 do
    if Pressed(hcancel) return 1
    if Pressed(hexit) return -1
    wait
  enddo
  return 0
end

// Given head and headcam flag, calculates corrections (dx,dy) for coordinates
// (x,y). If headcam is 0, corrections are for the head, if 1 - for head camera
// and if 2 - temporary corrections.

///---------------IF FINE CORRECTIONS AVAILABLE, USE THEM!!!!!!!!

function int Getcorr(int head,int headcam,float x,float y,float *dx,float *dy)
  int i,j
  float ys,wx,wy
  // Get y step.
  if head<$LAY.nfing*2 then
    ys=ystep
  else
    ys=videoy
  endif
  if xstep==0.0 || ys==0.0 then
    // Error in input parameters.
    dx[0]=0.0
    dy[0]=0.0
    return -1
  endif
  // Get indices of the bottom left grid point containing (x,y).
  i=Floor((x-$LAY.xoffset/1000.0)/xstep)+CENTERX
  if i<0 then
    i=0
  else if i>=CORRX then
    i=CORRX-1
  endif
  j=Floor((y-$LAY.yoffset[head/2]/1000.0)/ys)+CENTERY
  if j<0 then
    j=0
  else if j>=CORRY then
    j=CORRY-1
  endif
  // Get weights. If point is outside the grid, may be outside [0..1] range!
  wx=(x-((i-CENTERX)*xstep+$LAY.xoffset/1000.0))/xstep
  wy=(y-((j-CENTERY)*ys+$LAY.yoffset[head/2]/1000.0))/ys
  // Calculate corrections.
  if headcam==0 then
    dx[0]=((corr[head][i,j].dx*(1.0-wx)+corr[head][i+1,j].dx*wx)*(1.0-wy)+     \
    (corr[head][i,j+1].dx*(1.0-wx)+corr[head][i+1,j+1].dx*wx)*wy)/1000.0
    dy[0]=((corr[head][i,j].dy*(1.0-wx)+corr[head][i+1,j].dy*wx)*(1.0-wy)+     \
    (corr[head][i,j+1].dy*(1.0-wx)+corr[head][i+1,j+1].dy*wx)*wy)/1000.0
  else if headcam==1 then
    dx[0]=((hcam[head][i,j].dx*(1.0-wx)+hcam[head][i+1,j].dx*wx)*(1.0-wy)+     \
    (hcam[head][i,j+1].dx*(1.0-wx)+hcam[head][i+1,j+1].dx*wx)*wy)/1000.0
    dy[0]=((hcam[head][i,j].dy*(1.0-wx)+hcam[head][i+1,j].dy*wx)*(1.0-wy)+     \
    (hcam[head][i,j+1].dy*(1.0-wx)+hcam[head][i+1,j+1].dy*wx)*wy)/1000.0
  else
    dx[0]=((cnew[head][i,j].dx*(1.0-wx)+cnew[head][i+1,j].dx*wx)*(1.0-wy)+     \
    (cnew[head][i,j+1].dx*(1.0-wx)+cnew[head][i+1,j+1].dx*wx)*wy)/1000.0
    dy[0]=((cnew[head][i,j].dy*(1.0-wx)+cnew[head][i+1,j].dy*wx)*(1.0-wy)+     \
    (cnew[head][i,j+1].dy*(1.0-wx)+cnew[head][i+1,j+1].dy*wx)*wy)/1000.0
  endif
end

// Service function, reads actual X-Y head and camera accelerations from the
// crate in meters per second square. Returns 0 on success, 1 on error and -1
// if user interrupted the test.
function int Getaccel(float *axhead,float *ayhead,float *axcam,float *aycam)
  int t
  char buf[128]
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
    return 1                           // Unsupported function
  if demo return 0
  // Send command.
  SYS.Killimm(32)
  buf[0]=S_DEBUG
  buf[1]=0x23                          // Query original movement parameters
  SYS.Sendimm(32,2,buf)
  // Wait for answer.
  t=Time()
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>2000  return 1         // Timeout
    wait
  enddo
  if $A[32].answer!=S_DEBUG return 1   // Unsupported function
  // Extract data.
  axhead[0]=$float4($A[32]+5)
  ayhead[0]=$float4($A[32]+5+16)
  axcam[0] =$float4($A[32]+5+32)
  aycam[0] =$float4($A[32]+5+48)
end

// Service function, sets new X-Y head and camera accelerations(meters per
// second square). To restore original parameters, set corresponding items to
// zero. Returns 0 on success, 1 on erorr and -1 if user interrupted the test.
function int Setaccel(float axhead,float ayhead,float axcam,float aycam)
  int t
  char buf[128]
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
    return 1                           // Unsupported function
  if demo return 0
  // Send command.
  SYS.Killimm(32)
  Memset(buf,0,66)
  buf[0]=S_DEBUG
  buf[1]=0x24                          // Set movement parameters
  $float4(buf+2   )=axhead
  $float4(buf+2+16)=ayhead
  $float4(buf+2+32)=axcam
  $float4(buf+2+48)=aycam
  SYS.Sendimm(32,66,buf)
  // Wait for answer.
  t=Time()
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>5000 return 1          // Timeout
    wait
  enddo
  delay 100                            // Just to be sure
  if $A[32].answer!=S_DEBUG return 1   // Unsupported function?
end

// Debugging function, asks operator to press OK.
function int Pause(format s)
  handle hok
  change hinfo text="Please press 'OK'"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text=format("Debugging pause, reason: '%s'. Please press ",s)
  draw font=MAINFONT text="OK" font=TIMESFONT text=".\n\nIf you see this "
  draw text="message, then calibration script you are using is an "
  draw text="experimental version."
  draw show
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY,120,24
    name="OK"
    help="Press to continue"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hok) then
      return 0
    endif
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// VIDEO SUPPORT ROUTINES ////////////////////////////

// Given video channel, returns head that carries corresponding video camera,
// or -1 if channel is invalid or not assigned.
function int Headfromchannel(int channel)
  int head,n
  if $LAY.cameras!=0 then
    if channel==0 return $LAY.nfing*2
    if channel==1 return $LAY.nfing*2+1
  else
    n=0
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      if channel==n return head
      n++
    enddo
  endif
  return -1
end

// Reciprocal to Headfromchannel(). Given head, returns associated video
// channel, or -1 if head is invalid or carries no camera.
function int Channelfromhead(int head)
  int i,channel
  if $LAY.cameras!=0 then
    if head==$LAY.nfing*2 return 0
    if head==$LAY.nfing*2+1 return 1
  else if ($LAY.headcameras & (1<<head))!=0 then
    channel=0
    for i=0,i<head,i++ do
      if ($LAY.headcameras & (1<<i))!=0 channel++
    enddo
    return channel
  endif
  return -1
end

// Service function, giveh head camera returns head camera on the opposite side.
function int Oppositeheadcam(int head)
  int nfing,opprail
  if symmetricheadcams==0 return -1
  nfing=$LAY.nfing
  opprail=((head+nfing)/2)%nfing
  // Try to select opposite camera on th esame left or right side first.
  if (head & 1)==0 && (headcams & (1<<(opprail*2)))!=0 then
    return opprail*2
  else if (head & 1)==0 && (headcams & (1<<(opprail*2+1)))!=0 then
    return opprail*2+1
  else if (head & 1)!=0 && (headcams & (1<<(opprail*2+1)))!=0 then
    return opprail*2+1
  else if (head & 1)!=0 && (headcams & (1<<(opprail*2)))!=0 then
    return opprail*2
  else
    return -1
  endif
end

// Service function, given X-Y coordinates, calculates head coordinates of the
// opposite camera to illuminate point X-Y. Doesn't work for dedicated cameras.
function int Oppositexy(float x,float y,int opp,float *oppx,float *oppy,float d)
  float yoffset,fi
  yoffset=$LAY.yoffset[opp/2]/1000.0
  fi=Abs(Asin((y-yoffset)/radius))
  if (opp & 1)==0 then
    oppx[0]=x+oppdx*Cos(fi)+oppdy*Sin(fi)
  else
    oppx[0]=x-oppdx*Cos(fi)-oppdy*Sin(fi)
  endif
  if y<yoffset-encdist/2.0 then
    oppy[0]=y-oppdx*Sin(fi)+oppdy*Cos(fi)
  else
    oppy[0]=y+oppdx*Sin(fi)-oppdy*Cos(fi)
  endif
  if y<yoffset-encdist/2.0 then
    oppx[0]=oppx[0]+headthrudx[opp][0]+d*0.7*(opp & 1?(-1.0):1.0)
    oppy[0]=oppy[0]+headthrudy[opp][0]+d*0.7
  else if y>yoffset+encdist/2.0 then
    oppx[0]=oppx[0]+headthrudx[opp][2]+d*0.7*(opp & 1?1.0:(-1.0))
    oppy[0]=oppy[0]+headthrudy[opp][2]+d*0.7
  else
    oppx[0]=oppx[0]+headthrudx[opp][1]
    oppy[0]=oppy[0]+headthrudy[opp][1]+d
  endif
  oppx[0]=Max($LAY.leftlimit/1000.0,Min(oppx[0],$LAY.rightlimit/1000.0))
  if oppy[0]<($LAY.bottom[opp/2]+1)/1000.0-MAXCORRY then
    oppy[0]=($LAY.bottom[opp/2]+1)/1000.0-MAXCORRY
  else if oppy[0]>($LAY.top[opp/2]-2)/1000.0+MAXCORRY then
    oppy[0]=($LAY.top[opp/2]-2)/1000.0+MAXCORRY
  endif
end

// Service function, given X-Y coordinates, calculates camera coordinates of
// the opposite camera to illuminate point X-Y. Doesn't work for dedicated
// cameras.
function int Oppositexycam(float x,float y,int opp,                            \
  float *oppx,float *oppy,float d)
  float yoffset,fi
  yoffset=$LAY.yoffset[opp/2]/1000.0
  fi=Abs(Asin((y-yoffset)/headcamradius))
  if (opp & 1)==0 then
    oppx[0]=x+oppdx*Cos(fi)+oppdy*Sin(fi)
  else
    oppx[0]=x-oppdx*Cos(fi)-oppdy*Sin(fi)
  endif
  if y<yoffset-encdist/2.0 then
    oppy[0]=y-oppdx*Sin(fi)+oppdy*Cos(fi)
  else
    oppy[0]=y+oppdx*Sin(fi)-oppdy*Cos(fi)
  endif
  if y<yoffset-encdist/2.0 then
    oppx[0]=oppx[0]+headthrudx[opp][0]+d*0.7*(opp & 1?(-1.0):1.0)
    oppy[0]=oppy[0]+headthrudy[opp][0]+d*0.7
  else if y>yoffset+encdist/2.0 then
    oppx[0]=oppx[0]+headthrudx[opp][2]+d*0.7*(opp & 1?1.0:(-1.0))
    oppy[0]=oppy[0]+headthrudy[opp][2]+d*0.7
  else
    oppx[0]=oppx[0]+headthrudx[opp][1]
    oppy[0]=oppy[0]+headthrudy[opp][1]+d
  endif
end

// Calculates position of the opposite camera: 0 - bottom line, 1 - middle
// line, 2 - top line.
function int Getyindex(int head,float y)
  int index
  if illumination!=1 then
    index=1                            // No shinethrough: same brightness
  else if boardtype!=1 && boardtype!=2 then
    index=1                            // FR4 board: same brightness
  else if head<0 || head>=$LAY.nfing*2 then
    index=1                            // Dedicated camera: same brightness
  else if individualbc==0 then
    index=1                            // Single brightness for all
  else if y<$LAY.yoffset[head/2]/1000.0-encdist/2.0 then
    index=0                            // Bottom line
  else if y>$LAY.yoffset[head/2]/1000.0+encdist/2.0 then
    index=2                            // Top fiducial
  else
    index=1                            // Central fiducial
  endif
  return index
end

// Reads individual per-camera brightness, contrast, illumination type and
// focal coordinate from .ini file.
function int Bcgetini()
  int n,head,bri,ctr
  char key[32]
  // Get defaults for the first run.
  illtype=0x03; longexp=0;
  getini("Video","Illumination type","%i,%i",&illtype,&longexp)
  bri=0; getini("ScrollAutoSave","Brightness","%i",&bri)
  ctr=0; getini("ScrollAutoSave","Contrast","%i",&ctr)
  focus[0]=-1000; getini("Video","Camera focus[0]","%i",focus+0)
  focus[1]=-1000; getini("Video","Camera focus[1]","%i",focus+1)
  for head=0,head<32,head++ do
    brightness[head][1]=bri
    brightness[head][0]=bri
    brightness[head][2]=bri
    contrast[head][1]=ctr
    contrast[head][0]=ctr
    contrast[head][2]=ctr
    if individualbc then
      sprintf(key,"Brightness[%i]",head)
      n=getini("Video",key,"%i,%i,%i",                                         \
        brightness[head]+1,brightness[head]+0,brightness[head]+2)
      if n<3 then
        brightness[head][0]=brightness[head][1]
        brightness[head][2]=brightness[head][1]
      endif
      sprintf(key,"Contrast[%i]",head)
      n=getini("Video",key,"%i,%i,%i",                                         \
        contrast[head]+1,contrast[head]+0,contrast[head]+2)
      if n<3 then
        contrast[head][0]=contrast[head][1]
        contrast[head][2]=contrast[head][1]
      endif
    endif
  enddo
end

// Saves individual per-camera brightness and contrast values to .ini file
function int Bcsetini()
  int head
  char key[32]
  setini("Video","Illumination type","%i,%i",illtype,longexp)
  setini("Video","Camera focus[0]","%i",focus[0])
  setini("Video","Camera focus[1]","%i",focus[1])
  if individualbc==0 then
    // No individual settings.
    setini("ScrollAutoSave","Brightness","%i",brightness[0][1])
    setini("ScrollAutoSave","Contrast","%i",contrast[0][1])
  else
    // Individual per-camera settings.
    for head=0,head<32,head++ do
      if cameras!=0 then
        if head<$LAY.nfing*2 continue
        if (cameras & (1<<(head-$LAY.nfing*2)))==0 continue
      else
        if (headcams & (1<<head))==0 continue
      endif
      sprintf(key,"Brightness[%i]",head)
      setini("Video",key,"%i,%i,%i",                                           \
        brightness[head][1],brightness[head][0],brightness[head][2])
      sprintf(key,"Contrast[%i]",head)
      setini("Video",key,"%i,%i,%i",                                           \
        contrast[head][1],contrast[head][0],contrast[head][2])
      ;
    enddo
  endif
end

// Connects brightness and contrast controls to the specified head. Index is
// the position of the camera: 0 - bottom line, 1 - middle line, 2 - top line.
function int Bcsetcam(int channel,int index)
  int head
  if individualbc==0 return
  head=Headfromchannel(channel)
  if index<0 || index>2 index=1
  if head==bchead && index==bcindex then
    return
  else if head>=0 && head<32 then
    if hbrightness!=NULL change hbrightness select=brightness[head][index]
    if hcontrast!=NULL change hcontrast select=contrast[head][index]
    if hfocus!=NULL && (head==$LAY.nfing*2 || head==$LAY.nfing*2+1) then
      change hfocus text=format(" %i",focus[head-$LAY.nfing*2])
    endif
    bchead=head
    bcindex=index
  else
    bchead=-1
  endif
end

// Creates brightness, contrast and illumination or focus controls at the
// specified location (default location if x and y are -1).
function int Bccreate(handle hparent,int x,int y,int channel,int index,int mode)
  if x<0 x=5
  if y<0 y=303
  if mode!=0 then
    if testertype==TT_S3 then
      mode=2                           // Create focus controls
    else if (testertype==TT_A7 || testertype==TT_A8) && boardtype==0 then
      mode=1                           // Create illumination controls
    else
      mode=0
    endif
  endif
  hbrititle=control TEXT
    window=hparent
    position=x,y+4,27,16
    name="Gain"
    help=" "
    font=INFOFONT
  endc
  hbrightness=control HSCROLL
    window=hparent
    position=x+32,y+2,(mode?120:150),21
    name=(individualbc?"":"Brightness")
    help=format("%s",                                  \
      individualbc?" ":"")
    limits=-100,100
  endc
  hctrtitle=control TEXT
    window=hparent
    position=x,y+31,27,16
    name="Exp"
    help=" "
    font=INFOFONT
  endc
  hcontrast=control HSCROLL
    window=hparent
    position=x+32,y+29,(mode?120:150),21
    name=(individualbc?"":"Contrast")
    help=format("%s",                       \
      individualbc?" ":"")
    limits=-100,100
  endc
  if mode==1 then
    // Illumination controls.
    hilltop=control CHECKBOX
      window=hparent
      position=x+160,y,50,18
      name="Top"
      help=""
      font=INFOFONT
      mode=((illtype & 0x0C)==0 || (illtype & 0x4)!=0?M_CHECKED:0)
    endc
    hillskew=control CHECKBOX
      window=hparent
      position=x+160,y+18,55,18
      name="Skew"
      help=""
      font=INFOFONT
      mode=((illtype & 0x08)!=0?M_CHECKED:0)
    endc
    hilllong=control CHECKBOX
      window=hparent
      position=x+160,y+36,55,18
      name="HiExp"
      help=""
      font=INFOFONT
      mode=(longexp?M_CHECKED:0)
    endc
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  else if mode==2 then
    // Focus controls.
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=control TEXT
      window=hparent
      position=x+160,y+31,45,16
      name="Focus"
      help=" "
      font=INFOFONT
    endc
    hfocusup=control BUTTON
      window=hparent
      position=x+205,y+29,21,21
      name="-"
      help="Press and hold to move camera up"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hfocus=control TEXT
      window=hparent
      position=x+225,y+29,62,21
      help="Current camera Z coordinate, micrometers"
      font=MEDIUMFONT
      mode=M_BORDER
      bkcolor=LIGHTYELLOW
      color=DARKGRAY
    endc
    hfocusdn=control BUTTON
      window=hparent
      position=x+286,y+29,21,21
      name="+"
      help="Press and hold to move camera down"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
  else
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  endif
  bchead=-1
  Bcsetcam(channel,index)
end

// Checks whether user has changed brightness, contrast or illumination and
// updates data. Returns combination of 0x01 (if brightness or contrast was
// changed) and 0x02 (if illumination type was changed). Additionally, sets
// S3 focus.
function int Bcupdate(int updateall)
  int head,cam,changed,n,index
  char s[80]
  if individualbc==0 then
    head=0
    index=1
  else if bchead<0 || bchead>=32 then
    return 0
  else
    head=bchead
    index=bcindex
  endif
  changed=0
  if hbrightness!=NULL && Pressed(hbrightness) then
    if updateall then
      brightness[head][1]=Status(hbrightness)
      brightness[head][0]=brightness[head][1]
      brightness[head][2]=brightness[head][1]
    else
      brightness[head][index]=Status(hbrightness)
    endif
    changed=changed | 0x01
  endif
  if hcontrast!=NULL && Pressed(hcontrast) then
    if updateall then
      contrast[head][1]=Status(hcontrast)
      contrast[head][0]=contrast[head][1]
      contrast[head][2]=contrast[head][1]
    else
      contrast[head][index]=Status(hcontrast)
    endif
    changed=changed | 0x01
  endif
  if hilltop!=NULL && Pressed(hilltop) then
    if Status(hilltop)!=0 then
      illtype=illtype|0x04
    else
      illtype=illtype & (~0x04)
      if (illtype & 0x0C)==0 then
        illtype=0x0B
        change hillskew mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hillskew!=NULL && Pressed(hillskew) then
    if Status(hillskew)!=0 then
      illtype=illtype|0x08
    else
      illtype=illtype & (~0x08)
      if (illtype & 0x0C)==0 then
        illtype=0x07
        change hilltop mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hilllong!=NULL && Pressed(hilllong) then
    longexp=Status(hilllong)
    changed=changed | 0x01
  endif
  if hfocus!=NULL then
    n=Min(Pressed(hfocusdn),3)
    n=n-Min(Pressed(hfocusup),3)
    cam=head-$LAY.nfing*2
    if n!=0 && (cam==0 || cam==1) then
      focus[cam]=Max(-8000,Min(focus[cam]+n*20,8000))
      change hfocus text=format(" %i",focus[cam])
      updatefocus[cam]=1
    endif
  endif
  if testertype==TT_S3 then
    if ($LAY.cameras & 0x1)!=0 && updatefocus[0]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+0,focus[0])
      SERV.Cmdimm(32,s)
      updatefocus[0]=0
    endif
    if ($LAY.cameras & 0x2)!=0 && updatefocus[1]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+1,focus[1])
      SERV.Cmdimm(32,s)
      updatefocus[1]=0
    endif
  endif
  return changed
end

// Deletes brightness and contrast controls. It's not a sin to forget to call
// this function, but then better not call any Bcxxx() except Bccreate() or
// Bcdisable().
function int Bcdelete()
  if bchead<0 return
  destroy hbrititle; hbrititle=NULL
  destroy hbrightness; hbrightness=NULL
  destroy hctrtitle; hctrtitle=NULL
  destroy hcontrast; hcontrast=NULL
  bchead=-1
  if hilltop!=NULL then
    destroy hilltop; hilltop=NULL
    destroy hillskew; hillskew=NULL
    destroy hilllong; hilllong=NULL
  endif
  if hfocus!=NULL then
    destroy hfoctitle; hfoctitle=NULL
    destroy hfocusup; hfocusup=NULL
    destroy hfocus; hfocus=NULL
    destroy hfocusdn; hfocusdn=NULL
  endif
end

// Disables brightness and contrast processing in the case that corresponding
// controls were not deleted by Bcdelete()
function int Bcdisable()
  hbrititle=NULL
  hbrightness=NULL
  hctrtitle=NULL
  hcontrast=NULL
  bchead=-1
  hilltop=NULL
  hillskew=NULL
  hilllong=NULL
  hfoctitle=NULL
  hfocusup=NULL
  hfocus=NULL
  hfocusdn=NULL
end

// Returns current brightness (-100..100) for the specified channel.
function int Bcgetbri(int channel,int index)
  int head
  if individualbc==0 then
    return brightness[0][1]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return brightness[head][index]
  endif
end

// Returns current contrast (-100..100) for the specified head.
function int Bcgetctr(int channel,int index)
  int head
  if individualbc==0 then
    return contrast[0][1]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return contrast[head][index]
  endif
end

// Service function, calculates zoom that fits image from channel into the
// video window.
function float Getzoom(int channel)
  int videox,videoy,j
  SYS.Videosize(channel,&videox,&videoy,&j)
  if videox==0 || videoy==0 then
    return 0.5
  else
    return Max((LEFTX-8.0)/videox,290.0/videoy)
  endif
end

// Calculates displacement of the opposite camera necessary for the perfect
// illumination (tester coordinates) and, if necessary, adjusts brightness and
// contrast. Assumes that cut on the channel is already done. Parameters xfid
// and yfid are raw coordinates of the fiducial in camera pixels, relative to
// the center of the image. Returns 1 if brightness adjustment was done, 2 if
// opposite camera should be moved, 0 if position of the opposite camera is
// good enough, -2 if fiducial is shifted and -1 on error.
function int Autoadjust(int head,int index,int opp,int y,                      \
  float xfid,float yfid,float angle,int onlyreduce,float *dx,float *dy)
  int i,j,d,n,adjust,videodx,videody,channel,qmin,qmax,ix,iy
  int hist[256],sum,nsum,quad[4]
  float rcheck,gradx,grady
  char buf[10201]
  if $LAY.cameras!=0 return -1         // Doesn't work with dedicated cameras
  if index<0 || index>2 index=1
  adjust=0
  channel=Channelfromhead(head)
  if channel<0 return -1
  SYS.Videosize(channel,&videodx,&videody,&j)
  // Radius of the outer circle on the board is 1 mm. I check at the distance
  // 1.3 mm. If area is invisible, check is skipped.
  rcheck=1.3/headcamscale[head]
  if Abs(xfid)+rcheck>videodx/2 || Abs(yfid)+rcheck>videody/2                  \
    return -2                          // Check area may be invisible
  dx[0]=0.0
  dy[0]=0.0
  // Get brightness in 4 quadrants. Quadrants: 1 0
  //                                           2 3
  d=0.25/headcamscale[head]+1
  if d>50 d=50
  qmin=1000; qmax=-1000
  for i=0,i<4,i++ do
    ix=xfid+rcheck*Cos(angle+PI/4.0+PI/2.0*i)
    iy=yfid+rcheck*Sin(angle+PI/4.0+PI/2.0*i)
    n=SYS.Getvideo(channel,ix-d,ix+d+1,1,iy-d,iy+d+1,1,buf)
    Memset(hist,0,Sizeof(hist))
    for j=0,j<n,j++ do
      hist[buf[j]]++
    enddo
    sum=0; nsum=0
    // I take mean over the top 20% of the histogramm. This should eliminate
    // fingerprints, dust and needle shades.
    for j=255,j>=0,j-- do
      sum=sum+hist[j]*j
      nsum=nsum+hist[j]
      if nsum*5>=n break
    enddo
    if nsum==0 return 0                // Only if n=0, but this really happens
    quad[i]=sum/nsum
    qmin=Min(qmin,quad[i])
    qmax=Max(qmax,quad[i])
  enddo
  if qmax>=255 &&                                                              \
    (brightness[head][index]>=(-95) || contrast[head][index]>=(-95)) then
    // Overexposed picture. Reduce amplification or exposition.
    if brightness[head][index]>contrast[head][index] then
      brightness[head][index]=(brightness[head][index]+100.0)*0.9-101.0
      if hbrightness!=NULL change hbrightness select=brightness[head][index]
      adjust=1
    else
      contrast[head][index]=(contrast[head][index]+100.0)*0.9-101.0
      if hcontrast!=NULL change hcontrast select=contrast[head][index]
      adjust=1
    endif
  else if qmax<=160 && onlyreduce!=0 &&                                        \
    (brightness[head][index]<=88 || contrast[head][index]<=88) then
    // Dark picture. Increase amplification or exposition.
    if brightness[head][index]<contrast[head][index] then
      brightness[head][index]=(brightness[head][index]+102.0)*1.05-100.0
      if hbrightness!=NULL change hbrightness select=brightness[head][index]
      adjust=1
    else
      contrast[head][index]=(contrast[head][index]+102.0)*1.05-100.0
      if hcontrast!=NULL change hcontrast select=contrast[head][index]
      adjust=1
    endif
  else
    // Calculate gradient.
    gradx=quad[0]+quad[3]-quad[1]-quad[2]
    grady=quad[0]+quad[1]-quad[2]-quad[3]
    if Abs(gradx)>25.0 || Abs(grady)>25.0 then
      // Inhomogeneous illumination, move opposite head.
      if $LAY.side[head/2]==0 then
        dx[0]=-gradx*0.005
        dy[0]=grady*0.005
      else
        dx[0]=gradx*0.005
        dy[0]=grady*0.005
      endif
      dx[0]=Max(-0.5,Min(dx[0],0.5))
      dy[0]=Max(-0.5,Min(dy[0],0.5))
      adjust=2
    endif
  endif
  return adjust
end

// In the case of the new calibration board we need a special fiducial because
// border around the double square may be partially covered by the middle cross.
function handle Model(int chan,int type,float a,float b,float c,               \
  float fi,int color)
  int x0,y0,d,d0,d1,d2,d3,fg,bg
  if (type==SYNT_LEFT || type==SYNT_RIGHT) && headcamfidtype!=0 && fi==0.0 then
    // Important: X size must be doubleword-aligned!
    d=(a+3*b+5) & 0xFFFFFFFC
    if hfidgraph!=NULL && fidgraphsize<d then
      destroy hfidgraph
      hfidgraph=NULL
    endif
    if hfidgraph==NULL then
      hfidgraph=control GRAPH          // Invisible window to create fiducials
        window=hmain
        position=10000,10000,d,d
      endc
      fidgraphsize=d
    endif
    if color==WHITEONBLACK then
      fg=WHITE
      bg=BLACK
    else
      fg=BLACK
      bg=WHITE
    endif
    x0=d/2
    y0=d/2
    d1=(a-b+1)/2
    d2=(a+b+1)/2
    d0=d1                              // Ignore gaps near the cross
    d3=d2+b
    // Drawing sequence below is similar to the one I use in Ollytest to create
    // corresponding fiducial.
    draw window=hfidgraph color=VIDEOFILL bkcolor=VIDEOFILL clear
    draw color=bg bkcolor=bg
    if type==SYNT_LEFT then
      draw at x0-d3,y0-d3 fillrect x0-d0+1,y0-d0+1
      draw at x0+d0,y0+d0 fillrect x0+d3+1,y0+d3+1
    else
      draw at x0-d3,y0+d0 fillrect x0-d0+1,y0+d3+1
      draw at x0+d0,y0-d3 fillrect x0+d3+1,y0-d0+1
    endif
    draw color=fg bkcolor=fg
    if type==SYNT_LEFT then
      draw at x0-d2,y0-d2 fillrect x0-d1+1,y0-d1+1
      draw at x0+d1,y0+d1 fillrect x0+d2+1,y0+d2+1
    else
      draw at x0-d2,y0+d1 fillrect x0-d1+1,y0+d2+1
      draw at x0+d1,y0-d2 fillrect x0+d2+1,y0-d1+1
    endif
    draw show                          // Not strictly necessary
    return SYS.Graphmodel(chan,hfidgraph,x0,y0,BLACK,WHITE,MODEL_BIG)
  else
    return SYS.Syntmodel(chan,type,a,b,c,fi,color)
  endif
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// ELECTRICAL CALIBRATION ////////////////////////////

// Returns percent of calibrated crosses on the slowest rail.
function float Electroscan(float shy)
  int i,m,n,t,rail,finger,head,opp,side,ncal,next,nopp,vcond,pcond
  int step,dir,allref,leftdone,searchref,pending,result
  int ref                              // Head to be used as reference
  float percent,minpercent             // Percentages of execution
  float refpercent[2],maxpercent[2]
  int maxrail[2]                       // Fastest rail on side
  int finished[2]                      // Head that finished scanning on side
  float x,y,a,d,w,afactor,wfactor,yoffset
  float x0,y0,x1,y1
  char s[512],u[256],scmd[64],longmode[16],buf[128]
  minpercent=100.0;
  refpercent[0]=0.0; refpercent[1]=0.0
  maxpercent[0]=0.0; maxpercent[1]=0.0
  finished[0]=-1; finished[1]=-1
  if testersides==0x03 then
    maxrail[0]=firsttop; maxrail[1]=firstbot
  else if testersides==0x1 then
    maxrail[0]=firsttop; maxrail[1]=firsttop
  else
    maxrail[0]=firstbot; maxrail[1]=firstbot
  endif
  // All-references mode is turned on when calibration uses micro needles on
  // the glass board and there are reference heads. Contact of micro needles
  // with chrome is especially bad, I attempt at least to improve the contact
  // in the reference. Of course, embedded software must support multiple
  // references in calibration - old versions support at most one reference!
  leftdone=1                           // Valid only if allref is set
  if ALLREF==0 then
    allref=0                           // All-reference mode disabled
  else if (boardtype==1 || boardtype==2) && singleref==0 &&                    \
    kelvinscan==0 && (measfeatures & MF_MULTICAL)!=0 &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
    for head=0,head<$LAY.nfing*2,head=head+2 do
      if c[head].next<c[head].ncal then
        leftdone=0; break              // Some left head is still calibrating
      endif
    enddo
    allref=1                           // OK to use all reference heads
  else
    allref=0
  endif
  // If shuttle Y offset is present, add it to all movement commands.
  if (shy==0.0) then
    Strcpy(scmd,"")
  else
    sprintf(scmd," SHY(%g)",shy)
  endif
  for rail=0,rail<$LAY.nfing,rail++ do // Go over all rails
    percent=0.0
    yoffset=$LAY.yoffset[rail]/1000.0
    side=($LAY.side[rail]!=0)
    for finger=0,finger<2,finger++ do
      if finger==1 && allref!=0 && leftdone==0 then
        continue                       // All-references mode, wait for left
      endif
      head=rail*2+finger
      opp=rail*2+(1-finger)
      ncal=c[head].ncal
      nopp=c[opp].ncal
      next=c[head].next
      step=c[head].step
      if ncal==0 || next>=ncal then
        percent=percent+50.0           // Head already calibrated or excluded
      else
        percent=percent+(next*4+step)*12.5/ncal
      endif
      // In demo mode, emulate scanning results. Each 20th point is bad.
      if demo then
        c[head].xm[next]=c[head].xa[next]+                                     \
          Random(accuracy)+Random(accuracy)-Random(accuracy)-Random(accuracy)
        c[head].ym[next]=c[head].ya[next]+                                     \
          Random(accuracy)+Random(accuracy)-Random(accuracy)-Random(accuracy)
        if Random(20)==0 then          // Bad point
          c[head].xm[next]=c[head].xm[next]+Random(accuracy*12)-accuracy*6
          c[head].ym[next]=c[head].ym[next]+Random(accuracy*12)-accuracy*6
        endif
        c[head].err[next]=0
        c[head].next=next+1
        continue
      endif
      // Process answers from reference heads.
      if c[head].pending!=0 && kelvinscan==2 && c[head].searchref==2 &&        \
        $A[head].length!=0                                                     \
      then
        if $A[head].answer==S_ERROR then
          // Reference line not found, or shortcut in probe. Repeat search.
          c[head].pending=0
          c[head].searchref=1
          continue
        else if $A[head].answer==S_CALIBRATE then
          // Reference line found, update coordinates of reference point.
          c[head].refy=($int4($A[head]+17)+$int4($A[head]+13))/2000.0
          c[head].pending=0
          c[head].searchref=0
          continue
        endif
      endif
      // If head is already calibrated or excluded, it has nothing to do.
      if ncal==0 continue
      // Process answers from the tester.
      if c[head].pending==0 then
        ;                              // We expect no answer
      else if $A[head].length==0 then
        continue                       // Still no answer from head
      else if $A[head].answer==S_ERROR && $A[head].subcmd==E_PADNOTFOUND then
        c[head].pending=0              // Pad not found, retry
        c[head].attempt=c[head].attempt+1
        // If HV conditioning on glass is enabled, make several fast HV
        // measurements. I don't dare it for Kelvin or hard touch needles. If
        // conditioning is off, try to clean needles by contacting on glass.
        if c[head].attempt==2 &&                                               \
          ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHPS                      \
        then
          vcond=Min(v+50,100)
          pcond=Min(p+40,100)
          if $LAY.probetype==0 && c[head].hvcondok!=0 then
            for i=0,i<15,i++ do
              sprintf(s,"M%s %i[%f,%fA255V%iP%i] %i[%f,%fA255V%iP%i] H(%i,%i)",\
                scmd,head,c[head].hvcondx0+Random(refsizex)-refsizex/2.0,      \
                c[head].hvcondy0+Random(refsizey)-refsizey/2.0,vcond,pcond,    \
                opp,c[opp].hvcondx0+Random(refsizex)-refsizex/2.0,             \
                c[opp].hvcondy0+Random(refsizey)-refsizey/2.0,vcond,pcond,     \
                head,opp)
              SERV.Cmdimm(32,s)
            enddo
          else
            x0=$LAY.xoffset/1000.0+boardshift+xstep*1.5
            while x0-1.5*xstep>fromxloc do
              x0=x0-xstep
            enddo
            x1=$LAY.xoffset/1000.0+boardshift-xstep*1.5
            while x1+1.5*xstep<toxloc do
              x1=x1+xstep
            enddo
            y0=$LAY.yoffset[head/2]/1000.0-ystep/2.0
            y1=$LAY.yoffset[head/2]/1000.0+ystep/2.0
            if (head & 1) then         // Need to swap coordinates
              x=x0; x0=x1; x1=x
              y=y0; y0=y1; y1=y
            endif
            for i=0,i<60,i++ do
              sprintf(s,"M%s %i[%f,%fA255V%iP%i] %i[%f,%fA255V%iP%i] DLY(5)",  \
                scmd,head,x0+Random(refsizex)-refsizex/2.0,                    \
                y0+Random(refsizey)-refsizey/2.0,vcond,pcond,                  \
                opp,x1+Random(refsizex)-refsizex/2.0,                          \
                y1+Random(refsizey)-refsizey/2.0,vcond,pcond)
              SERV.Cmdimm(32,s)
            enddo
          endif
        endif
        if singleref==0 && kelvinscan!=3 then
          if kelvinscan==2 then        // Change reference point
            c[opp].searchref=1
          else if allref!=0 then       // Request all references change
            c[opp].searchref=1
          else
            c[opp].refx=c[opp].refx0+(Random(refsizex)-refsizex/2.0)/2.0
            c[opp].refy=c[opp].refy0+(Random(refsizey)-refsizey/2.0)/2.0
          endif
        endif
        sprintf(c[head].errmsg,"Beam not found")
      else if $A[head].answer==S_ERROR && $A[head].subcmd==E_CONTACT &&        \
        kelvinscan==1 then
        // Shortcut in Kelvin probe. Try to remove the obstacle by hitting
        // calibration board several times between the lines. If this does not
        // help, ask operator to clean the needle manually.
        c[head].pending=0              // Pad not found, retry
        if c[head].attempt<2 then
          c[head].autoclean=5
        else
          cleankelvin=head
        endif
        c[head].attempt=c[head].attempt+1
        sprintf(c[head].errmsg,"Shortcut in Kelvin probe")
      else if $A[head].answer==S_READY then
        c[head].pending=0              // Simple movement
      else if $A[head].answer==S_INPORT then
        c[head].pending=0              // Attempt to clean Kelvin probe
      else if $A[head].answer!=S_CALIBRATE then
        c[head].pending=0              // Wrong answer
        c[head].attempt=c[head].attempt+1
        sprintf(c[head].errmsg,"Wrong answer %02X",$A[head].answer)
      else
        c[head].pending=0              // Correct answer, check for accuracy
        x=c[head].xt; y=c[head].yt
        if step==0 then
          w=Abs($int4($A[head]+9)-$int4($A[head]+5))/1000.0
          d=0
          c[head].wx[next]=w
          a=0
          if ($A[head].length>=31) then
            x=$int4($A[head]+23)/256000.0
          else
            x=($int4($A[head]+9)+$int4($A[head]+5))/2000.0
          endif
          c[head].z0=($A[head].length>=23?$uint2($A[head]+21):0)
        else if step==1 then
          w=Abs($int4($A[head]+17)-$int4($A[head]+13))/1000.0
          d=0
          c[head].wy[next]=w
          a=0
          if ($A[head].length>=31) then
            y=$int4($A[head]+27)/256000.0
          else
            y=($int4($A[head]+17)+$int4($A[head]+13))/2000.0
          endif
          c[head].z1=($A[head].length>=23?$uint2($A[head]+21):0)
        else if step==2 then
          w=Abs($int4($A[head]+9)-$int4($A[head]+5))/1000.0
          d=Abs(w-c[head].wx[next])
          c[head].wx[next]=(c[head].wx[next]+w)/2.0
          a=Abs(x-($int4($A[head]+9)+$int4($A[head]+5))/2000.0)
          if ($A[head].length>=31) then
            x=x/2.0+$int4($A[head]+23)/512000.0
          else
            x=x/2.0+($int4($A[head]+9)+$int4($A[head]+5))/4000.0
          endif
          c[head].z2=($A[head].length>=23?$uint2($A[head]+21):0)
        else
          w=Abs($int4($A[head]+17)-$int4($A[head]+13))/1000.0
          d=Abs(w-c[head].wy[next])
          c[head].wy[next]=(c[head].wy[next]+w)/2.0
          a=Abs(y-($int4($A[head]+17)+$int4($A[head]+13))/2000.0)
          if ($A[head].length>=31) then
            y=y/2.0+$int4($A[head]+27)/512000.0
          else
            y=y/2.0+($int4($A[head]+17)+$int4($A[head]+13))/4000.0
          endif
          c[head].z3=($A[head].length>=23?$uint2($A[head]+21):0)
        endif
        // The allowed errors on the old testers are significantly larger.
        if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||     \
          testertype==TT_A2H || testertype==TT_A3 || testertype==TT_A4 then
          afactor=0.50
        else if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
          afactor=0.04
        else if testertype==TT_A7 || testertype==TT_A8 then
          afactor=0.08
        else
          afactor=0.25
        endif
        if a>linewidth*afactor+distance/15.0+2*accuracy ||                     \
          d>linewidth*afactor+accuracy then
          step=step-2                  // High shift between beams or different
          c[head].step=step            // widths, scan beams again.
          c[head].attempt=0
          c[head].rescan=c[head].rescan+1
          sprintf(c[head].errmsg,"Shift=%.3f, Wdiff=%.3f mm",a,d)
        else if (w<linewidth*(kelvinscan==1?0.2:0.4) || w>linewidth*2.5) &&    \
          c[head].attempt==0 then      // Suspicious line width, retry once
          c[head].attempt=c[head].attempt+1
          sprintf(c[head].errmsg,"Width=%.3f mm",w)
        else                           // Beam calibrated
          if step==0 || step==2 then
            c[head].widthx=c[head].widthx*0.90+w*0.10
            Addsigma(c[head].wstatx,w)
          else
            c[head].widthy=c[head].widthy*0.90+w*0.10
            Addsigma(c[head].wstaty,w)
          endif
          c[head].xt=x
          c[head].yt=y
          c[head].attempt=0
          c[head].errmsg[0]='\0'
          step++
          c[head].step=step
          if step>3 then               // Cross calibrated
            c[head].xm[next]=x
            c[head].ym[next]=y
            c[head].err[next]=0
            step=0
            c[head].step=step
            c[head].rescan=0
            // If necessary, correct first approach for remaining crosses to
            // make calibration faster.
            if (c[head].mode & CM_CORRX)!=0 then
              d=x-c[head].xa[next]     // Pre-correct in X direction
              d=Max(-xstep/5,Min(xstep/5,d))
              for i=next+1,i<ncal,i++ do
                c[head].xm[i]=c[head].xa[i]+d
              enddo
              c[head].mode=c[head].mode & (~CM_CORRX)
            endif
            if (c[head].mode & CM_CORRYTOP)!=0 && y>yoffset+ystep then
              d=y-c[head].ya[next]     // Pre-correct top crosses in Y dir
              d=Max(-ystep/5,Min(ystep/5,d))
              for i=next+1,i<ncal,i++ do
                if (c[head].ya[i]<yoffset+ystep) continue
                c[head].ym[i]=c[head].ya[i]+d
              enddo
              c[head].mode=c[head].mode & (~CM_CORRYTOP)
            endif
            if (c[head].mode & CM_CORRYBOT)!=0 && y<yoffset-ystep then
              d=y-c[head].ya[next]     // Pre-correct bottom crosses in Y dir
              d=Max(-ystep/5,Min(ystep/5,d))
              for i=next+1,i<ncal,i++ do
                if (c[head].ya[i]>yoffset-ystep) continue
                c[head].ym[i]=c[head].ya[i]+d
              enddo
              c[head].mode=c[head].mode & (~CM_CORRYBOT)
            endif
            if c[head].z0>0 && c[head].z1>0 && c[head].z2>0 && c[head].z3>0 then
              // Answer includes Z coordinate, save it with the data. This
              // coordinate is used in 3-D calibration and in the verification
              // of Z alignment.
              c[head].z[next]=(c[head].z0+c[head].z1+c[head].z2+c[head].z3)/4.0
            else if (calmode==MODE_VER && verifymode==VERIFY_ZALIGN) ||        \
              (testertype==TT_S3 && $LAY.cameras!=0 &&                         \
              (cratefeatures & CF_3DCOR)!=0) then
              // If this is the verification of Z alignment, or if 3-D
              // calibration is possible, ask for the current Z coordinate.
              // Command INPORT is very fast, so no significant delay is
              // introduced.
              c[head].z[next]=0
              if head & 1 then
                sprintf(buf,"INPORT 0x%04X",0x8081+((head/2)<<8))
              else
                sprintf(buf,"INPORT 0x%04X",0x8080+((head/2)<<8))
              endif
              SERV.Cmdimm(head,buf)
              t=Time()
              while 1 do
                if $A[head].length>0 then
                  if $A[head].answer==S_INPORT                                 \
                    c[head].z[next]=$uint2($A[head]+5)
                  break
                else if Time()-t>250 then
                  SYS.Killimm(head)
                  break
                endif
              enddo
            endif
            // Save coordinates of found pad to the log file.
            if hlog!=NULL then
              fprintf(hlog,"  %i%c:   %8.3f %8.3f  %7.4f %7.4f",               \
              head/2,(head & 1?'R':'L'),c[head].xa[next],c[head].ya[next],     \
              x-c[head].xa[next],y-c[head].ya[next])
              if c[head].z[next]>0 then
                fprintf(hlog,"   Z=%7.1f\n",c[head].z[next])
              else
                fprintf(hlog,"\n")
              endif
            endif
            next++                     // Continue with the next cross
            c[head].next=next
            if next>=ncal then
              c[head].tend=Time()
              if kelvinscan==3 then
                sprintf(buf,"M%s %i(Z) NOP",scmd,head)
              else
                sprintf(buf,"M%s %i[%f,%f] NOP",                               \
                scmd,head,c[head].refx,c[head].refy)
              endif
              SERV.Cmdimm(head,buf)    // Head calibrated, move to ref point and
              c[head].infield=0        // don't send commands to head anymore.
              c[head].pending=1
              finished[side]=head
              break
            endif
          endif
        endif
      endif
      if next>=ncal continue           // Head already calibrated or excluded
      // Do we have some problem with the cross?
      if c[head].attempt>3 || c[head].rescan>1 then
        c[head].err[next]=1            // Multiple attempts to scan cross were
        step=0                         // unsuccessfull. Skip it.
        c[head].step=step
        c[head].attempt=0
        c[head].rescan=0
        if hlog!=NULL then
          fprintf(hlog,"  %i%c:   %8.3f %8.3f  Not calibrated (%s)\n",         \
          head/2,(head & 1?'R':'L'),c[head].xa[next],c[head].ya[next],         \
          c[head].errmsg)
        endif
        next++
        c[head].next=next
        if next>=ncal c[head].tend=Time()
        break
      endif
      // Select reference pad for next scan command.
      if singleref==0 then
        ref=opp                        // Select opposite head as reference
      else
        ref=globref[side]
        if head==ref then
          if c[head].pending==0 && c[head].infield!=0 then
            if kelvinscan==3 then
              sprintf(buf,"M%s %i(Z) NOP",scmd,head)
            else
              sprintf(buf,"M%s %i[%f,%f] NOP",                                 \
              scmd,head,c[head].refx,c[head].refy)
            endif
            SERV.Cmdimm(head,buf)      // Move reference to ref point
            c[head].infield=0
            c[head].pending=1
            c[head].usesref=-1         // No associated reference
          endif
          continue                     // Finger is reference, skip it now
        endif
        if c[ref].infield!=0 continue  // Reference finger busy, wait
        for i=0,i<$LAY.nfing*2,i++ do  // Check if finger was used as reference
          if c[i].ncal==0 continue
          if c[i].pending!=0 && c[i].usesref==head break
        enddo
        if i<$LAY.nfing*2 continue     // Finger still used as reference
      endif
      // Check that there is no interference with opposite finger.
      if singleref!=0 &&               /* Otherwise no interference        */  \
        finger==0 &&                   /* Right finger has right of way    */  \
        opp!=ref &&                    /* Opposite finger is not reference */  \
        c[opp].next<nopp &&            /* Opposite finger not yet finished */  \
        c[head].xa[next]+xstep/2>      /* Opposite finger stays in way     */  \
        c[opp].xa[c[opp].next]                                                 \
      then
        if c[head].infield!=0 then
          if kelvinscan==3 then
            sprintf(buf,"M%s %i(Z) NOP",scmd,head)
          else
            sprintf(buf,"M%s %i[%f,%f] NOP",                                   \
            scmd,head,c[head].refx,c[head].refy)
          endif
          SERV.Cmdimm(32,buf)          // Move head to reference point to give
          c[head].infield=0            // way to opposite finger
        endif
        continue
      endif
      if c[ref].pending!=0 continue    // Reference head still busy, wait
      // Do we need to determine next Kelvin reference point on the line?
      if (kelvinscan==2 && c[ref].searchref==1) then
        c[ref].refx=c[ref].refx0+(Random(refsizex)-refsizex/2.0)/2.0
        c[ref].refy=$LAY.yoffset[ref/2]/1000.0
        sprintf(s,"M%s %i[%f,%fA15V%iP%i] %i(SAME) CAL(%i,%iW%iD64,%c)",       \
          scmd,ref,c[ref].refx,c[ref].refy,v,p,head,ref,head,                  \
          $LAY.probetype==0?linewidth*1000.0:linewidth*650.0,                  \
          $LAY.probetype==0?'G':'K')
        if SERV.Cmdimm(ref,s)>0 then
          c[ref].searchref=2
          c[ref].pending=1
          c[ref].infield=1
        endif
        continue
      endif
      // If reference point on the line is still absent, wait.
      if (kelvinscan==2 && c[opp].searchref!=0) continue
      // If automatical cleaning of shortened Kelvin probe is requested, contact
      // calibration board several times between the crosses. Usually this does
      // not help.
      if c[head].autoclean>0 then
        y=c[head].ym[next]
        if y>yoffset then
          y=y-ystep/2.0
        else
          y=y+ystep/2.0
        endif
        x=c[head].xm[next]
        if x>(fromx+tox)/2.0 then
          x=x-xstep/2.0
        else
          x=x+xstep/2.0
        endif
        x=x+Random(xstep/4.0)-xstep/8.0
        y=y+Random(ystep/4.0)-ystep/8.0
        sprintf(s,"M%s %i(%f,%fV%iP%i) Z(%i)",scmd,head,x,y,v,p,head)
        if SERV.Cmdimm(head,s)>0 then
          c[head].pending=1            // Command sent
          c[head].infield=1
          c[head].usesref=-1
          c[ref].infield=0
        endif
        c[head].autoclean=c[head].autoclean-1
        continue
      endif
      // If requested to clean Kelvin probe, wait till all heads are paused.
      if cleankelvin>=0 continue
      // If line in the all-references mode is not found, we can't simply
      // change the position of the reference: this will cause reference head
      // to jump between this command and commands pending in the crate. The
      // solution: wait till all tasks are executed and change references
      // simultaneously for all heads.
      if allref then
        searchref=0
        pending=0
        for i=0,i<$LAY.nfing*2,i++ do
          if c[i].ncal==0 continue
          if ((i^head) & 1)==0 continue
          if $LAY.side[head/2]!=$LAY.side[i/2] continue
          if c[i].searchref!=0 searchref=1
          if c[i^1].pending!=0 pending=1
        enddo
        if searchref!=0 && pending!=0 then
          continue                     // Wait till all relevant heads finish
        endif
        if searchref!=0 then
          for i=0,i<$LAY.nfing*2,i++ do
            if c[i].ncal==0 continue
            if ((i^head) & 1)==0 continue
            if $LAY.side[head/2]!=$LAY.side[i/2] continue
            c[i].refx=c[i].refx0+(Random(refsizex)-refsizex/2.0)/2.0
            c[i].refy=c[i].refy0+(Random(refsizey)-refsizey/2.0)/2.0
            c[i].searchref=0
          enddo
        endif
      endif
      // OK to send next scan command.
      if c[head].tstart==0 c[head].tstart=Time()
      d=distance+linewidth*2.0*c[head].rescan
      wfactor=1.0
      if c[head].attempt==1 then       // If at first you don't succeed, try
        d=d+linewidth/2.0              // (with slightly different parameters)
        wfactor=1.25                   // again and again!
      else if c[head].attempt==2 then
        d=d+linewidth
        wfactor=0.8
      endif
      d=Min(d,xstep/2.0,ystep/2.0)
      if step==0 then
        x=c[head].xm[next]             // First step, take assumed coordinates
        y=c[head].ym[next]-d
        if y<$LAY.bottom[rail]/1000.0 ||                                       \
          (testertype==TT_A5L && smallboard!=0 &&                              \
          y<$LAY.bottom[smallfirst]/1000.0+25.0) ||                            \
          (testertype==TT_A7 && smallboard!=0 && boardtype!=1 &&               \
          y<$LAY.bottom[smallfirst]/1000.0+25.0) ||                            \
          (testertype==TT_A7 && smallboard!=0 && boardtype==1 &&               \
          y<$LAY.bottom[smallfirst]/1000.0+55.0)                               \
          y=c[head].ym[next]+d
        w=c[head].widthx*wfactor
        dir=0
      else if step==1 then
        x=c[head].xt+d                 // X coordinate of the cross is known
        y=c[head].ym[next]
        w=c[head].widthy*wfactor
        dir=64
      else if step==2 then
        x=c[head].xt                   // Try at same Y distance as first beam
        y=2*c[head].yt-c[head].ym[next]+d
        if y>($LAY.top[rail]-5)/1000.0 ||                                      \
          (testertype==TT_A5L && smallboard!=0 &&                              \
          y>($LAY.top[smalllast]-5)/1000.0-25.0) ||                            \
          (testertype==TT_A7 && smallboard!=0 && boardtype!=1 &&               \
          y>($LAY.top[smalllast]-5)/1000.0-25.0) ||                            \
          (testertype==TT_A7 && smallboard!=0 && boardtype==1 &&               \
          y>($LAY.top[smalllast]-5)/1000.0-55.0)                               \
          y=c[head].yt-d
        w=c[head].widthx*wfactor
        dir=128
      else
        x=c[head].xt-d                 // Last beam
        y=c[head].yt
        w=c[head].widthy*wfactor
        dir=192
      endif
      if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||       \
        testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||         \
        testertype==TT_A7 || testertype==TT_A8                                 \
      then
        if c[head].attempt==0 then
          longmode[0]='\0'
        else
          Strcpy(longmode,",LONG")
        endif
        if kelvinscan==1 ||                                                    \
          (c[head].forcekelvin>0 && next>=c[head].forcekelvin) then
          sprintf(s,"M%s %i[%f,%fA%iV%iP%i] %i(Z) CAL(%i,%iW%iD%i,K%s)",       \
          scmd,head,x,y,acc,v,p,ref,head,ref,Max(w*1000.0,1.0),dir,longmode)
        else if kelvinscan==3 then
          sprintf(s,"M%s %i[%f,%fA%iV%iP%i] %i(Z) CAL(%i,32W%iD%i%s)",         \
          scmd,head,x,y,acc,v,p,ref,head,Max(w*1000.0,1.0),dir,longmode)
        else
          n=sprintf(s,"M%s %i[%f,%fA%iV%iP%i] ",scmd,head,x,y,acc,v,p)
          if allref==0 then
            // Single reference (standard mode).
            sprintf(s+n,"%i[%f,%fV%iP%i] CAL(%i,%iW%iD%i%s)",                  \
            ref,c[ref].refx,c[ref].refy,v,p,head,ref,                          \
            Max(w*1000.0,1.0),dir,longmode)
          else
            // All-references mode. I prolongate measurements to get reliable
            // opens. Note that serv.scr must support these new features.
            m=0
            for i=0,i<$LAY.nfing*2,i++ do
              if c[i].ncal==0 continue
              if ((i^head) & 1)==0 continue
              if $LAY.side[head/2]!=$LAY.side[i/2] continue
              n=n+sprintf(s+n,"%i[%f,%fV%iP%i] ",i,c[i].refx,c[i].refy,v,p)
              m=m+sprintf(u+m,",%i",i)
            enddo
            sprintf(s+n,"CAL(%i%s,W%iD%iL%s)",                                 \
            head,u,Max(w*1000.0,1.0),dir,longmode)
          endif
        endif
        result=SERV.Cmdimm(head,s)
        if result<0 then
          allref=0                     // Unsupported by serv.scr?
        else if result>0 then
          c[head].pending=1            // Hurrah, command sent!
          c[head].infield=1
          c[head].usesref=ref
          c[ref].infield=0
        endif
      else
        a=Min(255.0,50.0+1.0/accuracy)
        if (c[head].mode & CM_LOWACC)!=0 a=a/5.0
        buf[0]=S_CALIBRATE
        if singleref==0 then
          buf[1]=side                  // Side
        else
          buf[1]=head|0x40             // Direct head specification
        endif
        $int3(buf+2)=x*1000.0          // Initial X coordinate
        $int3(buf+5)=y*1000.0          // Initial Y coordinate
        $uint2(buf+8)=w*1000.0         // Expected width of the line
        buf[10]=a                      // Delay (reflects expected accuracy)
        buf[11]=dir                    // Direction of scanning
        if singleref==0 then
          buf[12]=side                 // Same side for reference pad
        else
          buf[12]=ref|0x40             // Direct reference head specification
        endif
        $int3(buf+13)=c[ref].refx*1000.0 // X coordinate of reference pad
        $int3(buf+16)=c[ref].refy*1000.0 // Y coordinate of reference pad
        $uint2(buf+19)=0               // Must be zero
        if SYS.Sendimm(head,21,buf)>0 then
          c[head].pending=1            // Command sent!
          c[head].infield=1
          c[head].usesref=ref
          c[ref].infield=0
        endif
      endif
    enddo
    minpercent=Min(minpercent,percent)
    if rail==globref[side]/2 then      // Necessary for auto reference change
      refpercent[side]=percent
    endif
    if percent>maxpercent[side] then   // Necessary for auto reference change
      maxpercent[side]=percent
      maxrail[side]=rail
    endif
  enddo
  // Check if it's necessary to change reference in the single reference mode.
  if demo==0 && singleref!=0 then
    for side=0,side<2,side++
      if (testersides & (1<<side))==0 continue
      if c[globref[side]].next<c[globref[side]].ncal && finished[side]>=0 then
        globref[side]=finished[side]   // Head finished, take as reference
      else if maxpercent[side]-refpercent[side]>=5.0 then
        head=maxrail[side]*2           // Time to change reference!
        if c[head+1].next>=c[head+1].ncal then
          globref[side]=head+1
        else
          globref[side]=head
        endif
      endif
    enddo
  endif
  return minpercent
end

// After scanning, call this function to estimate y shift, angle and radius for
// the given head. Returns combination of bits 0x01 for y shift, 0x02 for angle
// and 0x04 for radius. The bit is set and variable modified if corresponding
// value is seemed to be estimated correctly. Additionally, bit 0x80 is set if
// some estimations are unreliable.
function int Estimateoffset(int head,float *dy,float *dfi,float *dr)
  int i,j,n,answer
  float xa[4],ya[4],xm[4],ym[4]
  float xoffset,yoffset,fpl,fmi,rpl,rmi
  float deltar[2],deltah[2],deltaro[2],deltafi[2]
  n=c[head].next                       // Number of scanned points
  if n<2 return 0
  answer=0
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[head/2]/1000.0
  // Extract pairs of points into arrays xa,ya,xm,ym.    [1]  [3]
  // Distribution of indexes is shown to the right:      [0]  [2]
  xa[0]=9.0e99; xa[1]=9.0e99; xa[2]=-9.0e99; xa[3]=-9.0e99
  ya[0]=9.0e99; ya[1]=-9.0e99; ya[2]=9.0e99; ya[3]=-9.0e99
  for i=0,i<n,i++ do
    if c[head].err[i]!=0 continue
    if c[head].ya[i]>yoffset continue
    for j=0,j<n,j++ do                 // Find symmetrical if any
      if c[head].err[j]!=0 continue
      if Abs(c[head].xa[i]-c[head].xa[j])>xstep/10.0 continue
      if Abs(c[head].ya[i]+c[head].ya[j]-2*yoffset)>ystep/10.0 continue
      if c[head].xa[i]<xa[0] then      // New pair 0,1 found
        xa[0]=c[head].xa[i]; xm[0]=c[head].xm[i]
        ya[0]=c[head].ya[i]; ym[0]=c[head].ym[i]
        xa[1]=c[head].xa[j]; xm[1]=c[head].xm[j]
        ya[1]=c[head].ya[j]; ym[1]=c[head].ym[j]
      endif
      if c[head].xa[i]>xa[2] then      // New pair 2,3 found
        xa[2]=c[head].xa[i]; xm[2]=c[head].xm[i]
        ya[2]=c[head].ya[i]; ym[2]=c[head].ym[i]
        xa[3]=c[head].xa[j]; xm[3]=c[head].xm[j]
        ya[3]=c[head].ya[j]; ym[3]=c[head].ym[j]
      endif
    enddo
  enddo
  if xa[0]>xa[2] return 0              // Found no pairs of points
  // Calculate nonidealities for two pairs of points.
  for i=0,i<2,i++ do
    if (head & 1)==0 then              // Left finger
      fmi=Asin((ym[2*i]-yoffset)/radius)
      fpl=Asin((ym[2*i+1]-yoffset)/radius)
      rmi=xm[2*i]-radius*Cos(fmi)
      rpl=xm[2*i+1]-radius*Cos(fpl)
    else                               // Right finger
      fmi=-Asin((ym[2*i]-yoffset)/radius)
      fpl=-Asin((ym[2*i+1]-yoffset)/radius)
      rmi=xm[2*i]+radius*Cos(fmi)
      rpl=xm[2*i+1]+radius*Cos(fpl)
    endif
    deltafi[i]=Atan((rpl-rmi)/2.0/encdist)-(fpl+fmi)/2.0
    if (head & 1)==0 then              // Left finger
      deltar[i]=encdist/(Cos((fpl+fmi)/2.0+deltafi[i])*Sin((fpl-fmi)/2.0))-    \
        radius
      deltah[i]=-(deltar[i]+radius)*Sin((fpl+fmi)/2.0+deltafi[i])*             \
        Cos((fpl-fmi)/2.0)
      deltaro[i]=(xa[2*i]+xa[2*i+1]-rmi-rpl)/2.0-                              \
        (radius+deltar[i])*(Cos(fpl+deltafi[i])+Cos(fmi+deltafi[i]))/2.0
    else                               // Right finger
      deltar[i]=-encdist/(Cos((fpl+fmi)/2.0+deltafi[i])*Sin((fpl-fmi)/2.0))-   \
        radius
      deltah[i]=(deltar[i]+radius)*Sin((fpl+fmi)/2.0+deltafi[i])*              \
        Cos((fpl-fmi)/2.0)
      deltaro[i]=(xa[2*i]+xa[2*i+1]-rmi-rpl)/2.0+                              \
        (radius+deltar[i])*(Cos(fpl+deltafi[i])+Cos(fmi+deltafi[i]))/2.0
    endif
  enddo
  // Estimate requested parameters.
  if xa[2]-xa[0]>=xstep*4 then         // Means both pairs here and apart enough
    dfi[0]=(deltah[1]-deltah[0])/(xa[2]-xa[0])
    dr[0]=(deltar[0]*(xa[2]-xoffset)+deltar[1]*(xoffset-xa[0]))/(xa[2]-xa[0])
    dy[0]=(deltah[0]*(xa[2]-xoffset)+deltah[1]*(xoffset-xa[0]))/(xa[2]-xa[0])
    answer=0x07
  else
    dr[0]=(deltar[0]+deltar[1])/2.0
    dy[0]=(deltah[0]+deltah[1])/2.0
    answer=0x85
  endif
  return answer
end

// Calculates head or head camera corrections for specified head. If headcam is
// 0, fills head corrections, 1 - head camera and 2 - temporary correction
// tables for head camera. Returns -1 if there is insufficient number of
// scanned points, -2 if software was unable to interpolate given set of points
// (hardly possible, anyway), and number of points considered as bad (max. 3)
// if recalculation of corrections was successful.
function int Correctfinger(int head,int headcam)
  int i,j,j0,j1,k,m,n,np,nm,nz,imax,jmax,deleted,makefine
  float xoffset,yoffset,xremove,sign,rhead,afactor,arg
  float dpxin[CORRX],dpyin[CORRX]      // Measured corrections
  float pa[CORRX]                      // Accuracy in point
  int   cp[CORRX]                      // Whether calibrated or not
  float dpx[CORRX],dpy[CORRX]          // Splined corrections
  float dmxin[CORRX],dmyin[CORRX]      // Measured corrections
  float ma[CORRX]                      // Accuracy in point
  int   cm[CORRX]                      // Whether calibrated or not
  float dmx[CORRX],dmy[CORRX]          // Splined corrections
  float dzxin[CORRX],dzyin[CORRX]      // Measured corrections, middle line
  float za[CORRX]                      // Accuracy in point
  int   cz[CORRX]                      // Whether calibrated or not
  float dzx[CORRX],dzy[CORRX]          // Splined corrections
  float deltafi[CORRY]                 // Y profile
  int   nfi[CORRY]                     // Whether calibrated or not
  float dfiy[CORRY]                    // Splined deltafi(y)
  float x[CORRX],xz[CORRX],xshift,fidata[CORRY],ydata[CORRY],y[CORRY]
  float railteta[CORRX],drad[CORRX],raild[CORRX],raily[CORRX]
  float fx[FINEX],frailteta[FINEX],fraily[FINEX],fdrad[FINEX],fraild[FINEX]
  float fy[FINEY],ffiy[FINEY]
  float fip,fim,fi,rop,rom,ro,rodiff,ro0,fi0,xi,gx,gy,dx,dy
  float railr,rextra,railro,sx,sy,sxx,sxy,xdist,shrink,xellipse
  float a,b,r,d,dteta,dh,dro,dfi,dr,diffx,diffy,auxdist
  float xsel[CORRX],dxsel[CORRX],dysel[CORRX],asel[CORRX]
  deleted=0
  if c[head].next<4+3*precisey then
    return -1                          // Error: too few calibration points
  endif
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[head/2]/1000.0
  sign=((head & 1)==0)?1.0:-1.0
  rhead=(headcam==0?radius:headcamradius)
  makefine=(cratefeatures & CF_FINECORR)
repeat:
  np=0; nm=0; nz=0
  for i=0,i<CORRX,i++ do
    cp[i]=-1; dpxin[i]=0.0; dpyin[i]=0.0; pa[i]=xstep*10.0;
    cm[i]=-1; dmxin[i]=0.0; dmyin[i]=0.0; ma[i]=xstep*10.0;
    cz[i]=-1; dzxin[i]=0.0; dzyin[i]=0.0; za[i]=xstep*10.0;
  enddo
  if headcam==0 || illumination==0 || boardtype==0 then
    afactor=1.0
  else
    afactor=2.5                        // Shinethru on glass with headcams
  endif
  // Get and sort all points to be used in calibration.
  for i=0,i<c[head].next,i++ do
    if c[head].err[i]!=0 continue
    if Abs(Abs(c[head].ya[i]-yoffset)-c[head].encdist)>ystep/4.0 continue
    j=Floor((c[head].xa[i]-xoffset+xstep/2.0)/xstep+CENTERX)
    if (j<0 || j>=CORRX) continue
    if c[head].ya[i]>yoffset then
      if cp[j]>=0 continue             // Remove reproducibility check points
      dpxin[j]=c[head].xm[i]-c[head].xa[i]
      dpyin[j]=c[head].ym[i]-c[head].ya[i]
      cp[j]=i; pa[j]=accuracy*afactor*0.20
      np++
    else
      if cm[j]>=0 continue             // Remove reproducibility check points
      dmxin[j]=c[head].xm[i]-c[head].xa[i]
      dmyin[j]=c[head].ym[i]-c[head].ya[i]
      cm[j]=i; ma[j]=accuracy*afactor*0.20
      nm++
    endif
  enddo
  if np<2 || nm<2 return -1            // Error: too few data points
  // Restore bad or missing points using splines.
  for i=0,i<CORRX,i++ do
    x[i]=xoffset+(i-CENTERX)*xstep
  enddo
  SYS.Linfit(CORRX,x,dpxin,pa,CORRX,x,dpx);
  SYS.Linfit(CORRX,x,dpyin,pa,CORRX,x,dpy);
  dpxin[0]=dpx[0]; dpyin[0]=dpy[0]
  pa[0]=accuracy*afactor*5.0
  dpxin[CORRX-1]=dpx[CORRX-1]; dpyin[CORRX-1]=dpy[CORRX-1]
  pa[CORRX-1]=accuracy*afactor*5.0
  j=0
  for i=0,i<CORRX,i++ do
    if pa[i]>xstep continue
    xsel[j]=x[i]
    dxsel[j]=dpxin[i]
    dysel[j]=dpyin[i]
    asel[j]=(exactfit?0.0:pa[i])
    j++
  enddo
  i=SYS.Splinefit(j,xsel,dxsel,asel,CORRX,x,dpx)
  if i!=0 return -2                    // Splinefit reports error
  i=SYS.Splinefit(j,xsel,dysel,asel,CORRX,x,dpy)
  if i!=0 return -2                    // Splinefit reports error
  if exactfit==0 then
    // Smooth splined data using 5-point cubical fitting.
    Smooth35(dpx,CORRX)
    Smooth35(dpy,CORRX)
  endif
  SYS.Linfit(CORRX,x,dmxin,ma,CORRX,x,dmx);
  SYS.Linfit(CORRX,x,dmyin,ma,CORRX,x,dmy);
  dmxin[0]=dmx[0]; dmyin[0]=dmy[0]
  ma[0]=accuracy*afactor*5.0
  dmxin[CORRX-1]=dmx[CORRX-1]; dmyin[CORRX-1]=dmy[CORRX-1]
  ma[CORRX-1]=accuracy*afactor*5.0
  j=0
  for i=0,i<CORRX,i++ do
    if ma[i]>xstep continue
    xsel[j]=x[i]
    dxsel[j]=dmxin[i]
    dysel[j]=dmyin[i]
    asel[j]=(exactfit?0.0:ma[i])
    j++
  enddo
  i=SYS.Splinefit(j,xsel,dxsel,asel,CORRX,x,dmx)
  if i!=0 return -2                    // Splinefit reports error
  i=SYS.Splinefit(j,xsel,dysel,asel,CORRX,x,dmy)
  if i!=0 return -2                    // Splinefit reports error
  if exactfit==0 then
    // Smooth splined data using 5-point cubical fitting.
    Smooth35(dmx,CORRX)
    Smooth35(dmy,CORRX)
  endif
  railr=0.0
  sx=0.0; sy=0.0; sxx=0.0; sxy=0.0
  // Estimate parameters of the head's model. I calculate global parameters
  // only in points where at least one measurement is valid.
  n=0
  for i=0,i<CORRX,i++ do
    fip=sign*Asin((dpy[i]+c[head].encdist)/rhead)
    fim=sign*Asin((dmy[i]-c[head].encdist)/rhead)
    rop=dpx[i]-sign*rhead*Cos(fip)
    rom=dmx[i]-sign*rhead*Cos(fim)
    fi=(fip+fim)/2.0
    rodiff=(rop-rom)/2.0
    railteta[i]=Atan(rodiff/c[head].encdist)-fi
    drad[i]=sign*c[head].encdist/Cos(fi+railteta[i])/Sin((fip-fim)/2.0)-rhead
    raild[i]=-(rop+rom)/2.0-                                                   \
      sign*(rhead+drad[i])*(Cos(fip+railteta[i])+Cos(fim+railteta[i]))/2.0
    raily[i]=-rodiff/Tan((fip-fim)/2.0)
    if cp[i]>=0 || cm[i]>=0 then
      railr=railr+drad[i]
      xdist=(i-CENTERX)*xstep
      sx=sx+xdist
      sy=sy+raild[i]
      sxx=sxx+xdist*xdist
      sxy=sxy+xdist*raild[i]
      n++
    endif
  enddo
  railr=railr/n                        // "Mean" radius
  rextra=railr
  shrink=(sx*sy-n*sxy)/(sx*sx-n*sxx)
  railro=(sy-shrink*sx)/n              // Assuming ideal encoder, not board
  c[head].shrink=-shrink
  // Calculate parameters for fine model.
  if makefine then
    for i=0,i<FINEX,i++ do
      fx[i]=xoffset+(i-FINECX)*FINEDX
    enddo
    d=0.0
    i=SYS.Splinefit(CORRX,x,raild,&d,FINEX,fx,fraild)
    if i!=0 makefine=0
    i=SYS.Splinefit(CORRX,x,raily,&d,FINEX,fx,fraily)
    if i!=0 makefine=0
    i=SYS.Splinefit(CORRX,x,railteta,&d,FINEX,fx,frailteta)
    if i!=0 makefine=0
    i=SYS.Splinefit(CORRX,x,drad,&d,FINEX,fx,fdrad)
    if i!=0 makefine=0

    // NOW TAKE INTO ACCOUNT THE RESULTS OF SUB-RASTER ANGULAR DEVIATIONS

  endif
  // Smooth calculated coordinate-dependent parameters.
<<<<<<< CALIBR.SCR
  Smooth35(railteta,CORRX)
  Smooth35(drad,CORRX)
  Smooth35(raild,CORRX)
  Smooth35(raily,CORRX)
  // Now calculate corrections. Note that head parameters are taken at point
  // where linear motor stays, i.e. they depend on the Y coordinate!
  for i=0,i<CORRX,i++ do
    fi0=sign*Asin((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
    ro0=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
    for j=0,j<CORRY,j++ do
      fi=sign*Asin(((j-CENTERY)*ystep-raily[i])/(rhead+rextra))-railteta[i]
      ro=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi+railteta[i])
=======
  Smooth35(railteta,GRIDX)
  Smooth35(drad,GRIDX)
  Smooth35(raild,GRIDX)
  Smooth35(raily,GRIDX)
  // Now calculate legacy corrections in extended raster. Note that head
  // parameters are taken at point where linear motor stays, i.e. they depend
  // on the Y coordinate!
  for i=0,i<GRIDX,i++ do
    fi0=sign*Asinlim((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
    ro0=(i-GRIDCX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
    for j=0,j<GRIDY,j++ do
      fi=sign*Asinlim(((j-GRIDCY)*ystep-raily[i])/(rhead+rextra))-railteta[i]
      ro=(i-GRIDCX)*xstep-railro-sign*(rhead+rextra)*Cos(fi+railteta[i])
>>>>>>> 1.202
      k=i+Floor((ro-ro0)/xstep)
      k=Max(0,Min(k,CORRX-2))
      r=ro-ro0-(k-i)*xstep
      d=(xstep-r)/xstep
      dteta=railteta[k]*d+railteta[k+1]*(1.0-d)
      dh=raily[k]*d+raily[k+1]*(1.0-d)
      dro=(idealboard==0?railro:raild[k]*d+raild[k+1]*(1.0-d))
      dr=(idealboard==0?railr:drad[k]*d+drad[k+1]*(1.0-d))
      fi=sign*Asin(((j-CENTERY)*ystep-dh)/(rhead+dr))-dteta
      ro=(i-CENTERX)*xstep-dro-sign*(rhead+dr)*Cos(fi+dteta)
      if headcam==0 then
        corr[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        corr[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else if headcam==1 then
        hcam[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        hcam[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else
        cnew[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        cnew[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      endif
    enddo
  enddo
  // Save calculated deviations of head from ideal to calibrator.
  c[head].dr=railr
  r=0.0; n=0
  for i=0,i<CORRX,i++ do
    if cp[i]<0 && cm[i]<0 continue
    r=r+railteta[i]
    n++
  enddo
  if n==0 then
    c[head].dteta=0.0
  else
    c[head].dteta=r/n
  endif
  rextra=railr+extralen
  // Compare measured and calculated corrections. If difference is too high
  // (two times the accuracy of calibration board plus accuracy of tester),
  // remove worst point and repeat calculations from the very beginning.
  r=0.0
  k=Floor(c[head].encdist/ystep+0.5)
  for i=0,i<CORRX,i++ do
    if cp[i]>=0 then
      Getcorr(head,headcam,xoffset+(i-CENTERX)*xstep,yoffset+c[head].encdist,  \
        &diffx,&diffy)
      diffx=dpxin[i]-diffx
      diffy=dpyin[i]-diffy
      d=Sqrt(diffx*diffx+diffy*diffy)
      if d>r then
        imax=i; jmax=k+CENTERY; r=d
      endif
    endif
    if cm[i]>=0 then
      Getcorr(head,headcam,xoffset+(i-CENTERX)*xstep,yoffset-c[head].encdist,  \
        &diffx,&diffy)
      diffx=dmxin[i]-diffx
      diffy=dmyin[i]-diffy
      d=Sqrt(diffx*diffx+diffy*diffy)
      if d>r then
        imax=i; jmax=CENTERY-k; r=d
      endif
    endif
  enddo
  if r>(accuracy*afactor+(kelvinscan==1?0.010:0.005))*2.0 && deleted<3 then
    if jmax<CENTERY then
      c[head].err[cm[imax]]=2
    else
      c[head].err[cp[imax]]=2
    endif
    deleted++
    goto repeat
  endif
  // If Y profile is requested, use vertical lines to calculate encoder
  // deviations.
  Memset(dfiy,0,Sizeof(dfiy))          // No Y profile by default
  Memset(ffiy,0,Sizeof(ffiy))
  for j=0,j<CORRY,j++ do
    diffvalid[head][j]=0
    rdiff[head][j]=0.0
    fidiff[head][j]=0.0
  enddo
  if headcam==0 && precisey==PRY_YPROF then
    // Extract data.
    Memset(deltafi,0,Sizeof(deltafi))
    Memset(nfi,0,Sizeof(nfi))
    for m=0,m<c[head].next,m++ do
      if c[head].err[m]!=0 continue
      if 1 || Abs(c[head].xa[m]-c[head].leftprofilex)<xstep*0.25 ||                 \       ///////////////////////////
        Abs(c[head].xa[m]-c[head].rightprofilex)<xstep*0.25                    \
      then
        // Grid node corresponding to vertical scan line.
        i=Floor((c[head].xa[m]-xoffset)/xstep+0.5)+CENTERX
        // Angle and linear coordinate for the crossing with calibration line.
<<<<<<< CALIBR.SCR
        fi0=sign*Asin((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
        ro0=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
=======
        fi0=sign*Asinlim((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
        ro0=(i-GRIDCX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
>>>>>>> 1.202
        // Y grid node and corresponding angle.
<<<<<<< CALIBR.SCR
        j=Floor((c[head].ya[m]-yoffset)/ystep+0.5)+CENTERY
        fi=sign*Asin((c[head].ym[m]-yoffset)/rhead)
=======
        j=Floor((c[head].ya[m]-yoffset)/ystep+0.5)+GRIDCY
        fi=sign*Asinlim((c[head].ym[m]-yoffset)/rhead)
>>>>>>> 1.202
        // Linear head coordinate.
        ro=c[head].xm[m]-xoffset-sign*rhead*Cos(fi)
        // Interpolation factors.
        k=i+Floor((ro-ro0)/xstep)
        k=Max(0,Min(k,CORRX-2))
        r=ro-ro0-(k-i)*xstep
        d=(xstep-r)/xstep
        dteta=railteta[k]*d+railteta[k+1]*(1.0-d)
        dh=raily[k]*d+raily[k+1]*(1.0-d)
        deltafi[j]=deltafi[j]+1.0/Cos(fi+dteta)*                               \
          ((rhead*Sin(fi)-sign*dh-sign*(c[head].ym[m]-c[head].ya[m]))/         \
          (rhead+rextra)-Sin(fi+dteta))
        nfi[j]++
        // For analysis, calculate deviations between measured coordinates and
        // coordinates corrected with 2/3-line calibrations. I split them into
        // radius and angle. Here I assume that crosses on the calibration
        // board coincide with the nodes of calibration raster.
        Getcorr(head,0,c[head].xa[m],c[head].ya[m],&dx,&dy)
        dx=dx-(c[head].xm[m]-c[head].xa[m])
        dy=dy-(c[head].ym[m]-c[head].ya[m])
        fidiff[head][j]=fidiff[head][j]+(dy*Cos(fi)-dx*Sin(fi))*sign
        rdiff[head][j]=rdiff[head][j]+(dy*Sin(fi)+dx*Cos(fi))*sign
        diffvalid[head][j]++
      endif
    enddo
    // Prepare data for extrapolation.
    n=0
    for j=0,j<CORRY,j++ do
      if diffvalid[head][j]>0 then
        fidiff[head][j]=fidiff[head][j]/diffvalid[head][j]
        rdiff[head][j]=rdiff[head][j]/diffvalid[head][j]
      endif
      y[j]=(j-CENTERY)*ystep
      if nfi[j]==0 continue
      fidata[n]=deltafi[j]/nfi[j]
      ydata[n]=y[j]
      n++
    enddo
    if n>=4 then
      d=0.0
      SYS.Splinefit(n,ydata,fidata,&d,CORRY,y,dfiy)
      if makefine then
        for j=0,j<FINEY,j++ do
          fy[j]=rhead*Sin((j-FINECY)*FINEDY/rhead)
        enddo
        SYS.Splinefit(n,ydata,fidata,&d,FINEY,fy,ffiy)
        Smooth35(ffiy,FINEY)
      endif
      Smooth35(dfiy,CORRY)
    endif
  endif
  c[head].shrink=-shrink
  // Recalculate correction files once again, this time with radius correction.
<<<<<<< CALIBR.SCR
  for i=0,i<CORRX,i++ do
    fi0=sign*Asin((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
    ro0=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
    for j=0,j<CORRY,j++ do
      fi=sign*Asin(((j-CENTERY)*ystep-raily[i])/(rhead+rextra))-railteta[i]
      ro=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi+railteta[i])
=======
  for i=0,i<GRIDX,i++ do
    fi0=sign*Asinlim((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
    ro0=(i-GRIDCX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
    for j=0,j<GRIDY,j++ do
      fi=sign*Asinlim(((j-GRIDCY)*ystep-raily[i])/(rhead+rextra))-railteta[i]
      ro=(i-GRIDCX)*xstep-railro-sign*(rhead+rextra)*Cos(fi+railteta[i])
>>>>>>> 1.202
      k=i+Floor((ro-ro0)/xstep)
      k=Max(0,Min(k,CORRX-2))
      r=ro-ro0-(k-i)*xstep
      d=(xstep-r)/xstep
      dteta=railteta[k]*d+railteta[k+1]*(1.0-d)+dfiy[j]
      dh=raily[k]*d+raily[k+1]*(1.0-d)
      dro=(idealboard==0?railro:raild[k]*d+raild[k+1]*(1.0-d))
      dr=(idealboard==0?railr:drad[k]*d+drad[k+1]*(1.0-d))+extralen
      fi=sign*Asin(((j-CENTERY)*ystep-dh)/(rhead+dr))-dteta
      ro=(i-CENTERX)*xstep-dro-sign*(rhead+dr)*Cos(fi+dteta)
      if headcam==0 then
        corr[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        corr[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else if headcam==1 then
        hcam[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        hcam[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else
        cnew[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        cnew[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      endif
    enddo
  enddo
  xellipse=0.0
  if headcam==0 && precisey==PRY_YPROF then
    // Calculations that use Y profile leave small error in X direction
    // (presumably due to the ellipse: 1 degree non-orthogonality of Y axis may
    // lead to up to 17 um error on S1). Correct X shift similarly to the
    // 3-line calibration.
    d=0.0; n=0
    for m=0,m<c[head].next,m++ do
      if c[head].err[m]!=0 continue
      if Abs(c[head].xa[m]-c[head].leftprofilex)>=xstep*0.25 &&                \
        Abs(c[head].xa[m]-c[head].rightprofilex)>=xstep*0.25 continue
      if Abs(c[head].ya[m]-yoffset)>=ystep*2.25 continue
      i=Floor((c[head].xa[m]-xoffset)/xstep+0.5)+CENTERX
      j=Floor((c[head].ya[m]-yoffset)/ystep+0.5)+CENTERY
      if headcam==0 then
        d=d+(c[head].xm[m]-c[head].xa[m])*1000.0-corr[head][i,j].dx
      else
        d=d+(c[head].xm[m]-c[head].xa[m])*1000.0-hcam[head][i,j].dx
      endif
      n++
    enddo
    if n>=2 then
      xellipse=d/n*1.02                // Note: in micrometers!
      // Parabolic corrections.
      for j=0,j<CORRY,j++ do
        r=(j-CENTERY)*ystep/c[head].encdist
        r=Floor(xellipse*(1.0-r*r)+0.5)
        for i=0,i<CORRX,i++ do
          if headcam==0 then
            corr[head][i,j].dx=corr[head][i,j].dx+r
          else if headcam==1 then      // Currently never executed, headcam==0
            hcam[head][i,j].dx=hcam[head][i,j].dx+r
          else                         // Currently never executed, headcam==0
            cnew[head][i,j].dx=cnew[head][i,j].dx+r
          endif
        enddo
      enddo
    endif
  endif
  // Copy smoothed and restored corrections in original points to calibrator.
  // This is necessary for debugging purposes only.
  for i=0,i<CORRX,i++ do
    c[head].dpx[i]=dpx[i]
    c[head].dpy[i]=dpy[i]
    c[head].dmx[i]=dmx[i]
    c[head].dmy[i]=dmy[i]
  enddo
  // Adjust corrections using deviations measured on the auxiliary line. In the
  // previous versions it was the central line, but now it can be any line used
  // to improve the accuracy. I still call it "central line".
  if precisey==PRY_3LINE || (headcam!=0 && precisey==PRY_YPROF) then
    // Get and sort residual inaccuracies on the auxiliary line.
    for i=0,i<c[head].next,i++ do
      if c[head].err[i]!=0 continue
      if Abs(c[head].ya[i]-c[head].centerliney)>ystep*1.25 continue
      j=Floor((c[head].xa[i]-xoffset+xstep/2.0)/xstep+CENTERX)
      if (j<0 || j>=CORRX) continue
      if cz[j]>=0 continue             // Remove reproducibility check points
      Getcorr(head,headcam,c[head].xa[i],c[head].ya[i],                        \
        &diffx,&diffy)
      diffx=c[head].xm[i]-c[head].xa[i]-diffx
      diffy=c[head].ym[i]-c[head].ya[i]-diffy
      if Abs(diffx)>(accuracy*afactor+(kelvinscan==1?0.010:0.005))*5 ||        \
        Abs(diffy)>(accuracy*afactor+(kelvinscan==1?0.010:0.005))*5            \
      then
        c[head].err[i]=2
        deleted++
        continue                       // Deviation too high, possibly error
      endif
      dzxin[j]=diffx
      dzyin[j]=diffy
      cz[j]=i; za[j]=accuracy*0.20*afactor
      nz++
    enddo
    if nz<2 || nz<np-1 || nz<nm-1 then
      if hlog!=NULL then
        fprintf(hlog,"  %i%c: Auxiliary line has ",head/2,(head & 1?'R':'L'))
        fprintf(hlog,"too few valid points (%i), 2-line calibration used\n",nz)
      endif
    else
      // I assume that at calibration lines the deviations are zero and use
      // 3-point parabolas to interpolate in all other points. Again, third
      // line is not necessarily the central one.
      auxdist=c[head].centerliney-yoffset
      for j=0,j<CORRY,j++ do
        r=(j-CORRY/2)*ystep
        xshift=Sqrt(rhead*rhead-r*r)-Sqrt(rhead*rhead-auxdist*auxdist)
        if (head & 1) xshift=-xshift
        for i=0,i<CORRX,i++ do
          xz[i]=x[i]+xshift
        enddo
        SYS.Linfit(CORRX,x,dzxin,za,CORRX,xz,dzx);
        SYS.Linfit(CORRX,x,dzyin,za,CORRX,xz,dzy);
        dzxin[0]=dzx[0]; dzyin[0]=dzy[0]
        za[0]=accuracy*afactor*5.0
        dzxin[CORRX-1]=dzx[CORRX-1]; dzyin[CORRX-1]=dzy[CORRX-1]
        za[CORRX-1]=accuracy*afactor*5.0
        k=0
        for i=0,i<CORRX,i++ do
          if za[i]>xstep continue
          xsel[k]=x[i]
          dxsel[k]=dzxin[i]
          dysel[k]=dzyin[i]
          asel[k]=(exactfit?0.0:za[i])
          k++
        enddo
        i=SYS.Splinefit(k,xsel,dxsel,asel,CORRX,xz,dzx)
        if i!=0 return -2                    // Splinefit reports error
        i=SYS.Splinefit(k,xsel,dysel,asel,CORRX,xz,dzy)
        if i!=0 return -2                    // Splinefit reports error
        if exactfit==0 then
          // Smooth splined data using 5-point cubical fitting.
          Smooth35(dzx,CORRX)
          Smooth35(dzy,CORRX)
        endif
        for i=0,i<CORRX,i++ do
          // Using parabola d=ay^2+b.
          a=dzx[i]/(auxdist*auxdist-c[head].encdist*c[head].encdist)
          b=dzx[i]-a*auxdist*auxdist
          if headcam==0 then
            corr[head][i,j].dx=corr[head][i,j].dx+Floor((a*r*r+b)*1000.0+0.5)
          else if headcam==1 then
            hcam[head][i,j].dx=hcam[head][i,j].dx+Floor((a*r*r+b)*1000.0+0.5)
          else
            cnew[head][i,j].dx=cnew[head][i,j].dx+Floor((a*r*r+b)*1000.0+0.5)
          endif
          a=dzy[i]/(auxdist*auxdist-c[head].encdist*c[head].encdist)
          b=dzy[i]-a*auxdist*auxdist
          if headcam==0 then
            corr[head][i,j].dy=corr[head][i,j].dy+Floor((a*r*r+b)*1000.0+0.5)
          else if headcam==1 then
            hcam[head][i,j].dy=hcam[head][i,j].dy+Floor((a*r*r+b)*1000.0+0.5)
          else
            cnew[head][i,j].dy=cnew[head][i,j].dy+Floor((a*r*r+b)*1000.0+0.5)
          endif
        enddo
      enddo
    endif
  endif
  // If crate supports fine corrections, calculate them. The main difference is
  // that fine corrections are for Ro-Fi nodes in fine raster whereas old are
  // X-Y in standard raster. To facilitate my task, I convert Ro-Fi coordinates
  // of the node to X-Y, calculate corrections similarly to the code above and
  // then convert corrections from X-Y to Ro-Fi.

// NOTE: 3-LINE CALIBRATION IS NOT YET SUPPORTED! MAKE THSI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  if headcam==0 && precisey==PRY_YPROF && makefine!=0 then
    // Currently correction tables are asymmetric (128 points to the left/down
    // from the center but only 127 to the right/up. I fill only symmetric part
    // and restore skipped zero row later.
    d=Max($LAY.top[head/2]/1000.0-yoffset,yoffset-$LAY.bottom[head/2]/1000.0)
    fi=Asin(Max(-0.9999,Min(d/rhead,0.9999)))
    j0=Max(1,FINECY-Floor(fi*rhead/FINEDY)-4)
    j1=Min(FINECY+Floor(fi*rhead/FINEDY)+4,FINEY)
    for i=1,i<FINEX,i++ do
      for j=j0,j<j1,j++ do
        // Point (i,j) is a Ro-Fi correction node. Here are the ideal X-Y
        // coordinates relative to the central point.
        gx=(i-FINECX)*FINEDX+sign*(Cos((j-FINECY)*FINEDY/rhead)-1.0)*rhead
        xi=gx/FINEDX+FINECX            // X "index" of the node
        arg=(j-FINECY)*FINEDY/rhead
        gy=rhead*Sin(Max(-PI/2.0001,Min(arg,PI/2.0001)))
        // Note that indices in raily[], railteta[] and so on correspond to
        // the lines at distance encdist from the central line.
        arg=(c[head].encdist-Interpolate(fraily,FINEX,xi))/(rhead+rextra)
        fi0=sign*Asin(Max(-0.9999,Min(arg,0.9999)))
        ro0=gx-railro-sign*(rhead+rextra)*Cos(fi0)
        arg=(gy-Interpolate(fraily,FINEX,xi))/(rhead+rextra)
        fi=sign*Asin(Max(-0.9999,Min(arg,0.9999)))-                            \
          Interpolate(frailteta,FINEX,xi)
        ro=gx-railro-sign*(rhead+rextra)*                                      \
          Cos(fi+Interpolate(frailteta,FINEX,xi))
        k=Floor(xi+(ro-ro0)/FINEDX)
        k=Max(0,Min(k,FINEX-2))
        d=1.0-((ro-ro0)/FINEDX+xi-k)
        dteta=frailteta[k]*d+frailteta[k+1]*(1.0-d)+ffiy[j]
        dh=fraily[k]*d+fraily[k+1]*(1.0-d)
        dro=(idealboard==0?railro:fraild[k]*d+fraild[k+1]*(1.0-d))
        dr=(idealboard==0?railr:fdrad[k]*d+fdrad[k+1]*(1.0-d))+extralen
        arg=(gy-dh)/(rhead+dr)
        fi=sign*Asin(Max(-0.9999,Min(arg,0.9999)))-dteta
        ro=gx-dro-sign*(rhead+dr)*Cos(fi+dteta)
        dx=ro+sign*rhead*Cos(fi)-gx
        dy=sign*rhead*Sin(fi)-gy
        // Residual parabolic corrections in X for ellipticity.
        r=gy/c[head].encdist
        dx=dx+xellipse/1000.0*(1.0-r*r)
        // X-Y corrections calculated. Convert them to Ro-Fi. To do this, I
        // calculate full Ro-Fi coordinates for the point (x+dx,y+dy) and
        // then subtract ideal (ro,fi).
        fi=Asin(Max(-0.9999,Min((gy+dy)/rhead,0.9999)))
        dro=sign*dx+((Cos((j-FINECY)*FINEDY/rhead))-Cos(fi))*rhead
        dfi=sign*(fi*rhead-(j-FINECY)*FINEDY)
        if (head & 1)==0 then
          // Left head. Fine corrections are in micrometers.
          fcorr[head][i,j].dx=dro*1000.0
          fcorr[head][i,j].dy=dfi*1000.0
        else
          // Right head.
          fcorr[head][2*FINECX-i,2*FINECY-j].dx=dro*1000.0
          fcorr[head][2*FINECX-i,2*FINECY-j].dy=dfi*1000.0
        endif
      enddo
      // Fill unused rows.
      for j=0,j<j0,j++ do
        fcorr[head][i,j].dx=fcorr[head][i,j0].dx
        fcorr[head][i,j].dy=fcorr[head][i,j0].dy
      enddo
      for j=j1,j<FINEY,j++ do
        fcorr[head][i,j].dx=fcorr[head][i,j1-1].dx
        fcorr[head][i,j].dy=fcorr[head][i,j1-1].dy
      enddo
    enddo
    // Fill unused column 0.
    for j=0,j<FINEY,j++ do
      fcorr[head][0,j].dx=fcorr[head][1,j].dx
      fcorr[head][0,j].dy=fcorr[head][1,j].dy
    enddo
    // Fine corrections are valid.
    cext[head].mode=cext[head].mode | CE_VALIDFINE
    cext[head].caldate=$LAY.caldate
    cext[head].corrcount=0
    cext[head].finex0=-FINECX
    cext[head].finenx=FINEX
    cext[head].finey0=j0-FINECY
    cext[head].fineny=j1-j0+1
    cext[head].finedx=FINEDX*1000.0
    cext[head].finedy=FINEDY*1000.0
  endif
  // Corrections calculated. Protocol results to file.
  c[head].corrok=1
  if headcam==1 then
    cext[head].mode=cext[head].mode | (CE_VALID|CE_HEADCAM)
    cext[head].caldate=$LAY.caldate
    cext[head].corrcount=0
  endif
  if hlog!=NULL then
    if headcam==0 then
      fprintf(hlog,"  %i%c:   ",head/2,(head & 1?'R':'L'))
    else
      fprintf(hlog,"  H%i%c:  ",head/2,(head & 1?'R':'L'))
    endif
    fprintf(hlog,"%i crosses excluded, ",deleted)
    fprintf(hlog,"dR=%6.3f, dTeta=%7.4f\n",railr,c[head].dteta)
  endif
  return deleted
end

// Service function, extrapolates data using splines and cubical parabolas.
function int Restoredata(int nin,float *xin,float *yin,float dyin,             \
  int nout,float *xout,float *yout)
  int i,n
  float x[101],y[101],dy[101],step
  if nin<2 || nout<2 return -1         // Error in input parameters
  // Create fictional supporting points that help to extrapolate spline. I use
  // cubical parabolas.
  SYS.Polyfit(nin,xin,yin,Min(3,nin-1),nout,xout,yout)
  step=Abs(xout[1]-xout[0])
  n=0
  for i=0,i<nout,i++ do
    if xout[i]>=xin[0]-step break
    x[n]=xout[i]
    y[n]=yout[i]
    dy[n]=Max(accuracy*0.2,dyin)*5.0
    n++
  enddo
  for i=0,i<nin,i++ do
    x[n]=xin[i]
    y[n]=yin[i]
    dy[n]=dyin*0.16
    n++
  enddo
  for i=0,i<nout,i++ do
    if xout[i]<=xin[nin-1]+step continue
    x[n]=xout[i]
    y[n]=yout[i]
    dy[n]=Max(accuracy*0.2,dyin)*5.0
    n++
  enddo
  // Restore data.
  return SYS.Splinefit(n,x,y,dy,nout,xout,yout)
end

// Calculates head or head camera corrections for the specified head.
// Correction data points may be shifted in X direction from the nodes of the
// correction data grid. If headcam is 0, fills head corrections, if 1 - head
// camera. Returns -1 if there is insufficient number of scanned points, -2 if
// software was unable to interpolate given set of points (hardly possible,
// anyway), and number of points considered as bad (max. 3) if recalculation of
// corrections was successful.
function int Correctshifted(int head,int headcam)
  int i,j,k,m,n,imax,deleted
  float r,xoffset,yoffset,sign,rhead,afactor
  float xorg[3,CORRX],yorg[3,CORRX]    // Exact coordinates (bot,mid,top)
  float dxorg[3,CORRX],dyorg[3,CORRX]  // Measured deviations (bot,mid,top)
  int   norg[3]                        // No. of original points (bot,mid,top)
  float x[CORRX],y[CORRY]              // Coordinates of calibration grid nodes
  float dpx[CORRX],dpy[CORRX]          // Restored corrections at plus line
  int   cp[CORRX]                      // Whether plus point calibrated
  float dmx[CORRX],dmy[CORRX]          // Restored corrections at minus line
  int   cm[CORRX]                      // Whether minus point calibrated
  float dzx[CORRX],dzy[CORRX]          // Restored corrections, middle line
  int   cz[CORRX]                      // Whether middle point calibrated
  float dfiy[CORRY]                    // Splined deltafi(y)
  float deltafi[CORRY]                 // Y profile
  int   nfi[CORRY]                     // Whether Y point calibrated or not
  float fidata[CORRY],ydata[CORRY]
  float railteta[CORRX],drad[CORRX],raild[CORRX],raily[CORRX],xz[CORRX]
  float ffiy[FINEY]
  float fip,fim,fi,rop,rom,ro,rodiff,ro0,fi0,xi,gx,gy,dx,dy
  float railr,rextra,railro,sx,sy,sxx,sxy,xdist,shrink,xellipse
  float a,b,d,dteta,dh,dro,dr,diffx,diffy,auxdist,xshift
  deleted=0
  if c[head].next<4+3*precisey then
    return -1                          // Error: too few calibration points
  endif
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[head/2]/1000.0
  sign=((head & 1)==0)?1.0:-1.0
  rhead=(headcam==0?radius:headcamradius)
  if headcam==0 || illumination==0 || boardtype==0 then
    afactor=1.0
  else
    afactor=2.5                        // Shinethru on glass with headcams
  endif
repeat:
  // Initialize variables.
  for i=0,i<CORRX,i++ do
    cp[i]=0
    cz[i]=0
    cm[i]=0
    x[i]=xoffset+(i-CENTERX)*xstep
  enddo
  // Get all calibrated points on three lines.
  norg[0]=0; norg[1]=0; norg[2]=0
  for i=0,i<c[head].next,i++ do
    if c[head].err[i]!=0 continue
    if Abs(c[head].ya[i]-(yoffset-c[head].encdist))<ystep*0.25 then
      k=0                              // Bottom line
    else if Abs(c[head].ya[i]-(yoffset+c[head].encdist))<ystep*0.25 then
      k=2                              // Top line
    else if Abs(c[head].ya[i]-c[head].centerliney)<ystep*1.25 then
      k=1                              // Central line
    else
      continue                         // Aux point or vertical line, ignore
    endif
    if norg[k]<CORRX then
      xorg[k,norg[k]]=c[head].xa[i]
      yorg[k,norg[k]]=c[head].ya[i]
      dxorg[k,norg[k]]=c[head].xm[i]-c[head].xa[i]
      dyorg[k,norg[k]]=c[head].ym[i]-c[head].ya[i]
      norg[k]++
    endif
  enddo
  if norg[0]<2 || norg[2]<2 then
    return -1                          // Error: too few calibration points
  endif
  // Sort calibrated points by their X coordinates. Bubble sort!
  for k=0,k<3,k++ do
    for i=0,i<norg[k]-1,i++ do
      for j=i+1,j<norg[k],j++ do
        if xorg[k,i]>xorg[k,j] then
          r=xorg[k,i]; xorg[k,i]=xorg[k,j]; xorg[k,j]=r
          r=yorg[k,i]; yorg[k,i]=yorg[k,j]; yorg[k,j]=r
          r=dxorg[k,i]; dxorg[k,i]=dxorg[k,j]; dxorg[k,j]=r
          r=dyorg[k,i]; dyorg[k,i]=dyorg[k,j]; dyorg[k,j]=r
        endif
      enddo
    enddo
  enddo
  // If two points coincide (accuracy check), get mean.
  for k=0,k<3,k++ do
    j=0
    for i=1,i<norg[k],i++ do
      if Abs(xorg[k,j]-xorg[k,i])<xstep*0.1 then
        yorg[k,j]=(yorg[k,j]+yorg[k,i])/2.0
        dxorg[k,j]=(dxorg[k,j]+dxorg[k,i])/2.0
        dyorg[k,j]=(dyorg[k,j]+dyorg[k,i])/2.0
      else
        j++
        xorg[k,j]=xorg[k,i]
        yorg[k,j]=yorg[k,i]
        dxorg[k,j]=dxorg[k,i]
        dyorg[k,j]=dyorg[k,i]
      endif
    enddo
    norg[k]=j+1
  enddo
  if norg[0]<2 || norg[2]<2 then
    return -1                          // Error: too few calibration points
  endif
  if norg[1]<2 norg[1]=0
  // Restore points at the nodes of the calibration grid.
  Restoredata(norg[0],xorg[0],dxorg[0],accuracy*afactor,CORRX,x,dmx)
  Restoredata(norg[0],xorg[0],dyorg[0],accuracy*afactor,CORRX,x,dmy)
  for i=0,i<CORRX,i++ do
    cm[i]=0
    for j=0,j<norg[0],j++ do
      if Abs(x[i]-xorg[0,j])<=xstep/2.0 then
        cm[i]=1; break
      endif
    enddo
  enddo
  Restoredata(norg[2],xorg[2],dxorg[2],accuracy*afactor,CORRX,x,dpx)
  Restoredata(norg[2],xorg[2],dyorg[2],accuracy*afactor,CORRX,x,dpy)
  for i=0,i<CORRX,i++ do
    cp[i]=0
    for j=0,j<norg[2],j++ do
      if Abs(x[i]-xorg[2,j])<=xstep/2.0 then
        cp[i]=1; break
      endif
    enddo
  enddo


/*
  if exactfit==0 then
    // Smooth splined data using 5-point cubical fitting.
    Smooth35(dmx,CORRX)
    Smooth35(dmy,CORRX)
    Smooth35(dmy,CORRX)
    Smooth35(dmy,CORRX)
  endif
*/



  railr=0.0
  sx=0.0; sy=0.0; sxx=0.0; sxy=0.0
  // Estimate parameters of the head's model. I calculate global parameters
  // only in points where at least one measurement is valid.
  n=0
  for i=0,i<CORRX,i++ do
    fip=sign*Asin((dpy[i]+c[head].encdist)/rhead)
    fim=sign*Asin((dmy[i]-c[head].encdist)/rhead)
    rop=dpx[i]-sign*rhead*Cos(fip)
    rom=dmx[i]-sign*rhead*Cos(fim)
    fi=(fip+fim)/2.0
    rodiff=(rop-rom)/2.0
    railteta[i]=Atan(rodiff/c[head].encdist)-fi
    drad[i]=sign*c[head].encdist/Cos(fi+railteta[i])/Sin((fip-fim)/2.0)-rhead
    raild[i]=-(rop+rom)/2.0-                                                   \
      sign*(rhead+drad[i])*(Cos(fip+railteta[i])+Cos(fim+railteta[i]))/2.0
    raily[i]=-rodiff/Tan((fip-fim)/2.0)
    if cp[i]>0 || cm[i]>0 then
      railr=railr+drad[i]
      xdist=(i-CENTERX)*xstep
      sx=sx+xdist
      sy=sy+raild[i]
      sxx=sxx+xdist*xdist
      sxy=sxy+xdist*raild[i]
      n++
    endif
  enddo
  railr=railr/n                        // "Mean" radius
  rextra=railr
  shrink=(sx*sy-n*sxy)/(sx*sx-n*sxx)
  railro=(sy-shrink*sx)/n              // Assuming ideal encoder, not board
  c[head].shrink=-shrink

/*
  // Smooth calculated coordinate-dependent parameters.
  Smooth35(railteta,CORRX)
  Smooth35(drad,CORRX)
  Smooth35(raild,CORRX)
  Smooth35(raily,CORRX)
*/

  // Now calculate corrections. Note that head parameters are taken at point
  // where linear motor stays, i.e. they depend on the Y coordinate!
  for i=0,i<CORRX,i++ do
    fi0=sign*Asin((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
    ro0=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
    for j=0,j<CORRY,j++ do
      fi=sign*Asin(((j-CENTERY)*ystep-raily[i])/(rhead+rextra))-railteta[i]
      ro=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi+railteta[i])
      k=i+Floor((ro-ro0)/xstep)
      k=Max(0,Min(k,CORRX-2))
      r=ro-ro0-(k-i)*xstep
      d=(xstep-r)/xstep
      dteta=railteta[k]*d+railteta[k+1]*(1.0-d)
      dh=raily[k]*d+raily[k+1]*(1.0-d)
      dro=(idealboard==0?railro:raild[k]*d+raild[k+1]*(1.0-d))
      dr=(idealboard==0?railr:drad[k]*d+drad[k+1]*(1.0-d))
      fi=sign*Asin(((j-CENTERY)*ystep-dh)/(rhead+dr))-dteta
      ro=(i-CENTERX)*xstep-dro-sign*(rhead+dr)*Cos(fi+dteta)
      if headcam==0 then
        corr[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        corr[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else if headcam==1 then
        hcam[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        hcam[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else
        cnew[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        cnew[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      endif
    enddo
  enddo
  // Save calculated deviations of head from ideal to calibrator.
  c[head].dr=railr
  r=0.0; n=0
  for i=0,i<CORRX,i++ do
    if cp[i]==0 && cm[i]==0 continue
    r=r+railteta[i]
    n++
  enddo
  if n==0 then
    c[head].dteta=0.0
  else
    c[head].dteta=r/n
  endif
  rextra=railr+extralen
  // Compare measured and calculated corrections on the top and bottom lines.
  // If difference is too high (two times the accuracy of calibration board
  // plus accuracy of tester), remove worst point and repeat calculations from
  // the very beginning.
  r=0.0
  for i=0,i<c[head].next,i++ do
    if c[head].err[i]!=0 ||                                                    \
      Abs(c[head].ya[i]-(yoffset-c[head].encdist))>=ystep*0.25 ||              \
      Abs(c[head].ya[i]-(yoffset+c[head].encdist))>=ystep*0.25                 \
      continue
    Getcorr(head,headcam,c[head].xa[i],c[head].ya[i],&diffx,&diffy)
    diffx=c[head].xm[i]-c[head].xa[i]-diffx
    diffy=c[head].ym[i]-c[head].ya[i]-diffy
    d=Sqrt(diffx*diffx+diffy*diffy)
    if d>r then
      imax=i; r=d
    endif
  enddo
  if r>(accuracy*afactor+(kelvinscan==1?0.010:0.005))*2.0 && deleted<3 then
    c[head].err[imax]=2
    deleted++
    goto repeat
  endif
  // If Y profile is requested, use vertical lines to calculate encoder
  // deviations.
  Memset(dfiy,0,Sizeof(dfiy))          // No Y profile by default
  Memset(ffiy,0,Sizeof(ffiy))
  for j=0,j<CORRY,j++ do
    diffvalid[head][j]=0
    rdiff[head][j]=0.0
    fidiff[head][j]=0.0
  enddo
  if headcam==0 && precisey==PRY_YPROF then
    // Extract data.
    Memset(deltafi,0,Sizeof(deltafi))
    Memset(nfi,0,Sizeof(nfi))
    for m=0,m<c[head].next,m++ do
      if c[head].err[m]!=0 continue
      // Grid node corresponding to vertical scan line.
      i=Floor((c[head].xa[m]-xoffset)/xstep+0.5)+CENTERX
      // Angle and linear coordinate for the crossing with calibration line.
      fi0=sign*Asin((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
      ro0=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
      // Y grid node and corresponding angle.
      j=Floor((c[head].ya[m]-yoffset)/ystep+0.5)+CENTERY
      fi=sign*Asin((c[head].ym[m]-yoffset)/rhead)
      // Linear head coordinate.
      ro=c[head].xm[m]-xoffset-sign*rhead*Cos(fi)
      // Interpolation factors.
      k=i+Floor((ro-ro0)/xstep)
      k=Max(0,Min(k,CORRX-2))
      r=ro-ro0-(k-i)*xstep
      d=(xstep-r)/xstep
      dteta=railteta[k]*d+railteta[k+1]*(1.0-d)
      dh=raily[k]*d+raily[k+1]*(1.0-d)
      deltafi[j]=deltafi[j]+1.0/Cos(fi+dteta)*                                 \
        ((rhead*Sin(fi)-sign*dh-sign*(c[head].ym[m]-c[head].ya[m]))/           \
        (rhead+rextra)-Sin(fi+dteta))
      nfi[j]++
      // For analysis, calculate deviations between measured coordinates and
      // coordinates corrected with 2/3-line calibrations. I split them into
      // radius and angle. Here I assume that crosses on the calibration
      // board coincide with the nodes of calibration raster.
      Getcorr(head,0,c[head].xa[m],c[head].ya[m],&dx,&dy)
      dx=dx-(c[head].xm[m]-c[head].xa[m])
      dy=dy-(c[head].ym[m]-c[head].ya[m])
      fidiff[head][j]=fidiff[head][j]+(dy*Cos(fi)-dx*Sin(fi))*sign
      rdiff[head][j]=rdiff[head][j]+(dy*Sin(fi)+dx*Cos(fi))*sign
      diffvalid[head][j]++
    enddo
    // Prepare data for extrapolation.
    n=0
    for j=0,j<CORRY,j++ do
      if diffvalid[head][j]>0 then
        fidiff[head][j]=fidiff[head][j]/diffvalid[head][j]
        rdiff[head][j]=rdiff[head][j]/diffvalid[head][j]
      endif
      y[j]=(j-CENTERY)*ystep
      if nfi[j]==0 continue
      fidata[n]=deltafi[j]/nfi[j]
      ydata[n]=y[j]
      n++
    enddo
    if n>=4 then
      d=0.0
      SYS.Splinefit(n,ydata,fidata,&d,CORRY,y,dfiy)
      Smooth35(dfiy,CORRY)
    endif
  endif
  c[head].shrink=-shrink
  // Recalculate correction files once again, this time with radius correction.
  for i=0,i<CORRX,i++ do
    fi0=sign*Asin((c[head].encdist-raily[i])/(rhead+rextra))-railteta[i]
    ro0=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
    for j=0,j<CORRY,j++ do
      fi=sign*Asin(((j-CENTERY)*ystep-raily[i])/(rhead+rextra))-railteta[i]
      ro=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi+railteta[i])
      k=i+Floor((ro-ro0)/xstep)
      k=Max(0,Min(k,CORRX-2))
      r=ro-ro0-(k-i)*xstep
      d=(xstep-r)/xstep
      dteta=railteta[k]*d+railteta[k+1]*(1.0-d)+dfiy[j]
      dh=raily[k]*d+raily[k+1]*(1.0-d)
      dro=(idealboard==0?railro:raild[k]*d+raild[k+1]*(1.0-d))
      dr=(idealboard==0?railr:drad[k]*d+drad[k+1]*(1.0-d))+extralen
      fi=sign*Asin(((j-CENTERY)*ystep-dh)/(rhead+dr))-dteta
      ro=(i-CENTERX)*xstep-dro-sign*(rhead+dr)*Cos(fi+dteta)
      if headcam==0 then
        corr[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        corr[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else if headcam==1 then
        hcam[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        hcam[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else
        cnew[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        cnew[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      endif
    enddo
  enddo
  xellipse=0.0
  if headcam==0 && precisey==PRY_YPROF then
    // Calculations that use Y profile leave small error in X direction
    // (presumably due to the ellipse: 1 degree non-orthogonality of Y axis may
    // lead to up to 17 um error on S1). Correct X shift similarly to the
    // 3-line calibration.
    d=0.0; n=0
    for m=0,m<c[head].next,m++ do
      if c[head].err[m]!=0 continue
      if Abs(c[head].xa[m]-c[head].leftprofilex)>=xstep*0.25 &&                \
        Abs(c[head].xa[m]-c[head].rightprofilex)>=xstep*0.25 continue
      if Abs(c[head].ya[m]-yoffset)>=ystep*2.25 continue
      i=Floor((c[head].xa[m]-xoffset)/xstep+0.5)+CENTERX
      j=Floor((c[head].ya[m]-yoffset)/ystep+0.5)+CENTERY
      if headcam==0 then
        d=d+(c[head].xm[m]-c[head].xa[m])*1000.0-corr[head][i,j].dx
      else
        d=d+(c[head].xm[m]-c[head].xa[m])*1000.0-hcam[head][i,j].dx
      endif
      n++
    enddo
    if n>=2 then
      xellipse=d/n*1.02                // Note: in micrometers!
      // Parabolic corrections.
      for j=0,j<CORRY,j++ do
        r=(j-CENTERY)*ystep/c[head].encdist
        r=Floor(xellipse*(1.0-r*r)+0.5)
        for i=0,i<CORRX,i++ do
          if headcam==0 then
            corr[head][i,j].dx=corr[head][i,j].dx+r
          else if headcam==1 then      // Currently never executed, headcam==0
            hcam[head][i,j].dx=hcam[head][i,j].dx+r
          else                         // Currently never executed, headcam==0
            cnew[head][i,j].dx=cnew[head][i,j].dx+r
          endif
        enddo
      enddo
    endif
  endif
  // Copy smoothed and restored corrections in original points to calibrator.
  // This is necessary for debugging purposes only.
  for i=0,i<CORRX,i++ do
    c[head].dpx[i]=dpx[i]
    c[head].dpy[i]=dpy[i]
    c[head].dmx[i]=dmx[i]
    c[head].dmy[i]=dmy[i]
  enddo
  // Adjust corrections using deviations measured on the auxiliary line. In the
  // previous versions it was the central line, but now it can be any line used
  // to improve the accuracy. I still call it "central line".
  if precisey==PRY_3LINE || (headcam!=0 && precisey==PRY_YPROF) then
    j=0
    for i=0,i<norg[1],i++ do
      Getcorr(head,headcam,xorg[1,i],yorg[1,i],&diffx,&diffy)
      diffx=dxorg[1,i]-diffx
      diffy=dyorg[1,i]-diffy
      if Abs(diffx)>(accuracy*afactor+(kelvinscan==1?0.010:0.005))*5 ||        \
        Abs(diffy)>(accuracy*afactor+(kelvinscan==1?0.010:0.005))*5            \
      then
        // Mark point as deleted. It's not critical if point is artificial.
        for k=0,k<<c[head].next,k++ do
          if c[head].err[k]==0 && c[head].xa[k]==xorg[1,i] &&                  \
            c[head].ya[k]==yorg[1,i]                                           \
          then
            c[head].err[k]=2
            break
          endif
        enddo
        deleted++
      else
        xorg[1,j]=xorg[1,i]
        yorg[1,j]=yorg[1,i]
        dxorg[1,j]=diffx
        dyorg[1,j]=diffy
        j++
      endif
    enddo
    norg[1]=j
    if norg[1]<2 || norg[1]<norg[0]-1 || norg[1]<norg[2]-1 then
      if hlog!=NULL then
        fprintf(hlog,"  %i%c: Auxiliary line has ",head/2,(head & 1?'R':'L'))
        fprintf(hlog,"too few valid points (%i), 2-line calibration used\n",   \
        norg[1])
      endif
    else
      // I assume that at calibration lines the deviations are zero and use
      // 3-point parabolas to interpolate in all other points. Again, third
      // line is not necessarily the central one.
      auxdist=c[head].centerliney-yoffset
      for j=0,j<CORRY,j++ do
        r=(j-CORRY/2)*ystep
        xshift=Sqrt(rhead*rhead-r*r)-Sqrt(rhead*rhead-auxdist*auxdist)
        if (head & 1) xshift=-xshift
        for i=0,i<CORRX,i++ do
          xz[i]=x[i]+xshift
        enddo
        Restoredata(norg[1],xorg[1],dxorg[1],accuracy*afactor,CORRX,xz,dzx)
        Restoredata(norg[1],xorg[1],dyorg[1],accuracy*afactor,CORRX,xz,dzy)


//        if exactfit==0 then
//          // Smooth splined data using 5-point cubical fitting.
//          Smooth35(dzx,CORRX)
//          Smooth35(dzy,CORRX)
//        endif



        for i=0,i<CORRX,i++ do
          // Using parabola d=ay^2+b.
          a=dzx[i]/(auxdist*auxdist-c[head].encdist*c[head].encdist)
          b=dzx[i]-a*auxdist*auxdist
          if headcam==0 then
            corr[head][i,j].dx=corr[head][i,j].dx+Floor((a*r*r+b)*1000.0+0.5)
          else if headcam==1 then
            hcam[head][i,j].dx=hcam[head][i,j].dx+Floor((a*r*r+b)*1000.0+0.5)
          else
            cnew[head][i,j].dx=cnew[head][i,j].dx+Floor((a*r*r+b)*1000.0+0.5)
          endif
          a=dzy[i]/(auxdist*auxdist-c[head].encdist*c[head].encdist)
          b=dzy[i]-a*auxdist*auxdist
          if headcam==0 then
            corr[head][i,j].dy=corr[head][i,j].dy+Floor((a*r*r+b)*1000.0+0.5)
          else if headcam==1 then
            hcam[head][i,j].dy=hcam[head][i,j].dy+Floor((a*r*r+b)*1000.0+0.5)
          else
            cnew[head][i,j].dy=cnew[head][i,j].dy+Floor((a*r*r+b)*1000.0+0.5)
          endif
        enddo
      enddo
    endif
  endif
  // Corrections calculated. Protocol results to file.
  c[head].corrok=1
  if headcam==1 then
    cext[head].mode=cext[head].mode | (CE_VALID|CE_HEADCAM)
    cext[head].caldate=$LAY.caldate
    cext[head].corrcount=0
  endif
  if hlog!=NULL then
    if headcam==0 then
      fprintf(hlog,"  %i%c:   ",head/2,(head & 1?'R':'L'))
    else
      fprintf(hlog,"  H%i%c:  ",head/2,(head & 1?'R':'L'))
    endif
    fprintf(hlog,"%i crosses excluded, ",deleted)
    fprintf(hlog,"dR=%6.3f, dTeta=%7.4f\n",railr,c[head].dteta)
  endif
  return deleted
end

// If headcam is 0, calculates head corrections, 1 - head camera (main case)
// and 2 - temporary correction tables for head camera in the general case of
// asymmetrically placed calibration lines. Requires that topliney and
// bottomliney in the calibrator are set. 3-line calibration is unsupported.
// Returns -1 if there is insufficient number of scanned points, -2 if software
// was unable to interpolate given set of points (hardly possible, anyway), and
// number of points considered as bad (max. 3) if recalculation of corrections
// was successful.
function int Correctasym(int head,int headcam)
  int i,j,k,kp,km,n,np,nm,nz,imax,jmax,deleted
  float xoffset,yoffset,xremove,sign,rhead,afactor
  float dpxin[CORRX],dpyin[CORRX]      // Measured corrections
  float pa[CORRX]                      // Accuracy in point
  int   cp[CORRX]                      // Whether calibrated or not
  float dpx[CORRX],dpy[CORRX]          // Splined corrections
  float dmxin[CORRX],dmyin[CORRX]      // Measured corrections
  float ma[CORRX]                      // Accuracy in point
  int   cm[CORRX]                      // Whether calibrated or not
  float dmx[CORRX],dmy[CORRX]          // Splined corrections
  float x[CORRX],xz[CORRX],xshift
  float railteta[CORRX],drad[CORRX],raild[CORRX],raily[CORRX]
  float fip,fim,fi,rop,rom,ro,rodiff,ro0,fi0
  float railr,rextra,railro,sx,sy,sxx,sxy,xdist,shrink
  float a,b,r,d,dteta,dh,dro,dr,diffx,diffy,encplus,encminus
  float xsel[CORRX],dxsel[CORRX],dysel[CORRX]
  deleted=0
  if c[head].next<4 then
    return -1                          // Error: too few calibration points
  endif
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[head/2]/1000.0
  sign=((head & 1)==0)?1.0:-1.0
  rhead=(headcam==0?radius:headcamradius)
repeat:
  np=0; nm=0; nz=0
  for i=0,i<CORRX,i++ do
    cp[i]=-1; dpxin[i]=0.0; dpyin[i]=0.0; pa[i]=xstep*10.0;
    cm[i]=-1; dmxin[i]=0.0; dmyin[i]=0.0; ma[i]=xstep*10.0;
  enddo
  if headcam==0 || illumination==0 || boardtype==0 then
    afactor=1.0
  else
    afactor=2.5                        // Shinethru on glass with headcams
  endif
  // Get and sort points to be used in calibration (top and bottom lines).
  for i=0,i<c[head].next,i++ do
    if c[head].err[i]!=0 continue
    j=Floor((c[head].xa[i]-xoffset+xstep/2.0)/xstep+CENTERX)
    if (j<0 || j>=CORRX) continue
    if Abs(c[head].ya[i]-c[head].topliney)<ystep/4.0 then
      if cp[j]>=0 continue             // Remove reproducibility check points
      dpxin[j]=c[head].xm[i]-c[head].xa[i]
      dpyin[j]=c[head].ym[i]-c[head].ya[i]
      cp[j]=i; pa[j]=accuracy*0.20*afactor
      np++
    else if Abs(c[head].ya[i]-c[head].bottomliney)<ystep/4.0 then
      if cm[j]>=0 continue             // Remove reproducibility check points
      dmxin[j]=c[head].xm[i]-c[head].xa[i]
      dmyin[j]=c[head].ym[i]-c[head].ya[i]
      cm[j]=i; ma[j]=accuracy*0.20*afactor
      nm++
    endif
  enddo
  if np<2 || nm<2 return -1            // Error: too few data points
  // Restore bad or missing points using splines.
  for i=0,i<CORRX,i++ do
    x[i]=xoffset+(i-CENTERX)*xstep
  enddo
  SYS.Linfit(CORRX,x,dpxin,pa,CORRX,x,dpx);
  SYS.Linfit(CORRX,x,dpyin,pa,CORRX,x,dpy);
  dpxin[0]=dpx[0]; dpyin[0]=dpy[0]
  pa[0]=accuracy*afactor
  dpxin[CORRX-1]=dpx[CORRX-1]; dpyin[CORRX-1]=dpy[CORRX-1]
  pa[CORRX-1]=accuracy*afactor
  if exactfit then
    // Splines must pass exactly through the measured points.
    j=0
    for i=0,i<CORRX,i++ do
      if pa[i]>xstep continue
      xsel[j]=x[i]
      dxsel[j]=dpxin[i]
      dysel[j]=dpyin[i]
      j++
    enddo
    r=0.0
    i=SYS.Splinefit(j,xsel,dxsel,&r,CORRX,x,dpx)
    if i!=0 return -2                  // Splinefit reports error
    i=SYS.Splinefit(j,xsel,dysel,&r,CORRX,x,dpy)
    if i!=0 return -2                  // Splinefit reports error
  else
    // Loose splines.
    i=SYS.Splinefit(CORRX,x,dpxin,pa,CORRX,x,dpx)
    if i!=0 return -2                  // Splinefit reports error
    i=SYS.Splinefit(CORRX,x,dpyin,pa,CORRX,x,dpy)
    if i!=0 return -2                  // Splinefit reports error
    // Smooth splined data using 5-point cubical fitting.
    Smooth35(dpx,CORRX)
    Smooth35(dpy,CORRX)
  endif
  SYS.Linfit(CORRX,x,dmxin,ma,CORRX,x,dmx);
  SYS.Linfit(CORRX,x,dmyin,ma,CORRX,x,dmy);
  dmxin[0]=dmx[0]; dmyin[0]=dmy[0]
  ma[0]=accuracy*afactor
  dmxin[CORRX-1]=dmx[CORRX-1]; dmyin[CORRX-1]=dmy[CORRX-1]
  ma[CORRX-1]=accuracy*afactor
  if exactfit then
    // Splines must pass exactly through the measured points.
    j=0
    for i=0,i<CORRX,i++ do
      if ma[i]>xstep continue
      xsel[j]=x[i]
      dxsel[j]=dmxin[i]
      dysel[j]=dmyin[i]
      j++
    enddo
    r=0.0
    i=SYS.Splinefit(j,xsel,dxsel,&r,CORRX,x,dmx)
    if i!=0 return -2                  // Splinefit reports error
    i=SYS.Splinefit(j,xsel,dysel,&r,CORRX,x,dmy)
    if i!=0 return -2                  // Splinefit reports error
  else
    // Loose splines.
    i=SYS.Splinefit(CORRX,x,dmxin,ma,CORRX,x,dmx)
    if i!=0 return -2                  // Splinefit reports error
    i=SYS.Splinefit(CORRX,x,dmyin,ma,CORRX,x,dmy)
    if i!=0 return -2                  // Splinefit reports error
    // Smooth splined data using 5-point cubical fitting.
    Smooth35(dmx,CORRX)
    Smooth35(dmy,CORRX)
  endif
  railr=0.0
  sx=0.0; sy=0.0; sxx=0.0; sxy=0.0
  // Estimate parameters of the head's model. I calculate global parameters
  // only in points where at least one measurement is valid.
  n=0
  encplus=c[head].topliney-yoffset     // Replace encdist in nonsymmetrical
  encminus=yoffset-c[head].bottomliney // calibration. Note: both positive!
  for i=0,i<CORRX,i++ do
    fip=sign*Asin((dpy[i]+encplus)/rhead)
    fim=sign*Asin((dmy[i]-encminus)/rhead)
    rop=dpx[i]-sign*rhead*Cos(fip)
    rom=dmx[i]-sign*rhead*Cos(fim)
    fi=(fip+fim)/2.0
    rodiff=(rop-rom)/2.0
    railteta[i]=Atan(2.0*rodiff/(encplus+encminus))-fi
    drad[i]=sign*(encplus+encminus)/2.0/Cos(fi+railteta[i])/                   \
      Sin((fip-fim)/2.0)-rhead
    raild[i]=-(rop+rom)/2.0-                                                   \
      sign*(rhead+drad[i])*(Cos(fip+railteta[i])+Cos(fim+railteta[i]))/2.0
    raily[i]=(encplus-encminus)/2.0-rodiff/Tan((fip-fim)/2.0)
    if cp[i]>=0 || cm[i]>=0 then
      railr=railr+drad[i]
      xdist=(i-CENTERX)*xstep
      sx=sx+xdist
      sy=sy+raild[i]
      sxx=sxx+xdist*xdist
      sxy=sxy+xdist*raild[i]
      n++
    endif
  enddo
  railr=railr/n                        // "Mean" radius
  rextra=railr
  shrink=(sx*sy-n*sxy)/(sx*sx-n*sxx)
  railro=(sy-shrink*sx)/n              // Assuming ideal encoder, not board
  c[head].shrink=-shrink
  // Smooth calculated coordinate-dependent parameters.
  Smooth35(railteta,CORRX)
  Smooth35(drad,CORRX)
  Smooth35(raild,CORRX)
  Smooth35(raily,CORRX)
  // Now calculate corrections. Note that head parameters are taken at the
  // point where linear motor stays, i.e. they depend on the Y coordinate!
  for i=0,i<CORRX,i++ do
    // If encplus=encminus=encdist, corrections in xxx[i] correspond to the
    // position of linear motor when needle points at encdist. Unsymmetrical
    // calibration assumes that parameters are almost independent on ro (more
    // or less the case for headcam calibration, because head is already
    // corrected). As a compromise, I take the mean of encplus and encminus.
    fi0=sign*Asin(((encplus+encminus)/2.0-raily[i])/(rhead+rextra))-railteta[i]
    ro0=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi0+railteta[i])
    for j=0,j<CORRY,j++ do
      fi=sign*Asin(((j-CENTERY)*ystep-raily[i])/(rhead+rextra))-railteta[i]
      ro=(i-CENTERX)*xstep-railro-sign*(rhead+rextra)*Cos(fi+railteta[i])
      k=i+Floor((ro-ro0)/xstep)
      k=Max(0,Min(k,CORRX-2))
      r=ro-ro0-(k-i)*xstep
      d=(xstep-r)/xstep
      dteta=railteta[k]*d+railteta[k+1]*(1.0-d)
      dh=raily[k]*d+raily[k+1]*(1.0-d)
      dro=(idealboard==0?railro:raild[k]*d+raild[k+1]*(1.0-d))
      dr=(idealboard==0?railr:drad[k]*d+drad[k+1]*(1.0-d))
      fi=sign*Asin(((j-CENTERY)*ystep-dh)/(rhead+dr))-dteta
      ro=(i-CENTERX)*xstep-dro-sign*(rhead+dr)*Cos(fi+dteta)
      if headcam==0 then
        corr[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        corr[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else if headcam==1 then
        hcam[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        hcam[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      else
        cnew[head][i,j].dx=                                                    \
          Floor((ro+sign*rhead*Cos(fi)-(i-CENTERX)*xstep)*1000.0+0.5)
        cnew[head][i,j].dy=                                                    \
          Floor((sign*rhead*Sin(fi)-(j-CENTERY)*ystep)*1000.0+0.5)
        ;
      endif
    enddo
  enddo
  // Save calculated deviations of head from ideal to calibrator.
  c[head].dr=railr
  r=0.0; n=0
  for i=0,i<CORRX,i++ do
    if cp[i]<0 && cm[i]<0 continue
    r=r+railteta[i]
    n++
  enddo
  if n==0 then
    c[head].dteta=0.0
  else
    c[head].dteta=r/n
  endif
  // Compare measured and calculated corrections. If difference is too high
  // (two times the accuracy of calibration board plus accuracy of tester),
  // remove worst point and repeat calculations from the very beginning.
  r=0.0
  kp=Floor(encplus/ystep+0.5)+CENTERY
  km=CENTERY-Floor(encminus/ystep+0.5)
  for i=0,i<CORRX,i++ do
    if cp[i]>=0 then
      Getcorr(head,headcam,xoffset+(i-CENTERX)*xstep,yoffset+encplus,          \
        &diffx,&diffy)
      diffx=dpxin[i]-diffx
      diffy=dpyin[i]-diffy
      d=Sqrt(diffx*diffx+diffy*diffy)
      if d>r then
        imax=i; jmax=kp; r=d
      endif
    endif
    if cm[i]>=0 then
      Getcorr(head,headcam,xoffset+(i-CENTERX)*xstep,yoffset-encminus,         \
        &diffx,&diffy)
      diffx=dmxin[i]-diffx
      diffy=dmyin[i]-diffy
      d=Sqrt(diffx*diffx+diffy*diffy)
      if d>r then
        imax=i; jmax=km; r=d
      endif
    endif
  enddo
  if r>(accuracy*afactor+(kelvinscan==1?0.010:0.005))*2.0 && deleted<3 then
    if jmax<CENTERY then
      c[head].err[cm[imax]]=2
    else
      c[head].err[cp[imax]]=2
    endif
    deleted++
    goto repeat
  endif
  // Radius correction is not implemented here.
  ;
  // Copy smoothed and restored corrections in original points to calibrator.
  // This is necessary for debugging purposes only.
  for i=0,i<CORRX,i++ do
    c[head].dpx[i]=dpx[i]
    c[head].dpy[i]=dpy[i]
    c[head].dmx[i]=dmx[i]
    c[head].dmy[i]=dmy[i]
  enddo
  // 3-line calibration is unsupported.
  ;
  // Corrections calculated. Protocol results to file.
  c[head].corrok=1
  if headcam then
    cext[head].mode=cext[head].mode | (CE_VALID|CE_HEADCAM)
    cext[head].caldate=$LAY.caldate
    cext[head].corrcount=0
  endif
  if hlog!=NULL then
    if headcam==0 then
      fprintf(hlog,"  %i%c:   ",head/2,(head & 1?'R':'L'))
    else
      fprintf(hlog,"  H%i%c:  ",head/2,(head & 1?'R':'L'))
    endif
    fprintf(hlog,"%i crosses excluded, ",deleted)
    fprintf(hlog,"dR=%6.3f, dTeta=%7.4f\n",railr,c[head].dteta)
  endif
  return deleted
end

// Attempts to fit the position of the calibration board with a plane using
// bilinear regression and saves results to c3dnew[]. This data is necessary
// for 3-D calibration. Returns 0 on success and -1 on error.
function int Surfaceposition(int head,float *sigma)
  int i,n,attempt,imax
  float a[3][3],b[3],xoffset,yoffset,x,y,z,delta,dmax,d[5]
  Memset(c3dnew[head],0,256)
  sigma[0]=0.0
  n=c[head].ncal
  if n==0 return -1
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[head/2]/1000.0
  // I allow for at most 4 damaged points (with Z deviation exceeding 100
  // micrometers from the plane).
  for attempt=4,attempt>0,attempt-- do
    Memset(a,0,Sizeof(a))
    Memset(b,0,Sizeof(b))
    for i=0,i<n,i++ do
      if c[head].err[i]!=0 continue    // Point not calibrated
      if c[head].z[i]<=0.0 continue    // Undefined Z ccordinate
      // Get local point coordinates.
      if (head & 1)==0 then
        x=c[head].xm[i]-xoffset        // Left head
        y=c[head].ym[i]-yoffset
      else
        x=xoffset-c[head].xm[i]        // Right head
        y=yoffset-c[head].ym[i]
      endif
      z=c[head].z[i]
      // Calculate matrix.
      a[0,0]=a[0,0]+x*x
      a[0,1]=a[0,1]+x*y
      a[0,2]=a[0,2]+x
      b[0]=b[0]+x*z
      a[1,1]=a[1,1]+y*y
      a[1,2]=a[1,2]+y
      b[1]=b[1]+y*z
      a[2,2]=a[2,2]+1.0
     b[2]=b[2]+z
    enddo
    if a[2,2]<5.0 return -1            // Too few points
    // Matrix a is symmetrical.
    a[1,0]=a[0,1]
    a[2,0]=a[0,2]
    a[2,1]=a[1,2]
    // Solve the system.
    if Solvelinear(a,b,3)!=0 return -1
    // Find point with the highest deviation and calculate dispersion.
    Initsigma(d)
    imax=-1
    dmax=0.0
    for i=0,i<n,i++ do
      if c[head].err[i]!=0 continue    // Point not calibrated
      if c[head].z[i]<=0.0 continue    // Undefined Z ccordinate
      // Get local point coordinates.
      if (head & 1)==0 then
        x=c[head].xm[i]-xoffset        // Left head
        y=c[head].ym[i]-yoffset
      else
        x=xoffset-c[head].xm[i]        // Right head
        y=yoffset-c[head].ym[i]
      endif
      delta=c[head].z[i]-(b[2]+b[0]*x+b[1]*y)
      if Abs(delta)>dmax then
        dmax=Abs(delta)
        imax=i
      endif
      Addsigma(d,delta)
    enddo
    if imax<0 || dmax<=100.0 break     // Good approximation
    // Some point has deviation over 100 um, remove it from Z data.
    c[head].z[imax]=0.0
  enddo
  if attempt==0 return -1              // Too many damaged points
  // Save data to descriptor. Note that measured tilts are in um/mm and must
  // be converted to um/um units.
  c3dnew[head].key=COPT_3D
  c3dnew[head].date=$LAY.caldate       // Date of calibration
  c3dnew[head].mode=1
  c3dnew[head].zcenter=b[2]
  c3dnew[head].zfactorx=b[0]/1000.0
  c3dnew[head].zfactory=b[1]/1000.0
  sigma[0]=Getsigma(d)
  return 0
end

// Returns -1 if there is insufficient number of scanned points, -2 if software
// was unable to interpolate given set of points (hardly possible, anyway), and
// number of points considered as bad (max. 3) if recalculation of corrections
// was successful. It is assumed that encoder is ideal (ATTENTION!) and that
// scan points coincide with the points of correction grid.
function int Correctvideo(int camera)
  int i,j,k,n,bad,head
  float fix[CORRX],fixx[CORRX],fiy[CORRX],fixy[CORRX]
  float ffi[CORRX],fh[CORRX],fdeltax[CORRY],fdeltay[CORRY]
  int nfi[CORRX],nh[CORRX],ndelta[CORRY]
  float accfi[CORRX],acch[CORRX],accy[CORRY]
  float x[CORRX],y[CORRY]
  float xx,yy,xoffset,yoffset,r;
  if (cameras & (1<<camera))==0                                                \
    return 0                           // Camera excluded from calibration
  head=$LAY.nfing*2+camera
  n=c[head].next                       // Number of scanned points
  if n<2 return -1                     // Error: too few data
  // Initialize working arrays.
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[$LAY.nfing]/1000.0
  for i=0,i<CORRX,i++ do
    ffi[i]=0.0; nfi[i]=0; accfi[i]=100.0
    fh[i]=0.0; nh[i]=0; acch[i]=xstep*10.0
    x[i]=xoffset+(i-CENTERX)*xstep
  enddo
  for j=0,j<CORRY,j++ do
    fdeltax[j]=0.0; fdeltay[j]=0.0; ndelta[j]=0
    accy[j]=videoy*10.0                // No limits
    y[j]=yoffset+(j-CENTERY)*videoy
  enddo
  // Gather data.
  for k=0,k<n,k++ do
    if c[head].err[k]!=0 continue      // Bad or excluded point
    i=Floor((c[head].xa[k]-xoffset+xstep/2.0)/xstep+CENTERX)
    if i<0 || i>=CORRX continue        // Outside the grid
    j=Floor((c[head].ya[k]-yoffset+videoy/2.0)/videoy+CENTERY)
    if j<0 || j>=CORRY continue        // Outside the grid
    fix[i]=fix[i]+c[head].ya[k]
    fixx[i]=fixx[i]+c[head].ya[k]*c[head].ya[k]
    fiy[i]=fiy[i]+c[head].xm[k]-c[head].xa[k]
    fixy[i]=fixy[i]+c[head].ya[k]*(c[head].xm[k]-c[head].xa[k])
    nfi[i]++
    fdeltay[j]=fdeltay[j]+(c[head].ya[k]-c[head].ym[k])
    ndelta[j]++
  enddo
  // Restore dfi(x) using least squares (old story about cannons and sparrows).
  for i=0,i<CORRX,i++ do
    if nfi[i]<=2 continue              // No way to calculate camera angle
    r=fix[i]*fix[i]-nfi[i]*fixx[i]
    if Abs(r)<videoy*videoy/2 continue // Unreliable data for least squares
    ffi[i]=(fix[i]*fiy[i]-nfi[i]*fixy[i])/r
    accfi[i]=accuracy/($LAY.top[$LAY.nfing]-$LAY.bottom[$LAY.nfing])*1000.0*0.2
  enddo
  i=SYS.Splinefit(CORRX,x,ffi,accfi,CORRX,x,ffi)
  if i!=0 return -2                    // Splinefit reports error
  // Restore deltay(y), nothing special.
  for j=0,j<CORRY,j++ do
    if ndelta[j]==0 continue
    fdeltay[j]=fdeltay[j]/ndelta[j]
    accy[j]=accuracy*0.20
  enddo
  i=SYS.Splinefit(CORRY,y,fdeltay,accy,CORRY,y,fdeltay)
  if i!=0 return -2                    // Splinefit reports error
  // Gather remaining data.
  for k=0,k<n,k++ do
    if c[head].err[k]!=0 continue      // Bad or excluded point
    i=Floor((c[head].xa[k]-xoffset+xstep/2.0)/xstep+CENTERX)
    if i<0 || i>=CORRX continue        // Outside the grid
    j=Floor((c[head].ya[k]-yoffset+videoy/2.0)/videoy+CENTERY)
    if j<0 || j>=CORRY continue        // Outside the grid
    fdeltax[j]=fdeltax[j]+(c[head].xa[k]-c[head].xm[k])-                       \
      (videolength-c[head].ya[k])*ffi[i]
    fh[i]=fh[i]+(c[head].ya[k]-c[head].ym[k])-fdeltay[j]
    nh[i]++
  enddo
  // Restore deltax(y).
  for j=0,j<CORRY,j++ do
    if ndelta[j]==0 continue
    fdeltax[j]=fdeltax[j]/ndelta[j]
  enddo
  i=SYS.Splinefit(CORRY,y,fdeltax,accy,CORRY,y,fdeltax)
  if i!=0 return -2                    // Splinefit reports error
  // Restore h(x).
  for i=0,i<CORRX,i++ do
    if nh[i]==0 continue
    fh[i]=fh[i]/nh[i]
    acch[i]=accuracy*0.20
  enddo
  i=SYS.Splinefit(CORRX,x,fh,acch,CORRX,x,fh)
  if i!=0 return -2                    // Splinefit reports error
  // Calculate correction tables.
  for i=0,i<CORRX,i++ do
    for j=0,j<CORRY,j++ do
      yy=(j-CENTERY)*videoy+yoffset
      corr[head][i,j].dx=                                                      \
        Floor((-fdeltax[j]-(videolength-yy)*ffi[i])*1000.0+0.5)
      corr[head][i,j].dy=Floor((-fh[i]-fdeltay[j])*1000.0+0.5)
    enddo
  enddo
  // Verify results.
  bad=0
  for k=0,k<n,k++ do
    if c[head].err[k]!=0 continue      // Bad point
    i=Floor((c[head].xa[k]-xoffset+xstep/2.0)/xstep+CENTERX)
    if i<0 || i>=CORRX continue        // Outside the grid
    j=Floor((c[head].ya[k]-yoffset+videoy/2.0)/videoy+CENTERY)
    if j<0 || j>=CORRY continue        // Outside the grid
    xx=c[head].xm[k]-c[head].xa[k]-corr[head][i,j].dx/1000.0
    yy=c[head].ym[k]-c[head].ya[k]-corr[head][i,j].dy/1000.0
    if Abs(xx)>accuracy*3.0 || Abs(yy)>accuracy*3.0 then
      c[head].err[k]=2
      bad++
    endif
  enddo
  // Protocol results to file.
  if hlog!=NULL then
    fprintf(hlog,"  V%s: %i crosses excluded\n",(head & 1?"Bot":"Top"),bad)
  endif
  c[head].corrok=1                     // Corrections calculated
  return bad
end

// Service function, searches for the nearest camera fiducial in Y direction in
// the case of S3 (where both dedicated fiducials and crosses are allowed).
function float Nearestcameray(float y)
  int n
  float yoffset,yexp
  if testertype!=TT_S3 return y
  yoffset=$LAY.yoffset[$LAY.nfing]/1000.0
  n=Floor((y-yoffset+2.5)/155.0)
  yexp=yoffset+n*155.0
  if Abs(y-yexp)<=2.5 return y         // Line between the rails
  yexp=yexp+7.5
  n=Floor((y-yexp)/10.0+0.5)
  return yexp+n*10.0
end

// Returns -1 if there is insufficient number of scanned points, -2 if software
// was unable to interpolate given set of points, and number of points
// considered bad (max. 5) if recalculation of corrections was successful. It
// is assumed that scan points coincide with the points of correction grid. The
// difference from Correctvideo() is that here board is considered ideal and no
// camera model is built; data is simply smoothed.
function int Splinevideo(int camera)
  int i,j,k,kmax,q,n,head,bad
  int valid[CORRX][CORRY],validy[CORRY]
  float r,rmax,corx[CORRX][CORRY],cory[CORRX][CORRY]
  float linexx[CORRX],linexy[CORRX],lineyx[CORRY],lineyy[CORRY]
  float xdata[64],ydata[64],accxy[64],coord[64]
  float xoffset,yoffset,xx,yy,x[CORRX],y[CORRY]
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[$LAY.nfing]/1000.0
  if (cameras & (1<<camera))==0                                                \
    return 0                           // Camera excluded from calibration
  head=$LAY.nfing*2+camera
  bad=0
repeat:
  n=c[head].next                       // Number of scanned points
  if n<4 return -1                     // Error: too few points
  // Prepare variables (necessary when repeating).
  for j=0,j<CORRY,j++ do
    for i=0,i<CORRX,i++ do
      valid[i,j]=0
      corx[i,j]=0.0
      cory[i,j]=0.0
    enddo
    validy[j]=0
  enddo
  // Gather data.
  for k=0,k<n,k++ do
    if c[head].err[k]!=0 continue      // Bad or excluded point
    i=Floor((c[head].xa[k]-xoffset+xstep/2.0)/xstep+CENTERX)
    if i<0 || i>=CORRX continue        // Outside the grid
    j=Floor((c[head].ya[k]-yoffset+videoy/2.0)/videoy+CENTERY)
    if j<0 || j>=CORRY continue        // Outside the grid
    corx[i,j]=corx[i,j]+c[head].xm[k]-c[head].xa[k]
    cory[i,j]=cory[i,j]+c[head].ym[k]-c[head].ya[k]
    valid[i,j]++
  enddo
  for i=0,i<CORRX,i++ do
    for j=0,j<CORRY,j++ do
      if valid[i,j]==0 continue
      corx[i,j]=corx[i,j]/valid[i,j]
      cory[i,j]=cory[i,j]/valid[i,j]
    enddo
  enddo
  // Interpolate available data with splines in horizontal direction.
  for j=0,j<CORRY,j++ do
    k=1
    for i=0,i<CORRX,i++ do
      x[i]=i
      if valid[i,j]==0 continue
      xdata[k]=corx[i,j]
      ydata[k]=cory[i,j]
      accxy[k]=accuracy*0.10
      coord[k]=i
      k++
    enddo
    if k<4 continue                    // Too few points
    SYS.Linfit(k-1,coord+1,xdata+1,accxy,CORRX,x,linexx);
    SYS.Linfit(k-1,coord+1,ydata+1,accxy,CORRX,x,linexy);
    coord[0]=0; accxy[0]=accuracy*5.0
    xdata[0]=linexx[0]; ydata[0]=linexy[0]
    coord[k]=CORRX-1; accxy[k]=accuracy*5.0
    xdata[k]=linexx[CORRX-1]; ydata[k]=linexy[CORRX-1]
    i=SYS.Splinefit(k+1,coord,xdata,accxy,CORRX,x,linexx)
    if i!=0 return -2                  // Splinefit reports error
    i=SYS.Splinefit(k+1,coord,ydata,accxy,CORRX,x,linexy)
    if i!=0 return -2                  // Splinefit reports error
    // Smooth splined data using 5-point cubical fitting.
    Smooth35(linexx,CORRX)
    Smooth35(linexy,CORRX)
    for i=0,i<CORRX,i++ do
      corx[i,j]=linexx[i]
      cory[i,j]=linexy[i]
    enddo
    validy[j]=1
  enddo
  // Interpolate restored data with splines in vertical direction and copy
  // restored data to correction tables.
  for i=0,i<CORRX,i++ do
    k=1
    for j=0,j<CORRY,j++ do
      y[j]=yoffset+(j-CENTERY)*videoy
      if validy[j]==0 continue
      xdata[k]=corx[i,j]
      ydata[k]=cory[i,j]
      accxy[k]=accuracy*0.10
      coord[k]=Nearestcameray(yoffset+(j-CENTERY)*videoy)
      k++
    enddo
    if k<3 return -1
    SYS.Linfit(k-1,coord+1,xdata+1,accxy,CORRY,y,lineyx);
    SYS.Linfit(k-1,coord+1,ydata+1,accxy,CORRY,y,lineyy);
    coord[0]=Nearestcameray(yoffset-CENTERY*videoy)
    accxy[0]=accuracy*5.0
    xdata[0]=lineyx[0]; ydata[0]=lineyy[0]
    coord[k]=Nearestcameray(yoffset+(CORRY-1-CENTERY)*videoy)
    accxy[k]=accuracy*5.0
    xdata[k]=lineyx[CORRY-1]; ydata[k]=lineyy[CORRY-1]
    j=SYS.Splinefit(k+1,coord,xdata,accxy,CORRY,y,lineyx)
    if j!=0 return -2                  // Splinefit reports error
    j=SYS.Splinefit(k+1,coord,ydata,accxy,CORRY,y,lineyy)
    if j!=0 return -2                  // Splinefit reports error
    // Smooth splined data using 5-point cubical fitting.
    Smooth35(lineyx,CORRY)
    Smooth35(lineyy,CORRY)
    for j=0,j<CORRY,j++ do
      corr[head][i,j].dx=Floor(lineyx[j]*1000.0+0.5)
      corr[head][i,j].dy=Floor(lineyy[j]*1000.0+0.5)
    enddo
  enddo
  // Verify results and, if necesary, remove the most outstanding point.
  rmax=-1.0
  for k=0,k<n,k++ do
    if c[head].err[k]!=0 continue      // Bad point
    i=Floor((c[head].xa[k]-xoffset+xstep/2.0)/xstep+CENTERX)
    if i<0 || i>=CORRX continue        // Outside the grid
    j=Floor((c[head].ya[k]-yoffset+videoy/2.0)/videoy+CENTERY)
    if j<0 || j>=CORRY continue        // Outside the grid
    xx=c[head].xm[k]-c[head].xa[k]-corr[head][i,j].dx/1000.0
    yy=c[head].ym[k]-c[head].ya[k]-corr[head][i,j].dy/1000.0
    r=Sqrt(xx*xx+yy*yy)
    if r>rmax then
      rmax=r; kmax=k
    endif
  enddo
  if rmax>(accuracy+0.005)*3.0 && bad<5 then
    c[head].err[kmax]=2
    bad++
    goto repeat
  endif
  // Protocol results to file.
  if hlog!=NULL then
    fprintf(hlog,"  V%s: %i crosses excluded\n",(head & 1?"Bot":"Top"),bad)
  endif
  c[head].corrok=1                     // Corrections calculated
  return bad
end

// Calculates corrections from the verification data, without head or camera
// model. Similar to Splinevideo(). Returns 0 on success, -1 if number of
// verification points is insufficient for meaningful corrections and -2 if
// software was unable to fit data.
function int Correctionsfromverification(int head)
  int i,j,k,kmax,n,bad
  int valid[CORRX][CORRY],validy[CORRY]
  float r,rmax,corx[CORRX][CORRY],cory[CORRX][CORRY],stepx,stepy
  float linexx[CORRX],linexy[CORRX],lineyx[CORRY],lineyy[CORRY]
  float xdata[64],ydata[64],accxy[64],coord[64]
  float xoffset,yoffset,xx,yy,x[CORRX],y[CORRY]
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[head/2]/1000.0
  n=c[head].next                       // Number of scanned points
  if n<16 return -1                    // Error: too few points
  bad=0
repeat:
  if head<$LAY.nfing*2 then
    stepx=xstep                        // Head
    stepy=ystep
  else
    stepx=xstep                        // Video camera
    stepy=videoy
  endif
  // Prepare variables (necessary when repeating).
  for j=0,j<CORRY,j++ do
    for i=0,i<CORRX,i++ do
      valid[i,j]=0
      corx[i,j]=0.0
      cory[i,j]=0.0
    enddo
    validy[j]=0
  enddo
  // Gather data.
  for k=0,k<n,k++ do
    if c[head].err[k]!=0 continue      // Bad or excluded point
    i=Floor((c[head].xa[k]-xoffset+stepx/2.0)/stepx+CENTERX)
    if i<0 || i>=CORRX continue        // Outside the grid
    j=Floor((c[head].ya[k]-yoffset+stepy/2.0)/stepy+CENTERY)
    if j<0 || j>=CORRY continue        // Outside the grid
    corx[i,j]=corx[i,j]+c[head].xm[k]-c[head].xa[k]
    cory[i,j]=cory[i,j]+c[head].ym[k]-c[head].ya[k]
    valid[i,j]++
  enddo
  for i=0,i<CORRX,i++ do
    for j=0,j<CORRY,j++ do
      if valid[i,j]==0 continue
      corx[i,j]=corx[i,j]/valid[i,j]
      cory[i,j]=cory[i,j]/valid[i,j]
    enddo
  enddo
  // Interpolate available data with splines in horizontal direction.
  for j=0,j<CORRY,j++ do
    k=1
    for i=0,i<CORRX,i++ do
      x[i]=i
      if valid[i,j]==0 continue
      xdata[k]=corx[i,j]
      ydata[k]=cory[i,j]
      accxy[k]=accuracy*0.10
      coord[k]=i
      k++
    enddo
    if k<5 continue                    // Too few points
    SYS.Linfit(k-1,coord+1,xdata+1,accxy,CORRX,x,linexx);
    SYS.Linfit(k-1,coord+1,ydata+1,accxy,CORRX,x,linexy);
    coord[0]=0; accxy[0]=accuracy*5.0
    xdata[0]=linexx[0]; ydata[0]=linexy[0]
    coord[k]=CORRX-1; accxy[k]=accuracy*5.0
    xdata[k]=linexx[CORRX-1]; ydata[k]=linexy[CORRX-1]
    i=SYS.Splinefit(k+1,coord,xdata,accxy,CORRX,x,linexx)
    if i!=0 return -2                  // Splinefit reports error
    i=SYS.Splinefit(k+1,coord,ydata,accxy,CORRX,x,linexy)
    if i!=0 return -2                  // Splinefit reports error
    for i=0,i<CORRX,i++ do
      corx[i,j]=linexx[i]
      cory[i,j]=linexy[i]
    enddo
    validy[j]=1
  enddo
  // Interpolate restored data with splines in vertical direction and copy
  // restored data to correction tables.
  for i=0,i<CORRX,i++ do
    k=1
    for j=0,j<CORRY,j++ do
      y[j]=j
      if validy[j]==0 continue
      xdata[k]=corx[i,j]
      ydata[k]=cory[i,j]
      accxy[k]=accuracy*0.10
      coord[k]=j
      k++
    enddo
    if k<3 return -1
    SYS.Linfit(k-1,coord+1,xdata+1,accxy,CORRY,y,lineyx);
    SYS.Linfit(k-1,coord+1,ydata+1,accxy,CORRY,y,lineyy);
    coord[0]=0; accxy[0]=accuracy*5.0
    xdata[0]=lineyx[0]; ydata[0]=lineyy[0]
    coord[k]=CORRY-1; accxy[k]=accuracy*5.0
    xdata[k]=lineyx[CORRY-1]; ydata[k]=lineyy[CORRY-1]
    j=SYS.Splinefit(k+1,coord,xdata,accxy,CORRY,y,lineyx)
    if j!=0 return -2                  // Splinefit reports error
    j=SYS.Splinefit(k+1,coord,ydata,accxy,CORRY,y,lineyy)
    if j!=0 return -2                  // Splinefit reports error
    for j=0,j<CORRY,j++ do
      cnew[head][i,j].dx=Floor(lineyx[j]*1000.0+0.5)
      cnew[head][i,j].dy=Floor(lineyy[j]*1000.0+0.5)
    enddo
  enddo
  // Verify results and, if necesary, remove the most outstanding point.
  rmax=-1.0
  for k=0,k<n,k++ do
    if c[head].err[k]!=0 continue      // Bad point
    i=Floor((c[head].xa[k]-xoffset+stepx/2.0)/stepx+CENTERX)
    if i<0 || i>=CORRX continue        // Outside the grid
    j=Floor((c[head].ya[k]-yoffset+stepy/2.0)/stepy+CENTERY)
    if j<0 || j>=CORRY continue        // Outside the grid
    xx=c[head].xm[k]-c[head].xa[k]-cnew[head][i,j].dx/1000.0
    yy=c[head].ym[k]-c[head].ya[k]-cnew[head][i,j].dy/1000.0
    r=Sqrt(xx*xx+yy*yy)
    if r>rmax then
      rmax=r; kmax=k
    endif
  enddo
  if rmax>(accuracy+0.005)*3.0 && bad<5 then
    c[head].err[kmax]=2
    bad++
    goto repeat
  endif
  return 0
end

// Check whether some critical error was detected, such as broken cable, absent
// measurement card, damaged locks etc. Returns 0 if calibration should
// continue, 1 if tester to be rebooted, or -1 if operator decided to interrupt
// calibration.
function int Checkgloberrors()
  int err
  handle hcont,hboot
  if videoonly globalerr=globalerr & (~GE_MEAS)
  if globalerr==0 return 0
  change hinfo limits=0,0
  change hinfo text="Error detected"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED text="Critical error detected!"
  draw at 6,60 color=BLACK
  if globalerr & GE_BOOT then
    draw text="Tester is not booted. Perharps somebody pressed emergency "
    draw text="switch, or surge caused crash of embedded software. "
    err=1
  else if globalerr & GE_HARDWARE then
    draw text="Embedded software detected some problems with shuttle. Please "
    draw text="check sensors and pneumatics. "
    err=0
  else if globalerr & GE_IOERROR then
    draw text="Embedded software detected serial transmission error. Please "
    draw text="check cables and connections to the ground. "
    err=2
  else if globalerr & GE_COMMAND then
    draw text="Embedded software rejected some command. Please check the "
    draw text="version of embedded software. "
    err=2
  else if globalerr & GE_MEAS then
    draw text="Self-test has detected severe error in measurement electronics. "
    draw text="Correct resistive measurements seem to be impossible. Please "
    draw text="check measurement hardware. "
    err=2
  else
    draw text="Some internal error occured. "
    err=2
  endif
  globalerr=0                          // Two errors at once? Hardly possible.
  hboot=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Reboot"
    help="Press to reload the Flying Probe Tester"
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Continue"
    help="Press to continue calibration at your own risk!"
  endc
  if err==0 then                       // No serious error
    draw text="Press 'Continue' to continue calibration."
    disable hboot
  else if err==1 then
    draw text="You must reboot the tester and begin calibration again."
    disable hcont
  else
    draw text="\nContinuation of calibration may result in strange tester "
    draw text="behaviour and unreliable calibration. Try to reboot tester or "
    draw text="continue at your own risk!"
  endif
  draw show
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hboot) then
      return 1
    else if Pressed(hcont) || autoconfirm then
      return 0
    endif
    wait
  enddo
end

// Compiles and loads additional scripts necessary for calibration.
function int Preparescripts()
  handle hok
  clear hright
  change hinfo limits=0,0
  // If this script is called directly from the Test Player, default parameters
  // may be yet uninitialized.
  if $GLOBAL.defstroke==0 then
    $GLOBAL.defstroke=40
    $GLOBAL.defpressure=30
    $GLOBAL.defheight=5000
    $GLOBAL.defaccuracy=250
  endif
  if SYS.Compile("loader.scr",1)!=0 then
    change hinfo text="Module 'LOADER' is unavailable"
  else if SYS.Compile("serv.scr",1)!=0 then
    change hinfo text="Module 'SERV' is unavailable"
  else
    return 0
  endif
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED text="Unrecoverable error detected!"
  draw at 6,60 color=BLACK
  draw text="This calibration script uses functions from some other script "
  draw text="files, such as SERV or LOADER. Some of these files are absent, "
  draw text="or have errors, or cannot be loaded, so correct calibration is "
  draw text="not possible. The exact reason is listed in the main OT window. "
  draw color=LIGHTRED text="Please upgrade your OllyTest installation!"
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Oops..."
    help="Press to terminate the calibration"
  endc
  while Pressed(hok)==0 && Pressed(hexit)==0 do
    wait
  enddo
  return -1
end

// Check that Flying Probe Tester is loaded. Leave this procedure only when
// tester is loaded or when Close button is pressed.
function int Loadtester()
  int i,j,t
  handle hload,hretry,hdemomode
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="Soft reset"
  delay 500
  if demo return 0
  SYS.Softimm(0)
  t=Time(); i=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format(" - %i s",j)
      i=j
    endif
    if j>=4 && hdemomode==NULL then
      hdemomode=control BUTTON
        window=hright
        position=(RIGHTX-120)/2,USERY,120,24
        name="Run demo"
        help="Press to run calibration in demo mode"
        bkcolor=WHITE
      endc
    endif
    if hdemomode!=NULL && Pressed(hdemomode) then
      demo=1
      draw window=hmain bitmap=0,0,1,"demobk" show
      return 0
    endif
    if j>15 break
    wait
  enddo
  draw window=hright font=TIMESFONT
  if $A[0].length==0 then
    if hdemomode!=NULL destroy hdemomode
    change hinfo name="No answer from crate"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is switched off\n"
    draw text="- Crash in embedded software\n"
    if $GLOBAL.a5==0 then
      draw text="- Flying Debugger or Test Player is running\n"
      draw text="- Optocable is pulled out\n"
    else
      draw text="- Network cable is unplugged\n"
    endif
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Try again"
      help="Press to re-attempt connection"
    endc
    while 1 do
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      wait
    enddo
  else if $A[0].answer==S_ERROR &&                                             \
    ($A[0].subcmd==E_NOCRATDATA || $A[0].subcmd==E_NOFINGDATA) then
    change hinfo name="Tester not loaded"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="The Flying Probe Tester is not loaded. Of course, it "
    draw color=LIGHTRED text="must " color=BLACK
    draw text="be loaded before you can start calibration. Typically, all you "
    draw text="need is to press 'Load all' in the appearing window. "
    if $GLOBAL.disabledrails!=0 then
      draw text="Please check for rails disabled in the Debug mode. "
    endif
    if ($GLOBAL.debugmode & 0x20BF)!=0 || ($GLOBAL.videomode & 0x20BF)!=0 ||   \
      $GLOBAL.disabledrails!=0 || $uint4($GLOBAL+280)!=0 then
      draw color=LIGHTRED
      draw text="Please also check that current Debug mode allows you to "
      draw text="calibrate tester!"
    endif
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Call Loader"
      help="Press to load the Flying Probe Tester"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Try again"
      help="Press to re-attempt connection"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if $A[0].answer!=S_RESET then
    change hinfo name="Wrong answer to Soft Reset"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="Flying Probe Tester returned some unexpected answer. Normally, "
    draw text="this never happens. All I may suggest is to press 'Hard Reset' "
    draw text="and then reboot the tester. "
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Call Loader"
      help="Press to load the Flying Probe Tester"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Try again"
      help="Press to re-attempt connection"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  endif
  return 0
end

// Gets actual layout with all available extentions from the tester.
function int Getlayout()
  int i,j,t,mask,err
  char buf[16]
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text=""
  delay 500
  if demo return 0
  // Get main layout.
  buf[0]=S_LAYOUT
  buf[1]=0x03                          // Read layout with corrected phases
  SYS.Sendimm(0,2,buf)
  t=Time(); i=0; err=0
  while 1 do
    if $A[0].length!=0 then
      if $A[0].answer!=S_LAYOUT || $A[0].length!=774 err=1
      break
    endif
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("Waiting for layout - %i s",j)
      i=j
    endif
    if j>15 then
      err=2; break                     // Timeout!
    endif
    wait
  enddo
  if err==0 then
    // Layout received. Get layout extentions.
    Memcpy($LAY,$A[0]+6,768)
    for i=0,i<16,i++                   // Same offsets in tester & inner copy
      $LAYCORR.leftzerox[i]=$LAY.leftzerox[i]
      $LAYCORR.leftzeroy[i]=$LAY.leftzeroy[i]
      $LAYCORR.rightzerox[i]=$LAY.rightzerox[i]
      $LAYCORR.rightzeroy[i]=$LAY.rightzeroy[i]
    enddo
    if $LAY.extlay>=1 then
      buf[0]=S_LAYOUT
      buf[1]=15                        // Read main layout extention
      SYS.Sendimm(0,2,buf)
    endif
    for j=1,j<$LAY.extlay && j<5,j++ do
      buf[0]=S_LAYOUT
      buf[1]=20                        // Read additional layout extention
      $int4(buf+2)=j-1                 // Index
      SYS.Sendimm(j,6,buf)
    enddo
    i=-1
    while 1 do
      for j=0,j<$LAY.extlay && j<5,j++ do
        if $A[j].length==0 break
        if $A[j].answer!=S_LAYOUT || $A[j].length!=(j==0?774:778) then
          err=1; break                 // Invalid answer
        endif
      enddo
      if err!=0 || j>=$LAY.extlay break
      if Pressed(hexit) return -1
      j=(Time()-t)/1000
      if i!=j then
        change hinfo text=format("Waiting for layout - %i s",j)
        i=j
      endif
      if j>15 then
        err=2; break                   // Timeout!
      endif
      wait
    enddo
    if err==0 then
      Memcpy($EXTLAY,$A[0]+6,768)
      if $LAY.extlay>=2 then
        Memcpy($EXT0,$A[1]+10,768)
      else
        Memset($EXT0,0,768)
      endif
      if $LAY.extlay>=3 then
        Memcpy($EXT1,$A[2]+10,768)
      else
        Memset($EXT1,0,768)
      endif
      if $LAY.extlay>=4 then
        Memcpy($EXT2,$A[3]+10,768)
      else
        Memset($EXT2,0,768)
      endif
      if $LAY.extlay>=5 then
        Memcpy($EXT3,$A[4]+10,768)
      else
        Memset($EXT3,0,768)
      endif
    endif
    SYS.Broadcast(8,"CHG LAY")         // Inform others that layout changed
  endif
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if err==1 then
    change hinfo text="Error getting layout"
    draw text="Calibration script was unable to get layout correctly. This "
    draw text="error is absolutely unexpected here. Perharps, the best way to "
    draw text="recover is to reboot the tester. If you select this option, "
    draw text="then in the appearing window first press 'Hard reset', then "
    draw text="'Load all'. After the tester is loaded, try to get layout again."
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Call Loader"
      help="Press to reload the Flying Probe Tester"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Try again"
      help="Press to re-attempt getting layout"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if err==2 then
    change hinfo text="No answer from crate"
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is off\n"
    draw text="- Flying Debugger or Test Player is running\n"
    draw text="- Crash in embedded software\n"
    draw text="- Optocable is pulled out\n"
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Try again"
      help="Press to re-attempt connection"
    endc
    while 1 do
      if Pressed(hretry) break
      if Pressed(hexit) return -1
      wait
    enddo
  endif
  // If all heads in layout are disabled, probably we have external scanner.
  mask=(1<<$LAY.nfing)-1
  if ($LAY.excludedrails & mask)==mask then
    videoonly=1
  else
    videoonly=0
  endif
  return err
end

// Checks for rails disabled in layout. Returns 0 if all rails are enabled or
// if operator decided to continue calibration, and -1 to close calibration.
function int Checklayout()
  int i,n,nexcl,excludedrails
  char s[256]
  handle hcont,hfinish
  excludedrails=$LAY.excludedrails & ((1<<$LAY.nfing)-1)
  if $LAY.cameras!=0                                                           \
    excludedrails=excludedrails | ($LAY.excludedrails & 0xC000)
  if excludedrails==0 &&                                                       \
    (($LAY.config & LC_VACUUMBOX)==0 || testersides==0x1) return 0
  clear hright
  change hinfo limits=0,0
  change hinfo text="Disabled rails"
  draw window=hright font=TIMESFONT
  draw color=LIGHTRED at 6,30 wrap=RIGHTX-5
  if excludedrails!=0 then
    draw text="Some rails are disabled. " color=BLACK
    n=0; nexcl=0
    for i=0,i<$LAY.nfing,i++ do
      if ($LAY.excludedrails & (1<<i))==0 &&                                   \
        (($LAY.config & LC_VACUUMBOX)==0 || $LAY.side[i]==0) continue
      if n!=0 n=n+sprintf(s+n,", ")
      n=n+sprintf(s+n,"%i",i)
      nexcl++
    enddo
    if nexcl==1 then
      draw text=format("Rail %s is ",s)
    else
      draw text=format("Rails %s are ",s)
    endif
    draw text="excluded from the bootstrap and measurements in the main "
    draw text="tester layout. "
  else
    draw text="Bottom side is disabled. " color=BLACK
    draw text="Checkbox " font=MAINFONT text="Vacuum box " font=TIMESFONT
    draw text="in the main tester layout prevents movements of bottom "
    draw text="fingers and camera. They will be excluded from the "
    draw text="calibration. "
  endif
  draw text="Please decide whether you want to calibrate the handicapped "
  draw text="tester."
  draw show
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Continue"
    help="Press to calibrate remaining rails"
  endc
  hfinish=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Quit"
    help="Press to finish calibration"
  endc
  while 1 do
    if Pressed(hcont) then
      return 0
    else if Pressed(hfinish) then
      startlayout=1
      return -1
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Disables automatic adjustment of brightness and contrast on all video
// cameras. Errors are ignored. Works for all kinds of cameras.
function int Disableautoset()
  int head,channel
  for head=0,head<($LAY.nfing+1)*2,head++ do
    channel=Channelfromhead(head)
    if channel<0 continue
    SYS.Autoset(channel,0)
  enddo
end

// Reads current tester temperature (in 1/10-th of degree). If necessary, uses
// USB sensor. If operator interrupted C adjust, returns -1. if there was a
// command sending or receiving error, returns 1. Otherwise, returns
// temperature in the range 10..999, which corresponds to 1..99.9 degrees. It
// is the responsibility of caller to display and process errors.
function int Readtemperature()
  int ident,t,temp
  char s[128]
  float etemp
  if ($EXTLAY.measopt & HCM_TMEASOFF) then
    temp=220                           // Default temperature
  else
    sprintf(s,"INPORT %i",0x2011)      // Read effective (smoothed) temperature
    ident=SERV.Cmdimm(32,s)
    if ident<=0 return 1               // Unable to send command
    t=Time()                           // Timeout 5 seconds
    while $A[32].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Time()-t>5000 return 1        // Timeout exhausted
      wait
    enddo
    if $A[32].length!=7 return 1       // Bad length of answer
    if $A[32].answer!=S_INPORT return 1// Bad answer
    temp=$uint2($A[32]+5)
  endif
  if temp==220 then                    // Default temperature, try USB sensor
    if SYS.Exttemperature(&etemp)==0 then
      temp=Floor(etemp*10.0+0.5)
    endif
  endif
  return Min(999,Max(10,temp))
end

// Function applies measured offsets to layout (if temponly is 0) and writes
// calibration date and temperature.
function int Applyoffsets(int temponly)
  int i,j,k,n,nhead
  float dx,dy
  char s[32]
  if demo return 0
  // Apply offsets.
  if (temponly==0) then
    nhead=2*$LAY.nfing
    if $LAY.cameras!=0 nhead=nhead+2
    for i=0,i<nhead,i++ do
      if c[i].next==0 continue         // Not scanned
      // In some cases there are two or more scans of central point (for
      // example, when script checks hysteresis of the dedicated camera).
      dx=0.0; dy=0.0; n=0
      for j=0,j<c[i].next,j++ do
        if c[i].err[j]!=0 continue     // Scanned with error
        // Note that X coordinate of the cross may differ from the rail center
        // if it is not reachable (like S3 with split shuttle) and is not
        // checked here.
        if c[i].ya[j]!=$LAY.yoffset[i/2]/1000.0 continue
        dx=dx+c[i].xm[j]-c[i].xa[j]
        dy=dy+c[i].ym[j]-c[i].ya[j]
        n++
      enddo
      if n>0 then
        dx=dx/n
        dy=dy/n
        if (i & 1)==0 then             // Left head
          $LAY.leftzerox[i/2]=$LAYCORR.leftzerox[i/2]+dx*1000.0
          $LAY.leftzeroy[i/2]=$LAYCORR.leftzeroy[i/2]+dy*1000.0
        else                           // Right head
          $LAY.rightzerox[i/2]=$LAYCORR.rightzerox[i/2]+dx*1000.0
          $LAY.rightzeroy[i/2]=$LAYCORR.rightzeroy[i/2]+dy*1000.0
        endif
      endif
    enddo
  endif
  // Update date. What a kludge.
  if (temponly==0) then
    Strtime(s,"%d,%m,%Y",0,0)
    sscanf(s,"%i,%i,%i",&i,&j,&k)
    $LAY.caldate=(i+j*32+(k-1980)*512) & 0xFFFF
  endif
  // Update temperature.
  i=Readtemperature()
  if i<10 i=0
  $LAY.caltemp=i
  SYS.Broadcast(8,"CHG LAY")           // Inform others that layout changed
end

// Function loads corrected layout and layout extentions to the tester.
function int Loadlayout(int temponly)
  int i,j,t,isa5,maxextent,nextent,err
  char buf[774]
  handle hretry
  change hinfo limits=0,0
  change hinfo text="Reloading layout"
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Calibration procedure is loading new layout with "
  if temponly then
    draw text="updated temperature to the tester."
  else
    draw text="corrected offsets of central points to the tester."
  endif
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 then
    draw text=" This operation may take up to one minute."
    isa5=0
  else
    isa5=1
  endif
  draw show
  if demo then
    delay 500
    return 0
  endif
  SYS.Softimm(0)
  t=Time(); i=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if j>3 && i!=j then
      change hinfo text=format(" - %i s",j)
      i=j
    endif
    wait
  enddo
  // Load main layout. Answer indicates whether and how many additional layout
  // extentions are supported.
  buf[0]=S_LOADRUN
  buf[1]=2                             // Reload layout
  $int4(buf+2)=0                       // Dummy zero bytes
  Memcpy(buf+6,$LAY,768)
  if SYS.Sendimm(0,774,buf)<=0 err=1   // Unable to send command
  t=Time(); i=-1
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("Reloading layout - %i s",j)
      i=j
    endif
    if j>=120 then
      SYS.Killimm(0)
      err=2; break                     // Timeout
    endif
    wait
  enddo
  if err==0 && $A[0].answer!=S_LOADRUN then
    err=3
  endif
  // Calculate total number of layout extentions to load.
  nextent=0
  if err==0 then
    if isa5 && $A[0].length>=7 then
      maxextent=$char($A[0]+6)
    else
      maxextent=1
    endif
    if maxextent>=5 then
      for i=4,i<768,i++ do             // First 4 bytes are validity marker
        if $char($EXT3+i)!=0 break
      enddo
      if i<768 nextent=5
    endif
    if nextent==0 && maxextent>=4 then
      for i=4,i<768,i++ do
        if $char($EXT2+i)!=0 break
      enddo
      if i<768 nextent=4
    endif
    if nextent==0 && maxextent>=3 then
      for i=4,i<768,i++ do
        if $char($EXT1+i)!=0 break
      enddo
      if i<768 nextent=3
    endif
    if nextent==0 && maxextent>=2 then
      for i=4,i<768,i++ do
        if $char($EXT0+i)!=0 break
      enddo
      if i<768 nextent=2
    endif
    if nextent==0 then
      for i=0,i<768,i++ do
        if $char($EXTLAY+i)!=0 break
      enddo
      if i<768 nextent=1
    endif
  endif
  // Send additional layout extentions. Note that main extention is sent
  // afterwards, this is the recommended order.
  for j=1,j<nextent && err==0,j++ do   // Note: nextent<=5
    buf[0]=S_LOADRUN
    buf[1]=20                          // Load additional layout extention
    $int4(buf+2)=j-1                   // Index
    if j==1 then
      Memcpy(buf+6,$EXT0,768)
    else if j==2 then
      Memcpy(buf+6,$EXT1,768)
    else if j==3 then
      Memcpy(buf+6,$EXT2,768)
    else
      Memcpy(buf+6,$EXT3,768)
    endif
    if SYS.Sendimm(j,774,buf)<=0 err=1 // Unable to send command
  enddo
  // Send main layout extention.
  if err==0 && nextent>=1 then
    buf[0]=S_LOADRUN
    buf[1]=15                          // Load main layout extention
    $int4(buf+2)=0                     // Dummy zero bytes
    Memcpy(buf+6,$EXTLAY,768)
    if SYS.Sendimm(0,774,buf)<=0 err=1 // Unable to send command
  endif
  i=-1
  while err==0 do
    for j=0,j<nextent,j++ do
      if $A[j].length==0 break
      if $A[j].answer!=S_LOADRUN err=3
    enddo
    if j>=nextent break                // All answers are back
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("Reloading layout - %i s",j)
      i=j
    endif
    if j>=120 then
      for j=0,j<nextent,j++ do
        SYS.Killimm(j)
      enddo
      err=2; break                     // Timeout
    endif
    wait
  enddo
  if err==0 then
    for i=0,i<16,i++                   // Same offsets in tester & inner copy
      $LAYCORR.leftzerox[i]=$LAY.leftzerox[i]
      $LAYCORR.leftzeroy[i]=$LAY.leftzeroy[i]
      $LAYCORR.rightzerox[i]=$LAY.rightzerox[i]
      $LAYCORR.rightzeroy[i]=$LAY.rightzeroy[i]
    enddo
    videocorrectx[0]=0.0               // Reloading layout invalidates offsets
    videocorrecty[0]=0.0
    videocorrectx[1]=0.0
    videocorrecty[1]=0.0
    if hlog!=NULL then
      fprintf(hlog,"Corrected layout loaded to tester\n")
    endif
    i=Checkgloberrors()                // Necessary after measurement test
    return i                           // Layout reloaded correctly
  endif
  i=Checkgloberrors()
  if i!=0 return i
  change hinfo text="Communication problem!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Unable to send command!"
  else if err==2 then
    draw text="No answer within 2 minutes!"
  else
    draw text="Command executed incorrectly!"
  endif
  draw at 6,60 wrap=RIGHTX-5 color=BLACK
  hretry=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Check status"
    help="Press to re-check the tester status"
  endc
  draw text="Calibration procedure was unable to load tester with corrected "
  draw text="layout. It is necessary to re-check the status of the tester."
  draw show
  if hlog!=NULL then
    fprintf(hlog,"ERROR: Unable to load tester with corrected layout\n")
  endif
  while 1 do
    if Pressed(hretry) return 1        // Check again the status of the tester
    if Pressed(hexit) return -1        // Quit calibration
    wait
  enddo
end

// Service function, sends main layout extention to tester. Layout itself and
// additional layout extentions remain unchanged. Returns 0 on success and -1
// on any error.
function int Sendmainextention()
  int t
  char buf[774]
  buf[0]=S_LOADRUN
  buf[1]=15                            // Reload layout extention
  $int4(buf+2)=0                       // Dummy operand
  Memcpy(buf+6,$EXTLAY,768)            // Layout extention
  SYS.Killimm(32)
  if SYS.Sendimm(32,774,buf)<=0 then
    return -1                          // Unable to send command
  endif
  t=Time()
  while Time()-t<3000 do               // 3 seconds timeout
    wait
    if $A[32].length==0 continue
    if $A[32].answer!=S_LOADRUN then
      return -1                        // Invalid answer - execution error?
    else
      return 0                         // Success
    endif
  enddo
  return -1                            // Timeout
end

// Function writes corrected layout and layout extentions to the file. Returns
// 0 on success and -1 if calibration sequence is interrupted.
function int Savelayout()
  int i,j,autosave,nextra,err
  char s[260]
  handle f,hlayoutname,hbrowse,hskip,hsave
  change hinfo limits=0,0
  change hinfo text="Saving layout to file"
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Please select file where corrected layout should be saved "
  draw text="(usually current layout) and press 'Save'. Or, doubleclick "
  draw text="'Skip' to discard changes (in this case you must discard "
  draw text="corrections, too)."
  draw show
  autosave=operator
nextattempt:
  err=0
  hlayoutname=control COMBOEDIT
    window=hright
    position=5,200,RIGHTX-10,120
    name="Layout file"
    help="File where to save tester layout"
    mode=M_VSCROLL
  endc
  hbrowse=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="Browse"
    help="Press to select different file"
  endc
  hskip=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="Skip"
    help="Doubleclick to discard layout"
    mode=M_DBLCLICK
  endc
  hsave=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="Save"
    help="Press to save layout to selected file"
  endc
  while 1 do
    if Pressed(hbrowse) then
      confirm hlayoutname
      Text(hlayoutname,s)
      if SYS.Browse(hmain,s,"Specify layout name",0)!=0 then
        change hlayoutname text=s
      endif
    else if Pressed(hskip) then
      if (hlog!=NULL) then
        fprintf(hlog,"Operator decided not to save layout to the disk\n")
      endif
      break
    else if Pressed(hsave) || autosave then
      if demo==0 then
        confirm hlayoutname
        Text(hlayoutname,s)
        f=Fopen(s,"wb")
        if f==NULL err=1
        // Save main layout.
        if err==0 && Fwrite($LAY,768,f)!=768 err=2
        // Determine number of layout extentions to save.
        nextra=0
        if err==0 then
          for i=4,i<768,i++ do         // First 4 bytes are validity marker
            if $char($EXT3+i)!=0 break
          enddo
          if i<768 nextra=5
          if nextra==0 then
            for i=4,i<768,i++ do
              if $char($EXT2+i)!=0 break
            enddo
            if i<768 nextra=4
          endif
          if nextra==0 then
            for i=4,i<768,i++ do
              if $char($EXT1+i)!=0 break
            enddo
            if i<768 nextra=3
          endif
          if nextra==0 then
            for i=4,i<768,i++ do
              if $char($EXT0+i)!=0 break
            enddo
            if i<768 nextra=2
          endif
          if nextra==0 then
            for i=0,i<768,i++
              if $char($EXTLAY+i)!=0 break
            enddo
            if i<768 nextra=1
          endif
        endif
        if err==0 && nextra>=1 then
          if Fwrite($EXTLAY,768,f)!=768 err=2
        endif
        if err==0 && nextra>=2 then
          $int4($EXT0)=0x30747845
          if Fwrite($EXT0,768,f)!=768 err=2
        endif
        if err==0 && nextra>=3 then
          $int4($EXT1)=0x31747845
          if Fwrite($EXT1,768,f)!=768 err=2
        endif
        if err==0 && nextra>=4 then
          $int4($EXT2)=0x32747845
          if Fwrite($EXT2,768,f)!=768 err=2
        endif
        if err==0 && nextra>=5 then
          $int4($EXT3)=0x33747845
          if Fwrite($EXT3,768,f)!=768 err=2
        endif
        Fclose(f)
        if hlog!=NULL then
          if err==0 then
            fprintf(hlog,"Layout saved as '%s'\n",s)
          else
            fprintf(hlog,"Unable to save layout!\n")
          endif
        endif
      endif
      break
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
  if err==0 return
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=LIGHTRED
  if err==1 then
    draw text="Unable to create file. Please try different name."
  else
    draw text="Unable to save layout. Please try different file."
  endif
  draw show
  autosave=0
  goto nextattempt
end

<<<<<<< CALIBR.SCR
=======
// Service function, creates internal copy of the correction file for the
// specified head. If flag update is set, finalizes corrections by updating
// internal structures. On success, returns length of the file in bytes. On
// error, returns 0.
function int Createheadcorrfile(int head,char *buf)
  int i,j,ii,jj,n,camera,coffs,hascext
  struct t_cext ext
  if head<0 || head>=$LAY.nfing*2+2                                            \
    return 0                           // Error in input parameters
  if c[head].ncal==0 return 0          // No corrections for the given head
  // Add legacy head corrections.
  for ii=0,ii<CORRX,ii++ do
    i=ii-CENTERX+GRIDCX
    for jj=0,jj<CORRY,jj++ do
      j=jj-CENTERY+GRIDCY
      $int2(buf+(ii*CORRY+jj)*4+0)=corr[head][i,j].dx
      $int2(buf+(ii*CORRY+jj)*4+2)=corr[head][i,j].dy
    enddo
  enddo
  n=CORRX*CORRY*4
  // Prepare extention header.
  Memcpy(ext,cext[head],256)
  // Fine corrections are deprecated; cartesian corrections are as yet not in
  // the data.
  Memset(ext+8,0,256-8)
  // Check whether we need to add cartesian corrections in the form of legacy
  // corrections extended in X direction and determine its limits. Cartesian
  // corrections cover legacy corrections.
  if $LAY.leftlimit<$LAY.xoffset-(CENTERX-1)*xstep*1000.0 ||                   \
    $LAY.rightlimit>$LAY.xoffset+(CENTERX-1)*xstep*1000.0 ||                   \
    (head>=$LAY.nfing*2 && twostep!=0 && camrvalid[head-$LAY.nfing*2]!=0)      \
  then
    ext.cartx0=($LAY.leftlimit-$LAY.xoffset)/(1000.0*xstep)-2
    if ext.cartx0>0 ext.cartx0=0
    if ext.cartx0<(-GRIDCX) ext.cartx0=-GRIDCX
    i=($LAY.xoffset+$LAY.rightlimit)/(1000.0*xstep)+2
    if i<0 i=0
    if i>GRIDCX i=GRIDCX
    ext.cartnx=i-ext.cartx0+1
    ext.carty0=-CENTERY-1
    ext.cartny=CORRY+2
    ext.cartdx=xstep*1000.0
    ext.cartdy=ystep*1000.0
    ext.mode=ext.mode | CE_VALID
  endif
  // Currently the only defined extention is the position of the calibration
  // board during the calibration (used by 3-D corrections).
  if c3dnew[head].key!=COPT_IGNORE then
    ext.mode=ext.mode | CE_VALID
  endif
  if ext.mode & CE_VALID then
    n=n+256                            // t_cext is 256 bytes long
    // If any extention is present, for backward compatibility I add legacy
    // head camera correctios (zeroed if there is no camera).
    for ii=0,ii<CORRX,ii++ do
      i=ii-CENTERX+GRIDCX
      for jj=0,jj<CORRY,jj++ do
        j=jj-CENTERY+GRIDCY
        $int2(buf+n+(ii*CORRY+jj)*4+0)=hcam[head][i,j].dx
        $int2(buf+n+(ii*CORRY+jj)*4+2)=hcam[head][i,j].dy
      enddo
    enddo
    n=n+CORRX*CORRY*4
    // Add 3-D calibration data.
    if c3dnew[head].key!=COPT_IGNORE then
      ext.optdata[0]=n
      Memcpy(buf+n,c3dnew[head],256)
      n=n+256
    endif
    // Add cartesian corrections.
    if ext.cartnx>0 then
      // main corrections.
      ext.carthead=n
      for ii=0,ii<ext.cartnx,ii++ do
        i=ii+ext.cartx0+GRIDCX
        for jj=0,jj<ext.cartny,jj++ do
          j=jj+ext.carty0+GRIDCY
          $float4(buf+n+(ii*ext.cartny+jj)*8+0)=corr[head][i,j].dx
          $float4(buf+n+(ii*ext.cartny+jj)*8+4)=corr[head][i,j].dy
        enddo
      enddo
      n=n+ext.cartnx*ext.cartny*8
      // Dedicated camera corrections for the right shuttle.
      if head>=$LAY.nfing*2 && twostep!=0 &&                                   \
        camrvalid[head-$LAY.nfing*2]!=0                                        \
      then
        camera=head-$LAY.nfing*2
        ext.carthead2=n
        for ii=0,ii<ext.cartnx,ii++ do
          i=ii+ext.cartx0+GRIDCX
          for jj=0,jj<ext.cartny,jj++ do
            j=jj+ext.carty0+GRIDCY
            $float4(buf+n+(ii*ext.cartny+jj)*8+0)=camr[camera][i,j].dx
            $float4(buf+n+(ii*ext.cartny+jj)*8+4)=camr[camera][i,j].dy
          enddo
        enddo
        n=n+ext.cartnx*ext.cartny*8
      endif
    endif
    // Add cartesian head camera corrections.
    if ext.cartnx>0 && (ext.mode & CE_HEADCAM)!=0 then
      ext.carthcam=n
      for ii=0,ii<ext.cartnx,ii++ do
        i=ii+ext.cartx0+GRIDCX
        for jj=0,jj<ext.cartny,jj++ do
          j=jj+ext.carty0+GRIDCY
          $float4(buf+n+(ii*ext.cartny+jj)*8+0)=hcam[head][i,j].dx
          $float4(buf+n+(ii*ext.cartny+jj)*8+4)=hcam[head][i,j].dy
        enddo
      enddo
      n=n+ext.cartnx*ext.cartny*8
    endif
    // Add header.
    ext.caldate=$LAY.caldate
    Memcpy(buf+CORRX*CORRY*4,ext,256)
  endif
  // Report sucecss.
  return n
end

>>>>>>> 1.202
// Send correction data from correction tables (zero=0,2) or all zeros (zero=1)
// to tester for the specified head or for all heads if head=-1. Parameter
// zero=2 means preparations for the 3-D calibration and disables current
// 3-D corrections. If movehome is not 0, moves heads into the home positions.
function int Loadcorr(int head,int zero,int movehome)
<<<<<<< CALIBR.SCR
  int h,i,j,j0,j1,j2,nhead,err,t,ident,hasheadcam
=======
  int h,i,ii,j,jj,j0,j1,j2,len,nhead,err,t,ident,ident0,ident1,hasheadcam
>>>>>>> 1.202
  char s[256],buf[1024]
  handle hreload,hcancel
reload:
  clear hright
  change hinfo limits=0,0
  if zero!=1 then
    if head<0 then
      change hinfo text="Loading corrections"
    else
      change hinfo text=format("Corrections (head %i)",head)
    endif
  else
    if head<0 then
      change hinfo text="Zeroing corrections"
    else
      change hinfo text=format("Corrections (head %i)",head)
    endif
  endif
  err=0
  // Before loading corrections, move all heads into home positions. This
  // movement is not critical, so I don't check for possible errors.
  if movehome!=0 && demo==0 then
    for i=0,i<$LAY.nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()
    while (1) do
      for i=0,i<$LAY.nfing,i++
        if c[i*2].ncal==0 continue
        if $A[i].length==0 break       // Some answers are still not here
      enddo
      if i>=$LAY.nfing break           // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()-t>10000 break          // No answer within 10 s timeout
      wait
    enddo
  endif
  // Now load corrections.
  nhead=2*$LAY.nfing
  if $LAY.cameras!=0 nhead=nhead+2
  SYS.Killimm(0)
  SYS.Killimm(1)
  for h=0,h<nhead,h++
    if h==2*$LAY.nfing && ($LAY.cameras & 1)==0 continue
    if h==2*$LAY.nfing+1 && ($LAY.cameras & 2)==0 continue
    if head>=0 && head!=h continue     // Skip head if not requested
    if $LAY.cameras==0 && h<$LAY.nfing*2 && ($LAY.headcameras & (1<<h))!=0 then
      hasheadcam=1
    else
      hasheadcam=0
    endif
<<<<<<< CALIBR.SCR
    // Load best available head corrections.
    if (cext[h].mode & CE_VALIDFINE)==CE_VALIDFINE &&                          \
      (cratefeatures & CF_FINECORR)!=0 && zero!=1 then
      // Check whether we need one or two commands to send fine column to the
      // crate. Two-command cases are highly improbable for current testers.
      j0=Max(0,cext[h].finey0+FINECY)
      j2=Min(j0+cext[h].fineny,FINEY-1)
      if j0<FINECY && (j1-j0+1)*8>1000 then
        j1=FINECY                      // Need two commands
      else
        j1=j2                          // One command is sufficient
      endif
      // Load fine correcions.
      for i=0,i<FINEX && err==0,i++ do
        if head<0 then
          change hinfo limits=h*FINEX+(i+1)/(hasheadcam+1),nhead*FINEX
        else
          change hinfo limits=(i+1)/(hasheadcam+1),FINEX
        endif
        if demo then
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if (i & 0x1F)==0 delay 10
          continue
        endif
        buf[0]=S_LOADRUN
        buf[1]=18                      // Load column of fine corrections
        $uint2(buf+2)=h                // Head
        $uint2(buf+4)=FINEDX*1000.0    // X correction step
        $uint2(buf+6)=FINEDY*1000.0    // Y correction step
        $uint4(buf+8)=0                // Reserved
        $uint2(buf+12)=i-FINECX        // Center-based column index
        $uint2(buf+14)=j0-FINECY       // Center-based index of first row
        $uint2(buf+16)=j1-FINECY       // Center-based index of last row
        for j=j0,j<=j1,j++ do
          $float4(buf+18+8*(j-j0))=fcorr[h][i,j].dx
          $float4(buf+22+8*(j-j0))=fcorr[h][i,j].dy
        enddo
        ident=SYS.Sendimm(0,18+(j1-j0+1)*8,buf)
        if ident<=0 err=1              // Unable to send command
        if j2>j1 then
          $uint2(buf+14)=j1+1-FINECY   // Second command, rest of data
          $uint2(buf+16)=j2-FINECY
          for j=j1+1,j<=j2,j++ do
            $float4(buf+18+8*(j-j1-1))=fcorr[h][i,j].dx
            $float4(buf+22+8*(j-j1-1))=fcorr[h][i,j].dy
          enddo
          ident=SYS.Sendimm(1,18+(j2-j1)*8,buf)
=======
    // The easiest way to load corrections (at least for external programs) is
    // to send the whole file and let Crate parse it. Support for this feature
    // is indicated by the bit CF_FULLCORR.
    if    1==2 &&         zero==0 && (cratefeatures & CF_FULLCORR)!=0 then       ////////////////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!============------====-----------=---------=======-
      len=Createheadcorrfile(h,corrbuf)
      if len==0 then
        err=3
      else
        SYS.Killimm(0)
        i=0
        while i<len && err==0 do
          buf[0]=S_LOADRUN
          buf[1]=21                    // Load bulk correction data
          $int2(buf+2)=h
          $int4(buf+4)=len
          $int4(buf+8)=i
          $int4(buf+12)=0
          $int4(buf+16)=0
          j=Min(998,len-i)
          Memcpy(buf+20,corrbuf+i,j)
          ident=SYS.Sendimm(0,20+j,buf)
>>>>>>> 1.202
          if ident<=0 err=1            // Unable to send command
        endif
        t=Time()
        // Note: no wait in cycle to accelerate loading!
        while err==0 do
          if $A[0].length!=0 && (j1==j2 || $A[1].length!=0) break
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if Time()-t>10000 err=2      // Timeout 10 s exhausted
        enddo
        if err==0 && $A[0].answer!=S_LOADRUN ||                                \
          (j1!=j2 && $A[1].answer!=S_LOADRUN) then
          err=4                        // Unexpected answer
        endif
      enddo
      // Finalize fine corrections.
      buf[0]=S_LOADRUN
      buf[1]=18                        // Load column of fine corrections
      $uint2(buf+2)=0xFFFF             // Finalization
      $uint2(buf+4)=FINEDX*1000.0      // X correction step
      $uint2(buf+6)=FINEDY*1000.0      // Y correction step
      $uint4(buf+8)=0                  // Reserved
      $uint2(buf+12)=0                 // Center-based column index
      $uint2(buf+14)=0                 // Center-based index of first row
      $uint2(buf+16)=0                 // Center-based index of last row
      $float4(buf+18)=0.0
      $float4(buf+22)=0.0
      SYS.Sendimm(32,26,buf)
    else
      // Load standard corrections.
      for i=0,i<CORRX && err==0,i++ do
        if head<0 then
          change hinfo limits=h*CORRX+(i+1)/(hasheadcam+1),nhead*CORRX
        else
          change hinfo limits=(i+1)/(hasheadcam+1),CORRX
        endif
        if demo then
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if (i & 7)==0 delay 10
          continue
        endif
        buf[0]=S_LOADRUN
        if (h & 1)==0 then
          buf[1]=0x07                  // Left head
          $uint2(buf+2)=h/2
          $uint2(buf+4)=i
          for j=0,j<CORRY,j++
            $uint2(buf+j*4+6)=(zero!=1?corr[h][i,j].dx:0)
            $uint2(buf+j*4+8)=(zero!=1?corr[h][i,j].dy:0)
          enddo
        else
          buf[1]=0x08                  // Right head
          $uint2(buf+2)=h/2
          $uint2(buf+4)=CORRX-i-1      // Swap columns
          for j=0,j<CORRY,j++          // Swap rows and negate corrections
            $uint2(buf+j*4+6)=(zero!=1?-corr[h][i,CORRY-j-1].dx:0)
            $uint2(buf+j*4+8)=(zero!=1?-corr[h][i,CORRY-j-1].dy:0)
          enddo
        endif
        ident=SYS.Sendimm(0,6+CORRY*4,buf)
        if ident<=0 err=1              // Unable to send command
        t=Time()
        // Note: no wait in cycle to accelerate loading!
        while err==0 do
          if $A[0].length!=0 break
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if Time()-t>10000 err=2      // Timeout 10 s exhausted
        enddo
        if err==0 && $A[0].answer!=S_LOADRUN then
          err=4                        // Unexpected answer
        endif
      enddo
    endif
    // If head camera is present, load head camera corrections.
    if hasheadcam then
      for i=0,i<CORRX && err==0,i++ do
        if head<0 then
          change hinfo limits=h*CORRX+(CORRX+i+1)/2,nhead*CORRX
        else
          change hinfo limits=(CORRX+i+1)/2,CORRX
        endif
        buf[0]=S_LOADRUN
        buf[1]=0x10                    // Head camera corrections
        $uint2(buf+2)=h
        $uint2(buf+4)=i
        if zero==1 ||                                                          \
          (cext[h].mode & (CE_VALID|CE_HEADCAM))!=(CE_VALID|CE_HEADCAM) then
          for j=0,j<CORRY,j++
            $uint2(buf+j*4+6)=0
            $uint2(buf+j*4+8)=0
          enddo
        else
          for j=0,j<CORRY,j++
            $uint2(buf+j*4+6)=hcam[h][i,j].dx
            $uint2(buf+j*4+8)=hcam[h][i,j].dy
          enddo
        endif
        ident=SYS.Sendimm(0,6+CORRY*4,buf)
        if ident<=0 err=1              // Unable to send command
        t=Time()
        // Note: no wait in cycle to accelerate loading!
        while err==0 do
          if $A[0].length!=0 break
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if Time()-t>10000 err=2      // Timeout 10 s exhausted
        enddo
        if err==0 && $A[0].answer!=S_LOADRUN then
          err=3                        // Unexpected headcam answer
        endif
      enddo
    endif
    // If head supports additional calibration data (for example, 3-D
    // corrections), load it. There is no additional data for A5-based testers.
    if (cratefeatures & CF_XCORR)!=0 &&                                        \
      testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6             \
    then
      for i=0,i<4 && err==0,i++ do
        if copt[h][i].key==COPT_IGNORE continue
        buf[0]=S_LOADRUN
        buf[1]=17                      // Load additional calibration data
        $uint2(buf+2)=h                // Head
        $uint2(buf+4)=0                // Reserved for the future
        if zero==1 || (zero==2 && copt[h][i].key==COPT_3D) then
          // If in zeroing mode, try also to zero all additional calibration
          // data.
          Memcpy(buf+6,copt[h][i],4)
          Memset(buf+10,0,252)
        else
          Memcpy(buf+6,copt[h][i],256)
        endif
        ident=SYS.Sendimm(0,262,buf)
        if ident<=0 err=1              // Unable to send command
        t=Time()
        // Note: no wait in cycle to accelerate loading!
        while err==0 do
          if $A[0].length!=0 break
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if Time()-t>10000 err=2      // Timeout 10 s exhausted
        enddo
        if err==0 && $A[0].answer!=S_LOADRUN then
          err=3                        // Unexpected answer
        endif
      enddo
      // If in zeroing mode, explicitly zero 3-D corrections.
      if zero!=0 && err==0 then
        buf[0]=S_LOADRUN
        buf[1]=17                      // Load additional calibration data
        $uint2(buf+2)=h                // Head
        $uint2(buf+4)=0                // Reserved for the future
        $int4(buf+6)=COPT_3D
        Memset(buf+10,0,252)
        // Small bug in the intermediate versions of embedded software: if
        // center Z coordinate is 0, head reports invalid data. I set center
        // to 20000 micrometers. When Z factors are zero, this setting is
        // ignored.
        $float4(buf+18)=20000.0
        ident=SYS.Sendimm(0,262,buf)
        if ident<=0 err=1              // Unable to send command
        t=Time()
        // Note: no wait in cycle to accelerate loading!
        while err==0 do
          if $A[0].length!=0 break
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if Time()-t>10000 err=2      // Timeout 10 s exhausted
        enddo
        if err==0 && $A[0].answer!=S_LOADRUN then
          err=3                        // Unexpected answer
        endif
      endif
    endif
  enddo
  // If shuttle Y corrections are supported by crate, load them too.
  if err==0 && (cratefeatures & CF_CRATEXCOR)!=0 && demo==0 &&                 \
    (zero==0 || zero==1)                                                      \
  then
    buf[0]=S_LOADRUN
    buf[1]=17                          // Load additional calibration data
    $uint2(buf+2)=0xFF                 // Crate controller
    $uint2(buf+4)=0                    // Reserved for the future
    if zero!=0 || shycor[0].ny==0 then
      $int4(buf+6)=0x00594853          // Shuttle Y corrections (left/only)
      $float4(buf+10)=10000.0          // Step
      $int4(buf+14)=1                  // Number of steps in each direction
      Memset(buf+18,0,3*12)
      ident0=SYS.Sendimm(0,18+3*12,buf)
    else
      Memcpy(buf+6,shycor[0],12+(shycor[0].ny*2+1)*12)
      ident0=SYS.Sendimm(0,6+12+(shycor[0].ny*2+1)*12,buf)
    endif
    if ident0<=0 err=1                 // Unable to send command
    if zero!=0 || shycor[1].ny==0 then
      $int4(buf+6)=0x00595253          // Shuttle Y corrections (right shuttle)
      $float4(buf+10)=10000.0          // Step
      $int4(buf+14)=1                  // Number of steps in each direction
      Memset(buf+18,0,3*12)
      ident1=SYS.Sendimm(1,18+3*12,buf)
    else
      Memcpy(buf+6,shycor[1],12+(shycor[1].ny*2+1)*12)
      ident1=SYS.Sendimm(1,6+12+(shycor[1].ny*2+1)*12,buf)
    endif
    if ident1<=0 err=1                 // Unable to send command
    t=Time()
    // Note: no wait in cycle to accelerate loading!
    while err==0 do
      if $A[0].length!=0 && $A[1].length!=0 break
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Time()-t>10000 err=2          // Timeout 10 s exhausted
    enddo
    if err==0 && ($A[0].answer!=S_LOADRUN || $A[1].answer!=S_LOADRUN) then
      err=3                            // Unexpected answer
    endif
  endif
  if err==0 && testertype==TT_S3 then
    change hinfo text="Soft reset..."
    change hinfo limits=0,0
    SYS.Softreset(0)                   // To apply changes in shuttle position
  endif
  if err==0 && hlog!=NULL then
    fprintf(hlog,"Corrections ")
    if head>=0 fprintf(hlog,"(head %i) ",head)
    if zero==1 then
      fprintf(hlog,"zeroed\n")
    else
      fprintf(hlog,"loaded\n")
    endif
  endif
  if err!=0 then
    i=Checkgloberrors()
    if i!=0 return i
    change hinfo limits=0,0
    change hinfo text="Communication problem!"
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==1 then
      draw text="Unable to send command!"
    else if err==2 then
      draw text="No answer within 10 seconds!"
    else if err==3 then
      draw text="Unable to load head camera corrections!"
    else
      draw text="Command executed incorrectly!"
    endif
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    hreload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Retry"
      help="Press to reload corrections"
    endc
    hcancel=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Skip"
      help="Do not reload corrections"
    endc
    if err==3 then
      draw text="Calibration procedure was unable to load corrections to head "
      draw text="cameras. Probably layout doesn't correspond to the tester, "
      draw text="or embedded software is too old. "
    else
      draw text="Calibration procedure was unable to load tester with "
      draw text="correction data. "
    endif
    draw text="Please select your action. " color=LIGHTRED text="ATTENTION, "
    draw color=BLACK text="if you choose to " font=MAINFONT text="Skip"
    draw font=TIMESFONT text=", the calibration may get invalid or inaccurate!"
    draw show
    while 1 do
      if Pressed(hreload) goto reload
      if Pressed(hcancel) then
        if hlog!=NULL then             // Skipped, check status of the tester
          fprintf(hlog,"Unable to load corrections to tester\n")
          fprintf(hlog,"  Operator skipped loading of corrections\n")
        endif
        return 1
      endif
      if Pressed(hexit) return -1      // Quit calibration
      wait
    enddo
  endif
end

// Function reads existing corrections from the disk. If bit RC_ZERO in mode is
// set, user is allowed to zero all corrections; the same for RC_ZEROASK, but
// user is asked if he is sure. Bit RC_KEEP allows to keep existing corrections.
// RC_ADJUST indicates that correction adjustments are possible. Returns 0 on
// success, 1 if user decided to keep corrections and -1 if calibration is
// interrupted.
function int Readoldcorr(int mode)
  int i,j,n,x,x0,x1,y,y0,y1,head,err,patch,nheads,autoload,baddate
  int btnx[3],btndx
  char s[260],drv[3],dir[260],fna[260],ext[260]
  handle f,hcorrname,hbrowse,hadjust,hkeep,hzero,hload,huse,hdontuse
  struct t_csy csy
  autoload=operator || (mode & RC_AUTOLOAD)!=0
oncemore:
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Please select prototype name for existing correction files "
  draw text="(usually current name) and press " font=MAINFONT text="Load"
  draw font=TIMESFONT text=". "
  if mode & (RC_ZERO|RC_ZEROASK) then
    if mode & RC_ZEROASK then
      draw text="If you know what you are doing, you may doubleclick "
    else
      draw text="Alternatively, you can press "
    endif
    draw font=MAINFONT text="Zero" font=TIMESFONT text=" to reset all "
    draw text="corrections to zero (case of non-calibrated tester)."
  endif
  if mode & RC_ADJUST then
    draw color=RED text="\n\nNote: if you are going to adjust corrections, "
    draw text="you MUST select " font=MAINFONT text="Load"
    draw font=TIMESFONT text="!"
  else
    draw color=DARKGRAY font=INFOFONT text="\n\nNote: Script substitutes last "
    draw text="two characters of the name by 0L, 0R, 1L ..."
  endif
  draw show
nextattempt:
  change hinfo limits=0,0
  change hinfo text="Choose corrections"
  err=0
  baddate=-1
  hcorrname=control COMBOEDIT
    window=hright
    position=5,170,RIGHTX-39,120
    name="Corrections file"
    help="Prototype for files containing correction data"
    mode=M_VSCROLL
  endc
  hbrowse=control BUTTON
    window=hright
    position=RIGHTX-29,170,24,24
    name=">"
    help="Press to select different prototype"
    font=MEDIUMFONT
  endc
  n=1
  if mode & (RC_ZERO|RC_ZEROASK) n++
  if mode & RC_KEEP n++
  if n==1 then
    btnx[0]=RIGHTX/2-60; btndx=120
  else if n==2 then
    btnx[0]=RIGHTX/2-124; btnx[1]=RIGHTX/2+5; btndx=120
  else
    btnx[0]=5; btnx[1]=3+RIGHTX/3; btnx[2]=1+2*(RIGHTX/3); btndx=RIGHTX/3-7
  endif
  i=0
  if $LAY.cameras!=0 then
    adjustcorr=(mode & RC_ADJUST)
  else if (mode & RC_ADJUST)!=0 then
    hadjust=control CHECKBOX
      window=hright
      position=15,USERY-50,RIGHTX-10,22
      name="I am going to adjust corrections"
      help="...but may change my decision afterwards"
      color=RED
    endc
    adjustcorr=0
  else
    hadjust=NULL
    adjustcorr=0
  endif
  if mode & RC_ZEROASK then
    hzero=control BUTTON
      window=hright
      position=btnx[i],USERY,btndx,24
      name="Zero"
      help="Doubleclick to load zero corrections (non-calibrated tester)"
      mode=M_DBLCLICK
    endc
    i++
  else if mode & RC_ZERO then
    hzero=control BUTTON
      window=hright
      position=btnx[i],USERY,btndx,24
      name="Zero"
      help="Press to load zero corrections (non-calibrated tester)"
    endc
    i++
  else
    hzero=NULL
  endif
  if mode & RC_KEEP then
    hkeep=control BUTTON
      window=hright
      position=btnx[i],USERY,btndx,24
      name="Keep old"
      help="Press to keep loaded corrections"
    endc
    i++
  else
    hkeep=NULL
  endif
  hload=control BUTTON
    window=hright
    position=btnx[i],USERY,btndx,24
    name="Load"
    help="Press to load existing corrections from disk"
  endc
  nheads=$LAY.nfing*2
  while 1 do
    if Pressed(hbrowse) then
      confirm hcorrname
      Text(hcorrname,s)
      if SYS.Browse(hmain,s,"Specify correction files",0)!=0 then
        change hcorrname text=s
      endif
    else if hadjust!=NULL && Pressed(hadjust) then
      adjustcorr=Status(hadjust)
      if adjustcorr then
        if hzero!=NULL disable hzero
        if hkeep!=NULL disable hkeep
      else
        if hzero!=NULL enable hzero
        if hkeep!=NULL enable hkeep
      endif
    else if hzero!=NULL && Pressed(hzero) then
      for head=0,head<nheads,head++ do
        Memset(corr[head],0,CORRX*CORRY*4)
        Memset(cext[head],0,256)
        Memset(copt[head],0,256*4)
        Memset(c3dold[head],0,256)
        Memset(hcam[head],0,CORRX*CORRY*4)
        Memset(fcorr[head],0,FINEX*FINEY*8)
        change hinfo limits=head+1,$LAY.nfing*2
      enddo
      Memset(shycor,0,Sizeof(shycor))
      corrsource=CS_ZEROED
      if hlog!=NULL fprintf(hlog,"Corrections zeroed\n")
      break
    else if hkeep!=NULL && Pressed(hkeep) then
      if hlog!=NULL fprintf(hlog,"Old corrections are kept\n")
      corrsource=CS_OLD
      return 1
    else if Pressed(hload) ||                                                  \
      (verifymode==VERIFY_ACC && (mode & RC_KEEP)==0 && autoload!=0) then
      confirm hcorrname
      Text(hcorrname,s)
      Fnsplit(s,drv,dir,fna,ext)
      patch=Strlen(fna)-2; if (patch<0) patch=0;
      i=Toupper(fna[patch+1])
      if Isdigit(fna[patch])==0 || (i!='L' && i!='R') then
        err=2; break
      endif
      if cameras!=0 nheads=nheads+2
      // Head, camera and head camera corrections.
      for head=0,head<nheads,head++ do
        if head==2*$LAY.nfing && ($LAY.cameras & 1)==0 continue
        if head==2*$LAY.nfing+1 && ($LAY.cameras & 2)==0 continue
        if demo==0 then
          fna[patch]=(head/2<10?head/2+'0':head/2-10+'A')
          fna[patch+1]=(head & 1)==0?'L':'R'
          fna[patch+2]='\0'
          Fnmerge(s,drv,dir,fna,ext)
          f=Fopen(s,"rb")
          if f==NULL then
            err=1; break
          endif
          // Read ordinary corrections. They are always here. Any other items
          // are optional.
          Memset(cext[head],0,256)
          Memset(copt[head],0,256*4)
          Memset(c3dold[head],0,256)
          Memset(hcam[head],0,CORRX*CORRY*4)
          Memset(fcorr[head],0,FINEX*FINEY*8)
          j=Fread(corr[head],CORRX*CORRY*4,f)
          if j!=CORRX*CORRY*4 then
            err=4
          else
            // Read extended corrections, if present.
            j=Fread(cext[head],256,f)
            if j!=0 && j!=256 err=3
            // Check whether calibration date coincides with layout.
            if err==0 && (cext[head].mode & CE_VALID)!=0 &&                    \
              cext[head].caldate!=$LAY.caldate then
              if baddate<0 baddate=head
            endif
            // Read head camera corrections, if any.
            if err==0 && (cext[head].mode & CE_VALIDHCAM)==CE_VALIDHCAM then
              j=Fread(hcam[head],CORRX*CORRY*4,f)
              if j!=0 && j!=CORRX*CORRY*4 then
                err=3
                Memset(hcam[head],0,CORRX*CORRY*4)
              else if j==0 then
                cext[head].mode=cext[head].mode & (~CE_HEADCAM)
              endif
            else
              cext[head].mode=cext[head].mode & (~CE_HEADCAM)
            endif
            // Read fine head corrections, if any.
            if err==0 && (cext[head].mode & CE_VALIDFINE)==CE_VALIDFINE then
              x0=cext[head].finex0+FINECX
              x1=x0+cext[head].finenx
              y0=cext[head].finey0+FINECY
              y1=y0+cext[head].fineny
              if cext[head].finehead<CORRX*CORRY*4*2+256 ||                    \
                x0<0 || x1<=x0 || x1>FINEX || y0<0 || y1<=y0 || y1>FINEY err=5
              if err==0                                                        \
                Fseek(f,cext[head].finehead,0)
              for x=x0,x<x1 && err==0,x++ do
                j=Fread(fcorr[head][x][y0],(y1-y0)*8,f)
                if j!=(y1-y0)*8 then
                  err=5; break
                endif
                for y=y0,y<y1,y++ do
                  if Abs(fcorr[head][x][y].dx)>MAXCORR*1000.0 ||               \
                    Abs(fcorr[head][x][y].dy)>MAXCORR*1000.0 then
                    err=5; break       // Unexpectedly large corrections
                  endif
                enddo
                for y=0,y<y0,y++ do
                  fcorr[head][x][y].dx=fcorr[head][x][y0].dx
                  fcorr[head][x][y].dy=fcorr[head][x][y0].dy
                enddo
                for y=y1,y<FINEY,y++ do
                  fcorr[head][x][y].dx=fcorr[head][x][y1-1].dx
                  fcorr[head][x][y].dy=fcorr[head][x][y1-1].dy
                enddo
              enddo
              for y=0,y<CORRY && err==0,y++ do
                for x=0,x<x0,x++ do
                  fcorr[head][x][y].dx=fcorr[head][x0][y].dx
                  fcorr[head][x][y].dy=fcorr[head][x0][y].dy
                enddo
                for x=x1,x<FINEX,x++ do
                  fcorr[head][x][y].dx=fcorr[head][x1-1][y].dx
                  fcorr[head][x][y].dy=fcorr[head][x1-1][y].dy
                enddo
              enddo
              if err!=0 then
                cext[head].mode=cext[head].mode & (~CE_FINE)
                Memset(fcorr[head],0,FINEX*FINEY*8)
              endif
            endif
            // Read optional corrections.
            if err==0 then
              for i=0,i<4 && err==0,i++ do
                if cext[head].optdata[i]==0 continue
                Fseek(f,cext[head].optdata[i],0)
                j=Fread(copt[head][i],256,f)
                if j==256 then
                  // Check whether this is a 3-D calibration data.
                  if copt[head][i].key==COPT_3D then
                    Memcpy(c3dold[head],copt[head][i],256)
                  endif
                else
                  err=6
                  Memset(copt[head][i],0,256)
                  cext[head].optdata[i]=0
                endif
              enddo
            endif
          endif
          Fclose(f)
        endif
        change hinfo limits=head+1,$LAY.nfing*2
        delay 20                       // Otherwise nobody notices
      enddo
      // Y shuttle corrections, optional.
      if demo==0 then
        Memset(shycor,0,Sizeof(shycor))
        fna[patch]='S'
        fna[patch+1]='Y'
        fna[patch+2]='\0'
        Fnmerge(s,drv,dir,fna,ext)
        f=Fopen(s,"rb")
        if f!=NULL then
          j=Fread(csy,Sizeof(csy),f)
          if j!=Sizeof(csy) then
            err=7
          else
            Fseek(f,csy.shycor0,0)
            j=Fread(shycor[0],Sizeof(shycor)/2,f)
            if j<12 || shycor[0].key!=0x00594853 ||                            \
              shycor[0].ny<1 || shycor[0].ny>40 || j<12+12*(shycor[0].ny*2+1)  \
            then
              Memset(shycor[0],0,Sizeof(shycor)/2)
              err=7
            endif
            if err==0 && csy.shycor1!=0 then
              Fseek(f,csy.shycor1,0)
              j=Fread(shycor[1],Sizeof(shycor)/2,f)
              if j<12 || shycor[1].key!=0x00595253 ||                          \
                shycor[1].ny<1 || shycor[1].ny>40 || j<12+12*(shycor[1].ny*2+1)\
              then
                Memset(shycor[1],0,Sizeof(shycor)/2)
                err=7
              endif
            endif
          endif
        endif
      endif
      if err==0 then
        corrsource=CS_FILE
      else
        adjustcorr=0
      endif
      if hlog!=NULL then
        if err==0 then
          fprintf(hlog,"Corrections loaded from '%s' etc.\n",s)
        else
          fprintf(hlog,                                                        \
          "Error %i when loading corrections from '%s' etc.\n",err,s)
        endif
      endif
      break
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
  if err==0 && baddate>=0 then
    change hinfo limits=0,0
    change hinfo text=""
    clear hright
    draw window=hright font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5 color=LIGHTRED
    draw text="Different calibration date in layout and correction files!\n\n"
    draw color=BLACK text="According to layout, tester was last calibrated on "
    if $LAY.caldate==0 then
      Strcpy(s,"unknown date")
    else
      Strtime(s,"%d-%b-%Y",2,$LAY.caldate)
    endif
    draw font=MAINFONT text=format("%s",s) font=TIMESFONT
    draw text=format(", while head %i%c - on ",baddate/2,(baddate & 1?'R':'L'))
    if cext[baddate].caldate==0 then
      Strcpy(s,"unknown date")
    else
      Strtime(s,"%d-%b-%Y",2,cext[baddate].caldate)
    endif
    draw font=MAINFONT text=format("%s",s) font=TIMESFONT
    draw text=". If layout and corrections don't match, tester may lose "
    draw text="accuracy. Do you still want to use these corrections?"
    draw show
    hdontuse=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Select different"
      help="Press to select different correction files"
    endc
    huse=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Use"
      help="Press to use loaded corrections"
    endc
    while 1 do
      if Pressed(huse) then
        return 0
      else if Pressed(hdontuse) then
        autoload=0
        goto oncemore
      else if Pressed(hexit) then
        return -1
      endif
      wait
    enddo
  endif
  if err==0 return 0
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=LIGHTRED
  if err==1 then
    draw text="Unable to open file(s). Please try different name."
  else if err==2 then
    draw text="Wrong prototype. Please ensure that name part of the file path "
    draw text="ends with '0L'."
  else if err==3 then
    draw text="Extended data in correction file is corrupted. "
    if $LAY.headcameras!=0 then
      draw text="Head camera corrections are bad or unavailable. "
    endif
    draw text="Please try different file."
  else if err==4 then
    draw text="Unable to read corrections from disk. Please try different file."
  else if err==5 then
    draw text="Invalid, unsupported or corrupted fine corrections. "
    draw text="Please try different file."
  else if err==6 then
    draw text="Invalid or corrupted optional corrections. Please try "
    draw text="different files."
  else if err==7 then
    draw text="Invalid or corrupted Y shuttle corrections. Please try "
    draw text="different files."
  else
    draw text="Internal error. Please try different file."
  endif
  draw show
  autoload=0
  goto nextattempt
end

// Reads existing corrections from the disk and extracts needle-to-camera
// offsets for head cameras. Reports no errors.
function int Readoldcamoffsets()
  int i,l,head,nheads,patch
  char s[260],drv[3],dir[260],fna[260],ext[260]
  handle f
  struct t_corr camcorr[CORRX,CORRY]
  if headcams==0 return 0              // Works only with head cameras
  nheads=$LAY.nfing*2
  // Reset offsets.
  Memset(headcamolddx,0,Sizeof(headcamolddx))
  Memset(headcamolddy,0,Sizeof(headcamolddy))
  // In 3-D calibration or verification old offset must be zeroed (corrections
  // are loaded).
  if calmode!=MODE_CAL return
  // Get default prototype name of correction files.
  getini("ComboEditAutoSave","Corrections fil[0]","%s",s)
  Fnsplit(s,drv,dir,fna,ext)
  patch=Strlen(fna)-2; if (patch<0) patch=0;
  i=Toupper(fna[patch+1])
  if Isdigit(fna[patch])==0 || (i!='L' && i!='R') then
    return -1                          // Invalid prototype
  endif
  // Go through all correction files.
  for head=0,head<nheads,head++ do
    fna[patch]=(head/2<10?head/2+'0':head/2-10+'A')
    fna[patch+1]=(head & 1)==0?'L':'R'
    fna[patch+2]='\0'
    Fnmerge(s,drv,dir,fna,ext)
    f=Fopen(s,"rb")
    if f==NULL continue                // No such file
    // File open, read headcam correction table.
    Fseek(f,CORRX*CORRY*4+256,0)
    l=Fread(camcorr,CORRX*CORRY*4,f)
    Fclose(f)
    if l!=CORRX*CORRY*4 continue       // Error or no headcam corrections
    headcamolddx[head]=camcorr[CORRX/2,CORRY/2].dx/1000.0
    headcamolddy[head]=camcorr[CORRX/2,CORRY/2].dy/1000.0
  enddo
end

// Function writes new correction files to the disk. Returns 0 on success and
// -1 if calibration sequence is interrupted.
function int Savecorr()
<<<<<<< CALIBR.SCR
  int i,j,head,err,patch,nheads,autosave,extended,fine,skipped,offset
=======
  int i,j,n,head,patch,nheads,autosave,extended,skipped,err
>>>>>>> 1.202
  char s[260],drv[3],dir[260],fna[260],ext[260]
  handle f,hcorrname,hbrowse,hskip,hsave
  struct t_csy csy
  change hinfo limits=0,0
  change hinfo text="Saving corrections"
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Please select prototype for files where correction data should "
  draw text="be saved (usually current name) and press 'Save'. Or, doubleclick "
  draw text="'Skip' to discard changes.\n"
  draw color=DARKGRAY font=INFOFONT text="Note: Script substitutes last two "
  draw text="characters of the name by 0L, 0R, 1L ..."
  draw show
  autosave=operator
nextattempt:
  err=0
  hcorrname=control COMBOEDIT
    window=hright
    position=5,200,RIGHTX-10,120
    name="Corrections file"
    help="Prototype for files containing correction data"
    mode=M_VSCROLL
  endc
  hbrowse=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="Browse"
    help="Press to select different prototype"
  endc
  hskip=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="Skip"
    help="Doubleclick to discard corrections"
    mode=M_DBLCLICK
  endc
  hsave=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="Save"
    help="Press to save corrections to the disk"
  endc
  extended=0
  fine=0
  skipped=0
  while 1 do
    if Pressed(hbrowse) then
      confirm hcorrname
      Text(hcorrname,s)
      if SYS.Browse(hmain,s,"Specify correction files",0)!=0 then
        change hcorrname text=s
      endif
    else if Pressed(hskip) then
      skipped=1
      break
    else if Pressed(hsave) || autosave then
      confirm hcorrname
      Text(hcorrname,s)
      Fnsplit(s,drv,dir,fna,ext)
      patch=Strlen(fna)-2; if (patch<0) patch=0;
      i=Toupper(fna[patch+1])
      if Isdigit(fna[patch])==0 || (i!='L' && i!='R') then
        err=2; break
      endif
      nheads=$LAY.nfing*2
      if cameras!=0 nheads=nheads+2
      // Save ordinary corrections.
      for head=0,head<nheads,head++ do
        if demo==0 then
          if c[head].ncal==0 continue
          fna[patch]=(head/2<10?head/2+'0':head/2-10+'A')
          fna[patch+1]=(head & 1)==0?'L':'R'
          fna[patch+2]='\0'
          Fnmerge(s,drv,dir,fna,ext)
          f=Fopen(s,"wb")
          if f==NULL then
            err=1; break
          endif
          // Save head corrections in old format.
          j=Fwrite(corr[head],CORRX*CORRY*4,f)
          if j!=CORRX*CORRY*4 err=3
          // I discard old optional corrections and replace them with the
          // new. Calibration script is the sole entity responsible for the
          // generation of correction data. If old script keeps data produced
          // by the new script, it may lead to problems.
          Memset(copt[head],0,Sizeof(copt[head]))
          // Currently the only defined extention is the position of the
          // calibration board during the calibration (used by 3-D
          // corrections).
          if err==0 && c3dnew[head].key!=COPT_IGNORE then
            cext[head].mode=cext[head].mode | CE_VALID
            cext[head].caldate=$LAY.caldate
            Memcpy(copt[head][0],c3dnew[head],256)
          endif
          // Save correction extensions. To do this, we must fill offsets of
          // optional data blocks.
          if err==0 && (cext[head].mode & CE_VALID)!=0 then
            // Prepare and save extension block. For backward compatibility,
            // if extensions are present, I also reserve space for the standard
            // head camera corrections.
            offset=CORRX*CORRY*4+256+CORRX*CORRY*4
            if (cext[head].mode & CE_FINE)!=0 then
              // Fine head corrections are present.
              cext[head].finehead=offset
              offset=offset+cext[head].finenx*cext[head].fineny*8
            endif
            for i=0,i<4,i++ do
              if copt[head][i].key!=COPT_IGNORE then
                cext[head].optdata[i]=offset
                offset=offset+256
              endif
            enddo
            j=Fwrite(cext[head],256,f)
            if j!=256 err=3
            // ATTENTION, all following operations must be in sync with the
            // cext[]! First, save head camera corrections or their placeholder.
            if err==0 then
              j=Fwrite(hcam[head],CORRX*CORRY*4,f)
              if j!=CORRX*CORRY*4 err=3
            endif
            // Save fine corrections.
            if err==0 && (cext[head].mode & CE_FINE)!=0 then
              for i=0,i<cext[head].finenx && err==0,i++ do
                j=Fwrite(fcorr[head][cext[head].finex0+FINECX+i,               \
                  cext[head].finey0+FINECY],cext[head].fineny*8,f)
                if j!=cext[head].fineny*8 err=3
              enddo
              fine=1
            endif
            // Save optional corrections.
            for i=0,i<4,i++ do
              if copt[head][i].key!=COPT_IGNORE then
                j=Fwrite(copt[head][i],256,f)
                if j!=256 err=3
              endif
            enddo
            extended=1
          endif
          Fclose(f)
        endif
        change hinfo limits=head+1,$LAY.nfing*2
        delay 20                       // Otherwise nobody notices
      enddo
      // Save shuttle Y corrections or, if absent, we must delete old file.
      // Unfortunately, there is no such function in Ollytest yet, so I simply
      // write dummy header.
      if err==0 && demo==0 && testertype==TT_S3 then
        fna[patch]='S'
        fna[patch+1]='Y'
        fna[patch+2]='\0'
        Fnmerge(s,drv,dir,fna,ext)
        f=Fopen(s,"wb")
        if f==NULL then
          err=1
        else
          Memset(csy,0,Sizeof(csy))
          csy.mode=CSY_VALID
          csy.caldate=$LAY.caldate
          n=256
          if shycor[0].ny!=0 then
            csy.shycor0=n
            n=n+12+(shycor[0].ny*2+1)*12
          endif
          if shycor[1].ny!=0 then
            csy.shycor1=n
            n=n+12+(shycor[1].ny*2+1)*12
          endif
          j=Fwrite(csy,Sizeof(csy),f)
          if j!=Sizeof(csy) err=3
          if shycor[0].ny>0 then
            j=Fwrite(shycor[0],12+(shycor[0].ny*2+1)*12,f)
            if j!=12+(shycor[0].ny*2+1)*12 err=3
          endif
          if shycor[1].ny>0 then
            j=Fwrite(shycor[1],12+(shycor[1].ny*2+1)*12,f)
            if j!=12+(shycor[1].ny*2+1)*12 err=3
          endif
        endif
        Fclose(f)
      endif
      break
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
  if err==0 then
    if hlog!=NULL then
      if skipped then
        fprintf(hlog,"Operator decided not to save corrections to the disk\n")
      else if fine!=0 then
        fprintf(hlog,"Fine corrections saved as '%s' etc.\n",s)
      else if extended!=0 then
        fprintf(hlog,"Extended corrections saved as '%s' etc.\n",s)
      else
        fprintf(hlog,"Corrections saved as '%s' etc.\n",s)
      endif
    endif
    return
  endif
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=LIGHTRED
  if err==1 then
    draw text="Unable to create file(s). Please try different name."
  else if err==2 then
    draw text="Wrong prototype. Please ensure that name part of the file path "
    draw text="ends with '0L'."
  else
    draw text="Unable to save corrections. Please try different name."
  endif
  draw show
  autosave=0
  goto nextattempt
end

// Checks layout and sets global variables testertype, testersides, topmask,
// topmin, topmax, bottommask, botmin and botmax. If tester is not recognized
// or not supported, function displays corresponding message.
function int Recognizetester()
  int i,w,h,zheadtype
  handle hok
  clear hright
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,60 wrap=RIGHTX-5
  w=($LAY.rightlimit-$LAY.leftlimit)/1000
  h=($LAY.top[0]-$LAY.bottom[0])/1000
  testersides=0
  topmask=0
  bottommask=0
  topmin=1000; topmax=-1000
  botmin=1000; botmax=-1000
  for i=0,i<$LAY.nfing,i++
    if $LAY.side[i]==0 then
      testersides=testersides|1
      topmask=topmask | (0x3<<(i*2))
      topmin=Min(topmin,i)
      topmax=Max(topmax,i)
    else
      testersides=testersides|2
      bottommask=bottommask | (0x3<<(i*2))
      botmin=Min(botmin,i)
      botmax=Max(botmax,i)
    endif
  enddo
  if topmin>topmax then
    topmin=0; topmax=-1
  endif
  if botmin>botmax then
    botmin=0; botmax=-1
  endif
  siderail=Max(topmax-topmin+1,botmax-botmin+1)
  for laytopmin=topmin,laytopmin<=topmax,laytopmin++ do
    if ($LAY.excludedrails & (1<<laytopmin))==0 break
  enddo
  for laytopmax=topmax,laytopmax>=laytopmin,laytopmax-- do
    if ($LAY.excludedrails & (1<<laytopmax))==0 break
  enddo
  for laybotmin=botmin,laybotmin<=botmax,laybotmin++ do
    if ($LAY.excludedrails & (1<<laybotmin))==0 break
  enddo
  for laybotmax=botmax,laybotmax>=laybotmin,laybotmax-- do
    if ($LAY.excludedrails & (1<<laybotmax))==0 break
  enddo
  // Sometimes it's possible to calibrate tester using calibration board of
  // different type (A5 glass on A7). In all such cases the number of rails is
  // limited to 2.
  if testersides==0x01 && laytopmax-laytopmin<=1 then
    smallfirst=laytopmin
    smalllast=laytopmax
  else if testersides==0x02 && laybotmax-laybotmin<=1 then
    smallfirst=laybotmin
    smalllast=laybotmax
  else if testersides==0x03 &&                                                 \
    laytopmax-laytopmin<=1 && laybotmax-laybotmin<=1 &&                        \
    $LAY.yoffset[laytopmin]==$LAY.yoffset[laybotmin] &&                        \
    $LAY.yoffset[laytopmax]==$LAY.yoffset[laybotmax] then
    smallfirst=laytopmin
    smalllast=laybotmax
  else
    smallfirst=-1
    smalllast=-1
  endif
  // Center of fitting is used in verification and 3-D calibration.
  centerx=$LAY.xoffset/1000.0
  if ($LAY.cameras & 0x1) then
    centery=$LAY.yoffset[$LAY.nfing]/1000.0
  else if ($LAY.cameras & 0x2) then
    centery=$LAY.yoffset[$LAY.nfing+1]/1000.0
  else if topmax>=0 then
    centery=($LAY.yoffset[topmin]+$LAY.yoffset[topmax])/2000.0
  else if botmax>=0 then
    centery=($LAY.yoffset[botmin]+$LAY.yoffset[botmax])/2000.0
  else
    centery=0.0
  endif
  if $LAY.nfing<=0 || $LAY.nfing>=16 then
    testertype=TT_WRONG                // Wrong layout
    draw text=format("Number of rails specified in the layout (%i) ",$LAY.nfing)
    draw text="is wrong. "
  else if testersides==0x3 && topmax>botmin then
    testertype=TT_WRONG                // Wrong layout
    draw text=format("Rails are not ordered by side (first top, then bottom). ")
  else if w<=0 || h<=0 then
    testertype=TT_WRONG                // Wrong layout
    draw text="The size of the tester's workarea is wrong. "
  else if ($LAY.config & LC_ISM2)!=0 then
    if h==45 then
      testertype=TT_M2;                // M2 - not supported
      draw text="M2 tester is not supported by this calibration procedure. "
    else
      testertype=TT_WRONG;             // Contradiction in layout
      draw text="The tester is declared as M2 in the layout, but the height "
      draw text=format("of the rail is %i millimeters instead of 45. ",h)
    endif
  else if h==155 && testersides==1 && w==600 &&                                \
    ($LAY.config & LC_AMASK)==LC_EXTANT && $LAY.cameras==0 then
    testertype=TT_A1;                  // A1/A1+ tester
  else if h==155 && ($LAY.config & LC_AMASK)==LC_FINGANT then
    if w==600 && $LAY.software==0x84 then
      testertype=TT_A2;                // A1 or A2 with linear motors
    else if w==600 && $LAY.software==0x86 then
      testertype=TT_A2;                // A1 or A2 with belts
    else if w==600 && $LAY.software==0x8A then
      testertype=TT_A2H;               // A2 (MCM modification)
    else if w==600 && $LAY.software==0x8E then
      testertype=TT_A4;                // A4
    else if w>=310 && w<=600 && testersides==0x01 &&                           \
      ($LAY.software==0xA7 || ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S1;                // S1 tester
    else if w>=310 && w<=600 && testersides==0x03 &&                           \
      ($LAY.software==0xA7 || $LAY.software==0xA8 ||                           \
      ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S2;                // S2 tester
    else if $LAY.software==0xA9 || $LAY.software==0xAA ||                      \
      ($LAY.config & LC_TYPEMASK)==LC_S3 then
      testertype=TT_S3;                // S3 tester
    else if $LAY.software==0xB8 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A8;                // A8 tester
    else if w==600 && ($LAY.software==0xA5 || $LAY.software==0xA6) then
      testertype=TT_A6;                // A6 tester
    else if w==800 && $LAY.software==0x84 then
      testertype=TT_A2L;               // A1L or A2L with linear motors
    else if w==800 && $LAY.software==0x86 then
      testertype=TT_A2L;               // A1L or A2L with belts
    else if demo then
      testertype=TT_A6;                // Assume A6 tester
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text="Unable to recognize the type of the tester. "
    endif
  else if h==215 && $LAY.software==0xA5 then
    testertype=TT_A5;                  // A5 special model
  else if h==200 then
    if w==520 && $LAY.software==0xA5 then
      testertype=TT_A5;                // A5 or new A1
    else if w==450 then
      testertype=TT_A3;                // A3
    else if w==520 && $LAY.software==0x8C then
      testertype=TT_A3L;               // A3L
    else if demo then
      testertype=TT_A5;                // Assume A5
    else
      testertype=TT_WRONG;             // Unknown tester
      if w!=450 && w!=520 then
        draw text=format("The width of the test area is %i millimeters ",w)
        draw text="instead of expected 450 or 520 for A1/A3/A5 testers. "
      else
        draw text="Unable to recognize the type of the tester. "
      endif
    endif
  else if h==225 || h==230 || h==240 then
    if w==610 && $LAY.software==0xA5 then
      testertype=TT_A5L;               // A5L
    else if w>=610 && w<=625 && $LAY.software==0xA5 &&                         \
      ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      testertype=TT_A5L;               // A5A (L&M automate)
    else if demo then
      testertype=TT_A5L;               // Assume A5L
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text="Unable to recognize the type of the tester. "
    endif
  else if h>=250 && h<=260 then
    if $LAY.software==0xB7 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A7;                // A7
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text="Unable to recognize the type of the tester. "
    endif
  else
    testertype=TT_WRONG;               // Tester not recognized
    draw text="Unable to recognize the type of the tester. "
    if h!=155 && h!=200 && h!=225 && h!=230 && h!=240 then
      draw color=BLACK text="Strange height of the rail "
      draw text=format("(%i millimeters instead of expected 155, ",h)
      draw text="200, 230, 240 or 255) is encountered. "
    endif
  endif
  if testertype==TT_WRONG || testertype==TT_UNDEF || testertype==TT_M2 then
    draw color=BLACK
    draw text="Therefore I don't know how to calibrate this tester. Please "
    if testertype!=TT_M2 then
      draw text="check the settings in the layout and correct them, or "
    endif
    draw text="use different calibration procedure which supports the "
    draw text="given machine."
    draw at 6,30 color=LIGHTRED text="Unrecoverable error detected!"
    draw show
    clear hleft
    change hleft help="Unable to calibrate this kind of tester"
    draw window=hleft color=DARKGRAY font=LARGEFONT mode=M_CENTERED
    if testertype==TT_M2 then
      draw at 58,30 bitmap=0,0,0,"m2"
      draw at LEFTX/2,300 text=format("M2/%i",$LAY.nfing*2)
    else
      draw at 95,30 bitmap=0,0,0,"unknown"
      draw at LEFTX/2,300 text="Unrecognized FPT"
    endif
    draw show
    change hinfo limits=0,0
    change hinfo text="Unable to calibrate"
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Oops..."
      help="Press to terminate the calibration"
    endc
    while Pressed(hok)==0 && Pressed(hexit)==0 do
      wait
    enddo
    testertype=TT_WRONG
  endif
  // Check if tester is equipped with splinogramms.
  zheadtype=$EXTLAY.zheadtype
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) && (((zheadtype & HCZ_VALID)!=0 && \
    ((zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL ||                                \
    (zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL ||                                \
    (zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP)) ||                               \
    ((zheadtype & HCZ_VALID)==0 && ($LAY.config & LC_ZSENSORS)!=0)) then
    softtouch=1
  else
    softtouch=0
  endif
end

function int Drawtesterview()
  char s[80]
  clear hleft
  draw window=hleft color=DARKGRAY font=LARGEFONT mode=M_CENTERED
  if testertype==TT_A1 then
    draw at 70,40 bitmap=0,0,0,"logo"
    sprintf(s,"A1/%i",$LAY.nfing*2)
  else if testertype==TT_A2 then
    draw at 32,15 bitmap=0,0,0,"a2"
    sprintf(s,"%s/%i",(testersides==3?"A2":"A1"),$LAY.nfing*2)
  else if testertype==TT_A2L then
    draw at 32,15 bitmap=0,0,0,"a2"
    sprintf(s,"%s/%i LARGE",(testersides==3?"A2":"A1"),$LAY.nfing*2)
  else if testertype==TT_A2H then
    draw at 32,15 bitmap=0,0,0,"a2"
    sprintf(s,"%s/%iH",(testersides==3?"A2":"A1"),$LAY.nfing*2)
  else if testertype==TT_A3 then
    draw at 51,30 bitmap=0,0,0,"a3"
    sprintf(s,"A3/%i",$LAY.nfing*2)
  else if testertype==TT_A3L then
    draw at 51,30 bitmap=0,0,0,"a3"
    sprintf(s,"A3/%i LARGE",$LAY.nfing*2)
  else if testertype==TT_A4 then
    draw at 51,30 bitmap=0,0,0,"a4"
    sprintf(s,"A4/%i",$LAY.nfing*2)
  else if testertype==TT_A5 then
    draw at 61,30 bitmap=0,0,0,"a5"
    if ($LAY.config & LC_TYPEMASK)==LC_NEWA1 then
      sprintf(s,"A1/%i",$LAY.nfing*2)  // New A1 (slower A5)
    else
      sprintf(s,"A5/%i",$LAY.nfing*2)  // Original A5 tester
    endif
  else if testertype==TT_A5L then
    draw at 61,30 bitmap=0,0,0,"a5"
    if ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      sprintf(s,"A5/%iA",$LAY.nfing*2) // A5 auto (L&M)
    else if $LAY.top[0]-$LAY.bottom[0]>=240000 then
      sprintf(s,"A5/%iYL",$LAY.nfing*2)
    else
      sprintf(s,"A5/%iL",$LAY.nfing*2)
    endif
  else if testertype==TT_A6 then
    draw at 51,30 bitmap=0,0,0,"a6"
    if ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
      sprintf(s,"A6/%i EPCOS",$LAY.nfing*2)
    else
      sprintf(s,"A6/%i",$LAY.nfing*2)
    endif
  else if testertype==TT_S1 then
    draw at 51,30 bitmap=0,0,0,"a6"   //////////////////////////////////////////
    sprintf(s,"S1/%i",$LAY.nfing*2)
  else if testertype==TT_S2 then
    draw at 51,30 bitmap=0,0,0,"a6"   //////////////////////////////////////////
    sprintf(s,"S2/%i",$LAY.nfing*2)
  else if testertype==TT_S3 then
    draw at 51,30 bitmap=0,0,0,"s3"
    sprintf(s,"S3/%i",$LAY.nfing*2)
  else if testertype==TT_A7 then
    draw at 51,30 bitmap=0,0,0,"a5"   //////////////////////////////////////////
    if ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      sprintf(s,"A7/%iA",$LAY.nfing*2)
    else if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      sprintf(s,"A7/%ieA",$LAY.nfing*2)
    else
      sprintf(s,"A7/%i",$LAY.nfing*2)
    endif
  else if testertype==TT_A8 then
    draw at 51,30 bitmap=0,0,0,"a6"   //////////////////////////////////////////
    sprintf(s,"A8/%i",$LAY.nfing*2)
  else
    draw at 95,30 bitmap=0,0,0,"unknown"
    sprintf(s,"Unknown tester")
  endif
  change hleft help=format("Calibrating %s",s)
  draw at LEFTX/2,300 text=s
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8)                                    \
  then
    draw font=MEDIUMFONT at LEFTX/2,324
    if $LAY.cameras==0 && $LAY.headcameras!=0 && softtouch then
      draw text="(Soft touch, head cameras)"
    else if $LAY.cameras==0 && $LAY.headcameras!=0 then
      draw text="(Head cameras)"
    else if softtouch then
      draw text="(Soft touch)"
    endif
  endif
  draw show
end

// Gets type of attached automation (half-automate, automate etc.) into the
// global variables automationtype and isauto. As these parameters are not
// important for the calibration, there is no error processing.
function int Getautomationtype()
  int t
  char buf[32]
  SYS.Killimm(32)
  buf[0]=S_DEBUG
  buf[1]=0x14                          // Query type of the automation
  SYS.Sendimm(32,2,buf)
  t=Time()
  automationtype=AUTO_UNKNOWN
  isauto=0
  while $A[32].length==0 do
    if Time()-t>2000 then
      SYS.Killimm(32)                  // Timeout, automation type is unknown
      return
    endif
    wait
  enddo
  if $A[32].answer!=S_DEBUG || $A[32].length!=9 return
  automationtype=$uint2($A[32]+5)
  if automationtype==AUTO_A2 || automationtype==AUTO_A4SEMI ||                 \
    automationtype==AUTO_A4FULL || automationtype==AUTO_A6SEMI ||              \
    automationtype==AUTO_A6FULL || automationtype==AUTO_A5LMSEMI ||            \
    automationtype==AUTO_A5LMFULL || automationtype==AUTO_S2LMMAN ||           \
    automationtype==AUTO_S2LMSEMI || automationtype==AUTO_S2LMFULL ||          \
    automationtype==AUTO_A7LMSEMI || automationtype==AUTO_A7LMFULL ||          \
    automationtype==AUTO_A8LMSEMI || automationtype==AUTO_A8LMFULL ||          \
    automationtype==AUTO_SPLIT                                                 \
  then
    isauto=1
  else
    isauto=0
  endif
end

// Determines size of the calibration board.
function int Setboardsize()
  if testersides==0x03 then
    calymin=Min($LAY.bottom[firsttop],$LAY.bottom[firstbot])/1000.0
    calymax=Max($LAY.top[lasttop],$LAY.top[lastbot])/1000.0
  else if testersides==0x01 then
    calymin=$LAY.bottom[firsttop]/1000.0
    calymax=$LAY.top[lasttop]/1000.0
  else
    calymin=$LAY.bottom[firstbot]/1000.0
    calymax=$LAY.top[lastbot]/1000.0
  endif
  calystep=ystep
  if testertype==TT_A5L && smallboard!=0 then
    calymin=Max(calymin,$LAY.bottom[smallfirst]/1000.0+25.0)
    calymax=Min(calymax,$LAY.top[smalllast]/1000.0-25.0)
  else if testertype==TT_A7 && smallboard!=0 && boardtype!=1 then
    calymin=Max(calymin,$LAY.bottom[smallfirst]/1000.0+25.0)
    calymax=Min(calymax,$LAY.top[smalllast]/1000.0-25.0)
    calystep=12.5
  else if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
    calymin=Max(calymin,$LAY.bottom[smallfirst]/1000.0+55.0)
    calymax=Min(calymax,$LAY.top[smalllast]/1000.0-55.0)
    calystep=12.5
  endif
  calxmin=Max(fromx-5.0,$LAY.leftlimit/1000.0)
  calxmax=Min(tox+5.0,$LAY.rightlimit/1000.0)
end

// Asks operator to enter fiducial type (SYNT_LEFT or SYNT_RIGHT) on the glass
// board.
function int Setfidtype()
  int i,x,y,btn,oldbtn
  handle hok,hchild
  getini("Calibration","Fiducial type","%i",&headcamfidtype)
  if headcamfidtype<0 || headcamfidtype>=3 headcamfidtype=0
  change hinfo limits=0,0
  change hinfo text="Select fiducial type"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Select type of fiducials on the top side of the glass board, as "
  draw text="shown on the left. Press " font=MAINFONT text="OK" font=TIMESFONT
  draw text="when ready."
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="OK"
    help="Press to confirm selection"
  endc
  clear hleft
  hchild=control GRAPH
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    limits=LEFTX-2,LEFTY-2
    color=WHITE
    bkcolor=WHITE
  endc
  oldbtn=0
redraw:
  draw window=hchild bkcolor=WHITE clear
  draw font=MEDIUMFONT mode=M_CENTERED color=BLACK
  draw at LEFTX/2,35 text="Fiducials on the top side:"
  x=LEFTX/2
  y=95
  for i=0,i<3,i++ do
    if i==headcamfidtype then
      draw color=LIGHTRED bkcolor=LIGHTRED
      draw at x-45,y-45 fillrect x+46,y+46
    endif
    draw color=BLACK bkcolor=WHITE
    draw at x-35,y-35 fillrect x+36,y+36
    if i==headcamfidtype then
      draw color=BLACK bkcolor=BLACK
    else
      draw color=DARKGRAY bkcolor=DARKGRAY
    endif
    draw at x-33,y-3 fillrect x+34,y+4
    draw at x-3,y-33 fillrect x+4,y+34
    if i==0 then
      draw at x,y fillellipse 59,59
      draw color=WHITE bkcolor=WHITE
      draw at x,y fillellipse 45,45
      if i==headcamfidtype then
        draw color=BLACK bkcolor=BLACK
      else
        draw color=DARKGRAY bkcolor=DARKGRAY
      endif
      draw at x-13,y-13 fillrect x-3,y-3
      draw at x+4,y+4 fillrect x+14,y+14
    else if i==1 then
      draw at x-16,y-16 fillrect x-6,y-6
      draw at x+7,y+7 fillrect x+17,y+17
    else
      draw at x+7,y-16 fillrect x+17,y-6
      draw at x-16,y+7 fillrect x-6,y+17
    endif
    y=y+90
  enddo
  draw show
  while 1 do
    if Mousexy(hchild,&x,&y,&btn)==1 then
      if (btn & 1)!=0 && (oldbtn & 1)==0 && x>=LEFTX/2-35 && x<=LEFTX/2+36 then
        for i=0,i<3,i++ do
          if y>=95+i*90-35 && y<=95+i*90+36 break
        enddo
        if i<3 && i!=headcamfidtype then
          headcamfidtype=i
          goto redraw
        endif
      endif
      oldbtn=btn
    endif
    if Pressed(hok) then
      setini("Calibration","Fiducial type","%i",headcamfidtype)
      Drawtesterview()
      return 0
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Reports size of calibration board to tester.
function int Setdefboard()
  int i,t,ident,err
  char s[128]
  handle hretry
  clear hright
  change hinfo limits=0,0
  change hinfo text="Setting tester parameters"
  if demo then
    delay 500
    return 0
  endif
  sprintf(s," %f,%f,%f,%f",calxmin,calymin,calxmax,calymax)
  ident=SERV.Cmdimm(0,s)
  if ident<=0 err=1                    // Unable to send command
  t=Time()
  while err==0 && $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as interrupt
    if Time()-t>2000 err=2             // Timeout exhausted
    wait
  enddo
  // When running under Test Player, DEFBOARD may return success (S_NOP).
  if (err==0 && $A[0].answer!=S_DEFBOARD && $A[0].answer!=S_NOP) then
    err=3                              // Unexpected answer
  endif
  // If tester is equipped with L&M automatical shuttle, exclude borders.
  if err==0 && ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&              \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHSPL &&                        \
    (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) &&                                 \
    (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                   \
    ($LAY.config & LC_LDMASK)==LC_LMS2AUTO)                                    \
  then
    if testertype==TT_A7 || testertype==TT_A8 then
      sprintf(s,"DEFREGION %f,%f,%f,%f,H=0",calxmin,calymin,calxmax,calymax)
    else if testertype==TT_A5 then
      sprintf(s,"DEFREGION %f,%f,%f,%f,H=12",calxmin,calymin,calxmax,calymax)
    else
      sprintf(s,"DEFREGION %f,%f,%f,%f,H=5",calxmin,calymin,calxmax,calymax)
    endif
    if SERV.Cmdimm(0,s)<=0 err=1
    if (testertype==TT_A7 || testertype==TT_A8) && $LAY.nfing<=4 then
      sprintf(s,"DEFREGION %f,%f,%f,%f,H=7",                                   \
        calxmin,$LAY.top[0]/1000.0-40.0,calxmin+40,$LAY.top[0]/1000.0+40.0)
      if SERV.Cmdimm(1,s)<=0 err=1
      sprintf(s,"DEFREGION %f,%f,%f,%f,H=7",                                   \
        calxmax-40.0,$LAY.top[0]/1000.0-40.0,calxmax,$LAY.top[0]/1000.0+40.0)
      if SERV.Cmdimm(2,s)<=0 err=1
    else
      sprintf(s,"DEFREGION %f,%f,%f,%f,H=0",                                   \
        calxmin+5.0,calymin+3.0,calxmax-5.0,calymax-3.0)
      if SERV.Cmdimm(1,s)<=0 err=1
      $A[2].length=1
    endif
    if SERV.Cmdimm(3,"MAKEZMAP")<=0 err=1
    t=Time()
    while err==0 && ($A[0].length==0 || $A[1].length==0 ||                     \
      $A[2].length==0 || $A[3].length==0) do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Time()-t>2000 err=2           // Timeout exhausted
      wait
    enddo
  endif
  if err!=0 then
    i=Checkgloberrors()
    if i!=0 return i
    change hinfo text="Communication problem!"
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==1 then
      draw text="Unable to send command!"
    else if err==2 then
      draw text="No answer from tester!"
    else
      draw text="Command executed incorrectly!"
    endif
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Check status"
      help="Press to re-check the tester status"
    endc
    draw text="Calibration procedure was unable to set tester parameters. "
    draw text="It is necessary to re-check the status of the tester."
    draw show
    while 1 do
      if Pressed(hretry) return 1      // Check again the status of the tester
      if Pressed(hexit) return -1      // Quit calibration
      wait
    enddo
  endif
end

// Creates default log file and writes tester description and calibration
// parameters.
function int Openlogfile(int caltype)
  int i,j
  char s[256],path[260]
  handle hbrowse,hskip
  if hlog!=NULL then                   // Re-open if called for the second time
    Fclose(hlog)
    hlog=NULL
  endif
  if verifymode==VERIFY_REPLAY then
    Strcpy(path,"replay.txt")
  else if calmode==MODE_3DCAL then
    Strcpy(path,"calibr3d.txt")
  else if calmode==MODE_VER then
    Strcpy(path,"verify.txt")
  else if calmode==MODE_CADJ then
    Strcpy(path,"caladj.txt")
  else
    Strcpy(path,"calibr.txt")
  endif
retry:
  hlog=Fopen(path,"wt")
  if hlog==NULL then
    clear hright
    change hinfo limits=0,0
    change hinfo text="Unable to open log file"
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK text="Unable to open log file "
    draw font=INFOFONT color=LIGHTRED text=format("'%s'",path)
    draw font=TIMESFONT color=BLACK text=". Please select different name or "
    draw text="press " font=MAINFONT text="Skip" font=TIMESFONT text=" to "
    draw text="disable protocolling."
    draw show
    hbrowse=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Select name"
      help="Press to select different file for calibration protocol"
    endc
    hskip=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Skip"
      help="Press to disable protocolling (not recommended!)"
    endc
    while 1 do
      if Pressed(hbrowse) then
        if SYS.Browse(hmain,path,"Select log file",0)!=0 goto retry
      else if Pressed(hskip) then
        return 0                       // Disable logging
      else if Pressed(hexit) then
        return -1                      // Quit calibration
      endif
      wait
    enddo
  endif
  // Log file created, fill it with important data.
  if verifymode==VERIFY_REPLAY then fprintf(hlog,                              \
    "\n                   R E P L A Y   L O G   F I L E\n\n")
  else if calmode==MODE_3DCAL then fprintf(hlog,                               \
    "\n          3 - D   C A L I B R A T I O N   L O G   F I L E\n\n")
  else if calmode==MODE_VER then fprintf(hlog,                                 \
    "\n             V E R I F I C A T I O N   L O G   F I L E\n\n")
  else if calmode==MODE_CADJ then fprintf(hlog,                                \
    "\n      C A P A C I T Y   A D J U S T M E N T   L O G   F I L E\n\n")
  else fprintf(hlog,                                                           \
    "\n              C A L I B R A T I O N   L O G   F I L E\n\n")
  endif
  fprintf(hlog,"Version of script file:    %s\n",VERSION)
  Strtime(s,   "Start on:                  %a %d-%b-%Y %H:%M\n",0,0)
  fprintf(hlog,"%s",s)
  if testertype==TT_A2 then
    j=sprintf(s,"A2/%i",$LAY.nfing*2)
  else if testertype==TT_A2L then
    j=sprintf(s,"A2/%iL",$LAY.nfing*2)
  else if testertype==TT_A2H then
    j=sprintf(s,"A2/%iM",$LAY.nfing*2)
  else if testertype==TT_A3 || testertype==TT_A3L then
    j=sprintf(s,"A3/%i",$LAY.nfing*2)
  else if testertype==TT_A4 then
    j=sprintf(s,"A4/%i",$LAY.nfing*2)
  else if testertype==TT_A5 then
    if ($LAY.config & LC_TYPEMASK)==LC_NEWA1 then
      j=sprintf(s,"A1/%i",$LAY.nfing*2)
    else
      j=sprintf(s,"A5/%i",$LAY.nfing*2)
    endif
  else if testertype==TT_A5L then
    j=sprintf(s,"A5/%iL",$LAY.nfing*2)
  else if testertype==TT_A6 then
    if ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
      j=sprintf(s,"A6/%i EPCOS",$LAY.nfing*2)
    else
      j=sprintf(s,"A6/%i",$LAY.nfing*2)
    endif
  else if testertype==TT_S1 then
    j=sprintf(s,"S1/%i",$LAY.nfing*2)
  else if testertype==TT_S2 then
    j=sprintf(s,"S2/%i",$LAY.nfing*2)
  else if testertype==TT_S3 then
    j=sprintf(s,"S3/%i",$LAY.nfing*2)
  else if testertype==TT_A7 then
    j=sprintf(s,"A7/%i",$LAY.nfing*2)
  else if testertype==TT_A8 then
    j=sprintf(s,"A8/%i",$LAY.nfing*2)
  else
    j=sprintf(s,"Unknown")
  endif
  if $LAY.cameras==1 || $LAY.cameras==2 then
    j=j+sprintf(s+j," with 1 camera")
  else if $LAY.cameras==0 && $LAY.headcameras!=0 then
    j=j+sprintf(s+j," with head cameras")
  endif
  if testersides!=0x03 j=j+sprintf(s+j," (single-sided)")
  fprintf(hlog,"Tester type:               %s\n",s)
  for i=0,i<32,i++ do
    s[i]=$LAY.serialid[i]
  enddo
  fprintf(hlog,"Layout ID string:          %.32s\n",s)
  if ($GLOBAL.debugmode & 0x20BF)!=0 || ($GLOBAL.videomode & 0x20BF)!=0 ||     \
    $GLOBAL.disabledrails!=0 || $uint4($GLOBAL+280)!=0 then
    fprintf(hlog,"Debug mode bits (heads):   0x%04X\n",$GLOBAL.debugmode)
    fprintf(hlog,"Debug mode bits (cameras): 0x%04X\n",$GLOBAL.videomode)
    fprintf(hlog,"Disabled rails:            0x%08X\n",$GLOBAL.disabledrails)
    fprintf(hlog,"Disabled measurements:     0x%08X\n",$uint4($GLOBAL+280))
  endif
  fprintf(hlog,"Type of calibration:       ");
  if (caltype==0) then fprintf(hlog,"Accurate with FR4 board\n");
  else if (caltype==1) then fprintf(hlog,"Fast with FR4 board\n");
  else if (caltype==2) then fprintf(hlog,"Accurate with glass board\n");
  else if (caltype==3) then fprintf(hlog,"Precise with MCM glass\n");
  else if (caltype==4) then fprintf(hlog,"Custom\n");
  else if (caltype==6) then fprintf(hlog,"Two-step MCM\n");
  else if (caltype==7) then fprintf(hlog,"Two-board MCM\n");
  else fprintf(hlog,"Quick head adjustment\n"); endif
  fprintf(hlog,"Calibration board:         ");
  if (caltype==5) then fprintf(hlog,"not required\n");
  else if (boardtype==0) then
    if smallboard then fprintf(hlog,"Small FR4\n");
    else fprintf(hlog,"FR4\n"); endif
  else if (boardtype==1) then
    if smallboard then fprintf(hlog,"Small glass\n");
    else fprintf(hlog,"Glass\n"); endif
  else if (boardtype==2) then fprintf(hlog,"MCM glass\n");
  else fprintf(hlog,"Unknown\n"); endif
  if caltype!=5 then
    fprintf(hlog,"Line width:                %.3f mm\n",linewidth)
    fprintf(hlog,"Relative accuracy:         %.4f mm\n",accuracy)
    fprintf(hlog,"Calibrated rails:          ")
    if usesides==0x00 then
      fprintf(hlog,"None\n")
    else
      if testersides==0x03 then
        fprintf(hlog,"From %i(%i) to %i(%i)",                                  \
        firsttop,firstbot,lasttop,lastbot)
      else if testersides==0x01 then
        fprintf(hlog,"From %i to %i",firsttop,lasttop)
      else
        fprintf(hlog,"From %i to %i",firstbot,lastbot)
      endif
      if usesides!=testersides then
        if usesides==0x1 fprintf(hlog,", top side only")
        if usesides==0x2 fprintf(hlog,", bottom side only")
      endif
      if (usesides & testersides & 0x2)!=0 &&                                  \
        ($LAY.config & LC_VACUUMBOX)!=0 then
        fprintf(hlog," (Bottom side disabled by vacuum box)")
      endif
      fprintf(hlog,"\n")
      if $LAY.excludedrails!=0 then
        fprintf(hlog,"Rails excluded in layout:  0x%04X\n",$LAY.excludedrails)
      endif
    endif
    fprintf(hlog,"X range:                   From %.1f to %.1f mm\n",fromx,tox)
    fprintf(hlog,"Z stroke:                  %i mm/s\n",v)
    fprintf(hlog,"Z pressure:                %i units\n",p)
    fprintf(hlog,"Minimal Z height:          %.1f mm\n",z)
    fprintf(hlog,"Crosses to scan:           ")
    if throwaway==1 then fprintf(hlog,"Every")
    else if throwaway==2 then fprintf(hlog,"Each second")
    else if throwaway==3 then fprintf(hlog,"Each third")
    else fprintf(hlog,"Each %i-th",throwaway); endif
    if precisey==PRY_3LINE then
      fprintf(hlog,", three lines")
    else if precisey==PRY_YPROF then
      fprintf(hlog,", Y profile")
    endif
    if interlace fprintf(hlog,", interlaced")
    fprintf(hlog,"\n")
    fprintf(hlog,"Distance from center:      %.1f mm\n",encdist)
    fprintf(hlog,"Single reference:          %s\n",singleref?"Yes":"No")
    fprintf(hlog,"Soft landing:              %s\n",softland?"Yes":"No")
    if $LAY.probetype==0 && kelvinscan==3 then
      fprintf(hlog,"Reference:                 External antenna\n")
    else
      fprintf(hlog,"Kelvin scan:               ")
      if $LAY.probetype!=1 then fprintf(hlog,"Does not apply\n")
      else if kelvinscan==1 then fprintf(hlog,"Single probe (no reference)\n")
      else if kelvinscan==2 then fprintf(hlog,"Reference on scan line\n")
      else if kelvinscan==3 then fprintf(hlog,"Against external antenna\n")
      else fprintf(hlog,"Standard\n"); endif
    endif
    fprintf(hlog,"Finger length correction:  %.3f mm\n",extralen)
    if $LAY.cameras!=0 || $LAY.headcameras==0 then
      fprintf(hlog,"Calibrate cameras:         ")
      if cameras==0 then fprintf(hlog,"None")
      else if cameras==1 then fprintf(hlog,"Top")
      else if cameras==2 then fprintf(hlog,"Bottom")
      else if cameras==3 then fprintf(hlog,"Both")
      else fprintf(hlog,"%08X",cameras); endif
      if ($LAY.cameras & 0x2)!=0 && ($LAY.config & LC_VACUUMBOX)!=0 then
        fprintf(hlog," (Bottom side disabled by vacuum box)")
      endif
      fprintf(hlog,"\n")
    else
      fprintf(hlog,"Calibrate head cameras:    Same as rails\n")
    endif
    fprintf(hlog,"Video calibration mode:    ")
    if cameramode==0 then fprintf(hlog,"Precise\n")
    else if cameramode==1 then fprintf(hlog,"Standard\n")
    else if cameramode==2 then fprintf(hlog,"Quick\n")
    else fprintf(hlog,"%i\n",cameramode); endif
    fprintf(hlog,"Clipping:                  ")
    if (noclip) then
      fprintf(hlog,"No\n")
    else
      fprintf(hlog,"Yes\n")
    endif
    fprintf(hlog,"Illumination:              ")
    if illumination==0 then
      fprintf(hlog,"From the same camera\n")
    else
      fprintf(hlog,"From the opposite side\n")
      if cameras!=0 then
        fprintf(hlog,"X offset of opp camera:    %.1f mm\n",oppdx)
      endif
    endif
    fprintf(hlog,"Reduced accelerations:     %s\n",lowspeed?"Yes":"No")
  endif
end

// Protocols decision to continue calibration.
function int Logcontinue()
  if hlog==NULL return
  if autoconfirm then
    fprintf(hlog,"  Calibration continues according to calibration options\n")
  else
    fprintf(hlog,"  Operator decided to continue calibration\n")
  endif
end

// Checks current tester temperature. Returns -1 if operator interrupted the
// calibration, 1 if there was a command sending or receiving error and 0 if
// measurement was correct.
function int Checktemp()
  int temp,err
  handle hquit,hcont
  clear hright
  change hinfo limits=0,0
  change hinfo text="Measuring temperature"
  temp=Readtemperature()
  if temp<0 return -1                  // Operator interrupted calibration
  if temp==1 then                      // Communication problem
    err=Checkgloberrors()
    if err!=0 return err
    err=1
  endif
  if hlog!=NULL && temp!=1 then
    fprintf(hlog,"Tester temperature:        %.1f C\n",temp/10.0)
  endif
  if temp<TMIN || temp>TMAX err=2      // Temperature out of limits
  if err!=0 then
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==1 then
      change hinfo text="Communication problem!"
      draw text="Calibration procedure was unable to measure actual "
      draw text="tester temperature. "
    else
      change hinfo text="Bad temperature!"
      draw text=format("Measured tester temperature (%.1f C) ",temp/10.0)
      draw text="lies outside the recommended limits "
      draw color=BLACK text=format("(%g..%g C). ",TMIN/10.0,TMAX/10.0)
    endif
    draw color=BLACK
    draw text="Will the temperature during test differ too much from the "
    draw text="current, you will lose accuracy. Please decide whether you want "
    draw text="to continue calibration or switch on air conditioning and wait "
    draw text="till tester temperature comes into limits."
    draw show
    hquit=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Quit"
      help="Press to interrupt calibration and restart it later"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Continue"
      help="Continue at your own risk"
    endc
    while 1 do
      if Pressed(hquit) then
        return -1                      // Quit calibration
      else if Pressed(hcont) || autoconfirm then
        if hlog!=NULL then
          fprintf(hlog,"Temperature is outside recommended limits ")
          fprintf(hlog,"(%.1f..%.1f C)\n",TMIN/10.0,TMAX/10.0)
          Logcontinue()
        endif
        return 0                       // Accept error
      else if Pressed(hexit) then
        return -1                      // Quit calibration
      endif
      wait
    enddo
  endif
end


// Service function, draws up or down arrow in the currently selected window.
// Point (x,y) is the tip of the arrow.
function int Drawarrow(int up,int x,int y)
  up=(up==0?-1:1)
  draw at x-7, y+7*up to x,   y       to x+8, y+8*up
  draw at x-7, y+8*up to x,   y+1*up  to x+8, y+9*up
  draw at x-7, y+9*up to x,   y+2*up  to x+8, y+10*up
  draw at x-6, y+9*up to x,   y+3*up  to x+7, y+10*up
  draw at x-1, y+3*up to x-1, y+22*up
  draw at x,   y+3*up to x,   y+22*up
  draw at x+1, y+3*up to x+1, y+22*up
end

// Checks position of zero marks on the Z axes of A7/A8 tester. If strict is
// set, uses stricter limits and reports results even if no problems are found.
// Embedded software must support the corresponding ports (checked by this
// routine). Returns 0 on success or if measurements are unsupported, 1 on
// request to repeat this verification and -1 if operator decided to stop
// calibration. This check is treated as unimportant.
function int Checkzzeros(int strict)
  int d,t,y,step,head,z,zedge[32],zlimit[32],zdone[32],finished,err
  int explain,firsterr,changed,limitmin,limitmax
  int zpower[32],zireg[32],zprev1[32],zprev2[32],friction[32]
  char s[256]
  handle hinterrupt,htable,hrepeat,hcont,hselect[32]
  // Check that Z motor power port is supported.
  err=0
  for head=0,head<$LAY.nfing*2,head++ do
    if c[head].ncal==0 continue        // Finger is excluded from calibration
    sprintf(s,"INPORT32 HEAD(%i),0x10010102",head)
    SERV.Cmdimm(head,s)
  enddo
  t=Time()
  while 1 do
    if Pressed(hexit) return -1
    for head=0,head<$LAY.nfing*2,head++ do
      if c[head].ncal==0 continue
      if $A[head].length==0 break
    enddo
    if head>=$LAY.nfing*2 break
    if Time()-t>2000 err=1
    wait
  enddo
  for head=0,head<$LAY.nfing*2 && err==0,head++ do
    if c[head].ncal==0 continue
    if $A[head].answer!=S_INPORT32 err=2
    if $int4($A[head]+5)==0 err=3
  enddo
  if err!=0 && strict==0 return 0      // Port is probably unsupported
  // Main test.
  if strict==0 then
    limitmin=100; limitmax=1200
  else
    limitmin=300; limitmax=1000
  endif
  Drawtesterview()
  change hinfo limits=0,0
  change hinfo text="Checking Z zero marks"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Script will estimate the friction in Z axes and check whether "
  draw text="end marks on the Z encoders are correctly placed. If you are "
  draw text="sure that marks are correct, doubleclick " font=MAINFONT
  draw text="Interrupt" font=TIMESFONT text="."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt Z zero marks test"
    mode=M_DBLCLICK
  endc
  for head=0,head<$LAY.nfing*2,head++ do
    zedge[head]=0                      // Z where edge of end sensor was reached
    zlimit[head]=0                     // Z where power limit was reached
    zdone[head]=0
    zireg[head]=-1000000
  enddo
  // Step 0 is the preliminary movement. Steps 1 and 2 are used to measure the
  // friction in the guide. Search for the locking ball (25 um steps) follows.
  for step=0,step<=82,step++ do
    if step==0 then
      z=5500
    else if step==1 then
      z=5550
    else
      z=5500-(step-2)*25
    endif
    // Send Z movement commands.
    finished=1
    for head=0,head<$LAY.nfing*2,head++ do
      if c[head].ncal==0 continue
      if zdone[head] continue
      // If first movement, set low Z port speed (10 um/interrupt = 100 mm/s)
      // to reduce noise.
      if step==0 then
        sprintf(s,"OUTPORT32 HEAD(%i) 0x10010007,10",head)
        SERV.Cmdimm(32,s)
      endif
      // Note: pressure check is turned off!
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010018,%i",head,z)
      SERV.Cmdimm(head,s)
      finished=0
    enddo
    if finished break                  // All done
    t=Time()
    // Wait for answers. They come instantly, long before the movement is
    // finished.
    while err==0 do
      if Pressed(hexit) return -1
      for head=0,head<$LAY.nfing*2,head++ do
        if c[head].ncal==0 continue
        if zdone[head] continue
        if $A[head].length==0 break
      enddo
      if head>=$LAY.nfing*2 break
      if Time()-t>2000 err=1           // Timeout
    enddo
    // Short delay to finish the movement and give time to Z regulator to set
    // new parameters. If this is one of the first positions, wait longer.
    t=Time()
    while Time()-t<(step==0?500:(step<=2?200:70)) do
      wait
    enddo
    // Measure motor power.
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      if zdone[head] continue
      sprintf(s,"INPORT32 HEAD(%i),0x10010102",head)
      SERV.Cmdimm(head,s)
    enddo
    t=Time()
    while err==0 do
      if Pressed(hexit) return -1
      for head=0,head<$LAY.nfing*2,head++ do
        if c[head].ncal==0 continue
        if zdone[head] continue
        if $A[head].length==0 break
        if $A[head].answer!=S_INPORT32 err=2
        zpower[head]=$int4($A[head]+5)
      enddo
      if head>=$LAY.nfing*2 break
      if Time()-t>2000 err=1           // Timeout
      // Note: no wait, otherwise this script would be too slow.
    enddo
    // Remember previous level of integral regulation.
    Memcpy(zprev2,zprev1,Sizeof(zireg))
    Memcpy(zprev1,zireg,Sizeof(zireg))
    // Measure new integral component of the regulation.
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      if zdone[head] continue
      sprintf(s,"INPORT32 HEAD(%i),0x10000202",head)
      SERV.Cmdimm(head,s)
    enddo
    t=Time()
    while err==0 do
      if Pressed(hexit) return -1
      for head=0,head<$LAY.nfing*2,head++ do
        if c[head].ncal==0 continue
        if zdone[head] continue
        if $A[head].length==0 break
        if $A[head].answer!=S_INPORT32 err=2
        zireg[head]=$int4($A[head]+5)
      enddo
      if head>=$LAY.nfing*2 break
      if Time()-t>2000 err=1           // Timeout
      // Note: no wait, otherwise this script would be too slow.
    enddo
    // Standard Z power is 4%. If power exceeds 6%, or if integral component of
    // regulation drops by more than 50 micrometers, we have reached the limit.
    // Move head into the default coordinate (5000 um) and mark head as done.
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      if zdone[head] continue
      if step==2 then
        // Estimate friction. If friction is too high, test is not possible.
        friction[head]=Abs(zprev1[head]-zireg[head])
        if friction[head]>=250 then
          sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,5000",head)
          SERV.Cmdimm(head,s)
          SYS.Killimm(head)            // Don't wait for answer
          zlimit[head]=z
          zdone[head]=2                // High friction
        endif
      else if step>4 && (zpower[head]>60 ||                                    \
        zprev2[head]-zireg[head]>($LAY.side[head/2]==0?400:300)) then
        // Locking ball found.
        sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,5000",head)
        SERV.Cmdimm(head,s)
        SYS.Killimm(head)              // Don't wait for answer
        zlimit[head]=z
        zdone[head]=1
      endif
    enddo
    // Get state of Z end sensors.
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      if zdone[head] || zedge[head]!=0 continue
      sprintf(s,"INPORT32 HEAD(%i),0x000000CA",head)
      SERV.Cmdimm(head,s)
    enddo
    t=Time()
    while err==0 do
      if Pressed(hexit) return -1
      for head=0,head<$LAY.nfing*2,head++ do
        if c[head].ncal==0 continue
        if zdone[head] || zedge[head]!=0 continue
        if $A[head].length==0 break
      enddo
      if head>=$LAY.nfing*2 break
      if Time()-t>2000 err=1           // Timeout
      // Note: no wait, otherwise this script would be too slow.
    enddo
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      if zdone[head] || zedge[head]!=0 continue
      if $A[head].answer!=S_INPORT32 then
        err=2
      else if ($A[head].inport & 0x4)==0 then
        zedge[head]=z
      endif
    enddo
  enddo
  // Restore default Z port speed and move all heads in default Z coordinate.
  SERV.Cmdimm(32,"OUTPORT32 ALL 0x10010007,0")
  SYS.Killimm(32)
  SERV.Cmdimm(32,"OUTPORT32 ALL 0x10010008,5000")
  SYS.Killimm(32)
  // Test finished, analyse results.
  if err==0 then
    if hlog!=NULL fprintf(hlog,"Results of Z zero mark test:\n")
    for head=0,head<$LAY.nfing*2,head++ do
      if c[head].ncal==0 continue
      if hlog!=NULL then
        fprintf(hlog,"  %i%c: sensor = %5i, limit = %5i um\n",                 \
        head/2,(head & 1?'R':'L'),zedge[head],zlimit[head])
      endif
      if zedge[head]==0 || zlimit[head]==0 then
        err=4                          // Definitely bad sensor position
      else if err!=4 && (zedge[head]-zlimit[head]<limitmin ||                  \
        zedge[head]-zlimit[head]>limitmax) then
        err=5                          // Bad sensor position
      else if err!=4 && err!=5 && zdone[head]==2 then
        err=6                          // High friction
      endif
    enddo
  endif
  if err==0 && strict==0 return 0      // Silent success
  // Report error or results.
  if err!=1 && err!=2 && err!=3 then
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30
    if err!=0 then
      draw color=LIGHTRED text="Script has found some heads which may cause "
      draw text="problems. "
    endif
    draw color=BLACK text="Click on the head button to see explanation."
    draw show
    htable=control CHILD
      window=hright
      position=9,90,RIGHTX-18,197
      help="Positions of Z end marks"
      bkcolor=PINK
      size=4096
      mode=M_VSCROLL
      limits=RIGHTX-20,$LAY.nfing*2*20+38
    endc
    draw window=htable font=INFOFONT color=DARKGRAY
    draw at 5,5 to 225,5
    draw at 5,5 to 5,32 at 10,26 text="Head"
    draw at 51,5 to 51,32 at 58,26 text="Friction, a.u."
    draw at 138,5 to 138,32 at 144,26 text="Distance, um"
    draw at 225,5 to 225,33
    draw at 5,32 to 225,32
    y=30
    draw font=FIXEDSYS
    explain=-1; firsterr=-1
    for head=0,head<$LAY.nfing*2,head++ do
      if c[head].ncal==0 continue
      y=y+20
      draw mode=M_CENTERED color=DARKGRAY
      draw at 5,y-18 to 5,y+2 to 225,y+2 to 225,y-18
      hselect[head]=control BUTTON
        window=htable
        position=5,y-18,51-5,20
        text=format("%i%c",head/2,(head & 1?'R':'L'))
        help=format("Click to see explanations for head %i%c",                 \
          head/2,(head & 1?'R':'L'))
        color=BLACK
        bkcolor=LIGHTGRAY
        font=FIXEDSYS
      endc
      if explain<0 explain=head
      if firsterr<0 && (zedge[head]==0 || zdone[head]==2) firsterr=head
      draw at 51,y-18 to 51,y+2
      draw color=(zdone[head]==2?LIGHTRED:BLACK)
      draw at 94,y text=format("%i",friction[head])
      draw color=DARKGRAY at 138,y-18 to 138,y+2
      draw at 181,y
      if zedge[head]==0 then
        if zdone[head]==2 then
          draw color=LIGHTRED text="Friction"
        else
          draw color=LIGHTRED text="<0"
        endif
      else if zlimit[head]==0 then
        draw color=LIGHTRED text=">2000"
      else
        d=zedge[head]-zlimit[head]
        draw color=(d<limitmin || d>limitmax?LIGHTRED:BLACK)
        draw text=format("%i",d)
      endif
    enddo
    if firsterr>=0 explain=firsterr
    if explain<0 explain=0
    change hselect[explain] color=LIGHTRED
    change hselect[explain] bkcolor=YELLOW
    changed=1
    change htable limits=1,y+7
    draw show
    hrepeat=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+20,120,24
      name="Repeat"
      help="Press to repeat Z mark test"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+20,120,24
      name="Continue"
      help="Press to continue calibration"
    endc
    while 1 do
      for head=0,head<$LAY.nfing*2,head++ do
        if c[head].ncal==0 continue
        if Pressed(hselect[head]) then
          change hselect[explain] color=BLACK
          change hselect[explain] bkcolor=LIGHTGRAY
          explain=head
          change hselect[explain] color=LIGHTRED
          change hselect[explain] bkcolor=YELLOW
          changed=1
        endif
      enddo
      if changed then
        // Display new explanation for head explain.
        draw window=hleft bkcolor=WHITE clear
        draw color=BLACK font=MEDIUMFONT mode=M_CENTERED
        draw at LEFTX/2,45
        draw text=format("Z encoder on head %i%s",explain/2,explain & 1?"R":"L")
        draw color=BLACK bkcolor=YELLOW at 130,80 fillrect 200,210
        draw color=STRANGE bkcolor=STRANGE at 153,81 fillrect 177,209
        d=zedge[explain]-zlimit[explain]
        if ($LAY.side[explain/2] & 1)==0 then
          // Head on the top side
          draw color=BLACK bkcolor=LIGHTGRAY at 120,70 fillrect 210,120
          draw at 133,107 ellipse 16,16
          draw at 197,107 ellipse 16,16
          draw color=LIGHTGRAY at 121,70 to 209,70
          draw color=LIGHTRED at 132,180 rect 151,205
          draw color=BLACK bkcolor=BLACK
          if zdone[explain]==2 then
            draw font=LARGEFONT mode=M_RIGHT at 125,210 text="?"
          else if zedge[explain]==0 then
            draw at 132,185 fillrect 151,210
            Drawarrow(1,115,180)
          else if zlimit[explain]==0 then
            draw at 132,170 fillrect 151,195
            Drawarrow(0,115,205)
          else if d<limitmin then
            draw at 132,185 fillrect 151,210
            Drawarrow(1,115,180)
          else if d>limitmax then
            draw at 132,175 fillrect 151,200
            Drawarrow(0,115,205)
          else
            draw at 132,180 fillrect 151,205
          endif
        else
          // Head on the bottom side
          draw color=BLACK bkcolor=LIGHTGRAY at 120,170 fillrect 210,220
          draw at 133,183 ellipse 16,16
          draw at 197,183 ellipse 16,16
          draw color=LIGHTGRAY at 121,219 to 209,219
          draw color=LIGHTRED at 179,85 rect 198,110
          draw color=BLACK bkcolor=BLACK
          if zdone[explain]==2 then
            draw font=LARGEFONT mode=M_LEFT at 205,115 text="?"
          else if zedge[explain]==0 then
            draw at 179,80 fillrect 198,105
            Drawarrow(0,215,110)
          else if zlimit[explain]==0 then
            draw at 179,95 fillrect 198,120
            Drawarrow(1,215,85)
          else if d<limitmin then
            draw at 179,80 fillrect 198,105
            Drawarrow(0,215,110)
          else if d>limitmax then
            draw at 179,90 fillrect 198,115
            Drawarrow(1,215,85)
          else
            draw at 179,85 fillrect 198,110
          endif
        endif
        draw color=BLACK font=TIMESFONT at 10,245 mode=M_LEFT wrap=LEFTX-5
        if zdone[explain]==2 then
          draw text="There is probably a high friction in the Z axis. "
          draw text="Therefore this script was unable to locate the position "
          draw text="of the locking ball."
        else if zedge[explain]==0 then
          draw text="Black label on the encoder that determines the home "
          draw text="position of the Z axis is too far out. Z axis touches "
          draw text="the locking ball. This may lead to oscillations and/or "
          draw text="overheating of the motor. Please move the label approx. "
          draw text="0.5 .. 1 mm in the direction of the arrow. (OK to place "
          draw text="ONE label over the existing)."
        else if zlimit[explain]==0 then
          draw text="The distance between the edge of the black label and the "
          draw text="locking ball exceeds 2 mm. The home position of the "
          draw text="needle is too close to the shuttle. Needle may be "
          draw text="damaged when shuttle moves in and out. Please move the "
          draw text="label approx. 1.5 mm in the direction of the arrow."
        else if d<limitmin then
          draw text="The distance between the edge of the black label on the "
          draw text="encoder (determines Z home position) and the locking "
          draw text="ball is suspiciously low. This may lead to continuous "
          draw text="buzzing noise after soft reset and/or overheating of "
          draw text="the motor. If necessary, move the label approx. "
          draw text=format("%.1f mm in the ",((limitmax-limitmin)/2-d)/1000.0)
          draw text="direction of the arrow. (OK to place ONE label over the "
          draw text="existing)."
        else if d>limitmax then
          draw text="The distance between the edge of the black label and the "
          draw text="locking ball is unnecessarily large. If tester is "
          draw text="equipped with the automatic shuttle, needle may be "
          draw text="damaged when shuttle moves in and out. Please check this "
          draw text="and, if necessary, move the label approx. "
          draw text=format("%.1f mm in the ",(d-(limitmax-limitmin)/2)/1000.0)
          draw text="direction of the arrow."
        else
          draw text="This Z axis is correctly adjusted."
        endif
        draw show
      endif
      if Pressed(hexit) then
        return -1
      else if Pressed(hrepeat) then
        return 1
      else if Pressed(hcont) then
        return 0
      endif
      wait
    enddo
  endif
  // Report error.
  clear hright
  hrepeat=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+20,120,24
    name="Repeat"
    help="Press to repeat Z mark test"
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+20,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED text="Error detected!"
  draw at 6,60 color=BLACK
  if err==1 then
    draw text="There was no answer from tester within 2 seconds. "
    draw text="Please decide what to do."
  else if err==2 then
    draw text="Calibration procedure received unexpected answer. "
    draw text="Please decide what to do."
  else
    draw text="Embedded software does not support test of zero marks. "
    draw text="Please update the software."
    disable hrepeat
  endif
  draw show
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hcont) then
      return 0
    else if Pressed(hrepeat) then
      return 1
    endif
    wait
  enddo
end

// Service function, draws text with arrow in the left window. Attention,
// function sets new mode, font and colours!
function int Drawtextpointer(int x0,int y0,int x1,int y1,char *text)
  int font,dx,t0,t1
  font=INFOFONT                        // Default pointer font
  if text[0]=='\0' return
  dx=Textx(font,text)
  if dx==0 dx=8*Strlen(text)
  if x0<=x1 then
    t0=x1; t1=t0+dx+8
  else
    t1=x1; t0=t1-dx-8
  endif
  if t1>=LEFTX-2 then                  // Align frame properly
    t0=t0-(t1-LEFTX+2);
    t1=LEFTX-2; endif
  if t0<2 then
    t1=t1+2-t0;
    t0=2; endif
  if x1>=t1 x1=t1-1
  if x1<t0 x1=t0
  draw color=BLACK bkcolor=WHITEBLUE font=font mode=0
  draw at x0,y0 to x1,y1
  if y0>y1 y1=y1-16
  draw at t0,y1 fillrect t1,y1+17
  draw at t0+3,y1+16 text=text
end

// Draws calibration board in shuttle and, if any of parameters dx, dy or dfi is
// non-zero, also the position of displaced calibration board. These parameters
// show the shifts necessary to place board in the exact position, i.e. dx>0
// means that board is too far to the left and must be moved right, dy>0 means
// that board is shifted down and must be moved up, dfi>0 means that board is
// turned clockwise and must be rotated counterclockwise, and so on. Mode is
// combination of DR_xxx.
function int Drawcalboard(float dx,float dy,float dfi,int mode)
  int shuttlewidth,pcbheight,pcbwidth,holderwidth,isxxl
  int pcbcolour,pcbborder
  int i,j,k,x0,xf,x,y,xc,yc,xd,yd,x1,y1,x2,y2
  int left,right,top,bottom,toppcb,botpcb,hw2
  int rdy,vertice[8],nwave,twodist
  float f,step,scale,sfi,cfi,xstart,xend,wbase
  char s[128]
  if boardtype==0 then                 // FR4 board
    pcbcolour=((dy==0.0 && dfi==0.0)?YELLOW:LIGHTYELLOW)
    pcbborder=BROWN
  else                                 // Glass board
    pcbcolour=((dy==0.0 && dfi==0.0)?WHITECYAN:WHITE)
    pcbborder=LIGHTBLUE
  endif
  isxxl=0
  if testertype==TT_A2 || testertype==TT_A2H || testertype==TT_A4 ||           \
    testertype==TT_A6 || (testertype==TT_S1 && $LAY.leftlimit>=600000) ||      \
    (testertype==TT_A8 && siderail<=2 && $LAY.leftlimit>=600000) then
    shuttlewidth=920
    pcbheight=650
    if boardtype==2 then pcbwidth=364;
    else pcbwidth=654; endif
    boardy=51
  else if testertype==TT_A2L then
    shuttlewidth=1120
    pcbheight=650
    if boardtype==2 then pcbwidth=364;
    else pcbwidth=654; endif
    boardy=51
  else if testertype==TT_A3 then
    shuttlewidth=700
    pcbheight=425
    pcbwidth=480
    boardy=46
  else if testertype==TT_A3L || testertype==TT_A5 then
    shuttlewidth=800
    pcbheight=425
    pcbwidth=550
    boardy=46
  else if testertype==TT_A5L then
    shuttlewidth=800
    if smallboard then
      pcbheight=425
      pcbwidth=550
      boardy=46
    else
      pcbheight=490
      pcbwidth=640
      boardy=49.5
    endif
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    shuttlewidth=600
    pcbheight=340
    pcbwidth=240
    boardy=51
  else if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
    if $LAY.rightlimit-$LAY.leftlimit>=600000 then
      shuttlewidth=920
      if siderail==2 then
        pcbheight=340
      else
        pcbheight=650
      endif
      if boardtype==0 && smallboard then pcbwidth=320;
      else if boardtype==1 && smallboard then pcbwidth=340;
      else if boardtype==2 then pcbwidth=364;
      else pcbwidth=654; endif
      boardy=51
    else
      shuttlewidth=500
      pcbheight=320
      pcbwidth=320
      boardy=18
    endif
  else if testertype==TT_A7 && largeboard &&                                   \
    $LAY.rightlimit-$LAY.leftlimit>800000 then
    shuttlewidth=1250
    pcbheight=250*siderail+30
    pcbwidth=890
    boardy=2.7
    isxxl=1
  else if testertype==TT_A7 && siderail==4 then
    shuttlewidth=1030
    pcbheight=995
    pcbwidth=590
    boardy=2.7
    isxxl=1
  else if testertype==TT_A7 && siderail==5 then
    shuttlewidth=1030
    pcbheight=1250
    pcbwidth=580
    boardy=2.7
    isxxl=1
  else if testertype==TT_A7 then
    shuttlewidth=920
    if smallboard then
      if boardtype==1 then
        pcbheight=425
        pcbwidth=550
        boardy=46
      else
        pcbheight=490
        pcbwidth=640
        boardy=49.5
      endif
    else
      pcbheight=540
      if boardtype==1 then
        pcbwidth=500
      else
        pcbwidth=640
      endif
      boardy=52
    endif
  else if testertype==TT_A8 then
    if $LAY.rightlimit-$LAY.leftlimit>=600000 then
      shuttlewidth=920
    else
      shuttlewidth=620
    endif
    if siderail<=2 then
      pcbheight=340
      boardy=20
    else
      pcbheight=650
      boardy=51
    endif
    if boardtype==2 then
      pcbwidth=332
    else
      pcbwidth=460
    endif
  endif
  if (mode & DR_EMPTY) pcbwidth=shuttlewidth/3
  if ($LAY.config & LC_LDMASK)==(LC_AUTOMATE|LC_A2LOADER) then
    boardx=0.0                         // Automatical shuttle
  else if testertype==TT_A5L && smallboard==0 then
    boardx=1.5                         // A5L large calibration board
  else if testertype==TT_A7 && isxxl then
    boardx=56                          // A7/20 calibration board
  else if ($LAY.config & LC_SMASK)==LC_A5WIDE then
    boardx=7.0                         // A5 wide shuttle
  else if ($LAY.config & LC_LDMASK)==(LC_LMS2|LC_A2LOADER) then
    boardx=13.0                        // S2 CF shuttle
  else
    boardx=(shuttlewidth-pcbwidth)/20.0-9
  endif
  holderwidth=40
  if isxxl then
    scale=(LEFTY-110.0)/pcbheight
  else
    scale=Min((LEFTX-20.0)/shuttlewidth,                                       \
    220.0/($LAY.top[$LAY.nfing-1]-$LAY.bottom[0])*1000.0)
  endif
  xf=LEFTX/2
  x0=xf+boardshift*scale
  left=x0-pcbwidth/2.0*scale+1
  right=left+pcbwidth*scale+1
  if boardshift>0 then
    twodist=left-right-4
  else
    twodist=right-left+4
  endif
  if testertype==TT_A5L && smallboard!=0 then
    top=50
    bottom=top+pcbheight*scale
    toppcb=top-25.0*scale
    botpcb=bottom-25.0*scale
  else if testertype==TT_A7 && isxxl then
    top=43
    bottom=top+pcbheight*scale
    toppcb=top-35.0*scale
    botpcb=bottom-25.0*scale
    holderwidth=20
  else if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
    top=75
    bottom=top+($LAY.top[$LAY.nfing-1]-$LAY.bottom[0])/1000.0*scale
    toppcb=top-55.0*scale
    botpcb=bottom-55.0*scale
  else if testertype==TT_A7 && smallboard!=0 && boardtype!=1 then
    top=50
    bottom=top+($LAY.top[$LAY.nfing-1]-$LAY.bottom[0])/1000.0*scale
    toppcb=top-25.0*scale
    botpcb=bottom-25.0*scale
  else
    top=50
    bottom=top+pcbheight*scale
    toppcb=top
    botpcb=bottom
  endif
  hw2=holderwidth*scale-2
  clear hleft
  // Draw shuttle plate.
  draw window=hleft color=LIGHTYELLOW bkcolor=LIGHTYELLOW
  draw at 0,0 fillrect LEFTX,LEFTY
  if ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
    draw color=GRAY bkcolor=GRAY
    draw at xf-shuttlewidth/2*scale,10
    draw fillrect xf+shuttlewidth/2*scale,bottom+(isxxl?20:60)
    draw color=DARKGRAY bkcolor=LIGHTYELLOW
    draw at xf-shuttlewidth/2*scale+15,(isxxl?18:22)
    if testertype==TT_A2 || testertype==TT_A2L || testertype==TT_A2H ||        \
      testertype==TT_A4 || testertype==TT_A6 ||                                \
      testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||           \
      (testertype==TT_A7 && isxxl==0) || testertype==TT_A8 then
      draw fillrect xf+shuttlewidth/2*scale-15,bottom+14
      for y=35,y<bottom+10,y=y+15
        draw at xf-shuttlewidth/2*scale+7,y fillellipse 5,5
        draw at xf+shuttlewidth/2*scale-7,y fillellipse 5,5
      enddo
    else
      draw fillrect xf+shuttlewidth/2*scale-15,bottom+(isxxl?10:24)
    endif
  endif
  if (mode & DR_EMPTY)==0 then
    // Draw calibration board and rail areas.
    draw color=pcbborder bkcolor=pcbcolour
    if smallboard==0 then
      draw at left,toppcb fillrect right,botpcb
      if twostep==2 then
        draw at left+twodist,toppcb fillrect right+twodist,botpcb
      endif
    endif
    x=xf-$LAY.xoffset/1000.0*scale
    y=bottom-5
    for i=0,i<$LAY.nfing,i++
      if smallboard!=0 && smallfirst>=0 && (i<smallfirst || i>smallfirst+1)    \
        continue
      xc=Max(left,x+$LAY.leftlimit/1000.0*scale-2)
      yc=Max(toppcb,y-$LAY.top[i]/1000.0*scale)
      xd=Min(right,x+$LAY.rightlimit/1000.0*scale)
      yd=Min(botpcb,y-$LAY.bottom[i]/1000.0*scale+1)
      if (mode & DR_RAIL)!=0 && mverifyrail>=0 && mverifyrail<$LAY.nfing &&    \
        $LAY.bottom[i]==$LAY.bottom[mverifyrail] &&                            \
        $LAY.top[i]==$LAY.top[mverifyrail]                                     \
      then
        draw bkcolor=PINK
      else
        draw bkcolor=pcbcolour
      endif
      draw at xc,yc fillrect xd,yd
      if twostep==2 then
        draw at xc+twodist,yc fillrect xd+twodist,yd
      endif
    enddo
    // Draw lowered and heightened areas on the board prepared for Z test.
    if calmode==MODE_VER && verifymode==VERIFY_ZALIGN then
      for i=0,i<$LAY.nfing,i++
        if testertype==TT_A6 || testertype==TT_S2 then
          x1=x0-8.2*xstep*scale
          x2=x0-3.8*xstep*scale
          y1=y-($LAY.yoffset[i]/1000.0+5.0*ystep)*scale
          y2=y-($LAY.yoffset[i]/1000.0-5.0*ystep)*scale
        else
          x1=x0-6.5*xstep*scale
          x2=x0-2.5*xstep*scale
          y1=y-($LAY.yoffset[i]/1000.0+3.5*ystep)*scale
          y2=y-($LAY.yoffset[i]/1000.0-3.5*ystep)*scale
        endif
        draw color=WHITE at x1,y2 to x1,y1 to x2+1,y1
        draw color=WHITE at x1+1,y2-1 to x1+1,y1+1 to x2,y1+1
        draw color=BLACK at x1+1,y2 to x2,y2 to x2,y1
        draw color=DARKGRAY at x1+2,y2-1 to x2-1,y2-1 to x2-1,y1+1
        if testertype==TT_A6 || testertype==TT_S2 then
          x1=x0+3.8*xstep*scale
          x2=x0+8.2*xstep*scale
          y1=y-($LAY.yoffset[i]/1000.0+5.0*ystep)*scale
          y2=y-($LAY.yoffset[i]/1000.0-5.0*ystep)*scale
        else
          x1=x0+2.5*xstep*scale
          x2=x0+6.5*xstep*scale
          y1=y-($LAY.yoffset[i]/1000.0+3.5*ystep)*scale
          y2=y-($LAY.yoffset[i]/1000.0-3.5*ystep)*scale
        endif
        draw color=BLACK at x1,y2 to x1,y1 to x2+1,y1
        draw color=DARKGRAY at x1+1,y2-1 to x1+1,y1+1 to x2,y1+1
        draw color=WHITE at x1+1,y2 to x2,y2 to x2,y1
        draw color=WHITE at x1+2,y2-1 to x2-1,y2-1 to x2-1,y1+1
      enddo
    endif
    // Draw lines and reference points on the calibration board.
    if (mode & DR_VIDEO)!=0 then
      draw color=LIGHTRED bkcolor=LIGHTRED
      i=$LAY.nfing*2
      if c[i].ncal==0 i++
      for j=0,j<c[i].ncal,j++
        xc=x+c[i].xa[j]*scale
        yc=y-c[i].ya[j]*scale
        draw at xc-1,yc-1 fillrect xc+2,yc+2
      enddo
    endif
    draw color=BLACK bkcolor=BLACK
    if (mode & (DR_HEAD|DR_VIDEO))!=0 then
      for i=0,i<$LAY.nfing,i++ do
        if (i<firsttop || i>lasttop) && (i<firstbot || i>lastbot) continue
        rdy=Max(1.0,refsizey*scale/2.0)
        xc=x+c[i*2].refx0*scale
        yc=y-c[i*2].refy0*scale
        draw at xc-1,yc-rdy fillrect xc+2,yc+rdy
        xc=x+c[i*2+1].refx0*scale
        yc=y-c[i*2+1].refy0*scale
        draw at xc-1,yc-rdy fillrect xc+2,yc+rdy
        if (mode & DR_HEAD)!=0 then
          k=i*2
          if c[i*2].ncal==0 k++
          for j=0,j<c[k].ncal,j++
            xc=x+c[k].xa[j]*scale
            yc=y-c[k].ya[j]*scale
            if mode & DR_SELECT then
              draw at xc-3,yc to xc+4,yc
              draw at xc,yc-3 to xc,yc+4
            else
              draw at xc-1,yc to xc+2,yc
              draw at xc,yc-1 to xc,yc+2
            endif
          enddo
        endif
      enddo
    endif
    // Draw Z position warning.
    if (mode & DR_Z)!=0 && calmode==MODE_3DCAL then
      draw mode=M_CENTERED font=LARGEFONT color=LIGHTRED
      draw at (left+right)/2,(toppcb+botpcb)/2+17
      draw text=format("dZ > %g mm",MIN3DDIST/1000.0)
    endif
    // Draw waveness test area.
    if mode & DR_WAVENESS then
      draw color=LIGHTRED
      for i=0,i<$LAY.nfing,i++ do
        if c[i*2].ncal==0 continue
        if wavenessdir==0 then
          // Horizontal line. Waveness limits must be calculated exactly as in
          // Fillcalibrators().
          xstart=fromxloc
          xend=toxloc
          if testertype==TT_A7 && smallboard==0 && boardtype==1 then
            while xstart<$LAY.xoffset/1000.0-232.5 do
              xstart=xstart+xstep
            enddo
            while xend>$LAY.xoffset/1000.0+232.5 do
              xend=xend-xstep
            enddo
          endif
          nwave=(xend-xstart)*NSUBWAVE/xstep
          nwave=nwave & 0xFFFFFFFE
          nwave=Min(nwave,NWAVEL)
          if wavenesstype==0 nwave=Min(nwave,NWAVE)
          wbase=$LAY.xoffset/1000.0+boardshift
          while wbase+((nwave/NSUBWAVE)/2)*xstep>xend do
            wbase=wbase-xstep
          enddo
          while wbase-((nwave/NSUBWAVE)/2)*xstep<xstart do
            wbase=wbase+xstep
          enddo
          x1=x+Max(xstart,wbase-((nwave/NSUBWAVE)/2)*xstep)*scale
          x2=x+Min(wbase+((nwave/NSUBWAVE)/2)*xstep,xend)*scale
          y1=y-($LAY.yoffset[i]/1000.0+wavenessvdist)*scale
          draw at x1,y1-1 to x2+1,y1-1
          draw at x1-1,y1 to x2+2,y1
          draw at x1,y1+1 to x2+1,y1+1
        else
          // Vertical line.
          x1=x+($LAY.xoffset/1000.0+wavenesshdist)*scale
          f=Min($LAY.top[0]-$LAY.yoffset[0],                                   \
            $LAY.yoffset[0]-$LAY.bottom[0])/1000.0
          if testertype==TT_M2 then
            f=f-2.0; step=ystep
          else if testertype==TT_A5L && smallboard!=0 then
            f=f-30.0; step=ystep
          else if testertype==TT_A7 && smallboard!=0 then
            f=f-25.0; step=12.5
          else
            f=f-5.0; step=ystep
          endif
          f=Floor(f/step)*step
          y1=y-($LAY.yoffset[i]/1000.0+f)*scale
          y2=y-($LAY.yoffset[i]/1000.0-f)*scale
          draw at x1-1,y1 to x1-1,y2+1
          draw at x1,y1-1 to x1,y2+2
          draw at x1+1,y1 to x1+1,y2+1
        endif
      enddo
    endif
  endif
  draw color=DARKGRAY bkcolor=GRAY
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    // Draw holders.
    draw at 15,10 fillrect 32,botpcb+50
    draw at 290,10 fillrect 307,botpcb+50
    draw at 15,toppcb-hw2-12 fillrect 159,toppcb-hw2+1
    draw at 15,botpcb+hw2+12 fillrect 159,botpcb+hw2-1
    draw at 163,toppcb-hw2-12 fillrect 307,toppcb-hw2+1
    draw at 163,botpcb+hw2+12 fillrect 307,botpcb+hw2-1
    // Draw fixtures.
    draw color=DARKGRAY bkcolor=WHITE
    draw at 45,toppcb-hw2 fillrect 154,toppcb+2
    draw at 168,toppcb-hw2 fillrect 277,toppcb+2
    draw at 45,botpcb-2 fillrect 154,botpcb+hw2
    draw at 168,botpcb-2 fillrect 277,botpcb+hw2
  else
    // Draw holding frame.
    if testertype==TT_A3 || testertype==TT_A3L ||                              \
      testertype==TT_A5 || testertype==TT_A5L then
      draw at xf-shuttlewidth/2*scale+17,toppcb-hw2-12
      draw fillrect xf+shuttlewidth/2*scale-17,toppcb-hw2+2
      draw at xf-shuttlewidth/2*scale+17,botpcb+10
      draw fillrect xf+shuttlewidth/2*scale-17,botpcb+23
    endif
    draw at left-hw2-15,10 fillrect left-hw2+2,botpcb+(isxxl?25:50)
    draw at right+hw2-2,10 fillrect right+hw2+15,botpcb+(isxxl?25:50)
    if testertype==TT_A3 || testertype==TT_A3L ||                              \
      testertype==TT_A5 || testertype==TT_A5L then
      draw at left-hw2-8,25 rect left-hw2-5,botpcb+21
      draw at right+hw2+5,25 rect right+hw2+8,botpcb+21
    endif
    if testertype==TT_A2 || testertype==TT_A2L || testertype==TT_A2H ||        \
      testertype==TT_A4 || testertype==TT_A6 ||                                \
      testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||           \
      testertype==TT_A7 || testertype==TT_A8 then
      draw at xf-shuttlewidth/2*scale,toppcb-hw2-12
      draw fillrect xf+shuttlewidth/2*scale,toppcb-hw2+1
    endif
    if testertype==TT_A7 && isxxl then
      draw at xf-shuttlewidth/2*scale,botpcb+1
      draw fillrect xf+shuttlewidth/2*scale,botpcb+14
    endif
    // Draw fixtures.
    if testertype==TT_A3 || testertype==TT_A3L ||                              \
      testertype==TT_A5 || testertype==TT_A5L then
      draw color=BLACK bkcolor=BLACK
      draw at left-hw2,toppcb+20 fillrect left+2,toppcb+35
      draw at left-hw2,botpcb-35 fillrect left+2,botpcb-20
      draw at right-2,toppcb+20 fillrect right+hw2,toppcb+35
      draw at right-2,botpcb-35 fillrect right+hw2,botpcb-20
      draw at xf-7,botpcb-2 fillrect xf+7,botpcb+12
    else if isxxl==0 then
      draw color=DARKGRAY bkcolor=WHITE
      draw at left-hw2,toppcb-5 fillrect left+2,botpcb+5
      draw at right-2,toppcb-5 fillrect right+hw2,botpcb+5
      draw at xf-7,botpcb-2 fillrect xf+7,botpcb+42
    endif
    if isxxl==0 then
      draw at xf-7,toppcb-hw2 fillrect xf+7,toppcb+2
    endif
  endif
  draw mode=M_CENTERED
  if Abs(dy)<0.001 dy=0.0
  if Abs(dfi)*pcbheight<0.001 dfi=0.0
  // Draw misplaced calibration board, if requested, and explanations.
  if (mode & DR_EMPTY) then
    ;                                  // I mean, empty!
  else if (mode & DR_DIFFCTR) then
    // Note: only configurations with max. 2 rails on each side!
    change hleft help="Note different central crosses!"
    draw at xf,LEFTY-12 font=TIMESFONT color=BROWN
    draw text="Layout centers differ from marked on the board"
    y=bottom-5
    for i=topmin,i<=topmax,i++ do
      yc=y-$LAY.yoffset[i]/1000.0*scale
      draw color=LIGHTRED
      draw at xf-3,yc to xf+4,yc
      draw at xf,yc-3 to xf,yc+4
      if i==0 then
        yc=(toppcb*3+botpcb*1)/4+2
      else
        yc=(toppcb*1+botpcb*3)/4-2
      endif
      draw color=GRAY
      draw at x0-3,yc to x0+4,yc
      draw at x0,yc-3 to x0,yc+4
      draw at x0-4,yc+1 to x0,yc+5
      draw at x0+1,yc+4 to x0+5,yc
      draw at x0+4,yc-1 to x0,yc-5
      draw at x0-1,yc-4 to x0-5,yc
    enddo
  else if (mode & DR_ROTATE)!=0 then
    change hleft help="General view of calibration board in shuttle"
    draw at xf,LEFTY-12 font=TIMESFONT color=BROWN
    draw text="Please rotate, but not flip, the calibration board"
    x=(left+right)/2
    y=(toppcb+botpcb)/2
    draw at x-22,y-22 clip x+23,y+1 color=LIGHTRED
    draw at x,y ellipse 38,38
    draw at x-21,y-8 to x-19,y
    draw at x-15,y-7 to x-19,y
    draw clip=NULL
    draw at x+4,y-22 text="180?"
  else if dx!=0.0 then
    change hleft help="Exaggerated displacement of calibration board"
    draw at xf,LEFTY-20 font=MEDIUMFONT color=BROWN
    draw text="Please adjust position of board"
    i=sprintf(s,"Move board %.1f mm %s",Abs(dx),(dx>0.0?"right":"left"))
    if dy!=0.0 i=i+sprintf(s+i," and %.1f mm %s",Abs(dy),(dy>0.0?"up":"down"))
    draw at xf,LEFTY-5 font=TIMESFONT text=s
    // Draw shifted board.
    if boardtype==0 then               // FR4 board
      draw color=BLACK bkcolor=YELLOW
    else                               // Glass board
      draw color=LIGHTBLUE bkcolor=WHITECYAN
    endif
    dx=Max(-6,Min(6,dx*5.0))
    dy=Max(-6,Min(6,dy*5.0))
    draw at left-dx,toppcb+dy fillrect right-dx,botpcb+dy
    x=(left+right)/2
    y=(toppcb+botpcb)/2
    if dx<0.0 then
      draw at x-13,y to x+12,y
      draw at x-6,y-3 to x-13,y
      draw at x-6,y+3 to x-13,y
    else if dx>0.0 then
      draw at x-10,y to x+15,y
      draw at x+8,y-3 to x+15,y
      draw at x+8,y+3 to x+15,y
    endif
    if Abs(dy)>0.2 then
      if dy>0.0 then
        draw at x,y-10 to x,y+15
        draw at x-3,y-3 to x,y-10
        draw at x+3,y-3 to x,y-10
      else if dy<0.0 then
        draw at x,y-10 to x,y+15
        draw at x-3,y+8 to x,y+15
        draw at x+3,y+8 to x,y+15
      endif
    endif
  else if dy!=0.0 || dfi!=0.0 then
    change hleft help="Exaggerated displacement of calibration board"
    draw at xf,LEFTY-20 font=MEDIUMFONT color=BROWN
    draw text="Please adjust position of board"
    i=0; s[i]='\0'
    if dy!=0.0 i=i+sprintf(s+i,"Move board %.1f mm %s",                        \
      Abs(dy),(dy>0.0?"up":"down"))
    if dfi!=0.0 i=i+sprintf(s+i,"%s %.1f mm %sclockwise",                      \
      (dy==0.0?"Turn board":" &"),Abs(dfi)*pcbheight/2.0,                      \
      (dfi>0.0?"counter":""))
    draw at xf,LEFTY-5 font=TIMESFONT text=s
    // Draw shifted board.
    x=(left+right)/2
    y=(toppcb+botpcb)/2
    dy=Max(-6,Min(6,dy*5.0))           // Y coordinate grows downstairs
    dfi=Max(-0.05,Min(0.05,dfi*10.0))  // Same
    sfi=Sin(dfi)
    cfi=Cos(dfi)
    vertice[0]=x+(right-x)*cfi-(y-toppcb)*sfi
    vertice[1]=y+(right-x)*sfi+(y-toppcb)*cfi+dy
    vertice[2]=x+(left-x)*cfi-(y-toppcb)*sfi
    vertice[3]=y+(left-x)*sfi+(y-toppcb)*cfi+dy
    vertice[4]=x+(left-x)*cfi-(y-botpcb)*sfi
    vertice[5]=y+(left-x)*sfi+(y-botpcb)*cfi+dy
    vertice[6]=x+(right-x)*cfi-(y-botpcb)*sfi
    vertice[7]=y+(right-x)*sfi+(y-botpcb)*cfi+dy
    if boardtype==0 then               // FR4 board
      draw color=BLACK bkcolor=YELLOW
    else                               // Glass board
      draw color=LIGHTBLUE bkcolor=WHITECYAN
    endif
    draw polygon=vertice,4
    draw at x-22,y-22 clip x+23,y+1 color=LIGHTRED
    if dfi>0.0 then
      draw at x,y ellipse 38,38
      draw at x-21,y-8 to x-19,y
      draw at x-15,y-7 to x-19,y
    else if dfi<0.0 then
      draw at x,y ellipse 38,38
      draw at x+20,y-8 to x+18,y
      draw at x+14,y-7 to x+18,y
    endif
    draw clip=NULL
    if dy>0.0 then
      draw at x,y-10 to x,y+15
      draw at x-3,y-3 to x,y-10
      draw at x+3,y-3 to x,y-10
    else if dy<0.0 then
      draw at x,y-10 to x,y+15
      draw at x-3,y+8 to x,y+15
      draw at x+3,y+8 to x,y+15
    endif
  else
    change hleft help="General view of calibration board in shuttle"
    if mode!=0 then
      draw at xf,LEFTY-20 font=MEDIUMFONT color=BROWN
      if testertype==TT_A5L && smallboard!=0 then
        draw text="Small A5 calibration board"
      else if testertype==TT_S2 && smallboard!=0 then
        draw text="Small S2 calibration board"
      else if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
        draw text="A5 glass calibration board"
      else if testertype==TT_A7 && smallboard!=0 && boardtype!=0 then
        draw text="A5L calibration board"
      else
        draw text="Calibration board in shuttle"
      endif
      draw at xf,LEFTY-5 font=TIMESFONT
      if mode==DR_HEAD then
        draw text="Only crosses to be scanned by heads are displayed"
      else if mode==DR_VIDEO then
        draw text="Only fiducials to be scanned by cameras are displayed"
      endif
    endif
  endif
  draw show
end

handle hxycontrol
handle hxcoord,hxscroll
handle hycoord,hyscroll

// Functions Startxyboardpos(), Xyboardpos() and Finishxyboardpos() control
// indicators that display X-Y position of calibration board in the shuttle.
// Do not call Xyboardpos() if you don't need to edit position.
function int Startxyboardpos()
  boardxcorr=0.0
  boardycorr=0.0
  getini("Calibration","Position","%f,%f",&boardxcorr,&boardycorr)
  hxycontrol=control CHILD
    window=hleft
    position=11,LEFTY-37,LEFTX-22,30
    help=" "
    color=LIGHTYELLOW
    bkcolor=LIGHTYELLOW
    size=256
  endc
  draw window=hxycontrol font=INFOFONT color=BLACK
  draw at 5,22 text="Board position: X="
  hxcoord=control EDIT
    window=hxycontrol
    position=118,3,40,24
    help="X coordinate of calibration board in shuttle"
    font=MEDIUMFONT
    color=BLACK
    bkcolor=WHITE
  endc
  change hxcoord text=format("%.1f",boardx+boardxcorr)
  hxscroll=control VSCROLL
    window=hxycontrol
    position=158,3,18,24
    help="Press to modify X coordinate of board for future use"
    limits=1,-1
  endc
  if boardx==0.0 then
    change hxcoord text="--"
    disable hxcoord
    disable hxscroll
  endif
  draw at 180,22 text=", Y="
  hycoord=control EDIT
    window=hxycontrol
    position=210,3,40,24
    help="Y coordinate of calibration board in shuttle"
    font=MEDIUMFONT
    color=BLACK
    bkcolor=WHITE
  endc
  change hycoord text=format("%.1f",boardy+boardycorr)
  hyscroll=control VSCROLL
    window=hxycontrol
    position=250,3,18,24
    help="Press to modify Y coordinate of board for future use"
    limits=1,-1
  endc
  if boardy==0.0 then
    disable hycoord
    disable hyscroll
  endif
  draw at 273,22 text="cm"
  draw show
end

function int Xyboardpos()
  char s[256]
  float f
  if Pressed(hxcoord) then
    Text(hxcoord,s); sscanf(s,"%f",&f);
    boardxcorr=f-boardx
    change hxcoord text=format("%.1f",boardx+boardxcorr)
  else if Pressed(hxscroll) then
    Text(hxcoord,s); sscanf(s,"%f",&f);
    boardxcorr=f-boardx+Status(hxscroll)*0.1
    change hxcoord text=format("%.1f",boardx+boardxcorr)
    change hxscroll select=0
  else if Pressed(hycoord) then
    Text(hycoord,s); sscanf(s,"%f",&f);
    boardycorr=f-boardy
    change hycoord text=format("%.1f",boardy+boardycorr)
  else if Pressed(hyscroll) then
    Text(hycoord,s); sscanf(s,"%f",&f);
    boardycorr=f-boardy+Status(hyscroll)*0.1
    change hycoord text=format("%.1f",boardy+boardycorr)
    change hyscroll select=0
  endif
end

function int Finishxyboardpos()
  setini("Calibration","Position","%f,%f",boardxcorr,boardycorr)
  destroy hxycontrol
  hxycontrol=NULL
  hxcoord=NULL; hxscroll=NULL
  hycoord=NULL; hyscroll=NULL
end

// Selects general type of calibration (0 - accurate FR4, 1 - fast FR4, 2 -
// with glass board, 3 - with MCM glass, 4 - custom, 5 - quick adjustment, 6 -
// two-step MCM) and mode (calmode=MODE_CAL: calibrate tester, MODE_3DCAL: make
// 3-D calibration of already 2-D calibrated tester, MODE_VER: verify existing
// calibration, MODE_CADJ: only make capacity adjustment).
function int Selectcaltype(int def)
  int y,changed,disablesmall
  handle hacc,hfast,hglass,hmcm,hmcm2,hmcmb,hcustom,hhead,htext,hsmall,hlarge
  handle hok,h3dcal,hverifyold,hcadjust
  clear hright
  change hinfo limits=0,0
  change hinfo text="Choose how to calibrate"
  disablesmall=0
  y=51
  hacc=control RADIO
    window=hright
    position=40,y,200,21
    name="Accurate with FR4 board"
    help="Standard full calibration with FR4 board"
  endc
  y=y+22
  hfast=control RADIO
    window=hright
    position=40,y,200,21
    name="Fast with FR4 board"
    help="Accelerated (less accurate) full calibration with FR4 board"
  endc
  y=y+22
  if ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
    hglass=control RADIO
      window=hright
      position=40,y,200,21
      name="Precise with glass board"
      help="Very accurate full calibration with glass board"
    endc
    y=y+22
  else
    hglass=NULL
  endif
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    hmcm=control RADIO
      window=hright
      position=40,y,200,21
      name="MCM with special glass"
      help="Calibrate left shuttle using narrow glass board"
    endc
    y=y+22
  else if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A7 then
    hmcm=control RADIO
      window=hright
      position=40,y,200,21
      name="MCM with special glass"
      help="Calibrate middle area using narrow glass board"
    endc
    y=y+22
  else
    hmcm=NULL
  endif
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    hmcm2=control RADIO
      window=hright
      position=40,y,200,21
      name="Two-step MCM"
      help="Two-step calibration using narrow glass board"
    endc
    y=y+22
    hmcmb=control RADIO
      window=hright
      position=40,y,200,21
      name="Two-board MCM"
      help="Two-board calibration using two narrow glass boards"
    endc


disable hmcmb


    y=y+22
  else
    hmcm2=NULL
  endif
  hcustom=control RADIO
    window=hright
    position=40,y,200,21
    name="Custom"
    help="You can select all options and handicaps as you like"
  endc
  y=y+22
  if quickcorrdisabled==0 && $LAY.cameras==0x3 && (testertype==TT_A5 ||        \
    testertype==TT_A5L || testertype==TT_A6 || testertype==TT_S1 ||            \
    testertype==TT_S2 || testertype==TT_A7 || testertype==TT_A8) then
    hhead=control RADIO
      window=hright
      position=40,y,200,21
      name="Quick head correction"
      help="Very imprecise but quick head correction without calibration board"
      color=BLUE
    endc
    y=y+22
  else
    hhead=NULL
  endif
  if hmcm==NULL then
    y=y+12
  endif
  htext=control TEXT
    window=hright
    position=5,y,RIGHTX-10,60
    font=INFOFONT
    color=DARKGRAY
  endc
  if testertype==TT_A5L then
    // A5a supports only small calibration boards.
    if ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      smallboard=1
    endif
    hsmall=control CHECKBOX
      window=hright
      position=37,219,210,21
      name="Small (A5) calibration board"
      help="Check if you want to calibrate A5L with A5 calibration board"
      mode=(smallboard?M_CHECKED:0)
    endc
    if ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      disable hsmall
      disablesmall=1
    endif
    hlarge=NULL
  else if testertype==TT_S2 && $LAY.nfing<=4 &&                                \
    $LAY.rightlimit-$LAY.leftlimit>=600000 then
    hsmall=control CHECKBOX
      window=hright
      position=37,219,210,21
      name="Small (330x330 mm) board"
      help="Check if you want to calibrate S2 with S2 Small calibration board"
      mode=(smallboard?M_CHECKED:0)
    endc
    hlarge=NULL
  else if testertype==TT_A7 && $LAY.rightlimit-$LAY.leftlimit>800000 then
    hsmall=NULL
    hlarge=control CHECKBOX
      window=hright
      position=37,219,210,21
      name="Extra wide A7W board"
      help="Check if you want to calibrate A7W with A7W board"
      mode=(largeboard?M_CHECKED:0)
    endc
  else if testertype==TT_A7 && smallfirst>=0 then
    hsmall=control CHECKBOX
      window=hright
      position=37,219,210,21
      help="Check if you want to calibrate A7 with A5 calibration board"
      mode=(smallboard?M_CHECKED:0)
    endc
    hlarge=NULL
  else if testertype==TT_A8 && $LAY.rightlimit-$LAY.leftlimit<=500000 then
    smallboard=1
    hsmall=control CHECKBOX
      window=hright
      position=37,219,210,21
      name="Small calibration board"
      help="Check if you want to calibrate with small calibration board"
      mode=M_CHECKED
    endc
    disable hsmall
    disablesmall=1
    hlarge=NULL
  else
    smallboard=0
    hsmall=NULL
    hlarge=NULL
  endif
  if testertype==TT_A6 && $LAY.cameras==0 && $LAY.headcameras!=0 &&            \
    testersides==0x3 && ($LAY.config & LC_VACUUMBOX)==0                        \
  then
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY-40,120,24
      name="Calibrate"
      help="Press to start new calibration"
    endc
    h3dcal=NULL
    hverifyold=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY-10,120,24
      name="Verify"
      help="Press to verify existing calibration or make special actions"
    endc
    hcadjust=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY+20,120,24
      name="C adjust"
      help="Press to align input capacities of on-head boards"
    endc
  else if (testertype==TT_S1 || testertype==TT_S2 ||                           \
    (testertype==TT_S3 && ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO)) &&         \
    $LAY.cameras!=0                                                            \
  then
    hok=control BUTTON
      window=hright
      position=(RIGHTX-150)/2,USERY-50,150,24
      name="Calibrate"
      help="Press to start new calibration"
    endc
    h3dcal=control BUTTON
      window=hright
      position=(RIGHTX-150)/2,USERY-20,150,24
      name="3-D calibration"
      help="Press to make 3-D calibration of already calibrated tester"
    endc
    if disable3d disable h3dcal
    hverifyold=control BUTTON
      window=hright
      position=(RIGHTX-150)/2,USERY+10,150,24
      name="Verify"
      help="Press to verify existing calibration or make special actions"
    endc
    hcadjust=NULL
  else
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY-30,120,24
      name="Calibrate"
      help="Press to start new calibration"
    endc
    h3dcal=NULL
    hverifyold=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Verify"
      help="Press to verify existing calibration"
    endc
    hcadjust=NULL
  endif
  if (hglass==NULL && def==2) def=0
  if (hmcm2==NULL && def==6) def=3
  if testertype!=TT_A1 && testertype!=TT_A2 && testertype!=TT_A2L &&           \
    testertype!=TT_A2H && testertype!=TT_A4 && testertype!=TT_A6 &&            \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_A8 then
    if def==3 def=2                    // No special MCM for A3/A3L/A5/A7/S3
    if hmcm!=NULL disable hmcm
  endif
  if testertype==TT_A3 then
    if def==2 def=1                    // No glass for A3 tester
    disable hglass
  endif
  if def==0 then
    change hacc mode=M_CHECKED; setfocus hacc
  else if def==1 then
    change hfast mode=M_CHECKED; setfocus hfast
  else if def==2 then
    change hglass mode=M_CHECKED; setfocus hglass
  else if def==3 then
    change hmcm mode=M_CHECKED; setfocus hmcm
  else if def==6 then
    change hmcm2 mode=M_CHECKED; setfocus hmcm2
  else if def==4 || hhead==NULL then
    change hcustom mode=M_CHECKED; setfocus hcustom
  else
    change hhead mode=M_CHECKED; setfocus hhead
    disable hverifyold
  endif
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Please select what kind of calibration you want to use:"
  draw show
  changed=1
  while 1 do
    if Pressed(hok) then
      calmode=MODE_CAL
      break
    else if h3dcal!=NULL && Pressed(h3dcal) then
      calmode=MODE_3DCAL
      break
    else if Pressed(hverifyold) && def!=5 then
      calmode=MODE_VER
      break
    else if hcadjust!=NULL && Pressed(hcadjust) then
      calmode=MODE_CADJ
      break
    else if Pressed(hexit) then
      return -1
    else if Pressed(hacc) then
      enable hverifyold
      def=0; changed=1
    else if Pressed(hfast) then
      enable hverifyold
      def=1; changed=1
    else if hglass!=NULL && Pressed(hglass) then
      enable hverifyold
      def=2; changed=1
    else if hmcm!=NULL && Pressed(hmcm) then
      enable hverifyold
      def=3; changed=1
    else if Pressed(hcustom) then
      enable hverifyold
      def=4; changed=1
    else if hhead!=NULL && Pressed(hhead) then
      disable hverifyold
      def=5; changed=1
    else if hmcm2!=NULL && Pressed(hmcm2) then
      enable hverifyold
      def=6; changed=1
    else if hmcmb!=NULL && Pressed(hmcmb) then
      enable hverifyold
      def=7; changed=1
    else if hsmall!=NULL && Pressed(hsmall) then
      smallboard=Status(hsmall)
    else if hlarge!=NULL && Pressed(hlarge) then
      largeboard=Status(hlarge)
    endif
    if changed!=0 then
      if def==0 then
        change htext text="Accurate calibration with "
        add htext text="FR4 board is default for most applications."
        if hsmall!=NULL && disablesmall==0 enable hsmall
        if hcadjust!=NULL enable hcadjust
      else if def==1 then
        change htext text="Fast calibration with FR4 "
        add htext text="board uses fewer calibration points."
        if hsmall!=NULL && disablesmall==0 enable hsmall
        if hcadjust!=NULL enable hcadjust
      else if def==2 then
        change htext text="Precise calibration with glass board "
        add htext text="assures accuracy 10-15 um."
        if hsmall!=NULL && disablesmall==0 enable hsmall
        if hcadjust!=NULL disable hcadjust
      else if def==3 && ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
        change htext text="MCM calibration with "
        add htext text="special glass board is very accurate, but "
        add htext text="calibrates only the central area of the tester."
        if hsmall!=NULL disable hsmall
        if hcadjust!=NULL disable hcadjust
      else if def==3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
        change htext text="MCM calibration with "
        add htext text="special glass board is very accurate, but "
        add htext text="calibrates only left shuttle."
        if hsmall!=NULL disable hsmall
        if hcadjust!=NULL disable hcadjust
      else if def==4 then
        change htext text="Custom calibration allows you to set any "
        add htext text="calibration options and to exclude some "
        add htext text="rails from the calibration."
        if hsmall!=NULL && disablesmall==0 enable hsmall
        if hcadjust!=NULL disable hcadjust
      else if def==6 then
        change htext text="Two-step MCM calibration assures "
        add htext text="very high accuracy for both shuttles."
        if hsmall!=NULL disable hsmall
        if hcadjust!=NULL disable hcadjust
      else if def==7 then
        change htext text="Two-board MCM calibration assures "
        add htext text="very high accuracy for both shuttles."
        if hsmall!=NULL disable hsmall
        if hcadjust!=NULL disable hcadjust
      else
        change htext text="Quick head correction is extremely quick and "
        add htext text="requires no calibration board, but accuracy "
        add htext text="may be as bad as 50-60 um."
        if hsmall!=NULL disable hsmall
        if hcadjust!=NULL disable hcadjust
      endif
      if testertype==TT_A7 && $LAY.rightlimit-$LAY.leftlimit<=800000 &&        \
        hsmall!=NULL                                                           \
      then
        if def==0 || def==1 then
          change hsmall text="A5L (640x470 mm) FR4 board"
        else if def==2 then
          change hsmall text="A5 (540x420 mm) glass board"
        else
          change hsmall text="A5 glass or A5L FR4 board"
        endif
      endif
      changed=0
    endif
    wait
  enddo
  return def
end

#define NNEEDLE        11              // Number of different needle types
#define NEEDLEX        280             // Width of needle image, pixels
#define NEEDLEY        280             // Height of needle image, pixels
#define NEEDLEB        12              // Border between needles

// Asks operator to verify needle type. Returns 0 on success and -1 if operator
// decided to interrupt calibration.
function int Selectneedle()
  // FFFFFFFF III P K N T U X PPP             AAA..., where:
  // +00 FFF - name of the bitmap file
  // +09 III - index, unique number describing type of the needle
  // +13 P   - type of pressure sensor (N-none, D-direct, M-mirror, I-inverted)
  // +15 K   - S for single-pin needles and K for Kelvin
  // +17 N   - B for blades and P for pins
  // +19 T   - basic type (H-hardtouch, A-adapter, S-splinogram, M-micro,
  //           P-hardtouch with sensor)
  // +21 U   - needle subtype, digit equal to HCZ_SUBCMASK in layout
  // +25 PPP - atg part number
  // +41 AAA - name of the needle type
  char data[NNEEDLE,80] = {                                                    \
    "ndhard   001 N S P H     A3A101803       Hard touch",                     \
    "ndhadapt 002 N S P A     A3A101818K2     Hard adapter",                   \
    "ndsplino 003 D S P S 0   A3A101816K2     Standard soft touch",            \
    "ndsplk4  009 D S P S 1   A3A101816K4     K4 soft touch",                  \
    "ndmicmir 004 M S P M     A3S104010K      Micro probe",                    \
    "ndmicro  005 I S P M     A3S104010KS     Micro probe",                    \
    "ndmicro  010 I S P M     A3S104010??     Shielded micro",                 \
    "ndkelmir 006 M K P M     A3A101821K      Kelvin",                         \
    "ndkelvin 007 I K P M     A3A101821KS     Kelvin",                         \
    "ndkblmir 008 M K B M     A3A101823K      LATEST",                         \
    "ndhardps 011 D S P P     A3A101855       Hard with sensor" }
  int i,j,n,type,dms,select,redraw,x,y,buttons,prevbuttons
  int scroll,runscroll,valid
  char s[512]
  handle hband,hname,hsens,hpins,hpart,hok,hcancel
  if testertype!=TT_A1 && testertype!=TT_A2 && testertype!=TT_A2L &&           \
    testertype!=TT_A2H && testertype!=TT_A4 && testertype!=TT_A6 &&            \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
    return 0                           // Needle can't be replaced
  // Temporarily I disable needle check if different needle type on the bottom
  // is specified.
  if ($int4($EXTLAY+460) & HCZ_VALID)!=0                                       \
    return 0
  clear hleft
  hband=control CHILD
    window=hleft
    position=0,0,LEFTX,LEFTY
    help="Select needle"
    limits=NEEDLEX+2*NEEDLEB,NNEEDLE*(NEEDLEX+NEEDLEB)+NEEDLEB
    mode=M_VSCROLL
    size=1024
  endc
  clear hright
  change hinfo limits=0,0
  change hinfo text="Verify needle type"
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Select type of the needles installed on the tester and press "
  draw font=MAINFONT text="OK" font=TIMESFONT text=", or press " font=MAINFONT
  draw text="Cancel" font=TIMESFONT text=" to leave layout unchanged. Note "
  draw text="that preselected type may be invalid if you run this procedure "
  draw text="for the first time."
  draw font=INFOFONT
  draw at 6,130 text="Needle type:"
  hname=control TEXT
    window=hright
    position=30,133,RIGHTX-60,16
    help="Needle type"
    font=MAINFONT
  endc
  draw at 6,166 text="Sensor:"
  hsens=control TEXT
    window=hright
    position=30,169,RIGHTX-60,16
    help="Sensor"
    font=MAINFONT
  endc
  draw at 6,202 text="Pins:"
  hpins=control TEXT
    window=hright
    position=30,205,RIGHTX-60,16
    help="Pins"
    font=MAINFONT
  endc
  draw at 6,238 text="atg part number:"
  hpart=control TEXT
    window=hright
    position=30,241,RIGHTX-60,16
    help="Part number"
    font=MAINFONT
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="OK"
    help="Press to confirm your selection"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Cancel"
    help="Press to leave layout unchanged"
  endc
  draw show
  // Get needle type.
  select=-1
  // Check whether precise type is declared in layout.
  if $uint2($EXTLAY+636)>0 then
    for i=0,i<NNEEDLE,i++ do
      j=(data[i][9]-'0')*100+(data[i][10]-'0')*10+(data[i][11]-'0')
      if j==$uint2($EXTLAY+636) then
        select=i; break
      endif
    enddo
  endif
  // If not, try to locate type in the table using features from layout.
  if select<0 && ($EXTLAY.zheadtype & HCZ_VALID)!=0 then
    type=$EXTLAY.zheadtype & HCZ_CONTMASK
    dms=$EXTLAY.zheadtype & HCZ_DMSMASK
    for i=0,i<NNEEDLE,i++ do
      if (type==HCZ_CONTSTD || type==HCZ_CONTDEF) && data[i][19]!='H' continue
      if type==HCZ_CONTEMU && data[i][19]!='A' continue
      if (type==HCZ_CONTSPL || type==HCZ_CONTHSPL) && data[i][19]!='S' continue
      if type==HCZ_CONTSKP && data[i][19]!='M' continue
      if type==HCZ_CONTHPS && data[i][19]!='P' continue
      if Isdigit(data[i,21]) && (($EXTLAY.zheadtype>>16) & 0x3)!=data[i,21]-'0'\
        continue
      if ($LAY.probetype & 1)==0 && data[i][15]!='S' continue
      if ($LAY.probetype & 1)!=0 && data[i][15]!='K' continue
      if data[i][13]=='N' && dms==HCZ_DMSSTD break
      if data[i][13]=='D' && dms==HCZ_DMSSTD break
      if data[i][13]=='D' && dms==HCZ_DMSAUTO then select=i; continue; endif
      if data[i][13]=='M' && dms==HCZ_DMSSTD break
      if data[i][13]=='M' && dms==HCZ_DMSAUTO then select=i; continue; endif
      if data[i][13]=='I' && dms==HCZ_DMSREV break
      if data[i][13]=='I' && dms==HCZ_DMSAUTO then select=i; continue; endif
    enddo
    if i<NNEEDLE select=i
  endif
  if select<0 select=0
  redraw=1
  prevbuttons=0
  scroll=select*(NEEDLEY+NEEDLEB)-(LEFTY-NEEDLEY)/2+NEEDLEB
  change hband offset=0,scroll
  runscroll=1
  while 1 do
    if Mousexy(hband,&x,&y,&buttons)==1 then
      y=y+Limit3(hband)
      if x>=NEEDLEB && x<NEEDLEX+NEEDLEB then
        i=(y-NEEDLEB)/(NEEDLEY+NEEDLEB)
        if y>=i*NEEDLEY+(i+1)*NEEDLEB && y<(i+1)*(NEEDLEY+NEEDLEB) then
          if (buttons & 1)!=0 && (prevbuttons & 1)==0 && i!=select then
            select=i
            scroll=select*(NEEDLEY+NEEDLEB)-(LEFTY-NEEDLEY)/2+NEEDLEB
            runscroll=1
            redraw=1
          endif
        endif
      endif
      prevbuttons=buttons
    endif
    if scroll<0 then
      scroll=0
    else if scroll>NNEEDLE*(NEEDLEX+NEEDLEB)+NEEDLEB-LEFTY then
      scroll=NNEEDLE*(NEEDLEX+NEEDLEB)+NEEDLEB-LEFTY
    endif
    j=scroll-Limit3(hband)
    if j==0 then
      runscroll=0
    else if runscroll!=0 && (buttons & 1)==0 then
      j=Max(-10,Min(j,10))
      change hband offset=0,Limit3(hband)+j
    endif
    if redraw then
      draw window=hband bkcolor=WHITE clear
      for i=0,i<NNEEDLE,i++ do
        for j=0,j<8 && data[i][j]!=' ',j++ do
          s[j]=data[i][j]
        enddo
        s[j]='\0'
        if i==select then
          draw color=LIGHTRED bkcolor=LIGHTRED
          draw at NEEDLEB-6,i*NEEDLEY+(i+1)*NEEDLEB-6
          draw fillrect=NEEDLEX+NEEDLEB+6,(i+1)*(NEEDLEY+NEEDLEB)+6
        endif
        draw at NEEDLEB,i*NEEDLEY+(i+1)*NEEDLEB
        draw bitmap=0,0,0,s
        change hname text=data[select]+41
        if data[select][13]=='N' then
          change hsens text="None"
        else if data[select][13]=='D' then
          change hsens text="Transmissive (direct)"
        else if data[select][13]=='M' then
          change hsens text="Reflective (mirror)"
        else if data[select][13]=='I' then
          change hsens text="Transmissive (inverse)"
        else
          change hsens text="Unknown"
        endif
        if data[select][15]=='K' && data[select][17]=='B' then
          change hpins text="Kelvin blades"
        else if data[select][15]=='K' && data[select][17]=='P' then
          change hpins text="Kelvin needles"
        else if data[select][15]=='S' && data[select][17]=='B' then
          change hpins text="Single blade"
        else if data[select][15]=='S' && data[select][17]=='P' then
          change hpins text="Single needle"
        else
          change hpins text="Unknown"
        endif
        change hpart text=format("%.15s",data[select]+25)
      enddo
      draw show
      redraw=0
    endif
    if Pressed(hok) then
      // Update layout.
      j=(data[select,9]-'0')*100+(data[select,10]-'0')*10+(data[select,11]-'0')
      $uint2($EXTLAY+636)=j
      if ($LAY.config & LC_AUTOPROBE)==0 then
        if data[select][15]=='K' then
          $LAY.probetype=1
        else
          $LAY.probetype=0
        endif
      endif
      if data[select,21]>='0' && data[select,21]<='3' then
        $EXTLAY.zheadtype=($EXTLAY.zheadtype & (~HCZ_SUBCMASK)) |              \
        ((data[select,21]-'0')<<16)
      endif
      type=$EXTLAY.zheadtype & (~HCZ_CONTMASK)
      if data[select][19]=='H' then
        $EXTLAY.zheadtype=type|HCZ_CONTSTD
      else if data[select][19]=='A' then
        $EXTLAY.zheadtype=type|HCZ_CONTEMU
      else if data[select][19]=='S' then
        $EXTLAY.zheadtype=type|HCZ_CONTSPL
      else if data[select][19]=='M' then
        $EXTLAY.zheadtype=type|HCZ_CONTSKP
      else if data[select][19]=='P' then
        $EXTLAY.zheadtype=type|HCZ_CONTHPS
      endif
      if ($EXTLAY.zheadtype & HCZ_DMSMASK)!=HCZ_DMSAUTO then
        dms=$EXTLAY.zheadtype & (~HCZ_DMSMASK)
        if data[select][13]=='N' || data[select][13]=='D' then
          $EXTLAY.zheadtype=dms|HCZ_DMSSTD
        else if data[select][13]=='M' then
          $EXTLAY.zheadtype=dms|HCZ_DMSSTD
        else if data[select][13]=='I' then
          $EXTLAY.zheadtype=dms|HCZ_DMSREV
        endif
      endif
      return 0
    else if Pressed(hcancel) then
      // Check whether needle type is compatible with other layout settings.
      // If not, zero type.
      if $uint2($EXTLAY+636)!=0 then
        for i=0,i<NNEEDLE,i++ do
          j=(data[i][9]-'0')*100+(data[i][10]-'0')*10+(data[i][11]-'0')
          if j==$uint2($EXTLAY+636) break
        enddo
        if i>=NNEEDLE then
          valid=0
        else
          valid=1
          if ($LAY.config & LC_AUTOPROBE)!=0 then
            if data[i][15]=='S' && $LAY.probetype!=0 valid=0
            if data[i][15]=='K' && $LAY.probetype!=1 valid=0
          endif
          type=$EXTLAY.zheadtype & HCZ_CONTMASK
          if data[i][19]=='H' && type!=HCZ_CONTSTD valid=0
          if data[i][19]=='A' && type!=HCZ_CONTEMU valid=0
          if data[i][19]=='S' && type!=HCZ_CONTSPL valid=0
          if data[i][19]=='M' && type!=HCZ_CONTSKP valid=0
          if ($EXTLAY.zheadtype & HCZ_DMSMASK)!=HCZ_DMSAUTO then
            dms=$EXTLAY.zheadtype & HCZ_DMSMASK
            if data[i][13]=='N' && dms!=HCZ_DMSSTD valid=0
            if data[i][13]=='D' && dms!=HCZ_DMSSTD valid=0
            if data[i][13]=='M' && dms!=HCZ_DMSSTD valid=0
            if data[i][13]=='I' && dms!=HCZ_DMSREV valid=0
          endif
        endif
        if valid==0 $uint2($EXTLAY+636)=0
      endif
      return 0
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Calculates shift of calibration board in X direction (center of board minus
// center of layout).
function int Calculateboardshift(int shuttle)
  float step
  if testertype==TT_A7 && $LAY.nfing==10 then
    // Shuttle of A7/20 is left-aligned.
    boardshift=-50.0
  else if testertype==TT_A7 && ($LAY.config & LC_LDMASK)==LC_LMAUTO &&         \
    boardtype==1 && smallboard==0 then
    // A7 glass board (500 mm wide) in A7 automatic shuttle.
    boardshift=-75.0
  else if testertype==TT_A7 && ($LAY.config & LC_LDMASK)==LC_LMAUTO &&         \
    boardtype==1 && smallboard!=0 then
    // A5 glass board (500 mm wide) in A7 automatic shuttle.
    boardshift=-50.0
  else if testertype==TT_A8 && (($LAY.config & LC_LDMASK)==LC_LMAUTO ||        \
    ($LAY.config & LC_LDMASK)==LC_LMS2AUTO) && boardtype==2 then
    // S2 board (300 mm wide) in A8 automatic shuttle.
    boardshift=$LAY.xoffset/1000.0
    if xstep==0.0 then
      step=25.0                        // Default for all current testers
    else
      step=xstep
    endif
    while boardshift-step>=$LAY.leftlimit/1000.0 do
      boardshift=boardshift-step
    enddo
    boardshift=boardshift+150.0-$LAY.xoffset/1000.0
  else if testertype==TT_A8 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO &&      \
    boardtype==2 then
    // S2 board (300 mm wide) in A8 split shuttle.
    if twostep==2 then
      if shuttle==0 then
        boardshift=-165.0
      else
        boardshift=165.0
      endif
    else
      if shuttle==0 then
        boardshift=-150.0
      else
        boardshift=150.0
      endif
    endif
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    // S3 board (200 mm wide) in S3 split shuttle.
    if shuttle==0 then
      boardshift=-125.0
    else
      boardshift=125.0
    endif
  else
    boardshift=0.0
  endif
end

// Sets calibration parameters to one of the predefined models. If radii
// specified in layout differ from expected, warns operator. Returns 0 on
// success and -1 if operator decided to interrupt calibration.
function int Presetparm(int caltype)
  int i,j,y,stranger,strangehr
  float x0,dy,f,lr,lhr,oldwidth
  char s[256]
  handle htable,hcont,hcorrect
  if caltype==5 return
  if testertype!=TT_A1 && testertype!=TT_A2 && testertype!=TT_A2L &&           \
    testertype!=TT_A2H && testertype!=TT_A4 && testertype!=TT_A6 &&            \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_A8 then
    if caltype==3 || ((caltype==6 || caltype==7) & testertype!=TT_S3) then
      caltype=2                        // Special glass exists for A2 only!
    endif
  endif
  if caltype!=4 || v==0 || p==0 || z==0.0 then
    if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
      v=20; p=10; z=4.0                // Default for hard touch needles
    else if caltype==2 || caltype==3 || caltype==6 || caltype==7 then
      v=30; p=20; z=3.0                // Default for glass board
    else if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
      v=40; p=50; z=3.0                // Default for FR4 on S1/S2
    else
      v=30; p=40; z=4.0                // Default for FR4 board
    endif
    if softtouch && p<50 &&                                                    \
      (($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP ||                      \
      (testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3))           \
    then
      p=50                             // Minimal allowed for splinogramms
    endif
  endif
  zscan=z
  // Check if every head camera has its counterpart on the opposite side, so
  // shinethrough calibration is possible.
  for i=0,i<$LAY.nfing*2,i++ do
    if $LAY.cameras!=0 break
    if ($LAY.headcameras & (1<<i))==0 continue
    if ($LAY.excludedrails & (1<<(i/2)))!=0 continue
    for j=0,j<$LAY.nfing*2,j++ do      // Try to find counterpart
      if $LAY.side[j/2]==$LAY.side[i/2] continue
      if ($LAY.headcameras & (1<<j))==0 continue
      if ($LAY.excludedrails & (1<<(j/2)))!=0 continue
      if $LAY.bottom[j/2]!=$LAY.bottom[i/2] continue
      if $LAY.top[j/2]!=$LAY.top[i/2] continue
      break                            // Counterpart found
    enddo
    if j>=$LAY.nfing*2 break
  enddo
  if i>=$LAY.nfing*2 && ($LAY.config & LC_VACUUMBOX)==0 then
    symmetricheadcams=1
  else
    symmetricheadcams=0
  endif
  if caltype!=4 || (firsttop<0 && firstbot<0) then
    cameras=$LAY.cameras
    if ($LAY.config & LC_VACUUMBOX)!=0 cameras=cameras & 0x01
    if ($LAY.excludedrails & 0x4000)!=0 cameras=cameras & 0x02
    if ($LAY.excludedrails & 0x8000)!=0 cameras=cameras & 0x01
    headcams=0
    if $LAY.cameras==0 then
      for i=0,i<$LAY.nfing*2,i++ do
        if ($LAY.headcameras & (1<<i))==0 continue
        if ($LAY.config & LC_VACUUMBOX)!=0 && $LAY.side[i/2]!=0 continue
        if ($LAY.excludedrails & (1<<(i/2)))!=0 continue
        headcams=headcams | (1<<i)
      enddo
    endif
    firsttop=laytopmin
    lasttop=laytopmax
    firstbot=laybotmin
    lastbot=laybotmax
    if videoonly then
      usesides=0
    else
      usesides=testersides
      if ($LAY.config & LC_VACUUMBOX)!=0 usesides=usesides & 0x1
    endif
  endif
  if caltype!=4 || encdist==0.0 then
    if testertype==TT_M2 then
      encdist=20.0
    else if testertype==TT_A3 || testertype==TT_A3L || testertype==TT_A5 then
      encdist=87.5
    else if testertype==TT_A5L then
      if smallboard then encdist=75.0;
      else encdist=100.0; endif
    else if testertype==TT_A7 then
      if smallboard && boardtype==1 then encdist=62.5;
      else if smallboard && boardtype!=1 then encdist=87.5;
      else encdist=105.0; endif
    else
      encdist=70.0
    endif
  endif
  if caltype==0 || (caltype==4 && linewidth==0) then
    boardtype=0                        // FR4 calibration board
    twostep=0
    linewidth=(testertype==TT_S2?0.200:0.300)
    warmuptime=120
    if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
      precisey=PRY_YPROF
    else
      precisey=PRY_3LINE
    endif
  else if caltype==1 then
    boardtype=0                        // FR4 calibration board
    twostep=0
    linewidth=(testertype==TT_S2?0.200:0.300)
    warmuptime=60
    precisey=PRY_STD
  else if caltype==2 then
    boardtype=1; linewidth=0.200;      // Glass calibration board
    twostep=0
    warmuptime=30
    if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
      precisey=PRY_YPROF
    else
      precisey=PRY_3LINE
    endif
  else if caltype==3 || caltype==6 || caltype==7 then
    boardtype=(testertype==TT_S3?1:2)
    linewidth=0.200
    if caltype==6 then
      twostep=1
    else if caltype==7 then
      twostep=2
    else
      twostep=0
    endif
    warmuptime=30
    if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
      precisey=PRY_YPROF
    else
      precisey=PRY_3LINE
    endif
  endif
  // Check if line width is different from standard.
  oldwidth=linewidth
  sprintf(s,"Line width[%i]",boardtype)
  getini("Calibration",s,"%f",&linewidth)
  if linewidth<0.100 || linewidth>0.400 then
    linewidth=oldwidth
  endif
  if caltype!=4 || throwaway==0 then
    if caltype==0 then
      throwaway=(smallboard?1:2)
    else if caltype==1 then
      throwaway=($LAY.rightlimit-$LAY.leftlimit>=450000 && smallboard==0?3:2)
    else if caltype==2 && (testertype==TT_S1 || testertype==TT_S2) &&          \
      $LAY.rightlimit-$LAY.leftlimit>=450000 && smallboard==0 then
      throwaway=2
    else
      throwaway=1
    endif
  endif
  Calculateboardshift(0)
  if caltype!=4 || (fromx==0.0 && tox==0.0) then
    x0=$LAY.xoffset/1000.0+boardshift
    f=Min(x0-$LAY.leftlimit/1000.0,$LAY.rightlimit/1000.0-x0)
    if testertype==TT_A3 then
      f=Min(f,225.0)                   // A3 calibration board: 450 mm
    else if testertype==TT_A3L || testertype==TT_A5 then
      f=Min(f,260.0)                   // A3L/A5 calibration board: 520 mm
    else if testertype==TT_A5L then
      if smallboard then
        f=Min(f,260.0)                 // A5 calibration board in A5L tester
      else
        f=Min(f,300.0)                 // Large A5L calibration board: 300 mm
      endif
    else if testertype==TT_M2 then
      f=Min(f,150.0)                   // M2 calibration board: 300 mm
    else if testertype==TT_S2 then
      if smallboard then
        f=Min(f,150.0)                 // Narrow S2 calibration board: 300 mm
      else if $LAY.rightlimit-$LAY.leftlimit>=600000 then
        f=Min(f,300.0)                 // A1/A2 calibration board: 600 mm
      else
        f=Min(f,150.0)                 // Narrow S2 calibration board: 300 mm
      endif
    else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      f=Min(f,100.0)                   // S3 split calibration board: 200 mm
    else if testertype==TT_A7 then
      if largeboard && $LAY.rightlimit-$LAY.leftlimit>800000 then
        f=Min(f,425.0)
      else if smallboard && boardtype==1 then
        f=Min(f,250.0)                 // A5 glass calibration board: 500 mm
      else if smallboard && boardtype!=1 then
        f=Min(f,300.0)                 // Large A5L calibration board: 600 mm
      else if smallboard==0 && ($LAY.nfing==8 || $LAY.nfing==10) then
        f=Min(f,275.0);                // A7XXL FR4 board
      else if smallboard==0 && boardtype==1 then
        f=Min(f,225.0);                // A7 glass board, slightly reduced
      else
        f=Min(f,300.0)                 // Native A7 calibration board: same
      endif
    else if boardtype==2 then
      f=Min(f,150.0)                   // A1/A2 MCM glass board: 300 mm
    else
      f=Min(f,300.0)                   // A1/A2 calibration board: 600 mm
    endif
    fromx=x0-f
    tox=x0+f
    if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO &&         \
      twostep!=0                                                               \
    then
      tox=tox+250                      // S3 split shuttle calibration
    else if boardtype==2 && twostep==1 then
      tox=tox+300.0                    // Two-step calibration
    else if boardtype==2 && twostep==2 then
      tox=tox+330.0                    // Two-board calibration
    endif
  endif
  if caltype!=4 extralen=0.0
  videofromx=Max(fromx,($LAY.leftlimit+$LAY.videodeadx)/1000.0)
  if testertype==TT_A3 || testertype==TT_A3L || testertype==TT_A4 ||           \
    testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||            \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8                                     \
  then
    videotox=tox
  else
    videotox=Min(tox,($LAY.rightlimit-$LAY.videodeadx)/1000.0)
  endif
  if testertype==TT_A5L && smallboard!=0 then
    videofromy=Max($LAY.bottom[$LAY.nfing]/1000.0,                             \
      $LAY.bottom[smallfirst]/1000.0+25.0)
    videotoy=Min($LAY.top[$LAY.nfing]/1000.0,$LAY.top[smalllast]/1000.0-25.0)
  else if testertype==TT_A7 && smallboard!=0 && boardtype!=1 then
    videofromy=Max($LAY.bottom[$LAY.nfing]/1000.0,                             \
      $LAY.bottom[smallfirst]/1000.0+25.0)
    videotoy=Min($LAY.top[$LAY.nfing]/1000.0,$LAY.top[smalllast]/1000.0-25.0)
  else if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
    videofromy=Max($LAY.bottom[$LAY.nfing]/1000.0,                             \
      $LAY.bottom[smallfirst]/1000.0+55.0)
    videotoy=Min($LAY.top[$LAY.nfing]/1000.0,$LAY.top[smalllast]/1000.0-55.0)
  else
    videofromy=$LAY.bottom[$LAY.nfing]/1000.0
    videotoy=$LAY.top[$LAY.nfing]/1000.0
  endif
  if testertype==TT_A3 || testertype==TT_A3L ||                                \
    testertype==TT_A5 || testertype==TT_A5L then
    videolength=360.0
  else if testertype==TT_A4 || testertype==TT_A6 || testertype==TT_S1 then
    videolength=440.0
  else if testertype==TT_S2 || testertype==TT_S3 then
    videolength=150.0
  else if testertype==TT_A7 then
    videolength=400.0
  else if testertype==TT_A8 then
    videolength=440.0
  else if testertype==TT_M2 then
    videolength=250.0
  else
    videolength=800.0
  endif
  if interlace<0 interlace=0
  if caltype!=4 && (testertype==TT_S1 || testertype==TT_S2 ||                  \
    testertype==TT_S3 || testertype==TT_A7 || testertype==TT_A8) then
    softland=1
  else
    softland=0
  endif
  if caltype==0 || caltype==1 then
    singleref=0
    kelvinscan=0
    interlace=0
    if testertype==TT_S2 && symmetricheadcams!=0 && usesides==0x3 then
      illumination=1                   // Shinethrough illumination
    else
      illumination=0                   // Direct illumination
    endif
  else if caltype!=4 then
    singleref=0
    kelvinscan=0
    if testertype!=TT_S3 &&                                                    \
      ($LAY.cameras==0x3 || (symmetricheadcams!=0 && usesides==0x3)) then
      illumination=1                   // Shinethrough illumination
    else
      illumination=0                   // Direct iullumination, no choice
    endif
  endif
  if caltype==0 || caltype==1 then
    oppdx=0.0
    oppdy=0.0
  else if $LAY.cameras!=0 || $LAY.headcameras==0 then
    oppdx=12.0
    oppdy=0.0
  else if testertype==TT_A7 || testertype==TT_A8 then
    oppdx=-2.0
    oppdy=15.0
  else
    oppdx=4.5
    oppdy=13.5
  endif
  autoverify=0
  if caltype==0 then
    cameramode=1
    measureoffset=1
    if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
      accuracy=0.010
    else
      accuracy=0.015
    endif
  else if caltype==1 then
    cameramode=2; accuracy=0.020
    measureoffset=1
  else if caltype==2 then
    if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
      cameramode=0
      accuracy=0.0001
    else
      cameramode=1
      accuracy=0.005
    endif
    measureoffset=0
  else if caltype==3 || caltype==6 || caltype==7 then
    cameramode=0
    measureoffset=0
    if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
      cameramode=0
      accuracy=0.0001
    else
      accuracy=0.010
    endif
  else if caltype==4 then
    if cameramode<0 cameramode=1
    if accuracy<=0 accuracy=0.015
  endif
  if boardtype==0 && testertype!=TT_S1 && testertype!=TT_S2 then
    noclip=0
  else
    noclip=1
  endif
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8                                     \
  then
    if caltype==0 || caltype==2 || caltype==3 || caltype==6 || caltype==7 then
      lowspeed=1
    else
      lowspeed=0
    endif
  else
    lowspeed=0
  endif
  if $LAY.cameras!=0 || $LAY.headcameras==0 then
    videosafedist=50.0                 // Dedicated cameras
  else
    videosafedist=75.0                 // Head cameras
    measureoffset=0
  endif
  maxdelta=4.0                         // Preliminary setting
  if testertype==TT_M2 then
    xstep=15.0; ystep=5.0; videoy=22.5
    radius=65.0; headcamradius=65.0; accuracy=0.005;
    if caltype!=4 then
      boardtype=1; linewidth=0.100;    // No FR4 board for M2 tester
    endif
  else if testertype==TT_A3 || testertype==TT_A3L ||                           \
    testertype==TT_A5 || testertype==TT_A5L then
    xstep=25.0; ystep=12.5; videoy=50.0
    radius=150.0; headcamradius=153.0
  else if testertype==TT_A2H then
    xstep=25.0; ystep=10.0; videoy=38.75
    radius=115.0; headcamradius=118.0
  else if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
    xstep=25.0; ystep=10.0;
    // Y step of video calibration data in S3 depends on the dimensions of the
    // working area.
    if $LAY.cameras==0 then
      videoy=77.5                      // Pro forma setting
    else
      dy=Max(Abs($LAY.top[$LAY.nfing]-$LAY.yoffset[$LAY.nfing])+2000*MAXCORRY, \
        Abs($LAY.yoffset[$LAY.nfing]-$LAY.bottom[$LAY.nfing])+2000*MAXCORRY)/  \
        1000.0/CENTERY
      if dy<=19.375 then
        videoy=19.375
      else if dy<=38.75 then
        videoy=38.75
      else
        videoy=77.5
      endif
    endif
    radius=115.0
    s[0]='\0'; getini("System","CameraType",s)
    if s[0]=='\0' getini("System","CameraType[0]",s)
    if Memicmp(s,"Fire90",6)==0 then
      headcamradius=116.0
    else
      headcamradius=118.0
    endif
  else if testertype==TT_A7 then
    xstep=25.0; ystep=17.5; videoy=100.0
    radius=180.0; headcamradius=183.0
  else
    xstep=25.0; ystep=10.0; videoy=77.5
    radius=115.0; headcamradius=118.0
  endif
  videofactor[0]=1.0
  videofactor[1]=1.0
  // Check that radius and headcamradius specified in layout are the same as
  // defaults.
  lr=$EXTLAY.radius/1000.0
  lhr=$EXTLAY.headcamradius/1000.0
  if warnradius==0 then                // Already asked, don't ask again
    if lr!=0.0 radius=lr
    if lhr!=0.0 headcamradius=lhr
    return 0
  endif
  warnradius=0
  if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
    stranger=(lr!=0.0 && lr!=radius && lr!=116.0)
  else
    stranger=(lr!=0.0 && lr!=radius)
  endif
  // The very first machine was shipped with 117 mm camera radius in layout.
  if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
    strangehr=(lhr!=0.0 && lhr!=headcamradius && lhr!=116.0 && lhr!=117.0)
  else
    strangehr=(lhr!=0.0 && lhr!=headcamradius && lhr!=117.0)
  endif
  if $LAY.cameras!=0 || $LAY.headcameras==0 strangehr=0
  if stranger==0 && strangehr==0 return 0
  if hlog!=NULL then
    fprintf(hlog,"Non-standard radius in layout\n")
    fprintf(hlog,"  Finger:       %7.3f, expected %7.3f\n",lr,radius)
    fprintf(hlog,"  Head camera:  %7.3f, expected %7.3f\n",lhr,headcamradius)
  endif
  change hinfo limits=0,0
  change hinfo text="Non-standard radius"
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=LIGHTRED
  if stranger!=0 && strangehr!=0 then
    draw text="Radii of finger ahd head camera differ from defaults! "
  else if stranger then
    draw text="Finger radius differs from default! "
  else
    draw text="Radius of head camera differs from default! "
  endif
  draw color=BLACK
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 then
    draw text="Embedded software of your tester ignores radii from layout, "
    draw text="but some high-level programs may get confused and produce "
    draw text="invalid data. "
  else
    draw text="Non-standard radii are highly unwanted because they may "
    draw text="confuse some older utilities. "
  endif
  draw text="Please consult the table below and decide what to do."
  draw show
  htable=control CHILD
    window=hright
    position=9,130,RIGHTX-18,157
    help="Finger and head camera radii, millimeters"
    bkcolor=PINK
    size=4096
  endc
  draw window=htable font=INFOFONT color=DARKGRAY
  draw at 5,5 to 241,5
  draw at 30,26 text="Item"
  draw at 102,26 text="Layout"
  draw at 181,26 text="Default"
  draw at 5,32 to 241,32
  draw font=FIXEDSYS
  y=50
  draw at 10,y color=BLACK text="Finger" at 91,y
  if lr==0.0 then
    draw text="---"
  else
    draw color=(stranger?LIGHTRED:BLACK) text=format("%7.3f",lr)
  endif
  draw at 171,y color=BLACK text=format("%7.3f",radius)
  draw at 5,y+2 to 241,y+2
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    y=y+20
    draw at 10,y color=BLACK text="Headcam" at 91,y
    if lhr==0.0 then
      draw text="---"
    else
      draw color=(strangehr?LIGHTRED:BLACK) text=format("%7.3f",lhr)
    endif
    draw at 171,y color=BLACK text=format("%7.3f",headcamradius)
    draw at 5,y+2 to 241,y+2
  endif
  draw at 5,5 to 5,y+2
  draw at 81,5 to 81,y+2
  draw at 161,5 to 161,y+2
  draw at 241,5 to 241,y+2
  change htable position=9,130,RIGHTX-18,y+7
  draw show
  hcorrect=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Correct"
    help="Press to quit calibration and correct layout"
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Continue"
    help="Press to continue calibration with radius from layout"
  endc
  while 1 do
    if Pressed(hcont) then
      if hlog!=NULL then
        fprintf(hlog,"  Operator decided to continue calibration\n")
      endif
      radius=lr; headcamradius=lhr
      return 0
    else if Pressed(hcorrect) then
      startlayout=1
      return -1
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Allows operator to set custom calibration parameters - lots of parameters!
function int Customparm()
  int i,j,n,redraw,exit,excludedrails,vpstep,hasmcm,ok
  float f,fright,step
  char s[128],w[1024]
  handle hboard,hwidth,hwscroll,haccuracy,haccscr
  handle hsides,hfrom,hto,hpoints,hencdist,hencchange
  handle hfromx,hfromxscr,htox,htoxscr
  handle hvelo,hvscr,hpres,hpscr,hzcoo,hzscr
  handle hymode,hinterlace,hsingleref,hsoftland
  handle hkelvin,hverify
  handle hcameras,hcameramode,hnoclip,hilluminate,hoppdist,hoppchange
  handle hoffset,hlowspeed,hconfirm,hpreset,hpresettype
  handle hwarn,hok,hcancel
  if calmode==MODE_CADJ return
  clear hleft
  change hleft help=" "
  clear hright
  change hinfo limits=0,0
  change hinfo text=(calmode==MODE_VER?                                        \
    "Custom verification":"Custom calibration")
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Please make your choice, then press " font=MAINFONT text="OK "
  draw font=TIMESFONT text="to accept custom settings or " font=MAINFONT
  draw text="Cancel " font=TIMESFONT text="to select non-custom "
  draw text=(calmode==MODE_VER?"verification.":"calibration.")
  draw show
  draw window=hleft font=INFOFONT wrap=0
  draw color=LIGHTGRAY bkcolor=LIGHTYELLOW
  draw at -1,-1 fillrect LEFTX+1,68
  draw at -1,209 fillrect LEFTX+1,273
  // Load custom parameters from .ini file.
  operator=1                           // Defaults
  autoconfirm=1
  getini("Calibration","Board","%i,%f,%f,%i",                                  \
    &boardtype,&linewidth,&accuracy,&twostep)
  if ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO twostep=0
  getini("Calibration","Stroke","%i,%i,%f",&v,&p,&z)
  getini("Calibration","Area","%i,%i,%f,%f,%i,%i,%i",                          \
    &firsttop,&lasttop,&fromx,&tox,&usesides,&firstbot,&lastbot)
  getini("Calibration","Parms","%i,%i,%i,%i",                                  \
    &throwaway,&autoverify,&measureoffset,&lowspeed)
  precisey=(testertype==TT_S3?PRY_YPROF:PRY_3LINE)
  getini("Calibration","Extras","%i,%f,%i",&operator,&extralen,&precisey)
  if precisey!=PRY_STD &&                                                      \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 then
    precisey=PRY_3LINE
  endif
  extralen=0.0                         // Currently turned off
  getini("Calibration","Heads","%f,%i,%i,%i,%i",                               \
    &encdist,&singleref,&interlace,&softland,&kelvinscan)
  getini("Calibration","Video","%i,%i,%f,%i",                                  \
    &cameramode,&illumination,&oppdx,&noclip)
  Calculateboardshift(0)
  // Controls to select the parameters of the calibration board.
  draw color=BLACK at 6,30 text="Board:"
  hboard=control COMBOLIST
    window=hleft
    position=46,10,128,150
    help="Select type of calibration board (FR4 or glass)"
    mode=M_VSCROLL
  endc
  if testertype==TT_A5L && smallboard==0 then
    add hboard text="FR4 large"
  else if testertype==TT_A5L && smallboard!=0 then
    add hboard text="FR4 small"
  else if testertype==TT_S2 && smallboard!=0 then
    add hboard text="FR4 small"
  else if testertype==TT_A7 && smallboard!=0 then
    add hboard text="FR4 (A5L)"
  else
    add hboard text="FR4"
  endif
  if testertype==TT_A7 && $LAY.rightlimit-$LAY.leftlimit>800000 then
    add hboard text="FR4 XXW"
  endif
  if testertype==TT_A5L && smallboard==0 then
    add hboard text="Glass large"
  else if testertype==TT_A5L && smallboard!=0 then
    add hboard text="Glass small"
  else if testertype==TT_A7 && smallboard!=0 then
    add hboard text="Glass (A5)"
  else
    add hboard text="Glass"
  endif
  if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||           \
    testertype==TT_A2H || testertype==TT_A4 || testertype==TT_A6 ||            \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_A8 then
    add hboard text="MCM glass"
    hasmcm=1
  else
    hasmcm=0
  endif
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    add hboard text="Two-step MCM"
    add hboard text="Two-board MCM"
    if testertype==TT_S3 then
      add hboard text="Two-step FR4"
      add hboard text="Two-board FR4"
    endif
  endif
  draw at 177,30 text=", line"
  hwidth=control EDIT
    window=hleft
    position=210,10,58,24
    help="Specify the width of the lines on the board, millimeters"
  endc
  hwscroll=control VSCROLL
    window=hleft
    position=268,10,20,24
    help="Press to adjust the width of the lines on the calibration board"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 290,30 text="mm"
  draw at 6,59 text="Relative accuracy of the board is"
  haccuracy=control EDIT
    window=hleft
    position=210,39,58,24
    help="Specify how accurate the board is, mm, disregarding shrinkage"
  endc
  haccscr=control VSCROLL
    window=hleft
    position=268,39,20,24
    help="Press to set the accuracy of the calibration board"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 290,59 text="mm"
  // Controls to select the rails participating in the calibration.
  draw at 6,95 text=(calmode==MODE_VER?"Verify":"Calibrate")
  hsides=control COMBOLIST
    window=hleft
    position=61,75,68,90
    help="Select side(s) to calibrate"
    mode=M_VSCROLL
  endc
  if ($LAY.config & LC_VACUUMBOX)==0                                           \
    add hsides text="All"
  if (testersides & 0x01)!=0                                                   \
    add hsides text="Top"
  if ($LAY.config & LC_VACUUMBOX)==0 && (testersides & 0x02)!=0                \
    add hsides text="Bottom"
  add hsides text="No"
  draw at 131,95 text="rails from"
  hfrom=control COMBOLIST
    window=hleft
    position=188,75,55,90
    mode=M_VSCROLL
  endc
  draw at 245,95 text="to"
  hto=control COMBOLIST
    window=hleft
    position=259,75,55,90
    mode=M_VSCROLL
  endc
  if testersides==0x03 then
    n=Max(topmax-topmin+1,botmax-botmin+1)
    for i=0,i<n,i++
      if i>topmax-topmin then
        add hfrom text=format(" %i (%i)",topmax,botmin+i)
        add hto text=format(" %i (%i)",topmax,botmin+i)
      else if i>botmax-botmin then
        add hfrom text=format(" %i (%i)",topmin+i,botmax)
        add hto text=format(" %i (%i)",topmin+i,botmax)
      else
        add hfrom text=format(" %i (%i)",topmin+i,botmin+i)
        add hto text=format(" %i (%i)",topmin+i,botmin+i)
      endif
    enddo
    change hfrom help="Start calibration from top (bottom) rail"
    change hto help="Last top (bottom) rail included into calibration"
  else
    for i=0,i<$LAY.nfing,i++
      add hfrom text=format("  %i",i)
      add hto text=format("  %i",i)
    enddo
    change hfrom help="Start calibration from rail"
    change hto help="Last rail included into calibration"
  endif
  // Controls to select the stroke.
  draw at 6,124 text="Stroke: V="
  hvelo=control EDIT
    window=hleft
    position=74,104,35,24
    help="Specify Z down speed, millimeters per second"
  endc
  hvscr=control VSCROLL
    window=hleft
    position=109,104,20,24
    help="Press to change speed"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 134,124 text="P="
  hpres=control EDIT
    window=hleft
    position=154,104,35,24
    help=softtouch?"Specify Z pressure, arb.units":"Specify Z pressure, gram"
  endc
  hpscr=control VSCROLL
    window=hleft
    position=189,104,20,24
    help="Press to change pressure"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 215,124 text="Hmin="
  hzcoo=control EDIT
    window=hleft
    position=256,104,38,24
    help="Specify minimal allowed Z up distance, millimeters"
  endc
  hzscr=control VSCROLL
    window=hleft
    position=294,104,20,24
    help="Press to change minimal Z up distance"
    limits=1,-1
    mode=M_NOTAB
  endc
  // Controls to select how to calibrate fingers.
  draw at 6,153 text="Scan"
  hpoints=control COMBOLIST
    window=hleft
    position=40,133,107,106
    help="Specify how many points in X direction to scan"
    mode=M_VSCROLL
  endc
  add hpoints text="Every"
  add hpoints text="Each second"
  add hpoints text="Each third"
  add hpoints text="Each fourth"
  add hpoints text="Each fifth"
  draw at 152,153 text="point at dY="
  hencdist=control EDIT
    window=hleft
    position=227,133,41,24
    help="Specify distance from center to crosses used for calibration, mm"
  endc
  hencchange=control VSCROLL
    window=hleft
    position=267,133,20,24
    help="Press to change the lines used for calibration"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 290,153 text="mm"
  draw at 6,181 text="Mode:"
  hymode=control COMBOLIST
    window=hleft
    position=45,161,80,100
    help="Calibration mode, strongly influences accuracy"
    mode=M_VSCROLL
  endc
  add hymode text="2 rows"
  add hymode text="3 rows"
  if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
    add hymode text="Y profile"
  endif
  draw at 132,181 text="Reference:"
  hkelvin=control COMBOLIST
    window=hleft
    position=199,161,115,120
    help="Select type of reference contact"
    mode=M_VSCROLL
  endc
  if $LAY.probetype==0 then
    add hkelvin text="Standard"
    add hkelvin text="Ext antenna"
    if (measfeatures & MF_DSCAN)!=0 &&                                         \
      (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||         \
      testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||           \
      testertype==TT_A7 || testertype==TT_A8) then
      add hkelvin text="Ref on line"
    endif
  else
    if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&        \
      testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&           \
      testertype!=TT_A7 && testertype!=TT_A8) ||                               \
      $LAY.probetype!=1 || (measfeatures & MF_KELVSCAN)==0                     \
    then
      if $LAY.probetype!=1 then
        add hkelvin text="No Kelvin"
      else
        add hkelvin text="Standard"
      endif
      disable hkelvin
      kelvinscan=0
    else
      add hkelvin text="Standard"
      add hkelvin text="Single probe"
      add hkelvin text="Ref on line"
      add hkelvin text="Ext antenna"
    endif
  endif
  hinterlace=control CUSTOMBOX
    window=hleft
    position=6,185,80,22
    name="Interlaced"
    help="Check to scan first odd, then even crosses on the calibration board"
    font=INFOFONT
  endc
  hsingleref=control CUSTOMBOX
    window=hleft
    position=96,185,122,22
    name="Single reference"
    help="Check to use only one reference finger per side"
    font=INFOFONT
  endc
  hsoftland=control CUSTOMBOX
    window=hleft
    position=224,185,91,22
    name="Soft landing"
    help="Check to activate soft landing during the calibration"
    font=INFOFONT
  endc
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP) then
    disable hsoftland                  // Tester does not support soft landing
    softland=0
  endif
  // Controls to select how to calibrate video cameras.
  if $LAY.cameras!=0 || $LAY.headcameras==0 then
    draw at 6,235 text=(calmode==MODE_VER?"Verify":"Calibrate")
    hcameras=control COMBOLIST
      window=hleft
      position=61,215,68,90
      help="Select which video cameras to calibrate"
      mode=M_VSCROLL
    endc
    add hcameras text="No"
    if ($LAY.cameras & 0x01)!=0 && ($LAY.excludedrails & 0x4000)==0            \
      add hcameras text="Top"
    if ($LAY.config & LC_VACUUMBOX)==0 && ($LAY.cameras & 0x02)!=0 &&          \
      ($LAY.excludedrails & 0x8000)==0                                         \
      add hcameras text="Bottom"
    if ($LAY.cameras & 0x03)==0x03 && ($LAY.excludedrails & 0xC000)==0         \
      add hcameras text="Both"
    if $LAY.cameras==0 then
      change hcameras select=0
      disable hcameras
    endif
    draw at 131,235 text="cameras in"
    hcameramode=control COMBOLIST
      window=hleft
      position=199,215,80,74
      help="Set the requested accuracy of camera calibration"
      mode=M_VSCROLL
    endc
    draw at 281,235 text="mode"
    hnoclip=NULL
  else
    draw at 6,235 text="Head cameras:"
    hcameras=NULL
    hcameramode=control COMBOLIST
      window=hleft
      position=98,215,85,74
      help="Set the requested accuracy of head camera calibration"
      mode=M_VSCROLL
    endc
    draw at 190,235 text="mode,"
    hnoclip=control CUSTOMBOX
      window=hleft
      position=229,215,83,22
      text="no clipping"
      help="Do not clip needles from the image when searching fiducials"
      font=INFOFONT
    endc
  endif
  add hcameramode text="Precise"
  add hcameramode text="Standard"
  add hcameramode text="Quick"
  draw at 6,263 text="Light from"
  hilluminate=control COMBOLIST
    window=hleft
    position=78,243,85,58
    help="Select how to illuminate the fiducials"
    mode=M_VSCROLL
  endc
  add hilluminate text="Same"
  if ($LAY.cameras==0x3 || (symmetricheadcams!=0 && usesides==0x3)) &&         \
    ($LAY.config & LC_VACUUMBOX)==0 && testertype!=TT_S3                       \
    add hilluminate text="Opposite"
  draw at 170,263 text="side, dX="
  hoppdist=control EDIT
    window=hleft
    position=229,243,38,24
    help="Specify X distance between cameras in shinethrough calibration"
  endc
  hoppchange=control VSCROLL
    window=hleft
    position=267,243,20,24
    help="Press to change X distance between cameras"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 290,263 text="mm"
  // Controls to limit X range.
  draw at 6,300 text="Limit scan to X from"
  hfromx=control EDIT
    window=hleft
    position=130,280,48,24
    help="Specify start X coordinate, millimeters"
  endc
  hfromxscr=control VSCROLL
    window=hleft
    position=178,280,20,24
    help="Press to change the start X coordinate"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 202,300 text="to"
  htox=control EDIT
    window=hleft
    position=219,280,48,24
    help="Specify final X coordinate, millimeters (including)"
  endc
  htoxscr=control VSCROLL
    window=hleft
    position=267,280,20,24
    help="Press to change the final X coordinate"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 290,300 text="mm"
  // Controls to set some general options.
  hoffset=control CUSTOMBOX
    window=hleft
    position=6,306,60,22
    name="Offset"
    help="Measure and correct offset between top and bottom grids"
    font=INFOFONT
  endc
  hlowspeed=control CUSTOMBOX
    window=hleft
    position=70,306,82,22
    name="Low speed"
    help="Limit X-Y accelerations during the calibration to reduce vibrations"
    font=INFOFONT
  endc
  hconfirm=control CUSTOMBOX
    window=hleft
    position=157,306,96,22
    name="Confirm save"
    help="Ask for confirmation when saving layout or corrections"
    font=INFOFONT
  endc
  hverify=control CUSTOMBOX
    window=hleft
    position=260,306,56,22
    name="Verify"
    help="Check to verify the reproducibility of scanning"
    font=INFOFONT
  endc
  if boardtype!=0 disable hverify
  // Controls to set parameters to one of the standard types.
  hpreset=control BUTTON
    window=hleft
    position=6,336,120,24
    name="Preset to"
    help="Press to preset calibration parameters to the selected type"
    bkcolor=LIGHTGRAY
  endc
  hpresettype=control COMBOLIST
    window=hleft
    position=126,336,188,150
    help="Select one of the predefined types of calibration"
  endc
  add hpresettype text="Accurate with FR4 board"
  add hpresettype text="Fast with FR4 board"
  add hpresettype text="Precise with glass board"
  if testertype!=TT_A7 then
    add hpresettype text="MCM with special glass"
    if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      add hpresettype text="Two-step MCM"
      add hpresettype text="Two-board MCM"
    endif
  endif
  change hpresettype select=0
  draw show
  hwarn=control GRAPH
    window=hright
    position=5,80,RIGHTX-10,150
    help=" "
    color=WHITE
    bkcolor=WHITE
    font=INFOFONT
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Cancel"
    help="Press to select calibration of different kind"
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="OK"
    help="Press to confirm custom settings"
  endc
  if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
    encdist=62.5
  endif
  if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
    vpstep=5
  else
    vpstep=10
  endif
  redraw=1
  while 1 do
    if redraw==0 then
      Text(haccuracy,s); sscanf(s,"%f",&accuracy);
      Text(hwidth,s); sscanf(s,"%f",&linewidth);
      Text(hpres,s); sscanf(s,"%i",&p);
      Text(hzcoo,s); sscanf(s,"%f",&z);
      if testertype!=TT_A7 || smallboard==0 || boardtype!=1 then
        Text(hencdist,s); sscanf(s,"%f",&encdist);
      endif
      Text(hoppdist,s); sscanf(s,"%f",&oppdx);
      Text(hfromx,s); sscanf(s,"%f",&fromx);
      Text(htox,s); sscanf(s,"%f",&tox);
    endif
    if Pressed(hboard) then
      i=Status(hboard)
      if testertype==TT_A7 && $LAY.rightlimit-$LAY.leftlimit>800000 then
        if i==1 then                   // FR4 XXW
          boardtype=0; largeboard=1
        else if i==2 then              // Glass
          boardtype=1; largeboard=0
        else
          boardtype=0; largeboard=0
        endif
        twostep=0
      else
        if i==1 then                   // Glass
          boardtype=1; twostep=0
        else if i==2 && hasmcm then    // MCM glass
          boardtype=2; twostep=0
        else if i==2+hasmcm then       // Two-step MCM
          boardtype=(testertype==TT_S3?1:2); twostep=1
        else if i==3+hasmcm then       // Two-board MCM
          boardtype=(testertype==TT_S3?1:2); twostep=2
        else if i==4+hasmcm then       // Two-step FR4
          boardtype=0; twostep=1
        else if i==5+hasmcm then       // Two-board FR4
          boardtype=0; twostep=2
        else                           // FR4
          boardtype=0; twostep=0
        endif
        largeboard=0
      endif
      Calculateboardshift(0)
      if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
        encdist=62.5
      endif
      redraw=1
    else if Pressed(hwidth) || Pressed(hwscroll) then
      linewidth=linewidth+Status(hwscroll)*0.010
      change hwscroll select=0; redraw=1
    else if Pressed(haccuracy) then
      redraw=1
    else if Pressed(haccscr) then
      i=Status(haccscr)
      if i<0 then
        if accuracy<0.00201 then
          accuracy=Round(accuracy+0.0001*i+0.00001,0.0001)
        else
          accuracy=Round(accuracy+0.0010*i+0.00001,0.0010)
        endif
      else
        if accuracy<0.00199 then
          accuracy=Round(accuracy+0.0001*i+0.00001,0.0001)
        else
          accuracy=Round(accuracy+0.0010*i+0.00001,0.0010)
        endif
      endif
      change haccscr select=0; redraw=1
    else if Pressed(hsides) then
      Text(hsides,s);
      if videoonly then usesides=0x0;
      else if Stricmp(s,"No")==0 then usesides=0x0;
      else if Stricmp(s,"Top")==0 then usesides=0x1;
      else if Stricmp(s,"Bottom")==0 then usesides=0x2;
      else usesides=testersides; endif
      if usesides!=0 && (usesides & testersides)==0 usesides=testersides
      if ($LAY.config & LC_VACUUMBOX)!=0 usesides=usesides & 0x1
      redraw=1
    else if Pressed(hfrom) then
      firsttop=Min(Max(laytopmin,topmin+Status(hfrom)),laytopmax)
      if lasttop<firsttop lasttop=firsttop
      firstbot=Min(Max(laybotmin,botmin+Status(hfrom)),laybotmax)
      if lastbot<firstbot lastbot=firstbot
      redraw=1
    else if Pressed(hto) then
      lasttop=Min(Max(laytopmin,topmin+Status(hto)),laytopmax)
      if lasttop<firsttop firsttop=lasttop
      lastbot=Min(Max(laybotmin,botmin+Status(hto)),laybotmax)
      if lastbot<firstbot firstbot=lastbot
      redraw=1
    else if Pressed(hvelo) || Pressed(hvscr) then
      v=v+Status(hvscr)*vpstep; change hvscr select=0
      redraw=1
    else if Pressed(hpres) || Pressed(hpscr) then
      p=p+Status(hpscr)*vpstep; change hpscr select=0
      redraw=1
    else if Pressed(hzcoo) || Pressed(hzscr) then
      z=z+Status(hzscr)*0.5; change hzscr select=0
      redraw=1
    else if Pressed(hencdist) || Pressed(hencchange) then
      if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
        encdist=62.5
      else
        if testertype==TT_A7 && smallboard!=0 then
          step=12.5
        else
          step=ystep
        endif
        f=Status(hencchange)*step
        if boardtype==1 && (testertype==TT_A3L || testertype==TT_A5) then
          encdist=encdist+f
          if Abs(encdist-50.0)<0.1 then
            // At 50.0 mm lines, A5 glass board has camera fiducials.
            encdist=encdist+f
          endif
        else if boardtype==1 && testertype==TT_A5L then
          encdist=encdist+2*f
          i=(encdist+step)/(2.0*step)
          encdist=i*step*2.0
        else
          encdist=encdist+f
        endif
      endif
      change hencchange select=0; redraw=1
    else if Pressed(hoppdist) || Pressed(hoppchange) then
      oppdx=Min(25.0,Max(0.0,oppdx+Status(hoppchange)*0.5))
      change hoppchange select=0; redraw=1
    else if Pressed(hpoints) then
      throwaway=Max(1,Min(5,Status(hpoints)+1))
      redraw=1
    else if Pressed(hfromx) || Pressed(hfromxscr) then
      fromx=fromx+Status(hfromxscr)*xstep
      if fromx>tox-xstep tox=fromx+xstep
      change hfromxscr select=0; redraw=1
    else if Pressed(htox) || Pressed(htoxscr) then
      tox=tox+Status(htoxscr)*xstep
      if tox<fromx+xstep fromx=tox-xstep
      change htoxscr select=0; redraw=1
    else if Pressed(hymode) then
      precisey=Status(hymode)
      redraw=1
    else if Pressed(hinterlace) then
      interlace=Status(hinterlace)
      if (interlace!=0 && singleref!=0) singleref=0
      redraw=1
    else if Pressed(hsingleref) then
      singleref=Status(hsingleref)
      if (singleref!=0 && interlace!=0) interlace=0
      redraw=1
    else if Pressed(hsoftland) then
      softland=Status(hsoftland)
      redraw=1
    else if Pressed(hkelvin) then
      if $LAY.probetype==0 then
        i=Status(hkelvin)
        if i==1 then
          kelvinscan=3
        else if i==2 then
          kelvinscan=2
        else
          kelvinscan=0
        endif
      else
        kelvinscan=Status(hkelvin)
      endif
      redraw=1
    else if Pressed(hoffset) then
      measureoffset=Status(hoffset)
      redraw=1
    else if Pressed(hlowspeed) then
      lowspeed=Status(hlowspeed)
      redraw=1
    else if Pressed(hverify) then
      autoverify=Status(hverify)
      redraw=1
    else if hcameras!=NULL && Pressed(hcameras) then
      Text(hcameras,s)
      if Strcmp(s,"No")==0 then cameras=0;
      else if Strcmp(s,"Top")==0 then cameras=1;
      else if Strcmp(s,"Bottom")==0 then cameras=2;
      else cameras=3; endif
      redraw=1;
    else if Pressed(hcameramode) then
      cameramode=Status(hcameramode)
      redraw=1
    else if Pressed(hnoclip) then
      noclip=Status(hnoclip)
      redraw=1
    else if Pressed(hilluminate) then
      illumination=Status(hilluminate)
      redraw=1
    else if Pressed(hconfirm) then
      operator=!Status(hconfirm)
      redraw=1
      autoconfirm=operator
    else if Pressed(hpreset) then
      i=Status(hpresettype)
      if i==4 then
        i=6                            // Two-step MCM
      else if i==5 then
        i=7                            // Two-board MCM
      endif
      if Presetparm(i)<0 return -1
      redraw=1
    else if Pressed(hok) then
      if usesides==0 && cameras==0 continue
      videofromx=Max(fromx,($LAY.leftlimit+$LAY.videodeadx)/1000.0)
      if testertype==TT_A3 || testertype==TT_A3L || testertype==TT_A4 ||       \
        testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||        \
        testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||         \
        testertype==TT_A7 || testertype==TT_A8                                 \
      then
        videotox=tox
      else
        videotox=Min(tox,($LAY.rightlimit-$LAY.videodeadx)/1000.0)
      endif
      headcams=0
      if $LAY.cameras==0 then
        for i=0,i<$LAY.nfing*2,i++ do
          if ($LAY.headcameras & (1<<i))==0 continue
          if (i<firsttop*2 || i>lasttop*2+1) && (i<firstbot*2 || i>lastbot*2+1)\
            continue
          if ($LAY.config & LC_VACUUMBOX)!=0 && $LAY.side[i/2]!=0 continue
          if ($LAY.excludedrails & (1<<(i/2)))!=0 continue
          if (usesides & 0x1)==0 && $LAY.side[i/2]==0 continue
          if (usesides & 0x2)==0 && $LAY.side[i/2]!=0 continue
          headcams=headcams | (1<<i)
        enddo
      endif
      firsttop=Min(Max(laytopmin,topmin+Status(hfrom)),laytopmax)
      if lasttop<firsttop lasttop=firsttop
      firstbot=Min(Max(laybotmin,botmin+Status(hfrom)),laybotmax)
      if lastbot<firstbot lastbot=firstbot
      lasttop=Min(Max(laytopmin,topmin+Status(hto)),laytopmax)
      if lasttop<firsttop firsttop=lasttop
      lastbot=Min(Max(laybotmin,botmin+Status(hto)),laybotmax)
      if lastbot<firstbot firstbot=lastbot
      setini("Calibration","Board","%i,%f,%f,%i",                              \
        boardtype,linewidth,accuracy,twostep)
      setini("Calibration","Stroke","%i,%i,%f",v,p,z)
      setini("Calibration","Area","%i,%i,%f,%f,%i,%i,%i",                      \
        firsttop,lasttop,fromx,tox,usesides,firstbot,lastbot)
      setini("Calibration","Parms","%i,%i,%i,%i",                              \
        throwaway,autoverify,measureoffset,lowspeed)
      setini("Calibration","Extras","%i,%f,%i",operator,extralen,precisey)
      setini("Calibration","Heads","%f,%i,%i,%i,%i",                           \
        encdist,singleref,interlace,softland,kelvinscan)
      setini("Calibration","Video","%i,%i,%f,%i",                              \
        cameramode,illumination,oppdx,noclip)
      autoconfirm=operator
      exit=1; redraw=1
    endif
    if redraw!=0 then
      if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
        disable hencdist
        disable hencchange
      else
        enable hencdist
        enable hencchange
      endif
      linewidth=Max(0.090,Min(0.400,linewidth))
      accuracy=Max(0.0001,Min(0.1000,accuracy))
      change haccuracy text=format("%.4f",accuracy)
      if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP &&                    \
        (testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3)          \
      then
        p=Max(10,Min(100,p))
        v=Max(10,Min(80,v))
      else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
        p=Max(5,Min(50,p))
        v=Max(5,Min(30,v))
      else
        p=Max(softtouch?50:20,Min(softtouch?120:80,p))
        v=Max(20,Min(80,v))
      endif
      change hvelo text=format("%i",v)
      change hpres text=format("%i",p)
      z=Max(2.5,Min(15.0,z)); change hzcoo text=format("%.1f",z)
      f=Min($LAY.top[0]-$LAY.yoffset[0],$LAY.yoffset[0]-$LAY.bottom[0])/1000.0
      if testertype==TT_M2 then
        f=f-2.0; step=ystep
      else if testertype==TT_A5L && smallboard!=0 then
        f=f-30.0; step=ystep
      else if testertype==TT_A7 && smallboard!=0 then
        f=f-25.0; step=12.5
      else
        f=f-5.0; step=ystep
      endif
      encdist=Max(3,Min(Floor(encdist/step+0.5),Floor(f/step)))*step
      if tox<fromx+xstep tox=fromx+xstep
      f=Min($LAY.xoffset-$LAY.leftlimit,$LAY.rightlimit-$LAY.xoffset)/1000.0
      if testertype==TT_A3 then
        f=Min(f,225.0)                 // A3 calibration board: 450 mm
      else if testertype==TT_A3L || testertype==TT_A5 then
        f=Min(f,260.0)                 // A3L/A5 calibration board: 520 mm
      else if testertype==TT_A5L then
        if smallboard then
          f=Min(f,260.0)               // A5 calibration board in A5L tester
        else
          f=Min(f,300.0)               // Large A5L calibration board: 300 mm
        endif
      else if testertype==TT_A7 then
        if largeboard && $LAY.rightlimit-$LAY.leftlimit>800000 then
          f=Min(f,425.0)
        else if smallboard && boardtype==1 then
          f=Min(f,250.0)               // A5 glass calibration board: 500 mm
        else if smallboard && boardtype!=1 then
          f=Min(f,300.0)               // Large A5L calibration board: 300 mm
        else if smallboard==0 && ($LAY.nfing==8 || $LAY.nfing==10) then
          f=Min(f,275.0);              // A7XXL FR4 board
        else if smallboard==0 && boardtype==1 then
          f=Min(f,225.0);              // A7 glass board, slightly reduced
        else
          f=Min(f,300.0)               // Native A7 calibration board: same
        endif
      else if testertype==TT_M2 then
        f=Min(f,150.0)                 // M2 calibration board: 300 mm
      else if boardtype==2 then
        f=Min(f,150.0)                 // A1/A2 MCM glass board: 300 mm
      else if testertype==TT_S2 && smallboard then
        f=Min(f,150.0)                 // S2 small calibration board: 300 mm
      else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
        f=Min(f,100.0)                 // S3 split calibration board: 200 mm
      else
        f=Min(f,300.0)                 // A1/A2 calibration board: 600 mm
      endif
      if twostep!=0 && testertype==TT_S3 then
        fright=f+250.0
      else if twostep==1 then
        fright=f+300.0
      else if twostep==2 then
        fright=f+330.0
      else
        fright=f
      endif
      if fromx<$LAY.xoffset/1000.0+boardshift-f then
        fromx=$LAY.xoffset/1000.0+boardshift-f
        if tox-fromx<xstep tox=fromx+xstep
      endif
      if tox>$LAY.xoffset/1000.0+boardshift+fright then
        tox=$LAY.xoffset/1000.0+boardshift+fright
        while tox>$LAY.rightlimit/1000.0 do
          tox=tox-xstep
        enddo
        if tox-fromx<xstep fromx=tox-xstep
      endif
      if videoonly usesides=0
      if ($LAY.config & LC_VACUUMBOX)!=0 usesides=usesides & 0x1
      if usesides==0x0 then
        change hsides select="No"
      else if usesides==0x1 then
        change hsides select="Top"
      else if usesides==0x2 then
        change hsides select="Bottom"
      else
        change hsides select="All"
      endif
      if testersides==0x03 then
        if laybotmin>laybotmax then
          change hfrom select=firsttop-topmin
          change hto select=lasttop-topmin
        else if laytopmin>laytopmax then
          change hfrom select=firstbot-botmin
          change hto select=lastbot-botmin
        else
          change hfrom select=Max(firsttop-topmin,firstbot-botmin)
          change hto select=Max(lasttop-topmin,lastbot-botmin)
        endif
      else if testersides==0x01 then
        change hfrom select=firsttop-topmin
        change hto select=lasttop-topmin
      else
        change hfrom select=firstbot-botmin
        change hto select=lastbot-botmin
      endif
      if testertype==TT_A7 && $LAY.rightlimit-$LAY.leftlimit>800000 then
        if boardtype==1 then
          i=2
        else if boardtype==0 && largeboard==1 then
          i=1
        else
          i=0
        endif
      else
        if boardtype==0 && twostep==2 then
          i=5+hasmcm                   // Two-board FR4
        else if boardtype==0 && twostep==1 then
          i=4+hasmcm                   // Two-step FR4
        else if boardtype!=0 && twostep==2 then
          i=3+hasmcm                   // Two-board MCM
        else if boardtype!=0 && twostep==1 then
          i=2+hasmcm                   // Two-step FR4
        else
          i=boardtype
        endif
      endif
      change hboard select=i
      change hwidth text=format("%.3f",linewidth)
      change hencdist text=format("%.1f",encdist)
      change hoppdist text=format("%.1f",oppdx)
      if hcameras!=NULL then
        cameras=cameras & $LAY.cameras
        if ($LAY.config & LC_VACUUMBOX)!=0 cameras=cameras & 0x01
        if ($LAY.excludedrails & 0x4000)!=0 cameras=cameras & 0x01
        if ($LAY.excludedrails & 0x8000)!=0 cameras=cameras & 0x02
        if cameras==0x00 then change hcameras select="No";
        else if cameras==0x01 then change hcameras select="Top";
        else if cameras==0x02 then change hcameras select="Bottom";
        else change hcameras select="Both"; endif
      endif
      change hcameramode select=cameramode
      change hnoclip select=noclip
      if ($LAY.cameras!=0x3 && (symmetricheadcams==0 || usesides!=0x3)) ||     \
        ($LAY.config & LC_VACUUMBOX)!=0 || testertype==TT_S3                   \
        illumination=0
      change hilluminate select=illumination
      change hpoints select=throwaway-1
      change hfromx text=format("%.0f",fromx)
      change htox text=format("%.0f",tox)
      change hymode select=precisey
      change hinterlace select=interlace
      change hsingleref select=singleref
      change hsoftland select=softland
      if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&      \
        testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&         \
        testertype!=TT_A7 && testertype!=TT_A8) then
        kelvinscan=0
        change hkelvin select=0
      else if $LAY.probetype==0 then
        if kelvinscan!=2 && kelvinscan!=3 kelvinscan=0
        if kelvinscan==3 then
          change hkelvin select=1
        else if kelvinscan==2 then
          change hkelvin select=2
        else
          change hkelvin select=0
        endif
      else if $LAY.probetype!=1 || (measfeatures & MF_KELVSCAN)==0 then
        kelvinscan=0
        change hkelvin select=0
      else
        change hkelvin select=kelvinscan
      endif
      if $LAY.cameras==0 && $LAY.headcameras!=0 measureoffset=0
      if cameras==0x3 && ($LAY.config & LC_VACUUMBOX)==0 &&                    \
        (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||       \
        testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||         \
        testertype==TT_A7 || testertype==TT_A8) then
        enable hoffset
        change hoffset select=measureoffset
      else
        change hoffset select=0
        disable hoffset
      endif
      if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||       \
        testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||         \
        testertype==TT_A7 || testertype==TT_A8 then
        enable hlowspeed
        change hlowspeed select=lowspeed
      else
        lowspeed=0
        change hlowspeed select=0
        disable hlowspeed
      endif
      change hverify select=autoverify
      change hconfirm select=!operator
      n=0
      if linewidth<0.1 n=n+sprintf(w+n,"- Low line width\n")
      if linewidth>0.5 n=n+sprintf(w+n,"- High line width\n")
      if boardtype!=0 && measureoffset then
        n=n+sprintf(w+n,"- Top-to-bottom offset on glass\n")
      endif
      if accuracy>0.050 then
        n=n+sprintf(w+n,"- Low board accuracy\n")
      else if boardtype==2 && accuracy>0.025 then
        n=n+sprintf(w+n,"- Low accuracy on glass\n")
      endif
      ok=1
      if usesides==0 && cameras==0 then
        ok=0
        n=n+sprintf(w+n,"- There is nothing to calibrate\n")
      else
        if videoonly==0 &&                                                     \
          (((testersides & 0x1)!=0 && (firsttop!=topmin || lasttop!=topmax)) ||\
          ((testersides & 0x2)!=0 && (firstbot!=botmin || lastbot!=botmax)) || \
          usesides!=(testersides & ($LAY.config & LC_VACUUMBOX?0x1:0x3)))      \
          n=n+sprintf(w+n,"- Some rails excluded\n")
        if cameras!=$LAY.cameras &&                                            \
          (($LAY.config & LC_VACUUMBOX)==0 || ((cameras^$LAY.cameras) & 1)!=0) \
          n=n+sprintf(w+n,"- Some cameras excluded\n")
        ;
      endif
      if usesides!=0 then
        if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS && v>20 then
          n=n+sprintf(w+n,"- High stroke with hard touch needles\n")
        else if v>65.0 then
          n=n+sprintf(w+n,"- High stroke\n")
        else if boardtype!=0 && v>(softtouch?55.0:45.0) then
          n=n+sprintf(w+n,"- High stroke on glass\n")
        else if softland && v>40.0 then
          n=n+sprintf(w+n,"- High stroke in soft landing mode\n")
        endif
        if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS && p>30 then
          n=n+sprintf(w+n,"- High pressure with hard touch needles\n")
        else if softland && p>50 then
          n=n+sprintf(w+n,"- High pressure in soft landing mode\n")
        endif
        if singleref n=n+sprintf(w+n,"- Single reference\n")
        if boardtype!=0 && kelvinscan==3 then
          n=n+sprintf(w+n,"- External antenna on glass\n")
        else if boardtype!=0 && kelvinscan!=0 then
          n=n+sprintf(w+n,"- Kelvin scanning on glass\n")
        endif
        if Abs(extralen)>0.0005 n=n+sprintf(w+n,"- Radius correction active\n")
      endif
      if tox-fromx<($LAY.rightlimit-$LAY.leftlimit)/2500.0                     \
        n=n+sprintf(w+n,"- Too narrow X range\n")
      if throwaway>3 || (throwaway==3 && boardtype==2)                         \
        n=n+sprintf(w+n,"- Too few scan points\n")
      if usesides!=0 && (cameras & usesides)!=cameras                          \
        n=n+sprintf(w+n,"- Camera calibrates excluded side\n")
      if illumination!=0 && flashthru==0 &&                                    \
        ($EXTLAY.illumination==ILL_FLASH ||                                    \
        $EXTLAY.illumination==ILL_FLASHMIX)                                    \
      then
        ok=0
        n=n+sprintf(w+n,"- Shinethrough with flashlight is not supported\n")
      endif
      if $LAY.cameras!=0 && ((boardtype==1 &&                                  \
        (testertype==TT_A3L || testertype==TT_A5 ||                            \
        testertype==TT_A5L || testertype==TT_A6 ||                             \
        testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||         \
        testertype==TT_A7 || testertype==TT_A8)) ||                            \
        boardtype==2) && illumination!=0 && (oppdx<7.0 || oppdx>17.0)          \
        n=n+sprintf(w+n,"- Strange camera-to-camera shift\n")
      if $LAY.cameras==0 && $LAY.headcameras!=0 && ((boardtype==1 &&           \
        (testertype==TT_A3L || testertype==TT_A5 ||                            \
        testertype==TT_A5L || testertype==TT_A6 ||                             \
        testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3)) ||       \
        boardtype==2) && illumination!=0 && (oppdx<(-2.0) || oppdx>7.0)        \
        n=n+sprintf(w+n,"- Strange camera-to-camera shift\n")
      if $LAY.cameras==0 && $LAY.headcameras!=0 && ((boardtype==1 &&           \
        (testertype==TT_A7 || testertype==TT_A8)) ||                           \
        boardtype==2) && illumination!=0 && (oppdx<(-4.0) || oppdx>4.0)        \
        n=n+sprintf(w+n,"- Strange camera-to-camera shift\n")
      if ($LAY.cameras!=0 || $LAY.headcameras!=0) && boardtype==0 &&           \
        illumination!=0 && testertype!=TT_S1 && testertype!=TT_S2              \
        n=n+sprintf(w+n,"- Shinethrough illumination on FR4\n")
      if ($LAY.cameras!=0 || $LAY.headcameras!=0) &&                           \
        (boardtype==1 || boardtype==2) && cameramode==2                        \
        n=n+sprintf(w+n,"- Quick camera calibration on glass\n")
      draw window=hwarn clear
      draw at 5,15 color=LIGHTRED wrap=RIGHTX-5
      if n>0 then
        draw text="ATTENTION, suspicious parameters:\n\n"
        draw text=w
        draw text="\n"
      endif
      excludedrails=$LAY.excludedrails & ((1<<$LAY.nfing)-1)
      if $LAY.cameras!=0                                                       \
        excludedrails=excludedrails | ($LAY.excludedrails & 0xC000)
      if (($LAY.config & LC_VACUUMBOX)!=0 && (testersides & 2)!=0) ||          \
        excludedrails!=0                                                       \
      then
        draw color=GREEN text="Please check tester layout:\n\n"
        if ($LAY.config & LC_VACUUMBOX)!=0 && (testersides & 2)!=0             \
          draw text="- Bottom side is disabled by vacuum box\n"
        if excludedrails!=0                                                    \
          draw text="- Some rails are excluded from boot\n"
        ;
      endif
      if ok then
        enable hok
      else
        disable hok
      endif
      if boardtype==0 then
        enable hverify
      else
        disable hverify
      endif
      draw show
      redraw=0
    endif
    if exit!=0 return 0
    if Pressed(hcancel) then
      return 1
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Allows operator to change stroke for predefined calibration type.
function int Customstroke()
  int n,vpstep,redraw
  char w[512]
  handle hvelo,hvscr,hpres,hpscr,hzcoo,hzscr
  handle hwarn,hok,hcancel
  clear hright
  change hinfo limits=0,0
  change hinfo text="Check stroke"
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="If necessary, you may adjust stroke for the subsequent "
  draw text=(calmode==MODE_VER?"verification.":"calibration.")
  draw mode=M_LEFT font=INFOFONT color=BLACK
  draw at 46,104 text="V ="
  hvelo=control EDIT
    window=hright
    position=94,84,45,24
    help="Specify Z down speed, millimeters per second"
  endc
  hvscr=control VSCROLL
    window=hright
    position=140,84,20,24
    help="Press to change speed"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 166,104 text="mm/s"
  draw at 46,134 text="P ="
  hpres=control EDIT
    window=hright
    position=94,114,45,24
    help="Specify Z pressure, internal units"
  endc
  hpscr=control VSCROLL
    window=hright
    position=140,114,20,24
    help="Press to change pressure"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 166,134 text="int. units"
  draw at 46,164 text="Hmin ="
  hzcoo=control EDIT
    window=hright
    position=94,144,48,24
    help="Specify minimal allowed Z up distance, millimeters"
  endc
  hzscr=control VSCROLL
    window=hright
    position=140,144,20,24
    help="Press to change minimal Z up distance"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 166,164 text="mm"
  draw show
  hwarn=control GRAPH
    window=hright
    position=5,190,RIGHTX-10,80
    help=" "
    color=WHITE
    bkcolor=WHITE
    font=INFOFONT
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Cancel"
    help="Press to select calibration of different kind"
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="OK"
    help="Press to confirm custom settings"
  endc
  if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
    vpstep=5
  else
    vpstep=10
  endif
  redraw=1
  while 1 do
    if redraw then
      if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP &&                    \
        (testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3)          \
      then
        p=Max(10,Min(100,p))
        v=Max(10,Min(80,v))
      else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
        p=Max(5,Min(50,p))
        v=Max(5,Min(30,v))
      else
        p=Max(softtouch?50:20,Min(softtouch?120:80,p))
        v=Max(20,Min(80,v))
      endif
      z=Max(2.5,Min(15.0,z))
      change hvelo text=format("%i",v)
      change hpres text=format("%i",p)
      change hzcoo text=format("%.1f",z)
      n=0
      if usesides!=0 then
        if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS && v>20 then
          n=n+sprintf(w+n,"- High stroke with hard touch needles\n")
        else if v>65.0 then
          n=n+sprintf(w+n,"- High stroke\n")
        else if boardtype!=0 && v>(softtouch?55.0:45.0) then
          n=n+sprintf(w+n,"- High stroke on glass\n")
        else if softland && v>40.0 then
          n=n+sprintf(w+n,"- High stroke in soft landing mode\n")
        endif
        if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS && p>30 then
          n=n+sprintf(w+n,"- High pressure with hard touch needles\n")
        else if softland && p>50 then
          n=n+sprintf(w+n,"- High pressure in soft landing mode\n")
        endif
      endif
      draw window=hwarn clear
      draw at 5,15 color=LIGHTRED wrap=RIGHTX-5
      if n>0 then
        draw text="ATTENTION, suspicious parameters:\n\n"
        draw text=w
        draw text="\n"
      endif
      draw show
      redraw=0
    endif
    if Pressed(hvelo) || Pressed(hvscr) then
      v=v+Status(hvscr)*vpstep; change hvscr select=0
      redraw=1
    else if Pressed(hpres) || Pressed(hpscr) then
      p=p+Status(hpscr)*vpstep; change hpscr select=0
      redraw=1
    else if Pressed(hzcoo) || Pressed(hzscr) then
      z=z+Status(hzscr)*0.5; change hzscr select=0
      redraw=1
    else if Pressed(hok) then
      setini("Calibration","Stroke","%i,%i,%f",v,p,z)
      break
    else if Pressed(hcancel) then
      return 1
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Fills t_calibr structures and some auxiliary variables with following
// information:
//
//   Mode         Heads                        Cameras
//
//   C_CENTER     Central crosses              Central fiducials
//   C_CORNER     Board position               Precalibration corners
//   C_CALIBR     Main calibration             Main calibration
//   C_VER3       Verification, 3 rows         Standard verification
//   C_VER5       Verification, 5 rows         Verification, same as heads
//   C_VERAREA    Verification, whole area     Verification, all available
//   C_VERALL     Verification, all available  Same as C_VERAREA
//   C_VERHALF    Verification, all at center  Same as C_VERAREA
//   C_PRECAL     ---                          Precalibration and center
//   C_CENTER2    Central crosses (same as 0)  Central fiducials, x2 directions
//   C_MVERIFY    Cross(es) at (mverifyx,mverifyy,mverifyrail,mverifymode...)
//   C_9N         Headcam: 9N crosses          9N crosses at (mverifyx,mverifyy)
//   C_SHY        Shuttle Y at fillshy         ---
//
// for specified types of calibration (FILL_MECH, FILL_VIDEO and FILL_HCAM).
// Note that FILL_MECH and FILL_HCAM are mutually exclusive. Returns 1 if
// tester is not supported, 2 if calibration board is not supported, 3 if there
// are too few calibration points, 4 if there are too many calibration points
// and -1 if error was detected and operator decided to interrupt calibration.
//
// Scandir directions:
//   6 7 8
//   5 0 1
//   4 3 2
//
function int Fillcalibrators(int mode,int type)
  int i,j,k,m,q,g,head,nfing,ncal,ntotal,nx,ny,err,xnode
  int cntrshift,ngroup,order[9],mvx0,mvx1,mvy0,mvy1,mvn
  int mx,my,mn,ix,iy,increasedist,mstart,mend,nmax
  float f,hh,width,refdx,refdy,hvconddy,verdist,refmin,refmax,icenter
  float x,y,xstart,xend,xlast,ystart,ycenter,yend,group[5]
  float headstart,dx,dy,step,vstep,xoffset,yoffset
  float leftprofilex,rightprofilex,deltax,deltay
  handle hok
  nfing=$LAY.nfing
  err=0
  if type & FILL_MECH then
    if mode==C_SHY &&                                                          \
      (testertype!=TT_S3 || (fillshy<(-155.0) || fillshy>155.0)) then
      err=10; goto error               // As yet unsupported mode
    endif
    // Fill head calibration data.
    hh=Min($LAY.top[0]-$LAY.yoffset[0],                                        \
      $LAY.yoffset[0]-$LAY.bottom[0])/1000.0
    if testertype==TT_M2 then
      hh=hh-2.0; vstep=ystep
    else if testertype==TT_A5L && smallboard!=0 then
      hh=hh-30.0; vstep=ystep
    else if testertype==TT_A7 && smallboard!=0 && boardtype!=1 then
      hh=hh-25.0; vstep=12.5
    else if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
      hh=hh-55.0; vstep=12.5
    else
      hh=hh-5.0; vstep=ystep
    endif
    if mode==C_VERHALF && ((topmax>=topmin && topmax-topmin!=1) ||             \
      (botmax>=botmin && botmax-botmin!=1))                                    \
      mode=C_VERALL
    if boardtype==0 then
      distance=1.2+Random(1.0)
    else
      distance=1.3+Random(1.4)
    endif
    if mode==C_CENTER || mode==C_CORNER || mode==C_CENTER2 || mode==C_SHY      \
      distance=distance+1.0
    distance=Min(distance,xstep/2.0,vstep/2.0)
    if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||         \
      testertype==TT_A2H || testertype==TT_A4 || testertype==TT_A6 ||          \
      (testertype==TT_S1 && ($LAY.rightlimit-$LAY.leftlimit)>=600000) ||       \
      (testertype==TT_A8 && ($LAY.rightlimit-$LAY.leftlimit)>=600000)          \
    then
      if boardtype==0 || boardtype==1 then
        refdx=296.5; refsizex=3.0; refdy=74.0; hvconddy=44.0; refsizey=3.0
      else if boardtype==2 && testertype==TT_A8 then
        refdx=156.5; refsizex=1.0; refdy=72.0; hvconddy=42.0; refsizey=7.0
      else if boardtype==2 then
        refdx=156.5; refsizex=1.0; refdy=72.0; hvconddy=44.0; refsizey=7.0
      else
        err=2                          // Unsupported type of calibration board
      endif
    else if testertype==TT_A3 then
      if boardtype==0 then
        refsizex=2.0; refsizey=2.0
        refdx=221.5; refdy=97.5
      else
        err=2                          // Unsupported type of calibration board
      endif
    else if testertype==TT_A3L || testertype==TT_A5 then
      if boardtype==0 || boardtype==1 then
        refsizex=2.0; refsizey=2.0
        refdx=257.5; refdy=97.5; hvconddy=77.5
      else
        err=2                          // Unsupported type of calibration board
      endif
    else if testertype==TT_A5L then
      if boardtype!=0 && boardtype!=1 then
        err=2                          // Unsupported type of calibration board
      else if smallboard==1 then
        refsizex=2.0; refsizey=2.0     // A5 board in A5L tester
        refdx=257.5; refdy=72.5; hvconddy=52.5
      else
        refsizex=2.0; refsizey=2.0     // Original A5L calibration board
        refdx=307.5; refdy=97.5; hvconddy=77.5
      endif
    else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      refsizex=1.0; refsizey=5.0
      refdx=112.5; refdy=70.0; hvconddy=54.0
    else if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
      if boardtype==2 then
        refsizex=1.0; refsizey=5.0
        refdx=156.5; refdy=70.0; hvconddy=54.0
      else if boardtype!=0 && boardtype!=1 then
        err=2                          // Unsupported type of calibration board
      else if $LAY.rightlimit-$LAY.leftlimit>=600000 && smallboard==0 then
        refsizex=3.0; refsizey=3.0
        refdx=296.5; refdy=74.0; hvconddy=54.0
      else
        refsizex=3.0; refsizey=3.0
        refdx=157.5; refdy=30.0; hvconddy=10.0
      endif
    else if testertype==TT_A7 then
      if boardtype!=0 && boardtype!=1 then
        err=2                          // Unsupported type of calibration board
      else if largeboard && $LAY.rightlimit-$LAY.leftlimit>800000 then
        refsizex=1.0; refsizey=5.0     // A7 XXW board
        refdx=429.25; refdy=97.5; hvconddy=92.5
      else if smallboard==1 && smallfirst>=0 && boardtype==0 then
        refsizex=2.0; refsizey=2.0     // A5L board in A7 tester
        refdx=307.5; refdy=97.5; hvconddy=77.5
      else if smallboard==1 && smallfirst>=0 && boardtype==1 then
        refsizex=2.0; refsizey=2.0     // A5 glass board in A7 tester
        refdx=257.5; refdy=60.0; hvconddy=40.0
      else if ($LAY.nfing==8 || $LAY.nfing==10) && boardtype==0 then
        refsizex=2.0; refsizey=2.0     // A7XXL board for A7/16 or A7/20
        refdx=282.5; refdy=112.5; hvconddy=92.5
      else if smallboard==0 && boardtype==1 then
        if lasttop-firsttop>=2 then
          err=2
        else
          refsizex=2.0; refsizey=2.0   // A7 glass board, slightly reduced
          refdx=232.5; refdy=112.5; hvconddy=92.5
        endif
      else
        refsizex=2.0; refsizey=2.0     // Original A7 calibration board
        refdx=307.5; refdy=112.5; hvconddy=92.5
      endif
    else if testertype==TT_A8 && $LAY.rightlimit-$LAY.leftlimit<500000 &&      \
      boardtype==2 then
      refsizex=3.0; refsizey=3.0       // S2 small glass in A8a
      refdx=157.5; refdy=74.0; hvconddy=54.0
    else if testertype==TT_A8 && smallboard==1 then
      refsizex=3.0; refsizey=3.0       // Small A8 board
      refdx=222.0; refdy=74.0; hvconddy=54.0
    else
      err=1                            // Unsupported type of tester
    endif
    if err==0 && usesides!=0 && ((usesides & testersides)==0 ||                \
      ((usesides & 0x1)!=0 && (firsttop<0 || lasttop<0 || firsttop>lasttop)) ||\
      ((usesides & 0x2)!=0 && (firstbot<0 || lastbot<0 || firstbot>lastbot)))  \
      err=8
    if err==0 && (kelvinscan==2 || kelvinscan==3) then
      f=0.0
      while f+xstep<=refdx do
        f=f+xstep
      enddo
      refdx=f-xstep/2
    endif
    // Limits of accessible area must be corrected for reference points.
    i=refdx/xstep
    xoffset=$LAY.xoffset/1000.0+boardshift
    fromxloc=Max(fromx,xoffset-i*xstep)
    toxloc=Min(tox,xoffset+i*xstep)
    if err==0 then
      globref[0]=-1; globref[1]=-1
      refmin=xoffset-refdx
      refmax=xoffset+refdx
      for i=0,i<nfing,i++              // Set coordinates of reference points
        c[i*2].refx0=refmin
        c[i*2+1].refx0=refmax
        if testertype==TT_A7 && siderail<=2 && smallboard==0 &&                \
          (automationtype==AUTO_A7LMMAN || automationtype==AUTO_A7LMSEMI ||    \
          automationtype==AUTO_A7LMFULL || automationtype==AUTO_A7LMNONE)      \
        then
          // Care for A7a testers with the additional side fixators in the
          // middle of the left/right sides!
          if i==laytopmin || i==laybotmin then
            c[i*2].refy0=$LAY.yoffset[i]/1000.0-refdy+Max(0.0,-fillshy)
            c[i*2+1].refy0=$LAY.yoffset[i]/1000.0-refdy+Max(0.0,fillshy)
          else
            c[i*2].refy0=$LAY.yoffset[i]/1000.0+refdy-Max(0.0,-fillshy)
            c[i*2+1].refy0=$LAY.yoffset[i]/1000.0+refdy-Max(0.0,fillshy)
          endif
        else
          c[i*2].refy0=$LAY.yoffset[i]/1000.0-refdy+Max(0.0,-fillshy)
          c[i*2+1].refy0=$LAY.yoffset[i]/1000.0+refdy-Max(0.0,fillshy)
        endif
        c[i*2].forcekelvin=0
        c[i*2+1].forcekelvin=0
        if (boardtype!=1 && boardtype!=2) || usehvconditioning==0 ||           \
          mode==C_SHY                                                          \
        then
          c[i*2].hvcondok=0
          c[i*2+1].hvcondok=0
        else
          c[i*2].hvcondok=1
          c[i*2].hvcondx0=refmin
          c[i*2].hvcondy0=$LAY.yoffset[i]/1000.0-hvconddy
          c[i*2+1].hvcondok=1
          c[i*2+1].hvcondx0=refmax
          c[i*2+1].hvcondy0=$LAY.yoffset[i]/1000.0+hvconddy
        endif
        if ($LAY.side[i]==0 && globref[0]<0) globref[0]=i*2
        if ($LAY.side[i]!=0 && globref[1]<0) globref[1]=i*2
      enddo
      if globref[0]<0 globref[0]=0     // Really unnecessary, but safe
      if globref[1]<0 globref[1]=0
      xstart=xoffset
      xend=xstart
      if mode==C_SHY then
        while xstart-xstep>=fromxloc do
          xstart=xstart-xstep
        enddo
        while xend+xstep<=toxloc do
          xend=xend+xstep
        enddo
      else
        while xstart-throwaway*xstep>=fromxloc do
          xstart=xstart-throwaway*xstep
        enddo
        while xend+throwaway*xstep<=toxloc do
          xend=xend+throwaway*xstep
        enddo
      endif
      ntotal=0
      for i=0,i<nfing*2,i++ do         // Initialize parameters
        yoffset=$LAY.yoffset[i/2]/1000.0
        c[i].mode=0
        c[i].type=FILL_MECH
        c[i].ncal=0
        if mode==C_MVERIFY && mverifyrail>=0 && i/2!=mverifyrail               \
          continue                     // Not a manual verification rail
        if ($LAY.top[i/2]==0 && $LAY.bottom[i/2]==0)                           \
          continue                     // Skip dummy rails
        if $LAY.excludedrails & (1<<(i/2))                                     \
          continue                     // Skip excluded rails
        if ((1<<$LAY.side[i/2]) & usesides)==0                                 \
          continue                     // Side is excluded from calibration
        if ($LAY.config & LC_VACUUMBOX)!=0 && $LAY.side[i/2]!=0                \
          continue                     // Bottom side is excluded by vacuum box
        if (i<firsttop*2 || i>lasttop*2+1) && (i<firstbot*2 || i>lastbot*2+1)  \
          continue                     // Rail is excluded from calibration
        c[i].refx=c[i].refx0+(Random(refsizex)-refsizex/2.0)/3.0
        c[i].refy=c[i].refy0+(Random(refsizey)-refsizey/2.0)/3.0
        c[i].searchref=1               // Search for line in kelvinscan=2 mode
        if kelvinscan==1 then
          width=Max(linewidth/2.0,linewidth-0.120)
        else if $LAY.probetype==1 then
          width=linewidth+0.050
        else if ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP then
          width=linewidth+0.025
        else
          width=linewidth
        endif
        if boardtype==0 then
          width=width+0.025            // High lines on FR4 board
        endif
        c[i].widthx=width
        c[i].widthy=width
        Initsigma(c[i].wstatx)
        Initsigma(c[i].wstaty)
        c[i].encdist=encdist
        c[i].radius=radius
        if mode==C_SHY then
          // Very raw, currently only for S3!
          ycenter=yoffset
          if fillshy>=0.0 then
            ycenter=ycenter+Floor(fillshy/vstep)*vstep
            if ycenter>yoffset+hh ycenter=ycenter-vstep
            ycenter=ycenter-fillshy
          else
            ycenter=ycenter-Floor(-fillshy/vstep)*vstep
            if ycenter<yoffset-hh ycenter=ycenter+vstep
            ycenter=ycenter-fillshy
          endif
          c[i].centercamy=ycenter
          ystart=ycenter-vstep
          if ystart<$LAY.bottom[i/2]/1000.0+5.0 ystart=ystart+vstep
          yend=ycenter+vstep
          if yend>$LAY.top[i/2]/1000.0-5.0 yend=yend-vstep
          // Full-size FR4 calibration board has no reference strips, only
          // relatively small reference pads, therefore we need to correct the
          // Y reference coordinate.
          if testertype==TT_S3 && $LAY.rightlimit-$LAY.leftlimit>=600000 &&    \
            smallboard==0                                                      \
          then
            if fillshy<0 then          // Shuttle is shifted up
              c[i].refy=$LAY.yoffset[i/2]/1000.0-refdy-fillshy
            else                       // Shuttle is shifted down
              c[i].refy=$LAY.yoffset[i/2]/1000.0+refdy-fillshy
            endif
            c[i].refy=c[i].refy+(Random(refsizex)-refsizex/2.0)/3.0
          endif
        else if testertype==TT_A5L && boardtype==1 then
          ycenter=yoffset
          y=$LAY.top[0]/1000.0
          dy=vstep*4
          while y>=$LAY.bottom[i/2]/1000.0 do
            y=y-dy
          enddo
          while y+dy<$LAY.top[i/2]/1000.0 do
            y=y+dy
            if Abs(y-yoffset)<Abs(ycenter-yoffset) then
              ycenter=y
            endif
          enddo
          c[i].centercamy=ycenter
          ystart=yoffset-encdist
          yend=yoffset+encdist
        else
          ystart=yoffset-encdist
          yend=yoffset+encdist
          if testertype!=TT_A7 || smallboard==0 || boardtype!=1 then
            c[i].centercamy=yoffset
            ycenter=yoffset
          else if yoffset<$LAY.top[smallfirst]/1000.0 then
            c[i].centercamy=yoffset+2*vstep
            ycenter=yoffset+9*vstep
          else
            c[i].centercamy=yoffset-2*vstep
            ycenter=yoffset-9*vstep
          endif
        endif
        c[i].asymmetric=0
        c[i].bottomliney=ystart
        c[i].centerliney=ycenter
        c[i].topliney=yend
        c[i].scandist=20.0             // Default
        ncal=0
        ny=hh/vstep
        if mode==C_CENTER || mode==C_CENTER2 then
          // Scan cross most close to the center of the rail.
          c[i].xa[0]=xoffset
          dx=1.0e10
          // This is script, working solutions are better than optimal!
          for j=-CORRX/2,j<=CORRX/2,j++ do
            x=xoffset+j*xstep
            if x<fromxloc-0.001 continue
            if x>toxloc+0.001 break
            deltax=Abs($LAY.xoffset/1000.0-x)
            if deltax<dx then
              dx=deltax
              c[i].xa[0]=x
            endif
          enddo
          c[i].ya[0]=yoffset
          c[i].scandir[0]=0
          c[i].z[0]=0
          c[i].group[0]=0
          ncal=1
        else if mode==C_CORNER then
          // Precalibration.
          c[i].mode=CM_LOWACC|CM_CORRX|CM_CORRYTOP|CM_CORRYBOT
          c[i].xa[0]=xstart
          if xstart-refmin<xstep c[i].xa[0]=c[i].xa[0]+xstep
          c[i].ya[0]=ystart
          c[i].scandir[0]=0
          c[i].z[0]=0
          c[i].group[0]=0
          c[i].xa[1]=xstart
          if xstart-refmin<xstep c[i].xa[1]=c[i].xa[1]+xstep
          c[i].ya[1]=yend
          c[i].scandir[1]=0
          c[i].z[1]=0
          c[i].group[1]=0
          for x=xstart,x<=toxloc-throwaway*xstep,x=x+throwaway*xstep
          enddo
          c[i].xa[2]=x
          if refmax-x<xstep c[i].xa[2]=c[i].xa[2]-xstep
          c[i].ya[2]=ystart
          c[i].scandir[2]=0
          c[i].z[2]=0
          c[i].group[2]=0
          c[i].xa[3]=x
          if refmax-x<xstep c[i].xa[3]=c[i].xa[3]-xstep
          c[i].ya[3]=yend
          c[i].scandir[3]=0
          c[i].z[3]=0
          c[i].group[3]=0
          ncal=4
        else if mode==C_SHY then
          if ystart>=$LAY.bottom[i/2]/1000.0+5.0 &&                            \
            ystart<=$LAY.top[i/2]/1000.0-5.0 &&                                \
            ystart+fillshy>=$LAY.bottom[i/2]/1000.0+5.0 &&                     \
            ystart+fillshy<=$LAY.top[i/2]/1000.0-5.0                           \
          then
            c[i].xa[ncal]=xstart
            if xstart-refmin<xstep c[i].xa[ncal]=c[i].xa[ncal]+xstep
            c[i].ya[ncal]=ystart
            c[i].scandir[ncal]=0
            c[i].z[ncal]=0
            c[i].group[ncal]=0
            ncal++
          endif
          if yend>=$LAY.bottom[i/2]/1000.0+5.0 &&                              \
            yend<=$LAY.top[i/2]/1000.0-5.0 &&                                  \
            yend+fillshy>=$LAY.bottom[i/2]/1000.0+5.0 &&                       \
            yend+fillshy<=$LAY.top[i/2]/1000.0-5.0                             \
          then
            c[i].xa[ncal]=xstart
            if xstart-refmin<xstep c[i].xa[ncal]=c[i].xa[ncal]+xstep
            c[i].ya[ncal]=yend
            c[i].scandir[ncal]=0
            c[i].z[ncal]=0
            c[i].group[ncal]=0
            ncal++
          endif
          for x=xstart,x<=toxloc-xstep,x=x+xstep
          enddo
          if ystart>=$LAY.bottom[i/2]/1000.0+5.0 &&                            \
            ystart<=$LAY.top[i/2]/1000.0-5.0 &&                                \
            ystart+fillshy>=$LAY.bottom[i/2]/1000.0+5.0 &&                     \
            ystart+fillshy<=$LAY.top[i/2]/1000.0-5.0                           \
          then
            c[i].xa[ncal]=x
            if refmax-x<xstep c[i].xa[ncal]=c[i].xa[ncal]-xstep
            c[i].ya[ncal]=ystart
            c[i].scandir[ncal]=0
            c[i].z[ncal]=0
            c[i].group[ncal]=0
            ncal++
          endif
          if yend>=$LAY.bottom[i/2]/1000.0+5.0 &&                              \
            yend<=$LAY.top[i/2]/1000.0-5.0 &&                                  \
            yend+fillshy>=$LAY.bottom[i/2]/1000.0+5.0 &&                       \
            yend+fillshy<=$LAY.top[i/2]/1000.0-5.0                             \
          then
            c[i].xa[ncal]=x
            if refmax-x<xstep c[i].xa[ncal]=c[i].xa[ncal]-xstep
            c[i].ya[ncal]=yend
            c[i].scandir[ncal]=0
            c[i].z[ncal]=0
            c[i].group[ncal]=0
            ncal++
          endif
        else if mode==C_VERAREA || mode==C_VERALL || mode==C_VERHALF then
          // Verification of the whole area.
          k=0
          if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
            if yoffset<$LAY.top[smallfirst]/1000.0 then
              mstart=-ny
              mend=9
            else
              mstart=-9
              mend=ny
            endif
          else
            mstart=-ny
            mend=ny
          endif
          nmax=((toxloc-xstart)/xstep+1.0)*(mend-mstart+1)
          q=0
          for x=xstart,x<=toxloc,x=x+xstep do
            for m=mstart,m<=mend,m++ do
              if boardtype==2 && m==0 continue
              k++
              if boardtype==1 && testertype==TT_A5L then
                if (m/2)*2!=m continue
                if mode==C_VERAREA && k%2!=0 continue
              else if boardtype==1 && (testertype==TT_A3L ||                   \
                testertype==TT_A5 || testertype==TT_A5L) then
                if m==(-4) || m==0 || m==4 continue
                if mode==C_VERAREA && k%2!=0 continue
              else if smallboard!=0 && boardtype==1 && testertype==TT_A7 then
                if m==(-10) || m==(-6) || m==(-2) || m==2 || m==6 || m==10     \
                  continue
                if mode==C_VERAREA && k%2!=0 continue
              else
                if mode==C_VERAREA && k%4!=0 continue
                if mode==C_VERALL then
                  if nmax>250 then
                    if ((q | (m-mstart)) & 1)!=0 continue
                  else if nmax>125 then
                    if k%2==0 continue
                  endif
                endif
                if mode==C_VERHALF then
                  if topmax-topmin==1 && i/2==topmin && m<0 continue
                  if topmax-topmin==1 && i/2==topmax && m>0 continue
                  if botmax-botmin==1 && i/2==botmin && m<0 continue
                  if botmax-botmin==1 && i/2==botmax && m>0 continue
                endif
              endif
              if ncal>=NCALIBR break
              // No central cross for S1 big glass!
              if boardtype!=1 || testertype!=TT_S1 || testertype!=TT_S3 ||     \
                Abs(x-xoffset)>xstep/2.0 || Abs(m*vstep>ystep/2.0)             \
              then
                c[i].xa[ncal]=x
                c[i].ya[ncal]=yoffset+m*vstep
                c[i].scandir[ncal]=0
                c[i].z[ncal]=0
                c[i].group[ncal]=0
                ncal++
              endif
            enddo
            q++
          enddo
        else if mode==C_MVERIFY then
          // Manual verification.
          if mverifymode==MVM_MULTI then
            group[0]=0.0
            cntrshift=0; ngroup=1
          else
            switch mverifygroups
            case MVG_2X175:            // Verify two groups at 175 mm
              group[0]=0.0; group[1]=175.0
              cntrshift=0; ngroup=2
            case MVG_3X75:             // Verify three groups at 75 mm
              group[0]=0.0; group[1]=75.0; group[2]=150.0
              cntrshift=0; ngroup=3
            case MVG_3X100:            // Verify three groups at 100 mm
              group[0]=0.0; group[1]=100.0; group[2]=200.0
              cntrshift=1; ngroup=3
            case MVG_3X150:            // Verify three groups at 150 mm
              group[0]=0.0; group[1]=150.0; group[2]=300.0
              cntrshift=0; ngroup=3
            default:                   // Verify single group
              group[0]=0.0
              cntrshift=0; ngroup=1
            endsw
          endif
          switch mverifymode
          case MVM_X3:                 // Verify single cross 3 times
            mvx0=0;  mvx1=0; mvy0=0;  mvy1=0; mvn=3
          case MVM_X10:                // Verify single cross 10 times
            mvx0=0;  mvx1=0; mvy0=0;  mvy1=0; mvn=10
          case MVM_1X3:                // Verify 1x3 crosses
            mvx0=0;  mvx1=0; mvy0=-1; mvy1=1; mvn=1
          case MVM_2X3:                // Verify 2x3 crosses
            mvx0=0;  mvx1=1; mvy0=-1; mvy1=1; mvn=1
          case MVM_3X3:                // Verify 3x3 crosses
            mvx0=-1; mvx1=1; mvy0=-1; mvy1=1; mvn=1
          case MVM_1X5:                // Verify 1x5 crosses
            mvx0=0;  mvx1=0; mvy0=-2; mvy1=2; mvn=1
          case MVM_2X5:                // Verify 2x5 crosses
            mvx0=0;  mvx1=1; mvy0=-2; mvy1=2; mvn=1
          case MVM_3X5:                // Verify 3x5 crosses
            mvx0=-1; mvx1=1; mvy0=-2; mvy1=2; mvn=1
          default:                     // Verify single cross
            mvx0=0;  mvx1=0; mvy0=0;  mvy1=0; mvn=1
          endsw
          while xoffset+xstep*mverifyx<fromxloc do
            mverifyx++
          enddo
          while xoffset+xstep*mverifyx>toxloc do
            mverifyx--
          enddo
          mverifyy=Max(-ny,Min(mverifyy,ny))
          increasedist=0
          icenter=0
          for mn=0,mn<mvn,mn++ do
            for mx=mvx0,mx<=mvx1,mx++ do
              for my=mvy0,my<=mvy1,my++ do
                for g=0,g<ngroup,g++ do
                  ix=mverifyx+mx+group[g]/xstep
                  x=xoffset+ix*xstep
                  if cntrshift!=0 && ix>=0 x=x+xstep
                  while x<fromxloc do
                    x=x+xstep; ix++
                  enddo
                  while x>toxloc do
                    x=x-xstep; ix--
                  enddo
                  iy=mverifyy+my
                  iy=Max(-ny,Min(iy,ny))
                  y=yoffset+iy*vstep
                  if (boardtype==2 && iy==0) ||                                \
                    (boardtype==1 && (iy==(-4) || iy==0 || iy==4) &&           \
                    (testertype==TT_A3L || testertype==TT_A5 ||                \
                    testertype==TT_A5L)) ||                                    \
                    (boardtype==1 && ix==0 && iy==0 &&                         \
                    (testertype==TT_S1 || testertype==TT_S3))                  \
                    increasedist=1
                  if g==0 && mx==0 && my==0 icenter=ncal
                  if ncal<NCALIBR then
                    c[i].xa[ncal]=x
                    c[i].ya[ncal]=y
                    c[i].scandir[ncal]=0
                    c[i].z[ncal]=0
                    c[i].group[ncal]=g
                    ncal++
                  endif
                  if mverifymode==MVM_MULTI then
                    for j=0,j<4 && ncal<NCALIBR,j++ do
                      c[i].xa[ncal]=x+(j & 1?-MULTISTEP:MULTISTEP)
                      c[i].ya[ncal]=y+(j & 2?-MULTISTEP:MULTISTEP)
                      c[i].scandir[ncal]=0
                      c[i].z[ncal]=0
                      c[i].group[ncal]=j+1
                      ncal++
                    enddo
                  endif
                enddo
              enddo
            enddo
          enddo
          // For some vague reasons, central point must stay first in the
          // calibrator (its coordinates are displayed in the window).
          if icenter>0 then
            f=c[i].xa[0]; c[i].xa[0]=c[i].xa[icenter]; c[i].xa[icenter]=f
            f=c[i].ya[0]; c[i].ya[0]=c[i].ya[icenter]; c[i].ya[icenter]=f
          endif
          if increasedist then
            distance=distance+2.5
          endif
        else
          // Calibration or verification.
          m=Floor(encdist/vstep+0.5)
          if vstep*2*m<f then
            verdist=encdist*2
          else
            verdist=vstep*(m/2)
          endif
          leftprofilex=xoffset
          rightprofilex=xoffset
          for k=0,k<CORRX,k++ do
            if interlace==0 then
              xnode=k
            else if xstart+throwaway*xstep*2*k<=toxloc then
              xnode=2*k
            else
              xnode=2*(k-Floor((toxloc-xstart)/throwaway/xstep/2))-1
            endif
            x=xstart+throwaway*xstep*xnode
            if x>toxloc break
            if x<=(xoffset+xstart)/2.0 then
              leftprofilex=x
            else if x>=(xoffset+xend)/2.0 &&                                   \
              rightprofilex<xoffset+xstep/2.0 then
              rightprofilex=x
            endif
            if ncal>=NCALIBR break
            c[i].xa[ncal]=x
            c[i].ya[ncal]=ystart
            c[i].scandir[ncal]=0
            c[i].z[ncal]=0
            c[i].group[ncal]=0
            ncal++
            if mode==C_VER5 then
              // Verification, add lower extra row.
              if ncal>=NCALIBR break
              c[i].xa[ncal]=x
              c[i].ya[ncal]=yoffset-verdist
              if boardtype==1 && testertype==TT_A5L then
                m=verdist/(2.0*vstep)
                if m*2.0*vstep!=verdist then
                  c[i].ya[ncal]=c[i].ya[ncal]-vstep
                endif
              else if boardtype==1 && (testertype==TT_A3L ||                   \
                testertype==TT_A5 || testertype==TT_A5L) then
                if verdist==50.0 then
                  c[i].ya[ncal]=c[i].ya[ncal]+vstep*((xnode & 1)==0?1.0:-1.0)
                else if verdist==37.5 then
                  c[i].ya[ncal]=c[i].ya[ncal]+vstep*((xnode & 1)==0?0.0:-2.0)
                endif
              else if smallboard!=0 && boardtype==1 && testertype==TT_A7 then
                c[i].ya[ncal]=yoffset
              endif
              c[i].scandir[ncal]=0
              c[i].z[ncal]=0
              c[i].group[ncal]=0
              ncal++
            endif
            if (mode==C_CALIBR && precisey==PRY_3LINE) ||                      \
              mode==C_VER3 || mode==C_VER5                                     \
            then
              // 3-line calibration or verification, add central points.
              if ncal>=NCALIBR break
              if mode==C_CALIBR && throwaway>1 && (i & 1)==0 &&                \
                radius-Sqrt(radius*radius-encdist*encdist)>xstep/2.0 &&        \
                x+xstep<=toxloc then   // Correct to closest RO coordinate
                c[i].xa[ncal]=x+xstep
              else if mode==C_CALIBR && throwaway>1 && (i & 1)!=0 &&           \
                radius-Sqrt(radius*radius-encdist*encdist)>xstep/2.0 &&        \
                x-xstep>=fromxloc then // Correct to closest RO coordinate
                c[i].xa[ncal]=x-xstep
              else
                c[i].xa[ncal]=x
              endif
              if boardtype==1 && (testertype==TT_S1 || testertype==TT_S3) &&   \
                $LAY.rightlimit-$LAY.leftlimit<450000                          \
              then
                c[i].ya[ncal]=ycenter+vstep*((xnode & 1)==0?1.0:-1.0)
                c[i].scandir[ncal]=0
                c[i].z[ncal]=0
                c[i].group[ncal]=0
                ncal++
              else if boardtype!=1 ||                                          \
                (testertype!=TT_S1 && testertype!=TT_S3) ||                    \
                Abs(c[i].xa[ncal]-xoffset)>xstep/2.0                           \
              then
                // Note: no central cross for S1 big glass!
                c[i].ya[ncal]=ycenter
                if (boardtype==2 || (boardtype==1 &&                           \
                  (testertype==TT_A3L || testertype==TT_A5 ||                  \
                  testertype==TT_S2))) &&                                      \
                  headcamfidtype!=1 && headcamfidtype!=2                       \
                then
                  c[i].ya[ncal]=c[i].ya[ncal]+vstep*((xnode & 1)==0?1.0:-1.0)
                endif
                c[i].scandir[ncal]=0
                c[i].z[ncal]=0
                c[i].group[ncal]=0
                ncal++
              endif
            endif
            if mode==C_VER5 &&                                                 \
              (smallboard==0 || boardtype!=1 || testertype!=TT_A7)             \
            then
              // Verification, add upper extra row. Not applies for A7 with
              // A5 glass board - in fact, it uses 4-line calibration...
              if ncal>=NCALIBR break
              c[i].xa[ncal]=x
              c[i].ya[ncal]=yoffset+verdist
              if boardtype==1 && testertype==TT_A5L then
                m=verdist/(2.0*vstep)
                if m*2.0*vstep!=verdist then
                  c[i].ya[ncal]=c[i].ya[ncal]+vstep
                endif
              else if boardtype==1 && (testertype==TT_A3L ||                   \
                testertype==TT_A5) then
                if verdist==50.0 then
                  c[i].ya[ncal]=c[i].ya[ncal]+vstep*((xnode & 1)==0?1.0:-1.0)
                else if verdist==37.5 then
                  c[i].ya[ncal]=c[i].ya[ncal]+vstep*((xnode & 1)==0?2.0:0.0)
                endif
              endif
              c[i].scandir[ncal]=0
              c[i].z[ncal]=0
              c[i].group[ncal]=0
              ncal++
            endif
            if ncal>=NCALIBR break
            c[i].xa[ncal]=x
            c[i].ya[ncal]=yend
            c[i].scandir[ncal]=0
            c[i].z[ncal]=0
            c[i].group[ncal]=0
            ncal++
          enddo
          if mode==C_CALIBR && precisey==PRY_YPROF then
            c[i].leftprofilex=leftprofilex
            c[i].rightprofilex=rightprofilex
            if throwaway>=2 then
              step=2*vstep
            else
              step=vstep
            endif
            // 2-line calibration with Y profile, currently only S3.
            for m=0,m<2,m++ do         // Two columns
              if m==0 then
                x=leftprofilex
              else
                x=rightprofilex
              endif
              y=yoffset-vstep
              while y-step>Max(calymin-1.0,$LAY.bottom[i/2]/1000.0) do
                y=y-step
              enddo
              for y=y,y<$LAY.top[i/2]/1000.0,y=y+step do
                if boardtype!=0 && Abs(y-$LAY.yoffset[i/2]/1000.0)<vstep/2.0   \
                  continue             // May be fiducial
                if Abs(y-ystart)<vstep/2.0 || Abs(y-yend)<vstep/2.0            \
                  continue             // Already here
                if y>=calymax+1.0 break
                if ncal>=NCALIBR break
                c[i].xa[ncal]=x
                c[i].ya[ncal]=y
                c[i].scandir[ncal]=0
                c[i].z[ncal]=0
                c[i].group[ncal]=0
                ncal++
              enddo
            enddo
          endif
        endif
        if mode==C_SHY then
          ntotal=ntotal+ncal
        else if mode==C_MVERIFY && ncal==0 then
          err=3
          break
        else if mode!=C_CENTER && mode!=C_CENTER2 && mode!=C_MVERIFY &&        \
          ncal<4                                                               \
        then
          // At least 4 scan points necessary for meaningful (but inaccurate)
          // calibration.
          err=3
          break
        else if ncal>=NCALIBR then
          // Too many calibration points (dirty implementation: last two
          // elements never used).
          err=4
          break
        endif
        if mode==C_CALIBR && autoverify!=0 then
          c[i].xa[ncal]=c[i].xa[0]     // Duplicate first point to check
          c[i].ya[ncal]=c[i].ya[0]     // reproducibility.
          c[i].scandir[ncal]=0
          c[i].z[ncal]=0
          c[i].group[ncal]=0
          ncal++
        endif
        if calmode!=MODE_CAL && mode!=C_CENTER && mode!=C_CORNER &&            \
          mode!=C_CENTER2 && mode!=C_SHY                                       \
        then
          deltax=(videocenterx[0]+videocenterx[1])/2.0
          deltay=(videocentery[0]+videocentery[1])/2.0
        else
          deltax=0
          deltay=0
        endif
        for j=0,j<ncal,j++
          c[i].xm[j]=c[i].xa[j]+deltax
          c[i].ym[j]=c[i].ya[j]+deltay
        enddo
        c[i].ncal=ncal
        c[i].next=0
        c[i].step=0
        c[i].pending=0
        c[i].autoclean=0
        c[i].infield=0
        c[i].current=-1
        c[i].attempt=0
        c[i].errmsg[0]='\0'
        c[i].rescan=0
        c[i].usesref=-1
        if mode!=C_VER3 && mode!=C_VER5 && mode!=C_VERAREA &&                  \
          mode!=C_VERALL && mode!=C_VERHALF                                    \
          c[i].corrok=0                // Corrections not yet calculated
        c[i].shrink=0.0
      enddo
    endif
  else if type & FILL_HCAM then
    // Fill head camera calibration data.
    hh=Min($LAY.top[0]-$LAY.yoffset[0],                                        \
      $LAY.yoffset[0]-$LAY.bottom[0])/1000.0
    if testertype==TT_M2 then
      hh=hh-2.0; vstep=ystep
    else if testertype==TT_A5L && smallboard!=0 then
      hh=hh-30.0; vstep=ystep
    else if testertype==TT_A7 && smallboard!=0 && boardtype!=1 then
      hh=hh-25.0; vstep=12.5
    else if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
      hh=hh-55.0; vstep=12.5
    else
      hh=hh-5.0; vstep=ystep
    endif
    if mode==C_SHY then
      err=10; goto error               // Unsupported mode
    endif
    if usesides!=0 && ((usesides & testersides)==0 ||                          \
      ((usesides & 0x1)!=0 && (firsttop<0 || lasttop<0 || firsttop>lasttop)) ||\
      ((usesides & 0x2)!=0 && (firstbot<0 || lastbot<0 || firstbot>lastbot)))  \
    then
      err=8
    endif
    xoffset=$LAY.xoffset/1000.0+boardshift
    if err==0 then
      SYS.Videosize(0,videowidth,videoheight,&i)
      if illumination==0 then
        throughdx=0.0
        throughdy=0.0
      else
        throughdx=-oppdx
        throughdy=0.0
      endif
      xstart=xoffset; xend=xstart
      while xstart-throwaway*xstep>=fromxloc do
        xstart=xstart-throwaway*xstep
      enddo
      while xend+throwaway*xstep<=toxloc do
        xend=xend+throwaway*xstep
      enddo
      // Leave room for the opposite camera in shinethrough illumination.
      if illumination==1 && cameras==0 && headcams!=0 then
        if xstart<$LAY.leftlimit/1000.0+15.0 then
          xstart=xstart+throwaway*xstep
        endif
        if xend>$LAY.rightlimit/1000.0-15.0 then
          xend=xend-throwaway*xstep
        endif
      endif
      for i=0,i<nfing*2,i++ do         // Initialize parameters
        yoffset=$LAY.yoffset[i/2]/1000.0
        c[i].mode=0
        c[i].type=FILL_HCAM
        c[i].ncal=0
        if mode==C_MVERIFY && mverifyrail>=0 && i/2!=mverifyrail               \
          continue                     // Not a manual verification rail
        if ($LAY.top[i/2]==0 && $LAY.bottom[i/2]==0)                           \
          continue                     // Skip dummy rails
        if $LAY.excludedrails & (1<<(i/2))                                     \
          continue                     // Skip excluded rails
        if (headcams & (1<<i))==0                                              \
          continue                     // No asociated head camera, skip
        if ((1<<$LAY.side[i/2]) & usesides)==0                                 \
          continue                     // Side is excluded from calibration
        if ($LAY.config & LC_VACUUMBOX)!=0 && $LAY.side[i/2]!=0                \
          continue                     // Bottom side is excluded by vacuum box
        if (i<firsttop*2 || i>lasttop*2+1) && (i<firstbot*2 || i>lastbot*2+1)  \
          continue                     // Rail is excluded from calibration
        c[i].widthx=linewidth
        c[i].widthy=linewidth
        if boardtype==1 && (testertype==TT_S1 || testertype==TT_S3) &&         \
          $LAY.rightlimit-$LAY.leftlimit<450000 then
          dy=77.5
          ystart=yoffset-dy
          ycenter=yoffset
          yend=yoffset+dy
          c[i].asymmetric=0
        else if boardtype==0 || (boardtype==1 && testertype==TT_S1) then
          dy=encdist
          ystart=yoffset-encdist
          ycenter=yoffset
          yend=yoffset+encdist
          c[i].asymmetric=0
        else if testertype==TT_A5L && boardtype==1 then
          y=$LAY.top[0]/1000.0
          dy=vstep*4
          while y>=$LAY.bottom[i/2]/1000.0 do
            y=y-dy
          enddo
          while y<=$LAY.bottom[i/2]/1000.0 do
            y=y+dy
          enddo
          ystart=y; ycenter=y
          while y+dy<$LAY.top[i/2]/1000.0 do
            y=y+dy
            if Abs(y-yoffset)<Abs(ycenter-yoffset) then
              ycenter=y
            endif
          enddo
          yend=y
          c[i].asymmetric=1
        else if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
          dy=vstep*4
          if yoffset<$LAY.top[smallfirst]/1000.0 then
            ystart=yoffset-6*vstep
            ycenter=yoffset+2*vstep
            yend=yoffset+10*vstep
          else
            ystart=yoffset-10*vstep
            ycenter=yoffset-2*vstep
            yend=yoffset+6*vstep
          endif
          c[i].asymmetric=1
        else if testertype==TT_A7 && smallboard==0 && boardtype==1 then
          while xstart<xoffset-232.5 do
            xstart=xstart+throwaway*xstep
          enddo
          while xend>xoffset+232.5 do
            xend=xend-throwaway*xstep
          enddo
          dy=125.0                     // Out of raster
          ystart=yoffset-dy
          ycenter=yoffset
          yend=yoffset+dy
          c[i].asymmetric=0
        else
          ystart=yoffset; yend=ystart
          dy=(testertype==TT_A2H?2*videoy:videoy)
          while ystart-dy>=$LAY.bottom[i/2]/1000.0 do
            ystart=ystart-dy
          enddo
          ycenter=yoffset
          while yend+dy<=$LAY.top[i/2]/1000.0 do
            yend=yend+dy
          enddo
          c[i].asymmetric=0
        endif
        c[i].bottomliney=ystart
        c[i].centercamy=ycenter
        c[i].centerliney=ycenter
        c[i].topliney=yend
        c[i].encdist=dy
        c[i].radius=headcamradius
        c[i].scandist=20.0             // Default
        ncal=0
        ny=hh/vstep
        if mode==C_CENTER || mode==C_CENTER2 then
          // Scan cross most close to the rail center (one or two directions).
          c[i].xa[0]=xoffset
          dx=1.0e10
          for j=-CORRX/2,j<=CORRX/2,j++ do
            x=xoffset+j*xstep
            if x<fromxloc-0.001 continue
            if x>toxloc+0.001 break
            deltax=Abs($LAY.xoffset/1000.0-x)
            if deltax<dx then
              dx=deltax
              c[i].xa[0]=x
            endif
          enddo
          c[i].ya[0]=ycenter
          if mode==C_CENTER then
            c[i].scandir[0]=0
            c[i].group[0]=0
            ncal=1
          else
            c[i].scandir[0]=4
            c[i].group[0]=0
            c[i].xa[1]=$LAY.xoffset/1000.0
            c[i].ya[1]=ycenter
            c[i].scandir[1]=8
            c[i].group[0]=0
            ncal=2
          endif
        else if mode==C_CORNER then
          // Precalibration.
          c[i].xa[0]=xstart
          c[i].ya[0]=ystart
          c[i].scandir[0]=0
          c[i].group[0]=0
          c[i].xa[1]=xstart
          c[i].ya[1]=yend
          c[i].scandir[1]=0
          c[i].group[1]=0
          c[i].xa[2]=xend
          c[i].ya[2]=ystart
          c[i].scandir[2]=0
          c[i].group[2]=0
          c[i].xa[3]=xend
          c[i].ya[3]=yend
          c[i].scandir[3]=0
          c[i].group[3]=0
          ncal=4
        else if mode==C_VERAREA || mode==C_VERALL || mode==C_VERHALF then
          if boardtype==0 ||                                                   \
            (boardtype==1 && (testertype==TT_S1 || testertype==TT_S3)) then
            // Verification of the whole area, same as electrical verification.
            k=0
            for x=xstart,x<=tox,x=x+xstep do
              for m=-ny,m<=ny,m++ do
                if boardtype==2 && m==0 continue
                k++
                if boardtype==1 && (testertype==TT_A3L ||                      \
                  testertype==TT_A5 || testertype==TT_A5L) then
                  if m==(-4) || m==0 || m==4 continue
                  if mode==C_VERAREA && k%2!=0 continue
                else
                  if mode==C_VERAREA && k%4!=0 continue
                endif
                if ncal>=NCALIBR break
                // No central cross for S1 big glass!
                if boardtype!=1 || (testertype!=TT_S1 && testertype!=TT_S3) || \
                  Abs(x-xoffset)>xstep/2.0 || Abs(m*vstep>vstep/2.0)           \
                then
                  c[i].xa[ncal]=x
                  c[i].ya[ncal]=yoffset+m*vstep
                  c[i].scandir[ncal]=0
                  c[i].group[ncal]=0
                  ncal++
                endif
              enddo
            enddo
          else if boardtype==1 && testertype==TT_A5L then
            // All available fiducials on the small board.
            for x=xstart,x<=xend,x=x+xstep do
              for y=ystart,y<=yend,y=y+dy do
                if ncal>=NCALIBR break
                c[i].xa[ncal]=x
                c[i].ya[ncal]=y
                c[i].scandir[ncal]=0
                c[i].group[ncal]=0
                ncal++
              enddo
            enddo
          else
            // All available fiducials on the glass.
            for y=ystart,y<=yend,y=y+dy do
              for x=xstart,x<=xend,x=x+xstep do
                if ncal>=NCALIBR break
                c[i].xa[ncal]=x
                c[i].ya[ncal]=y
                c[i].scandir[ncal]=0
                c[i].group[ncal]=0
                ncal++
              enddo
            enddo
          endif
        else if mode==C_MVERIFY then   // Manual verification
          if mverifymode==MVM_MULTI then
            group[0]=0.0
            cntrshift=0; ngroup=1
          else
            switch mverifygroups
            case MVG_2X175:            // Verify two groups at 175 mm
              group[0]=0.0; group[1]=175.0
              cntrshift=0; ngroup=2
            case MVG_3X75:             // Verify three groups at 75 mm
              group[0]=0.0; group[1]=75.0; group[2]=150.0
              cntrshift=0; ngroup=3
            case MVG_3X100:            // Verify three groups at 100 mm
              group[0]=0.0; group[1]=100.0; group[2]=200.0
              cntrshift=1; ngroup=3
            case MVG_3X150:            // Verify three groups at 150 mm
              group[0]=0.0; group[1]=150.0; group[2]=300.0
              cntrshift=0; ngroup=3
            default:                   // Verify single group
              group[0]=0.0
              cntrshift=0; ngroup=1
            endsw
          endif
          switch mverifymode
          case MVM_X3:                 // Verify single cross 3 times
            mvx0=0;  mvx1=0; mvy0=0;  mvy1=0; mvn=3
          case MVM_X10:                // Verify single cross 10 times
            mvx0=0;  mvx1=0; mvy0=0;  mvy1=0; mvn=10
          case MVM_1X3:                // Verify 1x3 crosses
            mvx0=0;  mvx1=0; mvy0=-1; mvy1=1; mvn=1
          case MVM_2X3:                // Verify 2x3 crosses
            mvx0=0;  mvx1=1; mvy0=-1; mvy1=1; mvn=1
          case MVM_3X3:                // Verify 3x3 crosses
            mvx0=-1; mvx1=1; mvy0=-1; mvy1=1; mvn=1
          case MVM_1X5:                // Verify 1x5 crosses
            mvx0=0;  mvx1=0; mvy0=-2; mvy1=2; mvn=1
          case MVM_2X5:                // Verify 2x5 crosses
            mvx0=0;  mvx1=1; mvy0=-2; mvy1=2; mvn=1
          case MVM_3X5:                // Verify 3x5 crosses
            mvx0=-1; mvx1=1; mvy0=-2; mvy1=2; mvn=1
          default:                     // Verify single cross
            mvx0=0;  mvx1=0; mvy0=0;  mvy1=0; mvn=1
          endsw
          while xoffset+xstep*mverifyx<fromxloc do
            mverifyx++
          enddo
          while xoffset+xstep*mverifyx>toxloc do
            mverifyx--
          enddo
          // If single cross is requested, allow fiducials on the borders.
          if mvn==1 && mvx0==mvx1 && mvy0==mvy1 && ngroup==1 then
            mverifyy=Max(-ny-1,Min(mverifyy,ny+1))
            y=yoffset+mverifyy*vstep
            if y<$LAY.bottom[i/2]/1000.0 y=$LAY.bottom[i/2]/1000.0
            if y>$LAY.top[i/2]/1000.0 y=$LAY.top[i/2]/1000.0
            if y<calymin mverifyy++
            if y>calymax mverifyy--
          else
            mverifyy=Max(-ny,Min(mverifyy,ny))
          endif
          icenter=0
          for mn=0,mn<mvn,mn++ do
            for mx=mvx0,mx<=mvx1,mx++ do
              for my=mvy0,my<=mvy1,my++ do
                for g=0,g<ngroup,g++ do
                  ix=mverifyx+mx+group[g]/xstep
                  x=xoffset+ix*xstep
                  if cntrshift!=0 && ix>=0 x=x+xstep
                  while x<fromxloc do
                    x=x+xstep; ix++
                  enddo
                  while x>toxloc do
                    x=x-xstep; ix--
                  enddo
                  iy=mverifyy+my
                  if !(mvn==1 && mvx0==mvx1 && mvy0==mvy1 && ngroup==1) then
                    iy=Max(-ny,Min(iy,ny))
                  endif
                  y=yoffset+iy*vstep
                  if y<$LAY.bottom[i/2]/1000.0 y=$LAY.bottom[i/2]/1000.0
                  if y>$LAY.top[i/2]/1000.0 y=$LAY.top[i/2]/1000.0
                  if (boardtype==2 && iy==0) ||                                \
                    (boardtype==1 && (iy==(-4) || iy==0 || iy==4) &&           \
                    (testertype==TT_A3L || testertype==TT_A5 ||                \
                    testertype==TT_A5L)) ||                                    \
                    (boardtype==1 && ix==0 && iy==0 &&                         \
                    (testertype==TT_S1 || testertype==TT_S3))                  \
                    increasedist=1
                  if g==0 && mx==0 && my==0 icenter=ncal
                  if ncal<NCALIBR then
                    c[i].xa[ncal]=x
                    c[i].ya[ncal]=y
                    c[i].scandir[ncal]=0
                    c[i].group[ncal]=g
                    ncal++
                  endif
                  if mverifymode==MVM_MULTI then
                    for j=0,j<4 && ncal<NCALIBR,j++ do
                      c[i].xa[ncal]=x+(j & 1?-MULTISTEP:MULTISTEP)
                      c[i].ya[ncal]=y+(j & 2?-MULTISTEP:MULTISTEP)
                      c[i].scandir[ncal]=0
                      c[i].group[ncal]=j+1
                      ncal++
                    enddo
                  endif
                enddo
              enddo
            enddo
          enddo
          // Central point must stay first in the calibrator.
          if icenter>0 then
            f=c[i].xa[0]; c[i].xa[0]=c[i].xa[icenter]; c[i].xa[icenter]=f
            f=c[i].ya[0]; c[i].ya[0]=c[i].ya[icenter]; c[i].ya[icenter]=f
          endif
        else if mode==C_9N then
          // Cross at (mverifyxpos,mverifyypos) repeated 9*mverifycount times.
          if $LAY.bottom[i/2]==$LAY.bottom[mverifyrail] &&                     \
            $LAY.top[i/2]==$LAY.top[mverifyrail] &&                            \
            mverifyypos>=$LAY.bottom[i/2]/1000.0 &&                            \
            mverifyypos<=$LAY.top[i/2]/1000.0 then
            // First loop is ordered, all other are random.
            c[i].mode=c[i].mode|CM_CORRXY
            if mverifydir==0x3 then      // Only X movements
              order[0]=0; order[1]=1; order[2]=5; order[3]=1; order[4]=5
              order[5]=1; order[6]=5; order[7]=1; order[8]=5
            else if mverifydir==0xC then // Only Y movements
              order[0]=0; order[1]=3; order[2]=7; order[3]=3; order[4]=7
              order[5]=3; order[6]=7; order[7]=3; order[8]=7
            else if mverifydir==0x1 then // Only movements from left
              order[0]=0; order[1]=5; order[2]=5; order[3]=5; order[4]=5
              order[5]=5; order[6]=5; order[7]=5; order[8]=5
            else if mverifydir==0x2 then // Only movements from right
              order[0]=0; order[1]=1; order[2]=1; order[3]=1; order[4]=1
              order[5]=1; order[6]=1; order[7]=1; order[8]=1
            else if mverifydir==0x4 then // Only movements from top
              order[0]=0; order[1]=7; order[2]=7; order[3]=7; order[4]=7
              order[5]=7; order[6]=7; order[7]=7; order[8]=7
            else if mverifydir==0x8 then // Only movements from bottom
              order[0]=0; order[1]=3; order[2]=3; order[3]=3; order[4]=3
              order[5]=3; order[6]=3; order[7]=3; order[8]=3
            else                         // All movements
              order[0]=0; order[1]=1; order[2]=2; order[3]=3; order[4]=4
              order[5]=5; order[6]=6; order[7]=7; order[8]=8
            endif
            for j=0,j<Max(mverifycount,1),j++ do
              if ncal>=NCALIBR break
              for k=0,k<9,k++ do
                if ncal>=NCALIBR break
                c[i].xa[ncal]=mverifyxpos
                c[i].ya[ncal]=mverifyypos
                c[i].scandir[ncal]=order[k]
                c[i].group[ncal]=0
                ncal++
              enddo
              for k=0,k<9,k++ do
                m=Random(k)
                q=order[k]; order[k]=order[m]; order[m]=q
              enddo
            enddo
          endif
        else
          m=Floor(encdist/vstep+0.5)
          // Note: verdist applies to FR4 board only!
          if vstep*2*m<hh then
            verdist=encdist*2
          else
            verdist=vstep*(m/2)
          endif
          for k=0,k<CORRX,k++ do
            if interlace==0 then
              xnode=k
            else if xstart+throwaway*xstep*2*k<=tox then
              xnode=2*k
            else
              xnode=2*(k-Floor((tox-xstart)/throwaway/xstep/2))-1
            endif
            x=xstart+throwaway*xstep*xnode
            if x<xstart continue
            if x>xend break
            // Main lower row.
            if ncal>=NCALIBR break
            c[i].xa[ncal]=x
            c[i].ya[ncal]=ystart
            c[i].scandir[ncal]=0
            c[i].group[ncal]=0
            ncal++
            if mode==C_VER5 && (boardtype==0 || (boardtype==1 &&               \
              (testertype==TT_A3L || testertype==TT_A5 ||                      \
              testertype==TT_A5L))) then
              // Verification, add lower extra row.
              if ncal>=NCALIBR break
              c[i].xa[ncal]=x
              if boardtype==0 then
                c[i].ya[ncal]=yoffset-verdist
              else
                c[i].ya[ncal]=yoffset-videoy
              endif
              c[i].scandir[ncal]=0
              c[i].group[ncal]=0
              ncal++
            endif
            if (mode==C_CALIBR &&                                              \
              (precisey==PRY_3LINE || precisey==PRY_YPROF) &&                  \
              (boardtype!=1 || testertype!=TT_A5L) &&                          \
              (boardtype!=1 || smallboard==0 || testertype!=TT_A7)) ||         \
              mode==C_VER3 || mode==C_VER5                                     \
            then
              // 3-line calibration or 3/5-line verification, add central line.
              if ncal>=NCALIBR break
              f=(yend-ystart)/2.0
              dx=headcamradius-Sqrt(headcamradius*headcamradius-f*f)
              if mode==C_CALIBR && throwaway>1 && (i & 1)==0 &&                \
                dx>xstep/2.0 && x+xstep<=toxloc then
                c[i].xa[ncal]=x+xstep  // Correct to closest RO coordinate
              else if mode==C_CALIBR && throwaway>1 && (i & 1)!=0 &&           \
                dx>xstep/2.0 && x-xstep>=fromxloc then
                c[i].xa[ncal]=x-xstep  // Correct to closest RO coordinate
              else
                c[i].xa[ncal]=x
              endif
              // No central cross for S1 big glass!
              if boardtype!=1 || (testertype!=TT_S1 && testertype!=TT_S3) ||   \
                $LAY.rightlimit-$LAY.leftlimit<450000 ||                       \
                Abs(c[i].xa[ncal]-$LAY.xoffset/1000.0)>xstep/2.0               \
              then
                c[i].ya[ncal]=ycenter
                c[i].scandir[ncal]=0
                c[i].group[ncal]=0
                ncal++
              endif
            endif
            if mode==C_VER5 && (boardtype==0 || (boardtype==1 &&               \
              (testertype==TT_A3L || testertype==TT_A5 ||                      \
              testertype==TT_A5L))) then
              // Verification, add upper extra row.
              if ncal>=NCALIBR break
              c[i].xa[ncal]=x
              if boardtype==0 then
                c[i].ya[ncal]=yoffset+verdist
              else
                c[i].ya[ncal]=yoffset+videoy
              endif
              c[i].scandir[ncal]=0
              c[i].group[ncal]=0
              ncal++
            endif
            // Main upper row.
            if ncal>=NCALIBR break
            c[i].xa[ncal]=x
            c[i].ya[ncal]=yend
            c[i].scandir[ncal]=0
            c[i].group[ncal]=0
            ncal++
          enddo
        endif
        if mode==C_MVERIFY && ncal==0 then
          err=3
          break
        else if mode!=C_CENTER && mode!=C_CENTER2 && mode!=C_MVERIFY &&        \
          mode!=C_9N && ncal<4 then
          // At least 4 scan points necessary for meaningful (but inaccurate)
          // calibration.
          err=3; break
        else if ncal>=NCALIBR then
          // Too many calibration points (dirty implementation: last two
          // elements never used).
          err=4; break
        endif
        if mode==C_CALIBR && autoverify!=0 then
          c[i].xa[ncal]=c[i].xa[0]     // Duplicate first point to check
          c[i].ya[ncal]=c[i].ya[0]     // reproducibility.
          c[i].scandir[ncal]=0
          c[i].group[ncal]=0
          ncal++
        endif
        if calmode!=MODE_CAL &&                                                \
          mode!=C_CENTER && mode!=C_CORNER && mode!=C_CENTER2                  \
        then
          deltax=(videocenterx[0]+videocenterx[1])/2.0
          deltay=(videocentery[0]+videocentery[1])/2.0
        else
          deltax=0
          deltay=0
        endif
        for j=0,j<ncal,j++
          c[i].xm[j]=c[i].xa[j]+deltax
          c[i].ym[j]=c[i].ya[j]+deltay
        enddo
        c[i].ncal=ncal
        c[i].next=0
        c[i].step=0
        c[i].pending=0
        c[i].autoclean=0
        c[i].infield=0
        c[i].current=-1
        c[i].attempt=0
        c[i].errmsg[0]='\0'
        c[i].rescan=0
        c[i].usesref=-1
        if mode!=C_VER3 && mode!=C_VER5 && mode!=C_VERAREA &&                  \
          mode!=C_VERALL && mode!=C_VERHALF                                    \
          c[i].corrok=0                // Corrections not yet calculated
        c[i].shrink=0.0
      enddo
    endif
  endif
  if (type & FILL_VIDEO)!=0 && err==0 && $LAY.cameras!=0 then
    // Fill camera calibration data. Attention, fromxloc and toxloc must be
    // already defined by calling this routine for the head calibration! 
    if mode==C_SHY then
      err=10; goto error               // Unsupported mode
    endif
    if ($LAY.cameras & 1) SYS.Videosize(0,videowidth+0,videoheight+0,&i)
    if ($LAY.cameras & 2) SYS.Videosize(1,videowidth+1,videoheight+1,&i)
    if illumination==0 then
      throughdx=0.0
      throughdy=0.0
    else if ($LAY.cameras & 3)!=3 then
      err=7                            // Shinethru is not possible
    else
      throughdx=-oppdx
      throughdy=0.0
    endif
    xoffset=$LAY.xoffset/1000.0+boardshift
    xstart=xoffset
    xend=xoffset
    step=throwaway*xstep
    if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      deltax=0.0
    else if boardtype==2 then
      deltax=0.0
    else
      deltax=maxdelta
    endif
    while xstart-step>=videofromx+deltax &&                                    \
      xstart-step>=fromxloc &&                                                 \
      xstart-step+throughdx>=($LAY.leftlimit+$LAY.videodeadx)/1000.0 do
      xstart=xstart-step
    enddo
    while xend+throwaway*xstep<=videotox-deltax &&                             \
      xend+throwaway*xstep<=toxloc &&                                          \
      xend+throwaway*xstep+throughdx<=videotox-maxdelta do
      xend=xend+throwaway*xstep
    enddo
    ystart=$LAY.yoffset[$LAY.nfing]/1000.0
    yend=ystart
    if testertype==TT_S3 then
      // Video calibration on intermediate crosses is allowed.
      if videoyfromcrate!=videoy then
        dy=videoy; err=9               // Old Crate!
      else if videoy<=20.0 && throwaway>=2 then
        dy=2*videoy
      else
        dy=videoy
      endif
    else if testertype==TT_A2H then
      dy=2*videoy
    else
      dy=videoy
    endif
    while ystart-dy>=$LAY.bottom[nfing]/1000.0+maxdelta &&                     \
      ystart-dy+throughdy>=$LAY.bottom[nfing]/1000.0+maxdelta &&               \
      (testertype!=TT_A5L || smallboard==0 ||                                  \
      ystart-dy>=$LAY.bottom[smallfirst]/1000.0+25.0) &&                       \
      (testertype!=TT_A7 || smallboard==0 || boardtype==1 ||                   \
      ystart-dy>=$LAY.bottom[smallfirst]/1000.0+25.0) &&                       \
      (testertype!=TT_A7 || smallboard==0 || boardtype!=1 ||                   \
      ystart-dy>=$LAY.bottom[smallfirst]/1000.0+55.0)                          \
    do
      ystart=ystart-dy                 // Attention, may be imprecise if S3!
    enddo
    while yend+dy<=$LAY.top[nfing]/1000.0-maxdelta &&                          \
      yend+dy+throughdy<=$LAY.top[nfing]/1000.0-maxdelta &&                    \
      (testertype!=TT_A5L || smallboard==0 ||                                  \
      yend+dy<=$LAY.top[smalllast]/1000.0-25.0) &&                             \
      (testertype!=TT_A7 || smallboard==0 || boardtype==1 ||                   \
      yend+dy<=$LAY.top[smalllast]/1000.0-25.0) &&                             \
      (testertype!=TT_A7 || smallboard==0 || boardtype!=1 ||                   \
      yend+dy<=$LAY.top[smalllast]/1000.0-55.0)                                \
    do
      yend=yend+dy                     // Attention, may be imprecise if S3!
    enddo
    if xstart>=xend err=6
    if ystart>=yend err=5
    for i=0,i<2 && err==0,i++ do
      head=$LAY.nfing*2+i
      c[head].mode=0
      c[head].type=FILL_VIDEO
      c[head].ncal=0
      if (cameras & (0x01<<i))==0                                              \
        continue                       // Camera is absent or excluded
      if ($LAY.config & LC_VACUUMBOX)!=0 && i==1                               \
        continue                       // Bottom camera excluded by vacuum box
      c[head].widthx=linewidth
      c[head].widthy=linewidth
      c[head].encdist=0.0
      c[head].radius=0.0
      c[head].scandist=20.0            // Default
      ncal=0
      if mode==C_CENTER then
        // Scan fiducial most close to the center of the rail.
        c[head].xa[0]=xoffset
        dx=1.0e10
        for j=-CORRX/2,j<=CORRX/2,j++ do
          x=xoffset+j*xstep
          if x<fromxloc-0.001 continue
          if x>toxloc+0.001 break
          deltax=Abs($LAY.xoffset/1000.0-x)
          if deltax<dx then
            dx=deltax
            c[head].xa[0]=x
          endif
        enddo
        c[head].ya[0]=$LAY.yoffset[nfing]/1000.0
        c[head].scandir[0]=0
        c[head].group[0]=0
        ncal=1
      else if mode==C_CORNER || mode==C_PRECAL then
        // Precalibration, 4 edge points to reduce duration of movements.
        c[head].xa[0]=xend
        c[head].ya[0]=Nearestcameray(yend)
        c[head].scandir[0]=0
        c[head].group[0]=0
        c[head].xa[1]=xend
        c[head].ya[1]=Nearestcameray(ystart)
        c[head].scandir[1]=0
        c[head].group[1]=0
        c[head].xa[2]=xstart
        c[head].ya[2]=Nearestcameray(ystart)
        c[head].scandir[2]=0
        c[head].group[2]=0
        c[head].xa[3]=xstart
        c[head].ya[3]=Nearestcameray(yend)
        c[head].scandir[3]=0
        c[head].group[3]=0
        ncal=4
        if mode==C_PRECAL then
          // Top-to-bottom offset, add several central points.
          if boardtype==0 then
            c[head].xa[4]=xoffset-2*xstep
            c[head].ya[4]=$LAY.yoffset[nfing]/1000.0
            c[head].scandir[4]=0
            c[head].group[4]=0
            c[head].xa[5]=xoffset
            c[head].ya[5]=$LAY.yoffset[nfing]/1000.0
            c[head].scandir[5]=0
            c[head].group[5]=0
            c[head].xa[6]=xoffset+2*xstep
            c[head].ya[6]=$LAY.yoffset[nfing]/1000.0
            c[head].scandir[6]=0
            c[head].group[6]=0
            ncal=7
          else
            c[head].xa[4]=xoffset
            c[head].ya[4]=$LAY.yoffset[nfing]/1000.0
            c[head].scandir[4]=0
            c[head].group[4]=0
            ncal=5
          endif
        endif
      else if mode==C_CALIBR then
        // Main video calibration.
        c[head].mode=CM_CORRECT
        // Calculate number of calibration rows. It must be at least 2.
        ny=0
        for y=ystart,y<=yend,y=y+dy do
          ny++
        enddo
        if ny<2 then
          err=5; break
        endif
        c[head].xa[0]=xstart
        c[head].ya[0]=Nearestcameray(ystart)
        c[head].scandir[0]=0
        c[head].group[0]=0
        c[head].xa[1]=xstart
        c[head].ya[1]=Nearestcameray(yend)
        c[head].scandir[1]=0
        c[head].group[1]=0
        c[head].xa[2]=xend
        c[head].ya[2]=Nearestcameray(yend)
        c[head].scandir[2]=0
        c[head].group[2]=0
        c[head].xa[3]=xend
        c[head].ya[3]=Nearestcameray(ystart)
        c[head].scandir[3]=0
        c[head].group[3]=0
        ncal=4
        if testertype==TT_S3 then
          // Preferrable direction is left-right.
          ny=0
          for y=ystart,y<=yend,y=y+dy do
            if (ny & 1)==0 then        // Left to right
              nx=0
              for x=xstart,x<=xend,x=x+throwaway*xstep do
                nx++                   // Necessary for verification
                if (x==xstart || x==xend) && (y==ystart || y==yend) continue
                c[head].xa[ncal]=x
                c[head].ya[ncal]=Nearestcameray(y)
                c[head].scandir[ncal]=0
                c[head].group[ncal]=0
                ncal++
              enddo
            else                       // Right to left
              nx=0
              for x=xstart,x<=xend,x=x+throwaway*xstep do
                xlast=x
                nx++
              enddo
              for x=xlast,x>=xstart,x=x-throwaway*xstep do
                if (x==xstart || x==xend) && (y==ystart || y==yend) continue
                c[head].xa[ncal]=x
                c[head].ya[ncal]=Nearestcameray(y)
                c[head].scandir[ncal]=0
                c[head].group[ncal]=0
                ncal++
              enddo
            endif
            ny++
          enddo
        else
          // Preferrable direction is up-down.
          nx=0
          for x=xstart,x<=xend,x=x+throwaway*xstep do
            if (nx & 1)==0 then        // Upwards
              for y=ystart,y<=yend,y=y+dy do
                if (x==xstart || x==xend) && (y==ystart || y==yend) continue
                c[head].xa[ncal]=x
                c[head].ya[ncal]=y
                c[head].scandir[ncal]=0
                c[head].group[ncal]=0
                ncal++
              enddo
            else                       // Downwards
              for y=yend,y>=ystart,y=y-dy do
                if (x==xstart || x==xend) && (y==ystart || y==yend) continue
                c[head].xa[ncal]=x
                c[head].ya[ncal]=y
                c[head].scandir[ncal]=0
                c[head].group[ncal]=0
                ncal++
              enddo
            endif
            nx++
          enddo
        endif
        if nx<2 then
          err=6; break
        endif
        if autoverify!=0 then
          // Duplicate first point to check reproducibility.
          c[head].xa[ncal]=c[head].xa[0]
          c[head].ya[ncal]=c[head].ya[0]
          c[head].scandir[ncal]=0
          c[head].group[ncal]=0
          ncal++
        endif
      else if mode==C_VER3 then
        // Verification.
        for x=xstart,x<=xend,x=x+throwaway*xstep do
          if (nx & 1)==0 then          // Upwards
            for y=ystart,y<=yend,y=y+dy do
              c[head].xa[ncal]=x
              c[head].ya[ncal]=Nearestcameray(y)
              c[head].scandir[ncal]=0
              c[head].group[ncal]=0
              ncal++
            enddo
          else                         // Downwards
            for y=yend,y>=ystart,y=y-dy do
              c[head].xa[ncal]=x
              c[head].ya[ncal]=Nearestcameray(y)
              c[head].scandir[ncal]=0
              c[head].group[ncal]=0
              ncal++
            enddo
          endif
        enddo
      else if (mode==C_VER5 && (boardtype==0 || testertype==TT_S3)) ||         \
        mode==C_MVERIFY then
        // Same crosses that heads use during calibration or verification.
        // ATTENTION, head calibrators must be filled with data!
        for j=0,j<$LAY.nfing*2,j=j+2 do
          if c[j].ncal==0 continue
          if mode==C_MVERIFY && i!=$LAY.side[j] continue
          for k=0, k<c[j].ncal, k++ do
            x=c[j].xa[k]
            if x-maxdelta+throughdx<videofromx continue
            if x+maxdelta-throughdx>videotox continue
            y=c[j].ya[k]
            if y-maxdelta<videofromy continue
            if y+maxdelta>videotoy continue
            if ncal>=NCALIBR break
            c[head].xa[ncal]=x
            c[head].ya[ncal]=y
            c[head].scandir[ncal]=0
            c[head].group[ncal]=c[j].group[k]
            ncal++
          enddo
        enddo
      else if mode==C_CENTER2 then
        // Scan central points in two directions.
        c[head].xa[0]=xoffset
        dx=1.0e10
        for j=-CORRX/2,j<=CORRX/2,j++ do
          x=xoffset+j*xstep
          if x<fromxloc-0.001 continue
          if x>toxloc+0.001 break
          deltax=Abs($LAY.xoffset/1000.0-x)
          if deltax<dx then
            dx=deltax
            c[head].xa[0]=x
          endif
        enddo
        c[head].ya[0]=$LAY.yoffset[nfing]/1000.0
        c[head].scandir[0]=4
        c[head].group[0]=0
        c[head].xa[1]=c[head].xa[0]
        c[head].ya[1]=$LAY.yoffset[nfing]/1000.0
        c[head].scandir[1]=8
        c[head].group[1]=0
        ncal=2
      else if mode==C_9N then
        // Cross at (mverifyxpos,mverifyypos) repeated 9*mverifycount times.
        if mverifyxpos-maxdelta+throughdx>=videofromx &&                       \
          mverifyxpos+maxdelta-throughdx<=videotox &&                          \
          mverifyypos-maxdelta>=videofromy &&                                  \
          mverifyypos+maxdelta<=videotoy                                       \
        then
          c[head].mode=c[i].mode|CM_CORRXY
          // First loop is ordered, all other are random.
          if mverifydir==0x3 then        // Only X movements
            order[0]=0; order[1]=1; order[2]=5; order[3]=1; order[4]=5
            order[5]=1; order[6]=5; order[7]=1; order[8]=5
          else if mverifydir==0xC then   // Only Y movements
            order[0]=0; order[1]=3; order[2]=7; order[3]=3; order[4]=7
            order[5]=3; order[6]=7; order[7]=3; order[8]=7
          else if mverifydir==0x1 then   // Only movements from left
            order[0]=0; order[1]=5; order[2]=5; order[3]=5; order[4]=5
            order[5]=5; order[6]=5; order[7]=5; order[8]=5
          else if mverifydir==0x2 then   // Only movements from right
            order[0]=0; order[1]=1; order[2]=1; order[3]=1; order[4]=1
            order[5]=1; order[6]=1; order[7]=1; order[8]=1
          else if mverifydir==0x4 then   // Only movements from top
            order[0]=0; order[1]=7; order[2]=7; order[3]=7; order[4]=7
            order[5]=7; order[6]=7; order[7]=7; order[8]=7
          else if mverifydir==0x8 then   // Only movements from bottom
            order[0]=0; order[1]=3; order[2]=3; order[3]=3; order[4]=3
            order[5]=3; order[6]=3; order[7]=3; order[8]=3
          else                           // All movements
            order[0]=0; order[1]=1; order[2]=2; order[3]=3; order[4]=4
            order[5]=5; order[6]=6; order[7]=7; order[8]=8
          endif
          for j=0,j<Max(mverifycount,1),j++ do
            if ncal>=NCALIBR break
            for k=0,k<9,k++ do
              if ncal>=NCALIBR break
              c[head].xa[ncal]=mverifyxpos
              c[head].ya[ncal]=mverifyypos
              c[head].scandir[ncal]=order[k]
              c[head].group[ncal]=0
              ncal++
            enddo
            for k=0,k<9,k++ do
              m=Random(k)
              q=order[k]; order[k]=order[m]; order[m]=q
            enddo
          enddo
        endif
      else if boardtype==0 then
        // Crosses evenly distributed over the whole board.
        k=0
        for x=xstart,x<=xend,x=x+xstep do
          for j=0,j<$LAY.nfing*2,j=j+2 do
            if (j<firsttop*2 || j>lasttop*2+1) &&                              \
              (j<firstbot*2 || j>lastbot*2+1) continue
            y=$LAY.yoffset[j]/1000.0
            for m=-CORRY/2,m<=CORRY/2,m++ do
              if y+m*step<=$LAY.bottom[j]/1000.0 continue
              if y+m*step>=$LAY.top[j]/1000.0 continue
              if y+m*step<=$LAY.bottom[$LAY.nfing]/1000.0 continue
              if y+m*step>=$LAY.top[$LAY.nfing]/1000.0 continue
              if testertype==TT_A5L && smallboard!=0 then
                if y+m*step<=$LAY.bottom[smallfirst]/1000.0+25.0 continue
                if y+m*step>=$LAY.top[smalllast]/1000.0-25.0 continue
              endif
              if testertype==TT_A7 && smallboard!=0 then
                if y+m*step<=$LAY.bottom[smallfirst]/1000.0+25.0 continue
                if y+m*step>=$LAY.top[smalllast]/1000.0-25.0 continue
              endif
              k++
              if k%7!=0 continue
              if ncal>=NCALIBR break
              c[head].xa[ncal]=x
              c[head].ya[ncal]=y+m*step
              c[head].scandir[ncal]=0
              c[head].group[ncal]=0
              ncal++
            enddo
          enddo
        enddo
      else
        // All available video fiducials.
        for x=xstart,x<=xend,x=x+xstep do
          for y=ystart,y<=yend,y=y+dy do
            if ncal>=NCALIBR break
            c[head].xa[ncal]=x
            c[head].ya[ncal]=Nearestcameray(y)
            c[head].scandir[ncal]=0
            c[head].group[ncal]=0
            ncal++
          enddo
        enddo
      endif
      for j=0,j<ncal,j++
        c[head].xm[j]=c[head].xa[j]+videocorrectx[i]
        c[head].ym[j]=c[head].ya[j]+videocorrecty[i]
      enddo
      c[head].ncal=ncal
      c[head].next=0
      c[head].step=0
      c[head].pending=0
      c[head].autoclean=0
      c[head].infield=0
      c[head].current=-1
      c[head].attempt=0
      c[head].errmsg[0]='\0'
      c[head].rescan=0
      if mode!=C_VER3 && mode!=C_VER5 && mode!=C_VERAREA &&                    \
        mode!=C_VERALL && mode!=C_VERHALF                                      \
      then
        c[head].corrok=0
      endif
      c[head].shrink=0.0
    enddo
  endif
error:
  if mode!=C_MVERIFY && err!=0 then
    clear hright
    change hinfo limits=0,0
    if type==FILL_MECH then
      change hinfo text="Bad head settings!"
    else if type==FILL_VIDEO then
      change hinfo text="Bad video settings!"
    else if type==FILL_HCAM then
      change hinfo text="Bad headcam settings!"
    else
      change hinfo text="Bad settings!"
    endif
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="OK"
      help="Press to select different type of calibration"
    endc
    draw window=hright color=LIGHTRED font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text "Bad or contradictory calibration settings encountered: "
    draw color=BLACK
    if err==1 then
      draw text "This tester is not supported by the current version of the "
      draw text "calibration routine. Therefore calibration is impossible."
      err=-1
    else if err==2 then
      draw text "This kind of calibration board is not supported for given "
      draw text "tester. Please select another type of calibration."
    else if err==3 then
      draw text "Too few calibration points. 4 points per head is an absolute "
      draw text "minimum; however, at least 8 are necessary to assure "
      draw text "acceptable accuracy. Please select different type of "
      draw text "calibration."
    else if err==4 then
      draw text "Too many calibration points. Internal data structures can't "
      draw text format("fit more than %i crosses per finger. ", NCALIBR-2)
      draw text "Please select less points in X direction, or ask for a "
      draw text "special version of calibration script."
    else if err==5 then
      draw text "Too few calibration rows for the camera. 2 rows is an "
      draw text "absolute minimum, and you need more to assure acceptable "
      draw text "accuracy. Please select different type of calibration."
    else if err==6 then
      draw text "Too few calibration columns for the camera. 2 columns is an "
      draw text "absolute minimum, and you need at least 4-5 to assure "
      draw text "acceptable accuracy. Please select different type of "
      draw text "calibration."
    else if err==7 then
      draw text "Shinethrough video calibration is requested, but there is "
      draw text "only one camera on the tester. Please select different type "
      draw text "of calibration."
    else if err==8 then
      draw text "Invalid range of rails participating in calibration is "
      draw text "selected. Please change your selection."
    else if err==9 then
      draw text "Crate controller is too old and does not support variable "
      draw text "step of correction tables for the video camera. Please "
      draw text "update embedded software!"
    else if err==10 then
      draw text "Corrections for different shuttle Y positions are not "
      draw text "supported for the specified calibration mode. This is an "
      draw text "internal error, please ask atg for the corrected calibration "
      draw text "script."
    else if err==11 then
      draw text "Too few points to calibrate shuttle. 4 points per Y position "
      draw text "is an absolute minimum; however, at least 8 are necessary to "
      draw text "assure acceptable accuracy. Please select different type of "
      draw text "calibration."
    endif
    draw show
    while 1 do
      if Pressed(hok) break
      if Pressed(hexit) return -1
      wait
    enddo
  endif
  return err
end

// Calculates flash shinethrough illumination bits for the specified head
// camera.
function int Getoppflash(int head)
  int opp,oppflash
  if head>=0 && headcams!=0 && illumination!=0 && flashthru!=0 then
    opp=Oppositeheadcam(head)
    if opp<0 then
      oppflash=0
    else
      oppflash=(opp<<16)|0x00800000
    endif
  else
    oppflash=0
  endif
  return oppflash
end

// Determines best focus of the dedicated S3 camera at the current coordinates.
// Expects that optimal focus is in the range zmin..zmax micrometers. On
// success, sets zfocus and returns 0. On error in parameters, returns 1. If
// focus can't be found, returns 2. If operator pressed hbreak, returns 3. If
// operator interrupted calibration, returns -1.
function int Videofocus(int head,int channel,handle hbreak,                    \
  int zmin,int zmax,int *zfocus)
  int i,j,k,m,n,t,z,ffreq,zstep,zmeasured,phase,sum,err
  int videox,videoy,dummy,vx,vy,noisez[5],npoint
  float noise[5],minnoise,a,x0,z0
  char s[80],*buf
  // Verify parameters.
  if testertype!=TT_S3 return 1        // Only S3 has autofocus
  if head<$LAY.nfing*2 || head>$LAY.nfing*2+1 ||                               \
    ($LAY.cameras & (1<<(head-$LAY.nfing*2)))==0                               \
    return 1                           // Non-existing camera
  // Get size of the picture from the camera and allocate buffer.
  SYS.Videosize(channel,&videox,&videoy,&dummy)
  if videox<=0 || videoy<=0 return 2   // No camera?
  vx=Min(1536,videox)
  vy=Min(1024,videoy)
  if Alloc(buf,vx*vy)==0 return 2      // Low memory
  // Execute sequence of Z movements. I start with the lowest coordinate. On
  // phase 0, I move upstairs in 100-um steps. When maximum is located, I scan
  // two additional near points (phases 1 and 2) and use parabolic interpolation
  // to determine the exact position of the maximum.
  ffreq=4                              // Spatial autofocus frequency, pixels
  phase=0
  z=zmax
  zstep=100                            // Good compromise for S3 camera
  npoint=0
  err=0
  minnoise=1.0e33
  while 1 do
    // Send command.
    sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",head,z)
    SERV.Cmdimm(32,s)
    // Wait till camera reaches z with 5 um accuracy.
    SYS.Killimm(head)
    t=Time()
    while 1 do
      sprintf(s,"INPORT32 HEAD(%i) 0x10000018",head)
      SERV.Cmdimm(head,s)
      while 1 do
        if $A[head].length!=0 break
        if Pressed(hexit) then
          err=-1; goto finish          // Operator interrupted calibration
        else if hbreak!=NULL && Pressed(hbreak) then
          SYS.Killimm(head)            // Operator pressed hbreak
          err=3; goto finish
        else if Time()-t>5000 then
          SYS.Killimm(head)            // Timeout
          err=2; goto finish
        endif
        wait
      enddo
      if $A[head].answer!=S_INPORT32 || $A[head].length!=9 then
        err=2; goto finish             // Invalid answer from crate
      endif
      zmeasured=$int4($A[head]+5)
      if Abs(z-zmeasured)<=5 break     // Accuracy reached
    enddo
    if hfocus!=NULL then
      change hfocus text=format(" %i",z)
    endif
    // Get video picture.
    SYS.Nextframe(channel)
    t=Time()
    while 1 do
      if SYS.Getvideo(channel,-vx/2,vx-vx/2,1,-vy/2,vy-vy/2,1,buf)>0 break
      if Pressed(hexit) then
        err=-1; goto finish            // Operator interrupted calibration
      else if hbreak!=NULL && Pressed(hbreak) then
        err=3; goto finish             // Operator pressed hbreak
      else if Time()-t>5000 then
        err=2; goto finish             // Timeout
      endif
      wait
    enddo
    // Calculate high frequency noise (base ffreq pixels). The higher this
    // noise, the sharper is the picture. It looks like ffreq=4 is optimal for
    // 5-megapixel S3 camera.
    for j=0,j<=vy-ffreq,j=j+ffreq do
      for i=0,i<=vx-ffreq,i=i+ffreq do
        sum=0
        k=j*vx+i
        for m=0,m<ffreq,m++ do
          for n=0,n<ffreq,n++ do
            sum=sum+buf[k+m*vx+n]
          enddo
        enddo
        buf[k]=sum/(ffreq*ffreq)
      enddo
    enddo
    sum=0
    for j=0,j<=vy-2*ffreq,j=j+ffreq do
      k=j*vx
      for i=0,i<=vx-2*ffreq,i=i+ffreq do
        sum=sum+Abs(buf[k]-buf[k+ffreq])+Abs(buf[k]-buf[k+ffreq*vx])
      enddo
    enddo
    minnoise=Min(sum,minnoise)
    // Now determine next action.
    if phase==0 then
      for i=4,i>0,i-- do
        noise[i]=noise[i-1]
        noisez[i]=noisez[i-1]          // Unnecessary, but helps to debug code
      enddo
      noise[0]=sum
      noisez[0]=z
      npoint++
      if npoint>=5 && noise[2]>minnoise*1.5 &&                                 \
        noise[0]<noise[2]*0.96 && noise[2]>noise[4]*0.96 then
        // Maximum found.
        noise[0]=noise[1]; noisez[0]=noisez[1]
        noise[4]=noise[3]; noisez[4]=noisez[3]
        z=z+zstep+zstep/2
        phase=1
      else
        z=z-zstep
        if z<zmin then
          err=2; goto finish
        endif
      endif
    else if phase==1 then
      noise[1]=sum
      noisez[1]=z
      z=z+zstep
      phase=2
    else if phase==2 then
      noise[3]=sum
      noisez[3]=z
      z=z-zstep/2                      // Middle point of array
      Parabint(noise,5,&a,&x0,&z0)
      zfocus[0]=z+x0*zstep
      focus[head-$LAY.nfing*2]=zfocus[0]
      if hfocus!=NULL then
        change hfocus text=format(" %i",zfocus[0])
      endif
      updatefocus[head-$LAY.nfing*2]=1 // Request to send new focus to camera
      break
    endif
  enddo
finish:
  Free(buf)
  return err
end

// Asks operator whether calibration board is already in the shuttle and
// whether shuttle should be moved out afterwards. Sets global variable
// unloadboard. When shuttle is in and user assures that calibration board is
// correctly placed, returns 1. When user decides to quit calibration, returns
// -1. Otherwise, returns 0.
function int Setlockunlock()
  int t,y,portdata,reloadboard
  char buf[32]
  handle hreload,hunload,hok
  reloadboard=1; unloadboard=1
  if twostep then
    return 0                           // Must move board inbetween
  else if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    return 0
  endif
  getini("Calibration","Move shuttle","%i,%i",&reloadboard,&unloadboard)
  Drawcalboard(0,0,0,DR_HEAD)
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  if $A[32].length==7 && $A[32].answer==S_INPORT then
    portdata=$A[32].inport
  else
    portdata=0
  endif
  clear hright
  change hinfo limits=0,0
  change hinfo text="Load/unload options"
  y=145
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if (portdata & 0x35)==0x20 then
    // Shuttle is in.
    draw text="If product in the shuttle is a calibration board, you may "
    draw text="decide to keep it inside the tester. Also you may choose "
    draw text="whether board should remain in the shuttle after calibration "
    draw text="is finished."
    hreload=control CHECKBOX
      window=hright
      position=20,y,240,22
      text="Replace current product"
      help="Move shuttle out before calibration will begin"
      mode=(reloadboard?M_CHECKED:0)
    endc
    y=y+35
  else
    // Shuttle is out.
    draw text="Please decide whether calibration board should remain in "
    draw text="the shuttle after calibration is finished."
    hreload=NULL
  endif
  draw show
  hunload=control CHECKBOX
    window=hright
    position=20,y,240,22
    text="Unload board after calibration"
    help="Safely unload calibration board when script closes"
    mode=(unloadboard?M_CHECKED:0)
  endc
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="OK"
    help="Press to continue calibration"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hok) then
      unloadboard=Status(hunload)
      if hreload!=NULL then
        reloadboard=Status(hreload)
      else
        reloadboard=1
      endif
      setini("Calibration","Move shuttle","%i,%i",reloadboard,unloadboard)
      return (reloadboard==0?1:0)
    endif
    wait
  enddo
end

// Returns 0 on success, >0 in case of communication error or -1 if operator
// decided to interrupt the calibration.
function int Installcalboard()
  int i,t,err,x,y,portdata,prevdata,ident,movecamera,changed
  int nfing,videoon,channel,head,opp,oppflash,contrast
  int redrawvideo,dummy,result
  float zoom,scalex,scaley,mminpixel,ystep,dy,xcoord,oppx,oppy
  char s[256],buf[128]
  handle hstatus,hlock,hunlock,hvideo,hok,hautofocus,hl,hc,hr
  handle hview,hlivevideo,hzoom
  if smallboard || boardshift!=0.0 then
    Drawcalboard(0,0,0,DR_DIFFCTR|DR_Z)
  else
    Drawcalboard(0,0,0,DR_Z)
  endif
  Startxyboardpos()
  clear hright
  change hinfo limits=0,0
  change hinfo text="Install calibration board"
  nfing=$LAY.nfing
  if $LAY.cameras!=0 then
    if (cameras & 0x1) then            // Select first available camera
      channel=0; head=nfing*2
    else if (cameras & 0x2) then
      channel=1; head=nfing*2+1
    else
      channel=-1
    endif
  else if $LAY.headcameras!=0 then
    Readoldcamoffsets()
    for i=0,i<nfing*2,i++ do           // Select first available headcam
      if (i<firsttop*2 || i>lasttop*2+1) && (i<firstbot*2 || i>lastbot*2+1)    \
        continue                       // Rail is excluded from calibration
      if (headcams & (1<<i))!=0 break
    enddo
    if i<nfing*2 then
      head=i
      channel=Channelfromhead(head)
    else
      channel=-1
    endif
  else
    channel=-1
  endif
  oppflash=Getoppflash(head)
  hstatus=control TEXT
    window=hright
    name="Unknown shuttle status"
    position=9,160,RIGHTX-17,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  if isauto then
    if testertype==TT_A2 || testertype==TT_A2L || testertype==TT_A3 ||         \
      testertype==TT_A3L || testertype==TT_S2 then
      hlock=control BUTTON
        window=hright
        position=RIGHTX/2-124,USERY-30,120,24
        name="Lock"
        help="Press to unlock the shuttle"
      endc
      hunlock=control BUTTON
        window=hright
        position=RIGHTX/2+5,USERY-30,120,24
        name="Unlock"
        help="Press to lock the shuttle"
      endc
    else
      hlock=NULL
      hunlock=NULL
    endif
    hvideo=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Video"
      help="Press to check Y board position using video camera"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="OK"
      help="Press if calibration board is correctly installed"
    endc
  else if testertype==TT_S2 || testertype==TT_S3 then
    hlock=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY-30,120,24
      name="Lock"
      help="Press to unlock the shuttle"
    endc
    hunlock=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-30,120,24
      name="Unlock"
      help="Press to lock the shuttle"
    endc
    hvideo=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Video"
      help="Press to check Y board position using video camera"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="OK"
      help="Press if calibration board is correctly installed"
    endc
  else
    hlock=NULL
    hunlock=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name="Unlock"
      help="Press to unlock the shuttle"
    endc
    hvideo=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="Video"
      help="Press to adjust Y board position using video camera"
    endc
    hok=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="OK"
      help="Press if calibration board is correctly installed"
    endc
  endif
  disable hvideo
  disable hok
  hautofocus=NULL
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if calmode==MODE_3DCAL then
    draw text="Now install the calibration board. " color=LIGHTRED
    draw text="Its vertical position must differ by at least "
    draw text=format("%g mm from the last calibration. ",MIN3DDIST/1000.0)
    draw color=BLACK
  else if calmode==MODE_VER && verifymode==VERIFY_ZALIGN then
    draw text="Now install the " color=LIGHTRED text="specially prepared "
    draw text="calibration board " color=BLACK text="with lowered and "
    draw text="heightened areas, as shown on the picture. Orientation is "
    draw text="not important. "
  else if twostep==2 then
    draw text="Now install two calibration boards, as shown on the left "
    draw text="picture. "
  else
    draw text=""
    draw text=" . "
  endif
  if smallboard then
    draw text="Note that board is for the different tester, and real centers "
    draw text="of the rails are shifted from the positions marked on the "
    draw text="board. "
  endif
  if hlock!=NULL && hunlock!=NULL then
    draw text="Press " font=MAINFONT text="Lock " font=TIMESFONT
    draw text="and " font=MAINFONT text="Unlock " font=TIMESFONT
    draw text="to move the shuttle. "
  else if hunlock!=NULL then
    draw text="Press " font=MAINFONT text="Unlock " font=TIMESFONT
    draw text="to unlock the shuttle. "
    if channel>=0 &&                                                           \
      testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 then
      draw text="If shuttle is locked, use " font=MAINFONT text="Video "
      draw font=TIMESFONT text="together with button 'Release' on the tester "
      draw text="to adjust Y coordinate. "
    endif
  endif
  draw text="Press " font=MAINFONT text="OK " font=TIMESFONT
  if twostep==2 then
    draw text="when boards are correctly installed."
  else
    draw text="when calibration board is correctly installed."
  endif
  if (boardtype==1 || boardtype==2) &&                                         \
    testertype!=TT_S1 && testertype!=TT_S3 then
    draw text=" Let somebody help you: glass calibration board is fragile!"
  endif
  draw show
  // Move all heads in home position, otherwise shuttle release doesn't work.
  // This movement is not critical, so I don't check for possible errors.
  if demo==0 then
    for i=0,i<nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()+10000                     // Wait 10 s for answers
    while (1) do
      for i=0,i<nfing,i++
        if c[i*2].ncal==0 continue
        if $A[i].length==0 break       // Some answers are still not here
      enddo
      if i>=nfing break                // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()>t break                // No answer within timeout
      wait
    enddo
  endif
  t=0; err=0; videoon=0
  portdata=-1; prevdata=portdata
  while err==0 do
    Xyboardpos()
    if portdata!=prevdata then
      i=portdata & 0x35
      if i==0x20 then                  // Shuttle locked in test position
        if channel>=0 enable hvideo
        enable hok
        change hstatus text="Shuttle locked"
      else if (i & 0x10)==0 &&                                                 \
        testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 then
        disable hvideo; disable hok
        change hstatus text="Shuttle in"
      else if testertype==TT_S3 then
        enable hvideo; enable hok
        change hstatus text="Shuttle out"
      else
        disable hvideo; disable hok
        change hstatus text="Shuttle out"
      endif
      prevdata=portdata
    endif
    if hlock!=NULL && Pressed(hlock) && demo==0 then
      buf[0]=S_LOCKDOOR; buf[1]=1      // Lock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else if hunlock!=NULL && Pressed(hunlock) && demo==0 then
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      if videoon!=0 then
        destroy hview; hview=NULL
        if hautofocus!=NULL destroy hautofocus; hautofocus=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        videoon=0
      endif
      videocorrectx[0]=0.0             // Unlocking PCB invalidates offsets
      videocorrecty[0]=0.0
      videocorrectx[1]=0.0
      videocorrecty[1]=0.0
    else if Pressed(hvideo) && channel>=0 then
      if videoon==0 then
        change hxycontrol position=-1000,-1000,LEFTX-22,30
        y=USERY-60
        if testertype==TT_S3 && $LAY.cameras!=0 then
          hautofocus=control BUTTON
            window=hright
            position=5+RIGHTX/3,y-30,RIGHTX/3-5,24
            name="Autofocus"
            help="Press to find optimal position of the camera"
          endc
        endif
        hl=control BUTTON              // Video is not yet here, create controls
          window=hright
          position=5,y,RIGHTX/3-5,24
          name="<< Left"
          help="Press to move camera to the left"
        endc
        hc=control BUTTON
          window=hright
          position=5+RIGHTX/3,y,RIGHTX/3-5,24
          name="Center"
          help="Press to move camera to the center"
        endc
        hr=control BUTTON
          window=hright
          position=5+2*(RIGHTX/3),y,RIGHTX/3-9,24
          name="Right >>"
          help="Press to move camera to the right"
        endc
        hview=control CHILD
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        draw window=hview font=INFOFONT
        draw show
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          bkcolor=VIDEOFILL
        endc
        Bccreate(hview,-1,-1,channel,1,1)
        hzoom=control CUSTOMBOX
          window=hview
          position=235,303,80,21
          name="Zoom in"
          help="Check to increase magnification by a factor of 2"
          color=BROWN
        endc
        zoom=Getzoom(channel)*(Status(hzoom)==0?1.0:2.0)
        SYS.Videoangle(hlivevideo,channel|oppflash,0,                          \
          zoom,Bcgetbri(channel,1),Bcgetctr(channel,1),                        \
          (channel<0?0:2)|(longexp?4:0),0.0)
        movecamera=1; xcoord=$LAY.xoffset/1000.0
        videoon=1
        redrawvideo=1
      else
        destroy hview; hview=NULL      // Video is already here, remove controls
        if hautofocus!=NULL destroy hautofocus; hautofocus=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        change hxycontrol position=11,LEFTY-37,LEFTX-22,30
        videoon=0
      endif
    else if Pressed(hok) && ((portdata & 0x35)==0x20 || testertype==TT_S3) then
      break
    else if Pressed(hexit) then
      err=-1
    endif
    if videoon then
      changed=Bcupdate(1)
      if (changed & 0x01)!=0 then
        zoom=Getzoom(channel)*(Status(hzoom)==0?1.0:2.0)
        SYS.Videoangle(hlivevideo,channel|oppflash,0,                          \
        zoom,Bcgetbri(channel,1),Bcgetctr(channel,1),                          \
        (channel<0?0:2)|(longexp?4:0),0.0)
      endif
      if (changed & 0x02)!=0 then
        movecamera=1                   // Type of illumionation is changed
      endif
      if redrawvideo || Pressed(hzoom) then
        zoom=Getzoom(channel)*(Status(hzoom)==0?1.0:2.0)
        SYS.Videoangle(hlivevideo,channel|oppflash,0,                          \
          zoom,Bcgetbri(channel,1),Bcgetctr(channel,1),                        \
          (channel<0?0:2)|(longexp?4:0),0.0)
        draw window=hlivevideo bkcolor=VIDEOFILL clear
        draw color=(testertype==TT_S1 || testertype==TT_S2?LIGHTGREEN:LIGHTRED)
        draw font=SMALLFONT
        // Scale to the left. High accuracy is not necessary. If magnification
        // is not yet known, I use rough default.
        scalex=5.12; scaley=5.12;
        getini("System","Video scale[0]","%f,%f",&scalex,&scaley);
        if scalex>0.2 && scalex<10.0 && scaley>0.2 && scaley<10.0 then
          mminpixel=(scalex+scaley)/1024.0
        else if testertype==TT_S3 then
          mminpixel=0.001;             // 1 um per pixel
        else
          mminpixel=0.008;             // 8 um per pixel
        endif
        draw at 10,10 to 10,288-10
        if zoom/mminpixel>200 then
          ystep=0.1
        else if zoom/mminpixel>100 then
          ystep=0.2
        else if zoom/mminpixel>40 then
          ystep=0.5
        else
          ystep=1.0
        endif
        for dy=-10.0,dy<=10.0,dy=dy+ystep do
          y=288/2-dy/mminpixel*zoom
          if y<8 || y>=288-8 continue
          draw at 10,y to 16,y
          draw at 20,y+6 text=format("%.1f",Abs(dy))
        enddo
        // Central cross.
        x=(LEFTX-10)/2; y=288/2
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        redrawvideo=0
      else if hautofocus!=NULL && Pressed(hautofocus) then
        disable hl; disable hc; disable hr
        disable hlock; disable hunlock; disable hvideo; disable hok
        change hinfo text="Focussing, please wait..."
        result=Videofocus($LAY.nfing*2+channel,channel,                        \
          hautofocus,-5000,-1000,&dummy)
        if result<0 then
          return -1
        else if result==0 || result==3 then
          change hinfo text="Install calibration board"
        else
          change hinfo text="Unable to find focus"
        endif
        enable hl; enable hc; enable hr
        enable hlock; enable hunlock; enable hvideo; enable hok
      else if Pressed(hc) then
        movecamera=1; xcoord=$LAY.xoffset/1000.0
      else if Pressed(hl) then
        movecamera=1
        if headcams then
          xcoord=$LAY.leftlimit/1000.0
        else
          xcoord=($LAY.leftlimit+$LAY.videodeadx)/1000.0
        endif
        xcoord=Max(xcoord,fromx,$LAY.leftlimit/1000.0+3.0*xstep)
      else if Pressed(hr) then
        movecamera=1
        if headcams then
          xcoord=$LAY.rightlimit/1000.0
        else
          xcoord=($LAY.rightlimit-$LAY.videodeadx)/1000.0
        endif
        xcoord=Min(xcoord,tox,$LAY.rightlimit/1000.0-3.0*xstep)
      endif
      if movecamera!=0 then
        if headcams then
          SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
          sprintf(buf,"M @%i[%g,%g] NOP",head,                                 \
            xcoord+headcamolddx[head],                                         \
            $LAY.yoffset[head/2]/1000.0+headcamolddy[head])
          SERV.Cmdimm(32,buf)
          opp=Oppositeheadcam(head)
          if illumination==0 || opp<0 then
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          else
            Oppositexycam(xcoord,$LAY.yoffset[head/2]/1000.0,opp,&oppx,&oppy,0)
            sprintf(buf,"M @%i[%f,%f] %i(Z) NOP",opp,oppx,oppy,opp^1)
            SERV.Cmdimm(32,buf)
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype & 0xC)
            SERV.Cmdimm(32,buf)
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",opp,illtype)
          endif
        else
          sprintf(buf,"M %i(%g,%g) NOP",head,xcoord,                           \
          $LAY.yoffset[$LAY.nfing]/1000.0)
        endif
        SERV.Cmdimm(32,buf)
        movecamera=0
      endif
    endif
    if demo then                       // Emulate locked shuttle
      portdata=0x20
    else if t==0 then                  // Send next port query
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      ident=SYS.Sendimm(0,3,buf)
      t=Time()+5000                    // Timeout 5 seconds
    else if $A[0].length>0 then
      if $A[0].answer==S_INPORT then
        portdata=$A[0].inport          // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if t<Time() then
      SYS.Killsend(ident)
      err=1                            // No answer from tester
    endif
    wait
  enddo
  if videoon!=0 then
    destroy hview
    if hautofocus!=NULL destroy hautofocus; hautofocus=NULL
    destroy hl
    destroy hc
    destroy hr
  endif
  if channel>=0 then
    sprintf(buf,"M %i(Z) NOP",head)
    SERV.Cmdimm(32,buf)                // Move camera in home position
  endif
  if headcams SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
  if err>0 then
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Retry"
      help="Press to check the tester status"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED text="Communication error! "
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from tester within 5 seconds. "
    else
      draw text="Calibration procedure received unexpected answer. "
    endif
    draw text="Please check connection with crate controller. Press "
    draw font=MAINFONT text="Retry " font=TIMESFONT text="to check tester "
    draw text="status and, eventually, reboot it."
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  Finishxyboardpos()
  return err
end

// Asks L&M for the value of the specified parameter. If answer is present,
// sets value to the received string <parm>=<answer> (i.e. parm and equation
// sign are included). If answer is absent (#), value remains unchanged.
// Returns 0 on success, 1 on failure or if value is absent and -1 if user
// cancelled calibration.
function int Getlmparameter(char *parm,char *value)
  int i,n,haseq,hashash
  char buf[768]
  SYS.Killimm(33)
  buf[0]=S_LMAUTO
  buf[1]=3                             // Get parameter
  n=2+sprintf(buf+2,"%s",parm)
  SYS.Sendimm(33,n,buf)
  while $A[33].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[33].answer!=S_LMAUTO return 1  // Bad answer
  haseq=0; hashash=0;
  for i=0,i<$A[33].length-6,i++ do
    if $char($A[33]+6+i)=='=' haseq=1
    if $char($A[33]+6+i)=='#' hashash=1
  enddo
  if haseq==0 || hashash!=0 return 1
  for i=0,i<$A[33].length-6,i++ do
    value[i]=$char($A[33]+6+i)
  enddo
  value[i]='\0'
  return 0
end

// Sends text command to L&M automation and waits for answer. Returns 1 on
// success, 0 on failure, 2 on timeout and -1 if user cancelled calibration.
function int Sendlmcommand(char *cmd,char *answer,char *error,int timeout)
  int m,n,status
  char buf[768]
  SYS.Killimm(33)
  buf[0]=S_LMAUTO
  buf[1]=4                             // Send command
  $uint2(buf+2)=timeout                // Timeout, seconds
  n=4+sprintf(buf+4,"%s\n",cmd)
  n=n+sprintf(buf+n,"%s",answer)
  SYS.Sendimm(33,n,buf)
  while $A[33].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[33].answer!=S_LMAUTO return 0  // Bad answer
  status=$uint2($A[33]+6)
  if (status & 0x01) return 2          // Timeout
  if $char($A[33]+8)=='1' then
    n=8
    m=0                                // Success
    while $char($A[33]+n)!='\n' && n<$A[33].length do
      error[m]=$char($A[33]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 1
  else
    n=8                                // Error
    while $char($A[33]+n)!='\n' && n<$A[33].length do
      n++
    enddo
    if $char($A[33]+n)=='\n' && n<$A[33].length n++
    m=0
    while $char($A[33]+n)!='\n' && n<$A[33].length do
      error[m]=$char($A[33]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 0
  endif
end

// Gets actual teachin settings for L&M hardware. Settings are saved to the
// array lmteachin[], prefix MECH.Teachin is replaced by MECH.Para. Returns 0
// on success, >0 in the case of communication error or -1 if operator decided
// to interrupt the calibration.
function int Getteachinsettings()
  int i
  nlmteachin=0
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO &&                                 \
    ($LAY.config & LC_LDMASK)!=LC_LMS2AUTO &&                                  \
    ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO return 0
  i=Getlmparameter("MECH.Teachin.ShuttleX",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  i=Getlmparameter("MECH.Teachin.ShuttleY",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  if ($LAY.config & LC_LDMASK)==LC_LMS2AUTO then
    i=Getlmparameter("MECH.Para.InputShuttleX",lmteachin[nlmteachin])
    if i!=0 return i
    nlmteachin++
    i=Getlmparameter("MECH.Para.InputShuttleY",lmteachin[nlmteachin])
    if i!=0 return i
    nlmteachin++
  else
    i=Getlmparameter("MECH.Para.BoardH",lmteachin[nlmteachin])
    if i!=0 return i
    nlmteachin++
    i=Getlmparameter("MECH.Para.BoardW",lmteachin[nlmteachin])
    if i!=0 return i
    nlmteachin++
  endif
  i=Getlmparameter("MECH.Para.UseCatcherOnly",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  return 0
end

// Installs calibration board in L&M automatical shuttle. Returns 0 on success,
// >0 in the case of communication error or -1 if operator decided to interrupt
// the calibration.
function int InstallcalboardLM()
  int i,t,nfing,setpos,prevdata,portdata,adjusting,adjusted,firsttime,err
  char s[256],buf[256],errtxt[256],calboard[256]
  handle f,hstatus,hload,hunload,hadjust,hok,hyes,hno
  i=Setlockunlock()
  if i<0 return -1
  if i==1 return 0
  Strcpy(calboard,"c:\\hardware\\shuttle_calib.txt")
  nfing=$LAY.nfing
  firsttime=1
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  if demo==0 then
    for i=0,i<nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      sprintf(buf,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
      SERV.Cmdimm(i,buf)
    enddo
    t=Time()
    while (1) do
      for i=0,i<nfing,i++
        if c[i*2].ncal==0 continue
        if $A[i].length==0 break       // Some answers are still not here
      enddo
      if i>=nfing break                // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()-t>10000 break          // No answer within 10 s timeout
      wait
    enddo
  endif
  Drawcalboard(0,0,0,DR_Z)             // Show calibration board in shuttle
  clear hright
  change hinfo limits=0,0
  // Check whether there is a board in the shuttle. It may happen that previous
  // calibration was interrupted. In this case, don't change any settings!
  if demo==0 then
    SYS.Killimm(32)
    buf[0]=S_INPORT
    $uint2(buf+1)=0x00F0               // Hardware control port
    SYS.Sendimm(32,3,buf)
    t=Time()
    while 1 do
      if $A[32].length>0 break
      if Pressed(hexit) return -1
      if Time()-t>5000 break
      wait
    enddo
    if $A[32].length==7 && $A[32].answer==S_INPORT then
      portdata=$A[32].inport
    else
      portdata=0
    endif
    if (portdata & 0x35)!=0x20 then
      // Set positions of L&M actuators for small calibration board.
      f=Fopen(calboard,"rb")
      if f!=NULL then
        Fclose(f)
        change hinfo text="Setting up shuttle..."
        sprintf(s,"PS.Cmd=FileRead %s",calboard)
        i=Sendlmcommand(s,"PS.Ready.FileRead",errtxt,5)
        if i<0 return -1
        setpos=(i==1)
      else
        setpos=0                       // Shuttle positions not set
      endif
    else
      setpos=0
    endif
  endif
  // Set manual automation mode.
  change hinfo text="Switching to manual mode..."
  if demo==0 then
    i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,20)
    if i<0 return -1
  endif
  // Installation controls.
  change hinfo text="Install calibration board"
  hstatus=control TEXT
    window=hright
    name="Unknown shuttle status"
    position=9,190,RIGHTX-17,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  hload=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY-35,120,24
    name="Load"
    help="Press to load calibration board to the shuttle"
  endc
  hunload=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY-35,120,24
    name="Unload"
    help="Press to unload calibration board from the shutle"
  endc
  hadjust=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Adjust"
    help="Press to adjust shuttle using manual control box"
  endc
  disable hadjust
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="OK"
    help="Press if calibration board is correctly installed"
  endc
  if demo==0 disable hok
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="Now install the calibration board. "
  if calmode==MODE_3DCAL then
    draw color=LIGHTRED text="Its vertical position must differ by at least "
    draw text=format("%g mm from the last calibration. ",MIN3DDIST/1000.0)
    draw color=BLACK
  endif
  draw text="Press " font=MAINFONT text="Adjust " font=TIMESFONT
  draw text="to adjust widht and height of the shuttle manually. Press "
  draw font=MAINFONT text="OK " font=TIMESFONT text="when calibration board "
  draw text="is correctly locked in the shuttle."
  if boardtype==1 || boardtype==2 then
    draw text=" Please be carefull: glass calibration board is fragile!"
  endif
  draw show
  // Main loop.
  prevdata=-1
  adjusting=0
  adjusted=0
  t=0
  err=0
  while err==0 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if adjusting then
        change hstatus text="Adjustment mode"
        enable hload
        disable hunload
        disable hadjust
        disable hok
      else if i==0x20 then             // Shuttle locked in test position
        change hstatus text="Board in the shuttle"
        disable hload
        enable hunload
        disable hadjust
        if firsttime then
          disable hok
        else
          enable hok
        endif
      else
        change hstatus text="Shuttle out"
        enable hload
        enable hunload
        //enable hadjust
        disable hadjust
        disable hok
      endif
      prevdata=portdata
    endif
    if Pressed(hload) && demo==0 then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      buf[0]=S_LOCKDOOR; buf[1]=1      // Lock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      firsttime=0
      prevdata=-1
    else if Pressed(hunload) && demo==0 then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      firsttime=0
      prevdata=-1
    else if Pressed(hadjust) && demo==0 then
      i=Sendlmcommand("MECH.Cmd=SetMode 4","MECH.Ready.SetMode",errtxt,60)
      if i<0 return -1
      i=Sendlmcommand("MECH.Para.Teachin=1","",errtxt,10)
      if i<0 return -1
      adjusting=1
      adjusted=1
      prevdata=-1
    else if Pressed(hok) && ((portdata & 0x35)==0x20 || demo!=0) then
      if adjusted!=0 && demo==0 then
        // Shuttle settings were probably changed, ask to update file.
        clear hright
        change hinfo limits=0,0
        change hinfo text="Save shuttle settings"
        draw window=hright color=BLACK font=TIMESFONT
        draw at 6,30 wrap=RIGHTX-5
        draw text="Would you like to save the actual shuttle settings to the "
        draw text="disk, so that the next calibration will automatically use "
        draw text="them?\n\n" color=GRAY text="Note: board size and catchers "
        draw text="remain unchanged; if necessary, edit them directly in the "
        draw text=format("file %s.",calboard)
        hyes=control BUTTON
          window=hright
          position=RIGHTX/2-124,USERY,120,24
          name="Yes"
          help="Press to save shuttle settings to the file"
        endc
        hno=control BUTTON
          window=hright
          position=RIGHTX/2+5,USERY,120,24
          name="No"
          help="Press to use new shuttle settings in the current session only"
        endc
        while 1 do
          if Pressed(hexit) then
            return -1
          else if Pressed(hno) then
            break
          else if Pressed(hyes) then
            Getteachinsettings()
            if nlmteachin>0 then
              f=Fopen(calboard,"wt")
              if f!=NULL then
                for i=0,i<nlmteachin,i++ do
                  fprintf(f,"%s\n",lmteachin[i])
                enddo
                Fclose(f)
              endif
            endif
            break
          endif
          wait
        enddo
      endif
      break
    else if Pressed(hexit) then
      return -1
    endif
    if demo then                       // Emulate locked shuttle
      portdata=0x20
    else if t==0 then                  // Send next port query
      SYS.Killimm(32)
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      SYS.Sendimm(32,3,buf)
      t=Time()                         // Timeout 5 seconds
    else if $A[32].length>0 then
      if $A[32].answer==S_INPORT then
        portdata=$A[32].inport         // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if Time()-t>5000 then
      t=0
      err=1                            // No answer from tester
    endif
    wait
  enddo
  return err
end

// Installs small glass calibration board in L&M automatical shuttle (any board
// in S3 split shuttle). Returns 0 on success, >0 in the case of communication
// error or -1 if operator decided to interrupt the calibration.
function int InstallglassboardLM(int shuttle)
  int i,t,nfing,setpos,prevdata,portdata,firsttime,err
  char buf[256],errtxt[256]
  handle f,hstatus,hload,hunload,hok,hyes,hno
  i=Setlockunlock()
  if i<0 return -1
  if i==1 return 0
  nfing=$LAY.nfing
  firsttime=1
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  if demo==0 then
    for i=0,i<nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      sprintf(buf,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
      SERV.Cmdimm(i,buf)
    enddo
    t=Time()
    while (1) do
      for i=0,i<nfing,i++
        if c[i*2].ncal==0 continue
        if $A[i].length==0 break       // Some answers are still not here
      enddo
      if i>=nfing break                // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()-t>10000 break          // No answer within 10 s timeout
      wait
    enddo
  endif
  Drawcalboard(0,0,0,DR_Z)
  clear hright
  change hinfo limits=0,0
  change hinfo text="Setting pure manual mode..."
  // Check that Parameter Server supports MECH.Para.IsGlassBoard. If parameter
  // is initially absent, it would be too dangerous to install glass: it could
  // be destroyed by the centering pieces.
  if demo==0 then
    Strcpy(buf,"#")
    i=Getlmparameter("MECH.Para.IsGlassBoard",buf)
    if i<0 return -1
    if i!=0 || buf[0]=='#' then
      change hinfo text="Old MECH"
      clear hright
      draw window=hright color=LIGHTRED font=TIMESFONT
      draw at 6,30 wrap=RIGHTX-5
      draw text="Your copy of MechA5a.exe does not support glass boards. "
      draw color=BLACK text="When shuttle with board moves, centering bars "
      draw text="will attempt to hold the board. Unfortunately, they are "
      draw text="powerfull enough to break the glass. Please calibrate tester "
      draw text="with FR4 board, or ask atg for the updated Parameter Server."
      draw show
      hok=control BUTTON
        window=hright
        position=(RIGHTX-120)/2,USERY,120,24
        name="Oops..."
        help="Press to terminate the calibration"
      endc
      while Pressed(hok)==0 && Pressed(hexit)==0 do
        wait
      enddo
      return -1
    endif
  endif
  // Now set glass board.
  if demo==0 then
    i=Sendlmcommand("MECH.Para.IsGlassBoard=1","",errtxt,10)
    if i<0 return -1
    if i==2 then
      change hinfo text="Unable to handle glass"
      clear hright
      draw window=hright color=LIGHTRED font=TIMESFONT
      draw at 6,30 wrap=RIGHTX-5
      draw text="Calibration script was unable to turn on special glass "
      draw text="handling. Parameter server reported timeout. When shuttle "
      draw text="with board moves, centering bars will attempt to hold the "
      draw text="board. Unfortunately, they are powerfull enough to break the "
      draw text="glass. Please calibrate tester with FR4 board, or restart "
      draw text="the calibration."
      draw show
      hok=control BUTTON
        window=hright
        position=(RIGHTX-120)/2,USERY,120,24
        name="Oops..."
        help="Press to terminate the calibration"
      endc
      while Pressed(hok)==0 && Pressed(hexit)==0 do
        wait
      enddo
      return -1
    endif
    isglassboard=1                     // IsGlassBoard was set to 1
  endif
  // Check whether there is a board in the shuttle. It may happen that previous
  // calibration was interrupted. In this case, don't change any settings!
  if demo==0 then
    SYS.Killimm(32)
    buf[0]=S_INPORT
    $uint2(buf+1)=0x00F0               // Hardware control port
    SYS.Sendimm(32,3,buf)
    t=Time()
    while 1 do
      if $A[32].length>0 break
      if Pressed(hexit) return -1
      if Time()-t>5000 break
      wait
    enddo
    if $A[32].length==7 && $A[32].answer==S_INPORT then
      portdata=$A[32].inport
    else
      portdata=0
    endif
    if (portdata & 0x35)!=0x20 then
      // Set positions of L&M actuators for small calibration board.
      f=Fopen("c:\\hardware\\shuttle_glass.txt","rb")
      if f!=NULL then
        Fclose(f)
        change hinfo text="Setting up shuttle..."
        i=Sendlmcommand("PS.Cmd=FileRead c:/hardware/shuttle_glass.txt",       \
          "PS.Ready.FileRead",errtxt,5)
        if i<0 return -1
        setpos=(i==1)
        buf[0]=S_LOCKDOOR; buf[1]=0    // Unlock shuttle, moves actuators
        SYS.Send(2,buf,0)              // Do not wait for answer, no need
      else
        setpos=0                       // Shuttle positions not set
      endif
    else
      setpos=0
    endif
  endif
  // Set pure manual automation mode.
  if demo==0 then
    i=Sendlmcommand("MECH.Cmd=SetMode 5","MECH.Ready.SetMode",errtxt,20)
    if i<0 return -1
    if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i",shuttle)
      i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
      if i<0 return -1
      pulledshuttle=shuttle
    endif
  endif
  // Installation controls.
  if boardtype==0 then
    if twostep==2 then
      change hinfo text="Install two boards"
    else
      change hinfo text="Install calibration board"
    endif
  else
    if twostep==2 then
      change hinfo text="Install two glass boards"
    else
      change hinfo text="Install glass board"
    endif
  endif
  hstatus=control TEXT
    window=hright
    name="Unknown shuttle status"
    position=9,190,RIGHTX-17,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  hload=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY-35,120,24
    name="Load"
    help="Press to load calibration board to the shuttle"
  endc
  hunload=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY-35,120,24
    name="Unload"
    help="Press to unload calibration board from the shutle"
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="OK"
    help="Press if calibration board is correctly installed"
  endc
  if demo==0 disable hok
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if twostep==1 then
    draw text="Now install calibration board in the "
    draw color=LIGHTRED text=(shuttle==0?"left":"right") color=BLACK
    draw text=" shuttle. "
  else if twostep==2 then
    draw text="Now install two calibration boards in both shuttles. "
  else
    draw text="Now install the calibration board. "
  endif
  if calmode==MODE_3DCAL then
    draw color=LIGHTRED text="Its vertical position must differ by at least "
    draw text=format("%g mm from the last calibration. ",MIN3DDIST/1000.0)
    draw color=BLACK
  endif
  draw text="Press " font=MAINFONT text="Adjust " font=TIMESFONT
  draw text="to adjust widht and height of the shuttle manually. Press "
  draw font=MAINFONT text="OK " font=TIMESFONT
  draw text="when calibration board is correctly placed in the shuttle. "
  draw text="Please be carefull: glass board is fragile!"
  draw show
  // Main loop.
  err=0
  prevdata=-1
  t=0
  while err==0 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if i==0x20 then                  // Shuttle locked in test position
        change hstatus text="Board in the shuttle"
        disable hload
        enable hunload
        if firsttime then
          disable hok
        else
          enable hok
        endif
      else
        change hstatus text="Shuttle out"
        enable hload
        enable hunload
        disable hok
      endif
      prevdata=portdata
    endif
    if Pressed(hload) && demo==0 then
      if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
        if pulledshuttle!=shuttle then
          pulledshuttle=shuttle
          sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i",shuttle)
          i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
          if i<0 return -1
        endif
      endif
      buf[0]=S_LOCKDOOR
      if testertype!=TT_S3 || ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
        buf[1]=1                       // Lock door
      else if shuttle==0 then
        buf[1]=80                      // Load board in left shuttle
      else
        buf[1]=81                      // Load board in right shuttle
      endif
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      firsttime=0
      prevdata=-1
    else if Pressed(hunload) && demo==0 then
      if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
        sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
        if i<0 return -1
        pulledshuttle=-1
      endif
      buf[0]=S_LOCKDOOR
      buf[1]=0                         // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      firsttime=0
      prevdata=-1
    else if Pressed(hok) && ((portdata & 0x35)==0x20 || demo!=0) then
      break
    else if Pressed(hexit) then
      return -1
    endif
    if demo then                       // Emulate locked shuttle
      portdata=0x20
    else if t==0 then                  // Send next port query
      SYS.Killimm(32)
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      SYS.Sendimm(32,3,buf)
      t=Time()                         // Timeout 5 seconds
    else if $A[32].length>0 then
      if $A[32].answer==S_INPORT then
        portdata=$A[32].inport         // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if Time()-t>5000 then
      t=0
      err=1                            // No answer from tester
    endif
    wait
  enddo
  return err
end

// Installs calibration board in EPCOS automatical shuttle. Returns 0 on
// success, >0 in case of communication error or -1 if operator decided to
// interrupt the script.
function int InstallcalboardEPCOS()
  int i,t,err,x,y,nfing,channel,head,opp,videoon,redrawvideo,movecamera
  float zoom,scalex,scaley,mminpixel,ystep
  float dy,xcoord,oppx,oppy,changed
  char s[256],buf[128],errtxt[256]
  handle hvideo,hok,hl,hc,hr
  handle hview,hlivevideo,hzoom
  Drawcalboard(0,0,0,DR_Z)             // Show calibration board in shuttle
  clear hright
  change hinfo limits=0,0
  nfing=$LAY.nfing
  err=0
  videoon=0
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  if demo==0 then
    for i=0,i<nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()+10000                     // Wait 10 s for answers
    while (1) do
      for i=0,i<nfing,i++
        if c[i*2].ncal==0 continue
        if $A[i].length==0 break       // Some answers are still not here
      enddo
      if i>=nfing break                // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()>t break                // No answer within timeout
      wait
    enddo
  endif
  if $LAY.cameras!=0 then
    if (cameras & 0x1) then            // Select first available camera
      channel=0; head=nfing*2
    else if (cameras & 0x2) then
      channel=1; head=nfing*2+1
    else
      channel=-1
    endif
  else if $LAY.headcameras!=0 then
    Readoldcamoffsets()
    for i=0,i<nfing*2,i++ do           // Select first available headcam
      if (i<firsttop*2 || i>lasttop*2+1) && (i<firstbot*2 || i>lastbot*2+1)    \
        continue                       // Rail is excluded from calibration
      if (headcams & (1<<i))!=0 break
    enddo
    if i<nfing*2 then
      head=i
      channel=Channelfromhead(head)
    else
      channel=-1
    endif
  else
    channel=-1
  endif
  if ($GLOBAL.debugmode & 0x40)==0 && demo==0 then
    // Move shuttle into the test position.
    change hinfo text="Setting manual mode..."
    errtxt[2]=0
    i=Sendlmcommand("MECH.Cmd=SetMode","MECH.Ready.SetMode",errtxt,10)
    if i<0 return -1
    if errtxt[2]!='2' then
      i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,10)
      if i<0 return -1
    endif
    change hinfo text="Moving up vacuum plate..."
    i=Sendlmcommand("MECH.Cmd=LifterToTestPos",                                \
      "MECH.Ready.LifterToTestPos",errtxt,20)
    if i<0 return -1
    if i==2 err=1                      // Timeout
    if i==0 err=2                      // Unable to move plate
    // May happen that answer to Vacuum won't come. Therefore I ignore the
    // possible timeout.
    i=Sendlmcommand("MECH.Cmd=Vacuum 0",                                       \
      "MECH.Ready.Vacuum",errtxt,2)
    if i<0 return -1
    if i==0 err=2                      // Unable to turn off vacuum
  endif
  if err==0 then
    change hinfo text="Install calibration board"
    hvideo=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Video"
      help="Press to adjust Y board position using video camera"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="OK"
      help="Press if calibration board is correctly installed"
    endc
    draw window=hright color=BLACK font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text="Now install the holder and place calibration board. "
    if calmode==MODE_3DCAL then
      draw color=LIGHTRED text="Its vertical position must differ by at least "
      draw text=format("%g mm from the last calibration. ",MIN3DDIST/1000.0)
      draw color=BLACK
    endif
    draw text="Use video camera to check its position. Press " font=MAINFONT
    draw text="OK " font=TIMESFONT text="when board is correctly installed."
    draw show
  endif
  while err==0 do
    if Pressed(hvideo) && channel>=0 then
      if videoon==0 then
        change hxycontrol position=-1000,-1000,LEFTX-22,30
        hl=control BUTTON              // Video is not yet here, create controls
          window=hright
          position=5,USERY-30,RIGHTX/3-5,24
          name="<< Left"
          help="Press to move camera to the left"
        endc
        hc=control BUTTON
          window=hright
          position=5+RIGHTX/3,USERY-30,RIGHTX/3-5,24
          name="Center"
          help="Press to move camera to the center"
        endc
        hr=control BUTTON
          window=hright
          position=5+2*(RIGHTX/3),USERY-30,RIGHTX/3-9,24
          name="Right >>"
          help="Press to move camera to the right"
        endc
        hview=control CHILD
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          bkcolor=VIDEOFILL
        endc
        Bccreate(hview,-1,-1,channel,1,0)
        hzoom=control CUSTOMBOX
          window=hview
          position=235,303,80,21
          name="Zoom in"
          help="Check to increase magnification by a factor of 2"
          color=BROWN
        endc
        zoom=Getzoom(channel)*(Status(hzoom)==0?1.0:2.0)
        SYS.Videoangle(hlivevideo,channel,0,                                   \
          zoom,Bcgetbri(channel,1),Bcgetctr(channel,1),                        \
          (channel<0?0:2)|(longexp?4:0),0.0)
        movecamera=1; xcoord=$LAY.xoffset/1000.0
        videoon=1
        redrawvideo=1
      else
        destroy hview; hview=NULL      // Video is already here, remove controls
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        change hxycontrol position=11,LEFTY-37,LEFTX-22,30
        videoon=0
      endif
    else if Pressed(hok) then
      break
    else if Pressed(hexit) then
      err=-1
    endif
    if videoon then
      changed=Bcupdate(1)
      if (changed & 0x01)!=0 then
        zoom=Getzoom(channel)*(Status(hzoom)==0?1.0:2.0)
        SYS.Videoangle(hlivevideo,channel,0,                                   \
        zoom,Bcgetbri(channel,1),Bcgetctr(channel,1),                          \
        (channel<0?0:2)|(longexp?4:0),0.0)
      endif
      if (changed & 0x02)!=0 then
        movecamera=1
      endif
      if redrawvideo || Pressed(hzoom) then
        zoom=Getzoom(channel)*(Status(hzoom)==0?1.0:2.0)
        SYS.Videoangle(hlivevideo,channel,0,                                   \
          zoom,Bcgetbri(channel,1),Bcgetctr(channel,1),                        \
          (channel<0?0:2)|(longexp?4:0),0.0)
        draw window=hlivevideo bkcolor=VIDEOFILL clear
        draw color=LIGHTRED font=SMALLFONT
        // Scale to the left. High accuracy is not necessary. If magnification
        // is not yet known, I use rough default.
        scalex=5.12; scaley=5.12;
        getini("System","Video scale[0]","%f,%f",&scalex,&scaley);
        if scalex>0.2 && scalex<10.0 && scaley>0.2 && scaley<10.0 then
          mminpixel=(scalex+scaley)/1024.0
        else if testertype==TT_S3 then
          mminpixel=0.001;             // 1 um per pixel
        else
          mminpixel=0.008;             // 8 um per pixel
        endif
        draw at 10,10 to 10,288-10
        if zoom/mminpixel>200 then
          ystep=0.1
        else if zoom/mminpixel>100 then
          ystep=0.2
        else if zoom/mminpixel>40 then
          ystep=0.5
        else
          ystep=1.0
        endif
        for dy=-10.0,dy<=10.0,dy=dy+ystep do
          y=288/2-dy/mminpixel*zoom
          if y<10 || y>=288-10 continue
          draw at 10,y to 16,y
          draw at 20,y+6 text=format("%.1f",Abs(dy))
        enddo
        // Central cross.
        x=(LEFTX-10)/2; y=288/2
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        redrawvideo=0
      else if Pressed(hc) then
        movecamera=1; xcoord=$LAY.xoffset/1000.0
      else if Pressed(hl) then
        movecamera=1
        if headcams then
          xcoord=$LAY.leftlimit/1000.0
        else
          xcoord=($LAY.leftlimit+$LAY.videodeadx)/1000.0
        endif
        xcoord=Max(xcoord,fromx,$LAY.leftlimit/1000.0+3.0*xstep)
      else if Pressed(hr) then
        movecamera=1
        if headcams then
          xcoord=$LAY.rightlimit/1000.0
        else
          xcoord=($LAY.rightlimit-$LAY.videodeadx)/1000.0
        endif
        xcoord=Min(xcoord,tox,$LAY.rightlimit/1000.0-3.0*xstep)
      endif
      if movecamera!=0 then
        if headcams then
          SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
          sprintf(buf,"M @%i[%g,%g] NOP",head,                                 \
            xcoord+headcamolddx[head],                                         \
            $LAY.yoffset[head/2]/1000.0+headcamolddy[head])
          SERV.Cmdimm(32,buf)
          opp=Oppositeheadcam(head)
          if illumination==0 || opp<0 then
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          else
            Oppositexycam(xcoord,$LAY.yoffset[head/2]/1000.0,opp,&oppx,&oppy,0)
            sprintf(buf,"M @%i[%f,%f] %i(Z) NOP",opp,oppx,oppy,opp^1)
            SERV.Cmdimm(32,buf)
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype & 0xC)
            SERV.Cmdimm(32,buf)
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",opp,illtype)
          endif
        else
          sprintf(buf,"M %i(%g,%g) NOP",head,xcoord,                           \
          $LAY.yoffset[$LAY.nfing]/1000.0)
        endif
        SERV.Cmdimm(32,buf)
        movecamera=0
      endif
    endif
    wait
  enddo
  if videoon!=0 then
    destroy hview
    destroy hl
    destroy hc
    destroy hr
  endif
  if channel>=0 then
    sprintf(buf,"M %i(Z) NOP",head)
    SERV.Cmdimm(32,buf)                // Move camera in home position
  endif
  if headcams SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
  if err>0 then
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Retry"
      help="Press to check tester status"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED text="Communication error! "
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from tester within expected timeout. "
    else
      draw text="Tester was unable to move up the vacuum plate. "
    endif
    if err!=2 draw text="Please check connection with crate controller. "
    draw text="Press " font=MAINFONT text="Retry " font=TIMESFONT
    draw text="to check tester status and, eventually, reboot it."
    draw show
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  return err
end

// Returns 0 on success and -1 if operator decided to interrupt the calibration.
function int Saveboardposition()
  handle hok
  if testertype==TT_S3 return          // Board position is fixed
  Drawcalboard(0,0,0,0)
  Startxyboardpos()
  clear hright
  change hinfo limits=0,0
  change hinfo text="Save board position"
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="Calibration board is placed correctly. Please update its X-Y "
  draw text="shuttle coordinates at the bottom of the left panel. They will "
  draw text="be displayed next time when you run calibration."
  draw show
  while 1 do
    Xyboardpos()
    if Pressed(hok) then
      break
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
  Finishxyboardpos()
  return 0
end

// Checks that calibration board (twostep!=2) or boards (twostep=2) is/are
// correctly placed, that needles are not broken or otherwise damaged, and that
// calibration board(s) has/have no contact to shuttle. If test is OK, does not
// move heads into home positions.
function int Checkplacement()
  int i,j,l1,l2,n,nbad,y,ident,t,err
  int softactive,softrepeat,softchanged,nocont[2][32]
  float refx[2][32],refy[2][32],dx[32],dy[32],x0,y0
  float res,cap,r[2][32],rlimit,capmax
  char s[512],s1[512],s2[128],buf[32]
  handle hretry,hreplace,hcont,htable
  if kelvinscan==3 return 0            // NOT EXACTLY! R TO SHUTTLE?..
  clear hright
  change hright help=" "
  change hinfo limits=0,0
  change hinfo text="Checking board placement"
  if demo then
    delay 500
    return 0
  endif
  if hlog!=NULL fprintf(hlog,"Checking board placement...\n")
  // In two-board mode, both boards will be checked in parallel. Get
  // coordinates.
  if twostep==2 then
    Calculateboardshift(1)
    Fillcalibrators(C_CALIBR,FILL_BOTH)
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue         // Finger is excluded from calibration
      refx[1][i]=c[i].refx0
      refy[1][i]=c[i].refy0
    enddo
    Calculateboardshift(0)
    Fillcalibrators(C_CALIBR,FILL_BOTH)
  endif
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Finger is excluded from calibration
    refx[0][i]=c[i].refx0
    refy[0][i]=c[i].refy0
  enddo
  // First step: check that fingers contact reference pads. For reliability, I
  // check each head against all other on the same side. If soft landing is
  // active and there is no contact, I set the learned soft landing correction
  // to 0.
  softactive=0
  softrepeat=0
  softchanged=1
  if calmode==MODE_CAL && (testertype==TT_A5 || testertype==TT_A5L ||          \
    testertype==TT_A6 || testertype==TT_S1 || testertype==TT_S2 ||             \
    testertype==TT_S3 || testertype==TT_A7 || testertype==TT_A8) &&            \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL ||                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP)                           \
  then
    // Check whether soft landing is active.
    if ($EXTLAY.zheadtype & HCZ_STRMASK)==HCZ_STRSOFT then
      softactive=1
    else
      buf[0]=S_INPORT32
      buf[1]=0xFF                      // Crate controller
      $uint4(buf+2)=0x10010001         // Query soft landing
      SYS.Sendimm(0,6,buf)
      t=Time()
      while Time()-t<3000 do
        if Pressed(hexit) return -1    // Button "Exit" works as an interrupt
        if $A[0].length!=0 then
          if $A[0].answer==S_INPORT32 && $uint4($A[0]+5)!=0 softactive=1
          break
        endif
        wait
      enddo
    endif
  endif
retry:
  for i=0,i<$LAY.nfing*2,i++ do
    dx[i]=(Random(refsizex)-refsizex/2.0)/2.0
    dy[i]=(Random(refsizey)-refsizey/2.0)/2.0
  enddo
  n=0
  // First shuttle.
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Finger is excluded from calibration
    l1=0; l2=0
    for j=0,j<$LAY.nfing*2,j++ do
      if c[j].ncal==0 continue
      if $LAY.side[i/2]!=$LAY.side[j/2] continue
      l1=l1+sprintf(s1+l1,"%i[%.2f,%.2fV%iP%i] ",                              \
        j,refx[0,j]+dx[j],refy[0,j]+dy[j],v,p)
      if j!=i l2=l2+sprintf(s2+l2,",%i",j)
    enddo
    // Note that if A5 tester is equipped with Kelvin needles, I use exact
    // resistance measurements to verify that both pins are electrically
    // connected to the measurement card. Otherwise, if corresponding option in
    // layout is active, tester will use alternative test method and ignore the
    // no contact.
    if $LAY.probetype==1 && (testertype==TT_A5 || testertype==TT_A5L ||        \
      testertype==TT_A6 || testertype==TT_S1 || testertype==TT_S2 ||           \
      testertype==TT_S3 || testertype==TT_A7 || testertype==TT_A8)             \
    then
      sprintf(s,"M %s E(%i%s)",s1,i,s2)
    else
      sprintf(s,"M %s R(%i%s)",s1,i,s2)
    endif
    ident=SERV.Cmdimm(i,s)
    if ident<=0 then
      err=1; break                     // Unable to send command
    endif
    n++
  enddo
  // Second shuttle, if any.
  if twostep==2 && err==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue           // Finger is excluded from calibration
      l1=0; l2=0
      for j=0,j<$LAY.nfing*2,j++ do
        if c[j].ncal==0 continue
        if $LAY.side[i/2]!=$LAY.side[j/2] continue
        l1=l1+sprintf(s1+l1,"%i[%.2f,%.2fV%iP%i] ",                            \
          j,refx[1,j]+dx[j],refy[1,j]+dy[j],v,p)
        if j!=i l2=l2+sprintf(s2+l2,",%i",j)
      enddo
      if $LAY.probetype==1 && (testertype==TT_A5 || testertype==TT_A5L ||      \
        testertype==TT_A6 || testertype==TT_S1 || testertype==TT_S2 ||         \
        testertype==TT_S3 || testertype==TT_A7 || testertype==TT_A8)           \
      then
        sprintf(s,"M %s E(%i%s)",s1,i,s2)
      else
        sprintf(s,"M %s R(%i%s)",s1,i,s2)
      endif
      ident=SERV.Cmdimm(i+32,s)
      if ident<=0 then
        err=1; break                     // Unable to send command
      endif
    enddo
  endif
  t=Time()
  while (err==0) do                    // Wait for answers
    for i=0,i<$LAY.nfing*2,i++
      if c[i].ncal==0 continue
      if $A[i].length==0 break         // Some answers are still not here
      if twostep==2 && $A[i+32].length==0 break
    enddo
    if i>=$LAY.nfing*2 break           // All answers came
    if Pressed(hexit) then
      err=-1; break                    // Operator interrupted calibration
    else if Time()-t>10000+50000/v then
      err=2; break                     // No answer within timeout
    endif
    wait
  enddo
  if boardtype==0 then rlimit=20.0;    // Resistance on FR4 limited to 20 Ohm
  else rlimit=50000.0; endif           // Resistance on glass limited to 50 kOhm
  if err==0 then                       // Analyze answers
    for i=0,i<$LAY.nfing*2,i++
      if c[i].ncal==0 continue
      if $A[i].answer!=S_MOVE || (twostep==2 && $A[i+32].answer!=S_MOVE) then
        err=3; break                   // Unexpected answer returned
      endif
      // I ignore Kelvin no contacts on glass.
      if $LAY.probetype==1 && boardtype==0 && ($A[i].status & 0x0200)!=0 then
        nocont[0][i]=1
        if err==0 err=11
      else
        nocont[0][i]=0
      endif
      r[0][i]=$A[i].r/1.0e6
      if r[0][i]>rlimit then
        if softactive==0 || softrepeat!=0 then
          err=10
        else                           // No soft landing or already changed
          sprintf(s,"OUTPORT32 HEAD(%i) 0x10010000,0",i)
          SERV.Cmdimm(63,s)
          softchanged=1
        endif
      endif
      if twostep==2 then
        if $LAY.probetype==1 && boardtype==0 &&                                \
          ($A[i+32].status & 0x0200)!=0 then
          nocont[1][i]=1
          if err==0 err=11
        else
          nocont[1][i]=0
        endif
        r[1][i]=$A[i+32].r/1.0e6
        if r[1][i]>rlimit then
          if softactive==0 || softrepeat!=0 then
            err=10
          else                         // No soft landing or already changed
            sprintf(s,"OUTPORT32 HEAD(%i) 0x10010000,0",i)
            SERV.Cmdimm(63,s)
            softchanged=1
          endif
        endif
      endif
    enddo
    if softchanged!=0 && softrepeat==0 then
      softrepeat=1
      goto retry
    endif
  endif
  if err<0 return err
  // Second step: check for the possible short to shuttle. Not necessary for
  // glass boards.
  if err==0 && boardtype==0 && (measfeatures & MF_FIXCDC)!=0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue
      if (i & 1)==0 || twostep!=2 then
        sprintf(s,"M %i[%g,%gV%iP%i] SHC(%i,RC)",                              \
        i,refx[0][i]+dx[i],refy[0][i]+dy[i],v,p,i)
      else
        sprintf(s,"M %i[%g,%gV%iP%i] SHC(%i,RC)",                              \
        i,refx[1][i]+dx[i],refy[1][i]+dy[i],v,p,i)
      endif
      SERV.Cmdimm(i,s)
    enddo
    t=Time()
    while (err==0) do                  // Wait 20 s for answers (bad meas)
      for i=0,i<$LAY.nfing*2,i++
        if c[i].ncal==0 continue
        if $A[i].length==0 break       // Some answers are still not here
      enddo
      if i>=$LAY.nfing*2 break         // All answers came
      if Pressed(hexit) then
        err=-1; break                  // Operator interrupted calibration
      else if Time()-t>20000 then
        err=2; break                   // No answer within timeout
      endif
      wait
    enddo
    nbad=0
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue
      if $A[i].answer!=S_MOVE break    // Unsupported command?
      res=$float4($A[i]+8)
      cap=$float4($A[i]+12)
      if testertype==TT_S1 then
        capmax=3000.0                  // Board directly on the shuttle!
      else if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
        capmax=500.0
      else if testertype==TT_S3 &&                                             \
        ($LAY.nfing>2 || $LAY.rightlimit-$LAY.leftlimit>450000) then
        capmax=1200.0
      else if testertype==TT_S3 then
        capmax=500.0
      else
        capmax=250.0
      endif
      if res<1.0e6 || cap>capmax nbad++
    enddo
    if err==0 && nbad>n/4 || (n<=4 && nbad>=1) then
      err=4
    endif
  endif
  if err<=0 return err
  for i=0,i<$LAY.nfing,i++
    if c[i*2].ncal==0 continue         // Finger is excluded from calibration
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    if SERV.Cmdimm(i,s)<=0 then
      err=1; break                     // Unable to send command
    endif
  enddo
  t=Time()
  while (err==0) do                    // Wait 10 s for answers
    for i=0,i<$LAY.nfing,i++
      if c[i*2].ncal==0 continue
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=$LAY.nfing break             // All answers came
    if Pressed(hexit) then
      err=-1; break                    // Operator interrupted calibration
    else if Time()-t>10000 then
      err=2; break                     // No answer within timeout
    endif
    wait
  enddo
  if err>0 then
    i=Checkgloberrors()
    if i!=0 return i
    change hinfo text="Problem with board placement!"
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,25 color=LIGHTRED
    if err==1 then
      draw text="Unable to send command!"
    else if err==2 then
      draw text="No answer within 10 seconds!"
    else if err==3 then
      draw text="Command executed incorrectly!"
    else if err==4 then
      draw text="Shortcut to shuttle!"
    else if err==10 then
      draw text="High resistance between reference pads!"
    else
      draw text="!"
    endif
    draw at 6,50 wrap=RIGHTX-5 color=BLACK
    if err<=3 then
      hretry=control BUTTON
        window=hright
        position=(RIGHTX-120)/2,USERY,120,24
        name="Check status"
        help="Press to re-check the tester status"
      endc
      draw text="Calibration procedure was unable to measure resistance "
      draw text="between the reference pads on the calibration board. It is "
      draw text="necessary to re-check the status of the tester."
    else if err==4 then
      hretry=control BUTTON
        window=hright
        position=RIGHTX/2-124,USERY,120,24
        name="Try again"
        help="Press to check for contact to ground again"
      endc
      hreplace=control BUTTON
        window=hright
        position=RIGHTX/2+5,USERY,120,24
        name="Replace"
        help=""
      endc
      draw text="With high probability, calibration board has electrical "
      draw text="contact to shuttle. If this is the case, proper calibration "
      draw text="is not possible. Please check resistance again, or reinstall "
      draw text="the board."
    else
      hretry=control BUTTON
        window=hright
        position=5,USERY+10,RIGHTX/3-5,24
        name="Try again"
        help="Press to check resistance once more"
      endc
      hreplace=control BUTTON
        window=hright
        position=5+RIGHTX/3,USERY+10,RIGHTX/3-5,24
        name="Replace"
        help=""
      endc
      hcont=control BUTTON
        window=hright
        position=5+2*(RIGHTX/3),USERY+10,RIGHTX/3-9,24
        name="Continue"
        help="Press to continue calibration at your own risk!"
      endc
      if err==10 then
        draw text="For reliable calibration, resistance between the large "
        draw text="rectangular reference pads on the calibration board must "
        draw text=format("not exceed %g Ohm. ",rlimit)
        draw text="Some resistances listed below in " color=LIGHTRED
        draw color=BLACK text="."
      else
        draw text=""
        draw text=""
        draw text=""
        draw color=LIGHTRED text=" " color=BLACK text=""
      endif
      draw text=""
      htable=control CHILD
        window=hright
        position=14,150,RIGHTX-28,130
        limits=RIGHTX-60,n*20+38
        mode=M_VSCROLL
        help=(err==10?                                                         \
          "Resistances measured between head and all other on the side":       \
          "Results of contact check")
        bkcolor=PINK
        size=4096
      endc
      y=30
      draw window=htable font=INFOFONT color=DARKGRAY mode=M_CENTERED
      draw at 5,5 to 215,5 at 5,5 to 5,32
      if twostep==2 then
        draw at 25,26 text="Head"
        draw at 45,5 to 45,32 at 130,5 to 130,32
        if err==10 then
          draw at 87,26 text="R left"
          draw at 172,26 text="R right"
        else
          draw at 87,26 text="Contact left"
          draw at 172,26 text="Contact right"
        endif
      else
        draw at 45,26 text="Head"
        draw at 85,5 to 85,32
        if err==10 then
          draw at 150,26 text="Resistance"
        else
          draw at 150,26 text=""
        endif
      endif
      draw at 215,5 to 215,33
      draw at 5,32 to 215,32
      draw font=FIXEDSYS
      if hlog!=NULL then
        if err==10 fprintf(hlog,"  High resistance between reference pads:\n")
        if err==11 fprintf(hlog,"  Bad contacts on reference pads:\n")
      endif
      for i=0,i<$LAY.nfing*2,i++ do
        if c[i].ncal==0 continue       // Head excluded from calibration
        y=y+20
        draw color=DARKGRAY
        draw at 5,y-18 to 5,y+2 to 215,y+2 to 215,y-18
        if twostep==2 then
          draw at 45,y-18 to 45,y+2
          draw at 25,y
        else
          draw at 85,y-18 to 85,y+2
          draw at 45,y
        endif
        draw color=BLACK text=format("%i%c",i/2,(i & 1?'R':'L'))
        if twostep==2 then
          draw at 87,y
          if err==10 then
            SERV.Ohmsshort(r[0][i],0,s)
            draw color=(r[0][i]<=rlimit?BLACK:LIGHTRED) text=s
            if r[0][i]>rlimit && hlog!=NULL then
              SERV.Ohmstotext(r[0][i],0,s)
              fprintf(hlog,"  Head %i%c, left shuttle:  "                      \
              "R=%s\n",i/2,(i & 1?'R':'L'),s)
            endif
          else
            draw color=(nocont[0][i]==0?BLACK:LIGHTRED)
            draw text=(nocont[0][i]==0?"OK":"")
            if nocont[0][i]!=0 && hlog!=NULL then
              fprintf(hlog,"  Head %i%c, left shuttle:  "                      \
              "No contact\n",i/2,(i & 1?'R':'L'))
            endif
          endif
          draw color=DARKGRAY at 130,y-18 to 130,y+2
          draw at 172,y
          if err==10 then
            SERV.Ohmsshort(r[1][i],0,s)
            draw color=(r[1][i]<=rlimit?BLACK:LIGHTRED) text=s
            if r[1][i]>rlimit && hlog!=NULL then
              SERV.Ohmstotext(r[1][i],0,s)
              fprintf(hlog,"  Head %i%c, right shuttle: "                      \
              "R=%s\n",i/2,(i & 1?'R':'L'),s)
            endif
          else
            draw color=(nocont[1][i]==0?BLACK:LIGHTRED)
            draw text=(nocont[1][i]==0?"OK":"")
            if nocont[1][i]!=0 && hlog!=NULL then
              fprintf(hlog,"  Head %i%c, right shuttle: "                      \
              "No contact\n",i/2,(i & 1?'R':'L'))
            endif
          endif
        else
          draw at 150,y
          if err==10 then
            SERV.Ohmstotext(r[0][i],0,s)
            draw color=(r[0][i]<=rlimit?BLACK:LIGHTRED) text=s
            if r[0][i]>rlimit && hlog!=NULL then
              fprintf(hlog,"  Head %i%c: R=%s\n",i/2,(i & 1?'R':'L'),s)
            endif
          else
            draw color=(nocont[0][i]==0?BLACK:LIGHTRED)
            draw text=(nocont[0][i]==0?"OK":"")
            if nocont[0][i]!=0 && hlog!=NULL then
              fprintf(hlog,"  Head %i%c: No contact\n",i/2,(i & 1?'R':'L'))
            endif
          endif
        endif
      enddo
      draw show
      setfocus htable
    endif
    draw window=hright show
    while 1 do
      if err<=3 then
        if Pressed(hretry) return 1    // Check status of the tester
      else if err==4 then
        if Pressed(hretry) return 2    // Check resistance again
        if Pressed(hreplace) return 3  // Replace calibration board
      else
        if Pressed(hretry) return 2    // Check resistance again
        if Pressed(hreplace) return 3  // Replace calibration board
        if Pressed(hcont) then
          if hlog!=NULL then
            fprintf(hlog,"  Operator decided to continue calibration\n")
          endif
          return 0                     // Accept test results
        endif
      endif
      if Pressed(hexit) return -1
      wait
    enddo
  endif
  return err
end

// Check that heads are correctly connected to multiplexer. If both analog
// cables and control cable for left and right head are mixed up, calibration
// will succeed but subsequent operation will be not possible. Returns 0 on
// success, 1 on request to reload tester, 2 to retry this test, 3 to change
// board placement and -1 if user unterrupted the calibration.
function int Checkorder()
  int i,j,m,n,t,y,head,nhead,rvalid[32],err
  float x0,y0,r,rmax[32]
  char s[512],w[256]
  handle hskip,hrepair,hretry,hcont,htable
  if demo || kelvinscan==1 || kelvinscan==2 return 0
  if firsttop>=lasttop && firstbot>=lastbot return 0
  change hinfo limits=0,0
  change hinfo text="Checking connections"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="If cables of left and right heads are interchanged on the "
  draw text="multiplexer, calibration will succeed but all subsequent tests "
  draw text="will fail. This error is hard to find, therefore script will "
  draw text="check analog connections. Please wait..."
  draw show
  if hlog!=NULL fprintf(hlog,"Checking multiplexer connections...\n")
  hskip=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Skip"
    help="Press to skip connections test"
  endc
  i=Waitcancel(hskip)
  if i<0 return i
  if i>0 return 0                      // Step skipped by user
  for head=0,head<$LAY.nfing*2,head++ do
    rvalid[head]=0
    rmax[head]=0.0
  enddo
  err=0
  for j=0,j<4 && err==0,j++ do
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      // Get X contacting coordinate.
      x0=$LAY.xoffset/1000.0+boardshift
      if (head & 1)==0 then            // Left heads
        while x0-2*xstep>c[head].refx do
          x0=x0-xstep
        enddo
        x0=x0+xstep/2.0
      else                             // Right heads
        while x0+2*xstep<c[head].refx do
          x0=x0+xstep
        enddo
        x0=x0-xstep/2.0
      endif
      // I select distance between the points in such way that simultaneous
      // shorts to wire are not possible.
      y0=$LAY.yoffset[head/2]/1000.0+((j & 1)==0?-ystep/2.5:ystep/2.5)
      m=sprintf(w,"R(%i",head)         // Gathers measurement
      n=sprintf(s,"M ")                // Gathers heads
      for i=0,i<$LAY.nfing*2,i++ do
        if c[i].ncal==0 continue
        if $LAY.side[i/2]!=$LAY.side[head/2] continue
        if i==head then                // Head to test
          n=n+sprintf(s+n,"%i(%g,%gV%iP%i) ",i,x0,y0,v,p)
        else                           // Reference head
          m=m+sprintf(w+m,",%i",i)
          n=n+sprintf(s+n,"%i[%g,%gV%iP%i] ",i,c[i].refx,c[i].refy,v,p)
        endif
      enddo
      sprintf(s+n,"%s)",w)
      if SERV.Cmdimm(head,s)<=0 err=1
    enddo
    // Wait for answers.
    t=Time()
    while err==0 do
      if Pressed(hexit) then
        err=-1; break                  // Operator interrupted calibration
      else if Pressed(hskip) then
        err=2; break                   // Operator skipped this test
      else if Time()-t>10000+50000/v then
        err=3; break                   // No answer within timeout
      endif
      for head=0,head<$LAY.nfing*2,head++ do
        if c[head].ncal==0 continue
        if $A[head].length==0 break
      enddo
      if head>=$LAY.nfing*2 break
    enddo
    // Analyse answers.
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      if $A[head].answer!=S_MOVE then
        err=4; break                   // Unexpected answer returned
      endif
      r=$A[head].r; if ($A[head].status & 0x0100) r=r*1.0e-6
      if ($A[head].status & 0x8E00)!=0 continue
      rvalid[head]=1
      rmax[head]=Max(rmax[head],r)
    enddo
  enddo
  // Test finished, check for results.
  if err<0 return err
  if err==0 then
    for head=0,head<$LAY.nfing*2,head++ do
      if c[head].ncal==0 continue
      if rvalid[head]==0 continue      // Better idea?
      if rmax[head]<1.0e8 then
        err=5
      endif
    enddo
  endif
  if err==0 return 0
  // Something is wrong, recover and inform operator.
  for i=0,i<$LAY.nfing*2,i++ do
    SYS.Killimm(i)
  enddo
  change hinfo limits=0,0
  if err==1 || err==3 || err==4 then
    // Error when executing the command.
    clear hright
    draw window=hright color=LIGHTRED font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text "Unable to test connections. " color=BLACK
    if err==1 then
      draw text="Script was unable to send commands to tester. "
    else if err==3 then
      draw text="There was no answer from the tester within the expected "
      draw text="timeout. "
    else
      draw text="Some commands were rejected by tester. "
    endif
    draw text="Please decide what to do."
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Retry"
      help="Press to repeat this test"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
    while 1 do
      if Pressed(hexit) then
        return -1
      else if Pressed(hretry) then
        return 2
      else if Pressed(hcont) then
        return 0
      endif
      wait
    enddo
  else if err==2 then
    // Operator skipped this test.
    return 0
  else
    // Some needles probably have invalid multiplexer connections.
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    change hinfo text="Invalid connections"
    draw at 6,30 color=LIGHTRED
    draw text="Some heads have low resistance to bare substrate. "
    draw color=BLACK text="Probably they are connected to wrong multiplexer "
    draw text="outputs (both analog and control cables!). Please consult the "
    draw text="table and decide what to do next."
    draw show
    nhead=0
    for head=0,head<$LAY.nfing*2,head++ do
      if c[head].ncal==0 continue
      nhead++
    enddo
    htable=control CHILD
      window=hright
      position=15,115,RIGHTX-30,155
      limits=RIGHTX-20,nhead*20+38
      mode=M_VSCROLL
      help="Results of capacitive test of needles"
      bkcolor=PINK
      size=4096
    endc
    y=30
    draw window=htable font=INFOFONT color=DARKGRAY
    draw at 5,5 to 205,5
    draw at 5,5 to 5,32 at 29,26 text="Head"
    draw at 85,5 to 85,32 at 104,26 text="R to substrate"
    draw at 205,5 to 205,33
    draw at 5,32 to 205,32
    draw font=FIXEDSYS
    if hlog!=NULL then
      fprintf(hlog,"  Invalid order of multiplexer connections:\n")
    endif
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue         // Head excluded from calibration
      y=y+20
      draw color=DARKGRAY
      draw at 5,y-18 to 5,y+2 to 205,y+2 to 205,y-18
      draw at 85,y-18 to 85,y+2
      draw at 30,y color=BLACK
      draw text=format("%2i%c",i/2,(i & 1?'R':'L'))
      draw at 98,y
      SERV.Ohmstotext(rmax[i],0,s)
      draw color=(rmax[i]>=1.0e8?BLACK:LIGHTRED) text=s
      if rmax[i]>1.0e8 && hlog!=NULL then
        fprintf(hlog,"  %i%c  R=%s\n",i/2,(i & 1?'R':'L'),s)
      endif
    enddo
    draw show
    setfocus htable
    hrepair=control BUTTON
      window=hright
      position=5,USERY+10,RIGHTX/3-5,24
      name="Quit"
      help="Press to quit calibration and repair needles"
    endc
    hretry=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY+10,RIGHTX/3-5,24
      name="Retry"
      help="Press to repeat measurements"
    endc
    hcont=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY+10,RIGHTX/3-9,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
    while 1 do
      if Pressed(hexit) || Pressed(hrepair) then
        return -1
      else if Pressed(hretry) then
        return 2
      else if Pressed(hcont) then
        if hlog!=NULL then
          fprintf(hlog,"  Operator decided to continue calibration\n")
        endif
        return 0
      endif
      wait
    enddo
  endif
  return 0
end

// Check that needle shields are electrically connected to the on-head and that
// shielding of the "blue cable" has no shortcut to ground. The first one is a
// relatively frequent error on A5/A6 with splinogramms or splinogramm adapters
// that has no influence on the calibration itself, but repairing the contact
// will force user to repeat calibration. The second is a dangerous error that
// can't be detected by other means.
function int Checkshields()
  int i,j,n,t,y,rail,arail,head,nhead,opp,side
  int noffs,skip[32],err,firstbad
  char s[256]
  float x0,y0,zc,zr,fc,ymin,ymax,dy,deltax[32],deltay[32]
  float temp,cmin[32],cmax,f[32][50],fmin[32],yoffs[50],stat[5]
  handle hskip,htable,hrepair,hretry,hcont
  if demo || kelvinscan==1 || kelvinscan==2 return 0
  change hinfo limits=0,0
  change hinfo text="Checking shields"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now calibration will check that "
  if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL ||                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL ||                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP ||                         \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTEMU                            \
  then
    if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTEMU then
      draw text="shields of splinogramm adapters "
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
      draw text="shields of soft parallelogramms "
    else
      draw text="shields of splinogramms "
    endif
    draw text="have good electrical contact to the adapter, and that "
  endif
  draw text="the shields of analog on-head cables have no contact to the "
  draw text="ground. Errors of this kind have negative influence on field and "
  draw text="capacity measurements and may lead to missed shorts, but neither "
  draw text="soft reset nor calibration are able to detect it. Please wait..."
  draw show
  if hlog!=NULL fprintf(hlog,"Checking shields...\n")
  hskip=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Skip"
    help="Press to skip shield checking"
  endc
  for i=0,i<$LAY.nfing*2,i++ do
    cmin[i]=1.0e12
    fmin[i]=1.0e12
    deltax[i]=0.0
    deltay[i]=0.0
  enddo
  // If extended layout requests capacity calibration in the air, reset this
  // bit for the duration of the test.
  if ($EXTLAY.extcfg & EXT_CAIR)!=0 then
    $EXTLAY.extcfg=$EXTLAY.extcfg & (~EXT_CAIR)
    Sendmainextention()
    $EXTLAY.extcfg=$EXTLAY.extcfg | EXT_CAIR
  endif
  // Touch each space between the calibration grid lines twice. Shorts to
  // ground are frequently position-dependent.
  if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
    ymin=-75.0
    ymax=75.0
  else
    ymin=1.0e10; ymax=-1.0e10;
    for rail=0,rail<$LAY.nfing,rail++ do
      if c[rail*2].ncal==0 continue
      ymin=Min(ymin,($LAY.bottom[rail]-$LAY.yoffset[rail])/1000.0)
      ymax=Max(ymax,($LAY.top[rail]-$LAY.yoffset[rail])/1000.0)
    enddo
  endif
  dy=-ystep*2.0/3.0
  while dy-ystep>ymin do
    dy=dy-ystep
  enddo
  noffs=0
  while dy+ystep/3.0<ymax && noffs<50 do
    yoffs[noffs]=dy; noffs++
    yoffs[noffs]=dy+ystep/3.0; noffs++
    dy=dy+ystep
  enddo
  if $uint2($EXTLAY+636)==NT_MICROSHLD then
    cmax=CMAXSHLD
  else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
    cmax=CMAXSHLD
  else if ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP then
    cmax=CMAXSTD
  else if $LAY.probetype==1 then
    cmax=CMAXKELV
  else
    cmax=CMAXSKP
  endif
  err=0
  // Check first left, then right heads.
  for side=0,side<2 && err==0,side++ do
    // Walk all selected points.
    for j=0,j<noffs && err==0,j++ do
      // Check all heads on the selected left or right side.
      for rail=0,rail<$LAY.nfing && err==0,rail++ do
        head=rail*2+side
        opp=rail*2+1-side
        if c[head].ncal==0 then
          skip[head]=1; continue
        endif
        f[head][j]=1.0e12
        // Get X contacting coordinate.
        x0=$LAY.xoffset/1000.0+boardshift
        if side==0 then
          while x0-2*xstep>c[head].refx do
            x0=x0-xstep
          enddo
          x0=x0+xstep/2.0
        else
          while x0+2*xstep<c[head].refx do
            x0=x0+xstep
          enddo
          x0=x0-xstep/2.0
        endif
        // Get Y contacting coordinate.
        y0=$LAY.yoffset[rail]/1000.0+yoffs[j]
        // Check whether point is reachable and on the calibration board.
        if y0<$LAY.bottom[rail]/1000.0+MAXCORRY ||                             \
          y0>$LAY.top[rail]/1000.0-MAXCORRY then
          skip[head]=1; continue
        endif
        if testertype==TT_A5L && smallboard==0 &&                              \
          (y0<$LAY.top[0]/1000.0-225.0+MAXCORRY ||                             \
          y0>$LAY.top[0]/1000.0+225.0-MAXCORRY) then
          skip[head]=1; continue
        else if testertype==TT_A5L && smallboard!=0 &&                         \
          (y0<$LAY.top[smallfirst]/1000.0-200.0+MAXCORRY ||                    \
          y0>$LAY.top[smallfirst]/1000.0+200.0-MAXCORRY) then
          skip[head]=1; continue
        else if testertype==TT_A7 && smallboard==0 &&                          \
          (y0<$LAY.top[0]/1000.0-250.0+MAXCORRY ||                             \
          y0>$LAY.bottom[$LAY.nfing-1]/1000.0+250.0-MAXCORRY) then
          skip[head]=1; continue
        else if testertype==TT_A7 && smallboard!=0 &&                          \
          (y0<$LAY.top[smallfirst]/1000.0-225.0+MAXCORRY ||                    \
          y0>$LAY.bottom[smalllast]/1000.0+225.0-MAXCORRY) then
          skip[head]=1; continue
        endif
        n=sprintf(s,"M %i(%g,%gV%iP%i) GROUP(%i,1,%i) ",                       \
          head,x0,y0,v,p,head+1,head+1)
        if (kelvinscan==3) then
          sprintf(s+n,"F(%i,32,32,32)",head)
        else
          sprintf(s+n,"%i[%g,%gV%iP%i] F(%i,%i,%i,%i)",opp,                    \
          c[opp].refx+deltax[head],c[opp].refy+deltay[head],v,p,               \
          head,opp,opp,opp)
        endif
        // Send command.
        SERV.Cmdimm(32,s)              // Dummy preliminary measurement
        if SERV.Cmdimm(head,s)<=0 then
          err=1; break                 // Unable to send command
        endif
        skip[head]=0
      enddo
      // Wait for answers.
      t=Time()
      while (err==0) do
        for rail=0,rail<$LAY.nfing,rail++ do
          head=rail*2+side
          if skip[head] continue
          if $A[head].length==0 break  // Some answers are still not here
        enddo
        if rail>=$LAY.nfing break      // All answers came
        if Pressed(hexit) then
          err=-1; break                // Operator interrupted calibration
        else if Pressed(hskip) then
          err=2; break                 // Operator skipped this test
        else if Time()-t>10000+50000/v then
          err=3; break                 // No answer within timeout
        endif
        wait
      enddo
      change hinfo limits=noffs*side+j+1,noffs*2
      // Process results.
      for rail=0,rail<$LAY.nfing && err==0,rail++ do
        head=rail*2+side
        if skip[head] continue
        if $A[head].answer!=S_MOVE || $A[head].subansw!=S_FIELD err=4
        if ($A[head].status & 0x9820)!=0 continue
        zc=1.0e12; SERV.Convertfield($A[head],&zc,&zr)
        // Remove sure no-contacts in antenna. Note however that original hard
        // touch (non-adapter) needles and shielded micro needles are so good
        // that the measured capacity is anyway close to 0. I recontact but
        // don't treat such measurements as bad.
        if zc<cmax*0.15-0.005 then
          deltax[head]=Random(DELTA)-DELTA/2
          deltay[head]=Random(DELTA)-DELTA/2
          if $uint2($EXTLAY+636)==NT_MICROSHLD ||                              \
            (testertype==TT_A5 || testertype==TT_A5L ||                        \
            testertype==TT_A6 || testertype==TT_S1 || testertype==TT_S2 ||     \
            testertype==TT_S3 || testertype==TT_A7 || testertype==TT_A8) &&    \
            ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTDEF &&                 \
            ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSTD                    \
          then
            continue
          endif
        endif
        if zc>50.0 continue            // Stays on line?
        cmin[head]=Min(cmin[head],zc)
        fc=Max($int2($A[head]+32),$int2($A[head]+36))
        f[head][j]=fc
      enddo
    enddo
  enddo
  // Note that there may be no contacts in antenna during field measurement.
  // This will be interpreted as a disconnected shield. Therefore I skip
  // noffs/4 results with the lowest field. This way we may lose
  // angle-dependent contacts, but avoid annoying false positives.
  for head=0,head<$LAY.nfing*2 && err==0,head++ do
    if c[head].ncal==0 continue
    // Bubble sort!
    for i=0,i<noffs-1,i++ do
      for j=i+1,j<noffs,j++ do
        if f[head][i]>f[head][j] then
          temp=f[head][i]; f[head][i]=f[head][j]; f[head][j]=temp
        endif
      enddo
    enddo
    fmin[head]=f[head][noffs/4]
  enddo
  // Restore capacity calibration.
  if ($EXTLAY.extcfg & EXT_CAIR)!=0 then
    Sendmainextention()
  endif
  // Now analyse the results.
  if err==0 then
    // Process field. As the conversion from capacity to field requires
    // knowledge of the input capacity and it may strongly vary, I just take
    // mean as a limit. Note that we must exclude heads with possible
    // no contsct in shield: they deliver much higher field values.
    Initsigma(stat)
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue
      if fmin[i]<1.0e10 && cmin[i]<=cmax Addsigma(stat,fmin[i])
    enddo
    // Process capacity and protocol results.
    nhead=0
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue
      nhead++
      if hlog!=NULL then
        fprintf(hlog,"  Head %i%s: ",i/2,(i & 1?"R":"L"));
        if cmin[i]<=3.0 then
          fprintf(hlog,"capacity %6.3f pf, ",cmin[i])
        else
          fprintf(hlog,"invalid capacity,   ")
        endif
        if fmin[i]<1.0e10 then
          fprintf(hlog,"field %5.0f bits",fmin[i])
        else
          fprintf(hlog,"invalid field   ")
        endif
      endif
      if cmin[i]>3.0 then              // Capacity is too high or not measured
        if err==0 then
          err=5; firstbad=i
        endif
      else if cmin[i]>cmax then        // Probably no contact
        if hlog!=NULL fprintf(hlog," (shield?)")
        if err!=6 firstbad=i
        err=6
      endif
      if ($LAY.config & LC_TYPEMASK)!=LC_S1 && fmin[i]<Getmean(stat)/2.0 then
        if hlog!=NULL fprintf(hlog," (shortcut?)")
        if err!=6 then
          err=7; firstbad=i
        endif
      endif
      if hlog!=NULL fprintf(hlog,"\n")
    enddo
  endif
  if err<=0 return err
  // Something is wrong, recover and inform operator.
  change hinfo limits=0,0
  for i=0,i<$LAY.nfing*2,i++ do
    SYS.Killimm(i)
  enddo
  if err==1 || err==3 || err==4 then
    // Error when executing the command.
    clear hright
    draw window=hright color=LIGHTRED font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text "Unable to test needles. " color=BLACK
    if err==1 then
      draw text="Script was unable to send commands to tester. "
    else if err==3 then
      draw text="There was no answer from the tester within the expected "
      draw text="timeout. "
    else
      draw text="Some commands were rejected by tester. "
    endif
    draw text="Please decide what to do."
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Retry"
      help="Press to repeat this test"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
    while 1 do
      if Pressed(hexit) then
        return -1
      else if Pressed(hretry) then
        return 1
      else if Pressed(hcont) then
        if hlog!=NULL then
          fprintf(hlog,"  Operator decided to continue calibration\n")
        endif
        return 0
      endif
      wait
    enddo
  else if err==2 then
    // Operator skipped this test.
    return 0
  else
    // Some needles are not tested or probably feature no contact to shield, or
    // shield is shortcut to the ground.
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==6 then
      change hinfo text="Shield not connected"
      draw text="One or more needles (for example, on head "
      draw text=format("%i%c) may have no ",firstbad/2,firstbad & 1?'R':'L')
      draw text="contact to shield. " color=BLACK text="The corresponding "
      draw text="contacts are pointed by arrows on the picture. "
    else if err==7 then
      change hinfo text="Shortcut to ground"
      draw text="One or more needles (for example, on head "
      draw text=format("%i%c) may have ",firstbad/2,firstbad & 1?'R':'L')
      draw text="shortcut between the shield and the ground. " color=BLACK
    else
      change hinfo text=""
      draw text=". "
      draw color=BLACK
    endif
    draw text="."
    draw show
    if err==6 then
      clear hleft
      draw window=hleft at 50,50 bitmap=0,0,0,"splcont" show
    endif
    htable=control CHILD
      window=hright
      position=9,115,RIGHTX-18,155
      limits=RIGHTX-48,nhead*20+38
      mode=M_VSCROLL
      help="Results of capacitive test of needles"
      bkcolor=PINK
      size=4096
    endc
    y=30
    draw window=htable font=INFOFONT color=DARKGRAY
    draw at 5,5 to 225,5
    draw at 5,5 to 5,32 at 9,26 text="Head"
    draw at 45,5 to 45,32 at 61,26 text="C,pF"
    draw at 105,5 to 105,32 at 121,26 text="F,bit"
    draw at 165,5 to 165,32 at 173,26 text=""
    draw at 225,5 to 225,33
    draw at 5,32 to 225,32
    draw font=FIXEDSYS
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue         // Head excluded from calibration
      y=y+20
      draw color=DARKGRAY
      draw at 5,y-18 to 5,y+2 to 225,y+2 to 225,y-18
      draw at 45,y-18 to 45,y+2
      draw at 105,y-18 to 105,y+2
      draw at 165,y-18 to 165,y+2
      draw at 10,y color=BLACK text=format("%2i%c",i/2,(i & 1)==0?'L':'R')
      draw at 54,y
      if cmin[i]>99.0 then             // Capacity is totally bad
        draw color=LIGHTRED text="  -"
      else
        draw color=(cmin[i]<=cmax?BLACK:LIGHTRED)
        draw text=format("%5.3f",cmin[i])
      endif
      draw at 114,y
      if fmin[i]>1.0e10 then           // Field is totally bad
        draw color=LIGHTRED text="  -"
      else
        draw color=(fmin[i]<Getmean(stat)/2.0?LIGHTRED:BLACK)
        draw text=format("%5.0f",fmin[i])
      endif
      draw at 173,y
      if cmin[i]>3.0 then              // Unable to measure capacity
        draw color=LIGHTRED text=" C"
      else if cmin[i]>cmax then        // Probably no contact
        draw color=LIGHTRED text="Shield"
      else if fmin[i]>1.0e10 then      // Unable to measure field
        draw color=LIGHTRED text="Bad F"
      else if fmin[i]<Getmean(stat)/2.0 then // Short to ground
        draw color=LIGHTRED text="Short"
      else
        draw color=BLACK text="OK"
      endif
    enddo
    draw show
    setfocus htable
    hrepair=control BUTTON
      window=hright
      position=5,USERY+10,RIGHTX/3-5,24
      name="Quit"
      help="Press to quit calibration and repair needles"
    endc
    hretry=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY+10,RIGHTX/3-5,24
      name="Retry"
      help="Press to repeat measurements"
    endc
    hcont=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY+10,RIGHTX/3-9,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
    while 1 do
      if Pressed(hexit) || Pressed(hrepair) then
        Drawcalboard(0,0,0,0)
        return -1
      else if Pressed(hretry) then
        Drawcalboard(0,0,0,0)
        return 1
      else if Pressed(hcont) then
        if hlog!=NULL then
          fprintf(hlog,"  Operator decided to continue calibration\n")
        endif
        Drawcalboard(0,0,0,0)
        return 0
      endif
      wait
    enddo
  endif
  return 0
end

// Checks that calibration board (twostep!=2) or boards (twostep==2) is/are not
// bent or otherwise deformed, and sets stroke for old-style calibration
// commands (like S_CALIBR). In 3-D calibration mode additionally verifies that
// Z distance from the last calibration is sufficiently high.
function int Checkbending()
  int i,j,k,n,t,ident,err,nover,nmeanpos,nz
  float x1,x2,y,zboard,dx,dy,ymin,ymax
  float zmeas,zmin[2][16],zmax[2][16],zmean[2][16],maxdiff
  float zold,minzdiff,zfactor,maxhilo,meanpos
  float alloweddiff,vc,pc,refx[2][32],refy[2][32]
  char s[128]
  handle hretry,hreplace,hcont,htable
  clear hright
  change hright help=" "
  change hinfo limits=0,0
  change hinfo text="Checking board bending"
  if demo then
    delay 500
    return 0
  endif
  if hlog!=NULL fprintf(hlog,"Checking board bending...\n");
  zfactor=1000.0                       // INPORT units in 1 millimeter
  if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||           \
    testertype==TT_A2H then
    maxhilo=3000.0/zfactor
  else if testertype==TT_A4 || testertype==TT_A6 ||                            \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A8 then
    maxhilo=4000.0/zfactor
  else if testertype==TT_A3 || testertype==TT_A3L ||                           \
    testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A7 then
    maxhilo=5000.0/zfactor             // Longer parallelogramms
  else
    maxhilo=3000.0/zfactor             // For extra security
  endif
  // Allowed board bending/inclination.
  if testertype==TT_S3 then
    alloweddiff=(boardtype==0?1.5:0.3)
  else if testertype==TT_S1 then
    alloweddiff=(boardtype==0?2.0:0.7)
  else
    alloweddiff=(boardtype==0?4.0:1.5)
  endif
  for i=0,i<16,i++                     // Rail
    for j=0,j<2,j++ do
      zmin[j][i]=999999999.9
      zmax[j][i]=-999999999.9
      zmean[j][i]=0.0
    enddo
  enddo
  for i=0,i<32,i++ do                  // Head
    oversurface[i]=0
  enddo
  meanpos=0.0; nmeanpos=0
  minzdiff=99999.9
  Fillcalibrators(C_CORNER,FILL_MECH)
  vc=Max(60.0,v)
  pc=Max(60.0,p)
  // In two-board mode, both boards will be checked in parallel. Get offset.
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Finger is excluded from calibration
    refx[0][i]=c[i].refx0; refx[1][i]=refx[0][i]
    refy[0][i]=c[i].refy0; refy[1][i]=refy[0][i]
  enddo
  if twostep==2 then
    Calculateboardshift(1)
    Fillcalibrators(C_CALIBR,FILL_BOTH)
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue         // Finger is excluded from calibration
      refx[1][i]=c[i].refx0
      refy[1][i]=c[i].refy0
    enddo
    Calculateboardshift(0)
    Fillcalibrators(C_CALIBR,FILL_BOTH)
  endif
  for j=0,j<10,j++                     // 9 points to check bending + CHECK0
    if err!=0 break
    for i=0,i<$LAY.nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      if j<9 then
        k=j%3
        if j/3==0 then
          x1=refx[0][i*2]+xstep/2      // Don't touch lines on the board!
          x2=refx[1][i*2+1]+xstep/2
        else if j/3==1 then
          x1=(refx[0][i*2]+refx[0][i*2+1])/2.0+xstep/4
          x2=(refx[1][i*2]+refx[1][i*2+1])/2.0+xstep/4
          k=2-k                        // Another test sequence
        else
          x1=refx[0][i*2+1]-xstep/2
          x2=refx[1][i*2+1]-xstep/2
        endif
        ymin=Min(c[i*2].bottomliney,c[i*2].centerliney,c[i*2].topliney)
        ymax=Max(c[i*2].bottomliney,c[i*2].centerliney,c[i*2].topliney)
        if k==0 y=ymin+ystep/4
        if k==1 y=(ymin+ymax)/2+ystep/4
        if k==2 y=ymax-ystep/4
        // Make two Z measurements for reliability.
        n=sprintf(s,"M %i(%g,%gH99V%iP%i) ",i*2,x1-0.1,y,vc,pc)
        if twostep!=2 n=n+sprintf(s+n," %i(Z)",i*2+1)
        sprintf(s+n," Z(%i)",i*2)
        if SERV.Cmdimm(i*2+0,s)<=0 then
          err=1; break                 // Unable to send command
        endif
        n=sprintf(s,"M %i(%g,%gH99V%iP%i) ",i*2,x1+0.1,y,vc,pc)
        if twostep!=2 n=n+sprintf(s+n," %i(Z)",i*2+1)
        sprintf(s+n," Z(%i)",i*2)
        if SERV.Cmdimm(i*2+1,s)<=0 then
          err=1; break                 // Unable to send command
        endif
        if twostep==2 then
          sprintf(s,"M %i(%g,%gH99V%iP%i) Z(%i)",i*2+1,x2-0.1,y,vc,pc,i*2+1)
          if SERV.Cmdimm(i*2+32,s)<=0 then
            err=1; break               // Unable to send command
          endif
          sprintf(s,"M %i(%g,%gH99V%iP%i) Z(%i)",i*2+1,x2+0.1,y,vc,pc,i*2+1)
          if SERV.Cmdimm(i*2+33,s)<=0 then
            err=1; break               // Unable to send command
          endif
        endif
      else
        sprintf(s,"M %i(Z) NOP",i*2)
        if SERV.Cmdimm(i*2+0,s)<=0 then
          err=1; break                 // Unable to send command
        endif
        if twostep==2 then
          sprintf(s,"M %i(Z) NOP",i*2+1)
          if SERV.Cmdimm(i*2+32,s)<=0 then
            err=1; break               // Unable to send command
          endif
        endif
      endif
    enddo
    t=Time()+12000                     // Wait 12 s for answers
    while (err==0) do
      for i=0,i<$LAY.nfing,i++
        if c[i*2].ncal==0 continue
        if $A[i*2+0].length==0 || $A[i*2+1].length==0 break
        if twostep==2 && ($A[i*2+32].length==0 || $A[i*2+33].length==0) break
      enddo
      if i>=$LAY.nfing break           // All answers came
      if Pressed(hexit) then
        err=-1; break                  // Operator interrupted calibration
      else if Time()>t then
        err=2; break                   // No answer within timeout
      endif
      wait
    enddo
    if err==0 then                     // Analyze answers
      for i=0,i<$LAY.nfing,i++
        if c[i*2].ncal==0 continue
        if j<9 then
          zboard=0.0; nz=0
          if $A[i*2+0].answer==S_INPORT then
            zboard=Max(zboard,$A[i*2+0].inport); nz++
          endif
          if $A[i*2+1].answer==S_INPORT then
            zboard=Max(zboard,$A[i*2+1].inport); nz++
          endif
          if nz==0 then
            err=3; break               // Unexpected answer returned
          endif
          if calmode==MODE_3DCAL then
            // Note that only left heads (same direction of X-Y) are tested.
            // 3-D calibration does not support two-board setup.
            dx=x1-$LAY.xoffset/1000.0
            dy=y-$LAY.yoffset[i]/1000.0
            zold=c3dold[i*2].zcenter+                                          \
              c3dold[i*2].zfactorx*dx+c3dold[i*2].zfactory*dy
            minzdiff=Min(minzdiff,Abs(zold-zboard))
          endif
          if testertype==TT_A1 then
            zmeas=zboard/zfactor
          else
            zmeas=(zboard-32768)/zfactor
          endif
          zmin[0][i]=Min(zmin[0][i],zmeas)
          zmax[0][i]=Max(zmax[0][i],zmeas)
          zmean[0][i]=zmean[0][i]+zmeas/9.0
          meanpos=meanpos+zmeas
          nmeanpos++
          if twostep==2 then
            zboard=0.0; nz=0
            if $A[i*2+32].answer==S_INPORT then
              zboard=Max(zboard,$A[i*2+32].inport); nz++
            endif
            if $A[i*2+33].answer==S_INPORT then
              zboard=Max(zboard,$A[i*2+33].inport); nz++
            endif
            if nz==0 then
              err=3; break             // Unexpected answer returned
            endif
            zmin[1][i]=Min(zmin[1][i],zmeas)
            zmax[1][i]=Max(zmax[1][i],zmeas)
            zmean[1][i]=zmean[1][i]+zmeas/9.0
            meanpos=meanpos+zmeas
            nmeanpos++
          endif
        endif
      enddo
    endif
  enddo
  if nmeanpos>0 meanpos=meanpos/nmeanpos
  if err<0 then                        // Operator interrupted calibration
    return err
  else if err==0 then                  // Check that bending is OK
    delay 500                          // Wait till error messages come
    maxdiff=0.0
    if hlog!=NULL then
      fprintf(hlog,"  Measured height differences in 9 reference points:\n");
    endif
    for i=0,i<$LAY.nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      if hlog!=NULL then
        if twostep==2 then
          fprintf(hlog,"  Rail %2i, left shuttle:  %4.2f mm  (%.2f..%.2f)\n",  \
          i,zmax[0][i]-zmin[0][i],zmin[0][i],zmax[0][i])
          fprintf(hlog,"  Rail %2i, right shuttle: %4.2f mm  (%.2f..%.2f)\n",  \
          i,zmax[1][i]-zmin[1][i],zmin[1][i],zmax[1][i])
        else
          fprintf(hlog,"  Rail %2i: %4.2f mm  (%.2f..%.2f)\n",                 \
          i,zmax[0][i]-zmin[0][i],zmin[0][i],zmax[0][i])
        endif
      endif
      maxdiff=Max(maxdiff,zmax[0][i]-zmin[0][i])
      if twostep==2 then
        maxdiff=Max(maxdiff,zmax[1][i]-zmin[1][i])
      endif
      if Abs(zmean[0][i]-meanpos)>=maxhilo && calmode!=MODE_3DCAL err=4
      if twostep==2 && Abs(zmean[1][i]-meanpos)>=maxhilo err=4
    enddo
    zscan=Max(3.0,z,maxdiff*1.5+1.0)   // Correct Z stroke for safety
    if maxdiff>alloweddiff then
      if hlog!=NULL then fprintf(hlog,                                         \
        "Measured bending (%.2f mm) exceeds allowed limit (%.2f mm)\n",        \
        maxdiff,alloweddiff);
      endif
      err=6                            // High bending
    endif
    if calmode==MODE_3DCAL then
      if hlog!=NULL then fprintf(hlog,                                         \
        "Minimal Z difference from the last calibration is %.1f mm\n",         \
        minzdiff/1000.0)
      endif
      if minzdiff<MIN3DDIST then
        err=5                          // Small Z difference in 3-D calibration
      endif
    endif
  else
    if hlog!=NULL fprintf(hlog,"  ERROR: Cannot measure bending\n");
    zscan=99.0                         // For safety, set REALLY high z!
  endif
  if hlog!=NULL fprintf(hlog,"  Safe Z height set to %.1f mm\n",zscan)
  sprintf(s,"STROKE %i,%i,%g",v,p,zscan)
  ident=SERV.Cmdimm(0,s)
  if ident<=0 err=1                    // Unable to send command
  t=Time()+10000                       // Wait 10 s for answer
  while (err==0) do
    if $A[0].length>0 then
      if $A[0].answer!=S_STROKE err=3  // Unexpected answer returned
      break                            // Answer is here
    else if Pressed(hexit) then
      err=-1                           // Operator interrupted calibration
    else if Time()>t then
      err=2                            // No answer within timeout
    endif
    wait
  enddo
  if err>0 then
    i=Checkgloberrors()
    if i!=0 return i
    change hinfo text="Problem with calibration board!"
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==1 then
      draw text="Unable to send command!"
    else if err==2 then
      draw text="No answer within 10 seconds!"
    else if err==3 then
      draw text="Command executed incorrectly!"
    else if err==4 then
      draw text="Asymmetrical Z placement!"
    else if err==5 then
      draw text="Low Z difference in 3-D calibration!"
    else
      draw text="Bent calibration board!"
    endif
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    if err<=3 then
      hretry=control BUTTON
        window=hright
        position=(RIGHTX-120)/2,USERY,120,24
        name="Check status"
        help="Press to re-check the tester status"
      endc
      hreplace=NULL
      hcont=NULL
      draw text="Calibration procedure was unable to measure Z position of the "
      draw text="calibration board. It is necessary to re-check the status of "
      draw text="the tester."
    else if err==5 then
      hretry=control BUTTON
        window=hright
        position=RIGHTX/2-124,USERY+10,120,24
        name="Try again"
        help="Press to measure Z position once more"
      endc
      hreplace=control BUTTON
        window=hright
        position=RIGHTX/2+5,USERY+10,120,24
        name="Replace"
        help=""
      endc
      hcont=NULL
      draw text="For reliable 3-D calibration, vertical distance between the "
      draw text="positions of the calibration board must be at least "
      draw text=format("%g mm. Minimal measured distance is ",MIN3DDIST/1000.0)
      draw text=format("only %.1f mm. ",minzdiff/1000.0)
      draw text="Please check board and then decide what to do next."
    else
      hretry=control BUTTON
        window=hright
        position=5,USERY+10,RIGHTX/3-5,24
        name="Try again"
        help="Press to measure Z position once more"
      endc
      hreplace=control BUTTON
        window=hright
        position=5+RIGHTX/3,USERY+10,RIGHTX/3-5,24
        name="Replace"
        help=""
      endc
      hcont=control BUTTON
        window=hright
        position=5+2*(RIGHTX/3),USERY+10,RIGHTX/3-9,24
        name="Continue"
        help="Press to continue calibration at your own risk!"
      endc
      if calmode==MODE_3DCAL && minzdiff<MIN3DDIST disable hcont
      nover=0
      for i=0,i<$LAY.nfing,i++ do
        if c[i*2].ncal==0 continue     // Head excluded from calibration
        nover=nover+oversurface[i*2]
        if twostep==2 nover=nover+oversurface[i*2+1]
      enddo
      draw text="To keep calibration safe and reliable, calibration board must "
      draw text="be placed in the middle between the heads (allowed offset "
      draw text=format("%.1f mm) and have bending less than ",maxhilo)
      draw text=format("%.1f mm. Some rails ",alloweddiff)
      draw text="(marked " color=LIGHTRED text="red " color=BLACK
      draw text="in the table below) don't satisfy these conditions. "
      if nover>0 then
        draw color=GRAY text="Grayed " color=BLACK
        draw text="rails had contacts over surface. "
      endif
      n=0
      for i=0,i<$LAY.nfing,i++ do
        if c[i*2].ncal!=0 n++
      enddo
      if twostep==2 n=(n+1)*2
      htable=control CHILD
        window=hright
        position=5,160,RIGHTX-10,120
        limits=RIGHTX-30,n*20+38
        mode=M_VSCROLL
        help="Minimal and maximal measured Z coordinates, millimeters"
        bkcolor=PINK
        size=4096
      endc
      y=30
      draw window=htable font=INFOFONT color=DARKGRAY
      draw at 5,5 to 235,5
      draw at 5,5 to 5,32 at 14,26 text="Rail"
      draw at 45,5 to 45,32 at 58,26 text="Z position, mm"
      draw at 155,5 to 155,32 at 172,26 text="Bending"
      draw at 235,5 to 235,33
      draw at 5,32 to 235,32
      draw font=FIXEDSYS
      if twostep==2 then
        y=y+20
        draw at 5,y-18 to 5,y+2 to 235,y+2 to 235,y-18
        draw at 80,y color=BLACK text="Left shuttle"
      endif
      for i=0,i<$LAY.nfing,i++ do
        if c[i*2].ncal==0 continue     // Head excluded from calibration
        y=y+20
        draw color=DARKGRAY
        draw at 5,y-18 to 5,y+2 to 235,y+2 to 235,y-18
        draw at 45,y-18 to 45,y+2
        draw at 155,y-18 to 155,y+2
        draw at 13,y color=BLACK text=format("%2i",i)
        if oversurface[i*2] then
          draw color=GRAY
        else if Abs(zmean[0][i]-meanpos)>=maxhilo ||                           \
          zmax[0][i]-zmin[0][i]>alloweddiff then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 52,y text=format("%5.1f..%5.1f",zmin[0][i],zmax[0][i])
        draw at 162,y text=format("%5.2f mm",zmax[0][i]-zmin[0][i])
      enddo
      if twostep==2 then
        y=y+20
        draw at 5,y-18 to 5,y+2 to 235,y+2 to 235,y-18
        draw at 77,y color=BLACK text="Right shuttle"
        for i=0,i<$LAY.nfing,i++ do
          if c[i*2].ncal==0 continue
          y=y+20
          draw color=DARKGRAY
          draw at 5,y-18 to 5,y+2 to 235,y+2 to 235,y-18
          draw at 45,y-18 to 45,y+2
          draw at 155,y-18 to 155,y+2
          draw at 13,y color=BLACK text=format("%2i",i)
          if oversurface[i*2+1] then
            draw color=GRAY
          else if Abs(zmean[1][i]-meanpos)>=maxhilo ||                         \
            zmax[1][i]-zmin[1][i]>alloweddiff then
            draw color=LIGHTRED
          else
            draw color=BLACK
          endif
          draw at 52,y text=format("%5.1f..%5.1f",zmin[1][i],zmax[1][i])
          draw at 162,y text=format("%5.2f mm",zmax[1][i]-zmin[1][i])
        enddo
      endif
      draw show
      setfocus htable
    endif
    draw window=hright show
    while 1 do
      if err<=3 then
        if Pressed(hretry) return 1    // Check again the status of the tester
      else
        if Pressed(hretry) then
          return 2                     // Check position again
        else if Pressed(hreplace) then
          return 3                     // Replace calibration board
        else if Pressed(hcont) || (hcont!=NULL && autoconfirm!=0) then
          Logcontinue()
          return 0                     // Accept test results
        endif
      endif
      if Pressed(hexit) return -1
      wait
    enddo
  endif
  return err
end

// Static variables used internally by Showcurrscan(), Showwavescan(),
// Showinterna() and Showyencoder().
handle hstat                           // Window with scanning statistics
handle hstatg                          // Graphics with statistics
handle hstatsel[4]                     // Head selection controls
handle hstathead                       // Displays selected head
handle hstatscale                      // Displays amplification
handle hstatscscr                      // Changes amplification
handle hstatzoom                       // Zooms grid in Y direction
handle hstatvaronly                    // Only variable part of deviations
int    stathead                        // Currently selected head
int    statnext                        // Number of displayed points
int    statselect                      // Selected point or -1 if none
int    statselx                        // X index of selected point or -1
int    statsely                        // Y index of selected point or -1
int    statscale                       // Scale index for errors
int    statzoom                        // Zoom grid in Y direction
int    statprevx,statprevy             // Previous mouse position
int    statall                         // Display left and right simultaneously
int    statredraw                      // Forces redraw

// Used to display intermediate and final scanning statistics. First call with
// mode=1 to create window, then call periodically with mode=0 to process
// operator's requests. To select different head, call with mode=2 and all=
// requested head. Call with mode=-1 to destroy window. If all is 1 when
// mode=0, routine shows deviations for left and right heads and video camera
// on the same picture.
function int Showcurrscan(int mode,int all)
  float stsc[8] = { 20.0, 50.0, 100.0, 250.0, 500.0, 1000.0, 2000.0, 5000.0 }
  int i,j,x,y,buttons,x0,y0,x1,y1,nodex,nodey,ncal,next,redraw,head
  float padx,pady,dx,dy,scalex,scaley,xoffset,yoffset,vstep,factor
  if mode==1 then                      // Create statistics window
    if hstat!=NULL destroy hstat
    hstat=control CHILD
      window=hleft
      position=0,0,LEFTX,LEFTY
      help=" "
      bkcolor=LIGHTGRAY
      size=256
    endc
    hstatg=control GRAPH
      window=hstat
      position=0,0,LEFTX,270
      help="Calibration results"
      color=GRAY
      bkcolor=WHITE
    endc
    draw window=hstat font=MEDIUMFONT color=DARKGRAY
    statall=all
    if statall==0 then
      hstatsel[0]=control BUTTON
        window=hstat
        position=47,278,25,25
        text="+"
        help="Press to go to the next rail"
        font=MEDIUMFONT
      endc
      if $LAY.nfing==1 && cameras==0 disable hstatsel[0]
      hstatsel[1]=control BUTTON
        window=hstat
        position=17,305,25,25
        text="-"
        help="Press to select left head (or upper camera)"
        font=MEDIUMFONT
      endc
      hstatsel[2]=control BUTTON
        window=hstat
        position=77,305,25,25
        text="+"
        help="Press to select right head (or upper camera)"
        font=MEDIUMFONT
      endc
      hstatsel[3]=control BUTTON
        window=hstat
        position=47,332,25,25
        text="-"
        help="Press to go to the previous rail"
        font=MEDIUMFONT
      endc
      if $LAY.nfing==1 && cameras==0 disable hstatsel[3]
      hstathead=control TEXT
        window=hstat
        position=44,308,31,23
        help="Currently selected head"
        font=MEDIUMFONT
        color=LIGHTRED
        bkcolor=LIGHTGRAY
        mode=M_CENTERED
      endc
    else
      hstatsel[0]=control BUTTON
        window=hstat
        position=27,288,25,25
        text="+"
        help="Press to go to the next rail"
        font=MEDIUMFONT
      endc
      hstatsel[1]=NULL
      hstatsel[2]=NULL
      hstatsel[3]=control BUTTON
        window=hstat
        position=27,322,25,25
        text="-"
        help="Press to go to the previous rail"
        font=MEDIUMFONT
      endc
      hstathead=control TEXT
        window=hstat
        position=60,308,80,23
        help="Currently selected rail"
        font=MEDIUMFONT
        color=LIGHTRED
        bkcolor=LIGHTGRAY
      endc
      stathead=stathead & 0xFFFFFFFE
      if stathead>=$LAY.nfing*2 stathead=0
    endif
    draw at 190,325 text="Scale"
    hstatscale=control TEXT
      window=hstat
      position=240,305,50,22
      text=format("x%g",stsc[statscale])
      help="Current scale for measured scan differences (pixels/millimeter)"
      font=MEDIUMFONT
      mode=M_BORDER|M_CENTERED
    endc
    hstatzoom=control CHECKBOX
      window=hstat
      position=190,330,120,22
      text="Full screen"
      help="Check to stretch the rail to full screen (different X-Y scales)"
      font=MEDIUMFONT
      color=DARKGRAY
      mode=(statzoom!=0)
    endc
    hstatscscr=control VSCROLL
      window=hstat
      position=290,305,24,22
      help="Change scale factor for measured scan differences"
      limits=1,-1
    endc
    draw show
    statnext=-1
    statselect=-1; statselx=-1; statsely=-1
    statprevx=-1
  else if (mode==0 || mode==2) && hstat!=NULL then
    // Maintain statistics window.
    if mode==2 then
      i=all
    else
      i=stathead
      if Pressed(hstatsel[0]) then
        if i/2==$LAY.nfing-1 then
          if cameras==1 then
            i=(i+2) & 0x1E             // Only left camera available
          else if cameras==2 then
            i=(i+2) | 0x01             // Only right camera available
          else if cameras==3 then
            i=i+2                      // Both cameras available
          endif
        else if i/2<$LAY.nfing-1 then
          i=i+2                        // Select next rail
        endif
      else if statall==0 && Pressed(hstatsel[1]) then
        if (i/2<$LAY.nfing || (cameras & 1)!=0) i=i & 0x1E
      else if statall==0 && Pressed(hstatsel[2]) then
        if (i/2<$LAY.nfing || (cameras & 2)!=0) i=i|1
      else if Pressed(hstatsel[3]) then
        if (i>=2) i=i-2
      else if Pressed(hstatzoom) then
        statzoom=Status(hstatzoom)
        redraw=1
      else if Pressed(hstatscscr) then
        j=Status(hstatscscr)
        if j<0 then
          statscale=Max(0,statscale-1); redraw=1
        else if j>0 then
          statscale=Min(7,statscale+1); redraw=1
        endif
        change hstatscscr select=0
        change hstatscale text=format("x%g",stsc[statscale])
      endif
    endif
    if i!=stathead then
      stathead=i
      statselect=-1; statselx=-1; statsely=-1
      redraw=1
    endif
    ncal=c[stathead].ncal
    next=c[stathead].next
    vstep=(stathead/2==$LAY.nfing?videoy:ystep)
    if (statnext!=next) redraw=1       // Number of scanned points changed
    // Conversion from millimeters to pixels:   Xpix=Xmm*scalex+dx
    //                                          Ypix=dy-Ymm*scaley
    if statzoom==0 then
      scalex=1.0/                                                              \
        (Max(($LAY.top[stathead/2]-$LAY.bottom[stathead/2])/(270.-94.),        \
        ($LAY.rightlimit-$LAY.leftlimit)/(LEFTX-33.0),0.0001)/1000.0)
      scaley=scalex
    else
      scalex=1000.0/(($LAY.rightlimit-$LAY.leftlimit)/(LEFTX-33.0))
      scaley=1000.0/(($LAY.top[stathead/2]-$LAY.bottom[stathead/2])/(270.-94.))
    endif
    dx=LEFTX/2.0-($LAY.leftlimit+$LAY.rightlimit)/2000.0*scalex
    dy=270/2.0+($LAY.top[stathead/2]+$LAY.bottom[stathead/2])/2000.0*scaley
    i=Mousexy(hstatg,&x,&y,&buttons)
    if i==1 && (x!=statprevx || y!=statprevy) then
      statprevx=x; statprevy=y         // Mouse cursor in statistics graph
      if statall || c[stathead].corrok then
        // Corrections available, select all grid nodes.
        nodex=((x-dx)/scalex-                                                  \
          $LAY.xoffset/1000.0+xstep*(CENTERX+0.5))/xstep
        nodey=((dy-y)/scaley-                                                  \
          $LAY.yoffset[stathead/2]/1000.0+vstep*(CENTERY+0.5))/vstep
        if nodex>=0 && nodex<CORRX && nodey>=0 && nodey<CORRY &&               \
          (statselx!=nodex || statsely!=nodey) then
          statselx=nodex               // Another node under cursor
          statsely=nodey
          statselect=-1
          for i=0,i<ncal,i++ do
            nodex=(c[stathead].xa[i]-                                          \
              $LAY.xoffset/1000.0+xstep*(CENTERX+0.5))/xstep
            nodey=(c[stathead].ya[i]-                                          \
              $LAY.yoffset[stathead/2]/1000.0+vstep*(CENTERY+0.5))/vstep
            if (nodex==statselx && nodey==statsely) then
              statselect=i             // Another cross under cursor
              break
            endif
          enddo
          redraw=1
        endif
      else
        // No corrections, select only calibration crosses
        for i=0,i<ncal,i++ do
          x=c[stathead].xa[i]*scalex+dx
          y=dy-c[stathead].ya[i]*scaley
          if Abs(x-statprevx)<6 && Abs(y-statprevy)<6 && statselect!=i then
            statselect=i               // Another cross under cursor
            statselx=(c[stathead].xa[i]-                                       \
              $LAY.xoffset/1000.0+xstep*(CENTERX+0.5))/xstep
            statsely=(c[stathead].ya[i]-                                       \
              $LAY.yoffset[stathead/2]/1000.0+vstep*(CENTERY+0.5))/vstep
            redraw=1
            break
          endif
        enddo
      endif
    endif
    if (redraw || statredraw) then
      statnext=next
      xoffset=$LAY.xoffset/1000.0
      yoffset=$LAY.yoffset[stathead/2]/1000.0
      draw window=hstatg bkcolor=WHITE clear
      draw color=GRAY bkcolor=(boardtype==0?LIGHTYELLOW:WHITECYAN)
      x0=$LAY.leftlimit/1000.0*scalex+dx
      y0=dy-$LAY.bottom[stathead/2]/1000.0*scaley
      x1=$LAY.rightlimit/1000.0*scalex+dx
      y1=dy-$LAY.top[stathead/2]/1000.0*scaley
      draw at x0,y1 fillrect x1+1,y0+1
      draw color=LIGHTGRAY             // Draw correction grid
      for i=-CENTERY,i<=CENTERY,i++ do
        y=dy-(yoffset+vstep*i)*scaley
        if y>y1 && y<y0 then
          draw at x0+1,y to x1,y
        endif
      enddo
      for i=-CENTERX,i<=CENTERX,i++ do
        x=(xoffset+xstep*i)*scalex+dx
        if x>x0 && x<x1 then
          draw at x,y0-1 to x,y1
        endif
      enddo
      // Draw general data on the top of the window.
      draw color=DARKGRAY font=TERMINALFONT mode=M_LEFT at 5,13
      if statall then
        if stathead>=$LAY.nfing*2 then
          draw text="Video cameras"
        else if c[stathead].type==FILL_HCAM then
          draw text=format("Head cameras on rail %i",stathead/2)
        else
          draw text=format("Rail %i",stathead/2)
        endif
      else
        if stathead>=$LAY.nfing*2 then
          draw text=format("%s camera",(stathead & 1?"Bottom":"Top"))
        else if c[stathead].type==FILL_HCAM then
          draw text=format("Head camera %i%c",stathead/2,(stathead & 1?'R':'L'))
        else
          draw text=format("Head %i%c",stathead/2,(stathead & 1?'R':'L'))
        endif
        draw at 115,13
        if ncal==0 then
          draw text="Excluded from calibration"
        else
          draw text=format("%.0f%% calibrated",next*100.0/ncal)
        endif
        if c[stathead].type==FILL_MECH then
          draw at 5,25
          draw text=format("Actual line width X %.3f, Y %.3f mm",              \
          c[stathead].widthx,c[stathead].widthy)
        endif
      endif
      // Display coordinates of selected point.
      if statselx>=0 then
        padx=(statselx-CENTERX)*xstep+$LAY.xoffset/1000.0
        pady=(statsely-CENTERY)*vstep+$LAY.yoffset[stathead/2]/1000.0
        x0=padx*scalex+dx
        y0=dy-pady*scaley
        draw color=DARKGRAY at x0,y0 ellipse 15,15
        draw at 5,270-2 text="At X       Y"
        draw color=BLACK
        draw at 33,270-2 text=format("%-5.1f",padx)
        draw at 80,270-2 text=format("%-5.1f",pady)
       endif
      // Display calculated corrections for selected head or head camera.
      if statall==0 && verification==0 && c[stathead].corrok then
        factor=stsc[statscale]/1000.0
        draw color=LIGHTBLUE
        if c[stathead].type!=FILL_HCAM then
          for i=0,i<CORRX,i++ do       // Head or dedicated camera
            x0=(xoffset+xstep*(i-CENTERX))*scalex+dx
            for j=0,j<CORRY,j++ do
              y0=dy-(yoffset+vstep*(j-CENTERY))*scaley
              x1=x0+corr[stathead][i,j].dx*factor
              y1=y0-corr[stathead][i,j].dy*factor
              draw pixel x0,y0 at x0,y0 to x1,y1
            enddo
          enddo
          if statselx>=0 && c[stathead].corrok then
            draw color=DARKGRAY at 143,270-2
            draw text="corX       corY         mm"
            draw color=LIGHTBLUE
            draw at 172,270-2
            draw text=format("%.3f",corr[stathead][statselx,statsely].dx/1000.0)
            draw at 240,270-2
            draw text=format("%.3f",corr[stathead][statselx,statsely].dy/1000.0)
          endif
        else
          for i=0,i<CORRX,i++ do       // Head camera
            x0=(xoffset+xstep*(i-CENTERX))*scalex+dx
            for j=0,j<CORRY,j++ do
              y0=dy-(yoffset+vstep*(j-CENTERY))*scaley
              x1=x0+hcam[stathead][i,j].dx*factor
              y1=y0-hcam[stathead][i,j].dy*factor
              draw pixel x0,y0 at x0,y0 to x1,y1
            enddo
          enddo
          if statselx>=0 && c[stathead].corrok then
            draw color=DARKGRAY at 143,270-2
            draw text="corX       corY         mm"
            draw color=LIGHTBLUE
            draw at 172,270-2
            draw text=format("%.3f",hcam[stathead][statselx,statsely].dx/1000.0)
            draw at 240,270-2
            draw text=format("%.3f",hcam[stathead][statselx,statsely].dy/1000.0)
          endif
        endif
      endif
      // Draw measured differences for selected head.
      if statall==0 then
        for i=0,i<ncal,i++ do
          x0=c[stathead].xa[i]*scalex+dx
          y0=dy-c[stathead].ya[i]*scaley
          if i>=next then
            draw color=DARKGRAY pixel x0,y0
            continue
          endif
          if c[stathead].err[i]!=1 then
            x1=x0+(c[stathead].xm[i]-c[stathead].xa[i])*stsc[statscale]
            y1=y0-(c[stathead].ym[i]-c[stathead].ya[i])*stsc[statscale]
            draw color=BLACK
            draw pixel x0,y0 at x0,y0 to x1,y1
          endif
          if c[stathead].err[i]!=0 then
            draw color=LIGHTRED at x0-2,y0-2 to x0+3,y0+3
            draw at x0-2,y0+2 to x0+3,y0-3
          endif
        enddo
        if statselect>=0 && statselect<next then
          draw color=DARKGRAY at 155,258
          if c[stathead].err[statselect]!=1 then
            draw text=format("dX         dY         mm%s",                     \
              c[stathead].err[statselect]==2?" Removed":"")
            if statall draw at 135,258 text=format("%iL:",stathead/2)
            draw color=(statall?LIGHTRED:BLACK)
            draw at 172,258 text=format("%.3f",                                \
            c[stathead].xm[statselect]-c[stathead].xa[statselect])
            draw at 240,258 text=format("%.3f",                                \
            c[stathead].ym[statselect]-c[stathead].ya[statselect])
          else
            draw text="Not calibrated"
          endif
        endif
      endif
      // Draw restored measurements after corrections are calculated.
      if statall==0 && verification==2 && stathead<$LAY.nfing*2 &&             \
        c[stathead].corrok                                                     \
      then
        draw color=GREEN
        for i=0,i<CORRX,i++ do
          x0=(xoffset+(i-CENTERX)*xstep)*scalex+dx
          // Top row.
          y0=dy-(yoffset+encdist)*scaley
          x1=x0+c[stathead].dpx[i]*stsc[statscale]
          y1=y0-c[stathead].dpy[i]*stsc[statscale]
          draw pixel x0,y0 at x0,y0 to x1,y1
          // Bottom row.
          y0=dy-(yoffset-encdist)*scaley
          x1=x0+c[stathead].dmx[i]*stsc[statscale]
          y1=y0-c[stathead].dmy[i]*stsc[statscale]
          draw pixel x0,y0 at x0,y0 to x1,y1
        enddo
        if statselx>=0 then
          draw color=DARKGRAY at 155,268
          y0=(statsely-CENTERY)*vstep
          if Abs(y0-encdist)<ystep/2.0 then
            draw text=format("sX         sY         mm")
            draw color=GREEN
            draw at 172,268 text=format("%.3f",c[stathead].dpx[statselx])
            draw at 240,268 text=format("%.3f",c[stathead].dpy[statselx])
          else if Abs(y0+encdist)<ystep/2.0 then
            draw text=format("sX         sY         mm")
            draw color=GREEN
            draw at 172,268 text=format("%.3f",c[stathead].dmx[statselx])
            draw at 240,268 text=format("%.3f",c[stathead].dmy[statselx])
          endif
        endif
      endif
      // Draw recalculated differences after separate verification is finished.
      if statall!=0 then
        // Left head.
        for i=0,i<ncal,i++ do
          if c[stathead].err[i]!=0 continue
          x0=c[stathead].xa[i]*scalex+dx
          y0=dy-c[stathead].ya[i]*scaley
          x1=x0+(c[stathead].xm[i]-c[stathead].xa[i])*stsc[statscale]
          y1=y0-(c[stathead].ym[i]-c[stathead].ya[i])*stsc[statscale]
          draw color=LIGHTRED
          draw pixel x0,y0 at x0,y0 to x1,y1
        enddo
        // Right head.
        head=stathead+1
        for i=0,i<c[head].ncal,i++ do
          if c[head].err[i]!=0 continue
          x0=c[head].xa[i]*scalex+dx
          y0=dy-c[head].ya[i]*scaley
          x1=x0+(c[head].xm[i]-c[head].xa[i])*stsc[statscale]
          y1=y0-(c[head].ym[i]-c[head].ya[i])*stsc[statscale]
          draw color=GREEN
          draw pixel x0,y0 at x0,y0 to x1,y1
        enddo
        // Differences in text format.
        if statselect>=0 && c[stathead].err[statselect]==0 then
          draw color=DARKGRAY
          draw at 130,258 text=format("%iL:",stathead/2)
          draw at 155,258 text=format("dX         dY         mm")
          draw color=LIGHTRED
          draw at 172,258 text=format("%.3f",                                  \
          c[stathead].xm[statselect]-c[stathead].xa[statselect])
          draw at 240,258 text=format("%.3f",                                  \
          c[stathead].ym[statselect]-c[stathead].ya[statselect])
        endif
        // Attention, I assume same points for left and right heads!
        if statselect>=0 && c[head].err[statselect]==0 then
          draw color=DARKGRAY
          draw at 130,268 text=format("%iR:",stathead/2)
          draw at 155,268 text=format("dX         dY         mm")
          draw color=GREEN
          draw at 172,268 text=format("%.3f",                                  \
          c[head].xm[statselect]-c[head].xa[statselect])
          draw at 240,268 text=format("%.3f",                                  \
          c[head].ym[statselect]-c[head].ya[statselect])
        endif
        // Video camera from the same side.
        if stathead<$LAY.nfing*2 then
          head=$LAY.nfing*2
          if $LAY.side[stathead/2]!=0 head++
          for i=0,i<c[head].ncal,i++ do
            if c[head].err[i]!=0 continue
            padx=c[head].xa[i]
            pady=c[head].ya[i]
            if pady<$LAY.bottom[stathead/2]/1000.0 continue
            if pady>$LAY.top[stathead/2]/1000.0 continue
            x0=padx*scalex+dx
            y0=dy-pady*scaley
            x1=x0+(c[head].xm[i]-padx)*stsc[statscale]
            y1=y0-(c[head].ym[i]-pady)*stsc[statscale]
            draw color=LIGHTBLUE
            draw pixel x0,y0 at x0,y0 to x1,y1
            if statselx>=0 &&                                                  \
              Abs(padx-(statselx-CENTERX)*xstep-xoffset)<xstep/2 &&            \
              Abs(pady-(statsely-CENTERY)*ystep-yoffset)<ystep/2               \
            then
              draw color=DARKGRAY
              draw at 130,248 text=(head & 1?"Bot:":"Top:")
              draw at 155,248 text=format("dX         dY         mm")
              draw color=LIGHTBLUE
              draw at 172,248 text=format("%.3f",c[head].xm[i]-padx)
              draw at 240,248 text=format("%.3f",c[head].ym[i]-pady)
            endif
          enddo
        endif
      endif
      draw show
      // Update head/rail display.
      if statall==0 then
        change hstathead text=format("%i%c",stathead/2,(stathead & 1?'R':'L'))
      else if stathead>=$LAY.nfing*2 then
        change hstathead text="Video"
      else
        change hstathead text=format("Rail %i",stathead/2)
      endif
      // Screen updated.
      redraw=0
      statredraw=0
    endif
  else                                 // Destroy statistics window
    if hstat!=NULL destroy hstat
    hstat=NULL
  endif
end

// Used to display results of waveness measurements. First call with mode=1 to
// create window, then call periodically with mode=0 to process operator's
// requests. To select different head, call with mode=2 and select=requested
// head. Call with mode=-1 to destroy window.
function int Showwavescan(int mode,int select)
  float  stsc[8] = { 20.0, 50.0, 100.0, 250.0, 500.0, 1000.0, 2000.0, 5000.0 }
  int i,j,x,y,buttons,nwave,nodex,next,redraw,head
  float dx,dy,fi,scalex
  if mode==1 then                      // Create statistics window
    if hstat!=NULL destroy hstat
    hstat=control CHILD
      window=hleft
      position=0,0,LEFTX,LEFTY
      help=" "
      bkcolor=LIGHTGRAY
      size=256
    endc
    hstatg=control GRAPH
      window=hstat
      position=0,0,LEFTX,270
      help="Waveness test results"
      color=GRAY
      bkcolor=WHITE
    endc
    draw window=hstat font=MEDIUMFONT color=DARKGRAY
    hstatsel[0]=control BUTTON
      window=hstat
      position=47,278,25,25
      text="+"
      help="Press to go to the next rail"
      font=MEDIUMFONT
    endc
    if $LAY.nfing==1 disable hstatsel[0]
    hstatsel[1]=control BUTTON
      window=hstat
      position=17,305,25,25
      text="-"
      help="Press to select left head"
      font=MEDIUMFONT
    endc
    hstatsel[2]=control BUTTON
      window=hstat
      position=77,305,25,25
      text="+"
      help="Press to select right head"
      font=MEDIUMFONT
    endc
    hstatsel[3]=control BUTTON
      window=hstat
      position=47,332,25,25
      text="-"
      help="Press to go to the previous rail"
      font=MEDIUMFONT
    endc
    if $LAY.nfing==1 disable hstatsel[3]
    hstathead=control TEXT
      window=hstat
      position=44,308,31,23
      help="Currently selected head"
      font=MEDIUMFONT
      color=LIGHTRED
      bkcolor=LIGHTGRAY
      mode=M_CENTERED
    endc
    draw at 190,325 text="Scale"
    hstatscale=control TEXT
      window=hstat
      position=240,305,50,22
      text=format("x%g",stsc[statscale])
      help="Current scale for measured deviations (pixels/millimeter)"
      font=MEDIUMFONT
      mode=M_BORDER|M_CENTERED
    endc
    hstatscscr=control VSCROLL
      window=hstat
      position=290,305,24,22
      help="Change scale factor for measured deviations"
      limits=1,-1
    endc
    draw show
    statnext=-1
    statselect=-1; statselx=-1; statsely=-1
    statprevx=-1
  else if (mode==0 || mode==2) && hstat!=NULL then
    // Maintain statistics window.
    if mode==2 then
      i=select
    else
      i=stathead
      if i>=$LAY.nfing*2 i=0
      if Pressed(hstatsel[0]) then
        if i/2<$LAY.nfing-1 i=i+2
      else if Pressed(hstatsel[1]) then
        i=i & 0x1E
      else if Pressed(hstatsel[2]) then
        i=i|1
      else if Pressed(hstatsel[3]) then
        if (i>=2) i=i-2
      else if Pressed(hstatscscr) then
        j=Status(hstatscscr)
        if j<0 then
          statscale=Max(0,statscale-1); redraw=1
        else if j>0 then
          statscale=Min(7,statscale+1); redraw=1
        endif
        change hstatscscr select=0
        change hstatscale text=format("x%g",stsc[statscale])
      endif
    endif
    if i!=stathead then
      stathead=i
      statselect=-1; statselx=-1; statsely=-1
      redraw=1
    endif
    next=c[stathead].next
    nwave=c[stathead].nwave
    if (statnext!=next) redraw=1       // Number of scanned points changed
    // Conversion from millimeters to pixels:   Xpix=N*scalex+dx
    if nwave<=1 then
      scalex=1.0
    else
      scalex=(LEFTX-33.0)/(nwave-1)
    endif
    dx=16.0
    dy=120
    i=Mousexy(hstatg,&x,&y,&buttons)
    if i==1 && x!=statprevx then
      statprevx=x                      // Mouse cursor in statistics graph
      nodex=(x-dx+scalex/2)/scalex
      if nodex>=0 && nodex<nwave && statselx!=nodex then
        statselx=nodex                 // Another node under cursor
        statselect=nodex
        redraw=1
      endif
    endif
    if redraw then
      statnext=next
      // Draw grid.
      draw window=hstatg bkcolor=WHITE clear
      draw color=LIGHTGRAY
      for i=0,i<nwave,i++ do
        x=i*scalex+dx
        draw at x,dy-100 to x,dy+100
      enddo
      for i=-10,i<=10,i++ do
        draw color=(i==0?GRAY:LIGHTGRAY)
        draw at dx,i*10+dy to (nwave-1)*scalex+dx,i*10+dy
      enddo
      // Draw general data on the top of the window.
      draw color=DARKGRAY font=TERMINALFONT mode=M_LEFT at 5,13
      draw text=format("Head %i%c",stathead/2,(stathead & 1?'R':'L'))
      draw at 100,13
      if c[stathead].ncal==0 then
        draw text="Excluded from calibration"
      else if nwave==0 then
        draw text="0% calibrated"
      else
        draw text=format("%.0f%% calibrated",next*100.0/nwave)
      endif
      if c[stathead].waveok then
        draw at 230,13 text=format("Ampl=%.3f mm",c[stathead].wavea*2.0)
      endif
      // If sine approximation is available, draw sine wave.
      if c[stathead].waveok then
        draw color=LIGHTMAGENTA
        for i=0,i<nwave,i++ do
          x=i*scalex+dx
          fi=((i-nwave/2+0.5)*xstep/NSUBWAVE)*TWOPI/WAVEDX
          y=dy-c[stathead].wavea*Sin(fi+c[stathead].wavefi)*stsc[statscale]
          if i==0 then
            draw at x,y
          else
            draw to x,y
          endif
        enddo
      endif
      // Draw points, highlight selected and display its data.
      for i=0,i<nwave,i++ do
        if i>=next break
        x=i*scalex+dx
        y=dy-c[stathead].wavedy[i]*stsc[statscale]
        if i==statselx then
          draw color=DARKGRAY at x,y ellipse 8,8
          draw color=DARKGRAY at 5,268 text="At X=         mm"
          draw at 155,268 text="dY=         mm"
          draw color=BLACK
          draw at 45,268 text=format("%-5.2f",c[stathead].wavexa[i])
          draw at 177,268 text=format("%.3f",c[stathead].wavedy[i])
          draw color=LIGHTRED bkcolor=LIGHTRED
        else
          draw color=BLACK bkcolor=BLACK
        endif
        draw at x,y fillellipse 3,3
      enddo
      draw show
      // Update head/rail display.
      change hstathead text=format("%i%c",stathead/2,(stathead & 1?'R':'L'))
      // Screen updated.
      redraw=0
    endif
  else                                 // Destroy statistics window
    if hstat!=NULL destroy hstat
    hstat=NULL
  endif
end

// Used to display internal calibration data. First call with mode=1 to create
// window, then call periodically with mode=0 to process operator's requests.
// To select different head, call with mode=2 and select=requested head. Call
// with mode=-1 to destroy window.
function int Showinterna(int mode,int select)
  float stsc[8] = { 20.0, 50.0, 100.0, 250.0, 500.0, 1000.0, 2000.0, 5000.0 }
  int i,j,n,x,y,nodex,redraw,buttons,varonly
  float dx,dy,dp,dm,scalex,xoffset,yoffset
  float r,xfit[CORRX],xtop[CORRX],xbot[CORRX],ytop[CORRX],ybot[CORRX]
  if mode==1 then                      // Create statistics window
    if hstat!=NULL destroy hstat
    hstat=control CHILD
      window=hleft
      position=0,0,LEFTX,LEFTY
      help=" "
      bkcolor=LIGHTGRAY
      size=256
    endc
    hstatg=control GRAPH
      window=hstat
      position=0,0,LEFTX,270
      help="Internal calibration data"
      color=GRAY
      bkcolor=WHITE
    endc
    draw window=hstat font=MEDIUMFONT color=DARKGRAY
    hstatsel[0]=control BUTTON
      window=hstat
      position=47,278,25,25
      text="+"
      help="Press to go to the next rail"
      font=MEDIUMFONT
    endc
    if $LAY.nfing==1 disable hstatsel[0]
    hstatsel[1]=control BUTTON
      window=hstat
      position=17,305,25,25
      text="-"
      help="Press to select left head"
      font=MEDIUMFONT
    endc
    hstatsel[2]=control BUTTON
      window=hstat
      position=77,305,25,25
      text="+"
      help="Press to select right head"
      font=MEDIUMFONT
    endc
    hstatsel[3]=control BUTTON
      window=hstat
      position=47,332,25,25
      text="-"
      help="Press to go to the previous rail"
      font=MEDIUMFONT
    endc
    if $LAY.nfing==1 disable hstatsel[3]
    hstathead=control TEXT
      window=hstat
      position=44,308,31,23
      help="Currently selected head"
      font=MEDIUMFONT
      color=LIGHTRED
      bkcolor=LIGHTGRAY
      mode=M_CENTERED
    endc
    hstatvaronly=control CHECKBOX
      window=hstat
      position=195,280,120,20
      text="Variable part"
      font=INFOFONT
      help="Check to view only variable part of splines"
    endc
    draw at 190,350 text="Scale"
    hstatscale=control TEXT
      window=hstat
      position=240,330,50,22
      text=format("x%g",stsc[statscale])
      help="Current scale for internal data (pixels/millimeter)"
      font=MEDIUMFONT
      mode=M_BORDER|M_CENTERED
    endc
    hstatscscr=control VSCROLL
      window=hstat
      position=290,330,24,22
      help="Change scale factor for internal data"
      limits=1,-1
    endc
    draw show
    statnext=-1
    statselect=-1; statselx=-1; statsely=-1
    statprevx=-1
  else if (mode==0 || mode==2) && hstat!=NULL then
    // Maintain statistics window.
    if mode==2 then
      i=select
      redraw=1
    else
      i=stathead
      if i>=$LAY.nfing*2 i=0
      if Pressed(hstatsel[0]) then
        if i/2<$LAY.nfing-1 i=i+2
      else if Pressed(hstatsel[1]) then
        i=i & 0x1E
      else if Pressed(hstatsel[2]) then
        i=i|1
      else if Pressed(hstatsel[3]) then
        if (i>=2) i=i-2
      else if Pressed(hstatscscr) then
        j=Status(hstatscscr)
        if j<0 then
          statscale=Max(0,statscale-1); redraw=1
        else if j>0 then
          statscale=Min(7,statscale+1); redraw=1
        endif
        change hstatscscr select=0
        change hstatscale text=format("x%g",stsc[statscale])
      else if Pressed(hstatvaronly) then
        redraw=1
      endif
    endif
    if i!=stathead then
      stathead=i
      statselect=-1; statselx=-1; statsely=-1
      redraw=1
    endif
    if statnext!=0 then
      statnext=0; redraw=1             // Redraw if displayed for the fisrt time
    endif
    // Conversion from millimeters to pixels:   Xpix=N*scalex+dx
    scalex=(LEFTX-33.0)/(CORRX-1)
    dx=16
    dp=66
    dm=193
    i=Mousexy(hstatg,&x,&y,&buttons)
    if i==1 && x!=statprevx then
      statprevx=x                      // Mouse cursor in statistics graph
      nodex=(x-dx+scalex/2)/scalex
      if nodex>=0 && nodex<CORRX && statselx!=nodex then
        statselx=nodex                 // Another node under cursor
        statselect=nodex
        redraw=1
      endif
    endif
    if redraw then
      varonly=Status(hstatvaronly)
      // Draw grid.
      draw window=hstatg bkcolor=WHITE clear
      for i=-5,i<=5,i++ do
        draw color=(i==0?GRAY:LIGHTGRAY)
        draw at dx,i*10+dp to (CORRX-1)*scalex+dx,i*10+dp
        draw at dx,i*10+dm to (CORRX-1)*scalex+dx,i*10+dm
      enddo
      for i=0,i<CORRX,i++ do
        x=i*scalex+dx
        draw color=(i==statselx?GRAY:LIGHTGRAY)
        draw at x,dp-50 to x,dp+50
        draw at x,dm-50 to x,dm+50
      enddo
      draw font=MEDIUMFONT color=GRAY
      draw at dx+5,dp-30 text=format("%i%c",stathead/2,stathead & 1?'R':'L')
      draw at dx+130,dp-30 text="Top"
      draw at dx+130,dm-30 text="Bot"
      if c[stathead].corrok then
        xoffset=$LAY.xoffset/1000.0
        yoffset=$LAY.yoffset[stathead/2]/1000.0
        // Draw general data on the top of the window.
        draw color=DARKGRAY font=TERMINALFONT mode=M_LEFT at 5,13
        if c[stathead].type==FILL_HCAM then
          draw text=format("Head camera %i%c",stathead/2,(stathead & 1?'R':'L'))
        else
          draw text=format("Head %i%c",stathead/2,(stathead & 1?'R':'L'))
        endif
        draw at 150,13 text=format("dR=%.3f mm",c[stathead].dr)
        // Display X coordinate at cursor.
        draw color=DARKGRAY at 5,dm+63 text="At X=        mm"
        draw color=BLACK at 41,dm+63
        draw text=format("%.1f",(statselx-CENTERX)*xstep+xoffset)
        // If necessary, calculate linear approximations.
        for i=0,i<CORRX,i++ do
          xtop[i]=0.0; xbot[i]=0.0
          ytop[i]=0.0; ybot[i]=0.0
        enddo
        if (varonly) then
          for i=0,i<CORRX,i++ do
            xfit[i]=i
            xtop[i]=c[stathead].dpx[i]
            xbot[i]=c[stathead].dmx[i]
            ytop[i]=c[stathead].dpy[i]
            ybot[i]=c[stathead].dmy[i]
          enddo
          r=1.0
          SYS.Linfit(CORRX,xfit,xtop,&r,CORRX,xfit,xtop)
          SYS.Linfit(CORRX,xfit,xbot,&r,CORRX,xfit,xbot)
          SYS.Linfit(CORRX,xfit,ytop,&r,CORRX,xfit,ytop)
          SYS.Linfit(CORRX,xfit,ybot,&r,CORRX,xfit,ybot)
        endif
        // Draw top splines.
        draw color=RED
        for i=0,i<CORRX,i++ do
          x=i*scalex+dx
          y=dp-(c[stathead].dpx[i]-xtop[i])*stsc[statscale]
          if i==0 then draw at x,y;
          else draw to x,y; endif
        enddo
        draw color=LIGHTRED
        for i=0,i<CORRX,i++ do
          x=i*scalex+dx
          y=dp-(c[stathead].dpy[i]-ytop[i])*stsc[statscale]
          if i==0 then draw at x,y;
          else draw to x,y; endif
        enddo
        // Draw bottom splines.
        draw color=GREEN
        for i=0,i<CORRX,i++ do
          x=i*scalex+dx
          y=dm-(c[stathead].dmx[i]-xbot[i])*stsc[statscale]
          if i==0 then draw at x,y;
          else draw to x,y; endif
        enddo
        draw color=LIGHTBLUE
        for i=0,i<CORRX,i++ do
          x=i*scalex+dx
          y=dm-(c[stathead].dmy[i]-ybot[i])*stsc[statscale]
          if i==0 then draw at x,y;
          else draw to x,y; endif
        enddo
        // Draw spline values.
        if statselx>=0 && statselx<CORRX then
          draw at 117,dp+63 color=DARKGRAY text="SplX=        mm"
          draw at 150,dp+63 color=RED
          draw text=format("%.3f",c[stathead].dpx[statselx])
          draw at 117,dp+74 color=DARKGRAY text="SplY=        mm"
          draw at 150,dp+74 color=LIGHTRED
          draw text=format("%.3f",c[stathead].dpy[statselx])
          draw at 117,dm+63 color=DARKGRAY text="SplX=        mm"
          draw at 150,dm+63 color=GREEN
          draw text=format("%.3f",c[stathead].dmx[statselx])
          draw at 117,dm+74 color=DARKGRAY text="SplY=        mm"
          draw at 150,dm+74 color=LIGHTBLUE
          draw text=format("%.3f",c[stathead].dmy[statselx])
        endif
        // Draw original data points. Note that last point is repeated for
        // reproducibility checks and does not participate in calculations.
        n=c[stathead].next
        if c[stathead].xa[0]==c[stathead].xa[n-1] &&                           \
          c[stathead].ya[0]==c[stathead].ya[n-1] n--
        for i=0,i<n,i++ do
          if c[stathead].err[i]!=0 && c[stathead].err[i]!=2 continue
          j=Floor((c[stathead].xa[i]-xoffset+xstep/2.0)/xstep+CENTERX)
          if (j<0 || j>=CORRX) continue
          x=j*scalex+dx
          if c[stathead].ya[i]>yoffset+encdist-ystep/2.0 then
            draw color=RED
            dy=(c[stathead].xm[i]-c[stathead].xa[i])
            if c[stathead].err[i]==0 then
              draw at x,dp-(dy-xtop[j])*stsc[statscale] ellipse 5,5
            else                       // Draw cross for excluded points
              draw at x-2,dp-(dy-xtop[j])*stsc[statscale]-2
              draw to x+3,dp-(dy-xtop[j])*stsc[statscale]+3
              draw at x-2,dp-(dy-xtop[j])*stsc[statscale]+2
              draw to x+3,dp-(dy-xtop[j])*stsc[statscale]-3
            endif
            if j==statselx then
              draw at 242,dp+63 text=format("%.3f",dy)
              draw color=DARKGRAY at 208,dp+63
              draw text=format(", dX=        mm")
            endif
            draw color=LIGHTRED
            dy=(c[stathead].ym[i]-c[stathead].ya[i])
            if c[stathead].err[i]==0 then
              draw at x,dp-(dy-ytop[j])*stsc[statscale] ellipse 5,5
            else                       // Draw cross for excluded points
              draw at x-2,dp-(dy-ytop[j])*stsc[statscale]-2
              draw to x+3,dp-(dy-ytop[j])*stsc[statscale]+3
              draw at x-2,dp-(dy-ytop[j])*stsc[statscale]+2
              draw to x+3,dp-(dy-ytop[j])*stsc[statscale]-3
            endif
            if j==statselx then
              draw at 242,dp+74 text=format("%.3f",dy)
              draw color=DARKGRAY at 208,dp+74
              draw text=format(", dY=        mm")
            endif
          else if c[stathead].ya[i]<yoffset-encdist+ystep/2.0 then
            draw color=GREEN
            dy=(c[stathead].xm[i]-c[stathead].xa[i])
            if c[stathead].err[i]==0 then
              draw at x,dm-(dy-xbot[j])*stsc[statscale] ellipse 5,5
            else
              draw at x-2,dm-(dy-xbot[j])*stsc[statscale]-2
              draw to x+3,dm-(dy-xbot[j])*stsc[statscale]+3
              draw at x-2,dm-(dy-xbot[j])*stsc[statscale]+2
              draw to x+3,dm-(dy-xbot[j])*stsc[statscale]-3
            endif
            if j==statselx then
              draw at 242,dm+63 text=format("%.3f",dy)
              draw color=DARKGRAY at 208,dm+63
              draw text=format(", dX=        mm")
            endif
            draw color=LIGHTBLUE
            dy=(c[stathead].ym[i]-c[stathead].ya[i])
            if c[stathead].err[i]==0 then
              draw at x,dm-(dy-ybot[j])*stsc[statscale] ellipse 5,5
            else
              draw at x-2,dm-(dy-ybot[j])*stsc[statscale]-2
              draw to x+3,dm-(dy-ybot[j])*stsc[statscale]+3
              draw at x-2,dm-(dy-ybot[j])*stsc[statscale]+2
              draw to x+3,dm-(dy-ybot[j])*stsc[statscale]-3
            endif
            if j==statselx then
              draw at 242,dm+74 text=format("%.3f",dy)
              draw color=DARKGRAY at 208,dm+74
              draw text=format(", dY=        mm")
            endif
          endif
        enddo
      endif
      draw show
      // Update head/rail display.
      change hstathead text=format("%i%c",stathead/2,(stathead & 1?'R':'L'))
      // Screen updated.
      redraw=0
    endif
  else                                 // Destroy statistics window
    if hstat!=NULL destroy hstat
    hstat=NULL
  endif
end

// Scans electrically all crosses specified in calibrators. If handle hremain
// of type GRAPH or CHILD is specified, Runelectroscan() displays elapsed and
// remaining time in this window. If hinterrupt of type BUTTON is not NULL and
// pressed, function returns 2; if hskip of type BUTTON is not NULL and
// pressed, returns 3; if hview of type BUTTON is not NULL and pressed,
// statistics window appears.
function int Runelectroscan(handle hremain,handle hinterrupt,                  \
  handle hskip,handle hview,float shy)
  float percent,prevpercent
  int i,j,nerr,t,tstep,testimated,tupdate,dt,viewon,ret
  char s[128]
  handle htemp,hcont,hcancel
  change hinfo limits=0,0              // Text is set by caller
  if hremain!=NULL clear hremain
  tstep=Time()
  tupdate=tstep
  viewon=0
  testimated=MAXINT
  prevpercent=-1.0
  cleankelvin=-1
  if demo==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      SYS.Killimm(i)                   // Remove pending commands, if any
      $A[i].length=1                   // Invalid non-zero length
    enddo
  endif
  while 1 do
    percent=Electroscan(shy)
    if percent!=prevpercent then
      prevpercent=percent
      change hinfo limits=percent*10.0,1000
    endif
    if percent>=100.0 then
      ret=0; break
    else if Pressed(hexit) then
      ret=-1; break                    // Operator interrupted calibration
    endif
    // If there is a shortcut in the Kelvin probe and all pending movements are
    // finished, ask user to clean the probe manually.
    if cleankelvin>=0 then
      t=Time()+20000                   // Wait 20 s for answers
      while Time()<t do
        for i=0,i<$LAY.nfing*2,i++
          if c[i].ncal==0 continue
          if $A[i].length==0 break
        enddo
        if i>=$LAY.nfing*2 break       // Aha, all answers already here!
        wait
      enddo
      for i=0,i<$LAY.nfing*2,i++ do    // Move shortened head in the field
        if c[i].ncal==0 continue
        if i!=cleankelvin then
          sprintf(s,"M %i(Z) NOP",i)
        else if (i & 1)==0 then
          sprintf(s,"M %i(%f,%f) NOP",i,                                       \
          ($LAY.leftlimit+$LAY.xoffset)/2000.0,$LAY.yoffset[i/2]/1000.0)
        else
          sprintf(s,"M %i(%f,%f) NOP",i,                                       \
          ($LAY.xoffset+$LAY.rightlimit)/2000.0,$LAY.yoffset[i/2]/1000.0)
        endif
        SERV.Cmdimm(32,s)
      enddo
      change hright position=5000,5000,RIGHTX,RIGHTY
      htemp=control CHILD
        window=hmain
        position=SPLIT,10+SERVY,RIGHTX,RIGHTY
        help=" "
        color=DARKGRAY
        bkcolor=WHITE
        size=1024
      endc
      draw window=htemp color=LIGHTRED font=MEDIUMFONT mode=M_CENTERED
      draw at RIGHTX/2,32
      draw text=format("Shortcut in %i%c",cleankelvin/2,cleankelvin & 1?'R':'L')
      draw at 6,60 color=BLACK font=TIMESFONT wrap=RIGHTX-5 mode=M_LEFT
      draw text="Calibration detected shortcut between the pins of the Kelvin "
      draw text=format("probe %i%c. ",cleankelvin/2,cleankelvin & 1?'R':'L')
      draw text="Either clean probe and continue calibration, or press "
      draw font=MAINFONT text="Break " font=TIMESFONT text="to interrupt "
      draw text="calibration and remove calibration board."
      draw show
      hcont=control BUTTON
        window=htemp
        position=RIGHTX/2-124,USERY,120,24
        name="Continue"
        help="Press when probe is cleaned"
      endc
      hcancel=control BUTTON
        window=htemp
        position=RIGHTX/2+5,USERY,120,24
        name="Break"
        help="Press to remove calibration board"
      endc
      while 1 do
        if Pressed(hcont) then
          break
        else if Pressed(hcancel) then
          ret=2; break
        else if Pressed(hexit) then
          ret=-1; break                // Operator interrupted calibration
        endif
        wait
      enddo
      destroy htemp
      change hright position=SPLIT-1,9+SERVY,RIGHTX,RIGHTY
      c[cleankelvin].attempt=0
      cleankelvin=-1
      if ret!=0 break
    endif
    // If Skip button is pressed, return 3.
    if hskip!=NULL then
      if Pressed(hskip) then
        disable hskip
        if demo==0 then
          change hinfo limits=0,0
          change hinfo text="Wait..."
          t=Time()+20000               // Wait 20 s for answers
          while Time()<t do
            for i=0,i<$LAY.nfing*2,i++
              if c[i].ncal==0 continue
              if $A[i].length==0 break
            enddo
            if i>=$LAY.nfing*2 break   // Aha, all answers already here!
            wait
          enddo
          for i=0,i<$LAY.nfing*2,i++ do
            SYS.Killimm(i)             // Remove pending commands, if any
            if c[i].ncal==0 continue
            sprintf(s,"M %i(Z) NOP",i)
            SERV.Cmdimm(i,s)
          enddo
          while Time()<t do
            for i=0,i<$LAY.nfing*2,i++
              if c[i].ncal==0 continue
              if $A[i].length==0 break
            enddo
            if i>=$LAY.nfing*2 break   // Aha, all answers already here!
            wait
          enddo
        endif
        ret=3; break                   // Operator skipped scanning
      endif
    endif
    // If Interrupt button is pressed, return 2.
    if hinterrupt!=NULL then
      if Pressed(hinterrupt) then
        disable hinterrupt
        if demo==0 then
          change hinfo limits=0,0
          change hinfo text="Wait..."
          t=Time()+20000               // Wait 20 s for answers
          while Time()<t do
            for i=0,i<$LAY.nfing*2,i++
              if c[i].ncal==0 continue
              if $A[i].length==0 break
            enddo
            if i>=$LAY.nfing*2 break   // Aha, all answers already here!
            wait
          enddo
          for i=0,i<$LAY.nfing*2,i++ do
            SYS.Killimm(i)             // Remove pending commands, if any
            if c[i].ncal==0 continue
            sprintf(s,"M %i(Z) NOP",i)
            SERV.Cmdimm(i,s)
          enddo
          while Time()<t do
            for i=0,i<$LAY.nfing*2,i++
              if c[i].ncal==0 continue
              if $A[i].length==0 break
            enddo
            if i>=$LAY.nfing*2 break   // Aha, all answers already here!
            wait
          enddo
        endif
        ret=2; break                   // Operator interrupted the scanning
      endif
    endif
    if hview!=NULL then
      if Pressed(hview) then
        if viewon==0 then
          Showcurrscan(1,0)
          viewon=1
        else
          Showcurrscan(-1,0)
          viewon=0
        endif
      endif
      if viewon==1 Showcurrscan(0,0)
    endif
    if hremain!=NULL then
      dt=Time()-tstep
      if (percent>5.0 && dt>45000) || percent>25.0 then
        t=dt*(100.0-percent)/percent
        if t<testimated-500 || t>testimated+30000 testimated=t
      endif
      if Time()>=tupdate then
        clear hremain
        draw window=hremain
        t=Time()-tstart+500
        draw at 8,22 color=BLUE text="Elapsed time:"
        draw at 120,22 text=format("%2im %02is",t/60000,(t/1000)%60)
        t=Time()-tstep+500
        draw at 8,42 color=RED text="Step time:"
        draw at 120,42 text=format("%2im %02is",t/60000,(t/1000)%60)
        draw at 8,82 text="Bad crosses:"
        nerr=0
        for i=0,i<$LAY.nfing*2,i++ do
          if c[i].ncal==0 continue
          for j=0,j<c[i].next,j++ do
            if c[i].err[j]!=0 nerr++
          enddo
        enddo
        draw at 120,82 text=format(" %i",nerr)
        draw at 8,62 text="Remains:"
        if testimated==MAXINT then
          draw at 120,62 color=DARKGRAY text=" ?"
        else
          draw at 120,62 color=RED
          draw text=format("%2im %02is",testimated/60000,(testimated/1000)%60)
        endif
        draw show
        tupdate=tupdate+1000
      endif
    endif
    wait
  enddo
  if viewon==1 Showcurrscan(-1,0)
  return ret
end

// Returns -1 if operator interrupted the calibration, 0 on success, 1 if
// there is an error in calibration data, 2 if interrupt button pressed or
// estimated board position is too bad, and 3 when user is sure that placement
// is correct.
function int Measureshifts()
  int i,y,n,ndy,ndfi,scanerr[32],err
  float dy[32],dfi[32],dr[32]
  float meandy,meandfi,maxdy,maxdfi,topdr
  handle hremain,hinterrupt,hskip,hview
  handle htable,hreplace,hcont
  i=Fillcalibrators(C_CORNER,FILL_MECH)// Prepare for shift & angle measurement
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible!)
  change hinfo limits=0,0
  change hinfo text="Measuring offsets"
  if hlog!=NULL fprintf(hlog,"Measuring offset of calibration board...\n")
  Drawcalboard(0,0,0,DR_HEAD)          // Show calibration board in shuttle
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now measuring the offset of the calibration board relative "
  draw text="to the fingers' axes of rotation. If you want to change board "
  draw text="placement, doubleclick button " font=MAINFONT text="Interrupt"
  draw font=TIMESFONT text=". If you are sure that board is placed correctly, "
  draw text="press " font=MAINFONT text="Skip" font=TIMESFONT text="."
  draw show
  hremain=control GRAPH                // To avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,120,200,85
    help="Duration of scanning and estimated time till end of current step"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  hinterrupt=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  hskip=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="Skip"
    help="Press to assume good placement of calibration board and skip heating"
  endc
  hview=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="Statistics"
    help=""
  endc
  i=Waitcancel(hskip)
  if i<0 return i
  if i>0 return 0                      // Step skipped by user
  i=Runelectroscan(hremain,hinterrupt,hskip,hview,0.0)
  if i!=0 return i
  // Calculate offsets and check whether they all lay within sound limits.
  if boardtype==0 || boardtype==1 then
    maxdy=0.5
    maxdfi=800.0/($LAY.rightlimit-$LAY.leftlimit)
  else
    maxdy=0.25
    maxdfi=500.0/($LAY.rightlimit-$LAY.leftlimit)
  endif
  ndy=0; ndfi=0; n=0; err=0
  meandy=0.0; meandfi=0.0; topdr=0
  if hlog!=NULL then
    fprintf(hlog,"Offsets of calibration board for each head:\n")
  endif
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    scanerr[i]=Estimateoffset(i,dy+i,dfi+i,dr+i)
    if hlog!=NULL then
      fprintf(hlog,                                                            \
      "  Head %i%c: St=%3i, dY=%7.3f mm, dFi=%7.3f mm, dR=%7.3f mm\n",         \
      i/2,(i & 1?'R':'L'),scanerr[i],dy[i],                                    \
      dfi[i]*($LAY.rightlimit-$LAY.leftlimit)/1000.0,dr[i])
    endif
    if (scanerr[i] & 0x01)!=0 then
      meandy=meandy+dy[i]; ndy++
    endif
    if (scanerr[i] & 0x02)!=0 then
      meandfi=meandfi+dfi[i]; ndfi++
    endif
    if (scanerr[i] & 0x04)!=0 then
      topdr=Max(topdr,Abs(dr[i]))
    endif
    n++
  enddo
  if ndy>0 meandy=meandy/ndy
  if ndfi>0 meandfi=meandfi/ndfi
  // If this is an S3, correct shuttle offset and head offsets in layout.
  if testertype==TT_S3 && Abs(meandy)>0.1 && Abs(meandy)<3.0 then
    if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      // Mea maxima culpa!
      $int4($EXTLAY+728)=$int4($EXTLAY+728)-meandy*1000.0
    else
      $int4($EXTLAY+728)=$int4($EXTLAY+728)+meandy*1000.0
    endif
    // Note that I do not change vertical offset of dedicated camera. Scan
    // shuttle position is based on zero pulse and does not use shuttle offset.
    for i=0,i<$LAY.nfing*2,i++ do
      if (i & 1)==0 then               // Left head
        $LAY.leftzeroy[i/2]=$LAY.leftzeroy[i/2]+meandy*1000.0
      else                             // Right head
        $LAY.rightzeroy[i/2]=$LAY.rightzeroy[i/2]+meandy*1000.0
      endif
    enddo
    if hlog!=NULL then
      fprintf(hlog,"Mean Y offset %.3f mm is applied to the layout\n",meandy)
    endif
    meandy=0.0                         // Corrected!
  else
    if Abs(meandy)<maxdy/2.0 meandy=0.0// Exclude for the sake of simplicity
  endif
  if Abs(meandfi)<maxdfi/2.0 meandfi=0.0
  if ndy<=n/2 || ndfi<=n/2 err=1       // Too few points, prediction unreliable
  if topdr>maxdy*5.0 err=2             // Some radius is too different
  if Abs(meandy)>maxdy err=3           // High vertical board shift
  if Abs(meandy)>maxdy*3.0 err=4       // Too high vertical board shift
  if Abs(meandfi)>maxdfi err=5         // High board placement angle
  if Abs(meandfi)>maxdfi*3.0 err=6     // Too high board placement angle
  if err==0 return 0                   // All within limits
  // Warn about bad board placement or finger length and ask what to do next.
  if hlog!=NULL then
    fprintf(hlog,"Placement problem %i: dY=%7.3f mm, dFi=%7.3f mm\n",          \
    err,meandy,meandfi*($LAY.rightlimit-$LAY.leftlimit)/1000.0)
  endif
  change hinfo limits=0,0
  change hinfo text="Placement problem"
  clear hright
  Drawcalboard(0,meandy,meandfi,0)     // Show calibration board in shuttle
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Due to the large number of bad crosses, board position is "
    draw text="unreliable."
  else if err==2 then
    draw text="Some fingers have length that differs too much from expected."
  else if err==3 || err==5 then
    draw text="Misplaced calibration board."
  else
    draw text="Shift of the calibration board is too high."
  endif
  draw color=BLACK text=" Please consult the table below and"
  if err!=2 then
    draw text=" adjust placement of the calibration board"
  else
    draw text=" check needles"
  endif
  if err!=4 && err!=6 draw text=", or continue at your own risk"
  draw text="." show
  htable=control CHILD
    window=hright
    position=9,110,RIGHTX-18,160
    limits=RIGHTX-20,n*20+38
    mode=M_VSCROLL
    help="Individual nonidealities of the heads"
    bkcolor=PINK
    size=4096
  endc
  y=30
  draw window=htable font=INFOFONT color=DARKGRAY
  draw at 5,5 to 225,5
  draw at 5,5 to 5,32 at 9,26 text="Head"
  draw at 45,5 to 45,32 at 54,26 text="dY,mm"
  draw at 105,5 to 105,32 at 113,26 text="dFi,deg"
  draw at 165,5 to 165,32 at 173,26 text="dR,mm"
  draw at 225,5 to 225,33
  draw at 5,32 to 225,32
  draw font=FIXEDSYS
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    y=y+20
    draw color=DARKGRAY
    draw at 5,y-18 to 5,y+2 to 225,y+2 to 225,y-18
    draw at 45,y-18 to 45,y+2
    draw at 105,y-18 to 105,y+2
    draw at 165,y-18 to 165,y+2
    draw at 12,y color=BLACK text=format("%2i%c",i/2,(i & 1)==0?'L':'R')
    draw at 53,y
    if (scanerr[i] & 0x01)==0 then     // No dy information
      draw color=LIGHTRED text="   -"
    else
      draw color=(Abs(dy[i])<=maxdy?BLACK:LIGHTRED)
      draw text=format("%5.1f",dy[i])
    endif
    draw at 113,y
    if (scanerr[i] & 0x02)==0 then     // No dfi information
      draw color=LIGHTRED text="   -"
    else
      draw color=(Abs(dfi[i])<=maxdfi?BLACK:LIGHTRED)
      draw text=format("%5.2f",dfi[i]*180.0/PI)
    endif
    draw at 173,y
    if (scanerr[i] & 0x04)==0 then     // No dr information
      draw color=LIGHTRED text="   -"
    else
      draw color=(Abs(dr[i])<=maxdy*3?BLACK:LIGHTRED)
      draw text=format("%5.2f",dr[i])
    endif
  enddo
  draw show
  setfocus htable
  if err!=4 && err!=6 then             // Display both buttons
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
  else                                 // High shift, display one button
    hreplace=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hcont=NULL
  endif
  while 1 do
    if Pressed(hreplace) return 2
    if hcont!=NULL && (Pressed(hcont) || autoconfirm) then
      Logcontinue()
      return 0
    endif
    if Pressed(hexit) return -1
    wait
  enddo
end

// Contacts calibration board between the crosses by all fingers in order to
// heat them up and to let board vibrate and jump for some time. Returns -1
// if operator decided to quit calibration, 1 if there was command sending
// error or 0 if warmup is finished successfully.
// NOT YET 100% FOOLPROOF!
function int Heatfingers(int warmuptime)
  int i,t,tupdate,step[16]
  float x0[16],y0[16],x[16],y[16],dx,dy
  char s[128]
  handle hbypass
  if warmuptime==0 return 0            // Warmup not necessary
  change hinfo limits=0,0
  change hinfo text="Warming up fingers"
  if hlog!=NULL fprintf(hlog,"Warming up fingers...\n");
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  if warmuptime<60 then
    draw text=format("For %i seconds ",warmuptime)
  else if warmuptime/60==1 then
    draw text="For 1 minute "
  else
    draw text=format("For %i minutes ",warmuptime/60)
  endif
  draw text="fingers will touch calibration board in random points between "
  draw text="crosses. This is necessary to warm up fingers and to shake "
  draw text="the calibration board, so it (hopefully) comes into more stable "
  draw text="position. If you are hurrying, you may bypass warmup, but "
  draw text="the accuracy will be slightly lower."
  draw show
  hbypass=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Bypass warmup"
    help="Press to break warmup and continue with calibration"
  endc
  i=Waitcancel(hbypass)
  if i<0 return i
  if i>0 return 0                      // Step skipped by user
  t=Time(); tupdate=t
  // Prepare for warmup.
  for i=0,i<$LAY.nfing,i++ do
    if c[i*2].ncal==0 continue         // Rail is excluded from calibration
    step[i]=0
    x0[i]=$LAY.xoffset/1000.0+boardshift-xstep*CENTERX
    while x0[i]<fromx || x0[i]<c[i*2].refx0+refsizex do
      x0[i]=x0[i]+xstep
    enddo
    x0[i]=x0[i]+xstep/2; x[i]=x0[i]
    y0[i]=$LAY.yoffset[i]/1000.0-ystep*CENTERY
    while y0[i]<$LAY.bottom[i]/1000.0 ||                                       \
      (testertype==TT_A5L && smallboard!=0 &&                                  \
      y0[i]<$LAY.bottom[smallfirst]/1000.0+25.0) ||                            \
      (testertype==TT_A7 && smallboard!=0 && boardtype!=1 &&                   \
      y0[i]<$LAY.bottom[smallfirst]/1000.0+25.0) ||                            \
      (testertype==TT_A7 && smallboard!=0 && boardtype==1 &&                   \
      y0[i]<$LAY.bottom[smallfirst]/1000.0+55.0) do
      y0[i]=y0[i]+ystep
    enddo
    y0[i]=y0[i]+ystep/2; y[i]=y0[i]
    $A[i].length=5                     // Mark all answers as "arrived"
  enddo
  // Warmup loop.
  while (Time()-t<warmuptime*1000) do
    if Time()>=tupdate then
      change hinfo limits=Min((Time()-t)/1000,warmuptime),warmuptime
      tupdate=tupdate+500
    endif
    if Pressed(hexit) then
      return -1
    else if Pressed(hbypass) then
      if hlog!=NULL then
        fprintf(hlog,"  Warm-up interrupted after %i seconds\n",(Time()-t)/1000)
      endif
      break
    endif
    if demo==0 then
      for i=0,i<$LAY.nfing,i++ do
        if c[2*i].ncal==0 continue     // Rail is excluded from calibration
        if $A[i].length==0 continue    // Previous command is still pending
        step[i]++
        if step[i]>2 then
          step[i]=0
          x[i]=x[i]+xstep              // Go to next cell
          if x[i]+xstep>tox || x[i]+xstep>c[2*i+1].refx0-refsizex then
            x[i]=x0[i]                 // Go to next row
            y[i]=y[i]+ystep
            if y[i]+ystep>$LAY.top[i]/1000.0 ||                                \
              (testertype==TT_A5L && smallboard!=0 &&                          \
              y[i]+ystep>$LAY.top[smalllast]/1000.0-25.0) ||                   \
              (testertype==TT_A7 && smallboard!=0 && boardtype!=1 &&           \
              y[i]+ystep>$LAY.top[smalllast]/1000.0-25.0) ||                   \
              (testertype==TT_A7 && smallboard!=0 && boardtype==1 &&           \
              y[i]+ystep>$LAY.top[smalllast]/1000.0-55.0) then
              y[i]=y0[i]               // Restart from beginning
            endif
          endif
        endif
        dx=Random(xstep/4.0)-xstep/8.0
        dy=Random(ystep/4.0)-ystep/8.0
        sprintf(s,"M %i(%g,%gA100V%iP%i) %i(%g,%gA100V%iP%i) R(%i,%i)",        \
          i*2,x[i]+dx,y[i]+dy,v,p,i*2+1,x[i]+xstep+dx,y[i]+dy,v,p,i*2,i*2+1)
        SERV.Cmdimm(i,s)               // Send next command
      enddo
    endif
    wait
  enddo
  if demo return 0
  // Bring fingers into home positions after warmup is finished or interrupted.
  for i=0,i<$LAY.nfing,i++ do
    if c[2*i].ncal==0 continue         // Rail is excluded from calibration
    SYS.Killimm(i)
    sprintf(s,"M %i(Z) %i(Z) N",i*2,i*2+1)
    SERV.Cmdimm(i,s)                   // Send homing command
  enddo
  t=Time()+10000                       // Timeout 10 seconds
  while Time()<t do
    for i=0,i<$LAY.nfing,i++ do
      if c[2*i].ncal==0 continue
      if $A[i].length!=5 || $A[i].answer!=S_READY break
    enddo
    if i==$LAY.nfing break             // All answers are back
    if Pressed(hexit) return -1
    wait
  enddo
end

#define NZPOINT        120             // Number of sampling points, N*6
#define NZSTAT         10              // Number of measurements per point, even
#define PRESSMIN       47500           // Minimal signal without pressure
#define ZPINMIN        10.0            // Minimal Z pin distance, um
#define ZPINMAX        100.0           // Maximal Z pin distance, um
#define XPINMAX        0.035           // Maximal X pin distance, mm
#define YPINMIN        0.030           // Minimal Y pin distance, mm
#define YPINMAX        0.090           // Maximal Y pin distance, mm

// Adjusts pressure factors for the microprobes. The procedure is similar to
// capacity adjustment script or to dedicated Kelvin probe test, but shortcuts
// and contact are not tested (no pad!). Returns -1 if operator decided to quit
// calibration, 1 to repeat adjustment and 0 to continue.
function int Adjustpressure()
  int i,j,n,t,head,nheads,imin,imax,select,badhead,limit[32],zn[32],ref,err
  int ntop,nbot,toplist,botlist,xb,yb,dx,redraw,firsthead,phase
  int testcontact,testkelvin
  float xcont,ycont,x[32],y[32],z[32],zref[32],zmax[32],pprev[32],zpmax[32]
  float pmean[32],zmean[32],kmean[32],cmean[32],zpmean,dyin
  float xpindist[32],ypindist[32],zpindist[32]
  float zp[32][NZPOINT],zz[32][NZPOINT],zk[32][NZPOINT],zc[32][NZPOINT]
  float zm[NZPOINT],pm[NZPOINT],zi[NZPOINT],pi[NZPOINT],zfactlo[32],zfacthi[32]
  float u,zbase,zscale,pbase,pscale,yscale,kcontact,ccontact,psensfact
  float zstep,zfactor,senslomin,senslomax,senshimin,senshimax,rangemin
  char s[256]
  handle hview,hinterrupt,hhead[32],hok,hrepeat,hcont
  if demo || (testertype!=TT_A5 && testertype!=TT_A5L &&                       \
    testertype!=TT_A6 && testertype!=TT_S1 && testertype!=TT_S2 &&             \
    testertype!=TT_S3 && testertype!=TT_A7 && testertype!=TT_A8) ||            \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP then
    return 0                           // Pressure factors are not supported
  endif
  nheads=$LAY.nfing*2
  // Set expected limits.
  if ($EXTLAY.zheadtype & HCZ_DMSMASK)==HCZ_DMSSTD then
    // Mirror (direct) sensor.
    zstep=8.0                          // Z step, micrometers
    psensfact=80.0                     // Expected bits per micrometer
    senslomin=50.0                     // Minimal low sensitivity, bits/um
    senslomax=100.0                    // Maximal low sensitivity, bits/um
    senshimin=60.0                     // Minimal high sensitivity, bits/um
    senshimax=110.0                    // Maximal high sensitivity, bits/um
    rangemin=22500.0                   // Minimal sensor range, bits
  else if ($EXTLAY.zheadtype & HCZ_DMSMASK)==HCZ_DMSREV then
    // Inverting sensor.
    zstep=4.0
    psensfact=150.0
    senslomin=90.0
    senslomax=200.0
    senshimin=120.0
    senshimax=240.0
    rangemin=43500.0
  else
    // Autodetect. We have no choice but to set wide limits.
    zstep=4.0
    psensfact=100.0
    senslomin=50.0
    senslomax=200.0
    senshimin=60.0
    senshimax=240.0
    rangemin=43500.0                   // A question of security
  endif
  if ($EXTLAY.zheadtype & HCZ_VALID)==0 then
    zfactor=1.10                       // A kind of compromise
  else if ($EXTLAY.zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA2G then
    zfactor=1.10                       // A2 gray parallelogramm
  else if ($EXTLAY.zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA2W then
    zfactor=1.10                       // A2 white parallelogramm
  else if ($EXTLAY.zheadtype & HCZ_TYPEMASK)==HCZ_TYPEA3 then
    zfactor=1.35                       // A3 gray parallelogramm
  else
    zfactor=1.00                       // Z axis with a scale
  endif
  // Verify that embedded software supports individual pressure factors.
  if (cratefeatures & CF_PRESSFACT)==0 then
    return 0                           // Pressure factor is not supported
  endif
  // Prepare for the adjustment.
  change hinfo limits=0,0
  change hinfo text="Calibrating pressure"
  if hlog!=NULL fprintf(hlog,"Calibrating pressure sensors...\n");
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text=""
  draw text=""
  draw text=""
  draw text=" " color=LIGHTRED text=""
  draw text="" color=BLACK
  if calmode!=MODE_VER || verifymode!=VERIFY_NEEDLES then
    draw text="" font=MAINFONT text="" font=TIMESFONT
    draw text="."
  endif
  draw show
  if calmode==MODE_VER && verifymode==VERIFY_NEEDLES then
    hinterrupt=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Quit"
      help="Doubleclick to cancel adjustment of pressure sensors"
      mode=M_DBLCLICK
    endc
  else
    hinterrupt=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Skip"
      help="Press to skip adjustment of pressure sensors"
    endc
  endif
  i=Waitcancel(hinterrupt)
  if i<0 return i
  if i>0 return 0                      // Step skipped by user
  // Prepare for test.
  for head=0,head<32,head++ do
    x[head]=-10000.0
    limit[head]=0
    xpindist[head]=0
  enddo
  // If we have Kelvin probes, find crosses on the calibration board that will
  // be used for the pressure correction and to measure distance between the
  // pins of Kelvin needle. Failure in scanning will turn corresponding test
  // off.
  if $LAY.probetype==0 || (measfeatures & MF_KELVSCAN)==0 then
    testcontact=(kelvinscan==0)        // Only if ref pads are accessible
    testkelvin=0
  else
    change hinfo text=""
    Fillcalibrators(C_CENTER,FILL_MECH)
    for head=0,head<nheads,head++ do
      if c[head].ncal==0 continue
      if (head & 1)==0 then            // Left heads
        c[head].xa[0]=c[head].xa[0]+2*xstep
        while c[head].xa[0]-2*xstep>fromxloc+1.5*xstep do
          c[head].xa[0]=c[head].xa[0]-2*xstep
        enddo
      else                             // Right heads
        c[head].xa[0]=c[head].xa[0]-2*xstep
        while c[head].xa[0]+2*xstep<toxloc-1.5*xstep do
          c[head].xa[0]=c[head].xa[0]+2*xstep
        enddo
      endif
      c[head].xm[0]=c[head].xa[0]
      c[head].xa[1]=c[head].xa[0]
      c[head].ya[1]=c[head].ya[0]
      c[head].xm[1]=c[head].xm[0]
      c[head].ym[1]=c[head].ym[0]
      c[head].ncal=2
      c[head].forcekelvin=1            // Second time use Kelvin scan
    enddo
    i=Runelectroscan(NULL,hinterrupt,NULL,NULL,0.0)
    if i<0 return -1
    if i==2 err=1
    for head=0,head<nheads,head++ do
      if c[head].ncal==0 continue
      if c[head].err[0]!=0 || c[head].err[1]!=0 then
        i=1
      else
        xpindist[head]=Abs(c[head].wx[0]-c[head].wx[1])/2.0
        ypindist[head]=Max(0.0,(c[head].wy[0]-c[head].wy[1])/2.0)
      endif
    enddo
    testcontact=(i==0)
    testkelvin=(i==0)
    change hinfo limits=0,0
    change hinfo text="Calibrating pressure"
  endif
  // Select X-Y coordinates and learn Z coordinate of the board. Contacting of
  // calibration lines is enforced for Kelvin needles. Contacting is enforced
  // for single micro probes if reference pads to be used and is acceptable
  // otherwise. Note that tester is not yet calibrated.
  for n=5,n>=0 && err==0,n-- do
    // Send movements.
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      if testkelvin!=0 then
        xcont=c[head].xm[0]            // Last contact exactly on the pad
        ycont=c[head].ym[0]
        if n>0 then
          xcont=xcont+Random(xstep*0.05)-xstep*0.025
          ycont=ycont+Random(ystep*0.10)-ystep*0.050
        endif
      else if testcontact!=0 then
        while 1 do
          xcont=c[head].refx0+Random(0.2)-0.1
          ycont=c[head].refy0+Random(0.2)-0.1
          if Abs(xcont-x[head])>0.01 || Abs(ycont-y[head])>0.01 break
        enddo
      else
        while 1 do
          if (head & 1)==0 then        // Left head
            xcont=c[head].refx0+xstep*1.4+Random(xstep*0.1)
          else                         // Right head
            xcont=c[head].refx0-xstep*1.4-Random(xstep*0.1)
          endif
          ycont=$LAY.yoffset[head/2]/1000.0+Random(ystep)*0.2+ystep*0.4
          // Assure real movement.
          if Abs(xcont-x[head])>0.01 || Abs(ycont-y[head])>0.01 break
        enddo
      endif
      sprintf(s,"M %i[%g,%gA10H15V15P5] Z(%i)",head,xcont,ycont,head)
      SYS.Killimm(head)
      if SERV.Cmdimm(head,s)==0 err=2
      x[head]=xcont
      y[head]=ycont
    enddo
    // Wait for answers.
    t=Time()
    while err==0 do
      if Pressed(hinterrupt) err=1
      if Pressed(hexit) return -1
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 continue
        if $A[head].length==0 break
      enddo
      if head>=nheads break            // All answers are back
      if Time()-t>10000 err=3          // Timeout
      wait
    enddo
    // Process answers.
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      if $A[head].answer!=S_INPORT err=2
      zref[head]=$A[head].inport       // Z reference coordinate, um
    enddo
  enddo
  // Wait a bit to stop possible shaking of the calibration board.
  if err==0 delay 2500
  // Start measurements. If contact test is off, I move all heads synchronously.
  // Otherwise, I test first all left teads, then all right.
  for phase=0,phase<2,phase++ do
    if testcontact==0 && phase==1 break
    // Move heads up and at coordinates.
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      if testcontact!=0 && (head & 1)!=phase continue
      sprintf(s,"M %i[%g,%gA10H15V15P5] UP(%i) NOP",head,x[head],y[head],head)
      SERV.Cmdimm(head,s)
      sprintf(s,"OUTPORT32 HEAD(%i),0x10010007,50",head)
      SERV.Cmdimm(32,s)
      if testcontact!=0 && kelvinscan!=1 && kelvinscan!=3 then
        ref=head^1
        sprintf(s,"M %i[%g,%gA%i] Z(%i)",ref,c[ref].refx,c[ref].refy,acc,ref)
        SERV.Cmdimm(32,s)
      endif
    enddo
    t=Time()
    while err==0 do
      if Pressed(hinterrupt) err=1
      if Pressed(hexit) return -1
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 continue
        if testcontact!=0 && (head & 1)!=phase continue
        if $A[head].length==0 break
      enddo
      if head>=nheads break            // All answers are back
      if Time()-t>10000 err=3          // Timeout
      wait
    enddo
    t=Time()
    while err==0 do                    // Wait 500 ms for stabilization
      if Pressed(hinterrupt) err=1
      if Pressed(hexit) return -1
      if Time()-t>500 break
      wait
    enddo
    for n=-100,n<NZPOINT && err==0,n++ do
      if testcontact then
        change hinfo limits=(NZPOINT+120)*phase+n+100,(NZPOINT+120)*2
      else
        change hinfo limits=n+100,NZPOINT+120
      endif
      firsthead=1;
      // Set Z coordinate.
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 || limit[head]!=0 continue
        if testcontact!=0 && (head & 1)!=phase continue
        if (firsthead) then
          // Older versions of Crate controller don't prolongate Z up timeout
          // on OUTPORT 0x10010018, therefore I reprogram Dallas potentiometer
          // with the current value. As a side effect, this command prolongates
          // Z up time.
          sprintf(s,"OUTPORT32 HEAD(%i),0xE0,%i",head,$EXTLAY.sinadj[head])
          SERV.Cmdimm(32,s)
          firsthead=0
        endif
        // Negative n values correspond to fast preliminary movement.
        if n<0 then
          z[head]=zref[head]+n*40.0-(NZPOINT/2)*zstep
        else
          z[head]=zref[head]+n*zstep-(NZPOINT/2)*zstep
        endif
        sprintf(s,"OUTPORT32 HEAD(%i),0x10010018,%i",head,z[head])
        SERV.Cmdimm(head,s)
        zmax[head]=z[head]
      enddo
      // Wait for answer.
      t=Time()
      while err==0 do
        if Pressed(hinterrupt) err=1
        if Pressed(hexit) err=-1
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          if $A[head].length==0 break
        enddo
        if head>=nheads break
        if Time()-t>5000 err=3         // Timeout
        wait
      enddo
      // If preliminary movement, delay and skip the rest.
      if n<=0 && err==0 then
        while Time()-t<50 do
          if Pressed(hexit) then
            err=-1; break
          endif
          wait
        enddo
        if n<0 continue
      endif
      // Make NZSTAT pressure, pin-to-pin resistance, capacity-to-reference and
      // coordinate tests. Note that there are no wait operators in the waiting
      // loops, they slow down the test significantly.
      for head=0,head<nheads,head++ do
        if testcontact!=0 && (head & 1)!=phase continue
        pmean[head]=0.0
        zmean[head]=0.0
        kmean[head]=0.0
        cmean[head]=0.0
      enddo
      for j=0,j<NZSTAT && err==0,j++ do
        // Measure pressures.
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          sprintf(s,"INPORT32 HEAD(%i),0x10000107",head)
          SERV.Cmdimm(head,s)
        enddo
        t=Time()
        while err==0 do
          if Pressed(hinterrupt) err=1
          if Pressed(hexit) err=-1
          for head=0,head<nheads && err==0,head++ do
            if c[head].ncal==0 || limit[head]!=0 continue
            if testcontact!=0 && (head & 1)!=phase continue
            if $A[head].length==0 break
          enddo
          if head>=nheads break
          if Time()-t>5000 err=3       // Timeout
        enddo
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          pmean[head]=pmean[head]+$A[head].inport
        enddo
        // Measure Z coordinates.
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          sprintf(s,"INPORT32 HEAD(%i),0x10000018",head)
          SERV.Cmdimm(head,s)
        enddo
        t=Time()
        while err==0 do
          if Pressed(hinterrupt) err=1
          if Pressed(hexit) err=-1
          for head=0,head<nheads && err==0,head++ do
            if c[head].ncal==0 || limit[head]!=0 continue
            if testcontact!=0 && (head & 1)!=phase continue
            if $A[head].length==0 break
          enddo
          if head>=nheads break
          if Time()-t>5000 err=3       // Timeout
        enddo
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          zmean[head]=zmean[head]+$A[head].inport
        enddo
        // Measure pin-to-pin resistances (Kelvin test only).
        if testkelvin then
          for head=0,head<nheads && err==0,head++ do
            if c[head].ncal==0 || limit[head]!=0 continue
            if testcontact!=0 && (head & 1)!=phase continue
            sprintf(s,"M %i[%g,%gA10H15V15P5] CONTKELV(%i)",                   \
              head,x[head],y[head],head)
            SERV.Cmdimm(head,s)
          enddo
          t=Time()
          while err==0 do
            if Pressed(hinterrupt) err=1
            if Pressed(hexit) err=-1
            for head=0,head<nheads && err==0,head++ do
              if c[head].ncal==0 || limit[head]!=0 continue
              if testcontact!=0 && (head & 1)!=phase continue
              if $A[head].length==0 break
            enddo
            if head>=nheads break
            if Time()-t>5000 err=3     // Timeout
          enddo
          for head=0,head<nheads && err==0,head++ do
            if c[head].ncal==0 || limit[head]!=0 continue
            if testcontact!=0 && (head & 1)!=phase continue
            if ($A[head].status & 0x0200)==0 kmean[head]=kmean[head]+10000.0
          enddo
        endif
        // Measure capacity (contact test only). Movement command depends on
        // the reference. If Kelvin scan (no reference) is requested, we can't
        // measure capacity at all.
        if testcontact==0 || kelvinscan==1 continue
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          if kelvinscan==3 then
            sprintf(s,"M %i[%g,%gA%i] CONTCAP(%i,32)",                         \
            head,x[head],y[head],acc,head)
          else
            ref=head^1
            sprintf(s,"M %i[%g,%gA%i] %i[%g,%g] CONTCAP(%i,%i)",               \
            head,x[head],y[head],acc,ref,c[ref].refx,c[ref].refy,head,ref)
          endif
          SERV.Cmdimm(head,s)
        enddo
        t=Time()
        while err==0 do
          if Pressed(hinterrupt) err=1
          if Pressed(hexit) err=-1
          for head=0,head<nheads && err==0,head++ do
            if c[head].ncal==0 || limit[head]!=0 continue
            if testcontact!=0 && (head & 1)!=phase continue
            if $A[head].length==0 break
          enddo
          if head>=nheads break
          if Time()-t>5000 err=3       // Timeout
        enddo
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          if $A[head].status & 0x1000 then
            cmean[head]=cmean[head]+10000.0
          else
            cmean[head]=cmean[head]+$int4($A[head]+8)
          endif
        enddo
      enddo
      // Process results.
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 || limit[head]!=0 continue
        if testcontact!=0 && (head & 1)!=phase continue
        pmean[head]=pmean[head]/NZSTAT
        zmean[head]=zmean[head]/NZSTAT
        kmean[head]=kmean[head]/NZSTAT
        cmean[head]=cmean[head]/NZSTAT
        if zmean[head]!=0 && n>NZPOINT/10 then
          if Abs(zmean[head]-z[head])>150.0 then
            limit[head]=1              // Coordinate differs from expected
          else if n>4 then
            zpmean=(zp[head][0]+zp[head][1]+zp[head][2]+zp[head][3])/4.0
            if zpmean-pmean[head]>10000 then
              limit[head]=1            // Pressure limit reached
            endif
          endif
        endif
        zz[head][n]=z[head]            // Or better zmean[]?
        zp[head][n]=pmean[head]
        zk[head][n]=kmean[head]
        zc[head][n]=cmean[head]
        zn[head]=n                     // Last point is discarded!
      enddo
    enddo
    // Measure maximal pressure that sensor can deliver. I set Z coordinate
    // 1000 micrometers under the measured contact. Attention, careless use of
    // this overpressure may destroy the needle!
    for head=0,head<nheads,head++ do
      if testcontact!=0 && (head & 1)!=phase continue
      limit[head]=0
      pprev[head]=100000
    enddo
    for j=0,j<=20 && err==0,j++ do
      if testcontact then
        change hinfo limits=(NZPOINT+120)*phase+NZPOINT+100+j,(NZPOINT+120)*2
      else
        change hinfo limits=NZPOINT+100+j,NZPOINT+120
      endif
      // Set Z coordinate.
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 || limit[head]!=0 continue
        if testcontact!=0 && (head & 1)!=phase continue
        z[head]=Max(zref[head]+j*50.0,zmax[head])
        sprintf(s,"OUTPORT32 HEAD(%i),0x10010018,%i",head,z[head])
        SERV.Cmdimm(head,s)
      enddo
      t=Time()
      while err==0 do
        if Pressed(hinterrupt) err=1
        if Pressed(hexit) err=-1
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          if $A[head].length==0 break
        enddo
        if head>=nheads break
        if Time()-t>5000 err=3         // Timeout
        wait
      enddo
      // Move down slowly!
      while Time()-t<100 do
        wait
      enddo
      // Check pressure. Single measurement is sufficient.
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 || limit[head]!=0 continue
        if testcontact!=0 && (head & 1)!=phase continue
        sprintf(s,"INPORT32 HEAD(%i),0x10000107",head)
        SERV.Cmdimm(head,s)
      enddo
      t=Time()
      while err==0 do
        if Pressed(hinterrupt) err=1
        if Pressed(hexit) err=-1
        for head=0,head<nheads && err==0,head++ do
          if c[head].ncal==0 || limit[head]!=0 continue
          if testcontact!=0 && (head & 1)!=phase continue
          if $A[head].length==0 break
        enddo
        if head>=nheads break
        if Time()-t>5000 err=3         // Timeout
        wait
      enddo
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 || limit[head]!=0 continue
        if testcontact!=0 && (head & 1)!=phase continue
        zpmax[head]=$A[head].inport
        if $A[head].inport<3000 limit[head]=1
        if $A[head].inport<32768 && pprev[head]-$A[head].inport<50 then
          limit[head]=1
        endif
      enddo
    enddo
    // Move heads up, necessary for older versions of Crate controller.
    for head=0,head<nheads,head++ do
      if c[head].ncal==0 continue
      if testcontact!=0 && (head & 1)!=phase continue
      sprintf(s,"OUTPORT32 HEAD(%i),0x10010007,0",head)
      SERV.Cmdimm(32,s)
      sprintf(s,"OUTPORT32 HEAD(%i),0x10010008,5000",head)
      SERV.Cmdimm(head,s)
    enddo
    t=Time()
    while Time()-t<500 do
      wait
    enddo
  enddo
  // Test is finished. Restore default Z port speed and move heads up and in
  // home position.
  for head=0,head<nheads && err==0,head++ do
    if c[head].ncal==0 continue
    sprintf(s,"OUTPORT32 HEAD(%i),0x10010007,0",head)
    SERV.Cmdimm(32,s)
    sprintf(s,"OUTPORT32 HEAD(%i),0x10010008,5000",head)
    SERV.Cmdimm(32,s)
  enddo
  delay 250
  if err<0 return -1
  for head=0,head<nheads && err==0,head++ do
    if c[head].ncal==0 continue
    sprintf(s,"M %i(Z) NOP",head)
    SERV.Cmdimm(32,s)
  enddo
  // Approximate pressure curves with splines.
  for head=0,head<nheads && err==0,head++ do
    if c[head].ncal==0 continue
    zpmean=(zp[head][0]+zp[head][1]+zp[head][2]+zp[head][3])/4.0
    for imin=4,imin<zn[head],imin++ do
      if zpmean-zp[head][imin]>=500 break
    enddo
    for imax=zn[head]-1,imax>=0,imax-- do
      if zpmean-zp[head][imax]>=2500 break
    enddo
    imax=imax-1
    if imax-imin>NZPOINT/16 then
      for j=0,j<imax-imin+1,j++ do
        zm[j]=j
        pm[j]=zp[head][j+imin]
        zi[j]=j
      enddo
      dyin=50.0
      SYS.Splinefit(imax-imin+1,zm,pm,&dyin,imax-imin+1,zi,pi);
      zfactlo[head]=Abs(pi[3]-pi[0])/3.0/zstep*zfactor
      zfacthi[head]=Abs(pi[imax-imin]-pi[imax-imin-3])/3.0/zstep*zfactor
    endif
  enddo
  // Determine pin-to-pin distance.
  if err==0 && testkelvin!=0 && kelvinscan!=1 then
    for head=0,head<nheads,head++ do
      zpindist[head]=-100000.0         // Means unknown Z distance between pins
      if c[head].ncal==0 continue
      if zn[head]<=1 continue
      if zk[head][0]>=5000.0 || zk[head][zn[head]-1]<=5000.0 continue
      if zc[head][0]>=5000.0 || zc[head][zn[head]-1]<=5000.0 continue
      kcontact=zz[head][zn[head]-1]
      ccontact=zz[head][zn[head]-1]
      for i=zn[head]-1,i>=0,i-- do
        if zk[head][i]>5000.0 kcontact=zz[head][i]
        if zc[head][i]>5000.0 ccontact=zz[head][i]
      enddo
      zpindist[head]=(kcontact-ccontact)/zfactor
    enddo
  endif
reporterror:
  // If error was detected, report it.
  if err!=0 then
    if hlog!=NULL then
      if err==1 then
        fprintf(hlog,                                                          \
        "  Calibration of pressure sensors interrupted by operator\n");
      else
        fprintf(hlog,                                                          \
        "  Calibration of pressure sensors was unsuccessfull (%i)\n",err);
      endif
    endif
    for head=0,head<nheads,head++ do
      if c[head].ncal==0 continue
      SYS.Killimm(head)
    enddo
    if err==1 return 0                   // Operator interrupted adjustment
    clear hright
    change hinfo limits=0,0
    change hinfo text="Sensors not calibrated!"
    hrepeat=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Repeat"
      help="Press to repeat pressure calibration"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Continue"
      help="Press to continue calibration"
    endc
    draw window=hright color=LIGHTRED font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text "Unable to calibrate pressure sensors. " color=BLACK
    if err==2 then
      draw text="Some commands were rejected by tester. "
    else if err==3 then
      draw text="There was no answer from the tester within the expected "
      draw text="timeout. "
    else
      draw text="The exact reason is unclear. "
    endif
    draw text="If you decide to " font=MAINFONT text="Continue" font=TIMESFONT
    draw text=", pressure factors in layout will remain unchanged."
    draw show
    while 1 do
      if autoconfirm then
        if hlog!=NULL fprintf(hlog,                                            \
        "  Calibration continues according to calibration options\n")
        return 0
      else if Pressed(hcont) then
        if hlog!=NULL fprintf(hlog,                                            \
        "  Operator decided to continue calibration\n")
        return 0
      else if Pressed(hrepeat) then
        return 1
      else if Pressed(hexit) then
        return -1
      endif
      wait
    enddo
  endif
  // Save results to log.
  if hlog!=NULL then
    fprintf(hlog,"  Pressure correction results:\n")
    for head=0,head<nheads,head++ do
      if c[head].ncal==0 continue
      fprintf(hlog,"  Head %i%c: Plo = %5.1f, Phi = %5.1f bits/um, ",          \
      head/2,head & 1?'R':'L',zfactlo[head],zfacthi[head])
      fprintf(hlog,"Pmin = %5.0f, Range = %5.0f bits\n",                       \
      zp[head][0],zp[head][0]-zpmax[head])
      n=0
      if ypindist[head]>0.0                                                    \
        n=n+sprintf(s+n,"Pin distance X = %5.1f, Y = %5.1f um",                \
        xpindist[head]*1000.0,ypindist[head]*1000.0)
      if err==0 && testkelvin!=0 && kelvinscan!=1 then
        if n>0 n=n+sprintf(s+n,", ")
        n=n+sprintf(s+n,"Z distance = %5.1f um",zpindist[head])
      endif
      if n>0 fprintf(hlog,"         : %s\n",s)
    enddo
  endif
  // Analyse results. If they are OK and autoconfirmation is active,
  // continue calibration without bothering the operator.
  badhead=-1
  for head=0,head<nheads && badhead<0,head++ do
    if c[head].ncal==0 continue
    if zfactlo[head]<senslomin || zfactlo[head]>senslomax badhead=head
    if zfacthi[head]<senshimin || zfacthi[head]>senshimax badhead=head
    if zp[head][0]<PRESSMIN badhead=head
    if zp[head][0]-zpmax[head]<rangemin badhead=head
    if testkelvin!=0 && kelvinscan!=1 && $EXTLAY.needletype!=NT_LATEST then
      if zpindist[head]<ZPINMIN || zpindist[head]>ZPINMAX badhead=head
    endif
    if ypindist[head]>0 then
      if xpindist[head]>XPINMAX badhead=head
      if ypindist[head]<YPINMIN || ypindist[head]>YPINMAX badhead=head
    endif
  enddo
  if badhead<0 && autoconfirm goto savedata
  // Ask user to verify test results.
  change hinfo limits=0,0
  change hinfo text=""
  clear hleft
  hview=control GRAPH                  // Create pressure correction viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help="Results of Z pressure test"
    color=BLACK
    bkcolor=WHITE
  endc
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=LIGHTRED
  if badhead<0 then
    draw text="Pressure factors adjusted."
  else
    draw text="."
  endif
  draw at 6,60 color=BLACK
  draw text="" font=MAINFONT text="OK "
  draw font=TIMESFONT text=""
  draw font=MAINFONT text=" " font=TIMESFONT text=""
  draw text="unchanged and " font=MAINFONT text=" " font=TIMESFONT
  draw text="."
  draw show
  ntop=0; toplist=0
  nbot=0; botlist=0
  for head=0,head<nheads,head++ do
    if $LAY.side[head/2]==0 then
      toplist=toplist | (1<<head)
      ntop++
    else
      botlist=botlist | (1<<head)
      nbot++
    endif
  enddo
  dx=(RIGHTX-15)/Max(ntop,nbot)-5
  if dx>50 dx=50
  yb=(ntop!=0 && nbot!=0?140:170)
  draw font=INFOFONT mode=M_CENTERED
  select=badhead
  // Create buttons for top heads.
  if ntop>0 then
    if nbot>0 then
      draw at RIGHTX/2,yb+10 text=":"
      yb=yb+12
    endif
    xb=(RIGHTX-(dx+5)*ntop+5)/2
    for head=0,head<nheads,head++ do
      if (toplist & (1<<head))==0 continue
      hhead[head]=control BUTTON
        window=hright
        position=xb,yb,dx,22
        name=format("%i%c",head/2,head & 1?'R':'L')
        help=format("Press to view data for head %i%c",head/2,head & 1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      if c[head].ncal==0 then
        disable hhead[head]
      else if select<0 then
        select=head
      endif
      xb=xb+dx+5
    enddo
    yb=yb+30
  endif
  // Create buttons for bottom cameras.
  if nbot>0 then
    if ntop>0 then
      draw at RIGHTX/2,yb+10 text=":"
      yb=yb+12
    endif
    xb=(RIGHTX-(dx+5)*nbot+5)/2
    for head=0,head<nheads,head++ do
      if (botlist & (1<<head))==0 continue
      hhead[head]=control BUTTON
        window=hright
        position=xb,yb,dx,22
        name=format("%i%c",head/2,head & 1?'R':'L')
        help=format("Press to view data for head %i%c",head/2,head & 1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      if c[head].ncal==0 then
        disable hhead[head]
      else if select<0 then
        select=head
      endif
      xb=xb+dx+5
    enddo
  endif
  hrepeat=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name=""
    help="Press to repeat test"
  endc
  hcont=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="Skip"
    help="Press to discard new pressure factors"
  endc
  hok=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="OK"
    help="Press to save new pressure factors to layout"
  endc
  redraw=1
  while 1 do
    if redraw then
      draw window=hview color=WHITE clear
      for head=0,head<nheads,head++ do
        if head==select then
          change hhead[head] color=LIGHTRED
          change hhead[head] bkcolor=YELLOW
        else
          change hhead[head] color=BLACK
          change hhead[head] bkcolor=GRAY
        endif
      enddo
      zscale=(LEFTX-81)/(NZPOINT*zstep)
      zbase=40.0+zscale*(NZPOINT/2)*zstep
      pscale=-200.0/12000.0; pbase=260.0+pscale*1000.0
      // Draw frame.
      draw color=GRAY at 40,60 rect LEFTX-40,261
      draw mode=M_CENTERED font=MEDIUMFONT color=DARKGRAY
      draw at LEFTX/2,34 text=format(" %i%c",select/2,select & 1?'R':'L')
      // Draw z scale.
      draw mode=M_CENTERED font=SMALLFONT
      for u=-(NZPOINT/2)*zstep,u<=(NZPOINT/2)*zstep,u=u+(NZPOINT/6)*zstep do
        xb=zbase+u*zscale
        draw color=GRAY at xb,261 to xb,266
        draw color=BLACK at xb,278 text=format("%g",u)
      enddo
      draw at LEFTX-20,264 text="Z, um"
      // Draw pressure scale.
      draw mode=M_RIGHT font=SMALLFONT
      for u=0,u<=10000,u=u+2000 do
        yb=pbase+u*pscale
        draw color=GRAY at 36,yb to 40,yb
        draw color=BLACK at 35,yb+7 text=format("%g",u)
      enddo
      draw color=BLACK mode=M_LEFT at 17,55 text=""
      // Draw capacity curve.
      if testcontact!=0 && kelvinscan!=1 then
        draw color=GREEN
        draw at LEFTX-80,20 to LEFTX-52,20
        draw at LEFTX-50,27 text="First pin"
        for i=0,i<zn[select],i++ do
          xb=(zz[select][i]-zref[select])*zscale+zbase
          yb=zc[select][i]*pscale+pbase
          if i==0 then
            draw at xb,yb
          else
            draw to xb,yb
          endif
        enddo
      endif
      // Draw Kelvin contact curve.
      if testkelvin!=0 then
        draw color=BLUE
        draw at LEFTX-80,35 to LEFTX-52,35
        draw at LEFTX-50,42 text="Both pins"
        for i=0,i<zn[select],i++ do
          xb=(zz[select][i]-zref[select])*zscale+zbase
          yb=zk[select][i]*pscale+pbase
          if i==0 then
            draw at xb,yb
          else
            draw to xb,yb
          endif
        enddo
      endif
      // Draw pressure curve.
      draw color=LIGHTRED
      draw at LEFTX-80,50 to LEFTX-52,50
      draw at LEFTX-50,57 text=""
      for i=0,i<zn[select],i++ do
        xb=(zz[select][i]-zref[select])*zscale+zbase
        yb=(zp[select][0]-zp[select][i])*pscale+pbase
        if i==0 then
          draw at xb,yb
        else
          draw to xb,yb
        endif
      enddo
      yb=293
      draw mode=M_LEFT font=SMALLFONT
      // Draw factors.
      if zfactlo[select]!=0.0 then
        if zfactlo[select]<senslomin || zfactlo[select]>senslomax then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 30,yb text=format("P factor LO = %.1f bits/um",zfactlo[select])
        draw text=format(", allowed %.1f .. %.1f",senslomin,senslomax)
        yb=yb+13
      endif
      if zfacthi[select]!=0.0 then
        if zfacthi[select]<senshimin || zfacthi[select]>senshimax then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 30,yb text=format("P factor HI = %.1f bits/um",zfacthi[select])
        draw text=format(", allowed %.1f .. %.1f",senshimin,senshimax)
        yb=yb+13
      endif
      // Draw minimal pressure.
      if zp[select][0]<PRESSMIN then
        draw color=LIGHTRED
      else
        draw color=BLACK
      endif
      draw at 30,yb text=format("P min = %.0f bits",zp[select][0])
      draw text=format(", allowed >%.1f",PRESSMIN)
      yb=yb+13
      // Draw pressure range.
      if zp[select][0]-zpmax[select]<rangemin then
        draw color=LIGHTRED
      else
        draw color=BLACK
      endif
      draw at 30,yb
      draw text=format("P range = %.0f bits",zp[select][0]-zpmax[select])
      draw text=format(", allowed >%.1f",rangemin)
      yb=yb+13
      // Draw Z pin distance.
      if testkelvin!=0 && kelvinscan!=1 then
        if $EXTLAY.needletype==NT_LATEST then
          draw color=BLACK
        else if zpindist[select]<ZPINMIN || zpindist[select]>ZPINMAX then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 30,yb
        draw text="Z pin dist = "
        if zpindist[select]<(-10000.0) then
          draw text="Unknown"
        else
          draw text=format("%.0f um",zpindist[select])
        endif
        if $EXTLAY.needletype!=NT_LATEST                                          \
          draw text=format(", allowed %.0f..%.0f",ZPINMIN,ZPINMAX)
        yb=yb+13
      endif
      // Draw X-Y pin distance.
      if ypindist[select]>0 then
        if xpindist[select]>XPINMAX then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 30,yb
        draw text=format("X pin dist = %.1f um, ",xpindist[select]*1000.0)
        if ypindist[select]<YPINMIN || ypindist[select]>YPINMAX then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw text=format("Y pin dist = %.1f um",ypindist[select]*1000.0)
      endif
      draw show
      redraw=0
    endif
    if Pressed(hok) break
    if Pressed(hcont) return 0
    if Pressed(hrepeat) return 1
    if Pressed(hexit) return -1
    for head=0,head<nheads,head++ do
      if Pressed(hhead[head]) then
        select=head
        redraw=1
      endif
    enddo
    wait
  enddo
savedata:
  // Calculate correction factors and save them to layout.
  if hlog!=NULL fprintf(hlog,"  Pressure correction factors:\n")
  for head=0,head<nheads,head++ do
    if c[head].ncal==0 continue
    if zfacthi[head]<senshimin/1.5 || zfacthi[head]>senshimax*1.5 then
      j=0
    else
      j=50.0*psensfact/zfacthi[head]+0.5
      if j<10 || j>255 j=0
    endif
    if hlog!=NULL then
      fprintf(hlog,                                                            \
      "  Head %i%c: dP/dZ = %5.1f bits/um, correction %4.2f (old %4.2f)\n",    \
      head/2,head & 1?'R':'L',                                                 \
      zfactlo[head],j/50.0,$uint1($EXTLAY+588+head)/50.0)
    endif
    $uint1($EXTLAY+588+head)=j
  enddo
  if calmode==MODE_VER && verifymode==VERIFY_NEEDLES then
    if Savelayout()<0 return -1
    Sendmainextention()
  else if badhead>=0 && hlog!=NULL then
    fprintf(hlog,"  Operator decided to continue calibration\n")
  endif
  return 0
end

// Measures individual resistances of the Kelvin needles. They are used mainly
// in LATEST measurements to limit power dissipation on the oxydized pads.
// Returns -1 if operator decided to quit script and 0 otherwise.
function int Needleresistance()
  int i,n,t,ntest,ngood[32],status,nbad,nhigh,nlow,nvalid,ys,vcond,pcond,err
  float x,y,r,rmin[32]
  char s[512]
  handle hinterrupt,htable,hretry,hcont,hsavepartial
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || $LAY.probetype!=1 ||            \
    boardtype!=0 || (measfeatures2 & MF2_LACONT)==0 || kelvinscan!=0           \
  then
    return 0                           // Unsupported feature
  endif
  i=Fillcalibrators(C_CENTER,FILL_MECH)// We need reference points
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 0                      // Error in parameters (impossible!)
  if hlog!=NULL fprintf(hlog,"Calibrating needle loop resistances...\n");
  ntest=20
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="Needle resistances"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now measuring the mean resistances of the needles and attached "
  draw text="wires, starting from the shortcut relay on the on-head board. "
  draw text="These resistances are used in LATEST measurements to detect "
  draw text="high-ohmical contacts that may cause damage to needle pins."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Stop test"
    help="Press to stop needle resistance measurements"
  endc
  i=Waitcancel(hinterrupt)
  if i<0 return i
  if i>0 then                          // Step skipped by user
    if hlog!=NULL                                                              \
      fprintf(hlog,"  Needle resistance calibration interrupted by operator\n");
    return 0
  endif
  for i=0,i<$LAY.nfing*2,i++ do
    ngood[i]=0
    rmin[i]=1.0e10
  enddo
  vcond=Min(v+20,80)
  pcond=Min(p+40,80)
  // Measurements begin here.
  err=0
  for n=0,n<ntest && err==0,n++ do
    change hinfo limits=n,ntest
    // Generate and send commands.
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue
      x=c[i].refx0+Random(DELTA)-Random(DELTA)
      y=c[i].refy0+Random(DELTA)-Random(DELTA)
      sprintf(s,"M %i[%.3f,%.3fV%gP%gA5] D(0x3E,%i,0,0,0,0,0,0,0)",            \
        i,x,y,vcond,pcond,i)
      SYS.Killimm(i)
      SERV.Cmdimm(i,s)
    enddo
    // Wait till answers are back.
    t=Time()
    while 1 do                         // Wait till all answers come back
      if Pressed(hexit) return -1      // Operator interrupted test
      if Pressed(hinterrupt) then
        if hlog!=NULL                                                          \
          fprintf(hlog,"  Resistance measurements interrupted by operator\n");
        return 0
      endif
      for i=0,i<$LAY.nfing*2,i++ do
        if c[i].ncal==0 continue
        if $A[i].length==0 break
      enddo
      if i>=$LAY.nfing*2 break         // All answers came
      if Time()-t>10000 then
        err=1; break                   // Timeout 10 seconds
      endif
      wait
    enddo
    if err!=0 break
    // Process answers.
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue
      if $A[i].answer==S_ERROR then
        err=2; break                   // Unsupported command?
      else if $A[i].answer!=S_DEBUG then
        err=3; break                   // Must not happen!
      else
        status=$int2($A[i]+5)
        if (status & 0x8A00)==0 then
          ngood[i]++
          r=$float4($A[i]+7)
          if (status & 0x0100) r=r*1.0e-6
          rmin[i]=Min(rmin[i],r)
        endif
      endif
    enddo
  enddo
  // Measurements finished, process results.
  n=0; nbad=0; nhigh=0; nlow=0; nvalid=0
  if err==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue
      n++
      if ngood[i]<ntest/2 then
        nbad++
      else if rmin[i]>=15.0 then
        nhigh++
      else if rmin[i]<=1.0 then
        nlow++
      else
        nvalid++
      endif
    enddo
  endif
  if err!=0 || nbad!=0 || nhigh!=0 || nlow!=0 then
    // Display error message.
    change hinfo text="Invalid needle resistances"
    change hinfo limits=0,0
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==1 then
      draw text="Timeout!"
      draw at 6,60 color=BLACK
      draw text="There is no answer from tester within 10 seconds. "
    else if err==2 then
      draw text="Tester reports error!"
      draw at 6,60 color=BLACK
      draw text="Embedded software was unable to execute measurement command "
      draw text="correctly. Most probably, the software is too old. "
    else if err==3 then
      draw text="Unexpected answer!"
      draw at 6,60 color=BLACK
      draw text="Embedded software returned unexpected answer. "
    else
      draw text="Bad or high-ohmical measurements!"
      draw at 6,60 color=BLACK
      draw text="Please decide what to do."
    endif
    draw show
    if err!=0 then
      htable=NULL
    else
      htable=control CHILD
        window=hright
        position=9,80,RIGHTX-18,170
        limits=RIGHTX-60,n*20+38
        mode=M_VSCROLL
        help="Detected problems"
        bkcolor=PINK
        size=4096
      endc
      ys=30
      draw window=htable font=INFOFONT color=DARKGRAY
      draw at 5,5 to 225,5
      draw at 5,5 to 5,32 at 14,26 text="Head"
      draw at 55,5 to 55,32 at 64,26 text="Minimal R, Ohm"
      draw at 170,5 to 170,33 at 178,26 text="Valid"
      draw at 225,5 to 225,33
      draw at 5,32 to 225,32
      draw font=FIXEDSYS mode=M_CENTERED
      for i=0,i<$LAY.nfing*2,i++ do
        if c[i].ncal==0 continue
        ys=ys+20
        draw color=DARKGRAY
        draw at 5,ys-18 to 5,ys+2 to 225,ys+2 to 225,ys-18
        draw at 55,ys-18 to 55,ys+2
        draw at 30,ys color=BLACK
        draw text=format("%i%c",i/2,(i & 1?'R':'L'))
        if rmin[i]>=15.0 || rmin[i]<=1.0 then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 112,ys text=format("%.3f",rmin[i])
        draw at 170,ys-18 to 170,ys+2
        if ngood[i]<10 then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 197,ys text=format("%i",ngood[i])
      enddo
      draw show
      setfocus htable
    endif
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY-15,120,24
      name="Retry"
      help="Press to repeat measurements"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-15,120,24
      name="Continue"
      help="Skip measurements and continue script"
    endc
    if err!=0 || nvalid==0 then
      hsavepartial=NULL
    else
      hsavepartial=control BUTTON
        window=hright
        position=RIGHTX/2-80,USERY+15,160,24
        name="Save partial results"
        help="Press to save good results to layout"
      endc
    endif
    while 1 do
      if Pressed(hexit) return -1
      if Pressed(hretry) goto repeat
      if Pressed(hcont) then
        if hlog!=NULL                                                          \
          fprintf(hlog,"  Resistance measurements interrupted by operator\n");
        return 0
      endif
      if hsavepartial!=NULL && Pressed(hsavepartial) break
      wait
    enddo
  endif
  // Save (partial) results to layout.
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue
    if ngood[i]>=10 && rmin[i]<10.0 then
      $int2($EXT0+702+2*i)=Floor(rmin[i]*1000.0+0.5)
      if hlog!=NULL then
        fprintf(hlog,"  Head %i%c: Rloop=%7.2f Ohm\n",                         \
        i/2,(i & 1?'R':'L'),rmin[i])
      endif
    else
      if hlog!=NULL then
        fprintf(hlog,                                                          \
        "  Head %i%c: bad resistance (Rloop=%7.2f Ohm, good=%i/%i)\n",         \
        i/2,(i & 1?'R':'L'),rmin[i],ngood[i],ntest)
      endif
    endif
  enddo
  return 0
end

// If tester is S1, corrects Z microstep and flashes it to the memory. Returns
// 0 on success, -1 if user interrupted calibration, 1 if user decided not to
// correct microstep and >1 on error.
function int Correctzmicrostep()
  int i,n,t,head,nheads,supported,done[32],finished,err
  float x,y
  char buf[32],s[256]
  handle hinterrupt,hcont
  if demo || (testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3) then
    return 0                           // Microstep corrections not supported
  endif
  nheads=$LAY.nfing*2
  change hinfo limits=0,0
  change hinfo text="Calibrating Z microstep"
  if hlog!=NULL fprintf(hlog,"Calibrating Z microstep...\n");
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="To assure smoth and reliable contacting, script will now "
  draw text="calibrate the microstep functions of the Z step motors. Press "
  draw font=MAINFONT text="Skip " font=TIMESFONT text="if microsteps are "
  draw text="calibrated and you have no reasons to repeat the procedure."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Skip"
    help="Press to skip microstep calibration"
  endc
  i=Waitcancel(hinterrupt)
  destroy hinterrupt
  if i<0 return i
  if i>0 then                          // Step skipped by user
    if hlog!=NULL                                                              \
      fprintf(hlog,"  Microstep calibration interrupted by operator\n");
    return 1
  endif
  err=0
  // Make 10 fast strokes to learn Z coordinate.
  for n=0,n<10 && err==0,n++ do
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      done[head]=0
      // Select coordinates of next contact. Random contacting of calibration
      // lines is acceptable. Note that tester is not yet calibrated.
      if (head & 1)==0 then            // Left head
        x=c[head].refx0+xstep*0.4+Random(xstep*0.2)
        if kelvinscan x=x+xstep
      else                             // Right head
        x=c[head].refx0-xstep*0.4-Random(xstep*0.2)
        if kelvinscan x=x-xstep
      endif
      y=$LAY.yoffset[head/2]/1000.0+ystep*0.2+Random(ystep*0.6)
      sprintf(s,"M %i(%g,%gH3V%iP%i) Z(%i)",head,x,y,v,p,head)
      if SERV.Cmdimm(head,s)==0 err=2
    enddo
    t=Time()
    while (err==0) do
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 continue
        if $A[head].length==0 break    // Some answers are still not here
      enddo
      if head>=nheads break            // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()-t>10000 break          // No answer within 10 s timeout
      wait
    enddo
  enddo
  // Activate Z microstep calibration. Attention, activation while Z axis is
  // moving leads to errors and causes lost phase due to the invalid Z
  // coordinate!
  if err==0 SERV.Cmdimm(32,"OUTPORT32 ALL 0x10010003,1")
  // Make at least 10 and at most 30 slooow Z movements with at least 3 mm real
  // hub.
  for n=0,err==0 && n<30,n++ do
    // Make hub.
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      // Select coordinates of next contact.
      if (head & 1)==0 then            // Left head
        x=c[head].refx0+xstep*0.4+Random(xstep*0.2)
        if kelvinscan x=x+xstep
      else                             // Right head
        x=c[head].refx0-xstep*0.4-Random(xstep*0.2)
        if kelvinscan x=x-xstep
      endif
      y=$LAY.yoffset[head/2]/1000.0+ystep*0.2+Random(ystep*0.6)
      sprintf(s,"M %i(%g,%gA%iH10V2P10) Z(%i)",head,x,y,acc,head)
      if SERV.Cmdimm(head,s)==0 err=2
    enddo
    t=Time()
    // Interruption of microstep calibration movement may lead to problems
    // with Z movement. Better wait.
    while (err==0 || err==1) do
      for head=0,head<nheads,head++ do
        if c[head].ncal==0 continue
        if $A[head].length==0 break    // Some answers are still not here
      enddo
      if head>=nheads break            // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()-t>10000 err=3          // No answer within 10 s timeout
      wait
    enddo
    // Check whether microsteps are corrected.
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      sprintf(s,"INPORT32 HEAD(%i),0x10010003",head)
      if SERV.Cmdimm(head,s)==0 err=2
    enddo
    t=Time()
    while (err==0) do
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 continue
        if $A[head].length==0 break    // Some answers are still not here
      enddo
      if head>=nheads break            // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()-t>3000 err=3           // No answer within 3 s timeout
      wait
    enddo
    supported=0
    finished=1
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      if $A[head].answer!=S_INPORT32 err=4
      if $uint4($A[head]+5)!=0 supported=1
      if $uint4($A[head]+5)==(-1) finished=0
      if $uint4($A[head]+5)==1 done[head]=1
    enddo
    if supported==0 err=5              // Unsupported feature
    if finished && n>=10 break         // Microstep calibrated
  enddo
  // Stop microstep calibration.
  SERV.Cmdimm(32,"OUTPORT32 ALL 0x10010003,0")
  if err!=0 then
    // Restore old flash data.
    SERV.Cmdimm(32,"OUTPORT32 ALL 0x10010004,1")
  endif
  for head=0,head<nheads,head++ do
    if c[head].ncal==0 continue
    SYS.Killimm(head)
  enddo
  if err==1 then                       // Operator interrupted adjustment
    if hlog!=NULL                                                              \
      fprintf(hlog,"  Microstep calibration interrupted by operator\n");
    return 1
  endif
  if err==5 then                       // Z microstep is not supported
    if hlog!=NULL                                                              \
      fprintf(hlog,"  Microstep calibration is not supported by software\n");
    return 1
  endif
  if err==0 then
    // Microstep is calibrated, save it to the flash memory.
    for head=0,head<nheads,head++ do
      if c[head].ncal==0 continue
      if done[head]==0 continue
      buf[0]=S_DEBUG
      buf[1]=0x27                      // Flash data
      buf[2]=head
      SYS.Sendimm(head,3,buf)
    enddo
    t=Time()
    while 1 do
      for head=0,head<nheads && err==0,head++ do
        if c[head].ncal==0 continue
        if done[head]==0 continue
        if $A[head].length==0 break    // Some answers are still not here
      enddo
      if head>=nheads break            // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()-t>5000 break           // No answer within 5 s timeout
      wait
    enddo
    for head=0,head<nheads,head++ do
      if c[head].ncal==0 continue
      if hlog!=NULL then
        if done[head]==0 then
          fprintf(hlog,"  Head %i%s: Microstep not learned\n",                 \
          head/2,head & 1?"R":"L");
        else if $uint1($A[head]+5)==0 then
          fprintf(hlog,"  Head %i%s: Microstep saved to flash\n",              \
          head/2,head & 1?"R":"L");
        else
          fprintf(hlog,"  Head %i%s: Unable to flash data\n",                  \
          head/2,head & 1?"R":"L");
        endif
      endif
    enddo
    return 0
  endif
  // Report error.
  if hlog!=NULL                                                                \
    fprintf(hlog,"  Microstep calibration was unsuccessfull (%i)\n",err);
  clear hright
  change hinfo limits=0,0
  change hinfo text="Microstep not calibrated!"
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text "Unable to calibrate Z microstep. " color=BLACK
  if err==2 then
    draw text="Some commands were rejected by tester. "
  else if err==3 then
    draw text="There was no answer from the tester within the expected "
    draw text="timeout. "
  else if err==3 then
    draw text="Script received unexpected answer from tester. "
  else
    draw text="The exact reason is unclear. "
  endif
  draw text="Microstep corrections remain unchanged."
  draw show
  while 1 do
    if Pressed(hcont) || autoconfirm break
    if Pressed(hexit) return -1
    wait
  enddo
  return err
end

// If tester is a double-sided S3, corrects Y encoder on the bottom (right)
// side of the shuttle. Returns 0 on success or if function is not supported,
// -1 if user interrupted calibration, 1 if user decided not to correct encoder
// and >1 on error.
function int Correctshuttleyencoder()
  int i,j,k,n,t,y,ymax,d,lowaccel,err
  char s[128],buf[128]
  float yenc[512],ydiff[512],yout[512],ycorr[512]
  float diffhyst[2][5],diff[5],yaccuracy
  handle hinterrupt,hcont
  if demo || testertype!=TT_S3 || testersides!=0x03 || $LAY.cameras!=0x03 ||   \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO                                    \
    return 0                           // Correction is not necessary
  err=0
  // Check that feature is supported. Indirect indication is the presence of
  // bit 0x00200000 in head camera port 0x1000021F.
  buf[0]=S_INPORT32
  buf[1]=$LAY.nfing*2+1                // Bottom camera
  $uint4(buf+2)=0x1000021F             // Query XYZ port presence
  SYS.Sendimm(0,6,buf)
  t=Time()
  while Time()-t<3000 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    if $A[0].length!=0 break
    wait
  enddo
  if $A[0].length<9 || $A[0].answer!=S_INPORT32 ||                             \
    ($uint4($A[0]+5) & 0x80200000)!=0x80200000                                 \
    return 0                           // Error or unsupported feature
  change hinfo limits=0,0
  change hinfo text="Align shuttle encoders"
  if hlog!=NULL fprintf(hlog,"Correcting shuttle Y encoder...\n");
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="S3 shuttle is driven by two independent Y motors. If readings of "
  draw text="left and right encoders differ, the motors may get very hot. "
  draw text="Y encoder alignment assures precise movements. Press "
  draw font=MAINFONT text="Skip " font=TIMESFONT text="if Y encoders are "
  draw text="aligned and you have no reasons to repeat the procedure."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Skip"
    help="Press to skip microstep calibration"
  endc
  i=Waitcancel(hinterrupt)
  if i<0 return i
  if i>0 then                          // Step skipped by user
    err=5; goto finish
  endif
  lowaccel=0
  SYS.Killimm(0)
  SYS.Killimm(1)
  // Move shuttle into the minimal allowed Y coordinate and notice the
  // readings of the right encoder. This is the maximal encoder coordinate
  // that we may use in the calibration. (In fact, delivered coordinate is
  // opposed, so this is a minimal coordinate). 1-micrometer accuracy of
  // S_INPORT32 is sufficient.
  sprintf(s,"M %i(%g,%gA10) NOP",                                               \
    $LAY.nfing*2,$LAY.xoffset/1000.0,$LAY.bottom[$LAY.nfing]/1000.0)
  SERV.Cmdimm(0,s)
  t=Time()
  while 1 do
    if $A[0].length!=0 break
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    if Time()-t>10000 then
      err=1; goto finish               // Timeout
    endif
    wait
  enddo
  if $A[0].answer!=S_READY then
    err=2; goto finish                 // Invalid answer
  endif
  buf[0]=S_INPORT32
  buf[1]=$LAY.nfing*2                  // Top camera
  $uint4(buf+2)=0x10000215             // Raw Y encoder coordinate, um
  SYS.Sendimm(0,6,buf)
  t=Time()
  while 1 do
    if $A[0].length!=0 break
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    if Time()-t>3000 then
      err=1; goto finish               // Timeout
    endif
    wait
  enddo
  if $A[0].length<9 || $A[0].answer!=S_INPORT32 ||                             \
    ($uint4($A[0]+5) & 0x80200000)!=0x80200000 then
    err=2; goto finish                 // Invalid answer
  endif
  ymax=-$int4($A[0]+5)
  y=ymax-5000                          // I add half of 10-mm correction step
  if y<=100000 then
    err=3; goto finish                 // Unexpected encoder coordinate
  endif
  n=y/10000+1                          // Number of steps
  // Permanently disable right motor.
  lowaccel=1
  sprintf(s,"OUTPORT32 HEAD(%i) 0x80000008,3",$LAY.nfing*2+1)
  SERV.Cmdimm(0,s)
  t=Time()
  while Time()-t<3000 do
    if Pressed(hexit) then
      err=-1; goto finish              // Button "Exit" works as an interrupt
    endif
    if $A[0].length!=0 break
    wait
  enddo
  if $A[0].answer!=S_OUTPORT32 then
    err=2; goto finish                 // Invalid answer
  endif
  // We have only one active motor. Reduce Y acceleration.
  Setaccel(axhead,ayhead,axcam,aycam/4.0)
  // Measure profile.
  for i=n-1,i>=0,i-- do
    change hinfo limits=n-1-i,n
    yenc[i]=y
    Initsigma(diffhyst[0])
    Initsigma(diffhyst[1])
    Initsigma(diff)
    // Two measurements with slightly different coordinates allow to remove
    // hysteresis.
    for j=0,j<2,j++ do
      // Move head into coordinate. As "M #head[]" is not yet supported
      // everywhere, I gather encoder movement command manually.
      buf[0]=S_MOVE
      buf[1]=M_ENCODER                 // Movement into encoder coordinates
      buf[2]=$LAY.nfing*2              // Top camera
      $int2(buf+3)=5000                // Height, ignored by camera
      buf[5]=0                         // Board bending, ignored by camera
      $int3(buf+6)=0                   // X coordinate: stay at zero mark
      $int3(buf+9)=-y+(j==0?1000:-1000)// Y coordinate, flipped on S3 shuttle
      $int2(buf+12)=0                  // Radius, must be zero
      buf[14]=10                       // Positioning accuracy
      buf[15]=50                       // Stroke, ignored by camera
      buf[16]=50                       // Pressure, ignored by camera
      buf[17]=M_NOP                    // Plain movement into the point
      SYS.Sendimm(0,18,buf)
      // Wait till command is executed.
      t=Time()
      while 1 do
        if $A[0].length!=0 break
        if Pressed(hexit) then
          err=-1; goto finish
        else if Pressed(hinterrupt) then
          err=5; goto finish
        endif
        if Time()-t>10000 then
          err=1; goto finish           // Timeout
        endif
        wait
      enddo
      // Measure difference between the left and right shuttle coordinates. For
      // statistics, I do it several times.
      for k=0,k<8,k++ do
        // Short pause.
        t=Time()
        while 1 do
          if Pressed(hexit) then
            err=-1; goto finish
          else if Pressed(hinterrupt) then
            err=5; goto finish
          endif
          if Time()-t>=(k==0?250:20) break
        enddo
        sprintf(s,"INPORT32 HEAD(%i) 0x10000219",$LAY.nfing*2+0)
        SERV.Cmdimm(0,s)
        sprintf(s,"INPORT32 HEAD(%i) 0x10000219",$LAY.nfing*2+1)
        SERV.Cmdimm(1,s)
        t=Time()
        while 1 do
          if $A[0].length!=0 && $A[1].length!=0 break
          if Pressed(hexit) then
            err=-1; goto finish
          endif
          if Time()-t>10000 then
            err=1; goto finish         // Timeout
          endif
        enddo
        if $A[0].answer!=S_INPORT32 || $A[1].answer!=S_INPORT32 then
          err=2; goto finish           // Invalid answer
        endif
        d=$int4($A[1]+5)-$int4($A[0]+5)
        if Abs(d)>250 then
          err=4; goto finish           // High difference
        endif
        Addsigma(diffhyst[j],d)        // Only for statistics
        Addsigma(diff,d)
      enddo
    enddo
    if hlog!=NULL then
      fprintf(hlog,"  Yenc = %8.3f mm  diff = %6.1f um  (%6.1f, %6.1f)\n",     \
      y/1000.0,Getmean(diff),Getmean(diffhyst[0]),Getmean(diffhyst[1]));
    endif
    ydiff[i]=Getmean(diff)
    y=y-10000
  enddo
  // Measurements finished. Interpolate profile with a spline and determine
  // corrections at points 0, -10000, -20000, ... micrometers of Y encoder
  // coordinate.
  yaccuracy=1.0                        // 1 um fitting accuracy
  for i=0,i<512,i++ do
    y=i*10000.0
    if y>ymax break
    yout[i]=y
  enddo
  SYS.Splinefit(n,yenc,ydiff,&yaccuracy,i,yout,ycorr)
  while i<512 do
    ycorr[i]=ycorr[i-1]
    i++
  enddo
  // Flash data to the controller of the bottom camera (right Y shuttle
  // encoder).
  change hinfo limits=0,0
  change hinfo text="Flashing Y corrections..."
  for i=0,i<512,i++ do
    buf[0]=S_DEBUG
    buf[1]=0x26                        // Set individual movement parameter
    buf[2]=$LAY.nfing*2+1
    $uint2(buf+3)=65+i                 // Y encoder corrections
    $float4(buf+5)=ycorr[i]
    SYS.Sendimm(32,9,buf)
  enddo
  buf[0]=S_DEBUG
  buf[1]=0x26
  buf[2]=$LAY.nfing*2+1
  $uint2(buf+3)=64                     // Validity of Y encoder corrections
  $float4(buf+5)=1
  SYS.Sendimm(32,9,buf)
  buf[0]=S_DEBUG
  buf[1]=0x27                          // Flash data
  buf[2]=$LAY.nfing*2+1
  SYS.Sendimm(0,3,buf)
  t=Time()
  while 1 do
    if $A[0].length!=0 break
    if Pressed(hexit) then
      err=-1; goto finish
    endif
    if Time()-t>3000 then
      err=1; goto finish               // Timeout
    endif
    wait
  enddo
  if $A[0].answer!=S_DEBUG || $A[0].length<6 || $char($A[0]+5)!=0 then
    err=6; goto finish                 // Data not flashed
  endif
finish:
  // If necessary, enable right Y motor and restore accelerations.
  if lowaccel then
    sprintf(s,"OUTPORT32 HEAD(%i) 0x80000008,0",$LAY.nfing*2+1)
    SERV.Cmdimm(21,s)
    Setaccel(axhead,ayhead,axcam,aycam)
  endif
  if err<=0 return err                 // Report success or operator interrupt
  if err==5 then
    if hlog!=NULL                                                              \
      fprintf(hlog,"  Shuttle Y encoder correction interrupted by operator\n");
    return 1                           // Cancelled by operator
  endif
  // Report error.
  if hlog!=NULL                                                                \
    fprintf(hlog,"  Shuttle Y encoder correction was unsuccessfull (%i)\n",err);
  clear hright
  change hinfo limits=0,0
  change hinfo text="Y encoder not corrected!"
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text "Unable to align Y shuttle encoders. " color=BLACK
  if err==1 then
    draw text="There was no answer from the tester within the expected "
    draw text="timeout. "
  else if err==2 then
    draw text="Script received unexpected answer from tester. "
  else if err==3 then
    draw text="Tester returned unexpected Y encoder coordinate. "
  else if err==4 then
    draw text="Coordinate difference between encoders is unrealistically high. "
  else if err==5 then
    draw text="Step was cancelled by the operator. "
  else if err==5 then
    draw text="Ct=rate was unable to flash data. "
  else
    draw text="The exact reason is unclear. "
  endif
  draw text="Encoder corrections remain unchanged."
  draw show
  while 1 do
    if Pressed(hcont) break
    if Pressed(hexit) return -1
    wait
  enddo
  return 2
end

// If embedded software supports soft landing, ask user to correct pressures.
// This is necessary because splinogramms are too different mechanically.
// Returns 0 on success, -1 if user interrupted calibration, 1 if user decided
// not to correct pressures and >1 on error.
function int Adjustsoftlanding()
  int i,t,tlast,head,nheads,headx,heady,vlocal,plocal,err
  int status[32],tstart[32],ncont[32],mincont,maxcont
  float x,y,dy,oldp[32],newp[32]
  char buf[32],s[256]
  handle hview,hcont,hinterrupt
  if demo || (testertype!=TT_A5 && testertype!=TT_A5L &&                       \
    testertype!=TT_A6 && testertype!=TT_A7 && testertype!=TT_A8) ||            \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP) then
    return 0                           // Soft landing is not supported
  endif
  nheads=$LAY.nfing*2
  // Verify that embedded software supports individual pressures. There is no
  // direct way to query this feature, so I try to activate soft landing in
  // the crate.
  buf[0]=S_OUTPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10010001             // Soft landing
  $uint4(buf+6)=1                      // Activate soft landing
  SYS.Sendimm(32,10,buf)
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10010001             // Query soft landing
  SYS.Sendimm(0,6,buf)
  t=Time(); err=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    if Time()-t>3000 err=3             // Timeout
    wait
  enddo
  if err==0 && $A[0].answer!=S_INPORT32 err=2
  if err!=0 goto reporterror
  if $uint4($A[0]+5)==0 return 0       // Soft landing is not supported
  // Now try to activate automatical corrections in head controllers.
  for head=0,head<nheads,head++ do
    if c[head].ncal==0 continue
    buf[0]=S_OUTPORT32
    buf[1]=head
    $uint4(buf+2)=0x10010001           // Automatical Z pressure correction
    $uint4(buf+6)=1                    // Activate correction
    SYS.Sendimm(head,10,buf)
  enddo
  t=Time()
  while err==0 do
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      if $A[head].length==0 break      // Some answer is not yet here
      if $A[head].answer!=S_OUTPORT32 err=2
    enddo
    if head>=nheads break              // All answers came
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    if Time()-t>3000 err=3             // Timeout
    wait
  enddo
  // Now check that automatical correction is active. If not, this feature is
  // not supported and will be silently ignored.
  for head=0,head<nheads && err==0,head++ do
    if c[head].ncal==0 continue
    buf[0]=S_INPORT32
    buf[1]=head
    $uint4(buf+2)=0x10010001           // Automatical Z pressure correction
    SYS.Sendimm(head,6,buf)
  enddo
  t=Time()
  while err==0 do
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      if $A[head].length==0 break      // Some answer is not yet here
      if $A[head].answer!=S_INPORT32 err=2
    enddo
    if head>=nheads break              // All answers came
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    if Time()-t>3000 err=3             // Timeout
    wait
  enddo
  for head=0,head<nheads && err==0,head++ do
    if c[head].ncal==0 continue
    if $uint4($A[head]+5)==0 return 0  // Feature is not supported, ignore
    oldp[head]=$EXTLAY.pfactor[head]
    if oldp[head]>=32768.0 oldp[head]=oldp[head]-65536.0
    newp[head]=oldp[head]
  enddo
  if err!=0 goto reporterror
  change hinfo limits=0,0
  change hinfo text="Calibrating pressure"
  if hlog!=NULL fprintf(hlog,"Calibrating pressure for soft landing...\n");
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Your tester is equipped with splinogramms that support soft "
  draw text="landing mode. This mode is slower than normal contacting but "
  draw text="reduces marks on the PCB. Script will now adjust the pressure in "
  draw text="soft landing mode for each splinogramm. Press " font=MAINFONT
  draw text="Skip " font=TIMESFONT text="if you don't use soft landing."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Skip"
    help="Press to skip pressure adjustment"
  endc
  hview=control GRAPH                  // Create pressure correction viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BLACK
    bkcolor=WHITE
  endc
  // It makes no sense to adjust soft landing with too high parameters. The
  // sense of this mode is to leave no printouts.
  if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP &&                        \
    (testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3)              \
  then
    vlocal=Min(20,v)
    plocal=Min(20,p)
  else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHPS then
    vlocal=Min(20,v)
    plocal=Min(20,p)
  else
    vlocal=Min(30,v)
    plocal=Min(50,p)
  endif
  // Start adjustment. To assure good quality of regulation, I make 100
  // contacts with each finger.
  maxcont=100
  for i=0,i<32,i++ do
    status[i]=0                        // 0:idle, 1:move, 2:contact, 3:get new
    ncont[i]=0
  enddo
  tlast=0
  while err==0 do
    mincont=maxcont
    t=Time()
    if t>tlast then
      // Display actual corrections.
      draw window=hview bkcolor=WHITE clear
      draw at LEFTX/2,40 color=BLACK mode=M_CENTERED font=MEDIUMFONT
      draw text="Individual pressure corrections"
      draw font=INFOFONT color=DARKGRAY
      heady=70
      for i=0,i<2,i++ do
        headx=(i==0?22:LEFTX/2+15)
        draw mode=M_LEFT at headx,heady text="Head"
        draw mode=M_RIGHT at headx+65,heady text="Old"
        draw at headx+115,heady text="Actual"
      enddo
      draw font=TIMESFONT
      for head=0,head<nheads && err==0,head++ do
        draw color=BLACK mode=M_LEFT
        headx=((head & 1)==0?22:LEFTX/2+15)
        heady=95+(head/2)*20
        if $LAY.side[head/2]!=0 heady=heady+7
        draw at headx+3,heady text=format("%i%c",head/2,(head & 1?'R':'L'))
        draw mode=M_RIGHT at headx+65,heady text=format("%i",oldp[head])
        if c[head].ncal==0 continue
        draw color=(newp[head]<(-800) || newp[head]>800?LIGHTRED:BLACK)
        draw at headx+115,heady text=format("%i",newp[head])
      enddo
      draw mode=M_LEFT show
      tlast=t+1000
    endif
    for head=0,head<nheads && err==0,head++ do
      if c[head].ncal==0 continue
      mincont=Min(mincont,ncont[head])
      if ncont[head]>=maxcont continue // Finger has finished adjustment
      if status[head]==0 then          // Head is idle, send new task
        // Select coordinates of next contact. Random contacting of calibration
        // lines is acceptable. Note that tester is not yet calibrated.
        if (head & 1)==0 then          // Left head
          x=c[head].refx0+xstep*0.4+Random(xstep*0.2)
          if kelvinscan x=x+xstep
        else                           // Right head
          x=c[head].refx0-xstep*0.4-Random(xstep*0.2)
          if kelvinscan x=x-xstep
        endif
        if testertype==TT_A5L && smallboard!=0 then
          dy=($LAY.top[head/2]-$LAY.bottom[head/2])/1000.0-70.0
          y=$LAY.bottom[head/2]/1000.0+35.0+Random(dy)
        else if testertype==TT_A7 && smallboard!=0 && boardtype!=1 then
          dy=($LAY.top[head/2]-$LAY.bottom[head/2])/1000.0-70.0
          y=$LAY.bottom[head/2]/1000.0+35.0+Random(dy)
        else if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
          y=$LAY.yoffset[head/2]/1000.0-60.0+Random(120.0)
        else
          dy=($LAY.top[head/2]-$LAY.bottom[head/2])/1000.0-20.0
          y=$LAY.bottom[head/2]/1000.0+10.0+Random(dy)
        endif
        sprintf(s,"M %i(%g,%gA15H10V%iP%i) Z(%i)",head,x,y,vlocal,plocal,head)
        if SERV.Cmdimm(head,s)==0 err=2
        tstart[head]=t
        status[head]=1
      else if status[head]==1 then     // Head is moving, wait for answer
        if t-tstart[head]>10000 err=3
        if $A[head].length==0 continue
        if $A[head].answer!=S_INPORT err=2
        tstart[head]=t
        status[head]=2
      else if status[head]==2 then     // Head contacts board, wait 100 ms
        if t-tstart[head]<100 continue
        ncont[head]++
        buf[0]=S_INPORT32              // Get actual pressure correction
        buf[1]=head
        $uint4(buf+2)=0x10010000       // Z pressure correction
        SYS.Sendimm(head,6,buf)
        tstart[head]=t
        status[head]=3
      else                             // Wait for actual pressure correction
        if t-tstart[head]>10000 err=3
        if $A[head].length==0 continue
        if $A[head].answer!=S_INPORT32 err=2
        newp[head]=newp[head]*0.85+$uint4($A[head]+5)*0.15
        status[head]=0
      endif
    enddo
    change hinfo limits=mincont,maxcont
    if mincont==maxcont break          // All fingers are adjusted
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    if Pressed(hinterrupt) err=1       // Operator interrupted adjustment
    wait
  enddo
  destroy hview
  if err!=0 goto reporterror
  // Now disable learning and save corrections to extended layout.
  for head=0,head<nheads,head++ do
    if c[head].ncal==0 continue
    buf[0]=S_OUTPORT32
    buf[1]=head
    $uint4(buf+2)=0x10010001           // Automatical Z pressure correction
    $uint4(buf+6)=0                    // Deactivate correction
    SYS.Sendimm(32,10,buf)
  enddo
  for head=0,head<nheads && err==0,head++ do
    if c[head].ncal==0 continue
    if newp[head]>700 then
      if hlog!=NULL then
        fprintf(hlog,                                                          \
        "  %i%c: old pressure correction %5i, new %5i - NOT UPDATED\n",        \
        head/2,(head & 1?'R':'L'),oldp[head],newp[head])
      endif
      continue
    endif
    if hlog!=NULL then
      fprintf(hlog,"  %i%c: old pressure correction %5i, new %5i\n",           \
      head/2,(head & 1?'R':'L'),oldp[head],newp[head])
    endif
    $EXTLAY.pfactor[head]=newp[head]
  enddo
  return 0                             // Pressure adjustment finished
reporterror:
  if hlog!=NULL then
    if err==1 then
      fprintf(hlog,"  Pressure calibration interrupted by operator\n");
    else
      fprintf(hlog,"  Pressure calibration was unsuccessfull (%i)\n",err);
    endif
  endif
  for head=0,head<nheads,head++ do
    if c[head].ncal==0 continue
    SYS.Killimm(head)
  enddo
  if err==1 return 1                   // Operator interrupted adjustment
  clear hright
  change hinfo limits=0,0
  change hinfo text="Pressure not calibrated!"
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text "Unable to calibrate splinogramms. " color=BLACK
  if err==2 then
    draw text="Some commands were rejected by tester. "
  else if err==3 then
    draw text="There was no answer from the tester within the expected "
    draw text="timeout. "
  else
    draw text="The exact reason is unclear. "
  endif
  draw text="Pressure corrections in extended layout remain unchanged."
  draw show
  while 1 do
    if Pressed(hcont) || autoconfirm break
    if Pressed(hexit) return -1
    wait
  enddo
  return err
end

// Activates (soft=1) or deactivates (soft=0) soft landing.
function int Activatesoftlanding(int soft)
  int t
  char buf[32]
  if demo || (testertype!=TT_A5 && testertype!=TT_A5L &&                       \
    testertype!=TT_A6 && testertype!=TT_S1 && testertype!=TT_S2 &&             \
    testertype!=TT_S3 && testertype!=TT_A7 && testertype!=TT_A8) ||            \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP) then
    return                             // Soft landing is not supported
  endif
  SYS.Killimm(32)
  buf[0]=S_OUTPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10010001             // Soft landing
  $uint4(buf+6)=(soft!=0)              // Activate soft landing
  SYS.Sendimm(32,10,buf)
  t=Time()
  while $A[32].length==0 do
    if Time()-t>3000 break             // Timeout
    wait
  enddo
end

// Returns -1 if operator interrupted the calibration, 0 on success, 1 if
// there is an error in calibration data, 2 if interrupt button pressed.
function int Scanoffsets(int mode)
  int i,n,imax,y,err,nerr
  float maxdx,maxdy,width,d,dmax
  handle hinterrupt
  handle htable,hretry,hreplace,hcont
  i=Fillcalibrators(C_CENTER,FILL_MECH)// Prepare for calibration of centers
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible!)
  change hinfo limits=0,0
  change hinfo text="Scanning centers"
  if hlog!=NULL fprintf(hlog,"Scanning head centers...\n");
  Drawcalboard(0,0,0,mode==0?DR_HEAD|DR_VIDEO:DR_HEAD)
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text=" "
  draw text=" "
  if mode==0 then
    draw text=""
    draw text=" "
  else
    draw text="Rail waveness will be tested in the vicinity of central "
    draw text="crosses. "
  endif
  draw text=""
  draw text="" font=MAINFONT text="" font=TIMESFONT
  draw text=""
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  i=Runelectroscan(NULL,hinterrupt,NULL,NULL,0.0)
  if i!=0 return i
  // Check whether all offsets measured and lay within sound limits.
  err=0; nerr=0; maxdx=0.0; maxdy=0.0
  n=0
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    if c[i].err[0]!=0 then
      nerr++
    else
      maxdx=Max(maxdx,Abs(c[i].xm[0]-c[i].xa[0]))
      maxdy=Max(maxdy,Abs(c[i].ym[0]-c[i].ya[0]))
    endif
    n++
  enddo
  if maxdx>xstep/2.5 err=2
  if maxdy>ystep/2.5 err=2
  if maxdx>xstep/4.0 err=1
  if maxdy>ystep/4.0 err=1
  if (nerr==0 && err==0) goto checkwidth
  // Warn about bad board placement and ask what to do next.
  change hinfo limits=0,0
  change hinfo text="Scanning problem"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if nerr!=0 then
    if hlog!=NULL fprintf(hlog,"ERROR: Some centers are not found\n");
    draw text="Some centers are not found. " color=BLACK
    if mode==0 then
      draw text="This makes further calibration unreliable. "
    else
      draw text="Waveness measurements are not possible. "
    endif
  else if err==1 then
    if hlog!=NULL fprintf(hlog,"ERROR: Some centers have high offsets\n");
    draw text="High offsets of central crosses. "
  else
    if hlog!=NULL fprintf(hlog,"ERROR: Some centers have high offsets\n");
    draw text="Very high offsets of central crosses. "
    draw color=BLACK text="It is possible that some neighbouring cross was "
    draw text="found instead of center. "
  endif
  draw color=BLACK
  draw text="Please consult the table below and decide what to do next."
  draw show
  htable=control CHILD
    window=hright
    position=29,110,RIGHTX-58,160
    limits=RIGHTX-78,n*20+38
    mode=M_VSCROLL
    help="Measured offsets of central points"
    bkcolor=PINK
    size=4096
  endc
  y=30
  draw window=htable font=INFOFONT color=DARKGRAY
  draw at 5,5 to 185,5
  draw at 5,5 to 5,32 at 9,26 text="Head"
  draw at 45,5 to 45,32 at 59,26 text="dX,mm"
  draw at 115,5 to 115,32 at 130,26 text="dY,mm"
  draw at 185,5 to 185,33
  draw at 5,32 to 185,32
  draw font=FIXEDSYS mode=M_CENTERED
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    y=y+20
    draw color=DARKGRAY
    draw at 5,y-18 to 5,y+2 to 185,y+2 to 185,y-18
    draw at 45,y-18 to 45,y+2
    draw at 115,y-18 to 115,y+2
    draw at 25,y color=BLACK text=format("%i%c",i/2,(i & 1)==0?'L':'R')
    draw at 80,y
    if c[i].err[0]!=0 then             // No dX information
      draw color=LIGHTRED text="-"
    else
      draw color=(Abs(c[i].xm[0]-c[i].xa[0])<=xstep/4.0?BLACK:LIGHTRED)
      draw text=format("%.3f",c[i].xm[0]-c[i].xa[0])
    endif
    draw at 150,y
    if c[i].err[0]!=0 then             // No dY information
      draw color=LIGHTRED text="-"
    else
      draw color=(Abs(c[i].ym[0]-c[i].ya[0])<=ystep/4.0?BLACK:LIGHTRED)
      draw text=format("%.3f",c[i].ym[0]-c[i].ya[0])
    endif
  enddo
  draw show
  setfocus htable
  if nerr==0 && err==1 then            // Replace or continue
    hretry=NULL
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
  else if nerr==0 && err==2 then       // Replace
    hretry=NULL
    hreplace=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hcont=NULL
  else                                 // Retry or replace
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Retry"
      help="Press to retry scanning of central crosses once more"
    endc
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hcont=NULL
  endif
  while 1 do
    if hretry!=NULL then
      if Pressed(hretry) return 3
    endif
    if hreplace!=NULL then
      if Pressed(hreplace) return 2
    endif
    if hcont!=NULL && (Pressed(hcont) || autoconfirm) then
      Logcontinue()
      break
    endif
    if Pressed(hexit) return -1
    wait
  enddo
  // Check that width of the lines on the calibration board coincides with
  // expected. Unreliable and shall be skipped in the case of Kelvin needles.
checkwidth:
  if $LAY.probetype!=0 || kelvinscan==1 return 0
  // Calculate mean widths.
  n=0
  width=0.0
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    if Getcount(c[i].wstatx)==0 || Getcount(c[i].wstaty)==0 continue
    width=width+Getmean(c[i].wstatx)+Getmean(c[i].wstaty)
    n++
  enddo
  if n==0 return 0                     // Impossible!
  width=width/(2.0*n)
  // Remove head with the maximal deviation exceeding 25% from statistics.
  imax=-1
  dmax=0.0
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue
    if Getcount(c[i].wstatx)==0 || Getcount(c[i].wstaty)==0 continue
    d=Abs(Getmean(c[i].wstatx)-width)
    if d>dmax then
      dmax=d; imax=i
    endif
    d=Abs(Getmean(c[i].wstaty)-width)
    if d>dmax then
      dmax=d; imax=i
    endif
  enddo
  if n>2 && dmax>width/4.0 then
    n=0
    width=0.0
    for i=0,i<$LAY.nfing*2,i++ do
      if i==imax || c[i].ncal==0 continue
      if Getcount(c[i].wstatx)==0 || Getcount(c[i].wstaty)==0 continue
      width=width+Getmean(c[i].wstatx)+Getmean(c[i].wstaty)
      n++
    enddo
    width=width/(2.0*n)
  else
    imax=-1
  endif
  // Earlier I have asked the operator if measured line width was too unsure.
  // Now I simply set width to the nearest 50-um interval. Currently lines on
  // the calibration boards are either 200 or 300 micrometers wide.
  if boardtype==0 then
    width=width-0.025                  // High lines on FR4 board
  endif
  if ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP then
    width=width-0.025
  endif
  if width>=linewidth-0.060 && width<=linewidth+0.060 then
    return 0                           // All correct
  endif
  if width<0.225 then
    linewidth=0.200
  else if width<0.275 then
    linewidth=0.250
  else
    linewidth=0.300
  endif
  if hlog!=NULL then
    fprintf(hlog,"Line width is changed to %.3f mm\n",linewidth);
  endif
  return 0
end

// Checks if offset of the calibration board on the second step of the two-step
// calibration is low. Returns -1 if operator interrupted the calibration, 0 on
// success, 2 on request to replace board and 3 on retry.
function int Checkoffsets()
  int i,n,y,err
  float meandx,meandy
  handle hinterrupt
  handle htable,hretry,hreplace,hcont
  i=Fillcalibrators(C_CENTER,FILL_MECH)// Prepare for calibration of centers
  if i<0 return -1                     // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible!)
  change hinfo limits=0,0
  change hinfo text="Verifying centers"
  if hlog!=NULL fprintf(hlog,"Verifying head centers on step 2...\n");
  Drawcalboard(0,0,0,DR_HEAD)
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now checking the positions of the central points on the "
  draw text="calibration board. They must be close to their positions "
  draw text="on the first step."
  draw text="If something goes bad or you want to change board placement, "
  draw text="doubleclick button " font=MAINFONT text="Interrupt" font=TIMESFONT
  draw text=" below."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  i=Runelectroscan(NULL,hinterrupt,NULL,NULL,0.0)
  if i<0 return -1
  if i>0 return 0
  // Check whether all offsets measured and lay within sound limits.
  err=0; meandx=0.0; meandy=0.0; n=0
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    if c[i].err[0]==0 then
      meandx=meandx+(c[i].xm[0]-c[i].xa[0])
      meandy=meandy+(c[i].ym[0]-c[i].ya[0])
      n++
    endif
  enddo
  if n>0 then
    meandx=meandx/n
    meandy=meandy/n
  endif
  if Abs(meandx)>0.7 err=1
  if Abs(meandy)>0.5 err=1
  if Abs(meandx)>1.5 err=2
  if Abs(meandy)>1.0 err=2
  if n==0 err=2
  if err==0 return 0
  // Warn about bad board placement and ask what to do next.
  if hlog!=NULL fprintf(hlog,"ERROR: Some centers have high offsets\n");
  Drawcalboard(-meandx,(Abs(meandy)<0.3?0.0:-meandy),0,0)
  change hinfo limits=0,0
  change hinfo text="Placement problem"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if n==0 then
    draw text="Can't scan layout centers. "
  else
    draw text="High shift of the calibration board. "
  endif
  draw color=BLACK text="This may reduce the accuracy of the calibration. "
  draw text="Please consult the table below and decide what to do next."
  draw show
  htable=control CHILD
    window=hright
    position=29,110,RIGHTX-58,160
    limits=RIGHTX-20,n*20+38
    mode=M_VSCROLL
    help="Measured offsets of central points"
    bkcolor=PINK
    size=4096
  endc
  y=30
  draw window=htable font=INFOFONT color=DARKGRAY
  draw at 5,5 to 185,5
  draw at 5,5 to 5,32 at 9,26 text="Head"
  draw at 45,5 to 45,32 at 59,26 text="dX,mm"
  draw at 115,5 to 115,32 at 130,26 text="dY,mm"
  draw at 185,5 to 185,33
  draw at 5,32 to 185,32
  draw font=FIXEDSYS
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    y=y+20
    draw color=DARKGRAY
    draw at 5,y-18 to 5,y+2 to 185,y+2 to 185,y-18
    draw at 45,y-18 to 45,y+2
    draw at 115,y-18 to 115,y+2
    draw at 12,y color=BLACK text=format("%2i%c",i/2,(i & 1)==0?'L':'R')
    draw at 57,y
    if c[i].err[0]!=0 then             // No dX information
      draw color=LIGHTRED text="   -"
    else
      draw color=(Abs(c[i].xm[0]-c[i].xa[0])<=0.7?BLACK:LIGHTRED)
      draw text=format("%6.3f",c[i].xm[0]-c[i].xa[0])
    endif
    draw at 126,y
    if c[i].err[0]!=0 then             // No dY information
      draw color=LIGHTRED text="   -"
    else
      draw color=(Abs(c[i].ym[0]-c[i].ya[0])<=0.5?BLACK:LIGHTRED)
      draw text=format("%6.3f",c[i].ym[0]-c[i].ya[0])
    endif
  enddo
  draw show
  setfocus htable
  if n==0 then                         // Retry or replace
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Retry"
      help="Press to retry scanning of central crosses once more"
    endc
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hcont=NULL
  else if err==1 then                  // Replace or continue
    hretry=NULL
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
  else                                 // Replace
    hretry=NULL
    hreplace=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hcont=NULL
  endif
  while 1 do
    if hretry!=NULL then
      if Pressed(hretry) return 3
    endif
    if hreplace!=NULL then
      if Pressed(hreplace) return 2
    endif
    if hcont!=NULL && (Pressed(hcont) || (autoconfirm && err!=2)) then
      Logcontinue()
      return 0
    endif
    if Pressed(hexit) return -1
    wait
  enddo
end

// Overcomes bug in OllyDbg where several fiducials with almost the same
// correlation are reported within tenth of pixel from the main maximum.
function int Correctfound(float *found,int nfound)
  int i
  if nfound>NFID nfound=NFID
  while nfound>1 do
    if Abs(found[3]-found[0])<1.0 && Abs(found[4]-found[1])<1.0 then
      for i=6,i<nfound*3,i++ do
        found[i-3]=found[i]
      enddo
      nfound--
    else
      break
    endif
  enddo
  return nfound
end

// Asks operator to adjust the offset between the top and bottom dedicated
// cameras in shinethrough mode.  Returns -1 if operator interrupted the
// calibration and 0 on success. Doesn't support head cameras.
function int Manualoppdist()
  int i,k,nfing,move,newview
  float oldoppdist
  char s[256]
  handle hview,hlivevideo
  handle hoffset,hl,hr,htop,hbottom,hdone
  if illumination==0 || (boardtype!=1 && boardtype!=2) || cameras!=0x3 then
    return 0                           // Adjustment is not necessary/possible
  endif
  nfing=$LAY.nfing
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  Bccreate(hview,-1,-1,0,1,0)
  change hinfo limits=0,0
  change hinfo text="Adjust illumination offset"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Shinethrough calibration uses opposite camera to illuminate "
  draw text="fiducials. Please adjust the distance between the top and "
  draw text="bottom camera so that the background is homogeneous, without "
  draw text="dark shadows. Use keys " font=MAINFONT text="L " font=TIMESFONT
  draw text="and " font=MAINFONT text="R " font=TIMESFONT text="to move "
  draw text="camera, " font=MAINFONT text="Top " font=TIMESFONT text="and "
  draw font=MAINFONT text="Bottom " font=TIMESFONT text="to select camera. "
  draw text="Press " font=MAINFONT text="Done " font=TIMESFONT
  draw text="when ready."
  draw font=INFOFONT mode=M_RIGHT at RIGHTX/2-28,180 text="Actual offset:"
  draw mode=M_LEFT at RIGHTX/2+28,180 text="mm"
  draw show
  hoffset=control TEXT
    window=hright
    position=RIGHTX/2-25,160,50,22
    help="Actual offset, millimeters"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
  endc
  hl=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY-80,40,40
    name="L"
    help="Press and hold to move selected camera to the left"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hr=control BUTTON
    window=hright
    position=RIGHTX/2+20,USERY-80,40,40
    name="R"
    help="Press and hold to move selected camera to the right"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  htop=control BUTTON
    window=hright
    position=5,USERY+10,RIGHTX/3-5,24
    name="Top"
    help="Press to select top video camera"
  endc
  hbottom=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY+10,RIGHTX/3-5,24
    name="Bottom"
    help="Press to select bottom video camera"
  endc
  hdone=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY+10,RIGHTX/3-9,24
    name="Done"
    help="Press to accept corrections"
  endc
  i=0                                  // Selected camera
  move=1; newview=1
  oldoppdist=oppdx
  while 1 do
    if Pressed(hexit) then
      return -1                        // Operator interrupted calibration
    else if Bcupdate(1)!=0 then
      newview=1
    else if Pressed(hdone) then
      if oppdx!=oldoppdist then
        setini("Calibration","Video","%i,%i,%f,%i",                            \
          cameramode,illumination,oppdx,noclip)
        if hlog!=NULL then
          fprintf(hlog,"Offset of the opposite camera is set to %.1f mm\n",    \
          oppdx)
        endif
      endif
      return 0
    else if Pressed(htop) then
      i=0; move=1; newview=1
    else if Pressed(hbottom) then
      i=1; move=1; newview=1
    else if Pressed(hl) then
      oppdx=Min(25.0,Max(0.0,oppdx-0.5)); move=1
    else if Pressed(hr) then
      oppdx=Min(25.0,Max(0.0,oppdx+0.5)); move=1
    endif
    if move then
      change hoffset text=format("%.1f",oppdx)
      sprintf(s,"M %i(%f,%fA255) %i(%f,%fA255) NOP",                           \
        nfing*2+i,$LAY.xoffset/1000.0+videocorrectx[i],                        \
        $LAY.yoffset[nfing]/1000.0+videocorrecty[i],                           \
        nfing*2+1-i,$LAY.xoffset/1000.0-oppdx+videocorrectx[1-i],              \
        $LAY.yoffset[nfing]/1000.0+videocorrecty[1-i])
      SERV.Cmdimm(32,s)
      move=0
    endif
    if newview then
      Bcsetcam(i,1)
      SYS.Videoangle(hlivevideo,i,0,Getzoom(i),                                \
        Bcgetbri(i,1),Bcgetctr(i,1),longexp?6:2,0)
      newview=0
    endif
    sprintf(s,"OUTPORT %i,0",0x2004+i )
    SERV.Cmdimm(32,s)
    sprintf(s,"OUTPORT %i,1",0x2004+1-i )
    SERV.Cmdimm(32,s)
    wait
  enddo
end

// If mode is 0, asks operator to adjust brightness and contrast of dedicated
// cameras. If mode is 1, corrects offsets of central points for video cameras
// in manual mode. Returns -1 if operator interrupted the calibration and 0 on
// success.
function int Manualcenters(int mode)
  int i,k,n,x,y,move,nfing,newview,result,dummy
  char s[256]
  float vcx[2],vcy[2],crossx,crossy
  handle hview,hlivevideo
  handle htop,hbottom,hu,hd,hl,hr,hdone
  if cameras==0 return 0               // Works only with dedicated cameras
  nfing=$LAY.nfing
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  Bccreate(hview,-1,-1,(cameras==0x02?1:0),1,1)
  change hinfo limits=0,0
  if mode==0 then
    change hinfo text="Set brightness and contrast"
    if hlog!=NULL fprintf(hlog,"Setting brightness and contrast...\n")
  else
    change hinfo text="Manual correction"
    if hlog!=NULL fprintf(hlog,"Searching for video centers manually...\n")
  endif
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  if testertype==TT_S3 && mode==0 && boardtype==1 then
    draw at 6,20 color=BLACK
  else
    draw at 6,30 color=BLACK
  endif
  if mode==0 then
    draw text="Please adjust brightness and contrast so that fiducials are "
    draw text="clearly visible. "
  else
    draw text="Please find position of central "
    if boardtype==2 then
      draw text="fiducuials "
    else
      draw text="crosses "
    endif
    draw text="on the calibration board. "
  endif
  draw text="Use cursor keys to move camera"
  if cameras==0x03 then
    draw text=", " font=MAINFONT text="Top " font=TIMESFONT text="and "
    draw font=MAINFONT text="Bottom " font=TIMESFONT text="to select camera"
  endif
  draw text=". Press " font=MAINFONT text="Done " font=TIMESFONT
  if mode==0 then
    draw text="to continue."
  else
    draw text="to accept corrections."
  endif
  if testertype==TT_S3 && mode==0 && boardtype==1 then
    draw wrap=RIGHTX/2+50
    draw text="\n\nNote: Fiducial on the upper side of the calibration "
    draw text="board has following shape:"
    x=RIGHTX/2+80
    y=110
    draw color=BLACK bkcolor=BLACK
    if headcamfidtype==1 then
      draw at x-33,y-3 fillrect x+34,y+4
      draw at x-3,y-33 fillrect x+4,y+34
      draw at x+7,y+7 fillrect x+17,y+17
      draw at x-16,y-16 fillrect x-6,y-6
    else if headcamfidtype==2 then
      draw at x-33,y-3 fillrect x+34,y+4
      draw at x-3,y-33 fillrect x+4,y+34
      draw at x+7,y-16 fillrect x+17,y-6
      draw at x-16,y+7 fillrect x-6,y+17
    else
      draw at x-33,y-4 fillrect x+34,y+5
      draw at x-4,y-33 fillrect x+5,y+34
      draw at x,y fillellipse 59,59
      draw color=WHITE bkcolor=WHITE
      draw at x,y fillellipse 45,45
      draw color=BLACK bkcolor=BLACK
      draw at x-12,y-12 fillrect x-2,y-2
      draw at x+3,y+3 fillrect x+13,y+13
    endif
  endif
  draw show
  x=RIGHTX/2
  hu=control BUTTON
    window=hright
    position=x-20,USERY-130,40,40
    name="U"
    help="Press and hold to move selected camera up"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hl=control BUTTON
    window=hright
    position=x-60,USERY-90,40,40
    name="L"
    help="Press and hold to move selected camera to the left"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hr=control BUTTON
    window=hright
    position=x+20,USERY-90,40,40
    name="R"
    help="Press and hold to move selected camera to the right"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hd=control BUTTON
    window=hright
    position=x-20,USERY-50,40,40
    name="D"
    help="Press and hold to move selected camera down"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  // Save original corrections.
  for i=0,i<2,i++ do
    vcx[i]=videocorrectx[i]
    vcy[i]=videocorrecty[i]
  enddo
  if cameras==0x03 then
    // Camera selection buttons are only necessary if there are two of them.
    htop=control BUTTON
      window=hright
      position=5,USERY+10,RIGHTX/3-5,24
      name="Top"
      help="Press to select top video camera"
    endc
    hbottom=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY+10,RIGHTX/3-5,24
      name="Bottom"
      help="Press to select bottom video camera"
    endc
    hdone=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY+10,RIGHTX/3-9,24
      name="Done"
      help="Press to accept corrections"
    endc
  else
    hdone=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY+10,120,24
      name="Done"
      help="Press to accept corrections"
    endc
  endif
  i=(cameras==0x02?1:0)                // Selected camera
  move=1; newview=1
  crossx=$LAY.xoffset/1000.0
  while crossx<videofromx+5.0 || crossx<fromxloc do
    crossx=crossx+xstep
  enddo
  while crossx>videotox-5.0 || crossx>toxloc do
    crossx=crossx-xstep
  enddo
  crossy=$LAY.yoffset[nfing]/1000.0
  while 1 do
    if Pressed(hexit) then
      return -1                        // Operator interrupted calibration
    else if Bcupdate(1)!=0 then
      newview=1
    else if Pressed(hdone) then
      return 0
    else if cameras==0x03 && Pressed(htop) then
      i=0; move=1; newview=1
    else if cameras==0x03 && Pressed(hbottom) then
      i=1; move=1; newview=1
    else if Pressed(hu) then
      videocorrecty[i]=Min(ystep/2.0,videocorrecty[i]+0.20); move=1
    else if Pressed(hl) then
      videocorrectx[i]=Max(-xstep/2.0,videocorrectx[i]-0.20); move=1
    else if Pressed(hr) then
      videocorrectx[i]=Min(xstep/2.0,videocorrectx[i]+0.20); move=1
    else if Pressed(hd) then
      videocorrecty[i]=Max(-ystep/2.0,videocorrecty[i]-0.20); move=1
    endif
    if move then
      n=sprintf(s,"M %i(%f,%fA255) ",                                          \
        nfing*2+i,crossx+videocorrectx[i],crossy+videocorrecty[i])
      if illumination!=0 n=n+sprintf(s+n,"%i(%f,%fA255) ",                     \
        nfing*2+1-i,crossx+throughdx+                                          \
        videocorrectx[1-i]+(videocorrectx[i]-vcx[i]),                          \
        crossy+throughdy+videocorrecty[1-i]+(videocorrecty[i]-vcy[i]))
      sprintf(s+n,"NOP")
      SERV.Cmdimm(32,s)
      // If opposite camera can stay in the way, move it away.
      if testertype!=TT_S3 && cameras==0x03 && illumination==0 then
        sprintf(s,"M %i(%f,%fA255) NOP",                                       \
          nfing*2+1-i,videotox,crossy)
        SERV.Cmdimm(32,s)
      endif
      move=0
    endif
    if newview then
      Bcsetcam(i,1)
      SYS.Videoangle(hlivevideo,i,0,Getzoom(i),                                \
        Bcgetbri(i,1),Bcgetctr(i,1),longexp?6:2,0)
      newview=0
    endif
    if illumination!=0 then            // Shinethrough calibration
      sprintf(s,"OUTPORT %i,0",0x2004+i )
      SERV.Cmdimm(32,s)
      sprintf(s,"OUTPORT %i,1",0x2004+1-i )
      SERV.Cmdimm(32,s)
    endif
    wait
  enddo
end

// Reads shinethrough corrections from initialization file.
function int Getheadcamshinethru()
  int head
  char s[256]
  Memset(headthrudx,0,Sizeof(headthrudx))
  Memset(headthrudy,0,Sizeof(headthrudy))
  if $LAY.cameras!=0 || headcams==0 return
  for head=0,head<32,head++ do
    if (headcams & (1<<head))==0 continue
    sprintf(s,"Shinethru corr[%i]",head)
    getini("Calibration",s,"%f,%f,%f,%f,%f,%f",                                \
    headthrudx[head]+0,headthrudy[head]+0,                                     \
    headthrudx[head]+1,headthrudy[head]+1,                                     \
    headthrudx[head]+2,headthrudy[head]+2)
  enddo
end

// Sets default or gets last known magnifications of head cameras.
function int Getheadcamscales()
  int i,head,channel,videosizex,videosizey
  float scale,scalex,scaley,headx,heady
  char s[256]
  for head=0,head<$LAY.nfing*2,head++ do
    if (headcams & (1<<head))==0 continue
    // Head camera scales in .ini file are in micrometers per pixel.
    headx=0.0; heady=0.0
    sprintf(s,"Headcam scale[%i]",head)
    getini("System",s,"%f,%f",&headx,&heady)
    if headx>1.0 && headx<20.0 && heady>1.0 && heady<20.0 then
      headcamscale[head]=(headx+heady)/2000.0
      continue
    endif
    // Old-style camera scales are in millimeters per 512 pixels.
    scalex=0.0; scaley=0.0
    sprintf(s,"Video scale[%i]",$LAY.side[head/2])
    getini("System",s,"%f,%f",&scalex,&scaley)
    if scalex>0.2 && scalex<10.0 && scaley>0.2 && scaley<10.0 then
      headcamscale[head]=(scalex+scaley)/1024.0
      continue
    endif
    // Empty .ini file, use defaults.
    channel=Channelfromhead(head)
    if channel<0 then
      videosizex=0
    else
      SYS.Videosize(channel,&videosizex,&videosizey,&i)
    endif
    if videosizex<800 then
      scale=5.0
    else if videosizex<1500 then
      scale=3.0
    else
      scale=1.0
    endif
    headcamscale[head]=scale/512.0
  enddo
end

// Asks operator to adjust offsets between specified head and opposite camera
// in the shinethrough mode. If changey is 1, allows to change Y coordinate
// of the specified head. If changey is -1, moves camera into the specified
// coordinates. If allowauto is not 0, allows automatic adjustment. Returns 1
// if user pressed OK, 2 if Cancel and -1 if user decided to interrupt
// calibration. Video window must be visible.
function int Adjustheadcamoffset(int head,float x,float y,int changey,         \
  handle hlivevideo,handle hzoom,handle hrotate,handle htext,int allowauto)
  int i,j,opp,oppflash,ret,index,move,update,channel,nfound
  int videosizex,videosizey,dummy,limit0,limit1,auto,fidx,fidy
  float yoffset,dx[3],dy[3],oppx,oppy,shiftx,shifty,angle,f
  float found[NFID][3],corrmax
  char s[256],oldtext[256]
  handle htemp,htop,hmiddle,hbottom,hu,hl,hr,hd,hmessage,hauto,hok,hcancel
  handle cross
  if boardtype!=1 && boardtype!=2 allowauto=0
  opp=Oppositeheadcam(head)
  if opp<0 return 0
  oppflash=Getoppflash(head)
  yoffset=$LAY.yoffset[opp/2]/1000.0
  index=Getyindex(opp,y)
  Text(hinfo,oldtext)
  limit0=Limit0(hinfo)
  limit1=Limit1(hinfo)
  if hzoom!=NULL disable hzoom
  change hright position=5000,5000,RIGHTX,RIGHTY
  htemp=control CHILD
    window=hmain
    position=SPLIT,10+SERVY,RIGHTX,RIGHTY
    help=" "
    color=DARKGRAY
    bkcolor=WHITE
    size=1024
  endc
  change hinfo text=format("Adjust illumination for head %i%c",                \
    head/2,head & 1?'R':'L')
  change hinfo limits=0,0
  if htext!=NULL change htext text=format(" %i%c",head/2,head & 1?'R':'L')
  if hlivevideo!=NULL then
    draw window=hlivevideo color=LIGHTRED
    draw at (LEFTX-10)/2,144 ellipse 120,120
    draw show
  endif
  draw window=htemp font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Using positioning keys, adjust back light for head camera "
  draw text=format("%i%c so that the circle is ",head/2,head & 1?'R':'L')
  draw text="homogeneously illuminated. Press " font=MAINFONT
  draw text="OK " font=TIMESFONT text="when ready or " font=MAINFONT
  draw text="Cancel " font=TIMESFONT text="to skip fiducial."
  if changey>0 then
    draw font=MAINFONT at 10,USERY-157 text="Line:"
  endif
  draw show
  if changey>0 then
    htop=control BUTTON
      window=htemp
      position=10,USERY-151,75,22
      name="Top"
      help="Press to adjust illimination in the top line of fiducials"
    endc
    hmiddle=control BUTTON
      window=htemp
      position=10,USERY-121,75,22
      name="Middle"
      help="Press to adjust illimination in the middle line of fiducials"
    endc
    hbottom=control BUTTON
      window=htemp
      position=10,USERY-91,75,22
      name="Bottom"
      help="Press to adjust illimination in the bottom line of fiducials"
    endc
  else
    htop=NULL
    hmiddle=NULL
    hbottom=NULL
  endif
  hu=control BUTTON
    window=htemp
    position=RIGHTX/2+(changey>0?25:-20),USERY-170,40,40
    name="U"
    help="Press and hold to move opposite camera up"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hl=control BUTTON
    window=htemp
    position=RIGHTX/2+(changey>0?-15:-60),USERY-130,40,40
    name="L"
    help="Press and hold to move opposite camera to the left"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hr=control BUTTON
    window=htemp
    position=RIGHTX/2+(changey>0?65:20),USERY-130,40,40
    name="R"
    help="Press and hold to move opposite camera to the right"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hd=control BUTTON
    window=htemp
    position=RIGHTX/2+(changey>0?25:-20),USERY-90,40,40
    name="D"
    help="Press and hold to move opposite camera down"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hmessage=control TEXT
    window=htemp
    position=5,USERY-33,RIGHTX-10,24
    help=" "
    color=LIGHTRED
    font=MEDIUMFONT
  endc
  if allowauto then
    hauto=control BUTTON
      window=htemp
      position=5,USERY,RIGHTX/3-5,24
      name="Auto"
      help="Press to try automatic adjustment"
    endc
    hok=control BUTTON
      window=htemp
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="OK"
      help="Press when illumination is adjusted"
    endc
    hcancel=control BUTTON
      window=htemp
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="Cancel"
      help="Press to skip currently scanned fiducial"
    endc
  else
    hauto=NULL
    hok=control BUTTON
      window=htemp
      position=RIGHTX/2-124,USERY,120,24
      name="OK"
      help="Press when illumination is adjusted"
    endc
    hcancel=control BUTTON
      window=htemp
      position=RIGHTX/2+5,USERY,120,24
      name="Cancel"
      help="Press to skip currently scanned fiducial"
    endc
  endif
  for i=0,i<3,i++ do
    dx[i]=0.0; dy[i]=0.0
  enddo
  ret=0; update=1; auto=0
  move=(changey<0?2:1)
  SYS.Killimm(32)
  $A[32].length=5
  while ret==0 do
    if Pressed(hexit) then
      ret=-1
    else if Pressed(hok) then
      for i=0,i<3,i++ do
        headthrudx[opp][i]=headthrudx[opp][i]+dx[i]; dx[i]=0.0
        headthrudy[opp][i]=headthrudy[opp][i]+dy[i]; dy[i]=0.0
      enddo
      sprintf(s,"Shinethru corr[%i]",opp)
      setini("Calibration",s,"%f,%f,%f,%f,%f,%f",                              \
        headthrudx[opp][0],headthrudy[opp][0],                                 \
        headthrudx[opp][1],headthrudy[opp][1],                                 \
        headthrudx[opp][2],headthrudy[opp][2])
      move=1; ret=1
    else if Pressed(hcancel) then
      for i=0,i<3,i++ do
        dx[i]=0.0; dy[i]=0.0
      enddo
      ret=2; move=1
    else if Pressed(hu) then
      dy[index]=dy[index]+0.5; move=1
      change hmessage text=""
    else if Pressed(hl) then
      dx[index]=dx[index]-0.5; move=1
      change hmessage text=""
    else if Pressed(hr) then
      dx[index]=dx[index]+0.5; move=1
      change hmessage text=""
    else if Pressed(hd) then
      dy[index]=dy[index]-0.5; move=1
      change hmessage text=""
    else if Pressed(htop) && index!=2 && changey>0 then
      y=c[head].topliney
      index=2; move=2; update=1
      change hmessage text=""
    else if Pressed(hmiddle) && index!=1 && changey>0 then
      y=yoffset
      index=1; move=2; update=1
      change hmessage text=""
    else if Pressed(hbottom) && index!=0 && changey>0 then
      y=c[head].bottomliney
      index=0; move=2; update=1
      change hmessage text=""
    else if Bcupdate(0)!=0 then
      update=1
    else if hrotate!=NULL && Pressed(hrotate) then
      rotateimage=Status(hrotate)
      update=1
    else if hauto!=NULL && Pressed(hauto) then
      if auto==0 then
        auto=1
        change hmessage text="Adjusting..."
        change hauto color=LIGHTRED
        change hauto bkcolor=YELLOW
        disable hu
        disable hl
        disable hr
        disable hd
        disable htop
        disable hmiddle
        disable hbottom
      else
        auto=-1
        change hmessage text=""
      endif
    endif
    if auto>0 && $A[32].length!=0 then
      // Auto adjustment of the opposite camera. Only works for special
      // fiducials on glass.
      channel=Channelfromhead(head)
      SYS.Nextframe(channel)
      SYS.Videosize(channel,&videosizex,&videosizey,&dummy)
      // Get position of the fiducial.
      angle=Asin((y-yoffset)/headcamradius)
      if (head & 1)==0 angle=-angle
      if $LAY.side[head/2]==0 angle=-angle
      corrmax=-1000.0
      for i=-2,i<=2,i++ do
        f=1.0+0.15*i
        cross=Model(channel,(headcamfidtype==2?SYNT_RIGHT:SYNT_LEFT),          \
          0.7/headcamscale[head]*f,0.3/headcamscale[head]*f,                   \
          0.0,0.0,BLACKONWHITE)
        nfound=SYS.Recognangle(cross,0,0,videosizex,videosizey,found,angle,0)
        SYS.Deletemodel(cross)
        if nfound>0 && found[0,2]>corrmax then
          fidx=found[0,0]-videosizex/2
          fidy=found[0,1]-videosizey/2
          corrmax=found[0,2]
        endif
      enddo
      if corrmax<450.0 then
        // Fiducial can not be recognized. Maybe brightness is totally wrong?
        i=Autoadjust(head,index,opp,y,0.0,0.0,angle,0,&shiftx,&shifty)
        if i==1 then
          update=1                     // Brightness changed, update viewer
        else
          auto=-1                      // Bad fiducial, stop auto adjustment
          change hmessage text="No fiducial"
        endif
      else
        i=Autoadjust(head,index,opp,y,fidx,fidy,angle,0,&shiftx,&shifty)
        if i==2 then
          dx[index]=dx[index]+shiftx   // Move opposite camera
          dy[index]=dy[index]+shifty
          move=1
        else if i==1 then
          update=1                     // Brightness changed, update viewer
        else if i==(-2) then
          auto=-1                      // Shifted fiducial, stop auto adjustment
          change hmessage text="Shifted fiducial"
        else
          auto=-1                      // Adjustment finished
          change hmessage text=""
        endif
      endif
    endif
    if auto<0 then
      // Request to stop auto adjustment.
      auto=0
      change hauto color=BLACK
      change hauto bkcolor=GRAY
      enable hu
      enable hl
      enable hr
      enable hd
      enable htop
      enable hmiddle
      enable hbottom
    endif
    if move && $A[32].length!=0 then
      // Request to move camera under test.
      if move==2 && changey then
        sprintf(s,"M @%i[%f,%fH30] NOP",head,x,y)
        SERV.Cmdimm(32,s)
      endif
      // Request to move opposite camera. Total corrections of the opposite
      // camera are limited to +/-12.0 mm.
      if headthrudx[opp][index]+dx[index]<(-12.0) then
        dx[index]=-12.0-headthrudx[opp][index]
      else if headthrudx[opp][index]+dx[index]>12.0 then
        dx[index]=12.0-headthrudx[opp][index]
      endif
      if headthrudy[opp][index]+dy[index]<(-12.0) then
        dy[index]=-12.0-headthrudy[opp][index]
      else if headthrudy[opp][index]+dy[index]>12.0 then
        dy[index]=12.0-headthrudy[opp][index]
      endif
      Oppositexy(x,y,opp,&oppx,&oppy,0.0)
      if oppy+dy[index]<($LAY.bottom[opp/2]+1)/1000.0-MAXCORRY then
        dy[index]=($LAY.bottom[opp/2]+1)/1000.0-MAXCORRY-oppy
      else if oppy+dy[index]>($LAY.top[opp/2]-2)/1000.0+MAXCORRY then
        dy[index]=($LAY.top[opp/2]-2)/1000.0+MAXCORRY-oppy
      endif
      sprintf(s,"M %i[%f,%fH30] NOP",opp,oppx+dx[index],oppy+dy[index])
      SERV.Cmdimm(32,s)
      if changey>0 then
        change htop color=(index==2?LIGHTRED:BLACK)
        change htop bkcolor=(index==2?YELLOW:GRAY)
        change hmiddle color=(index==1?LIGHTRED:BLACK)
        change hmiddle bkcolor=(index==1?YELLOW:GRAY)
        change hbottom color=(index==0?LIGHTRED:BLACK)
        change hbottom bkcolor=(index==0?YELLOW:GRAY)
      endif
      move=0
    endif
    if update && hlivevideo!=NULL then
      // Request to change video parameters.
      channel=Channelfromhead(head)
      if channel<0 || index==1 || hrotate==NULL || rotateimage==0 then
        angle=0.0
      else
        angle=Asin((y-yoffset)/headcamradius)
        if (head & 1)==0 angle=-angle
        if $LAY.side[head/2]==0 angle=-angle
      endif
      Bcsetcam(channel,index)
      SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),           \
        Bcgetbri(channel,index),Bcgetctr(channel,index),                       \
        (channel<0?0:2)|(longexp?4:0),angle)
      update=0
    endif
    wait
  enddo
  change hinfo text=oldtext
  change hinfo limits=limit0,limit1
  destroy htemp
  if hlivevideo!=NULL then
    draw window=hlivevideo color=VIDEOFILL
    draw at (LEFTX-10)/2,144 ellipse 120,120
    draw show
  endif
  change hright position=SPLIT-1,9+SERVY,RIGHTX,RIGHTY
  if hzoom!=NULL enable hzoom
  return ret
end

// Asks operator to adjust brightness and contrast of head cameras (starting,
// if possible, from the specified camera). Returns -1 if operator interrupted
// the calibration and 0 on success.
function int Headcambrightness(int firsthead,int showpos)
  int i,r,nfing,ntop,nbot,toplist,botlist,x,y,dx
  int head,opp,oppflash,prevhead,redraw,channel,status,illchanged
  float zoom,oppx,oppy
  char s[256]
  handle hview,hlivevideo,hbreak,hcont
  handle hheadcam[32],hadjust
  if headcams==0 return 0              // Works only with head cameras
  nfing=$LAY.nfing
  ntop=0; toplist=0
  nbot=0; botlist=0
  for i=0,i<nfing*2,i++ do
    if (headcams & (1<<i))==0 continue // No camera on the head
    if $LAY.side[i/2]==0 then
      toplist=toplist | (1<<i)
      ntop++
    else
      botlist=botlist | (1<<i)
      nbot++
    endif
  enddo
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  Fillcalibrators(C_CALIBR,FILL_HCAM)
  Bccreate(hview,-1,-1,-1,1,1)
  change hinfo limits=0,0
  change hinfo text="Check head cameras"
  if hlog!=NULL fprintf(hlog,"Checking head cameras manually...\n")
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please inspect all head cameras and set "
  if testertype==TT_A7 || testertype==TT_A8 then
    draw text="brightness, contrast and type of illumination. "
  else
    draw text="brightness and contrast. "
  endif
  if showpos then
    draw text="Small circle indicates expected position of the needle, "
    draw text="and the center of the fiducial should lie within the square. "
  endif
  draw text="Press " font=MAINFONT text="Continue " font=TIMESFONT
  draw text="when ready, or doubleclick " font=MAINFONT text="Break "
  draw font=TIMESFONT text="to stop calibration."
  dx=(RIGHTX-15)/Max(ntop,nbot)-5
  if dx>50 dx=50
  y=(ntop!=0 && nbot!=0?140:170)
  draw font=INFOFONT mode=M_CENTERED
  head=-1; prevhead=-1; zoom=0.5
  // Create buttons for top cameras.
  if ntop>0 then
    if nbot>0 then
      draw at RIGHTX/2,y+10 text="Top cameras:"
      y=y+12
    endif
    x=(RIGHTX-(dx+5)*ntop+5)/2
    for i=0,i<nfing*2,i++ do
      if (toplist & (1<<i))==0 continue
      if (head<0 || i==firsthead) head=i
      hheadcam[i]=control BUTTON
        window=hright
        position=x,y,dx,22
        name=format("%i%c",i/2,i & 1?'R':'L')
        help=format("Press to inspect head camera %i%c",i/2,i & 1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      x=x+dx+5
    enddo
    y=y+30
  endif
  // Create buttons for bottom cameras.
  if nbot>0 then
    if ntop>0 then
      draw at RIGHTX/2,y+10 text="Bottom cameras:"
      y=y+12
    endif
    x=(RIGHTX-(dx+5)*nbot+5)/2
    for i=0,i<nfing*2,i++ do
      if (botlist & (1<<i))==0 continue
      if (head<0 || i==firsthead) head=i
      hheadcam[i]=control BUTTON
        window=hright
        position=x,y,dx,22
        name=format("%i%c",i/2,i & 1?'R':'L')
        help=format("Press to inspect head camera %i%c",i/2,i & 1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      x=x+dx+5
    enddo
  endif
  // Create button to adjust opposite camera.
  if illumination!=0 then
    y=y+40
    hadjust=control BUTTON
      window=hright
      position=RIGHTX/2-75,y,150,22
      name="Adjust illumination"
      help="Press to adjust position of the opposite camera"
    endc
  else
    hadjust=NULL
  endif
  draw show
  hbreak=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Break"
    help="DOUBLECLICK to stop calibration"
    mode=M_DBLCLICK
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Continue"
    help="Press after all head cameras are inspected"
  endc
  redraw=1
  illchanged=0
  while 1 do
    status=Bcupdate(1)
    if (status & 0x01)!=0 then
      redraw=1
    endif
    if (status & 0x02)!=0 then
      redraw=1; illchanged=1
    endif
    if head!=prevhead || redraw!=0 then
      // Indicate selected head.
      if head!=prevhead then
        if prevhead>=0 then
          change hheadcam[prevhead] color=BLACK
          change hheadcam[prevhead] bkcolor=GRAY
        endif
        change hheadcam[head] color=LIGHTRED
        change hheadcam[head] bkcolor=YELLOW
      endif
      // Redraw screen and display live video from selected camera.
      channel=Channelfromhead(head)
      zoom=Getzoom(channel)
      draw window=hlivevideo bkcolor=VIDEOFILL clear
      if showpos then
        if ((head^$LAY.side[head/2]) & 1)==0 then
          x=(LEFTX-10)/2-(headcamradius-radius)/headcamscale[head]*zoom
        else
          x=(LEFTX-10)/2+(headcamradius-radius)/headcamscale[head]*zoom
        endif
        r=0.5/headcamscale[head]*zoom  // Circle with diameter 0.5 mm
        draw color=LIGHTRED at x,144 ellipse r,r
        x=(LEFTX-10)/2
        r=0.5/headcamscale[head]*zoom  // Rectangle with side 1 mm
        draw at x-r,144-r rect x+r+1,144+r+1
        r=r/2.0                        // Cross in the middle
        draw at x-r,144 to x+r+1,144 at x,144-r to x,144+r+1
      endif
      draw show
      Bcsetcam(channel,1)
      oppflash=Getoppflash(head)
      SYS.Videoangle(hlivevideo,channel|oppflash,0,zoom,                       \
        Bcgetbri(channel,1),Bcgetctr(channel,1),                               \
        (channel<0?0:2)|(longexp?4:0),0.0)
      // Move selected head to the central fiducial and all remaining cameras
      // in home positions and set illumination.
      if head!=prevhead || illchanged!=0 then
        opp=Oppositeheadcam(head)
        SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
        for i=0,i<nfing*2,i++ do
          if (headcams & (1<<i))==0 continue
          if i==head then
            sprintf(s,"M @%i[%f,%fH30] NOP",i,                                 \
            $LAY.xoffset/1000.0+boardshift,$LAY.yoffset[i/2]/1000.0)
          else if illumination!=0 && i==opp then
            Oppositexy($LAY.xoffset/1000.0+boardshift,                         \
              $LAY.yoffset[i/2]/1000.0,opp,&oppx,&oppy,0.0)
            sprintf(s,"M %i(%f,%fH30) NOP",i,oppx,oppy)
          else
            sprintf(s,"M %i(Z) NOP",i)
          endif
          SERV.Cmdimm(32,s)
          if (illumination==0 && i==head) || (illumination!=0 && i==opp) then
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",i,illtype)
            SERV.Cmdimm(32,s)
          endif
        enddo
      endif
      prevhead=head
      illchanged=0
      redraw=0
    endif
    if Pressed(hexit) then
      return -1
    else if Pressed(hbreak) then
      return -1
    else if Pressed(hcont) then
      SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
      return 0
    else if Pressed(hadjust) then
      i=Adjustheadcamoffset(head,$LAY.xoffset/1000.0+boardshift,               \
        $LAY.yoffset[head/2]/1000.0,1,hlivevideo,NULL,NULL,NULL,1)
      if i<0 return -1
      prevhead=-1                      // Head position may change
      redraw=1
    endif
    for i=0,i<nfing*2,i++ do
      if hheadcam[i]==NULL continue
      if Pressed(hheadcam[i]) head=i
    enddo
    wait
  enddo
end

// Determines whether and which clipping area should be used during fiducial
// recognition. Returns 0 if no clipping, -1 if clipping should be done on the
// left side and 1 if on the right.
function int Getclip(int head)
  if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||              \
    testertype==TT_A5L || testertype==TT_S2 || testertype==TT_A7 ||            \
    testertype==TT_A8)) || boardtype==2 then
    return 0                           // No clipping
  else if noclip!=0 then
    return 0                           // No clipping, requested by operator
  else if head<0 || head>=$LAY.nfing*2 then
    return 0                           // Invalid head
  else if ((head^$LAY.side[head/2]) & 1)==0 then
    return -1                          // Clip left
  else
    return 1                           // Clip right
  endif
end

// Service function, protocols correlation to the log file.
function int Reportcorrelation(int channel,float *found,int nfound,format text)
  int head
  if hlog==NULL return
  head=Headfromchannel(channel)
  fprintf(hlog,"  V%i%s %s:",head/2,(head & 1?"R":"L"),text)
  if nfound==0 then
    fprintf(hlog,"  No fiducials found")
  else
    fprintf(hlog,"  %7.1f,%7.1f (%4.0f)",found[0],found[1],found[2])
    if nfound>=2 then
      fprintf(hlog,"  %7.1f,%7.1f (%4.0f)",found[3],found[4],found[5])
    endif
  endif
  fprintf(hlog,"\n")
end

// Step bit definitions used by Headcamcenters().
#define HCS_BUSY       0x0800          // Head busy
#define HCS_MOVE       0x0700          // Mask to extract movements
#define   HCS_MOVEA    0x0400          // Start movement to center
#define   HCS_MOVEB    0x0200          // Start movement to shifted position
#define   HCS_MOVEC    0x0100          // Start movement to get factor
#define HCS_WAITMOVE   0x0020          // Wait till end of movement
#define HCS_DELAY      0x0010          // Delay after movement
#define HCS_SHIFTA     0x0004          // Learn center
#define HCS_SHIFTB     0x0002          // Scan shifted position
#define HCS_CENTER     0x0001          // Scan center & set factor

// Measures offsets between head cameras and needles, to verify that the tip of
// the needle is correctly clipped from the recognition, and X magnification.
// Assumes that centers are already scanned electrically and layout is
// corrected. Returns 0 if offsets are acceptable, 1 if operator decided to
// check offsets manually and -1 if he interrupted the calibration. High
// accuracy is not requested.
function int Headcamcenters()
  int i,j,k,fidtype,opp,oppflash,nfing,channel,videox,videoy,nfound
  int err,headerr[32],badhead,busy,step[32],tstart[32],nretry[32]
  int ncamera,ntop,nbot,centralcross[32]
  float f,t,x,x0,y,xc[32],yc[32],xs[32],ys[32],stop,sbot
  float corrmax[32],found[NFID][3],fiddif,oppx,oppy,angle
  char s[256],errmsg[32][64]
  handle hview,hlivevideo
  handle cross,model[32],hrepeat,hrecheck,hcont
  handle htable
  if headcams==0 return 0              // Works only with head cameras
  nfing=$LAY.nfing
repeat:
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  Bccreate(hview,-1,-1,0,1,0)
  change hinfo limits=0,0
  change hinfo text="Checking camera offsets"
  if hlog!=NULL then
    fprintf(hlog,"Checking head camera offsets and magnifications...\n")
  endif
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Calibration will now verify needle-to-camera offsets and measure "
  draw text="magnification of each camera. "
  draw show
  SYS.Videoangle(hlivevideo,0|Getoppflash(0),0,                                \
    Getzoom(0),Bcgetbri(0,1),Bcgetctr(0,1),(longexp?6:2),0.0)
  if demo then
    delay 1000
    for i=0,i<nfing*2,i++ do
      headcamscale[i]=0.015            // Exact value is unimportant
      headcamwfactor[i]=1.0
      headcamsfactor[i]=1.0
    enddo
    return 0
  endif
  // Initialize control structures.
  ncamera=0
  for i=0,i<nfing*2,i++ do
    if (headcams & (1<<i))==0 then
      step[i]=0
    else
      step[i]=HCS_MOVEA|HCS_SHIFTA|HCS_SHIFTB|HCS_CENTER
      ncamera++
    endif
    model[i]=NULL
    nretry[i]=0
    headerr[i]=0
    errmsg[i][0]='\0'
  enddo
  if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||              \
    testertype==TT_A5L || testertype==TT_A6 || testertype==TT_A7 ||            \
    testertype==TT_A8)) || boardtype==2                                        \
  then
    fiddif=0.85                        // Fiducials on glass are more ambiguous
  else
    fiddif=0.80                        // Old good cross
  endif
  err=0
  SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
  // Scan fiducials.
  while err==0 do
    busy=0
    for i=0,i<nfing*2,i++ do
      if step[i]==0 || headerr[i]!=0 continue
      busy=1
      channel=Channelfromhead(i)
      oppflash=Getoppflash(i)
      if Bcupdate(1)!=0 then
        Bcsetcam(channel,1)
        SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),         \
        Bcgetbri(channel,1),Bcgetctr(channel,1),(longexp?6:2),0.0)
      endif
      if step[i] & HCS_MOVE then
        // Try to start next movement. First check whether there is a collision
        // with fingers in the vicinity.
        for j=0,j<nfing*2,j++ do
          if j==i continue             // No collision with self
          if $LAY.top[j/2]<=$LAY.bottom[i/2] continue
          if $LAY.bottom[j/2]>=$LAY.top[i/2] continue
          if step[j] & HCS_BUSY break
        enddo
        if j<nfing*2 continue          // Finger in the vicinity is busy
        SYS.Killimm(i)
        opp=Oppositeheadcam(i)
        // Get coordinates of next scan point.
        x0=$LAY.xoffset/1000.0+boardshift
        x=x0
        if (step[i] & HCS_MOVEB) x=x+(i & 1?1.0:-1.0)
        if (step[i] & HCS_MOVE)==HCS_MOVEC then
          y=c[i].centercamy
        else
          y=$LAY.yoffset[i/2]/1000.0
        endif
        // Move head and its neighbour. Note: headcam movement! When head
        // moves, lights are turned off.
        sprintf(s,"M @%i[%f,%fH30A%i] %i(Z) NOP",i,x,y,acc,i^1)
        SERV.Cmdimm(i,s)
        sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",i)
        SERV.Cmdimm(32,s)
        sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",i^1)
        SERV.Cmdimm(32,s)
        // Move heads on the opposite side. Note: light source must stay over
        // the fiducial, not opposite to the scanning camera!
        if opp>=0 then
          if illumination==0 then
            sprintf(s,"M %i(Z) %i(Z) NOP",opp,opp^1)
          else
            Oppositexy(x0,y,opp,&oppx,&oppy,0.0)
            sprintf(s,"M %i(%f,%fH30) %i(Z) NOP",opp,oppx,oppy,opp^1)
          endif
          SERV.Cmdimm(32,s)
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",opp)
          SERV.Cmdimm(32,s)
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",opp^1)
          SERV.Cmdimm(32,s)
        endif
        step[i]=(step[i] & (~HCS_MOVE)) | (HCS_BUSY|HCS_WAITMOVE)
        tstart[i]=Time()
      else if step[i] & HCS_WAITMOVE then
        // Wait till the end of the movement and turn the lights on.
        if Time()-tstart[i]>10000 then
          err=1; break
        endif
        if $A[i].length==0 continue
        if $A[i].answer!=S_READY then
          err=2; break
        endif
        sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",i,                        \
          illumination==0?illtype:illtype & 0xC)
        SERV.Cmdimm(32,s)
        if illumination!=0 then
          opp=Oppositeheadcam(i)
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",opp,illtype)
          SERV.Cmdimm(32,s)
        endif
        step[i]=(step[i] & (~HCS_WAITMOVE)) | HCS_DELAY
        tstart[i]=Time()
      else if step[i] & HCS_DELAY then
        // Delay 500 ms after movement.
        if Time()-tstart[i]<500 continue
        step[i]=step[i] & (~HCS_DELAY)
      else if step[i] & HCS_SHIFTA then
        // Learn central fiducial.
        Bcsetcam(channel,1)
        SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),         \
          Bcgetbri(channel,1),Bcgetctr(channel,1),(longexp?6:2),0.0)
        SYS.Nextframe(channel)
        SYS.Videosize(channel,&videox,&videoy,&j)
        delay (videox<=1024?200:500)
        if (testertype==TT_S1 || testertype==TT_S3) &&                         \
          videox<=768 && videoy<=768 then
          model[i]=SYS.Videomodel(channel,videox/2,videoy/2,                   \
          Min(1000,videox),Min(1000,videoy),MODEL_SMART|MODEL_BIG)
        else
          model[i]=SYS.Videomodel(channel,videox/2,videoy/2,                   \
          Min(2000,videox*3/4),Min(2000,videoy-16),MODEL_BIG)
        endif
        if model[i]==NULL then
          step[i]=step[i] | HCS_MOVEA
          nretry[i]++
          if nretry[i]<3 continue
          err=4; break
        endif
        nfound=SYS.Recognangle(model[i],0,0,videox,videoy,found,               \
          0.0,Getclip(i))
        nfound=Correctfound(found,nfound)
        Reportcorrelation(channel,found,nfound,"Learned center")
        if nfound==0 || found[0,2]<350.0 || (found[1,2]>found[0,2]*fiddif) then
          SYS.Deletemodel(model[i]); model[i]=NULL
          step[i]=HCS_BUSY|HCS_MOVEA|HCS_SHIFTA|HCS_SHIFTB|HCS_CENTER
          nretry[i]++
          if nretry[i]<3 continue
          headerr[i]=5                 // Unable to recognize cross
          if nfound==0 then
            sprintf(errmsg[i],"No fiducial")
          else if found[0,2]<350.0 then
            sprintf(errmsg[i],"Low correlation (%.0f)",found[0,2])
          else
            sprintf(errmsg[i],"Two crosses (%.0f, %.0f)",found[0,2],found[1,2])
          endif
          step[i]=0
        endif
        xs[i]=found[0,0]               // In pixels, scale is yet unknown
        ys[i]=found[0,1]
        step[i]=(step[i] & (~HCS_SHIFTA)) | HCS_MOVEB
      else if step[i] & HCS_SHIFTB then
        // Scan learned fiducial in shifted position.
        Bcsetcam(channel,1)
        SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),         \
          Bcgetbri(channel,1),Bcgetctr(channel,1),(longexp?6:2),0.0)
        SYS.Nextframe(channel)
        SYS.Videosize(channel,&videox,&videoy,&j)
        delay (videox<=1024?200:500)
        nfound=SYS.Recognangle(model[i],0,0,videox,videoy,found,               \
          0.0,Getclip(i))
        nfound=Correctfound(found,nfound)
        Reportcorrelation(channel,found,nfound,"Shifted center")
        SYS.Deletemodel(model[i]); model[i]=NULL
        if nfound==0 || found[0,2]<350.0 || found[1,2]>found[0,2]*fiddif ||    \
          Abs(found[0,1]-ys[i])>Max(10.0,Abs(found[0,0]-xs[i])/15.0)           \
        then
          step[i]=HCS_BUSY|HCS_MOVEA|HCS_SHIFTA|HCS_SHIFTB|HCS_CENTER
          nretry[i]++
          if nretry[i]<3 continue
          headerr[i]=5                 // Unable to recognize cross
          if nfound==0 then
            sprintf(errmsg[i],"No fiducial")
          else if found[0,2]<350.0 then
            sprintf(errmsg[i],"Low correlation (%.0f)",found[0,2])
          else if found[1,2]>found[0,2]*fiddif then
            sprintf(errmsg[i],"Two crosses (%.0f, %.0f)",found[0,2],found[1,2])
          else
            sprintf(errmsg[i],"Rotated image (%.2f deg)",                      \
            (found[0,1]-ys[i])/Abs(found[0,0]-xs[i])*180.0/PI)
          endif
          step[i]=0
        else
          // Calculate magnification.
          if Abs(found[0,0]-xs[i])<10.0 then
            headerr[i]=6               // No shift?..
            sprintf(errmsg[i],"Low X shift (%.0f pixel)",found[0,0]-xs[i])
            step[i]=0
          else
            if ((i^$LAY.side[i/2]) & 1)==0 then
              f=1.0/(found[0,0]-xs[i]) // Millimeters per pixel
            else
              f=1.0/(xs[i]-found[0,0]) // Ditto
            endif
            if f*512<(-0.5) then
              headerr[i]=8             // Negative magnification
              sprintf(errmsg[i],"Neg magnification %.1f um/pix",f*1000)
              step[i]=0
            else if f*512.0<0.5 || f*512.0>10.0 then
              headerr[i]=6             // Magnification out of expected range
              sprintf(errmsg[i],"Bad magnification %.1f um/pix",f*1000)
              step[i]=0
            endif
          endif
        endif
        headcamscale[i]=f
        step[i]=(step[i] & (~HCS_SHIFTB)) | HCS_MOVEC
      else if step[i] & HCS_CENTER then
        // Check position of central fiducial and estimate visible line width.
        angle=Asin((c[i].centercamy-$LAY.yoffset[i/2]/1000.0)/headcamradius)
        if (i & 1)==0 angle=-angle
        if $LAY.side[i/2]==0 angle=-angle
        Bcsetcam(channel,1)
        SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),         \
          Bcgetbri(channel,1),Bcgetctr(channel,1),(longexp?6:2),angle)
        SYS.Nextframe(channel)
        SYS.Videosize(channel,&videox,&videoy,&j)
        delay (videox<=1024?200:500)
        headcamwfactor[i]=1.0          // Default values, just for the case
        headcamsfactor[i]=1.0
        corrmax[i]=0.0
        centralcross[i]=-1
        xs[i]=0.0
        ys[i]=0.0
        for j=0,j<=16,j++ do
          // Try size factors 0.70, 0.75, 0.80, ..., 1.30, optionally till 1.50.
          f=1.0+(j-6)*0.05
          for k=-1,k<=1,k++ do
            // Try distance factors 0.95, 1.00, 1.05.
            t=1.0+k*0.05
            // Central cross on the glass board for S1 can be either
            // SYNT_LEFT/SYNT_RIGHT or SYNT_CROSS, try both.
            for fidtype=0,fidtype<2,fidtype++ do
              if fidtype==0 then
                if k!=0 continue
                if (boardtype==1 && (testertype==TT_A3L ||                     \
                  testertype==TT_A5 || testertype==TT_A5L ||                   \
                  testertype==TT_A6 || testertype==TT_A7 ||                    \
                  testertype==TT_A8)) || boardtype==2 || headcamfidtype!=0     \
                  continue
                cross=Model(channel,SYNT_CROSS,                                \
                  linewidth/headcamscale[i]*f*7,linewidth/headcamscale[i]*f,   \
                  0.0,0.0,                                                     \
                  (illumination==0 && boardtype==0?WHITEONBLACK:BLACKONWHITE))
                ;
              else
                if (boardtype!=1 || (testertype!=TT_A3L &&                     \
                  testertype!=TT_A5 && testertype!=TT_A5L &&                   \
                  testertype!=TT_A6 && testertype!=TT_S1 &&                    \
                  testertype!=TT_S2 && testertype!=TT_S3 &&                    \
                  testertype!=TT_A7 && testertype!=TT_A8)) &&                  \
                  boardtype!=2 && headcamfidtype==0 continue
                cross=Model(channel,                                           \
                  (headcamfidtype==2?SYNT_RIGHT:SYNT_LEFT),                    \
                  0.7/headcamscale[i]*t,0.3/headcamscale[i]*f,                 \
                  0.0,0.0,                                                     \
                  (illumination==0 && (boardtype==0 || testertype==TT_S3)?     \
                  WHITEONBLACK:BLACKONWHITE))
                ;
              endif
              if cross==NULL continue
              nfound=SYS.Recognangle(cross,0,0,videox,videoy,found,            \
                angle,Getclip(i))
              SYS.Deletemodel(cross)
              if nfound>0 && found[0,2]>corrmax[i] then
                corrmax[i]=found[0,2]
                headcamwfactor[i]=f
                headcamsfactor[i]=t
                centralcross[i]=(fidtype==0?SYNT_CROSS:                        \
                  (headcamfidtype==2?SYNT_RIGHT:SYNT_LEFT))
                xc[i]=(found[0,0]-videox/2)*headcamscale[i]
                if $LAY.side[i/2]!=0 xc[i]=-xc[i]
                yc[i]=(found[0,1]-videoy/2)*headcamscale[i]
              endif
              if Pressed(hexit) then
                err=-1; break
              else if Bcupdate(1)!=0 then
                SYS.Videoangle(hlivevideo,channel|oppflash,0,                  \
                Getzoom(channel),Bcgetbri(channel,1),Bcgetctr(channel,1),      \
                (longexp?6:2),angle)
              endif
              wait
            enddo
          enddo
          if f>=1.30 && corrmax[i]>400.0 && headcamwfactor[i]<1.3 break
        enddo
        if corrmax[i]<400.0 then
          sprintf(errmsg[i],"Bad cross (corr %.0f at x%.1f)",                  \
            corrmax[i],headcamwfactor[i])
          headerr[i]=11
        endif
        c[i].centralcross=centralcross[i]
        step[i]=0                      // Scanning finished
      endif
      if Pressed(hexit) then
        err=-1; break
      endif
    enddo
    if err!=0 badhead=i
    if busy==0 break                   // All done
    wait
  enddo
  // Clean up.
  for i=0,i<nfing*2,i++ do
    if err==0 && headerr[i]!=0 then
      if hlog!=NULL fprintf(hlog,"  Camera %i%c: %s\n",                        \
        i/2,i & 1?'R':'L',errmsg[i])
      err=headerr[i]
      badhead=i
    endif
    if model[i]!=NULL then
      SYS.Deletemodel(model[i]); model[i]=NULL
    endif
  enddo
  if err<0 return -1                   // Operator interrupted calibration
  // Save results to log file.
  if err==0 then
    for i=0,i<nfing*2,i++ do
      if (headcams & (1<<i))==0 continue
      if (Abs(yc[i])>0.5 ||                                                    \
        ((i & 1)==0 && xc[i]>0.5) || ((i & 1)!=0 && xc[i]<(-0.5))) then
        if err==0 err=7
        headerr[i]=7
        badhead=i
        sprintf(errmsg[i],"Shift %.3f,%.3f mm",xc[i],yc[i])
      endif
      if hlog!=NULL then
        SYS.Videosize(channel,&videox,&videoy,&j)
        fprintf(hlog,"  Camera %i%c: dX=%7.3f, dY=%7.3f mm, S=%4.2f um/pix, ", \
          i/2,i & 1?'R':'L',xc[i],yc[i],headcamscale[i]*1000.0)
        fprintf(hlog,"F=%4.2f/%4.2f (%s, corr %.0f)\n",                        \
          headcamwfactor[i],headcamsfactor[i],                                 \
          (centralcross[i]==SYNT_CROSS?"SYNT_CROSS":                           \
          (centralcross[i]==SYNT_RIGHT?"SYNT_RIGHT":"SYNT_LEFT")),             \
          corrmax[i])
        ;
      endif
    enddo
  endif
  // Save magnifications and report success.
acceptadjustment:
  SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
  if err==0 then
    ntop=0; stop=0.0; nbot=0; sbot=0.0
    for i=0,i<nfing*2,i++ do
      if (headcams & (1<<i))==0 continue
      // Save magnifications to .ini file so that other programs can use it.
      sprintf(s,"Headcam scale[%i]",i)
      setini("System",s,"%f,%f",headcamscale[i]*1000.0,headcamscale[i]*1000.0)
      if $LAY.side[i/2]==0 then
        stop=stop+headcamscale[i]; ntop++
      else
        sbot=sbot+headcamscale[i]; nbot++
      endif
    enddo
    // Save mean temperature of the patients... uups, mean magnifications.
    if ntop>0 then
      setini("System","Video scale[0]","%f,%f",stop/ntop*512.0,stop/ntop*512.0)
      if hlog!=NULL then
        fprintf(hlog,"  Mean TOP magnification    %6.2f um/pixel\n",           \
        stop/ntop*1000.0)
      endif
    endif
    if nbot>0 then
      setini("System","Video scale[1]","%f,%f",sbot/nbot*512.0,sbot/nbot*512.0)
      if hlog!=NULL then
        fprintf(hlog,"  Mean BOTTOM magnification %6.2f um/pixel\n",           \
        sbot/nbot*1000.0)
      endif
    endif
    return 0                           // Report success
  endif
  // Visualize and report error.
  change hinfo text="Scanning problem"
  clear hright
  if badhead>=0 then
    channel=Channelfromhead(badhead)
    Bcsetcam(channel,1)
    oppflash=Getoppflash(badhead)
    SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),             \
      Bcgetbri(channel,1),Bcgetctr(channel,1),(longexp?6:2),0.0)
    x=$LAY.xoffset/1000.0+boardshift
    y=$LAY.yoffset[badhead/2]/1000.0
    sprintf(s,"M @%i[%f,%fH30A%i] %i(Z) NOP",badhead,x,y,acc,badhead^1)
    SERV.Cmdimm(32,s)
    SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
    if illumination==0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",badhead,illtype)
      SERV.Cmdimm(32,s)
    else
      opp=Oppositeheadcam(badhead)
      Oppositexy(x,y,opp,&oppx,&oppy,0.0)
      sprintf(s,"M %i(%f,%fH30) %i(Z) NOP",opp,oppx,oppy,opp^1)
      SERV.Cmdimm(32,s)
      sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",badhead,illtype & 0xC)
      SERV.Cmdimm(32,s)
      sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",opp,illtype)
      SERV.Cmdimm(32,s)
    endif
  endif
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 at 6,30 color=LIGHTRED
  if err==1 then
    if hlog!=NULL fprintf(hlog,"  No answer from tester\n")
    draw text="Timeout!" color=BLACK at 6,60
    draw text="There was no answer from the tester within 10 seconds. "
  else if err==2 then
    if hlog!=NULL fprintf(hlog,"  Unexpected answer from tester\n")
    draw text="Bad answer!" color=BLACK at 6,60
    draw text="Tester returned unexpected answer to the movement command. "
  else if err==3 then
    if hlog!=NULL fprintf(hlog,                                                \
      "  Missing fiducial on rail %i%c\n",badhead/2,badhead & 1?'R':'L')
    draw text="Fiducial is not visible!" color=BLACK at 6,60
    draw text="Calibration procedure was unable to locate the position of the "
    draw text=format("central %s on head ",boardtype==0?"cross":"fiducial")
    draw text=format("%i%c. ",badhead/2,badhead & 1?'R':'L')
  else if err==4 then
    if hlog!=NULL fprintf(hlog,"  Unable to create search model\n")
    draw text="Unable to create model!" color=BLACK at 6,60
    draw text="Calibration procedure was unable to create the image of the "
    draw text=format("central %s on head ",boardtype==0?"cross":"fiducial")
    draw text=format("%i%c. ",badhead/2,badhead & 1?'R':'L')
  else if err==5 then
    if hlog!=NULL fprintf(hlog,                                                \
      "  Unable to measure shift on rail %i%c\n",badhead/2,badhead & 1?'R':'L')
    draw text="Unable to measure shift!" color=BLACK at 6,60
    draw text="Calibration procedure was unable to measure visible shift of "
    draw text=format("the central %s on head ",boardtype==0?"cross":"fiducial")
    draw text=format("%i%c. ",badhead/2,badhead & 1?'R':'L')
  else if err==6 then
    if hlog!=NULL fprintf(hlog,                                                \
      "  Bad magnification on rail %i%c\n",badhead/2,badhead & 1?'R':'L')
    draw text="Bad magnification!" color=BLACK at 6,60
    draw text="Measured optical magnification of the camera on head "
    draw text=format("%i%c is out of expected ",badhead/2,badhead & 1?'R':'L')
    draw text="limits. "
  else if err==7 then
    if hlog!=NULL fprintf(hlog,                                                \
      "  Misadjusted camera on rail %i%c\n",badhead/2,badhead & 1?'R':'L')
    draw text="Misadjusted camera!" color=BLACK at 6,60
    draw text="The shift between camera and needle on head "
    draw text=format("%i%c exceeds 0.5 mm. ",badhead/2,badhead & 1?'R':'L')
    draw text="The needle may disturb recognition, making automatical "
    draw text="scanning unreliable. "
  else if err==8 then
    if hlog!=NULL fprintf(hlog,                                                \
      "  Negative magnification on rail %i%c\n",badhead/2,badhead & 1?'R':'L')
    draw text="Bad magnification!" color=BLACK at 6,60
    draw text="Measured optical magnification of the camera on head "
    draw text=format("%i%c is negative. ",badhead/2,badhead & 1?'R':'L')
    draw text="Probably head camera is defined in layout as " font=MAINFONT
    if ($EXTLAY.hcorientation & (1<<badhead))==0 then
      draw text="HdCam " font=TIMESFONT text="instead of "
      draw font=MAINFONT text="HdCam R " font=TIMESFONT text=". "
    else
      draw text="HdCam R " font=TIMESFONT text="instead of "
      draw font=MAINFONT text="HdCam" font=TIMESFONT text=". "
    endif
  else if err==11 then
    if hlog!=NULL fprintf(hlog,                                                \
      "  Bad central cross on rail %i%c\n",badhead/2,badhead & 1?'R':'L')
    draw text="Bad central fiducial!" color=BLACK at 6,55
    draw text="Correlation for central fiducial viewed by head "
    draw text=format("%i%c is too low. ",badhead/2,badhead & 1?'R':'L')
    draw text="Either calibration board is damaged or misplaced, or "
    draw text="width of lines in setup is invalid. "
  else
    if hlog!=NULL fprintf(hlog,"  Unexpected error\n")
    draw text="Unexpected error!" color=BLACK at 6,60
  endif
  draw text="Press " font=MAINFONT text="Repeat " font=TIMESFONT
  draw text="to repeat measurements, or " font=MAINFONT text="Check "
  draw font=TIMESFONT text="to verify all head cameras manually."
  draw show
  if err==5 || err==6 || err==7 || err==8 || err==11 then
    htable=control CHILD
      window=hright
      position=9,140,RIGHTX-18,130
      limits=RIGHTX-38,ncamera*20+38
      mode=M_VSCROLL
      help="Results of camera offset checking"
      bkcolor=PINK
      size=4096
    endc
    k=30
    draw window=htable font=INFOFONT color=DARKGRAY
    draw at 5,5 to 225,5
    draw at 5,5 to 5,32 at 10,26 text="Hd"
    draw at 35,5 to 35,32 at 38,26 text="Detected error"
    draw at 225,5 to 225,32
    draw at 5,k+2 to 225,k+2
    draw font=TIMESFONT
    for i=0,i<$LAY.nfing*2,i++ do
      if (headcams & (1<<i))==0 continue
      k=k+20
      draw color=DARKGRAY
      draw at 5,k-18 to 5,k+2 to 225,k+2 to 225,k-18
      draw at 35,k-18 to 35,k+2
      draw at 8,k color=BLACK
      draw text=format("%2i%c",i/2,(i & 1?'R':'L'))
      draw at 38,k
      if headerr[i]==0 then
        draw color=DARKGRAY text="OK"
      else
        draw color=LIGHTRED text=errmsg[i]
      endif
    enddo
    draw show
    setfocus htable
  endif
  if err==7 then
    hrepeat=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name="Repeat"
      help="Press to repeat magnification measurements"
    endc
    hrecheck=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="Check"
      help="Press to verify head cameras"
    endc
    hcont=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="Continue"
      help="Press to continue at your own risk"
    endc
  else
    hrepeat=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Repeat"
      help="Press to repeat magnification measurements"
    endc
    hrecheck=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Check"
      help="Press to verify head cameras"
    endc
    hcont=NULL
  endif
  while 1 do
    if Pressed(hexit) then
      return -1                        // Operator interrupted calibration
    else if badhead>=0 && Bcupdate(1)!=0 then
      channel=Channelfromhead(badhead)
      Bcsetcam(channel,1)
      oppflash=Getoppflash(badhead)
      SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),           \
      Bcgetbri(channel,1),Bcgetctr(channel,1),(longexp?6:2),0.0)
    else if Pressed(hrepeat) then
      goto repeat
    else if Pressed(hrecheck) then
      return 1
    else if hcont!=NULL && (Pressed(hcont) || autoconfirm) then
      Logcontinue()
      err=0
      goto acceptadjustment
    endif
    wait
  enddo
end

// Measures optical magnification of dedicated video cameras and determines
// width of the cross best suitable for for video calibration. Returns -1 if
// operator interrupted the calibration, 0 on success or when video calibration
// is not requested, 1 if different type of calibration must be selected, 2 to
// change placement of calibration board and 3 to find centers manually.
function int Videomagnification()
  int i,j,n,cam,opp,nfing,step,nfound,modelx,modely,err[2]
  int dummy,fidtype[2]
  char s[256],errmsg[2][80]
  float found[NFID][3]                 // Found fiducials
  float leftx,lefty,stepx,stepy,f,corrmax,videocorr[2],fiddif
  float crossx,crossy
  handle hview,hlivevideo
  handle hrepeat,hreplace,hfind
  handle model
  change hinfo limits=0,0
  clear hleft
  if cameras==0 return 0               // Works only with dedicated cameras
  if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||              \
    testertype==TT_A5L || testertype==TT_A6 ||                                 \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8)) || boardtype==2                   \
  then
    fiddif=0.85                        // Fiducials are rather ambiguous
  else
    fiddif=0.75                        // Old good cross
  endif
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  Bccreate(hview,-1,-1,-1,1,0)
repeatmag:
  change hinfo text="Measuring magnification"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now determining magnifications of video cameras. This step is "
  draw text="necessary to increase accuracy and reduce calibration time."
  draw show
  if demo then
    delay 1000
    mminpixelx[0]=0.015                // Exact value is unimportant
    mminpixely[0]=0.015
    mminpixelx[1]=0.015
    mminpixely[1]=0.015
    return 0
  endif
  nfing=$LAY.nfing
  for i=0,i<2,i++ do
    err[i]=0
    sprintf(errmsg[i],"Success")
  enddo
  crossx=$LAY.xoffset/1000.0
  while crossx<videofromx+5.0 || crossx<fromxloc do
    crossx=crossx+xstep
  enddo
  while crossx>videotox-5.0 || crossx>toxloc do
    crossx=crossx-xstep
  enddo
  crossy=$LAY.yoffset[nfing]/1000.0
  // We don't know in advance which optical magnification to expect. There are
  // several testers with non-standard optics, so the best we can do is to make
  // no assumptions, except that viewed area is between 2 and 10 mm high, and
  // simply measure the magnification.
  i=0; step=0
  if testertype==TT_S3 then            // Expecting high resolution camera
    stepx=0.4
    stepy=0.4
  else
    stepx=1.0
    stepy=0.7
  endif
  while i<2 do
    if Pressed(hexit) return -1        // Operator interrupted calibration
    wait
    if (cameras & (1<<i))==0 || err[i]!=0 then
      i++; step=0; continue            // Camera absent, excluded or has error
    endif
    cam=nfing*2+i
    opp=nfing*2+(1-i)
    switch (step)
    case 0:                            // Move to center of calibration board
      Bcsetcam(i,1)
      SYS.Videoangle(hlivevideo,i,0,Getzoom(i),                                \
        Bcgetbri(i,1),Bcgetctr(i,1),longexp?6:2,0.0)
      n=sprintf(s,"M %i(%f,%fA%i) ",                                           \
        cam,crossx+videocorrectx[i],crossy+videocorrecty[i],acc)
      if illumination!=0 n=n+sprintf(s+n,"%i(%f,%fA255) ",                     \
        opp,crossx+throughdx+videocorrectx[1-i],                               \
        crossy+throughdy+videocorrecty[1-i])
      sprintf(s+n,"NOP")
      $A[i].length=0
      SERV.Cmdimm(i,s)
      if testertype!=TT_S3 && cameras==0x03 && illumination==0 then
        sprintf(s,"M %i(%f,%fA255) NOP",opp,videotox,crossy)
        SERV.Cmdimm(32,s)
      endif
      step++
    case 1:                            // Wait for center and define fiducial
      if $A[i].length==0 then
        continue                       // Still no answer from head
      else if $A[i].answer!=S_READY then
        sprintf(errmsg[i],"Invalid answer")
        err[i]=1; continue             // Invalid answer
      else
        if illumination!=0 then        // Shinethrough calibration
          sprintf(s,"OUTPORT %i,0",0x2004+i )
          SERV.Cmdimm(32,s)
          sprintf(s,"OUTPORT %i,1",0x2004+1-i )
          SERV.Cmdimm(32,s)
        endif
        SYS.Nextframe(i)
        Delay(500)                     // At point, wait and define fiducial
        if cameramode==0 SYS.Nextframe(i)
        if model!=NULL then
          SYS.Deletemodel(model); model=NULL
        endif
        if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||        \
          testertype==TT_A5L || testertype==TT_A6 ||                           \
          testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||       \
          testertype==TT_A7 || testertype==TT_A8)) ||                          \
          boardtype==2                                                         \
        then
          modelx=videowidth[i]*3/4
          modely=videoheight[i]*3/4
        else
          modelx=videowidth[i]/2
          modely=videoheight[i]/2
        endif
        modelx=Min(1000,modelx)
        modely=Min(1000,modely)
        model=SYS.Videomodel(i,videowidth[i]/2,videoheight[i]/2,               \
          modelx,modely,MODEL_SMART|MODEL_BIG)
        if model==NULL then
          sprintf(errmsg[i],"Unable to create video model")
          err[i]=2; continue           // Unable to create model
        endif
        step++
      endif
    case 2:                            // Move to bottom left point
      n=sprintf(s,"M %i(%f,%fA%i) ",                                           \
        cam,crossx-stepx+videocorrectx[i],crossy-stepy+videocorrecty[i],acc)
      if illumination!=0 n=n+sprintf(s+n,"%i(%f,%fA255) ",opp,                 \
        crossx+throughdx-stepx+videocorrectx[1-i],                             \
        crossy+throughdy-stepy+videocorrecty[1-i])
      sprintf(s+n,"NOP")
      $A[i].length=0
      SERV.Cmdimm(i,s)
      step++
    case 3:                            // Wait for bottom left and recognize
      if $A[i].length==0 then
        continue                       // Still no answer from head
      else if $A[i].answer!=S_READY then
        sprintf(errmsg[i],"Invalid answer")
        err[i]=1; continue             // Invalid answer
      else
        if illumination!=0 then        // Shinethrough calibration
          sprintf(s,"OUTPORT %i,0",0x2004+i )
          SERV.Cmdimm(32,s)
          sprintf(s,"OUTPORT %i,1",0x2004+1-i )
          SERV.Cmdimm(32,s)
        endif
        SYS.Nextframe(i)
        Delay(500)                     // At point, wait and recognize
        if cameramode==0 SYS.Nextframe(i)
        found[1,2]=0
        nfound=SYS.Recognize(model,0,0,videowidth[i],videoheight[i],found)
        nfound=Correctfound(found,nfound)
        if nfound==0 then              // Unable to recognize cross
          sprintf(errmsg[i],"Bottom left fiducial not found")
          err[i]=3; continue
        else if found[0,2]<450 then
          sprintf(errmsg[i],"Bottom left correlation low (%i)",found[0,2])
          err[i]=3; continue
        else if found[1,2]>found[0,2]*fiddif then
          sprintf(errmsg[i],"Ambiguous bottom left fiducial (%i,%i)",          \
            found[0,2],found[1,2])
          err[i]=3; continue
        endif
        leftx=found[0,0]
        lefty=found[0,1]
        step++
      endif
    case 4:                            // Move to top right point
      n=sprintf(s,"M %i(%f,%fA%i) ",                                           \
        cam,crossx+stepx+videocorrectx[i],crossy+stepy+videocorrecty[i],acc)
      if illumination!=0 n=n+sprintf(s+n,"%i(%f,%fA255) ",opp,                 \
        crossx+throughdx+stepx+videocorrectx[1-i],                             \
        crossy+throughdy+stepy+videocorrecty[1-i])
      sprintf(s+n,"NOP")
      $A[i].length=0
      SERV.Cmdimm(i,s)
      step++
    case 5:                            // Wait for top right and recognize
      if $A[i].length==0 then
        continue                       // Still no answer from head
      else if $A[i].answer!=S_READY then
        sprintf(errmsg[i],"Invalid answer")
        err[i]=1; continue             // Invalid answer
      else
        if illumination!=0 then        // Shinethrough calibration
          sprintf(s,"OUTPORT %i,0",0x2004+i )
          SERV.Cmdimm(32,s)
          sprintf(s,"OUTPORT %i,1",0x2004+1-i )
          SERV.Cmdimm(32,s)
        endif
        SYS.Nextframe(i)
        Delay(500)                     // At point, wait and recognize
        if cameramode==0 SYS.Nextframe(i)
        found[1,2]=0
        nfound=SYS.Recognize(model,0,0,videowidth[i],videoheight[i],found)
        nfound=Correctfound(found,nfound)
        if nfound==0 then              // Unable to recognize cross
          sprintf(errmsg[i],"Top right fiducial not found")
          err[i]=3; continue
        else if found[0,2]<450 then
          sprintf(errmsg[i],"Top right correlation low (%i)",found[0,2])
          err[i]=3; continue
        else if found[1,2]>found[0,2]*fiddif then
          sprintf(errmsg[i],"Ambiguous top right fiducial (%i,%i)",            \
            found[0,2],found[1,2])
          err[i]=3; continue
        endif
        SYS.Deletemodel(model); model=NULL
        // Convert measured distances to pixels/millimeter and verify. We
        // expect that magnification lies between 0.4 and 10 mm per 512 pixels.
        leftx=Abs(leftx-found[0,0])/(stepx*2.0)
        lefty=Abs(lefty-found[0,1])/(stepy*2.0)
        if leftx>512/0.4 || leftx<512/10.0 ||                                  \
          lefty>512/0.4 || lefty<512/10.0 ||                                   \
          leftx/lefty<0.9 || lefty/leftx<0.9                                   \
        then
          sprintf(errmsg[i],"Invalid magnification (X=%.3f, Y=%.3f pixel/mm)", \
            leftx,lefty)
          err[i]=4; continue           // Invalid magnifications
        endif
        mminpixelx[i]=1.0/leftx
        mminpixely[i]=1.0/lefty
        // Save magnification to .ini file so that other programs can use it.
        sprintf(s,"Video scale[%i]",i)
        setini("System",s,"%f,%f",mminpixelx[i]*512.0,mminpixely[i]*512.0)
      endif
      step++
    case 6:                            // Move to center of calibration board
      n=sprintf(s,"M %i(%f,%fA%i) ",                                           \
        cam,crossx+videocorrectx[i],crossy+videocorrecty[i],acc)
      if illumination!=0 n=n+sprintf(s+n,"%i(%f,%fA255) ",                     \
        opp,crossx+throughdx+videocorrectx[1-i],                               \
        crossy+throughdy+videocorrecty[1-i])
      sprintf(s+n,"NOP")
      $A[i].length=0
      SERV.Cmdimm(i,s)
      step++
    case 7:                            // Wait for center and find best cross
      if $A[i].length==0 then
        continue                       // Still no answer from head
      else if $A[i].answer!=S_READY then
        sprintf(errmsg[i],"Invalid answer")
        err[i]=1; continue             // Invalid answer
      else
        if illumination!=0 then        // Shinethrough calibration
          sprintf(s,"OUTPORT %i,0",0x2004+i )
          SERV.Cmdimm(32,s)
          sprintf(s,"OUTPORT %i,1",0x2004+1-i )
          SERV.Cmdimm(32,s)
        endif
        SYS.Nextframe(i)
        Delay(500)                     // At point, wait and define fiducial
        if cameramode==0 SYS.Nextframe(i)
        corrmax=0.0
        videofactor[i]=1.0
        videocorr[i]=0.0
        fidtype[i]=-1
        for f=0.6,f<=1.5,f=f+0.1 do
          if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||      \
            testertype==TT_A5L || testertype==TT_A6 || testertype==TT_A7 ||    \
            testertype==TT_A8 || ((testertype==TT_S1 || testertype==TT_S3) &&  \
            $LAY.rightlimit-$LAY.leftlimit<450000))) || boardtype==2           \
          then
            fidtype[i]=(headcamfidtype==2?SYNT_RIGHT:SYNT_LEFT)
            model=Model(i,fidtype[i],                                          \
            0.7*2.0/(mminpixelx[i]+mminpixely[i]),                             \
            0.3*2.0/(mminpixelx[i]+mminpixely[i])*f,                           \
            0.0,0.0,                                                           \
            (illumination==0 && (boardtype==0 || testertype==TT_S3)?           \
            WHITEONBLACK:BLACKONWHITE))
          else
            fidtype[i]=SYNT_CROSS
            model=Model(i,fidtype[i],                                          \
            Min(videoheight[i],videowidth[i])*0.25,                            \
            linewidth*2.0/(mminpixelx[i]+mminpixely[i])*f,                     \
            0.0,0.0,                                                           \
            (illumination==0 && (boardtype==0 || testertype==TT_S3)?           \
            WHITEONBLACK:BLACKONWHITE))
          endif
          if model==NULL continue      // Just a precaution
          nfound=SYS.Recognize(model,0,0,videowidth[i],videoheight[i],found)
          if nfound>0 && found[0,2]>corrmax then
            videofactor[i]=f
            videocorr[i]=found[0,2]
            corrmax=found[0,2]
          endif
          SYS.Deletemodel(model); model=NULL
        enddo
        if corrmax<=500.0 then
          sprintf(errmsg[i],"Low correlation in center (%i at factor %.1f)",   \
            corrmax,videofactor[i])
          err[i]=5; continue
        endif
        // If camera stays in the way for opposite camera, move it away.
        if testertype!=TT_S3 && cameras==0x03 && illumination==0 then
          sprintf(s,"M %i(%f,%fA255) NOP",                                     \
            cam,videotox,crossy)
          SERV.Cmdimm(32,s)
        endif
        i++; step=0                    // Proceed with next camera
      endif
    endsw
    if Bcupdate(1)!=0 then
      SYS.Videoangle(hlivevideo,i,0,Getzoom(i),                                \
      Bcgetbri(i,1),Bcgetctr(i,1),longexp?6:2,0.0)
    endif
  enddo
  if hlog!=NULL && cameras!=0 then
    fprintf(hlog,"Measured magnifications and factors for video cameras:\n")
    if cameras & 1 then
      fprintf(hlog,"  Magnification of  TOP camera:     ")
      if err[0]==0 then
        fprintf(hlog,"X=%5.2f, Y=%5.2f um/pixel\n",                            \
        mminpixelx[0]*1000.0,mminpixely[0]*1000.0)
        fprintf(hlog,                                                          \
        "  Fiducial type for TOP camera:     %s\n",                            \
        (fidtype[0]<0?"Unknown":                                               \
        (fidtype[0]==SYNT_CROSS?"SYNT_CROSS":                                  \
        (fidtype[0]==SYNT_LEFT?"SYNT_LEFT":"SYNT_RIGHT"))))
        fprintf(hlog,                                                          \
        "  Fiducial size for TOP camera:     Factor %.1f (correlation %3i)\n", \
        videofactor[0],videocorr[0])
      else
        fprintf(hlog,"%s\n",errmsg[0])
      endif
    endif
    if cameras & 2 then
      fprintf(hlog,"  Magnification of  BOTTOM camera:  ")
      if err[1]==0 then
        fprintf(hlog,"X=%5.2f, Y=%5.2f um/pixel\n",                            \
        mminpixelx[1]*1000.0,mminpixely[1]*1000.0)
        fprintf(hlog,                                                          \
        "  Fiducial type for BOTTOM camera:  %s\n",                            \
        (fidtype[1]<0?"Unknown":                                               \
        (fidtype[1]==SYNT_CROSS?"SYNT_CROSS":                                  \
        (fidtype[1]==SYNT_LEFT?"SYNT_LEFT":"SYNT_RIGHT"))))
        fprintf(hlog,                                                          \
        "  Fiducial size for BOTTOM camera:  Factor %.1f (correlation %3i)\n", \
        videofactor[1],videocorr[1])
      else
        fprintf(hlog,"%s\n",errmsg[1])
      endif
    endif
    if err[0]!=0 || err[1]!=0 then
      fprintf(hlog,"Magnification unreliable (code %i / %i)\n",err[0],err[1])
    endif
  endif
  if model!=NULL SYS.Deletemodel(model)
  if err[0]==0 && err[1]==0 return 0   // Success
  change hinfo text="Scanning problem"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED text="Unable to measure magnification.\n\n"
  draw color=BLACK
  for i=0,i<2,i++ do
    if (cameras & (1<<i))==0 continue
    draw text=format("%s camera: %s\n\n",i==0?"Top":"Bottom",errmsg[i])
  enddo
  draw text="Press " font=MAINFONT text="Repeat " font=TIMESFONT
  draw text="to repeat measurements, or " font=MAINFONT text="Replace "
  draw font=TIMESFONT text="to change placement of calibration board."
  if err[0]<=1 && err[1]<=1 then
    hrepeat=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Repeat"
      help="Press to repeat magnification measurements"
    endc
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Replace"
      help=""
    endc
    hfind=NULL
  else
    draw text=" If cross is shifted or not visible, you can " font=MAINFONT
    draw text="Find " font=TIMESFONT text="it manually."
    hrepeat=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name="Repeat"
      help="Press to repeat magnification measurements"
    endc
    hreplace=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="Replace"
      help=""
    endc
    hfind=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="Find"
      help="Press to find central crosses manually"
    endc
  endif
  draw show
  while 1 do
    if Pressed(hexit) then
      return -1                        // Operator interrupted calibration
    else if Bcupdate(1)!=0 then
      SYS.Videoangle(hlivevideo,i,0,Getzoom(i),                                \
      Bcgetbri(i,1),Bcgetctr(i,1),longexp?6:2,0.0)
    else if Pressed(hrepeat) then
      goto repeatmag
    else if Pressed(hreplace) then
      return 2
    else if hfind!=NULL && Pressed(hfind) then
      return 3
    endif
    wait
  enddo
end

// Defines fiducials for dedicated video cameras. If definealt is not 0, or if
// tester is S3, defines optional alternative fiducials. If color is
// WHITEONBLACK or BLACKONWHITE, sets specified colour, otherwise uses default.
// Returns 0 on success, -1 if operator interrupted calibration, and 1 if new
// type of calibration should be selected.
function int Definefiducials(int definealt,int color)
  int i,err
  handle hok
  if demo return 0
  // Delete old fiducials, if any.
  for i=0,i<2,i++ do
    if videomodel[i]!=NULL then
      SYS.Deletemodel(videomodel[i])
      videomodel[i]=NULL
    endif
    if videoaltmodel[i]!=NULL then
      SYS.Deletemodel(videoaltmodel[i])
      videoaltmodel[i]=NULL
    endif
  enddo
  if color!=WHITEONBLACK && color!=BLACKONWHITE then
    if illumination==0 && (boardtype==0 || testertype==TT_S3) then
      color=WHITEONBLACK
    else
      color=BLACKONWHITE
    endif
  endif
  // S3 testers can scan crosses on glass, due to very low depth of field.
  if testertype==TT_S3 && (boardtype==1 || boardtype==2) definealt=1
  // Define new fiducials.
  if cameras & 0x01 then
    if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||            \
      testertype==TT_A5L || testertype==TT_A6 ||                               \
      ((testertype==TT_S1 || testertype==TT_S3) &&                             \
      $LAY.rightlimit-$LAY.leftlimit<450000) ||                                \
      (testertype==TT_S3 && testersides==0x01) ||                              \
      testertype==TT_S2 || testertype==TT_A7 || testertype==TT_A8)) ||         \
      boardtype==2                                                             \
    then
      videomodel[0]=Model(0,                                                   \
      (headcamfidtype==2?SYNT_RIGHT:SYNT_LEFT),                                \
      0.7*2.0/(mminpixelx[0]+mminpixely[0]),                                   \
      0.3*2.0/(mminpixelx[0]+mminpixely[0])*videofactor[0],                    \
      0.0,0.0,color)
      if definealt then
        videoaltmodel[0]=Model(0,SYNT_CROSS,                                   \
        Min(videoheight[0],videowidth[0])*0.25,                                \
        linewidth*2.0/(mminpixelx[0]+mminpixely[0])*videofactor[0],            \
        0.0,0.0,color)
      endif
    else
      videomodel[0]=Model(0,SYNT_CROSS,                                        \
      Min(videoheight[0],videowidth[0])*0.25,                                  \
      linewidth*2.0/(mminpixelx[0]+mminpixely[0])*videofactor[0],              \
      0.0,0.0,color)
    endif
    if videomodel[0]==NULL err=1
  endif
  if cameras & 0x02 then
    if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||            \
      testertype==TT_A5L || testertype==TT_A6 ||                               \
      ((testertype==TT_S1 || testertype==TT_S3) &&                             \
      $LAY.rightlimit-$LAY.leftlimit<450000) ||                                \
      testertype==TT_S2 || testertype==TT_A7 || testertype==TT_A8)) ||         \
      boardtype==2                                                             \
    then
      videomodel[1]=Model(1,                                                   \
      (headcamfidtype==2?SYNT_RIGHT:SYNT_LEFT),                                \
      0.7*2.0/(mminpixelx[1]+mminpixely[1]),                                   \
      0.3*2.0/(mminpixelx[1]+mminpixely[1])*videofactor[1],                    \
      0.0,0.0,color)
      if definealt then
        videoaltmodel[1]=Model(1,SYNT_CROSS,                                   \
        Min(videoheight[1],videowidth[1])*0.25,                                \
        linewidth*2.0/(mminpixelx[1]+mminpixely[1])*videofactor[1],            \
        0.0,0.0,color)
      endif
    else
      videomodel[1]=Model(1,SYNT_CROSS,                                        \
      Min(videoheight[1],videowidth[1])*0.25,                                  \
      linewidth*2.0/(mminpixelx[1]+mminpixely[1])*videofactor[1],              \
      0.0,0.0,color)
    endif
    if videomodel[1]==NULL err=1
  endif
  if err==0 return 0
  change hinfo limits=0,0
  change hinfo text="Unable to define fiducials"
  if hlog!=NULL fprintf(hlog,"ERROR: Unable to define fiducials\n")
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="Pattern recognition module was unable to define fiducials. "
  draw color=BLACK text="This makes optical calibration impossible. This "
  draw text="error is unexpected. Please attempt to change calibration "
  draw text="parameters, or restart OllyTest."
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-160)/2,USERY,160,24
    name="Change parameters"
    help="Press to change calibration parameters"
  endc
  while 1 do
    if Pressed(hok) return 1
    if Pressed(hexit) return -1
    wait
  enddo
end

// Returns percent of calibrated crosses for the slowest camera or, if
// shinethrough is requested, percent of calibrated crosses for the whole
// tester. Following global variables must be preset before calling this
// routine: videowidth, videoheight, videomodel.
function int Videoscan(handle hlivevideo)
  int i,k,n,cam,opp,ncal,next,nfound,nalt,dummy
  float r,x,y,x0,x1,y0,y1,dx[4],dy[4],tx,ty,px,py,fiddif
  float found[NFID][3],fnalt[NFID][3],correl
  char s[256],t[256]
  for i=0,i<2,i++ do
    if (cameras & (1<<i))==0 continue  // This camera is absent
    cam=$LAY.nfing*2+i
    opp=$LAY.nfing*2+(1-i)
    ncal=c[cam].ncal
    next=c[cam].next
    if ncal==0 || next>=ncal then      // This camera is already calibrated
      if ncal>0 && illumination==0 && testertype!=TT_S3 &&                     \
        c[cam].infield && demo==0 then
        sprintf(s,"M %i(Z) NOP",cam)   // Camera finished calibration
        SERV.Cmdimm(32,s)
      endif
      c[cam].infield=0
      continue
    endif
    if (illumination!=0 || ($LAY.config & LC_TYPEMASK)==LC_S3) && i==1 &&      \
      c[opp].ncal>0 && c[opp].next<c[opp].ncal                                 \
      continue                         // This camera is in slave mode now
    // In demo mode, emulate scanning results. Each 20th point is bad.
    if demo then
      c[cam].xm[next]=c[cam].xa[next]+                                         \
        Random(accuracy)+Random(accuracy)-Random(accuracy)-Random(accuracy)
      c[cam].ym[next]=c[cam].ya[next]+                                         \
        Random(accuracy)+Random(accuracy)-Random(accuracy)-Random(accuracy)
      if Random(20)==0 then            // Bad point
        c[cam].xm[next]=c[cam].xm[next]+Random(accuracy*12)-accuracy*6
        c[cam].ym[next]=c[cam].ym[next]+Random(accuracy*12)-accuracy*6
      endif
      c[cam].err[next]=0
      c[cam].next=next+1
      continue
    endif
    // Process answer from the tester.
    if c[cam].pending==0 then
      ;                                // We expect no answer
    else if c[cam].pending==2 then
      if cameramode<2 && Time()<c[cam].timer then
        continue                       // Timeout pending
      endif
      c[cam].pending=0
      // OK to search for cross.
      if illumination!=0 then          // Shinethrough calibration
        sprintf(s,"OUTPORT %i,0",0x2004+i )
        SERV.Cmdimm(32,s)
        sprintf(s,"OUTPORT %i,1",0x2004+1-i )
        SERV.Cmdimm(32,s)
      endif
      if hlivevideo!=NULL then
        Bcsetcam(i,1)
        SYS.Videoangle(hlivevideo,i,0,Getzoom(i),                              \
          Bcgetbri(i,1),Bcgetctr(i,1),longexp?6:2,0.0)
        ;
      endif
      SYS.Nextframe(i)
      Delay(250)
      if cameramode==0 SYS.Nextframe(i)
      found[1,2]=0
      nfound=SYS.Recognize(                                                    \
        videomodel[i],0,0,videowidth[i],videoheight[i],found)
      if videoaltmodel[i]!=NULL then
        nalt=SYS.Recognize(                                                    \
          videoaltmodel[i],0,0,videowidth[i],videoheight[i],fnalt)
        if nalt>0 && (nfound<=0 || fnalt[0,2]>found[0,2]) then
          nfound=nalt
          Memcpy(found,fnalt,Sizeof(found))
        endif
      endif
      nfound=Correctfound(found,nfound)
      if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||          \
        testertype==TT_A5L || testertype==TT_A6 ||                             \
        testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||         \
        testertype==TT_A7 || testertype==TT_A8)) ||                            \
        boardtype==2                                                           \
      then
        fiddif=0.85                    // Fiducials are rather ambiguous
      else
        fiddif=0.75                    // Old good cross
      endif
      if nfound>0 && found[0,2]>350 &&                                         \
        (nfound==1 || found[1,2]<found[0,2]*fiddif) then
        // Cross found, check whether accuracy is sufficient.
        c[cam].step=5                  // Cross visible, don't jump around
        found[0,0]=(found[0,0]-videowidth[i]/2)*mminpixelx[i]
        found[0,1]=(found[0,1]-videoheight[i]/2)*mminpixely[i]
        if i==1 found[0,0]=-found[0,0] // Mirror X for the bottom camera
        r=Max(Abs(found[0,0]),Abs(found[0,1]))
        if r<Max(accuracy,0.002)*(cameramode==2?8.0:4.0) then
          // Accuracy sufficient, accept. In precise camera mode, I repeat
          // video recognition once again to improve the accuracy.
          tx=found[0,0]
          ty=found[0,1]
          correl=found[0,2]
          if cameramode==0 then
            Delay(50)
            SYS.Nextframe(i)
            found[1,2]=0
            nfound=SYS.Recognize(                                              \
              videomodel[i],0,0,videowidth[i],videoheight[i],found)
            if videoaltmodel[i]!=NULL then
              nalt=SYS.Recognize(                                              \
                videoaltmodel[i],0,0,videowidth[i],videoheight[i],fnalt)
              if nalt>0 && (nfound<=0 || fnalt[0,2]>found[0,2]) then
                nfound=nalt
                Memcpy(found,fnalt,Sizeof(found))
              endif
            endif
            nfound=Correctfound(found,nfound)
            if nfound>0 && found[0,2]>350 &&                                   \
              (nfound==1 || found[1,2]<found[0,2]*fiddif) then
              found[0,0]=(found[0,0]-videowidth[i]/2)*mminpixelx[i]
              found[0,1]=(found[0,1]-videoheight[i]/2)*mminpixely[i]
              if i==1 found[0,0]=-found[0,0]
              tx=(found[0,0]+tx)/2.0
              ty=(found[0,1]+ty)/2.0
              correl=(found[0,2]+correl)/2.0
            endif
          endif
          c[cam].xm[next]=c[cam].xm[next]+tx
          c[cam].ym[next]=c[cam].ym[next]-ty
          c[cam].err[next]=0
          c[cam].step=0
          c[cam].attempt=0
          c[cam].errmsg[0]='\0'
          c[cam].next=next+1
          if hlog!=NULL then
            fprintf(hlog,"  V%s: %8.3f %8.3f  %7.4f %7.4f   Corr=%4.0f\n",     \
            (cam & 1?"Bot":"Top"),c[cam].xa[next],c[cam].ya[next],             \
            c[cam].xm[next]-c[cam].xa[next],c[cam].ym[next]-c[cam].ya[next],   \
            correl)
          endif
          // If correction is requested and first 4 points are calibrated,
          // recalculate expected coordinates of all remaining points.
          if (c[cam].mode & CM_CORRECT)!=0 && c[cam].next==4 &&                \
            c[cam].err[0]==0 && c[cam].err[1]==0 && c[cam].err[2]==0 &&        \
            c[cam].err[3]==0 then
            x0=c[cam].xa[0]
            x1=c[cam].xa[3]
            y0=c[cam].ya[0]
            y1=c[cam].ya[1]
            for i=0,i<4,i++ do
              dx[i]=c[cam].xm[i]-c[cam].xa[i]
              dy[i]=c[cam].ym[i]-c[cam].ya[i]
            enddo
            for i=4,i<ncal,i++ do
              px=(c[cam].xa[i]-x0)/(x1-x0)
              py=(c[cam].ya[i]-y0)/(y1-y0)
              c[cam].xm[i]=c[cam].xa[i]+                                       \
                (dx[0]*(1.0-px)+dx[3]*px)*(1.0-py)+(dx[1]*(1.0-px)+dx[2]*px)*py
              c[cam].ym[i]=c[cam].ya[i]+                                       \
                (dy[0]*(1.0-px)+dy[3]*px)*(1.0-py)+(dy[1]*(1.0-px)+dy[2]*px)*py
              ;
            enddo
          else if (c[cam].mode & CM_CORRXY)!=0 && c[cam].err[next]==0 then
            dx[0]=c[cam].xm[next]-c[cam].xa[next]
            dy[0]=c[cam].ym[next]-c[cam].ya[next]
            for i=next+1,i<ncal,i++ do
              c[cam].xm[i]=c[cam].xa[i]+dx[0]
              c[cam].ym[i]=c[cam].ya[i]+dy[0]
            enddo
            c[cam].mode=c[cam].mode & (~CM_CORRXY)
          endif
        else if c[cam].attempt>=5 then
          // Uh-oh, too many attempts without success.
          c[cam].err[next]=1
          c[cam].step=0
          c[cam].attempt=0
          if hlog!=NULL then
            fprintf(hlog,"  V%s: %8.3f %8.3f  Not calibrated (attempts)\n",    \
            (cam & 1?"Bot":"Top"),c[cam].xa[next],c[cam].ya[next])
          endif
          c[cam].next=next+1
        else
          // Another step is necessary to reach requested accuracy.
          c[cam].xm[next]=c[cam].xm[next]+found[0,0]
          c[cam].ym[next]=c[cam].ym[next]-found[0,1]
          c[cam].attempt=c[cam].attempt+1
        endif
      else if c[cam].step>=5 then
        // No cross in the vicinity.
        c[cam].err[next]=1
        c[cam].step=0
        c[cam].attempt=0
        if hlog!=NULL then
          fprintf(hlog,"  V%s: %8.3f %8.3f  Not calibrated (no cross)\n",      \
          (cam & 1?"Bot":"Top"),c[cam].xa[next],c[cam].ya[next])
        endif
        c[cam].next=next+1
      else
        // Cross was not found or is unreliable, try another coordinate.
        c[cam].step=c[cam].step+1
        if c[cam].step==1 || c[cam].step==4 then
          c[cam].xm[next]=c[cam].xa[next]-videowidth[i]/3.0*mminpixelx[i]
        else
          c[cam].xm[next]=c[cam].xa[next]+videowidth[i]/3.0*mminpixelx[i]
        endif
        if c[cam].step==1 || c[cam].step==2 then
          c[cam].ym[next]=c[cam].ya[next]-videoheight[i]/3.0*mminpixely[i]
        else
          c[cam].ym[next]=c[cam].ya[next]+videoheight[i]/3.0*mminpixely[i]
        endif
        c[cam].attempt=0
      endif
      continue
    else if $A[i].length<5 then
      continue                         // Still no answer from head
    else if $A[i].answer==S_READY then
      c[cam].pending=2                 // At point, wait for rest
      c[cam].timer=Time()+(cameramode==0?750:150)
      continue
    else
      c[cam].pending=0                 // Movement failed, exclude point
      c[cam].err[next]=1
      c[cam].step=0
      c[cam].attempt=0
      if hlog!=NULL then
        fprintf(hlog,"  V%s: %8.3f %8.3f  Not calibrated (movement failed)\n", \
        (cam & 1?"Bot":"Top"),c[cam].xa[next],c[cam].ya[next])
      endif
      c[cam].next=next+1
      continue
    endif
    // Start next camera movement, if possible.
    x=c[cam].xm[next]
    y=c[cam].ym[next]
    if cratefeatures & CF_NANOMETER then
      // Request positioning with nanometer accuracy.
      n=sprintf(s,"M %i:(%.6f,%.6fA%i) ",cam,x,y,acc)
    else
      n=sprintf(s,"M %i(%f,%fA%i) ",cam,x,y,acc)
    endif
    if illumination==0 && c[cam].current!=next && c[opp].infield!=0 &&         \
      c[opp].ncal>0 && c[opp].next<c[opp].ncal &&                              \
      Abs(c[opp].xa[c[opp].next]-c[cam].xa[next])<videosafedist &&             \
      Abs(c[opp].ya[c[opp].next]-c[cam].ya[next])<videosafedist                \
    then
      // Opposite camera in the vicinity! Bottom camera must wait.
      if cam==$LAY.nfing*2+1 continue
      // To move top camera, place bottom in safe position.
      for k=0,k<c[opp].ncal,k++ do
        if Abs(c[opp].xa[k]-c[cam].xa[next])>=2.0*videosafedist ||             \
        Abs(c[opp].ya[k]-c[cam].ya[next])>=2.0*videosafedist break
      enddo
      if k>=c[opp].ncal continue       // No safe position for bottom camera
      n=n+sprintf(s+n,"%i(%f,%fA255) ",opp,c[opp].xa[k],c[opp].ya[k])
    else if illumination!=0 then
      n=n+sprintf(s+n,"%i(%f,%fA255) ",opp,x+throughdx,y+throughdy)
    endif
    sprintf(s+n,"NOP")
    // If approaching from the defined direction is requested, make 20 mm step.
    k=c[cam].scandir[next]
    if k!=0 then
      switch k
      case 1:  tx= 1.0; ty= 0.0
      case 2:  tx= 1.0; ty=-1.0
      case 3:  tx= 0.0; ty=-1.0
      case 4:  tx=-1.0; ty=-1.0
      case 5:  tx=-1.0; ty= 0.0
      case 6:  tx=-1.0; ty= 1.0
      case 7:  tx= 0.0; ty= 1.0
      case 8:  tx= 1.0; ty= 1.0
      default: tx= 0.0; ty= 0.0
      endsw
      tx=Max(videofromx+0.1,Min(x+c[cam].scandist*tx,videotox-0.1))
      ty=Max(videofromy+0.1,Min(y+c[cam].scandist*ty,videotoy-0.1))
      sprintf(t,"M %i(%f,%fA255) NOP",cam,tx,ty)
      SERV.Cmdimm(32,t)
    endif
    $A[i].length=0
    SERV.Cmdimm(i,s)
    c[cam].pending=1
    c[cam].infield=1
    c[cam].current=next
  enddo
  cam=$LAY.nfing*2
  opp=$LAY.nfing*2+1
  if c[cam].ncal==0 && c[opp].ncal==0 then
    // Nothing to calibrate.
    return 0
  else if illumination!=0 || ($LAY.config & LC_TYPEMASK)==LC_S3 then
    // Calculate percent of executed tasks for shinethrough or S3 mode.
    i=0
    if c[cam].ncal>0 i=c[cam].next
    if c[opp].ncal>0 i=i+c[opp].next
    i=i*100/(c[cam].ncal+c[opp].ncal)
  else
    // Calculate percent of executed tasks for parallel mode.
    i=100
    if c[cam].ncal>0 i=c[cam].next*100/c[cam].ncal
    if c[opp].ncal>0 i=Min(i,c[opp].next*100/c[opp].ncal)
  endif
  return i
end

// Scans optically all crosses specified in camera calibrators. If handle
// hremain of type GRAPH or CHILD is specified, Runvideoscan() displays elapsed
// and remaining time in this window. If hinterrupt of type BUTTON is not NULL
// and pressed, scanning is interrupted; if hstat of type BUTTON is not NULL and
// pressed, statistics window appears. Handle hlivevideo displays live video
// (and what else?). Returns -1 if operator decided to quit calibration, 0
// on success and 2 if operator interrupted video scanning.
function int Runvideoscan(handle hremain,handle hinterrupt,                    \
  handle hstat,handle hview,handle hlivevideo,int delayafter)
  int i,j,t,dt,tstep,tupdate,channel,viewon,testimated,ret,nerr,dummy
  float percent,prevpercent
  char s[128]
  change hinfo limits=0,0              // Text is set by caller
  if hremain!=NULL clear hremain
  tstep=Time()
  tupdate=tstep
  viewon=0
  testimated=MAXINT
  prevpercent=-1.0
  if demo==0 then
    for i=0,i<2,i++ do
      SYS.Killimm(i)                   // Remove pending commands, if any
      $A[i].length=1                   // Invalid non-zero length
    enddo
  endif
  if hlivevideo!=NULL then
    channel=(cameras==0x02?1:0)
    Bcsetcam(channel,1)
    SYS.Videoangle(hlivevideo,channel,0,Getzoom(channel),                      \
    Bcgetbri(channel,1),Bcgetctr(channel,1),(channel<0?0:2)|(longexp?4:0),0.0)
  endif
  while 1 do
    percent=Videoscan(hlivevideo)
    if percent!=prevpercent then
      prevpercent=percent
      change hinfo limits=percent*10.0,1000
    endif
    if percent>=100.0 then
      ret=0; break
    else if Pressed(hexit) then
      ret=-1; break                    // Operator interrupted calibration
    endif
    if hinterrupt!=NULL then
      if Pressed(hinterrupt) then
        disable hinterrupt
        if demo==0 then
          change hinfo limits=0,0
          change hinfo text="Wait..."
          t=Time()+10000               // Wait 10 s for answers
          while Time()<t do
            for i=0,i<2,i++
              if c[$LAY.nfing*2+i].ncal==0 continue
              if $A[i].length==0 break
            enddo
            if i>=2 break              // Aha, all answers already here!
            wait
          enddo
          for i=0,i<2,i++ do
            SYS.Killimm(i)             // Remove pending commands, if any
            if c[$LAY.nfing*2+i].ncal==0 continue
            sprintf(s,"M %i(Z) NOP",$LAY.nfing*2+i)
            SERV.Cmdimm(i,s)
          enddo
          while Time()<t do
            for i=0,i<2,i++
              if c[$LAY.nfing*2+i].ncal==0 continue
              if $A[i].length==0 break
            enddo
            if i>=2 break              // Aha, all answers already here!
            wait
          enddo
        endif
        ret=2; break                   // Operator interrupted the scanning
      endif
    endif
    if hstat!=NULL then
      if Pressed(hstat) then
        if viewon==0 then
          if hview!=NULL change hview position=5000,5000,LEFTX-10,288
          Showcurrscan(1,0)
          if stathead<$LAY.nfing*2 Showcurrscan(2,$LAY.nfing*2)
          viewon=1
        else
          Showcurrscan(-1,0)
          if hview!=NULL change hview position=-1,-1,LEFTX,LEFTY
          viewon=0
        endif
      endif
      if viewon==1 Showcurrscan(0,0)
    endif
    if hremain!=NULL then
      dt=Time()-tstep
      if (percent>5.0 && dt>45000) || percent>25.0 then
        t=dt*(100.0-percent)/percent
        if t<testimated-500 || t>testimated+30000 testimated=t
      endif
      if Time()>=tupdate then
        clear hremain
        draw window=hremain
        t=Time()-tstart+500
        draw at 8,22 color=BLUE text="Elapsed time:"
        draw at 120,22 text=format("%2im %02is",t/60000,(t/1000)%60)
        t=Time()-tstep+500
        draw at 8,42 color=RED text="Step time:"
        draw at 120,42 text=format("%2im %02is",t/60000,(t/1000)%60)
        draw at 8,82 text="Bad crosses:"
        nerr=0
        for i=$LAY.nfing*2,i<$LAY.nfing*2+2,i++ do
          if c[i].ncal==0 continue
          for j=0,j<c[i].next,j++ do
            if c[i].err[j]!=0 nerr++
          enddo
        enddo
        draw at 120,82 text=format(" %i",nerr)
        draw at 8,62 text="Remains:"
        if testimated==MAXINT then
          draw at 120,62 color=DARKGRAY text=" ?"
        else
          draw at 120,62 color=RED
          draw text=format("%2im %02is",testimated/60000,(testimated/1000)%60)
        endif
        draw show
        tupdate=tupdate+1000
      endif
    endif
    wait
  enddo
  if viewon==1 Showcurrscan(-1,0)
  // Show live video for some time after scanning is finished, otherwise
  // user will not see that last fiducial that was scanned.
  if delayafter!=0 delay delayafter    // Psychological delay
  if hview!=NULL change hview position=-1,-1,LEFTX,LEFTY
  return ret
end

// Returns -1 if operator interrupted the calibration, 0 on success, 1 if
// different type of calibration must be chosen, 2 on request to replace
// calibration board, 3 if scanning must be repeated and 4 if operator wants
// to find crosses manually.
function int Videooffsets()
  int i,err,needcomma
  float maxdx,maxdy,maxhystx,maxhysty,maxdiff
  handle hview,hlivevideo,hinterrupt
  handle hretry,hreplace,hfinish,hcont,hfind
  if cameras==0 return 0               // Works only with dedicated cameras
  i=Fillcalibrators(C_CENTER2,FILL_VIDEO)
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible!)
  change hinfo limits=0,0
  change hinfo text="Scanning centers"
  if hlog!=NULL fprintf(hlog,"Scanning video centers...\n");
  maxdiff=Max(accuracy,0.002)
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  Bccreate(hview,-1,-1,-1,1,0)
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now measuring the offsets of the central points on the "
  draw text="calibration board. These centers link together layout and "
  draw text="correction tables, so accurate offsets are vital to keep "
  draw text="corrections small. If something goes bad or you want to change "
  draw text="board placement, doubleclick button "
  draw font=MAINFONT text="Interrupt" font=TIMESFONT text=" below."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  i=Runvideoscan(NULL,hinterrupt,NULL,hview,hlivevideo,500)
  if i!=0 return i
  // Check whether all offsets are measured and lay within sound limits, and
  // whether camera hysteresis is acceptable.
  err=0; maxdx=0.0; maxdy=0.0; maxhystx=0.0; maxhysty=0.0
  if hlog!=NULL fprintf(hlog,"Calculating camera hysteresis...\n")
  for i=$LAY.nfing*2,i<$LAY.nfing*2+2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    if c[i].err[0]!=0 || c[i].err[1]!=0 then
      err=1; break                     // Cross not found
    else
      videocenterx[i-$LAY.nfing*2]=                                            \
        (c[i].xm[0]-c[i].xa[0]+c[i].xm[1]-c[i].xa[1])/2.0
      videocentery[i-$LAY.nfing*2]=                                            \
        (c[i].ym[0]-c[i].ya[0]+c[i].ym[1]-c[i].ya[1])/2.0
      maxdx=Max(maxdx,Abs(videocenterx[i-$LAY.nfing*2]))
      maxdy=Max(maxdy,Abs(videocentery[i-$LAY.nfing*2]))
      videohysteresisx[i-$LAY.nfing*2]=                                        \
        (c[i].xm[0]-c[i].xa[0])-(c[i].xm[1]-c[i].xa[1])
      videohysteresisy[i-$LAY.nfing*2]=                                        \
        (c[i].ym[0]-c[i].ya[0])-(c[i].ym[1]-c[i].ya[1])
      if hlog!=NULL then
        fprintf(hlog,"  Hysteresis of %s camera:%s dX=%5.1f, dY=%5.1f um\n",   \
        i==$LAY.nfing*2?"TOP":"BOTTOM",                                        \
        i==$LAY.nfing*2?"     ":"  ",                                          \
        videohysteresisx[i-$LAY.nfing*2]*1000.0,                               \
        videohysteresisy[i-$LAY.nfing*2]*1000.0)
      endif
      maxhystx=Max(maxhystx,Abs(videohysteresisx[i-$LAY.nfing*2]))
      maxhysty=Max(maxhysty,Abs(videohysteresisy[i-$LAY.nfing*2]))
    endif
  enddo
  if maxhystx>maxdiff err=2            // High hysteresis
  if maxhysty>maxdiff err=2
  if maxdx>xstep/4.0 err=3             // Avoid location of different cross
  if maxdy>ystep/4.0 err=3
  if maxdx>xstep/2.5 err=4
  if maxdy>ystep/2.5 err=4
  if err==0 return 0                   // Centers scanned correctly
  // Warn about bad board placement and ask what to do next.
  change hinfo limits=0,0
  change hinfo text="Scanning problem"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    if hlog!=NULL fprintf(hlog,"ERROR: Some centers were not found\n");
    draw text="Some centers were not found. "
    draw color=BLACK text="This makes further calibration impossible. "
  else if err==2 then
    if hlog!=NULL fprintf(hlog,"ERROR: High camera hysteresis\n");
    draw text="High camera hysteresis. "
    draw color=BLACK text="Recognized position of central cross depends on "
    draw text="the direction from which this cross is approached ("
    needcomma=0
    if Max(Abs(videohysteresisx[0]),Abs(videohysteresisy[0]))>maxdiff then
      draw text=format("top camera: dX=%.3f, ",videohysteresisx[0])
      draw text=format("dY=%.3f mm",videohysteresisy[0])
      needcomma=1
    endif
    if Max(Abs(videohysteresisx[1]),Abs(videohysteresisy[1]))>maxdiff then
      if needcomma draw text=", "
      draw text=format("bottom camera: dX=%.3f, ",videohysteresisx[1])
      draw text=format("dY=%.3f mm",videohysteresisy[1])
    endif
    draw text="). "
  else if err==3 then
    if hlog!=NULL fprintf(hlog,"ERROR: High offset of central cross\n");
    draw text="High offset of central cross. "
    draw color=BLACK text=""
  else
    if hlog!=NULL fprintf(hlog,"ERROR: High offset of central cross\n");
    draw text="Very high offset of central cross. "
    draw color=BLACK text="It is possible that some neighbouring cross was "
    draw text="found instead of central. "
  endif
  draw show
  if err==1 then                       // Replace or find manually
    hretry=NULL
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hfinish=NULL
    hcont=NULL
    hfind=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Find manually"
      help="Press to find crosses manually"
    endc
  else if err==2 then                  // Retry, quit or continue
    hretry=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name="Retry"
      help="Press to retry scanning of central crosses once more"
    endc
    hreplace=NULL
    hfinish=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="Quit"
      help="Press to quit calibration and repair video camera"
    endc
    hcont=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
    hfind=NULL
  else if err==3 then                  // Replace or continue
    hretry=NULL
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hfinish=NULL
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
    hfind=NULL
  else                                 // Retry or replace
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Retry"
      help="Press to retry scanning of central crosses once more"
    endc
    hreplace=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hfinish=NULL
    hcont=NULL
    hfind=NULL
  endif
  while 1 do
    if hretry!=NULL then
      if Pressed(hretry) return 3
    endif
    if hreplace!=NULL then
      if Pressed(hreplace) return 2
    endif
    if hfinish!=NULL then
      if Pressed(hfinish) return -1
    endif
    if hcont!=NULL && (Pressed(hcont) || autoconfirm) then
      Logcontinue()
      return 0
    endif
    if hfind!=NULL then
      if Pressed(hfind) return 4
    endif
    if Pressed(hexit) return -1
    wait
  enddo
end

// Checks rough camera alignment and Z- related hysteresis on S3 testers.
function int Checkfocushysteresis()
  int i,t,step,y,z[2],dz,valid[2][4],hystvalid[2],tiltvalid[2],err
  int channel,maxdiff
  float dx[2][4],dy[2][4],hystx[2],hysty[2],tiltx[2],tilty[2]
  char s[256]
  handle hview,hlivevideo,hskip,htable,hok
  if demo || testertype!=TT_S3 || cameras==0                                   \
    return 0                           // Does not apply
  i=Fillcalibrators(C_CENTER,FILL_VIDEO)
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible!)
  maxdiff=Max(accuracy,0.002)
  change hinfo limits=0,0
  change hinfo text="Z-related hysteresis"
  if hlog!=NULL fprintf(hlog,"Measuring Z camera hysteresis...\n")
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  channel=(cameras & 1?0:1)
  SYS.Videoangle(hlivevideo,channel,0,Getzoom(channel),                        \
    Bcgetbri(channel,1),Bcgetctr(channel,1),                                   \
    (channel<0?0:2)|(longexp?4:0),0.0)
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Now checking rough camera alignment and reproducibility after "
  draw text="Z (focus) movement. To skip this test, press "
  draw font=MAINFONT text="Skip" font=TIMESFONT text="."
  draw show
  hskip=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Skip"
    help="Press to skip camera verification"
  endc
  dz=500                               // Z step, micrometers
  Memset(valid,0,Sizeof(valid))
  // Steps: 0 - move focus down; 1 - move up to scan position; 2 - move focus
  // up; 3 - go back to scan position.
  for step=0,step<4,step++ do
    // Set Z coordinates.
    for i=$LAY.nfing*2,i<$LAY.nfing*2+2,i++ do
      if c[i].ncal==0 continue         // Head excluded from calibration
      z[i-$LAY.nfing*2]=focus[i-$LAY.nfing*2]
      if step==0 then
        z[i-$LAY.nfing*2]=z[i-$LAY.nfing*2]+500
      else if step==2 then
        z[i-$LAY.nfing*2]=z[i-$LAY.nfing*2]-500
      endif
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",i,z[i-$LAY.nfing*2])
      SERV.Cmdimm(32,s)
    enddo
    t=Time()
    while Time()-t<750 do
      if Pressed(hexit) return -1
      wait
    enddo
    // Scan crosses.
    Fillcalibrators(C_CENTER,FILL_VIDEO)
    change hinfo text=format("Focal hysteresis, step %i",step+1)
    if hlog!=NULL then
      if cameras==0x1 then
        fprintf(hlog,"  Step %i, focus = %5i um:\n",step+1,z[0])
      else if cameras==0x2 then
        fprintf(hlog,"  Step %i, focus = %5i um:\n",step+1,z[1])
      else
        fprintf(hlog,"  Step %i, focus = %5i / %5i um:\n",step+1,z[0],z[1])
      endif
    endif
    i=Runvideoscan(NULL,hskip,NULL,hview,hlivevideo,100)
    if i<0 return i
    if i>0 then
      if hlog!=NULL fprintf(hlog,"  Operator skipped verification\n")
      return 0
    endif
    for i=$LAY.nfing*2,i<$LAY.nfing*2+2,i++ do
      if c[i].ncal==0 continue         // Head excluded from calibration
      if c[i].err[0]!=0 continue
      dx[i-$LAY.nfing*2][step]=c[i].xm[0]-c[i].xa[0]
      dy[i-$LAY.nfing*2][step]=c[i].ym[0]-c[i].ya[0]
      valid[i-$LAY.nfing*2][step]=1
    enddo
  enddo
  // Process results.
  err=0
  for i=0,i<2,i++ do
    hystvalid[i]=0
    tiltvalid[i]=0
    if c[$LAY.nfing*2+i].ncal==0 continue
    if valid[i][0]!=0 && valid[i][2]!=0 then
      tiltx[i]=(dx[i][0]-dx[i][2])/(2.0*dz/1000.0)
      if Abs(tiltx[i])>MAXTILT err=err|1
      tilty[i]=(dy[i][0]-dy[i][2])/(2.0*dz/1000.0)
      if Abs(tilty[i])>MAXTILT err=err|1
      if hlog!=NULL                                                            \
        fprintf(hlog,"  Tilt of %s camera:%s tX=%5.1f, tY=%5.1f um/mm Z\n",    \
        (i==0?"TOP":"BOTTOM"),(i==0?"           ":"        "),                 \
        tiltx[i]*1000.0,tilty[i]*1000.0)
      tiltvalid[i]=1
    endif
    if valid[i][1]!=0 && valid[i][3]!=0 then
      hystx[i]=dx[i][1]-dx[i][3]
      if Abs(hystx[i])>maxdiff err=err|2
      hysty[i]=dy[i][1]-dy[i][3]
      if Abs(hysty[i])>maxdiff err=err|2
      if hlog!=NULL                                                            \
        fprintf(hlog,"  Hysteresis of %s camera:%s dX=%5.1f, dY=%5.1f um\n",   \
        (i==0?"TOP":"BOTTOM"),(i==0?"     ":"  "),                             \
        hystx[i]*1000.0,hysty[i]*1000.0)
      hystvalid[i]=1
    endif
  enddo
  if err==0 return 0
  // Warn operator.
  Drawtesterview()
  change hinfo limits=0,0
  change hinfo text="Tilt and hysteresis"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Shown below are the focus-related tilt and hysteresis of the "
  if ($LAY.cameras & 0x3)==0x3 then
    draw text="dedicated cameras "
  else
    draw text="dedicated camera "
  endif
  draw text=format("measured at ?%i um ",dz)
  draw text="from the plane of the calibration board."
  draw show
  htable=control CHILD
    window=hright
    position=9,90,RIGHTX-18,4*20+39
    help="Tilt and hysteresis"
    bkcolor=PINK
    size=4096
  endc
  draw window=htable font=INFOFONT color=DARKGRAY
  draw at 5,5 to 241,5
  draw at 5,5 to 5,32 at 10,26 text="Camera"
  draw at 61,5 to 61,32 at 70,26 text="Tilt, um/mm"
  draw at 150,5 to 150,32 at 159,26 text="Hyst, um"
  draw at 241,5 to 241,33
  draw at 5,32 to 241,32
  y=30
  draw font=FIXEDSYS
  for i=0,i<2,i++ do
    if c[$LAY.nfing*2+i].ncal==0 continue
    draw mode=M_LEFT color=DARKGRAY
    draw at 5,y+2 to 5,y+42 to 241,y+42 to 241,y+2
    draw at 10,y+20 text=(i==0?"Top":"Bottom")
    draw at 61,y+2 to 61,y+42
    draw color=(Abs(tiltx[i])>MAXTILT?LIGHTRED:BLACK)
    draw at 70,y+20 text=format("X=%.1f",tiltx[i]*1000.0)
    draw color=(Abs(tilty[i])>MAXTILT?LIGHTRED:BLACK)
    draw at 70,y+40 text=format("Y=%.1f",tilty[i]*1000.0)
    draw color=DARKGRAY at 150,y+2 to 150,y+42
    draw color=(Abs(hystx[i])>MAXTILT?LIGHTRED:BLACK)
    draw at 160,y+20 text=format("X=%.1f",hystx[i]*1000.0)
    draw color=(Abs(hysty[i])>MAXTILT?LIGHTRED:BLACK)
    draw at 160,y+40 text=format("Y=%.1f",hysty[i]*1000.0)
    y=y+40
  enddo
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY,120,24
    name="Continue"
    help="Press to continue calibration. In 5 seconds continues automagically"
    limits=5000,0
  endc
  while 1 do
    if Pressed(hok) return 0
    if Pressed(hexit) return -1
    wait
  enddo
end

// Returns -1 if operator interrupted the calibration, 0 on success, 1 if
// there is an error in calibration data and 2 if interrupt button pressed or
// estimated board position is too bad.
function int Calibrateheads(int shuttle)
  int i,firstwidth,err
  handle hremain,hinterrupt,hview
  if calmode==MODE_CADJ then           // C adjust does not need this routine
    return 2
  else if calmode==MODE_3DCAL then     // 3-D calibration
    err=Fillcalibrators(C_VERAREA,FILL_MECH)
  else if calmode==MODE_VER && verifymode==VERIFY_ZALIGN then
    err=Fillcalibrators(C_MVERIFY,FILL_MECH)
  else if calmode==MODE_VER then       // Verification
    err=Fillcalibrators(C_CALIBR+hverifytype,FILL_MECH)
  else                                 // Main calibration
    err=Fillcalibrators(C_CALIBR,FILL_MECH)
  endif
  if err<0 return err                  // Operator interrupted calibration
  if err>0 return 1                    // Error in parameters (impossible?!)
  change hinfo limits=0,0
  if calmode==MODE_VER then
    change hinfo text="Electrical verification"
    if hlog!=NULL then
      if shuttle==0 then
        fprintf(hlog,"Electrical verification...\n")
      else
        fprintf(hlog,"Electrical verification, right shuttle...\n")
      endif
    endif
  else
    change hinfo text="Electrical calibration"
    if hlog!=NULL then
      if shuttle==0 then
        fprintf(hlog,"Electrical calibration...\n")
      else
        fprintf(hlog,"Electrical calibration, right shuttle...\n")
      endif
    endif
  endif
  Drawcalboard(0,0,0,DR_HEAD)          // Show calibration board in shuttle
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  if calmode==MODE_VER then
    draw text="Electrical verification of fingers is running. "
  else
    draw text="Electrical calibration of fingers is running. "
  endif
  draw text="Have a cup of coffee. If something goes bad, doubleclick button "
  draw font=MAINFONT text="Interrupt" font=TIMESFONT text=" below."
  draw show
  hremain=control GRAPH                // GRAPH to avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,120,200,85
    help="Duration of scanning and estimated time till end of current step"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  hinterrupt=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  hview=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Statistics"
    help=""
  endc
  for i=0,i<$LAY.nfing*2,i++ do
    c[i].tstart=0
    c[i].tend=0
  enddo
  err=Runelectroscan(hremain,hinterrupt,NULL,hview,0.0)
  if err==0 && hlog!=NULL then
    firstwidth=1
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal<=4 continue         // Exclude center and shift scans
      if firstwidth then
        fprintf(hlog,"Line widths measured by heads:\n")
        firstwidth=0
      endif
      fprintf(hlog,"  Head %i%c:  dX=%7.3f, dY=%7.3f mm\n",                    \
        i/2,(i & 1?'R':'L'),c[i].widthx,c[i].widthy)
      ;
    enddo
    firstwidth=1
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal<=4 continue         // Exclude center and shift scans
      if firstwidth then
        fprintf(hlog,"Duration of calibration for each head:\n")
        firstwidth=0
      endif
      fprintf(hlog,"  Head %i%c:  Time=%7.3f s\n",                             \
        i/2,(i & 1?'R':'L'),(c[i].tend-c[i].tstart)/1000.0)
      ;
    enddo
  endif
  return err
end

// Returns -1 if operator interrupted the script, 0 on success, 1 if there is
// an error in calibration data and 2 if interrupt button was pressed.
function int Verifyscan()
  int i
  handle hremain,hinterrupt,hview
  i=Fillcalibrators(C_VER3,FILL_MECH)
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible?!)
  change hinfo limits=0,0
  change hinfo text="Electrical verification"
  if hlog!=NULL fprintf(hlog,"Electrical verification...\n")
  Drawcalboard(0,0,0,DR_HEAD)          // Show calibration board in shuttle
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Electrical verification of fingers is running."
  draw show
  hremain=control GRAPH                // GRAPH to avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,120,200,85
    help="Duration of scanning and estimated time till end of current step"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  hinterrupt=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Interrupt"
    help="Press to interrupt verification"
  endc
  hview=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Statistics"
    help="Press to display or hide verification statistics"
  endc
  i=Runelectroscan(hremain,hinterrupt,NULL,hview,0.0)
  if i!=0 return i
  if hlog!=NULL then
    // Show statistics of electrical verification for each head.

  endif
  return 0
end

// Returns -1 if operator interrupted the script, 0 on success, 1 if there is
// an error in calibration data and 2 if interrupt button was pressed.
function int Verifyvideo()
  int i
  handle hview,hlivevideo
  handle hremain,hinterrupt,hstat
  if cameras==0 return 0               // Works only with dedicated cameras
  change hinfo limits=0,0
  change hinfo text="Optical verification"
  if hlog!=NULL fprintf(hlog,"Optical verification...\n")
  i=Fillcalibrators(C_VER3,FILL_VIDEO) // Prepare for verification
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible!)
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Optical verification of video cameras is running."
  draw show
  hremain=control GRAPH                // GRAPH to avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,120,200,85
    help="Duration of scanning and estimated time till end of current step"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  hinterrupt=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Interrupt"
    help="Press to interrupt verification"
  endc
  hstat=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Statistics"
    help=""
  endc
  i=Runvideoscan(hremain,hinterrupt,hstat,hview,hlivevideo,500)
  return i
end

// Calculates correction tables for heads and dedicated cameras (headcam=0) or
// for head cameras (headcam=1). Parameter warn is 0 if warnings should be
// hidden, 1 if user should be asked what to do, and 2 if user should be
// informed but calibration must continue. Returns -1 if operator interrupted
// the calibration, 1 if operator requested to repeat calibration, and 0 if
// correction tables are good.
function int Corrall(int warn,int headcam)
  int i,j,k,n,y,ok[32],somebad,nheads,valid3d,ret
  float dx,dy,sigma[32],meandx[5],meandy[5]
  handle htable,hretry,hcont
  change hinfo limits=0,0
  change hinfo text="Correction tables"
  if hlog!=NULL then
    if headcam==0 then
      fprintf(hlog,"Generating correction tables...\n")
    else
      fprintf(hlog,"Generating correction tables for head cameras...\n")
    endif
  endif
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Script is calculating correction tables"
  if headcam draw text=" for head cameras"
  draw text=". Please wait..."
  draw show
  nheads=$LAY.nfing*2
  if cameras!=0 nheads=nheads+2
  n=0                                  // Number of heads being calibrated
  for i=0,i<nheads,i++ do
    if c[i].next>0 n++
  enddo
  k=0; somebad=0; valid3d=0
  for i=0,i<nheads,i++ do
    cext[i].mode=cext[i].mode & (~CE_FINE)
    if c[i].next<=0 continue
    if i>=$LAY.nfing*2 then
      j=Splinevideo(i-$LAY.nfing*2)    // Video camera
    else
      if c[i].asymmetric then
        j=Correctasym(i,headcam)       // Asymmetrical head camera calibration
      else
        j=Correctfinger(i,headcam)     // Symmetrical finger or head camera

//j=Correctshifted(i,headcam)


      endif
      if calmode==MODE_CAL then
        // Calculate tilt of calibration board and saves it to c3dnew[].
        if Surfaceposition(i,sigma+i)==0 valid3d=1
      endif
    endif
    if j<0 then somebad=-1;
    else if (j>0 && somebad>=0) then somebad=Max(somebad,j); endif
    ok[i]=j; k++
    change hinfo limits=k,n
  enddo
  if valid3d!=0 && hlog!=NULL then
    // Protocol measured tilts of the calibration board.
    fprintf(hlog,                                                              \
      "Position of the calibration board (local coordinates, X/Y in mm):\n")
    for i=0,i<nheads,i++ do
      if c[i].next<=0 continue
      if i>=$LAY.nfing*2 break
      fprintf(hlog,"  %i%c:   ",i/2,(i & 1?'R':'L'))
      if (c3dnew[i].mode & 0x1)==0 then
        fprintf(hlog,"Unable to calculate\n")
      else
        fprintf(hlog,"Z = %5.0f",c3dnew[i].zcenter)
        if c3dnew[i].zfactorx<0.0 then
          fprintf(hlog," - %6.4f * X",Abs(c3dnew[i].zfactorx)*1000.0)
        else
          fprintf(hlog," + %6.4f * X",Abs(c3dnew[i].zfactorx)*1000.0)
        endif
        if c3dnew[i].zfactory<0.0 then
          fprintf(hlog," - %6.4f * Y um",Abs(c3dnew[i].zfactory)*1000.0)
        else
          fprintf(hlog," + %6.4f * Y um",Abs(c3dnew[i].zfactory)*1000.0)
        endif
        fprintf(hlog,", sigma = %4.1f um\n",sigma[i])
      endif
    enddo
  endif
  if warn==0 || somebad==0 || somebad==1 then
    ret=0
    goto showdiff
  endif
  clear hleft
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if somebad<0 then
    draw text="Unable to calculate corrections!"
    if hlog!=NULL fprintf(hlog,"  ERROR: Unable to calculate corrections\n")
  else
    draw text="Unreliable calibration!"
    if hlog!=NULL fprintf(hlog,"  ERROR: Unreliable corrections\n")
  endif
  draw at 6,60 color=BLACK
  draw text="Script has problems with correction tables for some "
  draw text=(headcam==0?"fingers. ":"head cameras. ")
  if warn!=2 then
    draw text="Please consult the plots and decide what to do next."
  endif
  draw show
  htable=control CHILD
    window=hright
    position=9,110,RIGHTX-18,160
    limits=RIGHTX-38,n*20+38
    mode=M_VSCROLL
    help="Errors detected during calculation of correction tables"
    bkcolor=PINK
    size=4096
  endc
  if warn==2 then
    hretry=NULL
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2-60,USERY,120,24
      name="Continue"
      help="Press to continue calibration"
    endc
  else
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Recalibrate"
      help="Press to repeat calibration of ALL fingers"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Continue"
      help="Press to accept results and continue calibration"
    endc
  endif
  y=30
  draw window=htable font=INFOFONT color=DARKGRAY
  draw at 5,5 to 225,5
  draw at 5,5 to 5,32 at 9,26 text="Head"
  draw at 45,5 to 45,32 at 54,26 text="Errors"
  draw at 225,5 to 225,33
  draw at 5,32 to 225,32
  draw font=FIXEDSYS
  for i=0,i<nheads,i++ do
    if c[i].next<=0 continue           // Head not calibrated
    y=y+20
    draw color=DARKGRAY
    draw at 5,y-18 to 5,y+2 to 225,y+2 to 225,y-18
    draw at 45,y-18 to 45,y+2
    draw at 12,y color=BLACK text=format("%2i%c",i/2,(i & 1)==0?'L':'R')
    draw at 53,y
    if ok[i]==0 then
      draw color=BLACK text="OK"
    else if ok[i]==1 then
      draw color=BLACK text="1 point removed"
    else if ok[i]>1 then
      draw color=RED text=format("%i points removed",ok[i])
    else if ok[i]==(-1) then
      draw color=RED text="Too few found points"
    else
      draw color=RED text="Error in calculations"
    endif
  enddo
  draw show
  setfocus htable
  Showcurrscan(1,0)
  while 1 do
    if Pressed(hretry) then
      ret=1; break
    else if Pressed(hcont) then
      if hlog!=NULL then
        fprintf(hlog,"  Operator decided to accept corrections\n")
      endif
      ret=0; break
    else if Pressed(hexit) then
      ret=(-1); break
    endif
    Showcurrscan(0,0)
    wait
  enddo
  Showcurrscan(-1,0)
showdiff:
  // Protocol deviations between the scanned crosses and the calculated
  // corrections.
  if ret==0 && warn!=0 && hlog!=NULL then
    fprintf(hlog,"Comparing measured deviations and correction tables...\n")
    fprintf(hlog,"          X exp    Y exp   dXmeas  dYmeas    diffX   diffY\n")
    fprintf(hlog,"  Head       mm       mm       um      um       um      um\n")
    for i=0,i<nheads,i++ do
      if c[i].next<=0 continue         // Head not calibrated
      Initsigma(meandx)
      Initsigma(meandy)
      for j=0,j<c[i].next,j++ do
        Getcorr(i,headcam,c[i].xa[j],c[i].ya[j],&dx,&dy)
        fprintf(hlog,                                                          \
          "  D%i%c: %8.3f %8.3f  %7.1f %7.1f  %7.1f %7.1f",                    \
          i/2,(i & 1?'R':'L'),c[i].xa[j],c[i].ya[j],                           \
          (c[i].xm[j]-c[i].xa[j])*1000.0,                                      \
          (c[i].ym[j]-c[i].ya[j])*1000.0,                                      \
          (c[i].xm[j]-c[i].xa[j]-dx)*1000.0,                                   \
          (c[i].ym[j]-c[i].ya[j]-dy)*1000.0)
        if c[i].err[j]==1 then
          fprintf(hlog,"  (bad)\n")
        else if c[i].err[j]==2 then
          fprintf(hlog,"  (removed)\n")
        else
          fprintf(hlog,"\n")
          Addsigma(meandx,c[i].xm[j]-c[i].xa[j]-dx)
          Addsigma(meandy,c[i].ym[j]-c[i].ya[j]-dy)
        endif
      enddo
      fprintf(hlog,                                                            \
        "  >>>>>> D%i%c: dX=%6.2f ?%6.2f, dY=%6.2f ?%6.2f um\n",               \
        i/2,(i & 1?'R':'L'),Getmean(meandx)*1000.0,Getsigma(meandx)*1000.0,    \
        Getmean(meandy)*1000.0,Getsigma(meandy)*1000.0)
      ;
    enddo
  endif
  return ret
end

// Service function, calculates mismatch between the left (corrl) and right
// (corr) corrections provided that calibration board for the right table is
// virtually rotated by dfi radian around the center of the rail 0 and then
// translated by (dx,dy) millimeters. Returns squared mean matching accuracy.
function float Matchstepsfit(float dx,float dy,float dfi)
  int j,h,n
  float x,y,x0,y0,weight,sindfi,cosdfi,xshift,yshift,xhead,yhead
  float px,py,cx,cy,xdiff,ydiff
  // All distances in this routine are in micrometers!
  dx=dx*1000.0
  dy=dy*1000.0
  x0=$LAY.xoffset                      // Center of rotation
  y0=$LAY.yoffset[0]
  weight=0
  sindfi=Sin(dfi)
  cosdfi=Cos(dfi)
  n=0
  // For all heads.
  for h=0,h<$LAY.nfing*2,h++ do
    if c[h].ncal==0 continue           // Head excluded from the calibration
    // For all calibration points at the middle line.
    x=$LAY.xoffset
    for j=0,j<CORRY,j++ do
      y=$LAY.yoffset[h/2]+(j-CENTERY)*ystep*1000.0
      // For matching I use only "real" points of the correction table that lie
      // inside the working area.
      if y<$LAY.bottom[h/2] || y>$LAY.top[h/2] continue
      // Calculate shift of the calibration board (new-old).
      xshift=(x-x0)*(cosdfi-1.0)-(y-y0)*sindfi+dx
      yshift=(x-x0)*sindfi+(y-y0)*(cosdfi-1.0)+dy
      // Calculate head coordinates corresponding to shifted point. I use
      // linear interpolation both in X and in Y. Parabolic in Y?..
      px=xshift/(xstep*1000.0)
      py=yshift/(ystep*1000.0)
      cx=(corr[h][CENTERX,j].dx*(1.0-px)+corr[h][CENTERX+1,j].dx*px)*(1.0-py)+ \
        (corr[h][CENTERX,j+1].dx*(1.0-px)+corr[h][CENTERX+1,j+1].dx*px)*py
      cy=(corr[h][CENTERX,j].dy*(1.0-px)+corr[h][CENTERX+1,j].dy*px)*(1.0-py)+ \
        (corr[h][CENTERX,j+1].dy*(1.0-px)+corr[h][CENTERX+1,j+1].dy*px)*py
      xdiff=corrl[h][CENTERX,j].dx-(xshift+cx)
      ydiff=corrl[h][CENTERX,j].dy-(yshift+cy)
      weight=weight+xdiff*xdiff+ydiff*ydiff
      n++
    enddo
  enddo
  if n!=0 weight=weight/n              // Not necessary, but Sqrt(weight)=accur
  return weight
end

// Matches corrections of the left shuttle (corrl,hcaml) with those of the
// right shuttle (corr,hcam) and saves results to corr[] and hcam[].
// Corrections for the dedicated camera in the right shuttle are not used for
// matching. They are rotated and kept in camr[].
function int Matchsteps()
  int i,j,k,p,q,h,camera
  float x,y,dx,dy,dfi,stepxy,stepfi,wn,w0,wp,wu,wd,r
  float x0,y0,sindfi,cosdfi,xshift,yshift,cx,cy,bx,by,px,py
  float x1,y1,fi,dr,sign
  if hlog!=NULL then
    fprintf(hlog,"Matching corrections between left and right shuttle...\n")
  endif
  dx=0
  dy=0
  dfi=0
  stepxy=5.0
  stepfi=0.05
  for i=0,i<50,i++ do
    // Fit angle.
    wn=Matchstepsfit(dx,dy,dfi-stepfi)
    w0=Matchstepsfit(dx,dy,dfi)
    wp=Matchstepsfit(dx,dy,dfi+stepfi)
    if wp+wn-2.0*w0!=0 then
      r=(wn-wp)/(wp+wn-2.0*w0)/2.0
      dfi=dfi+stepfi*r
    endif
    stepfi=stepfi*0.9
    // Fit X and Y shifts.
    wn=Matchstepsfit(dx-stepxy,dy,dfi)
    wd=Matchstepsfit(dx,dy-stepxy,dfi)
    w0=Matchstepsfit(dx,dy,dfi)
    wp=Matchstepsfit(dx+stepxy,dy,dfi)
    wu=Matchstepsfit(dx,dy+stepxy,dfi)
    if wp+wn-2.0*w0!=0 then
      r=(wn-wp)/(wp+wn-2.0*w0)/2.0
      dx=dx+stepxy*r
    endif
    if wu+wd-2.0*w0!=0 then
      r=(wd-wu)/(wu+wd-2.0*w0)/2.0
      dy=dy+stepxy*r
    endif
    stepxy=stepxy*0.9
  enddo
  if hlog!=NULL then
    fprintf(hlog,"  Best fit: dX=%7.3f, dY=%7.3f mm, angle %7.4f degrees\n",   \
      dx,dy,dfi/3.14159265359*180.0)
    fprintf(hlog,"  Mean matching error %.1f micrometers\n",Sqrt(w0))
  endif
  // Recalculate head corrections, exactly as in Matchstepsfit(). All distances
  // are in micrometers.
  dx=dx*1000.0
  dy=dy*1000.0
  x0=$LAY.xoffset                      // Center of rotation
  y0=$LAY.yoffset[0]
  sindfi=Sin(dfi)
  cosdfi=Cos(dfi)
  for h=0,h<$LAY.nfing*2,h++ do        // For all heads
    if c[h].ncal==0 continue           // Head excluded from the calibration
    for j=0,j<CORRY,j++ do
      y=$LAY.yoffset[h/2]+(j-CENTERY)*ystep*1000.0
      for i=CENTERX,i<CORRX,i++ do
        x=$LAY.xoffset+(i-CENTERX)*xstep*1000.0
        // Calculate shift of the calibration board (new-old).
        xshift=(x-x0)*(cosdfi-1.0)-(y-y0)*sindfi+dx
        yshift=(x-x0)*sindfi+(y-y0)*(cosdfi-1.0)+dy
        // Calculate head coordinates corresponding to shifted point. I use
        // linear interpolation both in X and in Y. Parabolic in Y?..
        px=xshift/(xstep*1000.0)
        py=yshift/(ystep*1000.0)
        if i==CORRX-1 then
          p=i-1; px=1.0-px
        else
          p=i
        endif
        if j==CORRY-1 then
          q=j-1; py=1.0-py
        else
          q=j
        endif
        cx=xshift+(corr[h][p,q].dx*(1.0-px)+corr[h][p+1,q].dx*px)*(1.0-py)+    \
          (corr[h][p,q+1].dx*(1.0-px)+corr[h][p+1,q+1].dx*px)*py
        cy=yshift+(corr[h][p,q].dy*(1.0-px)+corr[h][p+1,q].dy*px)*(1.0-py)+    \
          (corr[h][p,q+1].dy*(1.0-px)+corr[h][p+1,q+1].dy*px)*py
        if i==CENTERX then
          // Take mean for the corrections on the central vertical line.
          corrl[h][i,j].dx=Floor((corrl[h][i,j].dx+cx)/2.0+0.5)
          corrl[h][i,j].dy=Floor((corrl[h][i,j].dy+cy)/2.0+0.5)
        else
          corrl[h][i,j].dx=Floor(cx+0.5)
          corrl[h][i,j].dy=Floor(cy+0.5)
        endif
      enddo
    enddo
  enddo
  // Recalculate dedicated camera corrections for the right shuttle.
  for camera=0,camera<2,camera++ do
    if ($LAY.cameras & (1<<camera))==0 continue
    h=$LAY.nfing*2+camera
    if c[h].ncal==0 continue           // Camera excluded from the calibration
    for j=0,j<GRIDY,j++ do
      y=$LAY.yoffset[h/2]+(j-GRIDCY)*videoy*1000.0
      for i=0,i<GRIDX,i++ do
        x=$LAY.xoffset+(i-GRIDCX)*xstep*1000.0
        // Calculate shift of the calibration board (new-old).
        xshift=(x-x0)*(cosdfi-1.0)-(y-y0)*sindfi+dx
        yshift=(x-x0)*sindfi+(y-y0)*(cosdfi-1.0)+dy
        // Calculate head coordinates corresponding to shifted point. I use
        // linear interpolation both in X and in Y. Parabolic in Y?..
        px=xshift/(xstep*1000.0)
        py=yshift/(videoy*1000.0)
        if i==GRIDX-1 then
          p=i-1; px=1.0-px
        else
          p=i
        endif
        if j==GRIDY-1 then
          q=j-1; py=1.0-py
        else
          q=j
        endif
        cx=xshift+(corr[h][p,q].dx*(1.0-px)+corr[h][p+1,q].dx*px)*(1.0-py)+    \
          (corr[h][p,q+1].dx*(1.0-px)+corr[h][p+1,q+1].dx*px)*py
        cy=yshift+(corr[h][p,q].dy*(1.0-px)+corr[h][p+1,q].dy*px)*(1.0-py)+    \
          (corr[h][p,q+1].dy*(1.0-px)+corr[h][p+1,q+1].dy*px)*py
        camr[camera][i,j].dx=cx
        camr[camera][i,j].dy=cy
      enddo
    enddo
    camrvalid[camera]=1
  enddo
  // Recalculate head camera corrections. All distances are in micrometers.
  dr=(headcamradius-radius)*1000.0
  for h=0,h<$LAY.nfing*2,h++ do
    if c[h].ncal==0 continue           // Head excluded from the calibration
    if (h & 1)==0 then
      sign=1.0                         // Left head
    else
      sign=-1.0                        // Right head
    endif
    for j=0,j<CORRY,j++ do
      y=$LAY.yoffset[h/2]+(j-CENTERY)*ystep*1000.0
      for i=CENTERX,i<CORRX,i++ do
        x=$LAY.xoffset+(i-CENTERX)*xstep*1000.0
        // Calculate shift of the calibration board (new-old).
        xshift=(x-x0)*(cosdfi-1.0)-(y-y0)*sindfi+dx
        yshift=(x-x0)*sindfi+(y-y0)*(cosdfi-1.0)+dy
        // Calculate head shift necessary to reach (x+xshift,y+yshift)
        // with the camera. This is how crate makes it.
        px=xshift/(xstep*1000.0)
        if i==CORRX-1 then
          p=i-1; px=1.0-px
        else
          p=i
        endif
        py=yshift/(ystep*1000.0)
        if j==CORRY-1 then
          q=j-1; py=1.0-py
        else
          q=j
        endif
        // Note: I use original right shuttle corrections.
        x1=xshift+(hcam[h][p,q].dx*(1.0-px)+hcam[h][p+1,q].dx*px)*(1.0-py)+    \
          (hcam[h][p,q+1].dx*(1.0-px)+hcam[h][p+1,q+1].dx*px)*py
        y1=yshift+(hcam[h][p,q].dy*(1.0-px)+hcam[h][p+1,q].dy*px)*(1.0-py)+    \
          (hcam[h][p,q+1].dy*(1.0-px)+hcam[h][p+1,q+1].dy*px)*py
        fi=Asin((y1+y-$LAY.yoffset[h/2])/(headcamradius*1000.0))
        x1=x1-sign*dr*Cos(fi)
        y1=y1-dr*Sin(fi)
        px=x1/(xstep*1000.0)
        if i==CORRX-1 then
          p=i-1; px=1.0-px
        else
          p=i
        endif
        py=y1/(ystep*1000.0)
        if j==CORRY-1 then
          q=j-1; py=1.0-py
        else
          q=j
        endif
        // Note: I use original right shuttle corrections.
        cx=(corr[h][p,q].dx*(1.0-px)+corr[h][p+1,q].dx*px)*(1.0-py)+           \
          (corr[h][p,q+1].dx*(1.0-px)+corr[h][p+1,q+1].dx*px)*py+x1
        cy=(corr[h][p,q].dy*(1.0-px)+corr[h][p+1,q].dy*px)*(1.0-py)+           \
          (corr[h][p,q+1].dy*(1.0-px)+corr[h][p+1,q+1].dy*px)*py+y1
        // Now, using new head corrections, try to adjust camera corrections so
        // that we reach the same point when specifying (x,y). The sequence is
        // perfectly convergent, three attempts are more than sufficient.
        for k=0,k<3,k++ do
          x1=hcam[h][i,j].dx
          y1=hcam[h][i,j].dy
          fi=Asin((y1+y-$LAY.yoffset[h/2])/(headcamradius*1000.0))
          x1=x1-sign*dr*Cos(fi)
          y1=y1-dr*Sin(fi)
          px=x1/(xstep*1000.0)
          if i==CORRX-1 then
            p=i-1; px=1.0-px
          else
            p=i
          endif
          py=y1/(ystep*1000.0)
          if j==CORRY-1 then
            q=j-1; py=1.0-py
          else
            q=j
          endif
          // Note: now I use recalculated right shuttle corrections!
          bx=(corrl[h][p,q].dx*(1.0-px)+corrl[h][p+1,q].dx*px)*(1.0-py)+       \
            (corrl[h][p,q+1].dx*(1.0-px)+corrl[h][p+1,q+1].dx*px)*py+x1
          by=(corrl[h][p,q].dy*(1.0-px)+corrl[h][p+1,q].dy*px)*(1.0-py)+       \
            (corrl[h][p,q+1].dy*(1.0-px)+corrl[h][p+1,q+1].dy*px)*py+y1
          hcam[h][i,j].dx=hcam[h][i,j].dx+(cx-bx)
          hcam[h][i,j].dy=hcam[h][i,j].dy+(cy-by)
        enddo
      enddo
    enddo
    // Merge left-side corrections.
    for j=0,j<CORRY,j++ do
      for i=0,i<CENTERX,i++ do
        hcam[h][i,j].dx=hcaml[h][i,j].dx
        hcam[h][i,j].dy=hcaml[h][i,j].dy
      enddo
      hcam[h][CENTERX,j].dx=(hcaml[h][CENTERX,j].dx+hcam[h][CENTERX,j].dx)/2
      hcam[h][CENTERX,j].dy=(hcaml[h][CENTERX,j].dy+hcam[h][CENTERX,j].dy)/2
    enddo
  enddo
  // Corrections recalculated.
  Memcpy(corr,corrl,Sizeof(corrl))
end

// Warns operator if corrections for some head or dedicated camera have too
// large offset of central point. Returns -1 if operator interrupted the
// calibration and 0 if correction tables are good.
function int Checkcenters()
  int i,j,ix,nheads,nbad,y
  float limit,x,cx,dx,deltax,xoffset
  handle htable,hcont
  nheads=$LAY.nfing*2
  if cameras!=0 nheads=nheads+2
  limit=Max(accuracy,0.002)*2000.0+5.0
  nbad=0
  // In some cases, like split shuttle, center of the layout lies outside the
  // calibration board. This code basically repeats Fillcalibrators(C_CENTER).
  xoffset=$LAY.xoffset/1000.0
  cx=xoffset
  dx=1.0e10
  for j=-GRIDX/2,j<=GRIDX/2,j++ do
    x=xoffset+j*xstep
    if x<fromxloc-0.001 continue
    if x>toxloc+0.001 break
    deltax=Abs(xoffset-x)
    if deltax<dx then
      dx=deltax
      cx=x
    endif
  enddo
  ix=GRIDCX+Floor((x-xoffset)/xstep+0.5)
  ix=Max(0,Min(ix,GRIDX-1))
  for i=0,i<nheads,i++ do
    if c[i].next<=0 continue
<<<<<<< CALIBR.SCR
    if Abs(corr[i][CENTERX,CENTERY].dx)>limit ||                               \
      Abs(corr[i][CENTERX,CENTERY].dy)>limit then
=======
    if Abs(corr[i][ix,GRIDCY].dx)>limit ||                                     \
      Abs(corr[i][ix,GRIDCY].dy)>limit then
>>>>>>> 1.202
      nbad++
    endif
  enddo
  if nbad==0 return 0                  // All offsets are low
  if hlog!=NULL then
    fprintf(hlog,"Large corrections in central points:\n")
    for i=0,i<nheads,i++ do
      if c[i].next<=0 continue
<<<<<<< CALIBR.SCR
      if Abs(corr[i][CENTERX,CENTERY].dx)>limit ||                             \
        Abs(corr[i][CENTERX,CENTERY].dy)>limit                                 \
=======
      if Abs(corr[i][ix,GRIDCY].dx)>limit ||                                   \
        Abs(corr[i][ix,GRIDCY].dy)>limit                                       \
>>>>>>> 1.202
      then
        fprintf(hlog,"  %i%c:   dX = %5i,  dY = %5i um\n",i/2,(i & 1?'R':'L'), \
<<<<<<< CALIBR.SCR
        corr[i][CENTERX,CENTERY].dx,corr[i][CENTERX,CENTERY].dy)
=======
        corr[i][ix,GRIDCY].dx,corr[i][ix,GRIDCY].dy)
>>>>>>> 1.202
      endif
    enddo
  endif
  clear hleft
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="Large corrections in central points!"
  draw at 6,60 color=BLACK
  draw text="Corrections of central points should to be close to zero. High "
  draw text="deviations may mean improperly fixed calibration board"
  if cameras==0 then
    draw text=" or loose needles. "
  else
    draw text=", loose needles or wobbly camera. "
  endif
  draw text="Please consult the table and if necessary, repeat calibration."
  draw show
  htable=control CHILD
    window=hright
    position=29,135,RIGHTX-58,150
    limits=RIGHTX-74,nheads*20+38
    mode=M_VSCROLL
    help="Heads or cameras with high deviations in central point"
    bkcolor=PINK
    size=4096
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2-60,USERY+20,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  y=30
  draw window=htable font=INFOFONT color=DARKGRAY
  draw at 5,5 to 185,5
  draw at 5,5 to 5,32 at 9,26 text="Head"
  draw at 45,5 to 45,32 at 59,26 text="dX,mm"
  draw at 115,5 to 115,32 at 130,26 text="dY,mm"
  draw at 185,5 to 185,33
  draw at 5,32 to 185,32
  draw font=FIXEDSYS
  for i=0,i<nheads,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    y=y+20
    draw color=DARKGRAY
    draw at 5,y-18 to 5,y+2 to 185,y+2 to 185,y-18
    draw at 45,y-18 to 45,y+2
    draw at 115,y-18 to 115,y+2
    draw at 12,y color=BLACK text=format("%2i%c",i/2,(i & 1)==0?'L':'R')
    draw at 57,y
<<<<<<< CALIBR.SCR
    if Abs(corr[i][CENTERX,CENTERY].dx)>limit then
=======
    if Abs(corr[i][ix,GRIDCY].dx)>limit then
>>>>>>> 1.202
      draw color=LIGHTRED
    else
      draw color=BLACK
    endif
<<<<<<< CALIBR.SCR
    draw text=format("%6i",corr[i][CENTERX,CENTERY].dx)
=======
    draw text=format("%6i",corr[i][ix,GRIDCY].dx)
>>>>>>> 1.202
    draw at 126,y
<<<<<<< CALIBR.SCR
    if Abs(corr[i][CENTERX,CENTERY].dy)>limit then
=======
    if Abs(corr[i][ix,GRIDCY].dy)>limit then
>>>>>>> 1.202
      draw color=LIGHTRED
    else
      draw color=BLACK
    endif
<<<<<<< CALIBR.SCR
    draw text=format("%6i",corr[i][CENTERX,CENTERY].dy)
=======
    draw text=format("%6i",corr[i][ix,GRIDCY].dy)
>>>>>>> 1.202
  enddo
  draw show
  setfocus htable
  while 1 do
    if Pressed(hcont) then
      break
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Analyzes the number of detected contacts over surface and warns operator
// about potentially problematical heads. Even single contact over surface is
// enough to cause this warning.
function int Checksurfdet()
  int i,err,maxcont,maxhead,n,y
  handle hcont,htable
  err=0; maxcont=0; maxhead=-1; n=0
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue
    if oversurface[i]!=0 err=1
    maxcont=Max(maxcont,oversurface[i])
    maxhead=i
    n++
  enddo
  if err==0 return 0                   // No contacts over surface detected
  change hinfo limits=0,0
  change hinfo text="Unreliable contact detection!"
  clear hright
  if hlog!=NULL then
    fprintf(hlog,"ERROR: %i contacts over surface from head %i%c\n",           \
    maxcont,maxhead/2,(maxhead & 1?'R':'L'))
  endif
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+10,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  change hright help=" "
  draw window=hright font=TIMESFONT
  draw at 6,30 color=BLACK wrap=RIGHTX-5
  draw text="Some heads are unable to reliably detect the moment of contact "
  draw text=format("with PCB (stroke set to %i mm/s). ",v)
  draw text="This may result in unreliable calibration and later in damaged "
  draw text="products or needles. Please consult the table below and "
  draw text="decide whether you want to continue calibration."
  if maxcont>=5 then
    draw text=" (By this amount of errors, you better stop it!)"
  endif
  draw show
  htable=control CHILD
    window=hright
    position=40,160,RIGHTX-80,100
    limits=RIGHTX-30,n*20+38
    mode=M_VSCROLL
    help="Number of detected contacts over surface for each head"
    bkcolor=PINK
    size=4096
  endc
  y=30
  draw window=htable font=INFOFONT color=DARKGRAY mode=M_CENTERED
  draw at 5,5 to 165,5
  draw at 5,5 to 5,32 at 32,26 text="Head"
  draw at 59,5 to 59,32 at 112,26 text="Bad contacts"
  draw at 165,5 to 165,33
  draw at 5,32 to 165,32
  draw font=FIXEDSYS
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue           // Head excluded from calibration
    y=y+20
    draw color=DARKGRAY
    draw at 5,y-18 to 5,y+2 to 165,y+2 to 165,y-18
    draw at 59,y-18 to 59,y+2
    draw at 32,y color=BLACK text=format("%i%c",i/2,(i & 1)==0?'L':'R')
    if oversurface[i]==0 then
      draw color=BLACK at 112,y text="--"
    else
      draw color=LIGHTRED at 112,y text=format("%i",oversurface[i])
    endif
  enddo
  draw show
  setfocus htable
  while 1 do
    if Pressed(hcont) || autoconfirm then
      Logcontinue()
      return 0
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Displays correction tables or results of verification.
function int Viewresults()
  int ret
  handle hcont
  change hinfo limits=0,0
  change hinfo text="View corrections"
  clear hleft
  clear hright
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+10,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  change hright help=" "
  draw window=hright font=TIMESFONT
  draw at 6,30 color=BLACK wrap=RIGHTX-5
  draw text="Now you can view calibration results."
  draw show
  Showcurrscan(1,0)
  while 1 do
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hcont) then
      ret=0; break
    endif
    Showcurrscan(0,0)
    wait
  enddo
  Showcurrscan(-1,0)
  return ret
end

// Displays internas of calibration, like splined points etc.
function int Viewinterna()
  int ret
  handle hcont
  change hinfo limits=0,0
  change hinfo text="View internal data"
  clear hleft
  clear hright
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+10,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  change hright help=" "
  draw window=hright font=TIMESFONT
  draw at 6,30 color=BLACK wrap=RIGHTX-5
  draw text="Now you can view internal calibration data. To make any "
  draw text="qualified conclusions, you need to know how calibration works."
  draw show
  Showinterna(1,0)
  while 1 do
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hcont) then
      ret=0; break
    endif
    Showinterna(0,0)
    wait
  enddo
  Showinterna(-1,0)
  return ret
end

// Used to display internal Y encoder data. First call with mode=1 to create
// window, then call periodically with mode=0 to process operator's requests.
// To select different head, call with mode=2 and select=requested head. Call
// with mode=-1 to destroy window.
function int Showyencoder(int mode,int select)
  float stsc[8] = { 20.0, 50.0, 100.0, 250.0, 500.0, 1000.0, 2000.0, 5000.0 }
  int i,j,x,y,nodey,redraw,buttons,first
  float dx,dp,scalex,yoffset
  if mode==1 then                      // Create statistics window
    if hstat!=NULL destroy hstat
    hstat=control CHILD
      window=hleft
      position=0,0,LEFTX,LEFTY
      help=" "
      bkcolor=LIGHTGRAY
      size=256
    endc
    hstatg=control GRAPH
      window=hstat
      position=0,0,LEFTX,270
      help="Internal Y encoder data"
      color=GRAY
      bkcolor=WHITE
    endc
    draw window=hstat font=MEDIUMFONT color=DARKGRAY
    hstatsel[0]=control BUTTON
      window=hstat
      position=47,278,25,25
      text="+"
      help="Press to go to the next rail"
      font=MEDIUMFONT
    endc
    if $LAY.nfing==1 disable hstatsel[0]
    hstatsel[1]=control BUTTON
      window=hstat
      position=17,305,25,25
      text="-"
      help="Press to select left head"
      font=MEDIUMFONT
    endc
    hstatsel[2]=control BUTTON
      window=hstat
      position=77,305,25,25
      text="+"
      help="Press to select right head"
      font=MEDIUMFONT
    endc
    hstatsel[3]=control BUTTON
      window=hstat
      position=47,332,25,25
      text="-"
      help="Press to go to the previous rail"
      font=MEDIUMFONT
    endc
    if $LAY.nfing==1 disable hstatsel[3]
    hstathead=control TEXT
      window=hstat
      position=44,308,31,23
      help="Currently selected head"
      font=MEDIUMFONT
      color=LIGHTRED
      bkcolor=LIGHTGRAY
      mode=M_CENTERED
    endc
    draw at 190,350 text="Scale"
    hstatscale=control TEXT
      window=hstat
      position=240,330,50,22
      text=format("x%g",stsc[statscale])
      help="Current scale for internal data (pixels/millimeter)"
      font=MEDIUMFONT
      mode=M_BORDER|M_CENTERED
    endc
    hstatscscr=control VSCROLL
      window=hstat
      position=290,330,24,22
      help="Change scale factor for internal data"
      limits=1,-1
    endc
    draw show
    statnext=-1
    statselect=-1; statselx=-1; statsely=-1
    statprevx=-1
  else if (mode==0 || mode==2) && hstat!=NULL then
    // Maintain statistics window.
    if mode==2 then
      i=select
      redraw=1
    else
      i=stathead
      if i>=$LAY.nfing*2 i=0
      if Pressed(hstatsel[0]) then
        if i/2<$LAY.nfing-1 i=i+2
      else if Pressed(hstatsel[1]) then
        i=i & 0x1E
      else if Pressed(hstatsel[2]) then
        i=i|1
      else if Pressed(hstatsel[3]) then
        if (i>=2) i=i-2
      else if Pressed(hstatscscr) then
        j=Status(hstatscscr)
        if j<0 then
          statscale=Max(0,statscale-1); redraw=1
        else if j>0 then
          statscale=Min(7,statscale+1); redraw=1
        endif
        change hstatscscr select=0
        change hstatscale text=format("x%g",stsc[statscale])
      endif
    endif
    if i!=stathead then
      stathead=i
      statselect=-1; statselx=-1; statsely=-1
      redraw=1
    endif
    if statnext!=0 then
      statnext=0; redraw=1             // Redraw if displayed for the fisrt time
    endif
    // Conversion from millimeters to pixels:   Xpix=N*scalex+dx
    scalex=(LEFTX-33.0)/(CORRY-1)
    dx=16
    dp=129
    i=Mousexy(hstatg,&x,&y,&buttons)
    if i==1 && x!=statprevx then
      statprevx=x                      // Mouse cursor in statistics graph
      nodey=(x-dx+scalex/2)/scalex
      if nodey>=0 && nodey<CORRY && statselx!=nodey then
        statselx=nodey                 // Another node under cursor
        statselect=nodey
        redraw=1
      endif
    endif
    if redraw then
      // Draw grid.
      draw window=hstatg bkcolor=WHITE clear
      for i=-10,i<=10,i++ do
        draw color=(i==0?GRAY:LIGHTGRAY)
        draw at dx,i*10+dp to (CORRY-1)*scalex+dx,i*10+dp
      enddo
      for i=0,i<CORRY,i++ do
        x=i*scalex+dx
        draw color=(i==statselx?GRAY:LIGHTGRAY)
        draw at x,dp-100 to x,dp+100
      enddo
      draw font=MEDIUMFONT color=GRAY
      draw at dx+5,dp-80 text=format("%i%c",stathead/2,stathead & 1?'R':'L')
      yoffset=$LAY.yoffset[stathead/2]/1000.0
      // Draw general data on the top of the window.
      draw color=DARKGRAY font=TERMINALFONT mode=M_LEFT at 5,13
      draw text=format(" %i%c",stathead/2,(stathead & 1?'R':'L'))
      // Display Y coordinate at cursor.
      draw color=DARKGRAY at 5,dp+113 text="At Y=        mm"
      draw color=BLACK at 41,dp+113
      draw text=format("%.1f",(statselx-CENTERY)*ystep+yoffset)
      // Draw angular data.
      draw color=LIGHTRED
      first=1
      for i=0,i<CORRY,i++ do
        if diffvalid[stathead][i]==0 continue
        x=i*scalex+dx
        y=dp-fidiff[stathead][i]*stsc[statscale]
        if first then
          draw at x,y
          first=0
        else
          draw to x,y
        endif
        draw at x,y ellipse 5,5
      enddo
      // Draw radius data.
      draw color=GREEN
      first=1
      for i=0,i<CORRY,i++ do
        if diffvalid[stathead][i]==0 continue
        x=i*scalex+dx
        y=dp-rdiff[stathead][i]*stsc[statscale]
        if first then
          draw at x,y
          first=0
        else
          draw to x,y
        endif
        draw at x,y ellipse 5,5
      enddo
      // Draw data values at cursor.
      if statselx>=0 && statselx<CORRX && diffvalid[stathead][statselx]!=0 then
        draw mode=M_RIGHT color=DARKGRAY
        draw at 215,dp+113 text="Angular diff ="
        draw at 215,dp+124 text="Radial diff ="
        draw mode=M_LEFT
        draw at 262,dp+113 text="mm"
        draw at 262,dp+124 text="mm"
        draw at 220,dp+113 color=LIGHTRED
        draw text=format("% .3f",fidiff[stathead][statselx])
        draw at 220,dp+124 color=GREEN
        draw text=format("% .3f",rdiff[stathead][statselx])
      endif
      draw show
      // Update head/rail display.
      change hstathead text=format("%i%c",stathead/2,(stathead & 1?'R':'L'))
      // Screen updated.
      redraw=0
    endif
  else                                 // Destroy statistics window
    if hstat!=NULL destroy hstat
    hstat=NULL
  endif
end

// Displays Y encoder data.
function int Viewyencoder()
  int ret
  handle hcont
  change hinfo limits=0,0
  change hinfo text="View Y encoder data"
  clear hleft
  clear hright
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+10,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  change hright help=" "
  draw window=hright font=TIMESFONT
  draw at 6,30 color=BLACK wrap=RIGHTX-5
  draw text="Now you can view internal Y encoder data. High values and rapid "
  draw text="changes usually mean bent encoder. To make any other qualified "
  draw text="conclusions, you need to know how calibration works."
  draw show
  Showyencoder(1,0)
  while 1 do
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hcont) then
      ret=0; break
    endif
    Showyencoder(0,0)
    wait
  enddo
  Showyencoder(-1,0)
  return ret
end

// Returns -1 if operator interrupted the calibration, 0 on success or when
// video calibration is not requested, 1 if there is an error in calibration
// data and 2 if interrupt button pressed or estimated board position is too
// bad.
function int Calibratevideo(int shuttle)
  int i
  handle hview,hlivevideo
  handle hremain,hinterrupt,hstat
  if cameras==0 return 0               // Works only with dedicated cameras
  change hinfo limits=0,0
  if calmode==MODE_CADJ then           // C adjust does not need this routine
    return 2
  else if calmode==MODE_3DCAL then
    change hinfo text="Optical calibration"
    if hlog!=NULL fprintf(hlog,"Optical calibration...\n")
    i=Fillcalibrators(C_VERAREA,FILL_VIDEO)
  else if calmode==MODE_VER && verifymode==VERIFY_ZALIGN then
    change hinfo text="Optical verification"
    if hlog!=NULL then
      if shuttle==0 then
        fprintf(hlog,"Optical verification...\n")
      else
        fprintf(hlog,"Optical verification, right shuttle...\n")
      endif
    endif
    Fillcalibrators(C_MVERIFY,FILL_MECH)
    i=Fillcalibrators(C_VER5,FILL_VIDEO)
  else if calmode==MODE_VER then
    change hinfo text="Optical verification"
    if hlog!=NULL then
      if shuttle==0 then
        fprintf(hlog,"Optical verification...\n")
      else
        fprintf(hlog,"Optical verification, right shuttle...\n")
      endif
    endif
    i=Fillcalibrators(C_VER3+vverifytype,FILL_VIDEO)
  else
    change hinfo text="Optical calibration"
    if hlog!=NULL then
      if shuttle==0 then
        fprintf(hlog,"Optical calibration...\n")
      else
        fprintf(hlog,"Optical calibration, right shuttle...\n")
      endif
    endif
    i=Fillcalibrators(C_CALIBR,FILL_VIDEO)
  endif
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible!)
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  if calmode==MODE_VER then
    draw text="Optical verification "
  else
    draw text="Optical calibration "
  endif
  draw text="of video cameras is running now. So far, we expect no problems. "
  draw text="Have a cup of coffee. If something goes bad, doubleclick button "
  draw font=MAINFONT text="Interrupt" font=TIMESFONT text=" below."
  draw show
  hremain=control GRAPH                // GRAPH to avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,120,200,85
    help="Duration of scanning and estimated time till end of current step"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  hinterrupt=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  hstat=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Statistics"
    help=""
  endc
  i=Runvideoscan(hremain,hinterrupt,hstat,hview,hlivevideo,500)
  return i
end

// Defines fiducials for head cameras. Flag definealt requests alternative
// fiducials (plain crosses) for theglass calibration board. If color is
// WHITEONBLACK or BLACKONWHITE, sets specified colour, otherwise uses default.
// Returns 0 on success, -1 if operator interrupted calibration, and 1 if new
// type of calibration should be selected.
function int Headcamfiducials(int definealt,int color)
  int i,err,channel,videox,videoy,dummy
  handle hok
  if demo return 0
  err=0
  if color!=WHITEONBLACK && color!=BLACKONWHITE then
    if illumination==0 && (boardtype==0 || testertype==TT_S3) then
      color=WHITEONBLACK
    else
      color=BLACKONWHITE
    endif
  endif
  if headcamfidtype!=0 definealt=0
  // Delete old fiducials, if any.
  for i=0,i<32,i++ do
    if headcammodel[i]!=NULL then
      SYS.Deletemodel(headcammodel[i])
      headcammodel[i]=NULL
    endif
    if headaltmodel[i]!=NULL then
      SYS.Deletemodel(headaltmodel[i])
      headaltmodel[i]=NULL
    endif
  enddo
  // Define new fiducials.
  for i=0,i<$LAY.nfing*2,i++ do
    if (headcams & (1<<i))==0 continue
    channel=Channelfromhead(i)
    if headcamwfactor[i]==0.0 headcamwfactor[i]=1.0
    if headcamsfactor[i]==0.0 headcamsfactor[i]=1.0
    if (boardtype==1 && (testertype==TT_A3L || testertype==TT_A5 ||            \
      testertype==TT_A5L ||                                                    \
      ((testertype==TT_S1 || testertype==TT_S3) &&                             \
      $LAY.rightlimit-$LAY.leftlimit<450000) ||                                \
      testertype==TT_S2 || testertype==TT_A7 || testertype==TT_A8)) ||         \
      boardtype==2                                                             \
    then
      headcammodel[i]=Model(channel,                                           \
        (headcamfidtype==2?SYNT_RIGHT:SYNT_LEFT),                              \
        0.7/headcamscale[i]*headcamsfactor[i],                                 \
        0.3/headcamscale[i]*headcamwfactor[i],                                 \
        0.0,0.0,color)
      if headcammodel[i]==NULL err=1
      if definealt then
        SYS.Videosize(channel,&videox,&videoy,&dummy)
        if videox==0 videox=768
        if videoy==0 videoy=576
        headaltmodel[i]=Model(channel,SYNT_CROSS,                              \
          Min(videox,videoy)*0.25,                                             \
          linewidth/headcamscale[i]*headcamwfactor[i],                         \
          0.0,0.0,color)
        ;
      endif
    else
      SYS.Videosize(channel,&videox,&videoy,&dummy)
      if videox==0 videox=768
      if videoy==0 videoy=576
      headcammodel[i]=Model(channel,SYNT_CROSS,                                \
        Min(videox,videoy)*0.25,                                               \
        linewidth/headcamscale[i]*headcamwfactor[i],                           \
        0.0,0.0,color)
      if headcammodel[i]==NULL err=1
    endif
  enddo
  if err==0 return 0
  change hinfo limits=0,0
  change hinfo text="Unable to define fiducials"
  if hlog!=NULL fprintf(hlog,"ERROR: Unable to define fiducials\n")
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="Pattern recognition module was unable to define fiducials. "
  draw color=BLACK text="This makes optical calibration impossible. This "
  draw text="error is unexpected. Please attempt to change calibration "
  draw text="parameters, or restart OllyTest."
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-160)/2,USERY,160,24
    name="Change parameters"
    help="Press to change calibration parameters"
  endc
  while 1 do
    if Pressed(hok) return 1
    if Pressed(hexit) return -1
    wait
  enddo
end

// Service function. If requested, make approaching head camera movement from
// the defined direction.
function int Headcamdirmovement(int head,int next,float x,float y)
  int k
  float tx,ty
  char t[128]
  k=c[head].scandir[next]
  if k==0 return                       // No head movement
  if c[head].scandist<=0.0 return      // Zero distance
  switch k
  case 1:  tx= 1.0; ty= 0.0
  case 2:  tx= 1.0; ty=-1.0
  case 3:  tx= 0.0; ty=-1.0
  case 4:  tx=-1.0; ty=-1.0
  case 5:  tx=-1.0; ty= 0.0
  case 6:  tx=-1.0; ty= 1.0
  case 7:  tx= 0.0; ty= 1.0
  case 8:  tx= 1.0; ty= 1.0
  default: tx= 0.0; ty= 0.0
  endsw
  if x<=$LAY.leftlimit/1000.0 && tx<0.0 return
  if x>=$LAY.rightlimit/1000.0 && tx>0.0 return
  if y<=$LAY.bottom[head/2]/1000.0 && ty<0.0 return
  if y>=$LAY.top[head/2]/1000.0 && ty>0.0 return
  x=x+c[head].scandist*tx
  x=Max($LAY.leftlimit/1000.0,Min(x,$LAY.rightlimit/1000.0))
  y=y+c[head].scandist*ty
  y=Max($LAY.bottom[head/2]/1000.0,Min(y,$LAY.top[head/2]/1000.0))
  sprintf(t,"M @%i[%f,%fA255] NOP",head,x,y)
  SERV.Cmdimm(32,t)
end

// Returns percent of calibrated crosses for the slowest rail or, if shine-
// through is requested, percent of calibrated crosses for the slowest pair.
// Returns -1 if operator decided to quit calibration, or -2 if he pressed the
// interrupt button.
function int Headcamscan(handle hlivevideo,handle htext,handle hrotate,        \
  handle hinterrupt,handle hselect[],int selected[],handle hview,int viewon[])
  int i,j,k,n,rail,finger,nfing,head,opp,oppflash,side,ncal,next
  int channel,videox,videoy,nfound,nalt,minpercent,redraw,index,adjust
  float x,y,r,angle,found[NFID][3],fnalt[NFID][3],dx,dy,fiddif,correl
  float yoffset,oppx,oppy,oppcorr,shiftx,shifty,corrx,corry
  char s[256]
  nfing=$LAY.nfing
  minpercent=100
  for rail=0,rail<nfing,rail++ do
    side=($LAY.side[rail]!=0)
    yoffset=$LAY.yoffset[rail]/1000.0
    for finger=0,finger<2,finger++ do
      head=rail*2+finger
      if (headcams & (1<<head))==0 continue
      // Check buttons. Placed into the loop to accelerate reaction.
      if Pressed(hexit) return -1
      if hinterrupt!=NULL then
        if Pressed(hinterrupt) return -2
      endif
      if Pressed(hrotate) then
        rotateimage=Status(hrotate)
        redraw=1
      else
        redraw=0
      endif
      if hselect[head]!=NULL && Pressed(hselect[head]) then
        if hselect[32]!=NULL then
          change hselect[32] color=BLACK
          change hselect[32] bkcolor=GRAY
        endif
        if hselect[33]!=NULL then
          change hselect[33] color=BLACK
          change hselect[33] bkcolor=GRAY
        endif
        selected[33]=0
        for j=0,j<nfing*2,j++ do
          if hselect[j]==NULL continue
          if (headcams & (1<<j))==0 continue
          if j==head then
            change hselect[j] color=LIGHTRED
            change hselect[j] bkcolor=YELLOW
            selected[j]=1
          else
            change hselect[j] color=BLACK
            change hselect[j] bkcolor=GRAY
            selected[j]=0
          endif
          redraw=1
        enddo
      else if hselect[32]!=NULL && Pressed(hselect[32]) then
        change hselect[32] color=LIGHTRED
        change hselect[32] bkcolor=YELLOW
        if hselect[33]!=NULL then
          change hselect[33] color=BLACK
          change hselect[33] bkcolor=GRAY
        endif
        selected[33]=0
        for j=0,j<nfing*2,j++ do
          if hselect[j]==NULL continue
          if (headcams & (1<<j))==0 continue
          change hselect[j] color=BLACK
          change hselect[j] bkcolor=GRAY
          selected[j]=1
        enddo
      else if hselect[33]!=NULL && Pressed(hselect[33]) then
        if hselect[32]!=NULL then
          change hselect[32] color=BLACK
          change hselect[32] bkcolor=GRAY
        endif
        change hselect[33] color=LIGHTRED
        change hselect[33] bkcolor=YELLOW
        selected[33]=1
        if hlivevideo!=NULL then
          channel=Channelfromhead(head)
          SYS.Videoangle(hlivevideo,-1,0,Getzoom(channel),                     \
          Bcgetbri(channel,1),Bcgetctr(channel,1),0,0.0)
        endif
        for j=0,j<nfing*2,j++ do
          if hselect[j]==NULL continue
          if (headcams & (1<<j))==0 continue
          change hselect[j] color=BLACK
          change hselect[j] bkcolor=GRAY
          selected[j]=0
        enddo
        redraw=1
      endif
      if redraw then
        // Redraw first seleced head, or preselected head if buttons are absent.
        for j=0,j<nfing*2,j++ do
          if (headcams & (1<<j))==0 continue
          if hselect[j]==NULL continue
          if selected[j]==0 continue
          if hlivevideo!=NULL then
            r=(c[j].yt-$LAY.yoffset[j/2]/1000.0)/headcamradius
            angle=(Abs(r)<0.9?Asin(r):0.0)
            if (j & 1)==0 angle=-angle
            if $LAY.side[j/2]==0 angle=-angle
            channel=Channelfromhead(j)
            index=Getyindex(j,c[j].yt)
            Bcsetcam(channel,index)
            oppflash=Getoppflash(j)
            SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),     \
              Bcgetbri(channel,index),Bcgetctr(channel,index),                 \
              (selected[33]?0:2)|(longexp?4:0),rotateimage?angle:0.0)
            change htext text=format(" %i%c",head/2,head & 1?'R':'L')
          endif
          break
        enddo
      endif
      ncal=c[head].ncal
      next=c[head].next
      if ncal==0 || next>=ncal then
        continue                       // Head already calibrated or excluded
      endif
      // In demo mode, emulate scanning results. Each 20th point is bad.
      if demo then
        c[head].xm[next]=c[head].xa[next]+                                     \
          Random(accuracy)+Random(accuracy)-Random(accuracy)-Random(accuracy)
        c[head].ym[next]=c[head].ya[next]+                                     \
          Random(accuracy)+Random(accuracy)-Random(accuracy)-Random(accuracy)
        if Random(20)==0 then            // Bad point
          c[head].xm[next]=c[head].xm[next]+Random(accuracy*24)-accuracy*12
          c[head].ym[next]=c[head].ym[next]+Random(accuracy*24)-accuracy*12
        endif
        c[head].err[next]=0
        c[head].next=next+1
        continue
      endif
      // In shinethrough mode, determine light source.
      if illumination==0 then
        opp=-1
      else
        opp=Oppositeheadcam(head)
      endif
      if c[head].step==0 then
        // Camera is free, try to start movement to the next point. Note that
        // step==0 means also that light is off.
        if c[head].tstart==0 c[head].tstart=Time()
        x=c[head].xa[next]             // Ideal coordinates of the next point
        y=c[head].ya[next]
        // Calibrate left headcams first.
        if finger==1 && c[head^1].next<c[head^1].ncal continue
        for j=0,j<nfing*2,j++ do
          if j==head continue          // No collision with self
          if c[j].step==0 continue     // Free camera can be moved away
          if j==opp break              // Shinethrough source is busy, wait
          if c[j].infield!=0 &&                                                \
            Abs(x-c[j].xt)<videosafedist && Abs(y-c[j].yt)<videosafedist then
            break                      // Neighbour in the way, wait
          endif
          if j==(head^1) && ((finger==0 && x+videosafedist>c[j].xt) ||         \
            (finger==1 && x-videosafedist<c[j].xt)) then
            break                      // Opposite camera blocks the movement
          endif
        enddo
        if j<nfing*2 continue          // Movement is not possible
        // Movement is possible, start it. Note: head camera movement.
        SYS.Killimm(head)
        c[head].xt=c[head].xm[next]
        c[head].yt=c[head].ym[next]
        Headcamdirmovement(head,next,c[head].xt,c[head].yt)
        n=sprintf(s,"M @%i[%f,%fH30A%i] ",head,c[head].xt,c[head].yt,acc)
        if illumination!=0 then
          Oppositexy(c[head].xt,c[head].yt,opp,&oppx,&oppy,0.0)
          c[opp].xt=oppx
          c[opp].yt=oppy
          n=n+sprintf(s+n,"%i[%f,%fH30] ",opp,oppx,oppy)
          c[opp].step=-1               // Used as illumination
          c[opp].infield=1
        endif
        sprintf(s+n,"NOP")
        SERV.Cmdimm(head,s)
        c[head].step=1                 // Moving to point
        c[head].infield=1
        // When moving to different cross, turn off the illumination. This is
        // just a precaution because usually illumination on step 0 is already
        // off.
        if c[head].attempt==0 then
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",head)
          SERV.Cmdimm(32,s)
          if opp>=0 then
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",opp)
            SERV.Cmdimm(32,s)
          endif
        endif
        // Move free neighbours, including opposite head, into the safe (home)
        // positions.
        for j=0,j<nfing*2,j++ do
          if c[j].step!=0 continue     // Busy head, including self & shinethru
          if c[j].infield==0 continue  // Already in home position
          if illumination==0 && $LAY.side[j/2]!=side                           \
            continue                   // Head on opposite side, lights off
          if $LAY.top[j/2]/1000.0+videosafedist<c[head].yt ||                  \
            $LAY.bottom[j/2]/1000.0-videosafedist>c[head].yt                   \
            continue                   // No intersection
          sprintf(s,"M %i(Z) NOP",j)
          SERV.Cmdimm(32,s)
          c[j].infield=0
        enddo
      else if c[head].step==1 then
        // Moving to point, check whether movement is finished.
        if $A[head].length==0 then
          continue                     // Movement is not finished
        else if $A[head].answer!=S_READY then
          // Oops! Probably bad coordinates, or tester is not loaded. Mark pad
          // as not found and try to continue calibration.
          c[head].err[next]=1
          c[head].step=0
          c[head].attempt=0
          c[head].rescan=0
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",head)
          SERV.Cmdimm(32,s)
          if opp>=0 then
            c[opp].step=0
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",opp)
            SERV.Cmdimm(32,s)
          endif
          if hlog!=NULL then
            fprintf(hlog,                                                      \
            "  H%i%c:  %8.3f %8.3f  Not calibrated (movement failed)\n",       \
            head/2,head & 1?'R':'L',c[head].xa[next],c[head].ya[next])
          endif
          c[head].next=c[head].next+1  // Continue with next pad
          if (c[head].next>=ncal && c[head].tend==0) c[head].tend=Time()
        else
          // Camera is at point, turn the lights on and start delay.
          if opp<0 then
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          else
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype & 0xC)
            SERV.Cmdimm(32,s)
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",opp,illtype)
          endif
          SERV.Cmdimm(32,s)
          c[head].step=2               // Delay and scan
          c[head].timer=Time()+(cameramode==0?500:250)
        endif
      else if c[head].step==2 then
        // Wait till head will come to the rest and scan the cross.
        if cameramode<2 && Time()<c[head].timer                                \
          continue                     // Wait longer
        angle=Asin((c[head].yt-yoffset)/headcamradius)
        if finger==0 angle=-angle
        if side==0 angle=-angle
        channel=Channelfromhead(head)
        index=Getyindex(head,c[head].yt)
        if hlivevideo!=NULL && selected[head]!=0 then
          Bcsetcam(channel,index)
          oppflash=Getoppflash(head)
          SYS.Videoangle(hlivevideo,channel|oppflash,0,Getzoom(channel),       \
            Bcgetbri(channel,index),Bcgetctr(channel,index),                   \
            (selected[33]?0:2)|(longexp?4:0),rotateimage?angle:0.0)
          change htext text=format(" %i%c",head/2,head & 1?'R':'L')
        else if opp>=0 then
          // Adjust individual brightness.
          for j=0,j<nfing*2,j++ do
            if selected[j]!=0 break
          enddo
          if j<nfing*2 then
            Bcsetcam(Channelfromhead(j),Getyindex(j,c[j].yt))
            oppflash=Getoppflash(j)
            SYS.Videoangle(hlivevideo,Channelfromhead(j)|oppflash,0,           \
              Getzoom(Channelfromhead(j)),                                     \
              Bcgetbri(Channelfromhead(j),Getyindex(j,c[j].yt)),               \
              Bcgetctr(Channelfromhead(j),Getyindex(j,c[j].yt)),               \
              (selected[33]?0:2)|(longexp?4:0),rotateimage?angle:0.0)
            change htext text=format(" %i%c",j/2,j & 1?'R':'L')
          endif
        endif
        SYS.Videosize(channel,&videox,&videoy,&j)
        SYS.Nextframe(channel)
        if cameramode!=2 Delay(200)
        if cameramode==0 SYS.Nextframe(channel)
        found[1,2]=0
        nfound=SYS.Recognangle(headcammodel[head],0,0,videox,videoy,           \
          found,angle,Getclip(head))
        if headaltmodel[head]!=NULL then
          nalt=SYS.Recognangle(headaltmodel[head],0,0,videox,videoy,           \
            fnalt,angle,Getclip(head))
          if nalt>0 && (nfound<=0 || fnalt[0,2]>found[0,2]*1.05) then
            nfound=nalt
            Memcpy(found,fnalt,Sizeof(found))
          endif
        endif
        nfound=Correctfound(found,nfound)
        if (boardtype==1 && (testertype==TT_A3L ||  testertype==TT_A5 ||       \
          testertype==TT_A5L || testertype==TT_A6 ||                           \
          testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||       \
          testertype==TT_A7 || testertype==TT_A8)) ||                          \
          boardtype==2                                                         \
        then
          fiddif=0.85                  // Fiducials are rather ambiguous
        else
          fiddif=0.80                  // Old good cross
        endif
        if nfound>0 && found[0,2]>(opp<0?350:500) &&                           \
          (nfound==1 || found[1,2]<found[0,2]*fiddif) then
          // Fiducial found, check whether accuracy is sufficient.
          adjust=0
          dx=(found[0,0]-videox/2)*headcamscale[head]
          dy=(found[0,1]-videoy/2)*headcamscale[head]
          correl=found[0,2]
          r=Max(Abs(dx),Abs(dy))
          // In shinethru mode, check that illumination is homogeneous. If
          // area is invisible, check is skipped.
          if AUTOTHRU!=0 && opp>=0 && (boardtype==1 || boardtype==2) &&        \
            (testertype==TT_S1 || testertype==TT_S2 ||                         \
            testertype==TT_A7 || testertype==TT_A8) &&                         \
            r<(cameramode==2?30.0:20.0)                                        \
          then
            i=Autoadjust(head,index,opp,c[head].yt,                            \
              found[0,0]-videox/2,found[0,1]-videoy/2,                         \
              angle,0,&shiftx,&shifty)
            if i==2 then
              // Move opposite camera. Total corrections of the opposite camera
              // are limited to +/-12.0 mm.
              shiftx=Max(-12.0,Min(headthrudx[opp][index]+shiftx,12.0))
              shifty=Max(-12.0,Min(headthrudy[opp][index]+shifty,12.0))
              if shiftx!=headthrudx[opp][index] ||                             \
                shifty!=headthrudy[opp][index]                                 \
              then
                headthrudx[opp][index]=shiftx
                headthrudy[opp][index]=shifty
                adjust=1
              endif
            else if i==1 then
              // Brightness changed.
              adjust=1
            endif
          endif
          // Adjustment of the opposite illumination does not count as scan
          // attempt.
          if adjust!=0 then
            c[head].attempt=c[head].attempt-1
          endif
          if r<Max(accuracy,0.002)*(cameramode==2?10.0:6.0) && adjust==0 then
            // Positioning accuracy is sufficient and adjustment of the
            // opposite camera, if any, is not necessary. In precise camera
            // mode, I repeat video recognition once again to improve the
            // accuracy.
            if cameramode==0 then
              Delay(50)
              SYS.Nextframe(channel)
              found[1,2]=0
              nfound=SYS.Recognangle(headcammodel[head],0,0,videox,videoy,     \
                found,angle,Getclip(head))
              if headaltmodel[head]!=NULL then
                nalt=SYS.Recognangle(headaltmodel[head],0,0,videox,videoy,     \
                  fnalt,angle,Getclip(head))
                if nalt>0 && (nfound<=0 || fnalt[0,2]>found[0,2]*1.05) then
                  nfound=nalt
                  Memcpy(found,fnalt,Sizeof(found))
                endif
              endif
              nfound=Correctfound(found,nfound)
              if nfound>0 && found[0,2]>(opp<0?350:500) &&                     \
                (nfound==1 || found[1,2]<found[0,2]*fiddif)                    \
              then
                found[0,0]=(found[0,0]-videox/2)*headcamscale[head]
                found[0,1]=(found[0,1]-videoy/2)*headcamscale[head]
                dx=(found[0,0]+dx)/2.0
                dy=(found[0,1]+dy)/2.0
                correl=(found[0,2]+correl)/2.0
              endif
            endif
            // Offsets dx and dy are given in millimeters along the camera
            // axes. We must rotate them into the tester coordinates.
            x=dx*Cos(angle)+dy*Sin(angle)
            y=dy*Cos(angle)-dx*Sin(angle)
            if side!=0 x=-x            // Mirror X for the bottom camera
            c[head].xm[next]=c[head].xm[next]+x
            c[head].ym[next]=c[head].ym[next]-y
            c[head].err[next]=0
            c[head].step=0
            c[head].attempt=0
            c[head].rescan=0
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",head)
            SERV.Cmdimm(32,s)
            if opp>=0 then
              c[opp].step=0
              sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",opp)
              SERV.Cmdimm(32,s)
            endif
            if hlog!=NULL then
              fprintf(hlog,"  H%i%c:  %8.3f %8.3f  %7.4f %7.4f   Corr=%4.0f\n",\
              head/2,head & 1?'R':'L',c[head].xa[next],c[head].ya[next],       \
              c[head].xm[next]-c[head].xa[next],                               \
              c[head].ym[next]-c[head].ya[next],correl)
            endif
            if (c[head].mode & CM_CORRXY)!=0 then
              corrx=c[head].xm[next]-c[head].xa[next]
              corry=c[head].ym[next]-c[head].ya[next]
              for i=next+1,i<ncal,i++ do
                c[head].xm[i]=c[head].xa[i]+corrx
                c[head].ym[i]=c[head].ya[i]+corry
              enddo
              c[head].mode=c[head].mode & (~CM_CORRXY)
            endif
            c[head].next=next+1
            if (c[head].next>=ncal && c[head].tend==0) c[head].tend=Time()
          else if c[head].attempt>=5 then
            // Uh-oh, too many attempts without success.
            c[head].err[next]=1
            c[head].step=0
            c[head].attempt=0
            c[head].rescan=0
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",head)
            SERV.Cmdimm(32,s)
            if opp>=0 then
              c[opp].step=0
              sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",opp)
              SERV.Cmdimm(32,s)
            endif
            if hlog!=NULL then
              fprintf(hlog,                                                    \
              "  H%i%c:  %8.3f %8.3f  Not calibrated (too many attempts)\n",   \
              head/2,head & 1?'R':'L',c[head].xa[next],c[head].ya[next])
            endif
            c[head].next=c[head].next+1
            if (c[head].next>=ncal && c[head].tend==0) c[head].tend=Time()
          else
            // Another step is necessary to reach requested accuracy.
            x=dx*Cos(angle)+dy*Sin(angle)
            y=dy*Cos(angle)-dx*Sin(angle)
            if side!=0 x=-x            // Mirror X for the bottom camera
            c[head].xm[next]=c[head].xm[next]+x
            c[head].ym[next]=c[head].ym[next]-y
            c[head].attempt=c[head].attempt+1
            // Send new movement.
            c[head].xt=c[head].xm[next]
            c[head].yt=c[head].ym[next]
            Headcamdirmovement(head,next,c[head].xt,c[head].yt)
            n=sprintf(s,"M @%i[%f,%fH30A%i] ",head,c[head].xt,c[head].yt,acc)
            if opp>=0 then
              if c[head].rescan==1 || c[head].rescan==4 then
                oppcorr=1.0
              else if c[head].rescan==2 || c[head].rescan==5 then
                oppcorr=-1.0
              else
                oppcorr=0.0
              endif
              Oppositexy(c[head].xt,c[head].yt,opp,&oppx,&oppy,oppcorr)
              c[opp].xt=oppx
              c[opp].yt=oppy
              n=n+sprintf(s+n,"%i[%f,%fH30] ",opp,oppx,oppy)
            endif
            sprintf(s+n,"NOP")
            SERV.Cmdimm(head,s)
            c[head].step=1             // Moving to point
          endif
        else if opp>=0 then
          // Shinethrough calibration: fiducial is ambiguous or not recognized.
          // If image is too bright, try to adjust. Otherwise, change
          // coordinates of back illumination and retry.
          if AUTOTHRU!=0 && (boardtype==1 || boardtype==2) &&                  \
            (testertype==TT_S1 || testertype==TT_S2 ||                         \
            testertype==TT_A7 || testertype==TT_A8)                            \
          then
            i=Autoadjust(head,index,opp,c[head].yt,0,0,angle,1,&shiftx,&shifty)
          else
            i=0
          endif
          if i!=1 then                 // i=1 means adjusted brightness
            if hlog!=NULL then
              fprintf(hlog,"  Error H%i%c:  ",head/2,head & 1?'R':'L')
              if (nfound==0) then
                fprintf(hlog,"No fiducials\n")
              else
                fprintf(hlog,"%.3f,%.3f(%i)",                                  \
                  found[0,0],found[0,1],found[0,2])
                if nfound>=2 then
                  fprintf(hlog,", %.3f,%.3f(%i)",                              \
                  found[1,0],found[1,1],found[1,2])
                endif
                fprintf(hlog,"\n")
              endif
            endif
            c[head].rescan=c[head].rescan+1
            if c[head].rescan>=6 then
              c[head].err[next]=1      // No chance, give up
              c[head].rescan=0
              if hlog!=NULL then
                fprintf(hlog,                                                  \
                "  H%i%c:  %8.3f %8.3f  Not calibrated (no cross)\n",          \
                head/2,head & 1?'R':'L',c[head].xa[next],c[head].ya[next])
              endif
              c[head].next=c[head].next+1
              if (c[head].next>=ncal && c[head].tend==0) c[head].tend=Time()
              c[head].step=0
              c[head].attempt=0
              c[head].rescan=0
              sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",head)
              SERV.Cmdimm(32,s)
              if opp>=0 then
                c[opp].step=0
                sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",opp)
                SERV.Cmdimm(32,s)
              endif
            else
              c[head].xt=c[head].xm[next]
              c[head].yt=c[head].ym[next]
              if c[head].rescan==3 then
                if viewon[0]!=0 then
                  Showcurrscan(-1,0)
                  if hview!=NULL change hview position=-1,-1,LEFTX,LEFTY
                  viewon[0]=0
                endif
                Bcdisable()
                change htext position=-1000,*,*,*
                change hrotate position=-1000,*,*,*
                Bccreate(hview,-1,-1,channel,index,0)
                i=Adjustheadcamoffset(head,c[head].xt,c[head].yt,0,            \
                  hlivevideo,NULL,hrotate,htext,0)
                if i<0 return -1         // Operator decided to quit calibration
                Bcdelete()
                change htext position=2,296,LEFTX-4,22
                change hrotate position=24,330,LEFTX-48,20
              endif
              Headcamdirmovement(head,next,c[head].xt,c[head].yt)
              n=sprintf(s,"M @%i[%f,%fH30A%i] ",head,c[head].xt,c[head].yt,acc)
              if AUTOTHRU!=0 then
                oppcorr=0.0
              else if c[head].rescan==1 || c[head].rescan==4 then
                oppcorr=1.0
              else if c[head].rescan==2 || c[head].rescan==5 then
                oppcorr=-1.0
              else
                oppcorr=0.0
              endif
              Oppositexy(c[head].xt,c[head].yt,opp,&oppx,&oppy,oppcorr)
              c[opp].xt=oppx
              c[opp].yt=oppy
              sprintf(s+n,"%i[%f,%fH30] NOP",opp,oppx,oppy)
              SERV.Cmdimm(head,s)
              c[head].step=1           // Moving to point
            endif
          endif
        else
          // No shinethrough: fiducial is ambiguous or not recognized. Change
          // coordinates of initial point and retry.
          if hlog!=NULL then
            fprintf(hlog,"  Error H%i%c:  ",head/2,head & 1?'R':'L')
            if (nfound==0) then
              fprintf(hlog,"No fiducials\n")
            else
              fprintf(hlog,"%.3f,%.3f(%i)",found[0,0],found[0,1],found[0,2])
              if nfound>=2 then
                fprintf(hlog,", %.3f,%.3f(%i)",found[1,0],found[1,1],found[1,2])
              endif
              fprintf(hlog,"\n")
            endif
          endif
          c[head].rescan=c[head].rescan+1
          r=Min(videox,videoy)*headcamscale[head]/6.0
          if c[head].rescan==1 then
            c[head].xm[next]=c[head].xa[next]-r
            c[head].ym[next]=c[head].ya[next]-r
          else if c[head].rescan==2 then
            c[head].xm[next]=c[head].xa[next]-r
            c[head].ym[next]=c[head].ya[next]+r
          else if c[head].rescan==3 then
            c[head].xm[next]=c[head].xa[next]+r
            c[head].ym[next]=c[head].ya[next]+r
          else if c[head].rescan==4 then
            c[head].xm[next]=c[head].xa[next]+r
            c[head].ym[next]=c[head].ya[next]-r
          else                           // No chance, give up
            c[head].err[next]=1
            c[head].rescan=0
            if hlog!=NULL then
              fprintf(hlog,                                                    \
              "  H%i%c:  %8.3f %8.3f  Not calibrated (no cross)\n",            \
              head/2,head & 1?'R':'L',c[head].xa[next],c[head].ya[next])
            endif
            c[head].next=c[head].next+1
            if (c[head].next>=ncal && c[head].tend==0) c[head].tend=Time()
          endif
          c[head].step=0
          c[head].attempt=0
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",head)
          SERV.Cmdimm(32,s)
          if opp>=0 then
            c[opp].step=0
            sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",opp)
            SERV.Cmdimm(32,s)
          endif
        endif
      endif
    enddo
    // Calculate percent of executed tasks for the selected rail. Cameras
    // belonging to the same rail are calibrated sequentially.
    k=100
    if c[rail*2].ncal!=0 || c[rail*2+1].ncal!=0 then
      j=0
      if c[rail*2].ncal>0 j=c[rail*2].next
      if c[rail*2+1].ncal>0 j=j+c[rail*2+1].next
      k=(j*100)/(c[rail*2].ncal+c[rail*2+1].ncal)
    endif
    // In shinethrough mode, take opposite rail into account. This means, each
    // rail will be processed twice, so what?
    if illumination!=0 then
      opp=(rail<nfing/2?rail+nfing/2:rail-nfing/2)
      if c[opp*2].ncal!=0 || c[opp*2+1].ncal!=0 then
        j=0
        if c[opp*2].ncal>0 j=c[opp*2].next
        if c[opp*2+1].ncal>0 j=j+c[opp*2+1].next
        k=k/2+(j*50)/(c[opp*2].ncal+c[opp*2+1].ncal)
      endif
    endif
    minpercent=Min(minpercent,k)
  enddo
  return minpercent
end

// Scans optically all crosses specified in head calibrators. If handle hremain
// of type GRAPH or CHILD is specified, Runheadcamscan() displays elapsed and
// remaining time in this window. If hinterrupt of type BUTTON is not NULL and
// pressed, scanning is interrupted; if hstat of type BUTTON is not NULL and
// pressed, statistics window appears. Handle hlivevideo displays live video
// (and what else?). Array hselect[34] is the list of buttons (probably all
// NULLs) that select camera to display ([32] - show all, [33] - stop video
// display). Parameter firsthead specifies camera to be displayed first (-1:
// auto). Returns -1 if operator decided to quit calibration script, 0 on
// success and 2 if operator interrupted head camera scanning.
function int Runheadcamscan(handle hremain,handle hinterrupt,handle hstat,     \
  handle hview,handle hlivevideo,handle htext,handle hrotate,handle hselect[], \
  int firsthead,int delayafter)
  int i,j,t,dt,nfing,tstep,tupdate,testimated,viewon,nerr,ret
  int selected[34],interrupt,dummy
  float percent,prevpercent
  char s[128]
  change hinfo limits=0,0              // Text is set by caller
  if hremain!=NULL clear hremain
  tstep=Time()
  tupdate=tstep
  testimated=MAXINT
  viewon=0
  prevpercent=-1.0
  nfing=$LAY.nfing
  if demo==0 then
    for i=0,i<nfing*2,i++ do
      SYS.Killimm(i)                   // Remove pending commands, if any
      $A[i].length=1                   // Invalid non-zero length
    enddo
  endif
  if hlivevideo!=NULL then
    Bcsetcam(0,1)
    SYS.Videoangle(hlivevideo,0|Getoppflash(0),0,Getzoom(0),                   \
    Bcgetbri(0,1),Bcgetctr(0,1),(selected[33]?0:2)|(longexp?4:0),0.0)
  endif
  if firsthead<0 || firsthead>32 ||                                            \
    (firsthead<32 && (headcams & (1<<firsthead))==0)                           \
  then
    firsthead=-1
  endif
  if hselect[32]!=NULL && firsthead<0 firsthead=32
  for i=0,i<32,i++ do
    c[i].infield=-1                    // Invalidate home status of all heads
    if firsthead<0 && (headcams & (1<<i))!=0 firsthead=i
  enddo
  if hselect[firsthead]!=NULL then
    change hselect[firsthead] color=LIGHTRED
    change hselect[firsthead] bkcolor=YELLOW
  endif
  for i=0,i<32,i++ do
    if firsthead==i then
      selected[i]=1
    else if hselect[i]==NULL then
      continue
    else if firsthead==32 then
      selected[i]=1
    endif
  enddo
  selected[33]=0                       // 1 will turn video off
  interrupt=0
  while 1 do
    percent=Headcamscan(hlivevideo,htext,hrotate,hinterrupt,hselect,           \
      selected,hview,&viewon)
    if percent==(-1) then
      ret=-1; break                    // Operator interrupted calibration
    else if percent==(-2) then
      interrupt=1
    endif
    if percent!=prevpercent then
      prevpercent=percent
      change hinfo limits=percent*10.0,1000
    endif
    if percent>=100.0 then
      ret=0; break
    else if Pressed(hexit) then
      ret=-1; break                    // Operator interrupted calibration
    endif
    if hinterrupt!=NULL then
      if Pressed(hinterrupt) interrupt=1
    endif
    if interrupt then
      disable hinterrupt
      if demo==0 then
        change hinfo limits=0,0
        change hinfo text="Wait..."
        t=Time()+10000                 // Wait 10 s for answers
        while Time()<t do
          for i=0,i<nfing*2,i++ do
            if c[i].ncal==0 continue
            if $A[i].length==0 break
          enddo
          if i>=nfing*2 break          // Aha, all answers already here!
          wait
        enddo
        for i=0,i<nfing*2,i++ do
          SYS.Killimm(i)               // Remove pending commands, if any
          if c[i].ncal==0 continue
          sprintf(s,"M %i(Z) NOP",i)
          SERV.Cmdimm(i,s)
        enddo
        while Time()<t do
          for i=0,i<nfing*2,i++ do
            if c[i].ncal==0 continue
            if $A[i].length==0 break
          enddo
          if i>=nfing*2 break          // Aha, all answers already here!
          wait
        enddo
      endif
      ret=2; break                     // Operator interrupted the scanning
    endif
    if hstat!=NULL then
      if Pressed(hstat) then
        if viewon==0 then
          if hview!=NULL change hview position=5000,5000,LEFTX-10,288
          Showcurrscan(1,0)
          viewon=1
        else
          Showcurrscan(-1,0)
          if hview!=NULL change hview position=-1,-1,LEFTX,LEFTY
          viewon=0
        endif
      endif
      if viewon==1 Showcurrscan(0,0)
    endif
    if hremain!=NULL then
      dt=Time()-tstep
      if (percent>5.0 && dt>45000) || percent>25.0 then
        t=dt*(100.0-percent)/percent
        if t<testimated-500 || t>testimated+30000 testimated=t
      endif
      if Time()>=tupdate then
        clear hremain
        draw window=hremain
        t=Time()-tstart+500
        draw at 8,22 color=BLUE text="Elapsed time:"
        draw at 120,22 text=format("%2im %02is",t/60000,(t/1000)%60)
        t=Time()-tstep+500
        draw at 8,42 color=RED text="Step time:"
        draw at 120,42 text=format("%2im %02is",t/60000,(t/1000)%60)
        draw at 8,82 text="Bad crosses:"
        nerr=0
        for i=0,i<nfing*2,i++ do
          if c[i].ncal==0 continue
          for j=0,j<c[i].next,j++ do
            if c[i].err[j]!=0 nerr++
          enddo
        enddo
        draw at 120,82 text=format(" %i",nerr)
        draw at 8,62 text="Remains:"
        if testimated==MAXINT then
          draw at 120,62 color=DARKGRAY text=" ?"
        else
          draw at 120,62 color=RED
          draw text=format("%2im %02is",testimated/60000,(testimated/1000)%60)
        endif
        draw show
        tupdate=tupdate+1000
      endif
    endif
    wait
  enddo
  if viewon==1 Showcurrscan(-1,0)
  // Show live video for some time after scanning is finished, otherwise
  // user will not see that last fiducial that was scanned.
  if delayafter!=0 delay delayafter    // Psychological delay
  // Switch camera lights off.
  SERV.Cmdimm(32,"OUTPORT32 ALL 0x80000002,0")
  if hview!=NULL change hview position=-1,-1,LEFTX,LEFTY
  return ret
end

// Calibrates head cameras. Returns -1 if operator interrupted the calibration,
// 0 on success or when video calibration is not requested, 1 if there is an
// error in calibration data and 2 if interrupt button was pressed.
function int Calibrateheadcams()
  int i,vtype,nfing,ntop,toplist,nbot,botlist,x,y,dx,firstcam,err
  handle hview,hlivevideo,htext,hrotate,hselect[34]
  handle hremain,hinterrupt,hstat
  if headcams==0 return 0              // Works only with head cameras
  nfing=$LAY.nfing
  change hinfo limits=0,0
  if calmode==MODE_CADJ then           // C adjust does not need this routine
    return 2
  else if calmode==MODE_VER then
    Memset(c,0,Sizeof(c))
    change hinfo text="Camera verification"
    if hlog!=NULL fprintf(hlog,"Head camera verification...\n")
    if verifymode==VERIFY_ZALIGN then
      vtype=C_MVERIFY
    else if vverifytype==0 then
      vtype=C_CALIBR
    else if vverifytype==1 then
      vtype=C_CALIBR+(hverifytype<=4?hverifytype:0)
    else
      vtype=C_VERAREA
    endif
    i=Fillcalibrators(vtype,FILL_HCAM)
  else if verification then
    change hinfo text="Camera verification"
    if hlog!=NULL fprintf(hlog,"Head camera verification...\n")
    i=Fillcalibrators(C_VER3,FILL_HCAM)
  else
    Memset(c,0,Sizeof(c))
    change hinfo text="Camera calibration"
    if hlog!=NULL fprintf(hlog,"Head camera calibration...\n")
    i=Fillcalibrators(C_CALIBR,FILL_HCAM)
  endif
  if i<0 return i                      // Operator interrupted calibration
  if i>0 return 1                      // Error in parameters (impossible!)
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  htext=control TEXT
    window=hview
    position=2,296,LEFTX-4,22
    help="Currently selected head camera"
    bkcolor=LIGHTYELLOW
    color=BLACK
    font=MEDIUMFONT
    mode=M_CENTERED
  endc
  hrotate=control CUSTOMBOX
    window=hview
    position=24,330,LEFTX-48,20
    text="Rotate live video according to head position"
    help="Check to rotate picture to tester X-Y coordinates"
    font=INFOFONT
    mode=(rotateimage?M_CHECKED:0)
  endc
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text=(calmode==MODE_VER || verification?"Verification ":"Calibration ")
  draw text="of head cameras is running. Have a cup of coffee. If something "
  draw text="goes bad, doubleclick button " font=MAINFONT text="Interrupt"
  draw font=TIMESFONT text=" below."
  draw show
  hremain=control GRAPH                // GRAPH to avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,92,200,85
    help="Duration of scanning and estimated time till end of current step"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  // Create camera selection buttons.
  ntop=0; toplist=0; nbot=0; botlist=0
  for i=0,i<nfing*2,i++ do
    if (headcams & (1<<i))==0 continue // No camera on the head
    if $LAY.side[i/2]==0 then
      toplist=toplist | (1<<i)
      ntop++
    else
      botlist=botlist | (1<<i)
      nbot++
    endif
  enddo
  dx=(RIGHTX-15)/Max(ntop,nbot)-5
  if dx>50 dx=50
  y=(ntop!=0 && nbot!=0?198:208)
  if ntop>0 then
    x=(RIGHTX-(dx+5)*ntop+5)/2
    for i=0,i<nfing*2,i++ do
      if (toplist & (1<<i))==0 continue
      hselect[i]=control BUTTON
        window=hright
        position=x,y,dx,22
        name=format("%i%c",i/2,i & 1?'R':'L')
        help=format("Press to inspect head camera %i%c",i/2,i & 1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      x=x+dx+5
    enddo
    y=y+25
  endif
  if nbot>0 then
    x=(RIGHTX-(dx+5)*nbot+5)/2
    for i=0,i<nfing*2,i++ do
      if (botlist & (1<<i))==0 continue
      hselect[i]=control BUTTON
        window=hright
        position=x,y,dx,22
        name=format("%i%c",i/2,i & 1?'R':'L')
        help=format("Press to inspect head camera %i%c",i/2,i & 1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      x=x+dx+5
    enddo
    y=y+25
  endif
  if ntop+nbot>0 then
    dx=100
    hselect[32]=control BUTTON
      window=hright
      position=RIGHTX/2-dx-3,y,dx,22
      name="Show all"
      help="Press to view live video from ALL cameras"
      color=BLACK
      bkcolor=GRAY
    endc
    hselect[33]=control BUTTON
      window=hright
      position=RIGHTX/2+3,y,dx,22
      name="No video"
      help="Press to stop video display, reduces camera temperature"
      color=BLACK
      bkcolor=GRAY
    endc
  endif
  hinterrupt=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  hstat=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Statistics"
    help=""
  endc
  for i=0,i<$LAY.nfing*2,i++ do
    c[i].tstart=0
    c[i].tend=0
  enddo
  err=Runheadcamscan(hremain,hinterrupt,hstat,hview,                           \
    hlivevideo,htext,hrotate,hselect,-1,500)
  if err==0 && hlog!=NULL then
    firstcam=1
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal<=4 continue         // Exclude center and shift scans
      if c[i].tstart==0 || c[i].tend==0 continue
      if firstcam then
        fprintf(hlog,"Duration of calibration for each head camera:\n")
        firstcam=0
      endif
      fprintf(hlog,"  Head camera %i%c:  Time=%7.3f s\n",                      \
        i/2,(i & 1?'R':'L'),(c[i].tend-c[i].tstart)/1000.0)
      ;
    enddo
  endif
  return err
end

// Service function, used by Fitshuttley(). Calculates fitting weight for the
// given combination of rotation and shift.
function float Shuttleyweight(int n,float *xa,float *ya,float *xm, float *ym,  \
  float dx,float dy,float fi)
  int i
  float x0,y0,w,sfi,cfi,xt,yt
  x0=$LAY.xoffset/1000.0
  y0=$LAY.yoffset[0]/1000.0
  w=0.0
  sfi=Sin(fi)
  cfi=Cos(fi)
  for i=0,i<n,i++ do
    // Rotate point around the center of the rail 0 and add shift. Note the
    // order of the operations. Do not change it!
    xt=(xa[i]-x0)*cfi-(ya[i]-y0)*sfi+x0+dx
    yt=(xa[i]-x0)*sfi+(ya[i]-y0)*cfi+y0+dy
    // Calculate weight.
    w=w+(xt-xm[i])*(xt-xm[i])+(yt-ym[i])*(yt-ym[i])
  enddo
  return w
end

// Service function, calculates best fit foy Y shuttle corrections. Returns 1
// on success and 0 on error.
function int Fitshuttley(float *xshift,float *yshift,float *angle)
  int i,j,n,head
  float xa[512],ya[512],xm[512],ym[512]
  float x,y,fi,dx,dy,dfi,fn,fu,f0,fp,fd,r
  // Extract data.
  n=0
  for head=0,head<$LAY.nfing*2,head++ do
    if c[head].ncal==0 continue
    for i=0,i<c[head].ncal,i++ do
      if c[head].err[i]!=0 continue
      if n>=512 break
      xa[n]=c[head].xa[i]
      ya[n]=c[head].ya[i]
      xm[n]=c[head].xm[i]
      ym[n]=c[head].ym[i]
      n++
    enddo
  enddo
  if n<4 then
    xshift[0]=0.0; yshift[0]=0.0; angle[0]=0.0
    return 0                           // Insufficient data for meaningful fit
  endif
  // Fit data.
  x=0.0; y=0.0; fi=0.0
  dx=0.5; dy=0.5; dfi=0.01
  // Ten steps must be sufficient. But we don't need to spare.
  for j=0,j<50,j++ do
    // Fit angle.
    fn=Shuttleyweight(n,xa,ya,xm,ym,x,y,fi-dfi)
    f0=Shuttleyweight(n,xa,ya,xm,ym,x,y,fi)
    fp=Shuttleyweight(n,xa,ya,xm,ym,x,y,fi+dfi)
    if fp+fn-2.0*f0!=0 then
      r=(fn-fp)/(fp+fn-2.0*f0)/2.0
      fi=fi+dfi*r
      if (f0>0.00001 && fn/f0>1.02) dfi=dfi*0.9
    endif
    // Fit X and Y shifts.
    fn=Shuttleyweight(n,xa,ya,xm,ym,x-dx,y,fi)
    fd=Shuttleyweight(n,xa,ya,xm,ym,x,y-dy,fi)
    f0=Shuttleyweight(n,xa,ya,xm,ym,x,y,fi)
    fp=Shuttleyweight(n,xa,ya,xm,ym,x+dx,y,fi)
    fu=Shuttleyweight(n,xa,ya,xm,ym,x,y+dy,fi)
    if fp+fn-2.0*f0!=0 then
      r=(fn-fp)/(fp+fn-2.0*f0)/2.0
      x=x+dx*r
      if (f0>0.00001 && fn/f0>1.02) dx=dx*0.9
    endif
    if fu+fd-2.0*f0!=0 then
      r=(fd-fu)/(fu+fd-2.0*f0)/2.0
      y=y+dy*r
      if (f0>0.00001 && fd/f0>1.02) dy=dy*0.9
    endif
  enddo
  xshift[0]=x
  yshift[0]=y
  angle[0]=fi
  // Report success.
  return 1
end

// Service function, smoothes shuttle Y calibration and restores missing data.
// Returns 0 on success and -1 on error.
function int Processshuttley(int shuttle,int ny,float ystep,                   \
  float *xshift,float *yshift,float *angle,int *valid)
  int i,n
  float yshuttle[81],yout[81],x[81],y[81],a[81],d[81],x0,y0,a0
  // Extract data.
  n=0
  for i=0,i<2*ny+1,i++ do
    yout[i]=i-ny
    if valid[i]==0 continue
    yshuttle[n]=i-ny
    x[n]=xshift[i]
    y[n]=yshift[i]
    a[n]=angle[i]
    if i==ny && shuttle==0 then
      d[n]=accuracy*0.002
    else
      d[n]=accuracy*0.200
    endif
    n++
  enddo
  if n<3 then
    return -1
  endif
  // Fit data.
  SYS.Splinefit(n,yshuttle,x,d,2*ny+1,yout,xshift)
  SYS.Splinefit(n,yshuttle,y,d,2*ny+1,yout,yshift)
  SYS.Splinefit(n,yshuttle,a,d,2*ny+1,yout,angle)
  // For the right shuttle, main corrections are already matched, therefore
  // measured corrections at calibration point are not zero.
  if shuttle==1 then
    x0=xshift[ny]
    y0=yshift[ny]
    a0=angle[ny]
    for i=0,i<2*ny+1,i++ do
      xshift[i]=xshift[i]-x0
      yshift[i]=yshift[i]-y0
      angle[i]=angle[i]-a0
    enddo
  endif
  // Zero point has zero corrections by definition. Beware rounding errors!
  xshift[ny]=0.0
  yshift[ny]=0.0
  angle[ny]=0.0
  // Fill correction data.
  if shuttle==0 then
    shycor[shuttle].key=0x00594853
  else if shuttle==1 then
    shycor[shuttle].key=0x00595253
  else
    return -1                          // Error in input parameters
  endif
  shycor[shuttle].ystep=ystep*1000.0   // In micrometers
  shycor[shuttle].ny=ny
  for i=0,i<2*ny+1,i++ do
    // Shifts are in micrometers.
    shycor[shuttle].data[i*3+0]=xshift[i]*1000.0
    shycor[shuttle].data[i*3+1]=yshift[i]*1000.0
    // Rotation is in radians.
    shycor[shuttle].data[i*3+2]=angle[i]
  enddo
  // Report success.
  return 0
end

// Calibrates Y shuttle movements. Returns 0 on success, 1 if it is necessary
// to repeat step and -1 if operator cancelled the calibration.
function int Calibrateshuttley(int shuttle)
  int i,j,iy,ny,t,valid[81],err
  float ystep
  float xshift[81],yshift[81],angle[81]
  char s[80],buf[1024]
  handle hinterrupt,hview,hrepeat,hskip
  if demo!=0 return 0
  if testertype!=TT_S3 return 0        // Other machines are not supported yet
  change hinfo limits=0,0
  change hinfo text="Y shuttle movements"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="To make component tests with more than two contact points, "
  draw text="we need precise shuttle movements. They will be calibrated now."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  hview=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Statistics"
    help=""
  endc
  // These parameters are currently adjusted for S3 testers.
  ystep=10.0*Min(Max(2,throwaway),3)
  if $LAY.software==0xA9 && $LAY.rightlimit-$LAY.leftlimit<=450000 then
    ny=Floor(105.0/ystep)
  else if testertype==TT_A8 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    ny=Floor(155.0/ystep)
  else
    ny=Floor(155.0/ystep)
  endif
  // Calibration loop.
  err=0
  for iy=-ny,iy<=ny,iy++ do
    if iy==0 && shuttle==0 then
      // Corrections at zero shift for the left/only shuttle are zero by
      // definition.
      xshift[ny]=0.0
      yshift[ny]=0.0
      angle[ny]=0.0
      valid[ny]=1
      continue
    endif
    // Fill calibrators. Only electrical calibration is necessary. Note that in
    // the worst case some rails may have no calibration points at all. This is
    // not an error.
    fillshy=iy*ystep
    Fillcalibrators(C_SHY,FILL_MECH)
    Drawcalboard(0,0,0,DR_HEAD)        // Show calibration board in shuttle
    // Scan crosses.
    if hlog!=NULL then
      if shuttle==0 then
        fprintf(hlog,"Shuttle Y calibration at SHY=")
      else
        fprintf(hlog,"Right shuttle Y calibration at SHY=")
      endif
      fprintf(hlog,"%.3f mm (point %i)...\n",fillshy,iy)
    endif
    change hinfo text=format("Shuttle at %g mm",fillshy)
    i=Runelectroscan(NULL,hinterrupt,NULL,hview,fillshy)
    if i<0 return -1
    if i>0 then
      err=i; break
    endif
    // Crosses scanned. Calculate best fit corrections.
    j=iy+ny
    valid[j]=Fitshuttley(xshift+j,yshift+j,angle+j)
    if hlog!=NULL then
      fprintf(hlog,"  >>>>>> SHY=%6.1f mm:  ",fillshy)
      if valid[j] then
        fprintf(hlog,"dX=%6.2f, dY=%6.2f um, angle=%7.4f deg\n",               \
        xshift[j]*1000.0,yshift[j]*1000.0,angle[j]*180.0/PI)
      else
        fprintf(hlog,"Unable to fit data\n")
      endif
    endif
  enddo
  // This routine is usually the last in the calibration. Move all heads and
  // shuttle in home positions. Failure to do this is not a critical error.
  for i=0,i<$LAY.nfing,i++
    if c[i*2].ncal==0 continue         // Rail is excluded from calibration
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,s)
  enddo
  t=Time()
  while (1) do
    for i=0,i<$LAY.nfing,i++
      if c[i*2].ncal==0 continue
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=$LAY.nfing break             // All answers came
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>5000 break             // No answer within 5 s timeout
    wait
  enddo
  // Restore missing points by cubical spline.
  if err!=0 then
    Memset(shycor,0,Sizeof(shycor))
    return 0
  else if Processshuttley(shuttle,ny,ystep,xshift,yshift,angle,valid)!=0 then
    err=4                              // Too few points for meaningful fit
  endif
  // Load corrections and report success.
  if err==0 then
    if (cratefeatures & CF_CRATEXCOR)!=0 then
      buf[0]=S_LOADRUN
      buf[1]=17                        // Load additional calibration data
      $uint2(buf+2)=0xFF               // Crate controller
      $uint2(buf+4)=0                  // Reserved for the future
      Memcpy(buf+6,shycor,12+(shycor.ny*2+1)*12)
      SYS.Sendimm(0,6+12+(shycor.ny*2+1)*12,buf)
      t=Time()
      while err==0 do
        if $A[0].length!=0 break
        if Pressed(hexit) return -1    // Button "Exit" works as an interrupt
        if Time()-t>5000 break         // Timeout 5 s exhausted, not critical
      enddo
    endif
    return 0
  endif
  // Report error.
  change hinfo limits=0,0
  change hinfo text="Scanning problem"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if hlog!=NULL fprintf(hlog,                                                  \
    "ERROR: Too few points for meaningful shuttle Y calibration\n");
  draw text="Shuttle Y calibration is unreliable. "
  draw color=BLACK text="Component tests with moving shuttle will be "
  draw text="inaccurate. If you have no plans for such tests, press "
  draw font=MAINFONT text="Skip" font=TIMESFONT text=". Otherwise, "
  draw text="press " font=MAINFONT text="Repeat" font=TIMESFONT text="."
  draw show
  hrepeat=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Repeat"
    help="Press to repeat shuttle Y calibration"
  endc
  hskip=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Skip"
    help="Press to discard Y calibation"
  endc
  while 1 do
    if Pressed(hrepeat) then
      return 1
    else if Pressed(hskip) then
      return 0
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Allows user to select and verify crosses manually. Returns 0 on success and
// -1 if operator interrupted the verification.
function int Verifymanually()
  int i,g,n,nlh[5],nrh[5],nlv[5],nrv[5],rail,head,update,vieweron,ret
  int cam
  float x,y,dx,dy,xlh[5],ylh[5],xrh[5],yrh[5],xlv[5],ylv[5],xrv[5],yrv[5]
  char s[512]
  handle hrail,hplus,hminus,hxy,hmode,hgroups,hverify,hfinish,hu,hl,hr,hd
  handle hlist,hview,hlivevideo,htext,hrotate,hselect[34]
  change hinfo limits=0,0
  change hinfo text="Manual verification"
  clear hleft
  clear hright
  change hright help=" "
  draw window=hright font=TIMESFONT
  draw at 6,25 color=BLACK wrap=RIGHTX-5
  draw text="Select cross and press " font=MAINFONT text="Verify "
  draw font=TIMESFONT text="to measure deviations. Press " font=MAINFONT
  draw text="Finish " font=TIMESFONT text="when ready."
  hu=control BUTTON
    window=hright
    position=40,57,30,30
    name="U"
    help="Press and hold to move selection up"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hl=control BUTTON
    window=hright
    position=10,87,30,30
    name="L"
    help="Press and hold to move selection left"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hr=control BUTTON
    window=hright
    position=70,87,30,30
    name="R"
    help="Press and hold to move selection right"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hd=control BUTTON
    window=hright
    position=40,117,30,30
    name="D"
    help="Press and hold to move selection down"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  draw font=MEDIUMFONT mode=M_RIGHT at 155,70 text="Rail"
  hrail=control TEXT
    window=hright
    position=160,50,49,23
    help="Selected rail"
    font=MEDIUMFONT
    mode=M_BORDER
  endc
  hminus=control BUTTON
    window=hright
    position=210,50,23,23
    name="<"
    help="Select previous available rail"
    font=MEDIUMFONT
  endc
  hplus=control BUTTON
    window=hright
    position=234,50,23,23
    name=">"
    help="Select next available rail"
    font=MEDIUMFONT
  endc
  draw at 155,100 text="X/Y"
  hxy=control TEXT
    window=hright
    position=160,80,97,23
    help="Coordinates of center"
    font=MAINFONT
    mode=M_BORDER
  endc
  draw at 155,128 text="Mode"
  hmode=control COMBOLIST
    window=hright
    position=160,107,97,200
    help="Mode of measurements (repeat count or X*Y crosses)"
    mode=M_BORDER
  endc
  add hmode text="Single"
  add hmode text="Rep 3"
  add hmode text="Rep 10"
  add hmode text="1x3"
  add hmode text="2x3"
  add hmode text="3x3"
  add hmode text="1x5"
  add hmode text="2x5"
  add hmode text="3x5"
  add hmode text="Multi"
  change hmode select=mverifymode
  draw at 155,155 text="Groups"
  hgroups=control COMBOLIST
    window=hright
    position=160,134,97,200
    help="Number and placement of test positions"
    mode=M_BORDER
  endc
  add hgroups text="Single"
  add hgroups text="Two (175 mm)"
  change hgroups select=mverifygroups
  hlist=control LIST
    window=hright
    position=8,163,RIGHTX-16,120
    help="Verification results"
    font=TERMINALFONT
    size=65536
    mode=M_VSCROLL
  endc
  hverify=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+15,120,24
    name="Verify"
    help="Press to scan selected cross"
  endc
  hfinish=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+15,120,24
    name="Finish"
    help="Press to finish manual verification"
  endc
  draw show
  // Prepare for optical recognition.
  Getheadcamscales()
  Headcamfiducials(1,-1)
  // Select initial cross.
  for rail=0,rail<$LAY.nfing,rail++ do
    mverifyrail=rail
    mverifyx=-1000
    mverifyy=-1000
    if Fillcalibrators(C_MVERIFY,FILL_MECH)==0 && c[rail*2].ncal==1 break
  enddo
  update=1
  vieweron=0
  if hlog!=NULL fprintf(hlog,"Manual verification...\n")
  while 1 do
    if update then
      update=0
      Fillcalibrators(C_MVERIFY,FILL_MECH)
      x=c[mverifyrail*2].xa[0]
      y=c[mverifyrail*2].ya[0]
      change hrail text=format(" %i",mverifyrail)
      change hxy text=format(" %.1f / %.1f",x,y)
      Drawcalboard(0,0,0,DR_HEAD|DR_SELECT)
      vieweron=0
    endif
    if Pressed(hu) then
      mverifyy++; update=1
    else if Pressed(hl) then
      mverifyx--; update=1
    else if Pressed(hr) then
      mverifyx++; update=1
    else if Pressed(hd) then
      mverifyy--; update=1
    else if Pressed(hplus) then
      rail=mverifyrail
      while mverifyrail<$LAY.nfing-1 do
        mverifyrail++
        if Fillcalibrators(C_MVERIFY,FILL_MECH)==0 && c[mverifyrail*2].ncal>0  \
          break
        ;
      enddo
      if c[mverifyrail*2].ncal==0 mverifyrail=rail
      update=1
    else if Pressed(hminus) then
      rail=mverifyrail
      while mverifyrail>0 do
        mverifyrail--
        if Fillcalibrators(C_MVERIFY,FILL_MECH)==0 && c[mverifyrail*2].ncal>0  \
          break
        ;
      enddo
      if c[mverifyrail*2].ncal==0 mverifyrail=rail
      update=1
    else if Pressed(hmode) then
      mverifymode=Status(hmode)
      update=1
    else if Pressed(hgroups) then
      mverifygroups=Status(hgroups)
      update=1
    else if Pressed(hverify) then
      change hlist color=GREEN
      add hlist text=format("------- Rail %i  X=%.1f, Y=%.1f mm",              \
        mverifyrail,c[mverifyrail*2+0].xa[0],c[mverifyrail*2+0].ya[0])
      change hlist color=BLACK
      // Run electrical scanning.
      zscan=z                          
      if (testertype!=TT_S1 && testertype!=TT_S3) || testersides!=0x1 then
        zscan=Max(zscan,15.0)          // For safety, set high z
      endif
      sprintf(s,"STROKE %i,%i,%g",v,p,zscan)
      SERV.Cmdimm(32,s)
      Fillcalibrators(C_MVERIFY,FILL_MECH)
      Runelectroscan(NULL,NULL,NULL,NULL,0.0)
      // Calculate mean deviations for all scanned crosses, separately for
      // each group.
      for g=0,g<5,g++ do
        xlh[g]=0.0; ylh[g]=0.0; nlh[g]=0
        xrh[g]=0.0; yrh[g]=0.0; nrh[g]=0
      enddo
      for i=0,i<c[mverifyrail*2+0].ncal,i++ do
        if c[mverifyrail*2+0].err[i]==0 then
          g=c[mverifyrail*2+0].group[i]
          dx=c[mverifyrail*2+0].xm[i]-c[mverifyrail*2+0].xa[i]
          dy=c[mverifyrail*2+0].ym[i]-c[mverifyrail*2+0].ya[i]
          if mverifymode==MVM_MULTI && g>0 then
            dx=dx+((g-1) & 1?-MULTISTEP:MULTISTEP)
            dy=dy+((g-1) & 2?-MULTISTEP:MULTISTEP)
          endif
          xlh[g]=xlh[g]+dx
          ylh[g]=ylh[g]+dy
          nlh[g]++
        endif
      enddo
      for i=0,i<c[mverifyrail*2+1].ncal,i++ do
        if c[mverifyrail*2+1].err[i]==0 then
          g=c[mverifyrail*2+1].group[i]
          dx=c[mverifyrail*2+1].xm[i]-c[mverifyrail*2+1].xa[i]
          dy=c[mverifyrail*2+1].ym[i]-c[mverifyrail*2+1].ya[i]
          if mverifymode==MVM_MULTI && g>0 then
            dx=dx+((g-1) & 1?-MULTISTEP:MULTISTEP)
            dy=dy+((g-1) & 2?-MULTISTEP:MULTISTEP)
          endif
          xrh[g]=xrh[g]+dx
          yrh[g]=yrh[g]+dy
          nrh[g]++
        endif
      enddo
      for g=0,g<5,g++ do
        if nlh[g]>0 then
          xlh[g]=xlh[g]/nlh[g]; ylh[g]=ylh[g]/nlh[g]
        endif
        if nrh[g]>0 then
          xrh[g]=xrh[g]/nrh[g]; yrh[g]=yrh[g]/nrh[g]
        endif
      enddo
      // Create video viewer.
      if vieweron==0 then
        clear hleft
        hview=control CHILD
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          help="Video viewer"
          bkcolor=VIDEOFILL
        endc
        draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
        draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
        draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
        draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
        draw show
        htext=control TEXT
          window=hview
          position=2,296,LEFTX-4,22
          help="Currently selected head camera"
          bkcolor=LIGHTYELLOW
          color=BLACK
          font=MEDIUMFONT
          mode=M_CENTERED
        endc
        hrotate=control CUSTOMBOX
          window=hview
          position=24,330,LEFTX-48,20
          text="Rotate live video according to head position"
          help="Check to rotate picture to tester X-Y coordinates"
          font=INFOFONT
          mode=(rotateimage?M_CHECKED:0)
        endc
        vieweron=1
      endif
      // Run optical scanning.
      for g=0,g<5,g++ do
        xlv[g]=0.0; ylv[g]=0.0; nlv[g]=0
        xrv[g]=0.0; yrv[g]=0.0; nrv[g]=0
      enddo
      if $LAY.cameras!=0 then
        // Dedicated cameras.
        if $LAY.side[mverifyrail]==0 then
          cam=$LAY.nfing*2
        else
          cam=$LAY.nfing*2+1
        endif
        if Fillcalibrators(C_MVERIFY,FILL_VIDEO)==0 && c[cam].ncal>=1 then
          Runvideoscan(NULL,hfinish,NULL,hview,hlivevideo,0)
          for i=0,i<c[cam].ncal,i++ do
            if c[cam].err[i]==0 then
              g=c[cam].group[i]
              dx=c[cam].xm[i]-c[cam].xa[i]
              dy=c[cam].ym[i]-c[cam].ya[i]
              if mverifymode==MVM_MULTI && g>0 then
                dx=dx+((g-1) & 1?-MULTISTEP:MULTISTEP)
                dy=dy+((g-1) & 2?-MULTISTEP:MULTISTEP)
              endif
              xlv[g]=xlv[g]+dx
              ylv[g]=ylv[g]+dy
              nlv[g]++
            endif
          enddo
          for g=0,g<5,g++ do
            if nlv[g]>0 then
              xlv[g]=xlv[g]/nlv[g]; ylv[g]=ylv[g]/nlv[g]
            endif
            if nrv[g]>0 then
              xrv[g]=xrv[g]/nrv[g]; yrv[g]=yrv[g]/nrv[g]
            endif
          enddo
        endif
      else
        // Head cameras.
        cam=-1
        if Fillcalibrators(C_MVERIFY,FILL_HCAM)==0 &&                          \
          (c[mverifyrail*2+0].ncal>=1 || c[mverifyrail*2+1].ncal>=1)           \
        then
          if c[mverifyrail*2+0].ncal>=1 then
            head=mverifyrail*2+0
          else
            head=mverifyrail*2+1
          endif
          Runheadcamscan(NULL,hfinish,NULL,hview,hlivevideo,htext,             \
            hrotate,hselect,head,0)
          for i=0,i<c[mverifyrail*2+0].ncal,i++ do
            if c[mverifyrail*2+0].err[i]==0 then
              g=c[mverifyrail*2+0].group[i]
              dx=c[mverifyrail*2+0].xm[i]-c[mverifyrail*2+0].xa[i]
              dy=c[mverifyrail*2+0].ym[i]-c[mverifyrail*2+0].ya[i]
              if mverifymode==MVM_MULTI && g>0 then
                dx=dx+((g-1) & 1?-MULTISTEP:MULTISTEP)
                dy=dy+((g-1) & 2?-MULTISTEP:MULTISTEP)
              endif
              xlv[g]=xlv[g]+dx
              ylv[g]=ylv[g]+dy
              nlv[g]++
            endif
          enddo
          for i=0,i<c[mverifyrail*2+1].ncal,i++ do
            if c[mverifyrail*2+1].err[i]==0 then
              g=c[mverifyrail*2+1].group[i]
              dx=c[mverifyrail*2+1].xm[i]-c[mverifyrail*2+1].xa[i]
              dy=c[mverifyrail*2+1].ym[i]-c[mverifyrail*2+1].ya[i]
              if mverifymode==MVM_MULTI && g>0 then
                dx=dx+((g-1) & 1?-MULTISTEP:MULTISTEP)
                dy=dy+((g-1) & 2?-MULTISTEP:MULTISTEP)
              endif
              xrv[g]=xrv[g]+dx
              yrv[g]=yrv[g]+dy
              nrv[g]++
            endif
          enddo
          for g=0,g<5,g++ do
            if nlv[g]>0 then
              xlv[g]=xlv[g]/nlv[g]; ylv[g]=ylv[g]/nlv[g]
            endif
            if nrv[g]>0 then
              xrv[g]=xrv[g]/nrv[g]; yrv[g]=yrv[g]/nrv[g]
            endif
          enddo
        endif
      endif
      // Display results.
      if mverifymode==MVM_MULTI then
        // Multiscan mode. Show information by head.
        n=0
        for g=0,g<5,g++ do
          // Display information for the left head.
          if nlh[g]==0 continue
          if n==0 then
            n=sprintf(s,"Head %iL (%i) ",mverifyrail,g)
          else
            n=sprintf(s,"        (%i) ",g)
          endif
          sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xlh[g],ylh[g])
          add hlist text=s
        enddo
        n=0
        for g=0,g<5,g++ do
          // Display information for the right head.
          if nrh[g]==0 continue
          if n==0 then
            n=sprintf(s,"Head %iR (%i) ",mverifyrail,g)
          else
            n=sprintf(s,"        (%i) ",g)
          endif
          sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xrh[g],yrh[g])
          add hlist text=s
        enddo
        if cam>=0 then
          n=0
          for g=0,g<5,g++ do
            // Display information for the dedicated camera on the side.
            if nlv[g]==0 continue
            if n==0 then
              n=sprintf(s,"Cam %s (%i) ",cam==$LAY.nfing*2?"top":"bot",g)
            else
              n=sprintf(s,"        (%i) ",g)
            endif
            sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xlv[g],ylv[g])
            add hlist text=s
          enddo
        else
          n=0
          for g=0,g<5,g++ do
            // Display information for the left head camera.
            if nlv[g]==0 continue
            if n==0 then
              n=sprintf(s,"Cam  %iL (%i) ",mverifyrail,g)
            else
              n=sprintf(s,"        (%i) ",g)
            endif
            sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xlv[g],ylv[g])
            add hlist text=s
          enddo
          n=0
          for g=0,g<5,g++ do
            // Display information for the right head camera.
            if nrv[g]==0 continue
            if n==0 then
              n=sprintf(s,"Cam  %iR (%i) ",mverifyrail,g)
            else
              n=sprintf(s,"        (%i) ",g)
            endif
            sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xrv[g],yrv[g])
            add hlist text=s
          enddo
        endif
      else
        // Standard mode. Show information by group.
        for g=0,g<5,g++ do
          // Display information for the left head.
          if nlh[g]==0 && nrh[g]==0 continue
          n=sprintf(s,"Head %iL (%i) ",mverifyrail,g)
          if nlh[g]==0 then
            sprintf(s+n,"Error")
          else
            sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xlh[g],ylh[g])
          endif
          add hlist text=s
          // Display information for the right head.
          n=sprintf(s,"Head %iR (%i) ",mverifyrail,g)
          if nrh[g]==0 then
            sprintf(s+n,"Error")
          else
            sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xrh[g],yrh[g])
          endif
          add hlist text=s
          // Display information for the camera(s).
          if cam>=0 then
            if nlv[g]>0 then
              n=sprintf(s,"Cam %s (%i) ",cam==$LAY.nfing*2?"top":"bot",g)
              sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xlv[g],ylv[g])
              add hlist text=s
            endif
          else
            if nlv[g]>0 then
              n=sprintf(s,"Cam  %iL (%i) ",mverifyrail,g)
              sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xlv[g],ylv[g])
              add hlist text=s
            endif
            if nrv[g]>0 then
              n=sprintf(s,"Cam  %iR (%i) ",mverifyrail,g)
              sprintf(s+n,"dX=%7.4f dY=%7.4f mm",xrv[g],yrv[g])
              add hlist text=s
            endif
          endif
        enddo
      endif
      change hinfo limits=0,0
    else if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hfinish) then
      ret=0; break
    endif
    wait
  enddo
  return ret
end

// Verifies repeatability of scanning. This feature is implemented both for
// dedicated and for on-head cameras.
function int Verifycamerastability()
  int i,rail,update,vieweron,oldy,head,channel,nbad,color,mode,ret
  float x,y,dist,sx[5],sy[5]
  char s[256]
  handle hu,hl,hr,hd,hxy,hside,hloops,hdist,hdir,hill,hadj,hcolor
  handle hlist,hview,hlivevideo,htext,hrotate,hverify,hfinish
  handle hselect[34],holdright
  if cameras==0 && headcams==0 return
  change hinfo limits=0,0
  change hinfo text="Camera stability"
  clear hright
  change hright help=" "
  draw window=hright font=TIMESFONT
  hu=control BUTTON
    window=hright
    position=40,17,30,30
    name="U"
    help="Press and hold to move selection up"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hl=control BUTTON
    window=hright
    position=10,47,30,30
    name="L"
    help="Press and hold to move selection left"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hr=control BUTTON
    window=hright
    position=70,47,30,30
    name="R"
    help="Press and hold to move selection right"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  hd=control BUTTON
    window=hright
    position=40,77,30,30
    name="D"
    help="Press and hold to move selection down"
    mode=M_REPEAT
    font=MEDIUMFONT
  endc
  draw mode=M_RIGHT at 145,27 text="X/Y"
  hxy=control TEXT
    window=hright
    position=150,8,107,23
    help="Coordinates of center"
    font=MAINFONT
    mode=M_BORDER
  endc
  draw at 145,55 text="Side"
  hside=control COMBOLIST
    window=hright
    position=150,35,107,200
    help="Side to scan"
  endc
  add hside text="Top"
  add hside text="Bottom"
  if usesides==0x2 then
    change hside select=1
  else
    change hside select=0
  endif
  if usesides!=0x3 disable hside
  draw at 145,83 text="Loops"
  hloops=control COMBOLIST
    window=hright
    position=150,62,107,200
    help="Mode of measurements (repeat count or X*Y crosses)"
  endc
  add hloops text="1"
  add hloops text="2"
  add hloops text="5"
  add hloops text="10"
  add hloops text="20"
  change hloops select=0
  draw at 145,110 text="Move"
  hdist=control COMBOLIST
    window=hright
    position=150,89,60,200
    help="Distance of movements, millimeters"
  endc
  add hdist text="0.0"
  add hdist text="0.5"
  add hdist text="1.0"
  add hdist text="2.0"
  add hdist text="5.0"
  add hdist text="10.0"
  add hdist text="20.0"
  add hdist text="50.0"
  add hdist text="100."
  add hdist text="200."
  change hdist select=0
  hdir=control COMBOLIST
    window=hright
    position=209,89,48,300
    help="Allowed direction of movements"
  endc
  add hdir text="XY"
  add hdir text="X"
  add hdir text="Y"
  add hdir text="L"
  add hdir text="R"
  add hdir text="Up"
  add hdir text="Dn"
  change hdir select=0
  draw at 105,137 text="Illumination"
  hill=control COMBOLIST
    window=hright
    position=110,116,100,300
    help="Allowed direction of movements"
  endc
  add hill text="Same side"
  if illumination==1 add hill text="Shinethru"
  change hill select=illumination
  hadj=control BUTTON
    window=hright
    position=212,116,45,24
    text="Adj"
    help="Adjust illumination"
  endc
  if cameras!=0 disable hadj
  draw at 105,164 text="Colour"
  hcolor=control COMBOLIST
    window=hright
    position=110,143,147,300
    help="Colour of fiducial on the background"
  endc
  add hcolor text="Default"
  add hcolor text="White on black"
  add hcolor text="Black on white"
  change hcolor select=0
  hlist=control LIST
    window=hright
    position=8,174,RIGHTX-16,120
    help="Verification results"
    font=TERMINALFONT
    size=65536
    mode=M_VSCROLL
  endc
  hverify=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+21,120,24
    name="Verify"
    help="Press to scan selected cross"
  endc
  hfinish=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+21,120,24
    name="Finish"
    help="Press to finish test"
  endc
  draw show
  // Select initial cross. I use C_MVERIFY to verify whether cross is available.
  mverifymode=MVM_SINGLE
  mverifygroups=MVG_SINGLE
  for rail=0,rail<$LAY.nfing,rail++ do
    mverifyrail=rail
    mverifyx=-1000
    mverifyy=-1000
    if Fillcalibrators(C_MVERIFY,FILL_MECH)==0 && c[rail*2].ncal==1 break
  enddo
  for i=0,i<34,i++ do
    hselect[i]=NULL
  enddo
  update=1
  vieweron=0
  if hlog!=NULL fprintf(hlog,"Camera stability...\n")
  while 1 do
    if update then
      update=0
      Fillcalibrators(C_MVERIFY,(cameras==0?FILL_HCAM:FILL_MECH))
      head=mverifyrail*2
      if c[head].ncal==0 head++
      x=c[head].xa[0]
      y=c[head].ya[0]
      change hxy text=format(" %.1f / %.1f",x,y)
      Drawcalboard(0,0,0,DR_HEAD|DR_SELECT|DR_RAIL)
      vieweron=0
    endif
    if Pressed(hu) then
      oldy=mverifyy; mverifyy++
      Fillcalibrators(C_MVERIFY,(cameras==0?FILL_HCAM:FILL_MECH))
      if mverifyy==oldy && mverifyrail<$LAY.nfing-1 &&                         \
        $LAY.yoffset[mverifyrail+1]/1000.0>c[mverifyrail*2].ya[0] then
        mverifyrail++
        mverifyy=-1000
        Fillcalibrators(C_MVERIFY,(cameras==0?FILL_HCAM:FILL_MECH))
        if mverifyy==(-1000) then
          mverifyrail--
          mverifyy=oldy
        endif
      endif
      update=1
    else if Pressed(hl) then
      mverifyx--; update=1
    else if Pressed(hr) then
      mverifyx++; update=1
    else if Pressed(hd) then
      oldy=mverifyy; mverifyy--
      Fillcalibrators(C_MVERIFY,(cameras==0?FILL_HCAM:FILL_MECH))
      if mverifyy==oldy && mverifyrail>0 &&                                    \
        $LAY.yoffset[mverifyrail-1]/1000.0<c[mverifyrail*2].ya[0] then
        mverifyrail--
        mverifyy=1000
        Fillcalibrators(C_MVERIFY,(cameras==0?FILL_HCAM:FILL_MECH))
        if mverifyy==1000 then
          mverifyrail++
          mverifyy=oldy
        endif
      endif
      update=1
    else if Pressed(hill) || Pressed(hcolor) then
      illumination=Status(hill)
      i=Status(hcolor)
      if i==0 then
        color=-1
      else if i==1 then
        color=WHITEONBLACK
      else
        color=BLACKONWHITE
      endif
      if cameras!=0 then
        i=Definefiducials(1,color)
      else
        i=Headcamfiducials(1,color)
      endif
      if i<0 ret=-1                    // Operator interrupted calibration
      update=1
    else if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hfinish) then
      ret=0; break
    endif
    // Many operations in verification and illumination adjustment are similar.
    if Pressed(hverify) then
      mode=1
    else if Pressed(hadj) then
      mode=2
    else
      mode=0
    endif
    if mode!=0 then
      // Determine rail and position.
      Fillcalibrators(C_MVERIFY,(cameras==0?FILL_HCAM:FILL_MECH))
      head=mverifyrail*2
      if c[head].ncal==0 head++
      mverifyxpos=c[head].xa[0]
      mverifyypos=c[head].ya[0]
      if cameras==0 then
        head=0
        for i=0,i<$LAY.nfing,i++ do
          if $LAY.bottom[i]==$LAY.bottom[mverifyrail] &&                       \
            $LAY.top[i]==$LAY.top[mverifyrail] &&                              \
            ($LAY.side[i] & 0x1)==Status(hside)                                \
          then
            head=i*2
            if ($LAY.headcameras & (1<<head))==0 head++
            break
          endif
        enddo
      else
        if Status(hside)==0 then
          head=rail*2+0
        else
          head=rail*2+1
        endif
      endif
      // Create video viewer.
      if vieweron==0 then
        clear hleft
        hview=control CHILD
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          help="Video viewer"
          bkcolor=VIDEOFILL
        endc
        draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
        draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
        draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
        draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
        draw show
        if mode==1 then
          htext=control TEXT
            window=hview
            position=2,296,LEFTX-4,22
            help="Currently selected camera"
            bkcolor=LIGHTYELLOW
            color=BLACK
            font=MEDIUMFONT
            mode=M_CENTERED
          endc
          hrotate=control CUSTOMBOX
            window=hview
            position=24,330,LEFTX-48,20
            text="Rotate live video according to head position"
            help="Check to rotate picture to tester X-Y coordinates"
            font=INFOFONT
            mode=(rotateimage?M_CHECKED:0)
          endc
          if $LAY.cameras!=0 disable hrotate
        else
          htext=NULL
          hrotate=NULL
          channel=Channelfromhead(head)
          Bccreate(hview,-1,-1,channel,1,1)
        endif
        vieweron=1
      endif
      if mode==1 then
        // Verification.
        Text(hloops,s); mverifycount=1; sscanf(s,"%i",&mverifycount);
        i=Status(hdir)
        if i==1 then
          mverifydir=0x3               // Only X movements
        else if i==2 then
          mverifydir=0xC               // Only Y movements
        else if i==3 then
          mverifydir=0x1               // Only movements from left
        else if i==4 then
          mverifydir=0x2               // Only movements from right
        else if i==5 then
          mverifydir=0x4               // Only movements from top
        else if i==6 then
          mverifydir=0x8               // Only movements from bottom
        else
          mverifydir=0xF               // X and Y movements
        endif
        Text(hdist,s); dist=20.0; sscanf(s,"%f",&dist)
        change hlist color=GREEN
        add hlist text=format("------- X=%.1f, Y=%.1f mm",                     \
          mverifyxpos,mverifyypos)
        if hlog!=NULL then
          fprintf(hlog,"------- X=%.1f, Y=%.1f mm",                            \
            mverifyxpos,mverifyypos)
          if dist==0.0 then
            fprintf(hlog,", no movements\n")
          else
            if mverifydir==0x3 then
              fprintf(hlog,", X")
            else if mverifydir==0xC then
              fprintf(hlog,", Y")
            else if mverifydir==0xF then
              fprintf(hlog,", X-Y")
            else if mverifydir==0x1 then
              fprintf(hlog,", left X")
            else if mverifydir==0x2 then
              fprintf(hlog,", right X")
            else if mverifydir==0x4 then
              fprintf(hlog,", top Y")
            else if mverifydir==0x8 then
              fprintf(hlog,", bottom Y")
            endif
            fprintf(hlog," movement %g mm\n",dist)
          endif
        endif
        change hlist color=BLACK
        if cameras==0 then
          Fillcalibrators(C_9N,FILL_HCAM)
          for i=0,i<$LAY.nfing*2,i++ do
            if i!=head then
              c[i].ncal=0
            else if c[i].ncal==0 then
              break
            endif
          enddo
          if i<$LAY.nfing*2 then
            change hlist color=LIGHTRED
            add hlist text=format("  Invalid coordinates")
            continue
          endif
        else
          Fillcalibrators(C_9N,FILL_VIDEO)
          c[head^1].ncal=0
          if c[head].ncal==0 then
            change hlist color=LIGHTRED
            add hlist text=format("  Invalid coordinates")
            continue
          endif
        endif
        c[head].scandist=dist
        // Run optical scanning.
        disable hverify
        disable hadj
        if cameras==0 then
          i=Runheadcamscan(NULL,hfinish,NULL,hview,hlivevideo,htext,           \
          hrotate,hselect,head,0)
        else
          i=Runvideoscan(NULL,hfinish,NULL,hview,hlivevideo,0)
        endif
        if i<0 return -1
        // Clean up for the case if interrupt.
        enable hadj
        enable hverify
        enable hfinish
        Pressed(hverify)
        Pressed(hfinish)
        change hinfo limits=0,0
        change hinfo text="Camera stability"
        // Display results.
        nbad=0
        Initsigma(sx)
        Initsigma(sy)
        for i=0,i<c[head].ncal,i++ do
          if c[head].err[i]!=0 then
            nbad++; continue
          endif
          Addsigma(sx,(c[head].xm[i]-c[head].xa[i])*1000.0)
          Addsigma(sy,(c[head].ym[i]-c[head].ya[i])*1000.0)
        enddo
        if nbad>0 then
          add hlist text=format("  %i bad fiducials",nbad)
          if hlog!=NULL fprintf(hlog,"  %i bad fiducials\n",nbad)
        endif
        if Getcount(sx)>0 then
          add hlist text=format("  dX: %6.1f..%6.1f, sigma %5.1f um",          \
            Getmin(sx),Getmax(sx),Getsigma(sx))
          add hlist text=format("  dY: %6.1f..%6.1f, sigma %5.1f um",          \
            Getmin(sy),Getmax(sy),Getsigma(sy))
          if hlog!=NULL then
            fprintf(hlog,"  dX: %6.1f (%6.1f..%6.1f), sigma %5.1f um\n",       \
              Getmean(sx),Getmin(sx),Getmax(sx),Getsigma(sx))
            fprintf(hlog,"  dY: %6.1f (%6.1f..%6.1f), sigma %5.1f um\n",       \
              Getmean(sy),Getmin(sy),Getmax(sy),Getsigma(sy))
            ;
          endif
        endif
      else
        // Illumination adjustment, currently only for head cameras. We need to
        // preserve the right panel.
        holdright=hright
        change holdright position=1000,*,*,*
        disable holdright
        hright=control CHILD
          window=hmain
          position=SPLIT,10+SERVY,RIGHTX,RIGHTY
          help=" "
          color=DARKGRAY
          size=2048
        endc
        if cameras==0 then
          if illumination==0 then      // Direct illumination
            i=Headcambrightness(head,1)
          else                         // Shinethrough illumination
            i=Adjustheadcamoffset(head,mverifyxpos,mverifyypos,-1,             \
            hlivevideo,NULL,NULL,NULL,1)
          endif
        endif
        destroy hright
        hright=holdright
        enable hright
        change hright position=SPLIT-1,9+SERVY,RIGHTX,RIGHTY
        if i<0 return -1
      endif
      update=1
    endif
    wait
  enddo
  return ret
end

// Verifies Z alignment using specially prepared calibration board. Similar to
// verifymanually(). Returns 0 on success, 1 if test is not supported, 2 if
// board placement must be changed, 3 if test to be repeated and -1 if operator
// interrupted verification.
function int Verifyzalignment()
  int contour[18] = { -25,10,25,10,25,7,80,7,87,0,80,-7,25,-7,25,-10,-25,-10 }
  int i,head,cam,rail,group,err,nh[32,3],nv[32,3],nz[32,3],first
  int x,y,yg,delta,redraw,xc,yc,ctr[18]
  float cy,dxh[32,3],dyh[32,3],zsurf[32,3],dxv[32,3],dyv[32,3],dx,dy,dz,zfactor
  char s[512]
  handle hstat,hcorr,hok,hrepeat,hfinish
  Drawcalboard(0,0,0,0)
  clear hright
  change hinfo limits=0,0
  change hinfo text="Z alignment test"
  // Verify whether layout of the special board is defined.
  if testertype!=TT_A3 && testertype!=TT_A5 && testertype!=TT_A5L &&           \
    testertype!=TT_A6 && testertype!=TT_S2 && testertype!=TT_A8 then
    err=1                              // (As yet) unsupported tester type
  else if boardtype!=0 then
    err=2                              // No Z alignment on the glass!
  else if testertype==TT_A5L && smallboard==0 then
    err=3                              // A5L: currently only small board
  else
    err=0                              // Verification is possible
  endif
  if err!=0 then
    change hinfo text="Unsupported verification"
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==2 then
      draw text="No verification on glass!"
      draw at 6,60 color=BLACK
      draw text="Z alignment verification on glass board is not possible. "
      draw text="Please restart the calibration script and select FR4 "
      draw text="verification."
    else if err==3 then
      draw text="Unsupported board type!"
      draw at 6,60 color=BLACK
      draw text="Z alignment verification on A5 Large is currently possible "
      draw text="only on the small calibration board. Please restart the "
      draw text="calibration script and select correct type of the calibration "
      draw text="board."
    else
      draw text="Unsupported tester!"
      draw at 6,60 color=BLACK
      draw text="Layout of the special board for your tester is not yet "
      draw text="defined. Please contact atg."
    endif
    draw show
    hok=control BUTTON
      window=hright
      position=RIGHTX/2-60,USERY,120,24
      name="OK"
      help="Press to finish verification"
    endc
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        return -1
      endif
      wait
    enddo
    return 1
  endif
  draw window=hright font=TIMESFONT
  draw at 6,25 color=BLACK wrap=RIGHTX-5
  draw text="Tester now verifies the alignment of fingers and cameras by "
  draw text="scanning crosses at different height."
  // Set parameters.
  for head=0,head<32,head++ do
    for group=0,group<3,group++ do
      nh[head,group]=0
      nv[head,group]=0
      nz[head,group]=0
      dxh[head,group]=0.0
      dyh[head,group]=0.0
      zsurf[head,group]=0.0
      dxv[head,group]=0.0
      dyv[head,group]=0.0
    enddo
  enddo
  v=Max(v,60.0)
  z=Max(z,21.0)
  zscan=z                              // For safety, set REALLY high z!
  sprintf(s,"STROKE %i,%i,%g",v,p,zscan)
  SERV.Cmdimm(32,s)
  if testertype==TT_A3 || testertype==TT_A5 ||                                 \
    (testertype==TT_A5L && smallboard==1) then
    // Small A5 FR4 board.
    mverifyx=-5
    mverifyy=0
    mverifymode=MVM_2X3                // Six crosses
    mverifygroups=MVG_3X100            // Three groups at 100 mm
/*
    mverifyx=-3                        // Parameters for A5 prototype board
    mverifyy=0
    mverifymode=MVM_1X5                // Five crosses
    mverifygroups=MVG_3X75             // Three groups at 75 mm
*/
    zfactor=1.0/1900.0                 // Empirical value!
  else if testertype==TT_A6 then
    mverifyx=-6
    mverifyy=0
    mverifymode=MVM_3X3                // Nine crosses
    mverifygroups=MVG_3X150            // Three groups at 150 mm
    zfactor=1.0/2700.0                 // Empirical value!
  else if testertype==TT_S2 then
    mverifyx=-6
    mverifyy=0
    mverifymode=MVM_3X3                // Nine crosses
    mverifygroups=MVG_3X150            // Three groups at 150 mm
    zfactor=1.0/1000.0                 // Ideal value
  endif
  mverifyrail=-1                       // All rails
  // Verify illumination.
  if cameras!=0 then
    if illumination!=0 then
      i=Manualoppdist()                // Adjust shinethrough offset
      if i<0 return -1                 // Operator interrupted calibration
    endif
    i=Manualcenters(0)                 // Adjust brightness and contrast
    if i<0 return -1                   // Operator interrupted calibration
    while 1 do
      i=Videomagnification()           // Measure camera magnification
      if i<0 return -1                 // Operator interrupted calibration
      if i==0 break                    // Magnification measured correctly
      if i==2 return 2                 // Change placement of the board
      if i==3 then                     // Request to find centers manually
        i=Manualcenters(1)             // Find centers manually
        if i<0 return -1               // Operator interrupted calibration
      endif
    enddo
    i=Definefiducials(0,-1)            // Define fiducials
    if i<0 return -1                   // Operator interrupted calibration
  else if headcams!=0 then
    Getheadcamscales()
    i=Headcambrightness(0,0)           // Adjust brightness and contrast
    if i<0 return -1                   // Operator interrupted calibration
    i=Headcamfiducials(0,-1)
    if i<0 return -1                   // Operator interrupted calibration
  endif
  // Run electrical scanning.
  i=Calibrateheads(0)
  if i<0 return -1
  // Gather statistics of electrical scanning.
  for head=0,head<$LAY.nfing*2,head++ do
    for i=0,i<c[head].ncal,i++ do
      if c[head].err[i]!=0 continue
      group=c[head].group[i]
      dxh[head,group]=dxh[head,group]+c[head].xm[i]-c[head].xa[i]
      dyh[head,group]=dyh[head,group]+c[head].ym[i]-c[head].ya[i]
      nh[head,group]++
      if c[head].z[i]!=0 then
        zsurf[head,group]=zsurf[head,group]+(c[head].z[i]-32768.0)*zfactor
        nz[head,group]++
      endif
    enddo
  enddo
  for head=0,head<$LAY.nfing*2,head++ do
    for group=0,group<3,group++ do
      if nh[head,group]>0 then
        dxh[head,group]=dxh[head,group]/nh[head,group]
        dyh[head,group]=dyh[head,group]/nh[head,group]
      endif
      if nz[head,group]>0 then
        zsurf[head,group]=zsurf[head,group]/nz[head,group]
      endif
    enddo
  enddo
  // Run optical scanning.
  if cameras!=0 then
    i=Calibratevideo(0)
    if i<0 return -1                   // Operator interrupted calibration
  else if headcams!=0 then
    i=Calibrateheadcams()
    if i<0 return -1                   // Operator interrupted calibration
  endif
  // Gather statistics of optical scanning.
  if cameras!=0 then
    for cam=$LAY.nfing*2,cam<$LAY.nfing*2+2,cam++ do
      for i=0,i<c[cam].ncal,i++ do
        if c[cam].err[i]!=0 continue
        for rail=0,rail<$LAY.nfing,rail++ do
          if $LAY.side[rail]!=(cam & 1) continue
          cy=c[cam].ya[i]*1000.0
          if cy<=$LAY.bottom[rail] && cy<$LAY.top[rail] break
        enddo
        if rail>=$LAY.nfing continue
        head=rail*2                    // As if this were the left head
        group=c[cam].group[i]
        dxv[head,group]=dxv[head,group]+c[cam].xm[i]-c[cam].xa[i]
        dyv[head,group]=dyv[head,group]+c[cam].ym[i]-c[cam].ya[i]
        nv[head,group]++
      enddo
    enddo
  else if headcams!=0 then
    for head=0,head<$LAY.nfing*2,head++ do
      for i=0,i<c[head].ncal,i++ do
        if c[head].err[i]!=0 continue
        group=c[head].group[i]
        dxv[head,group]=dxv[head,group]+c[head].xm[i]-c[head].xa[i]
        dyv[head,group]=dyv[head,group]+c[head].ym[i]-c[head].ya[i]
        nv[head,group]++
      enddo
    enddo
  endif
  for head=0,head<$LAY.nfing*2,head++ do
    for group=0,group<3,group++ do
      if nv[head,group]>0 then
        dxv[head,group]=dxv[head,group]/nv[head,group]
        dyv[head,group]=dyv[head,group]/nv[head,group]
      endif
    enddo
  enddo
  // Protocol statistics to the log file.
  if hlog!=NULL then
    fprintf(hlog,"\n  ------------------- Results of Z ")
    fprintf(hlog,"alignment verification --------------------\n")
    fprintf(hlog,"\n         ------ Field 1 ------   ------ ")
    fprintf(hlog,"Field 2 ------   ------ Field 3 ------\n")
    fprintf(hlog,"  Head   dX1,um  dY1,um  Z1,mm   dX2,um  ")
    fprintf(hlog,"dY2,um  Z2,mm   dX3,um  dY3,um  Z3,mm\n")
    for rail=0,rail<$LAY.nfing,rail++ do
      first=1
      for head=rail*2,head<rail*2+2,head++ do
        if nh[head,0]==0 && nh[head,1]==0 && nh[head,2]==0 continue
        if first then
          fprintf(hlog,"\n"); first=0
        endif
        fprintf(hlog,"   %2i%s",head/2,head & 1?"R":"L")
        for group=0,group<3,group++ do
          if nh[head,group]==0 then
            fprintf(hlog,"    -----   -----")
          else
            fprintf(hlog,"  %7.3f %7.3f",dxh[head,group],dyh[head,group])
          endif
          if nz[head,group]==0 then
            fprintf(hlog,"  -----")
          else
            fprintf(hlog," %6.2f",zsurf[head,group])
          endif
        enddo
        fprintf(hlog,"\n")
      enddo
      for head=rail*2,head<rail*2+2,head++ do
        if nv[head,0]==0 && nv[head,1]==0 && nv[head,2]==0 continue
        if first then
          fprintf(hlog,"\n"); first=0
        endif
        if cameras!=0 then
          fprintf(hlog,"  V%2i ",head/2)
        else
          fprintf(hlog,"  V%2i%s",head/2,head & 1?"R":"L")
        endif
        for group=0,group<3,group++ do
          if nv[head,group]==0 then
            fprintf(hlog,"    -----   -----")
          else
            fprintf(hlog,"  %7.3f %7.3f",dxv[head,group],dyv[head,group])
          endif
          if group<2 fprintf(hlog,"       ")
        enddo
        fprintf(hlog,"\n")
      enddo
    enddo
    fprintf(hlog,"\n  ------------------------ Head-to-camera ")
    fprintf(hlog,"differences ------------------------\n")
    fprintf(hlog,"\n         ------ Field 1 ------   ------ ")
    fprintf(hlog,"Field 2 ------   ------ Field 3 ------\n")
    fprintf(hlog,"  Head   dX1,um  dY1,um  Z1,mm   dX2,um  ")
    fprintf(hlog,"dY2,um  Z2,mm   dX3,um  dY3,um  Z3,mm\n")
    for rail=0,rail<$LAY.nfing,rail++ do
      if nv[rail*2,0]>0 && nv[rail*2,1]>0 && nv[rail*2,2]>0 then
        cam=rail*2
      else if nv[rail*2+1,0]>0 && nv[rail*2+1,1]>0 && nv[rail*2+1,2]>0 then
        cam=rail*2+1
      else
        continue
      endif
      first=1
      for head=rail*2,head<rail*2+2,head++ do
        if nh[head,0]==0 && nh[head,1]==0 && nh[head,2]==0 continue
        if first then
          fprintf(hlog,"\n"); first=0
        endif
        fprintf(hlog,"   %2i%s",head/2,head & 1?"R":"L")
        for group=0,group<3,group++ do
          if nh[head,group]==0 then
            fprintf(hlog,"    -----   -----")
          else
            fprintf(hlog,"  %7.3f %7.3f",                                      \
            dxh[head,group]-dxv[cam,group],dyh[head,group]-dyv[cam,group])
          endif
          if nz[head,group]==0 then
            fprintf(hlog,"  -----")
          else
            fprintf(hlog," %6.2f",zsurf[head,group])
          endif
        enddo
        fprintf(hlog,"\n")
      enddo
    enddo
    fprintf(hlog,"\n  ------------------------- Head-to-head ")
    fprintf(hlog,"differences -------------------------\n")
    fprintf(hlog,"\n         ------ Field 1 ------   ------ ")
    fprintf(hlog,"Field 2 ------   ------ Field 3 ------\n")
    fprintf(hlog,"  Rail   dX1,um  dY1,um  Z1,mm   dX2,um  ")
    fprintf(hlog,"dY2,um  Z2,mm   dX3,um  dY3,um  Z3,mm\n")
    for rail=0,rail<$LAY.nfing,rail++ do
      head=rail*2
      if (nh[head,0]==0 || nh[head+1,0]==0) &&                                 \
        (nh[head,1]==0 || nh[head+1,1]==0) &&                                  \
        (nh[head,2]==0 || nh[head+1,2]==0) continue
      fprintf(hlog,"\n  R%2i ",rail)
      for group=0,group<3,group++ do
        if nh[head,group]==0 || nh[head+1,group]==0 then
          fprintf(hlog,"    -----   -----")
        else
          fprintf(hlog,"  %7.3f %7.3f",                                        \
          dxh[head,group]-dxh[head+1,group],dyh[head,group]-dyh[head+1,group])
        endif
        if nz[head,group]==0 || nz[head+1,group]==0 then
          fprintf(hlog,"  -----")
        else
          fprintf(hlog," %6.2f",(zsurf[head,group]+zsurf[head+1,group])/2.0)
        endif
      enddo
      fprintf(hlog,"\n")
    enddo
    fprintf(hlog,"\n")
  endif
  // Ask whether to finish verification.
  change hinfo limits=0,0
  change hinfo text="Alignment test finished"
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 color=BLACK wrap=RIGHTX-5
  draw text="Verification is finished. "
  if hlog!=NULL then
    draw text="Results are saved to the protocol file, " font=INFOFONT
    draw text="verify.txt. " font=TIMESFONT
  endif
  draw text="Press " font=MAINFONT text="Repeat " font=TIMESFONT
  draw text="to run verification once more, or " font=MAINFONT
  draw text="Finish " font=TIMESFONT text="to close this script."
  draw show
  hstat=control RADIO
    window=hright
    position=30,110,180,20
    name="Show statistics"
    help="Check to show statistics of the measurements"
    mode=M_CHECKED
  endc
  hcorr=control RADIO
    window=hright
    position=30,135,180,20
    name="Show correction plates"
    help="Check to show thickness and position of correction plates"
  endc
  hrepeat=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Repeat"
    help="Press to repeat test"
  endc
  hfinish=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Finish"
    help="Press to close this script"
  endc
  redraw=1
  while 1 do
    if redraw then
      if redraw==1 then
        // Show test results.
        clear hleft
        draw window=hleft color=DARKGRAY font=MEDIUMFONT mode=M_CENTERED
        draw at LEFTX/2,30 text="Head-to-camera differences"
        draw color=BLACK font=SMALLFONT mode=M_LEFT
        x=18+8; y=49; delta=7
        draw at x-13,y text="Head"
        draw at x+30,y text="dX" at x+70,y text="dY" at x+110,y text="Z"
        x=170+8
        draw at x-13,y text="Head"
        draw at x+30,y text="dX" at x+70,y text="dY" at x+110,y text="Z"
        for rail=0,rail<$LAY.nfing,rail++ do
          y=y+($LAY.nfing<=6?40:33)
          if $LAY.side[rail]!=0 then
            y=y+delta; delta=0         // Distance between sides
          endif
          if nv[rail*2,0]>0 && nv[rail*2,1]>0 then
            cam=rail*2
          else if nv[rail*2+1,0]>0 && nv[rail*2+1,1]>0 then
            cam=rail*2+1
          else
            continue
          endif
          for head=rail*2,head<rail*2+2,head++ do
            draw color=DARKGRAY mode=M_RIGHT
            x=(head & 1?170:18)+13
            draw at x,y text=format("%i%s",rail,head & 1?"R":"L")
            for i=0,i<3,i++ do
              yg=y+i*9-9
              if nh[head,i]==0 then
                draw color=GRAY at x+45,yg text="-----"
                draw color=GRAY at x+85,yg text="-----"
              else
                dx=dxh[head,i]-dxv[cam,i]
                dy=dyh[head,i]-dyv[cam,i]
                draw color=(Abs(dx)>0.020?LIGHTRED:BLACK)
                draw at x+45,yg text=format("%.3f",dx)
                draw color=(Abs(dy)>0.020?LIGHTRED:BLACK)
                draw at x+85,yg text=format("%.3f",dy)
              endif
              if nz[head,i]==0 then
                draw color=GRAY at x+117,yg text="-----"
              else
                draw color=BLACK at x+117,yg text=format("%.1f",zsurf[head,i])
              endif
            enddo
          enddo
        enddo
      else
        // Show position and thickness of correction plates.
        clear hleft
        draw window=hleft color=DARKGRAY font=MEDIUMFONT mode=M_CENTERED
        draw at LEFTX/2,30 text="Correction plates"
        draw color=BLACK font=SMALLFONT mode=M_CENTERED
        draw at LEFTX/2,49 text="As seen from the top of the tester"
        draw color=BLACK font=SMALLFONT mode=M_LEFT
        y=49; delta=7
        for rail=0,rail<$LAY.nfing,rail++ do
          y=y+($LAY.nfing<=6?40:33)
          if $LAY.side[rail]!=0 then
            y=y+delta; delta=0         // Distance between sides
          endif
          if nv[rail*2,0]>0 && nv[rail*2,1]>0 then
            cam=rail*2
          else if nv[rail*2+1,0]>0 && nv[rail*2+1,1]>0 then
            cam=rail*2+1
          else
            continue
          endif
          for head=rail*2,head<rail*2+2,head++ do
            if nh[head,0]==0 || nh[head,2]==0 continue
            if nz[head,0]==0 || nz[head,2]==0 continue
            dz=zsurf[head,2]-zsurf[head,0]
            if Abs(dz)<3.0 continue
            dx=((dxh[head,2]-dxv[cam,2])-(dxh[head,0]-dxv[cam,0]))/dz*20000.0
            dy=((dyh[head,2]-dyv[cam,2])-(dyh[head,0]-dyv[cam,0]))/dz*10000.0
            draw color=DARKGRAY mode=M_RIGHT
            x=(head & 1?183:31)
            draw at x,y text=format("%i%s",rail,head & 1?"R":"L")
            yg=y+11
            xc=(head & 1?280:65)
            yc=y-12
            for i=0,i<18,i=i+2 do
              ctr[i]=(head & 1?xc-contour[i]:xc+contour[i])
              ctr[i+1]=yc+contour[i+1]
            enddo
            draw bkcolor=WHITE polygon=ctr,9
            draw at xc,yc bkcolor=WHITE fillellipse=10,10
            x=x+45
            if Abs(dx)>10.0 then
              draw color=LIGHTRED bkcolor=PINK
              if (dx>0) then
                draw at xc-25,yc-10 fillrect xc-15,yc+11
              else
                draw at xc+16,yc-10 fillrect xc+26,yc+11
              endif
              draw at x,yg text=format("%i um",Round(Abs(dx)+5.0,10.0))
              x=x+45
            endif
            if Abs(dy)>10.0 then
              draw color=GREEN bkcolor=WHITEGREEN
              if (dy<0) then
                draw at xc-25,yc-10 fillrect xc+26,yc-4
              else
                draw at xc-25,yc+5 fillrect xc+26,yc+11
              endif
              draw at x,yg text=format("%i um",Round(Abs(dy)+5.0,10.0))
            endif
          enddo
        enddo
      endif
      draw show
      redraw=0
    endif
    if Pressed(hstat) redraw=1
    if Pressed(hcorr) redraw=2
    if Pressed(hexit) return -1
    if Pressed(hrepeat) return 3
    if Pressed(hfinish) return 0
    wait
  enddo
end

function int Postprocess(int noverify)
  int y,ystep,hdcam
  handle hfinish,helectro,hopto,hmanu,hview,hheadcam,hsystem,hyencoder,hhcsys
  change hinfo limits=0,0
  if calmode==MODE_VER then
    change hinfo text="Replay finished"
  else
    change hinfo text="Calibration finished"
  endif
  Drawtesterview()
  clear hright
  change hright help=" "
  draw window=hright font=TIMESFONT
  draw at 6,30 color=BLACK wrap=RIGHTX-5
  if calmode==MODE_VER then
    draw text="Replay successfully finished, results are saved to "
    draw font=INFOFONT text="replay.txt. " font=TIMESFONT text="Please "
    draw text="inspect the data."
  else
    draw text="Calibration successfully finished. Please choose what you want "
    draw text="to do next."
  endif
  draw show
  if cameras==0 && headcams!=0 then
    hdcam=1
  else
    hdcam=0
  endif
  if noverify || hdcam==0 || precisey==0 then
    ystep=30
  else
    ystep=26
  endif
  y=USERY-(hdcam?220:190)
  if noverify then
    y=y+ystep
  else
    helectro=control BUTTON
      window=hright
      position=10,y,RIGHTX-20,24
      name="Run electrical verification"
      help="Press to start electrical verification of heads"
    endc
    if usesides==0 disable helectro
    y=y+ystep
    hopto=control BUTTON
      window=hright
      position=10,y,RIGHTX-20,24
      name="Run optical verification"
      help="Press to start optical verification of cameras"
    endc
    if cameras==0 && headcams==0 disable hopto
    y=y+ystep
    hmanu=control BUTTON
      window=hright
      position=10,y,RIGHTX-20,24
      name="Verify manually"
      help="Press to select and verify single crosses on the calibration board"
    endc
    y=y+ystep
  endif
  hview=control BUTTON
    window=hright
    position=10,y,RIGHTX-20,24
    name=(hdcam?"View head corrections":"View corrections")
    help="Press to view head correction tables"
  endc
  y=y+ystep
  if hdcam then
    hheadcam=control BUTTON
      window=hright
      position=10,y,RIGHTX-20,24
      name="View head camera corrections"
      help="Press to view correction tabless of head cameras"
    endc
    y=y+ystep
  endif
  hsystem=control BUTTON
    window=hright
    position=10,y,RIGHTX-20,24
    name="View internal head data"
    help="Press to view internal head calibration data"
  endc
  if usesides==0 || autoverified!=0 disable hsystem
  y=y+ystep
  if precisey==PRY_YPROF then
    hyencoder=control BUTTON
      window=hright
      position=10,y,RIGHTX-20,24
      name="View Y encoder data"
      help="Press to view internal data of Y encoder"
    endc
    y=y+ystep
  else
    hyencoder=NULL
  endif
  if hdcam then
    hhcsys=control BUTTON
      window=hright
      position=10,y,RIGHTX-20,24
      name="View internal head camera data"
      help="Press to view internal head camera calibration data"
    endc
    if usesides==0 || autoverified!=0 disable hhcsys
    y=y+ystep
  endif
  hfinish=control BUTTON
    window=hright
    position=10,USERY+5,RIGHTX-20,24
    name="Exit"
    help="Press to finish calibration"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hfinish) return 0
    if Pressed(helectro) return 1
    if Pressed(hopto) return 2
    if Pressed(hview) return 3
    if Pressed(hsystem) return 4
    if hdcam!=0 && Pressed(hheadcam) return 5
    if hdcam!=0 && Pressed(hhcsys) return 6
    if Pressed(hmanu) return 7
    if hyencoder!=NULL && Pressed(hyencoder) return 8
    wait
  enddo
end

// Selects what to verify or check and which crosses and fiducials will be used
// during verification. If mode is 1, assumes verification of tester accuracy.
// Returns 0 on success, 1 to change verification parameters and -1 if operator
// decided to quit calibration.
function int Selectverification(int mode)
  int i,n,y,redraw,vtype,setdist,ndist,ret
  float d,f,step,dist[20]
  char s[64]
  handle haccuracy,hzalignment,hcamstab,hmanual,hwaveness,hlimits
  handle hneedles,hzmarks,hreplay,hvideo,hhead,hcustom,hok
  handle hheadsame,hheadmiddle,hheadfive,hheadmany,hheadall,hheadhalf
  handle hvideosame,hvideoheads,hvideoall,hwavedir,hwavetype,hwavedist
  handle hleftshuttle,hrightshuttle
  hverifytype=1
  vverifytype=0
  getini("Calibration","Type of verification","%i,%i",&hverifytype,&vverifytype)
  if mode==1 goto verifyaccuracy
  change hinfo limits=0,0
  change hinfo text="Select verification mode"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please select what are you going to verify:"
  y=50
  haccuracy=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,24
    text="Tester accuracy"
    help="Press to verify the actual accuracy of the tester"
  endc
  y=y+30
  hzalignment=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,24
    text="Z alignment"
    help="Press to verify Z parallelity of heads and cameras with special board"
  endc
  if boardtype!=0 || (testertype!=TT_A3 && testertype!=TT_A5 &&                \
    testertype!=TT_A5L && testertype!=TT_A6 && testertype!=TT_S2 &&            \
    testertype!=TT_A7) ||                                                      \
    (testertype==TT_A5L && smallboard==0) ||                                   \
    ((testertype==TT_S1 || testertype==TT_S3) && smallboard!=0) then
    disable hzalignment
  endif
  y=y+30
  hcamstab=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,24
    text="Camera stability"
    help="Press to verify stability of the camera"
  endc
  if cameras==0 && headcams==0 then
    disable hcamstab
  endif
  y=y+30
  hmanual=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,24
    name="Verify manually"
    help="Press to select and verify single crosses on the calibration board"
  endc
  y=y+30
  hwaveness=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,24
    text="Rail profiles"
    help="Press to verify how straight the rails are"
  endc
  if kelvinscan==2 disable hwaveness
  y=y+30
  hlimits=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,24
    text="Rail limits"
    help="Press to assure that border points are reachable"
  endc
  y=y+30
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) &&                                 \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
    hneedles=control BUTTON
      window=hright
      position=20,y,RIGHTX-40,24
      text="Micro needles"
      help="Press to verify micro needles"
    endc
    y=y+30
  else
    hneedles=NULL
  endif
  if testertype==TT_A7 || testertype==TT_A8 then
    hzmarks=control BUTTON
      window=hright
      position=20,y,RIGHTX-40,24
      text="Z encoder marks"
      help="Press to verify position of end marks on Z encoders"
    endc
    y=y+30
  else
    hzmarks=NULL
  endif
  y=y+10
  hreplay=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,24
    text="Replay calibration"
    help="Press to simulate calibration or verification using protocolled data"
  endc
  y=y+30
  draw show
  while 1 do
    if Pressed(haccuracy) then
      goto verifyaccuracy
    else if Pressed(hzalignment) then
      verifymode=VERIFY_ZALIGN
      return 0
    else if Pressed(hcamstab) then
      verifymode=VERIFY_CAMSTAB
      return 0
    else if Pressed(hmanual) then
      verifymode=VERIFY_MANUAL
      return 0
    else if Pressed(hwaveness) then
      goto verifywaveness
    else if Pressed(hlimits) then
      verifymode=VERIFY_LIMITS
      return 0
    else if hneedles!=NULL && Pressed(hneedles) then
      verifymode=VERIFY_NEEDLES
      return 0
    else if hzmarks!=NULL && Pressed(hzmarks) then
      verifymode=VERIFY_ZMARKS
      return 0
    else if Pressed(hreplay) then
      verifymode=VERIFY_REPLAY
      return 0
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
verifyaccuracy:
  verifymode=VERIFY_ACC
  change hinfo text="Verify tester accuracy"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please select which points to use for head verification:"
  hhead=control CHILD
    window=hright
    position=40,53,RIGHTX-40,109
    help=" "
    color=WHITE
    bkcolor=WHITE
  endc
  hheadsame=control RADIO
    window=hhead
    position=0,0,RIGHTX-50,18
    text="Same as during calibration"
    help="Check to verify crosses that were used to calibrate tester"
  endc
  if testertype==TT_A7 && smallboard!=0 && boardtype==1 then
    hheadmiddle=control RADIO
      window=hhead
      position=0,18,RIGHTX-50,18
      text="Calibration + auxiliary line"
      help="Check to verify calibration crosses and auxiliary line"
    endc
    hheadfive=control RADIO
      window=hhead
      position=0,36,RIGHTX-50,18
      text="Four rows"
      help="Check to verify four rows of crosses"
    endc
  else
    hheadmiddle=control RADIO
      window=hhead
      position=0,18,RIGHTX-50,18
      text="Calibration + central line"
      help="Check to verify calibration crosses and central line"
    endc
    hheadfive=control RADIO
      window=hhead
      position=0,36,RIGHTX-50,18
      text="Five rows"
      help="Check to verify five rows of crosses"
    endc
  endif
  hheadmany=control RADIO
    window=hhead
    position=0,54,RIGHTX-50,18
    text="Evenly distributed"
    help="Check to verify crosses evenly distributed over rail area"
  endc
  hheadall=control RADIO
    window=hhead
    position=0,72,RIGHTX-50,18
    text="Whole area"
    help="Check to verify whole area, may be used for adjustment of corrections"
  endc
  if testertype==TT_S3 then
    hheadhalf=control RADIO
      window=hhead
      position=0,90,RIGHTX-50,18
      text="Near the center"
      help="Check to verify all crosses near the center, may be very long"
    endc
  else
    if hverifytype==5 hverifytype=4
    hheadhalf=NULL
  endif
  if hverifytype==0 then
    change hheadsame mode=M_CHECKED
  else if hverifytype==1 then
    change hheadmiddle mode=M_CHECKED
  else if hverifytype==2 then
    change hheadfive mode=M_CHECKED
  else if hverifytype==3 then
    change hheadmany mode=M_CHECKED
  else if hverifytype==4 then
    change hheadall mode=M_CHECKED
  else
    change hheadhalf mode=M_CHECKED
  endif
  draw at 6,182 color=BLACK
  if headcams==0 then
    draw text="and for video verification:"
  else
    draw text="and for head camera verification:"
  endif
  hvideo=control CHILD
    window=hright
    position=40,188,RIGHTX-40,55
    help=" "
    color=WHITE
    bkcolor=WHITE
  endc
  hvideosame=control RADIO
    window=hvideo
    position=0,0,RIGHTX-50,18
    text="Same as during calibration"
    help="Check to verify fiducials that were used to calibrate tester"
  endc
  hvideoheads=control RADIO
    window=hvideo
    position=0,18,RIGHTX-50,18
    text="Verified by heads"
    help="Check to verify crosses used during verification by heads"
  endc
  if boardtype==0 then
    hvideoall=control RADIO
      window=hvideo
      position=0,36,RIGHTX-50,18
      text="Evenly distributed"
      help="Check to verify crosses evenly distributed over calibration board"
    endc
  else
    if testertype!=TT_S3 disable hvideoheads
    hvideoall=control RADIO
      window=hvideo
      position=0,36,RIGHTX-50,18
      text="All available"
      help="Check to verify all available video fiducials"
    endc
  endif
  if vverifytype==0 then
    change hvideosame mode=M_CHECKED
  else if vverifytype==1 then
    change hvideoheads mode=M_CHECKED
  else
    change hvideoall mode=M_CHECKED
  endif
  draw show
  if twostep then
    hleftshuttle=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY-25,120,24
      name="Left shuttle"
      help="Press to verify left shuttle"
      color=LIGHTRED
      bkcolor=YELLOW
    endc
    hrightshuttle=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-25,120,24
      name="Right shuttle"
      help="Press to verify right shuttle"
      color=BLACK
      bkcolor=GRAY
    endc
  else
    hleftshuttle=NULL
    hrightshuttle=NULL
  endif
  if mode==1 then
    hcustom=NULL
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY+10,120,24
      name="OK"
      help="Press to confirm selection"
    endc
  else
    hcustom=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+10,120,24
      name="Customize"
      help="Press to modify verification parameters"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="OK"
      help="Press to confirm selection"
    endc
  endif
  redraw=1
  ret=0
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hheadsame) then
      hverifytype=0; redraw=1
    else if Pressed(hheadmiddle) then
      hverifytype=1; redraw=1
    else if Pressed(hheadfive) then
      hverifytype=2; redraw=1
    else if Pressed(hheadmany) then
      hverifytype=3; redraw=1
    else if Pressed(hheadall) then
      hverifytype=4; redraw=1
    else if Pressed(hheadhalf) then
      hverifytype=5; redraw=1
    else if Pressed(hvideosame) then
      vverifytype=0; redraw=2
    else if Pressed(hvideoheads) then
      vverifytype=1; redraw=2
    else if Pressed(hvideoall) then
      vverifytype=2; redraw=2
    else if hleftshuttle!=NULL && Pressed(hleftshuttle) then
      change hleftshuttle color=LIGHTRED
      change hleftshuttle bkcolor=YELLOW
      change hrightshuttle color=BLACK
      change hrightshuttle bkcolor=GRAY
      Calculateboardshift(0)
      redraw=1
    else if hrightshuttle!=NULL && Pressed(hrightshuttle) then
      change hleftshuttle color=BLACK
      change hleftshuttle bkcolor=GRAY
      change hrightshuttle color=LIGHTRED
      change hrightshuttle bkcolor=YELLOW
      Calculateboardshift(1)
      redraw=1
    else if Pressed(hcustom) then
      ret=1; break
    else if Pressed(hok) then
      break
    endif
    if redraw==1 then
      i=Fillcalibrators(C_CALIBR+hverifytype,FILL_MECH)
      if i<0 return i                  // Operator interrupted calibration
      if i!=0 return 1                 // Must change calibration parameters
      Drawcalboard(0,0,0,DR_HEAD)
      redraw=0
    else if redraw==2 && headcams==0 then
      i=Fillcalibrators(C_VER3+vverifytype,FILL_VIDEO)
      if i<0 return i                  // Operator interrupted calibration
      if i!=0 return 1                 // Must change calibration parameters
      Drawcalboard(0,0,0,DR_VIDEO)
      redraw=0
    else if redraw==2 && headcams!=0 then
      if vverifytype==0 then
        vtype=C_CALIBR
      else if vverifytype==1 then
        vtype=C_CALIBR+(hverifytype<=4?hverifytype:0)
      else
        vtype=C_VERAREA
      endif
      i=Fillcalibrators(vtype,FILL_HCAM)
      if i<0 return i                  // Operator interrupted calibration
      if i!=0 return 1                 // Must change calibration parameters
      Drawcalboard(0,0,0,DR_HEAD)
      redraw=0
    endif
    wait
  enddo
  setini("Calibration","Type of verification","%i,%i",hverifytype,vverifytype)
  return ret
verifywaveness:
  verifymode=VERIFY_WAVE
  change hinfo text="Verify rail profiles"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Select type of verification:"
  draw font=INFOFONT
  draw at 16,60 text="Direction:"
  hwavedir=control COMBOLIST
    window=hright
    position=56,68,140,100
    help="Select direction of lines"
    mode=M_BORDER
  endc
  add hwavedir text="Horizontal line"
//  add hwavedir text="Vertical line"     ---AS YET UNSUPPORTED
  change hwavedir select=wavenessdir
  draw at 16,120 text="Extent:"
  hwavetype=control COMBOLIST
    window=hright
    position=56,128,140,100
    help="Select test area"
    mode=M_BORDER
  endc
  draw at 16,180 text="Distance from center:"
  hwavedist=control COMBOLIST
    window=hright
    position=56,188,140,400
    help="Select distance from rail center"
    mode=M_BORDER|M_VSCROLL
  endc
  draw show
  if twostep then
    hleftshuttle=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY-25,120,24
      name="Left shuttle"
      help="Press to verify left shuttle"
      color=LIGHTRED
      bkcolor=YELLOW
    endc
    hrightshuttle=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-25,120,24
      name="Right shuttle"
      help="Press to verify right shuttle"
      color=BLACK
      bkcolor=GRAY
    endc
  else
    hleftshuttle=NULL
    hrightshuttle=NULL
  endif
  hcustom=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+10,120,24
    name="Customize"
    help="Press to modify verification parameters"
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+10,120,24
    name="OK"
    help="Press to confirm selection"
  endc
  setdist=1
  redraw=1
  Fillcalibrators(C_CENTER,FILL_MECH);
  while 1 do
    if setdist then
      clear hwavetype
      clear hwavedist
      if wavenessdir==0 then
        // Horizontal line.
        enable hwavetype
        add hwavetype text="Central area"
        add hwavetype text="Whole rail"
        change hwavetype select=wavenesstype
        // Vertical distance.
        d=0.0
        f=Min($LAY.top[0]-$LAY.yoffset[0],$LAY.yoffset[0]-$LAY.bottom[0])/1000.0
        if testertype==TT_M2 then
          f=f-2.0; step=ystep
        else if testertype==TT_A5L && smallboard!=0 then
          f=f-30.0; step=ystep
        else if testertype==TT_A7 && smallboard!=0 then
          f=f-25.0; step=12.5
        else
          f=f-5.0; step=ystep
        endif
        ndist=0
        while 1 do
          dist[ndist]=d; ndist++
          d=d+step
          if d>f break
        enddo
        n=0
        for i=-ndist+1,i<ndist,i++ do
          d=(i<=0?(dist[-i]):-dist[i])
          add hwavedist text=format("%.3f mm",d)
          if Abs(d-wavenessvdist)<step/4 then
            change hwavedist select=n
          endif
          n++
        enddo
      else
        add hwavetype text="Full height"
        change hwavetype select=0
        disable hwavetype
        // Horizontal distance.
        n=0
        for i=-CENTERX,i<=CENTERX,i++
          d=i*xstep
          if d<fromx-$LAY.xoffset/1000.0+xstep/2 continue
          if d>tox-$LAY.xoffset/1000.0-xstep/2 break
          add hwavedist text=format("%.3f mm",d)
          if Abs(d-wavenesshdist)<xstep/4 then
            change hwavedist select=n
          endif
          n++
        enddo
      endif
      setdist=0
    endif
    if Pressed(hexit) then
      return -1
    else if Pressed(hwavedir) then
      wavenessdir=Status(hwavedir)
      setdist=1
      redraw=1
    else if Pressed(hwavetype) then
      wavenesstype=Status(hwavetype)
      redraw=1
    else if Pressed(hwavedist) then
      Text(hwavedist,s)
      if wavenessdir==0 then
        sscanf(s,"%f",&wavenessvdist)
      else
        sscanf(s,"%f",&wavenesshdist)
      endif
      redraw=1
    else if hleftshuttle!=NULL && Pressed(hleftshuttle) then
      change hleftshuttle color=LIGHTRED
      change hleftshuttle bkcolor=YELLOW
      change hrightshuttle color=BLACK
      change hrightshuttle bkcolor=GRAY
      Calculateboardshift(0)
      Fillcalibrators(C_CENTER,FILL_MECH);
      redraw=1
    else if hrightshuttle!=NULL && Pressed(hrightshuttle) then
      change hleftshuttle color=BLACK
      change hleftshuttle bkcolor=GRAY
      change hrightshuttle color=LIGHTRED
      change hrightshuttle bkcolor=YELLOW
      Calculateboardshift(1)
      Fillcalibrators(C_CENTER,FILL_MECH);
      redraw=1
    else if Pressed(hcustom) then
      return 1
    else if Pressed(hok) then
      return 0
    endif
    if redraw then
      Drawcalboard(0,0.0,0.0,DR_HEAD|DR_WAVENESS)
      redraw=0
    endif
    wait
  enddo
end

// Calculates sum of squares of differences between new and old calibration
// after new calibration first shifted in X-Y direction (dx and dy mm), then
// rotated dfi radians counterclockwise around the point (cx,cy). Every
// physically calibrated point for camera and every head has same weight, but
// this is correct despite camera has more points because camera is usually
// more precise.
function float Calculatefit(float cx,float cy,float dx,float dy,float dfi)
  int i,n,head,nhead
  float fit,total,x1,y1,x2,y2,ss,cc
  nhead=2*$LAY.nfing
  if $LAY.cameras!=0 nhead=nhead+2
  total=0.0
  ss=Sin(dfi)
  cc=Cos(dfi)
  for head=0,head<nhead,head++ do
    if c[head].excludefromfit continue
    fit=0.0
    n=c[head].ncal
    for i=0,i<n,i++ do
      if c[head].err[i]!=0 continue    // Point not calibrated
      x1=c[head].xm[i]+dx-cx
      y1=c[head].ym[i]+dy-cy
      x2=x1*cc-y1*ss+cx-c[head].xa[i]
      y2=y1*cc+x1*ss+cy-c[head].ya[i]
      fit=fit+x2*x2+y2*y2
    enddo
    c[head].fit=fit
    total=total+fit
  enddo
  return total
end

// Compares new calibration with old (assumed to be exact) and calculates best
// fit shift and rotation for a single head. I use slow but simple method of
// parabolic gradients. Returns 0 on success and -1 if there are no points to
// make a fit.
function int Findheadfit(int head,float *bestdx,float *bestdy,float *bestfi)
  int i,h
  float cx,cy,dx,dy,dfi,dxstep,dystep,dfistep,r
  float fn,f0,fp
  for h=0,h<32,h++ do
    c[h].excludefromfit=(h==head?0:1)
  enddo
  if c[head].ncal==0 then
    bestdx[0]=0.0
    bestdy[0]=0.0
    bestfi[0]=0.0
    return -1
  endif
  // Rotation is around the center of the head area.
  cx=$LAY.xoffset/1000.0
  cy=$LAY.yoffset[head/2]/1000.0
  dx=0.0; dxstep=0.25
  dy=0.0; dystep=0.25
  dfi=0.0; dfistep=0.002
  for i=0,i<50,i++ do
    // Find best fit in X direction.
    fn=Calculatefit(cx,cy,dx-dxstep,dy,dfi)
    fp=Calculatefit(cx,cy,dx+dxstep,dy,dfi)
    f0=Calculatefit(cx,cy,dx,dy,dfi)
    if fp+fn-2.0*f0!=0 then
      r=(fn-fp)/(fp+fn-2.0*f0)/2.0
      dx=dx+dxstep*r
      if (f0>0.00001 && fn/f0>1.02) dxstep=dxstep*0.9
    endif
    // Find best fit in Y direction.
    fn=Calculatefit(cx,cy,dx,dy-dystep,dfi)
    fp=Calculatefit(cx,cy,dx,dy+dystep,dfi)
    f0=Calculatefit(cx,cy,dx,dy,dfi)
    if fp+fn-2.0*f0!=0 then
      r=(fn-fp)/(fp+fn-2.0*f0)/2.0
      dy=dy+dystep*r
      if (f0>0.00001 && fn/f0>1.02) dystep=dystep*0.9
    endif
    // Find best angular fit.
    fn=Calculatefit(cx,cy,dx,dy,dfi-dfistep)
    fp=Calculatefit(cx,cy,dx,dy,dfi+dfistep)
    f0=Calculatefit(cx,cy,dx,dy,dfi)
    if fp+fn-2.0*f0!=0 then
      r=(fn-fp)/(fp+fn-2.0*f0)/2.0
      dfi=dfi+dfistep*r
      if (f0>0.00001 && fn/f0>1.02) dfistep=dfistep*0.9
    endif
  enddo
  bestdx[0]=dx
  bestdy[0]=dy
  bestfi[0]=dfi
  return 0
end

// Preliminary check that 3-D corrections are supported and that the fresh
// calibration exists. Returns 0 on success, 1 if user wants to change type of
// calibration and -1 if he wants to interrupt calibration.
function int Check3dlayoutdate()
  int i,j,k,today
  char s[256]
  handle hback,hcont
  if (cratefeatures & CF_3DCOR)==0 then
    change hinfo limits=0,0
    change hinfo text="3-D calibration"
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK
    draw text="You are going to start the '3-D calibration', i.e. aligh "
    draw text="Z movements with the optical axis of the video camera. "
    draw text="But it seems that embedded software on your tester does not "
    draw text="support Z alignment and will ignore 3-D corrections. Are you "
    draw text="sure you want to make 3-D calibration?"
    draw show
    hback=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Back"
      help="Press to select different type of calibration"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
    while 1 do
      if Pressed(hexit) then
        return -1
      else if Pressed(hback) then
        return 1
      else if Pressed(hcont) then
        break
      endif
      wait
    enddo
  endif
  // Existing calibration must be fresh.
  Strtime(s,"%d,%m,%Y",0,0)
  sscanf(s,"%i,%i,%i",&i,&j,&k)
  today=(i+j*32+(k-1980)*512) & 0xFFFF
  if $LAY.caldate!=today then
    change hinfo limits=0,0
    change hinfo text="3-D calibration"
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK
    if cratefeatures & CF_3DCOR then
      draw text="You are going to start the '3-D calibration', i.e. aligh "
      draw text="Z movements with the optical axis of the video camera. "
    endif
    draw text="To reach good accuracy, tester must be freshly calibrated. "
    draw text="But layout reports that last calibration was on "
    Strtime(s,"%B %d, %Y",2,$LAY.caldate)
    draw font=MAINFONT text=s font=TIMESFONT text=". Are you sure "
    draw text="you want to make 3-D calibration?"
    draw show
    hback=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Back"
      help="Press to select different type of calibration"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Continue"
      help="Press to continue calibration at your own risk!"
    endc
    while 1 do
      if Pressed(hexit) then
        return -1
      else if Pressed(hback) then
        return 1
      else if Pressed(hcont) then
        break
      endif
      wait
    enddo
  endif
  change hinfo limits=0,0
  change hinfo text="3-D calibration"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="Important notification:"
  draw at 6,60 color=BLACK
  draw text="You are starting 3-D calibration of Z axes. Please ensure that "
  draw text="you use the same calibration board and set the same parameters "
  draw text="as during the last calibration!"
  hback=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Back"
    help="Press to select different type of calibration"
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Continue"
    help="Press to continue calibration"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hback) then
      return 1
    else if Pressed(hcont) then
      return 0
    endif
    wait
  enddo
end

// Verifies that old correction files contain position of the calibration board
// during the last calibration. Returns 0 on success, 1 if user decides to
// change type of calibration and -1 if he wants to interrupt calibration.
function int Check3doldcorr()
  int i,head,nheads
  handle hback,hfinish
  nheads=$LAY.nfing*2
  for head=0,head<nheads,head++ do
    if c[head].ncal==0 continue
    // The following check must be kept same as in the embedded software!
    if (c3dold.mode & 0x00000001)==0 break
    if c3dold.zcenter<10000.0 || c3dold.zcenter>40000.0 ||                     \
      Abs(c3dold.zfactorx)>=0.02 || Abs(c3dold.zfactory)>=0.02 break
    ;
  enddo
  if head>=nheads return 0             // Data is correct
  change hinfo limits=0,0
  change hinfo text="3-D calibration"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="Missing calibration data!"
  draw at 6,60 color=BLACK
  draw text="You are starting 3-D calibration of Z axes. Unfortunately, "
  draw text="existing corrections do not include Z plane of the calibration "
  draw text="board during the last calibration. 3-D calibration is not "
  draw text="possible. Please re-calibrate the tester using software that "
  draw text="fully supports 3-D."
  draw show
  hback=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Back"
    help="Press to select different type of calibration"
  endc
  hfinish=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Finish"
    help="Press to quit calibration"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hback) then
      return 1
    else if Pressed(hfinish) then
      return -1
    endif
    wait
  enddo
end

// Calculates deviation of the specified fitting from ideal.
function float Calculatevolfit(int head,                                       \
  float cx,float cy,float dx,float dy,float dfi,                               \
  float ytiltx,float ytilty,float ztiltx,float ztilty)
  int i,n
  float z,fit,ss,cc,sz,cz,x1,y1,x2,y2,h,xoffset,yoffset,r,zold,count
  ss=Sin(dfi)
  cc=Cos(dfi)
  xoffset=$LAY.xoffset/1000.0
  yoffset=$LAY.yoffset[head/2]/1000.0
  r=c[head].radius
  fit=0.0
  n=c[head].ncal
  count=0.0
  for i=0,i<n,i++ do
    if c[head].err[i]!=0 continue      // Point not calibrated
    z=c[head].z[i]
    if z<1.0 continue                  // Z coordinate unknown
    x1=c[head].xm[i]
    y1=c[head].ym[i]
    // Get Z height difference at point. Note that the sign is opposite to the
    // embedded software (here: z-zcalibr, there: zcalibr-z).
    if (head & 1) then
      // Right head.
      h=c[head].z[i]-c3dold[head].zcenter-                                     \
      c3dold[head].zfactorx*(xoffset-x1)-c3dold[head].zfactory*(yoffset-y1)
    else
      // Left head.
      h=c[head].z[i]-c3dold[head].zcenter-                                     \
      c3dold[head].zfactorx*(x1-xoffset)-c3dold[head].zfactory*(y1-yoffset)
    endif
    // Rotate and shift point coordinates to compensate rotation and shift of
    // the dedicated camera, then convert to local coordinates.
    x2=(x1-cx+dx)*cc-(y1-cy+dy)*ss+cx-xoffset
    y2=(y1-cy+dy)*cc+(x1-cx+dx)*ss+cy-yoffset
    if (head & 1) then                 // Right head
      x2=-x2; y2=-y2
    endif
    // Calculate head angle components.
    sz=y2/r
    cz=Sqrt(1.0-sz*sz)
    // Calculate corrected local cooordinates.
    x2=x2+(ytiltx+ztiltx*cz-ztilty*sz)*h
    y2=y2+(ytilty+ztiltx*sz+ztilty*cz)*h
    // Calculate deviation.
    if (head & 1) then
      // Right head.
      x2=x2-(xoffset-c[head].xa[i])
      y2=y2-(yoffset-c[head].ya[i])
    else
      // Left head.
      x2=x2-(c[head].xa[i]-xoffset)
      y2=y2-(c[head].ya[i]-yoffset)
    endif
    // Sum to minimize.
    fit=fit+x2*x2+y2*y2
    count=count+1.0
  enddo
  if count>0.0 fit=fit/count
  return fit
end

// Calculates parameters for 3-D calibration from the gathered data and applies
// them to the layout extention $EXT0. Only works if tester is equipped with
// dedicated cameras.
function int Calculate3dfactors()
  int i,side,head
  float cx,cy,dx,dy,fi,fn,f0,fp,r
  float ytiltx,ytilty,ztiltx,ztilty,step
  if $LAY.cameras==0 return            // 3-D calibration is not possible
  if hlog!=NULL then
    fprintf(hlog,"Old tilts of Y and Z axii (3-D calibration):\n")
    for head=0,head<$LAY.nfing*2,head++ do
      fprintf(hlog,"  %i%c:   Y(X)=%8.5f Y(Y)=%8.5f  Z(X)=%8.5f Z(Y)=%8.5f\n", \
        head/2,(head & 1?'R':'L'),                                             \
        $EXT0.ytiltx[head]/1.0e5,$EXT0.ytilty[head]/1.0e5,                     \
        $EXT0.ztiltx[head]/1.0e5,$EXT0.ztilty[head]/1.0e5)
      ;
    enddo
    fprintf(hlog,"New tilts of Y and Z axii:\n")
  endif
  for side=0,side<2,side++ do
    // 3-D calibration aligns heads with the dedicated camera. If camera is
    // missing, 3-D makes no sense. Note the order: first shift in X-Y
    // direction (dx and dy mm), then turn by dfi radians counterclockwise.
    if Findheadfit($LAY.nfing*2+side,&dx,&dy,&fi)<0 then
      continue
    endif
    cx=$LAY.xoffset/1000.0
    cy=$LAY.yoffset[$LAY.nfing]/1000.0
    // Calculate factors for the heads. There are four factors: tilt of Y
    // axis in X and Y, and tilt of Z axis in X and Y.
    for head=0,head<$LAY.nfing*2,head++ do
      if $LAY.side[head/2]!=side continue
      if c[head].ncal==0 continue
      if c3dold[head].key!=COPT_3D then
        if hlog!=NULL fprintf(hlog,                                            \
          "  %i%c:   Missing board position data in old correction file\n",    \
          head/2,(head & 1?'R':'L'))
        continue
      endif
      ytiltx=0.0; ytilty=0.0             // Sound initial values
      ztiltx=0.0; ztilty=0.0
      step=0.02
      // The convergence may be slow, hence so many steps. Usually 40 steps
      // are already sufficient.
      for i=0,i<100,i++ do
        // Tilt of Y axis in X direction.
        fn=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx-step,ytilty,ztiltx,ztilty)
        fp=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx+step,ytilty,ztiltx,ztilty)
        f0=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty,ztiltx,ztilty)
        if fp+fn-2.0*f0!=0 then
          r=(fn-fp)/(fp+fn-2.0*f0)/2.0
          ytiltx=ytiltx+step*r
        endif
        // Tilt of Y axis in Y direction.
        fn=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty-step,ztiltx,ztilty)
        fp=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty+step,ztiltx,ztilty)
        f0=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty,ztiltx,ztilty)
        if fp+fn-2.0*f0!=0 then
          r=(fn-fp)/(fp+fn-2.0*f0)/2.0
          ytilty=ytilty+step*r
        endif
        // Tilt difference in X direction.
        fn=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty,ztiltx-step,ztilty)
        fp=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty,ztiltx+step,ztilty)
        f0=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty,ztiltx,ztilty)
        if fp+fn-2.0*f0!=0 then
          r=(fn-fp)/(fp+fn-2.0*f0)/2.0
          ztiltx=ztiltx+step*r
        endif
        // Tilt difference in Y direction.
        fn=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty,ztiltx,ztilty-step)
        fp=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty,ztiltx,ztilty+step)
        f0=Calculatevolfit(head,cx,cy,dx,dy,fi,ytiltx,ytilty,ztiltx,ztilty)
        if fp+fn-2.0*f0!=0 then
          r=(fn-fp)/(fp+fn-2.0*f0)/2.0
          ztilty=ztilty+step*r
        endif
        step=step*0.97
      enddo
      // Tilts calculated, apply to layout. Note that measured factors are in
      // mm(board)/um(Z) and must be converted to um/um. In layout, tilts are
      // in 1/100000 um/um, so there are 5 additional orders of magnitude.
      if hlog!=NULL then fprintf(hlog,                                         \
        "  %i%c:   Y(X)=%8.5f Y(Y)=%8.5f  Z(X)=%8.5f Z(Y)=%8.5f",              \
        head/2,(head & 1?'R':'L'),                                             \
        ytiltx*1000.0,ytilty*1000.0,ztiltx*1000.0,ztilty*1000.0)
      endif
      if Abs(ytiltx)>0.000049 || Abs(ytilty)>0.000049 ||                       \
        Abs(ztiltx)>0.000049 || Abs(ztilty)>0.000049 then
        if hlog!=NULL fprintf(hlog," - too large\n")
      else
        $EXT0.valid=0x30747845
        $EXT0.ytiltx[head]=ytiltx*1.0e8
        $EXT0.ytilty[head]=ytilty*1.0e8
        $EXT0.ztiltx[head]=ztiltx*1.0e8
        $EXT0.ztilty[head]=ztilty*1.0e8
        if hlog!=NULL fprintf(hlog,"\n")
      endif
    enddo
  enddo
end

// Asks user to activate 3-D corrections in layout.
function int Check3dactive()
  handle hyes,hno
  if (cratefeatures & CF_3DCOR)==0 ||                                          \
    (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) return
  if ($EXTLAY.extcfg & EXT_3DCOR)!=0 return
  change hinfo limits=0,0
  change hinfo text="3-D calibration finished"
  Drawtesterview()
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Flag 'Use 3-D corrections' in layout is currently not set, "
  draw text="therefore results of this calibration will not be used. Do "
  draw text="you want to activate 3-D corrections?"
  draw show
  hyes=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Yes"
    help="Activate 3-D corrections"
  endc
  hno=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="No"
    help="Do NOT activate 3-D corrections"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hyes) then
      $EXTLAY.extcfg=$EXTLAY.extcfg | EXT_3DCOR
      break
    else if Pressed(hno) then
      break
    endif
    wait
  enddo
end

// Similar to Findheadfit, but calculates best fit for all heads on the
// specified side (on all sides if side is -1). Initially, it attempted to
// exclude head with worst accuracy, but I decided that this is a bad idea.
function int Findbestfit(int side,float *bestdx,float *bestdy,float *bestfi)
  int i,k,head,nhead
  float dx,dy,dfi,dxstep,dystep,dfistep,r
  float fn,f0,fp
  nhead=2*$LAY.nfing
  if $LAY.cameras!=0 nhead=nhead+2
  // First fit all heads together.
  for head=0,head<32,head++ do
    if head<nhead then
      k=($LAY.side[head/2]!=0)         // Head
    else
      k=head-nhead                     // Dedicated camera
    endif
    if side<0 || k==side then
      c[head].excludefromfit=0
    else
      c[head].excludefromfit=1
    endif
    c[head].fit=0.0
  enddo
  dx=0.0; dxstep=0.25                  // Good apriori assumptions
  dy=0.0; dystep=0.25
  dfi=0.0; dfistep=0.002
  for i=0,i<50,i++ do
    // Find best fit in X direction.
    fn=Calculatefit(centerx,centery,dx-dxstep,dy,dfi)
    fp=Calculatefit(centerx,centery,dx+dxstep,dy,dfi)
    f0=Calculatefit(centerx,centery,dx,dy,dfi)
    if fp+fn-2.0*f0!=0 then
      r=(fn-fp)/(fp+fn-2.0*f0)/2.0
      dx=dx+dxstep*r
      if (f0>0.00001 && fn/f0>1.02) dxstep=dxstep*0.9
    endif
    // Find best fit in Y direction.
    fn=Calculatefit(centerx,centery,dx,dy-dystep,dfi)
    fp=Calculatefit(centerx,centery,dx,dy+dystep,dfi)
    f0=Calculatefit(centerx,centery,dx,dy,dfi)
    if fp+fn-2.0*f0!=0 then
      r=(fn-fp)/(fp+fn-2.0*f0)/2.0
      dy=dy+dystep*r
      if (f0>0.00001 && fn/f0>1.02) dystep=dystep*0.9
    endif
    // Find best angular fit.
    fn=Calculatefit(centerx,centery,dx,dy,dfi-dfistep)
    fp=Calculatefit(centerx,centery,dx,dy,dfi+dfistep)
    f0=Calculatefit(centerx,centery,dx,dy,dfi)
    if fp+fn-2.0*f0!=0 then
      r=(fn-fp)/(fp+fn-2.0*f0)/2.0
      dfi=dfi+dfistep*r
      if (f0>0.00001 && fn/f0>1.02) dfistep=dfistep*0.9
    endif
  enddo
  bestdx[0]=dx
  bestdy[0]=dy
  bestfi[0]=dfi
end

// Shifts, then rotates measured positions of calibrated pads by specified
// amounts and calculates standard mean deviations from expected point.
function int Rotatemeasurements(float dx,float dy,float dfi)
  int i,n,head,nhead
  float ss,cc,x1,y1,statx[5],staty[5]
  nhead=2*$LAY.nfing
  if $LAY.cameras!=0 nhead=nhead+2
  ss=Sin(dfi)
  cc=Cos(dfi)
  for head=0,head<nhead,head++ do
    Initsigma(statx)
    Initsigma(staty)
    n=c[head].ncal
    for i=0,i<n,i++ do
      if c[head].err[i]!=0 continue
      x1=c[head].xm[i]+dx-centerx
      y1=c[head].ym[i]+dy-centery
      c[head].xm[i]=x1*cc-y1*ss+centerx
      c[head].ym[i]=y1*cc+x1*ss+centery
      Addsigma(statx,c[head].xm[i]-c[head].xa[i])
      Addsigma(staty,c[head].ym[i]-c[head].ya[i])
    enddo
    c[head].sigmax=Getsigma(statx)
    c[head].sigmay=Getsigma(staty)
  enddo
end

// Adjusts head or head camera corrections and loads them to the tester. On
// error, shows message and clears flag adjustcorr. Assumes that old
// corrections are valid and that corresponding calibration data is loaded.
function int Adjustcorrections(int isheadcam)
  int i,j,head,err
  float deltax,deltay,meandx[5],meandy[5]
  handle hquit,hcont
  if adjustcorr==0 return 0            // Adjustment not allowed
  err=0
  if corrsource!=CS_FILE then
    err=1; goto error                  // Invalid corrections in tester
  endif
  change hinfo limits=0,0
  if isheadcam==0 then
    change hinfo text="Adjusting head corrections..."
    if hlog!=NULL fprintf(hlog,"Adjusting head corrections...\n")
  else
    change hinfo text="Adjusting head cameras..."
    if hlog!=NULL fprintf(hlog,"Adjusting head camera corrections...\n")
  endif
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  if isheadcam==0 then
    draw text="First verification step is executed. Script will now adjust "
    draw text="head corrections."
  else
    draw text="Second verification step is executed. Script will now adjust "
    draw text="head camera corrections."
  endif
  draw show
  // Note that I do not rotate and shift measured deviations! Corrections
  // will be adjusted to the new position of the calibration board.
  if hlog!=NULL then
    fprintf(hlog,"Estimated residual deviations after correction adjustment:\n")
  endif
  for head=0,head<$LAY.nfing*2,head++ do
    change hinfo limits=head,$LAY.nfing*2
    // Calculate corrections.
    if c[head].ncal==0 continue
    if isheadcam==0 || vverifytype!=0 then
      // Uniformly distributed points.
      i=Correctionsfromverification(head)
    else if c[head].asymmetric then
      // Points as during the asymmetric calibration.
      i=Correctasym(head,2)
      if i>0 i=0
    else
      // Points as during the 3-line calibration.
      i=Correctfinger(head,2)
      if i>0 i=0
    endif
    if i!=0 then
      err=2; goto error                // Unable to calculate corrections
    endif
    // Adjust existing corrections.
    for i=0,i<CORRX,i++ do
      for j=0,j<CORRY,j++ do
        if isheadcam==0 then
          corr[head][i][j].dx=corr[head][i][j].dx+cnew[head][i][j].dx
          corr[head][i][j].dy=corr[head][i][j].dy+cnew[head][i][j].dy
        else
          hcam[head][i][j].dx=hcam[head][i][j].dx+cnew[head][i][j].dx
          hcam[head][i][j].dy=hcam[head][i][j].dy+cnew[head][i][j].dy
        endif
      enddo
    enddo
    // Protocol estimated deviations.
    if hlog!=NULL then
      fprintf(hlog,                                                            \
        "          X exp    Y exp   dXmeas  dYmeas    diffX   diffY\n")
      fprintf(hlog,                                                            \
        "  Head       mm       mm       um      um       um      um\n")
      Initsigma(meandx)
      Initsigma(meandy)
      for j=0,j<c[head].ncal,j++ do
        Getcorr(head,2,c[head].xa[j],c[head].ya[j],&deltax,&deltay)
        fprintf(hlog,                                                          \
          "  D%i%c: %8.3f %8.3f  %7.1f %7.1f  %7.1f %7.1f",                    \
          head/2,(head & 1?'R':'L'),c[head].xa[j],c[head].ya[j],               \
          (c[head].xm[j]-c[head].xa[j])*1000.0,                                \
          (c[head].ym[j]-c[head].ya[j])*1000.0,                                \
          (c[head].xm[j]-c[head].xa[j]-deltax)*1000.0,                         \
          (c[head].ym[j]-c[head].ya[j]-deltay)*1000.0)
        if c[head].err[j]==1 then
          fprintf(hlog,"  (bad)\n")
        else if c[head].err[j]==2 then
          fprintf(hlog,"  (removed)\n")
        else
          fprintf(hlog,"\n")
          Addsigma(meandx,c[head].xm[j]-c[head].xa[j]-deltax)
          Addsigma(meandy,c[head].ym[j]-c[head].ya[j]-deltay)
        endif
      enddo
      fprintf(hlog,                                                            \
        "  >>>>>> D%i%c: dX=%6.2f ?%6.2f, dY=%6.2f ?%6.2f um\n",               \
        head/2,(head & 1?'R':'L'),                                             \
        Getmean(meandx)*1000.0,Getsigma(meandx)*1000.0,                        \
        Getmean(meandy)*1000.0,Getsigma(meandy)*1000.0)
      ;
    endif
    // Apply adjustments to the head calibration data. This data will be
    // displayed as 'expected accuracy'.
    for i=0,i<c[head].ncal,i++ do
      if c[head].err[i]!=0 continue
      Getcorr(head,2,c[head].xm[i],c[head].ym[i],&deltax,&deltay)
      c[head].xm[i]=c[head].xm[i]-deltax
      c[head].ym[i]=c[head].ym[i]-deltay
    enddo
    // Fine corrections are not supported!
    for i=0,i<4,i++ do
      cext[head].optdata[i]=0
    enddo
    for i=0,i<4,i++ do
      if copt[head][i].key==COPT_3D break
    enddo
    if i<4 then
      Memcpy(c3dnew[head],copt[head][i],256)
    else
      Memset(c3dnew[head],0,256)
    endif
    cext[head].mode=cext[head].mode & (~CE_FINE)
    cext[head].caldate=$LAY.caldate
  enddo
  // Send new corrections to tester.
  i=Loadcorr(-1,0,1)
  return i
error:
  // Error detected, report and disable adjustment.
  adjustcorr=0
  change hinfo limits=0,0
  change hinfo text="Adjustment problem!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Undefined corrections!"
    draw at 6,60 color=BLACK
    draw text="This is an internal error. Script is requested to adjust "
    draw text=(isheadcam?"head camera ":"head ")
    draw text="corrections, but original corrections are not available. "
    if hlog!=NULL then
      fprintf(hlog,"  Undefined corrections, adjustment is not possible\n")
    endif
  else
    draw text="Unable to calculate corrections!"
    draw at 6,60 color=BLACK
    draw text="Script is unable to adjust "
    draw text=(isheadcam?"head camera ":"head ")
    draw text="corrections. Most probably, there are too few valid points "
    draw text="for meaningful adjustment. "
    if hlog!=NULL then
      fprintf(hlog,"  Unable to adjust corrections\n")
    endif
  endif
  draw text="You may continue verification, " color=LIGHTRED
  draw text="but existing corrections will remain unchanged" color=BLACK
  draw text="."
  draw show
  hquit=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Quit"
    help="Press to interrupt verification and close script"
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Continue"
    help="Continue without adjustment"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1                        // Quit verification
    else if Pressed(hquit) then
      return -1                        // Quit verification
    else if Pressed(hcont) then
      return 1                         // Continue verification
    endif
    wait
  enddo
end

// Calculates best fit, adjusts corrections and displays results of
// verification of existing corrections.
function int Fitcalibration()
  int i,j,k,n,y,y0,head,redraw,currdraw,datatype,ntype,camrel,vcorvalid,ret
  int adjusted
  float dx,dy,dfi,hx,hy,hfi,meandx,meandy,meandfi,dteta[2],deltax,deltay
  char s[260]
  handle htable,hraw,hxy,hrofi,htype,hfile,hfinish,hadjust
  clear hleft
  clear hright
  change hinfo limits=0,0
  if headcams!=0 && adjustcorr!=0 then
    // Script adjusts corrections for tester with head cameras.
    Memcpy(c,chcam,Sizeof(c))          // Restore head camera calibration data
    i=Adjustcorrections(1)
    if i<0 return -1                   // Operator interrupted calibration
    Memcpy(chcam,c,Sizeof(c))          // Save head camera calibration data
    Memcpy(c,cfing,Sizeof(c))
    i=Savecorr()
    if i==0 then
      diskvalid=1                      // Layout matches corrections on disk
      Loadcorr(-1,0,1)                 // Send new corrections to tester
    endif
    adjusted=1
  else
    // Find best fit between old and new calibration for all heads and for each
    // head individually.
    adjusted=0
    change hinfo text="Fitting data..."
    if hlog!=NULL fprintf(hlog,"Fitting verification data...\n")
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK
    draw text="Verification now searches for the best possible fit (in the "
    draw text="sense of least squares) between old and new position of "
    draw text="the calibration board. Please wait..."
    draw show
    meandx=0.0; meandy=0.0; meandfi=0.0; ntype=0
    for datatype=0,datatype<2,datatype++ do
      if datatype==0 then
        Memcpy(c,cfing,Sizeof(c))      // Restore head calibration data
      else
        if headcams==0 break
        Memcpy(c,chcam,Sizeof(c))      // Restore head camera calibration data
      endif
      // Fit top dedicated camera, parameters may be used later.
      if datatype==0 && ($LAY.cameras & 1)!=0 then
        Findheadfit($LAY.nfing*2,&hx,&hy,&hfi)
        c[$LAY.nfing*2].dx=hx
        c[$LAY.nfing*2].dy=hy
        c[$LAY.nfing*2].dfi=hfi
      endif
      // Fit whole calibration.
      Findbestfit(-1,&dx,&dy,&dfi)
      meandx=meandx+dx; meandy=meandy+dy; meandfi=meandfi+dfi
      ntype++
      i=Corrall(0,0)                   // Calculate radius and angle
      if i<0 return i                  // Operator interrupted process
      for i=0,i<32,i++ do
        c[i].corrok=0                  // Don't display corrections
      enddo
      // Calculate mean dteta.
      dteta[datatype]=0.0; n=0
      for i=0,i<$LAY.nfing*2,i++ do    // Cameras are not included
        if c[i].ncal==0 continue
        dteta[datatype]=dteta[datatype]+c[i].dteta
        n++
      enddo
      if n>0 dteta[datatype]=dteta[datatype]/n
      if datatype==0 then
        Memcpy(cfing,c,Sizeof(c))      // Save calculated finger parameters
      else
        Memcpy(chcam,c,Sizeof(c))      // Save calculated headcam parameters
      endif
    enddo
    // If tester is equipped with dedicated cameras, calculate shift relative
    // to the top camera. Otherwise, use mean shift.
    if ($LAY.cameras & 1)!=0 && cfing[$LAY.nfing*2].ncal>0 then
      camrel=1
      dx=cfing[$LAY.nfing*2].dx
      dy=cfing[$LAY.nfing*2].dy
      dfi=cfing[$LAY.nfing*2].dfi
    else
      camrel=0
      dx=meandx/ntype
      dy=meandy/ntype
      dfi=meandfi/ntype
    endif
  endif
  // Calculate mean deviations of heads and cameras from ideal according to the
  // found mean best fit. ATTENTION, I leave original data (cfing and chcam)
  // unchanged. Call Rotatemeasurements() each time if necessary, this call is
  // not too expensive.
  for datatype=0,datatype<2,datatype++ do
    if datatype==0 then
      Memcpy(c,cfing,Sizeof(c))        // Restore head calibration data
    else
      if headcams==0 break
      Memcpy(c,chcam,Sizeof(c))        // Restore head camera calibration data
    endif
    Rotatemeasurements(dx,dy,dfi)
    // Fit individual heads.
    for head=0,head<32,head++ do
      Findheadfit(head,&hx,&hy,&hfi)
      if datatype==0 then
        cfing[head].dx=hx
        cfing[head].dy=hy
        cfing[head].dfi=hfi
        cfing[head].sigmax=c[head].sigmax
        cfing[head].sigmay=c[head].sigmay
      else
        chcam[head].dx=hx
        chcam[head].dy=hy
        chcam[head].dfi=hfi
        chcam[head].sigmax=c[head].sigmax
        chcam[head].sigmay=c[head].sigmay
      endif
    enddo
  enddo
  // Check whether we have enough points to correct existing correction files.
  // Currently this applies only to S3 testers.
  if testertype!=TT_S3 || adjustcorr==0 || corrsource!=CS_FILE then
    vcorvalid=-1
  else
    // Note that I do not rotate and shift measured deviations! Corrections
    // will be adjusted to the new position of the calibration board.
    Memcpy(c,cfing,Sizeof(c))
    vcorvalid=1
    for head=0,head<32,head++ do
      if c[head].ncal==0 continue
      i=Correctionsfromverification(head)
      if i!=0 vcorvalid=0
    enddo
  endif
  // Write deviations to log file.
  if hlog!=NULL then
    for datatype=0,datatype<2,datatype++ do
      if datatype==0 then
        fprintf(hlog,                                                          \
          "Results of head verification (micrometers or degrees):\n")
        Memcpy(c,cfing,Sizeof(c))      // Restore head calibration data
      else
        if headcams==0 break
        fprintf(hlog,                                                          \
          "Results of head camera verification (micrometers or degrees):\n")
        Memcpy(c,chcam,Sizeof(c))      // Restore head camera calibration data
      endif
      for i=0,i<32,i++ do
        if c[i].ncal==0 continue
        if i>=$LAY.nfing*2 then        // Video cameras
          fprintf(hlog,"  V%s: ",(i & 1?"Bot":"Top"))
        else if datatype==1 then       // Head cameras
          fprintf(hlog,"  H%i%c:  ",i/2,(i & 1?'R':'L'))
        else
          fprintf(hlog,"  %i%c:   ",i/2,(i & 1?'R':'L'))
        endif
        fprintf(hlog,                                                          \
          "dX=%6.1f ?%5.1f,  dY=%6.1f ?%5.1f,  dFi=%7.4f",                     \
          c[i].dx*1000.0,c[i].sigmax*1000.0,                                   \
          c[i].dy*1000.0,c[i].sigmay*1000.0,c[i].dfi*180.0/PI)
        if i<$LAY.nfing*2 then
          fprintf(hlog,",  dR=%6.1f,  dTeta=%7.4f\n",                          \
          c[i].dr*1000.0,(c[i].dteta-dteta[datatype])*180.0/PI)
        else
          fprintf(hlog,"\n")
        endif
      enddo
    enddo
    if headcams!=0 && boardtype==0 && vverifytype==1 then
      // FR4 board is loaded and heads and cameras are verified on the same
      // points. Compare head and camera deviations.
      for i=0,i<32,i++ do
        if chcam[i].ncal==0 continue
        if cfing[i&0xFE].ncal==0 && cfing[i|0x01].ncal==0 continue
        fprintf(hlog,                                                          \
          "Differences between heads on rail %i and camera %i%s, %s\n",        \
          i/2,i/2,(i & 1?"R":"L"),"micrometers")
        fprintf(hlog,                                                          \
          "  :    X, mm    Y, mm  Left:  dX     dY  Right:  dX     dY\n")
        for j=0,j<chcam[i].ncal,j++ do
          fprintf(hlog,"  : %8.3f %8.3f ",chcam[i].xa[j],chcam[i].ya[j])
          if chcam[i].err[j]!=0 then
            fprintf(hlog," Not scanned\n")
            continue
          endif
          // Left cross with identical coordinates.
          k=i & 0xFE
          for n=0,n<cfing[k].ncal,n++ do
            if Abs(cfing[k].xa[n]-chcam[i].xa[j])<0.001 &&                     \
            Abs(cfing[k].ya[n]-chcam[i].ya[j])<0.001 break
          enddo
          if n>=cfing[k].ncal || cfing[k].err[n]!=0 then
            fprintf(hlog,"        -      - ")
          else
            fprintf(hlog,"    %6.1f %6.1f",                                    \
            (cfing[k].xm[n]-chcam[i].xm[j])*1000.0,                            \
            (cfing[k].ym[n]-chcam[i].ym[j])*1000.0)
          endif
          // Right cross with identical coordinates.
          k=i | 0x01
          for n=0,n<cfing[k].ncal,n++ do
            if Abs(cfing[k].xa[n]-chcam[i].xa[j])<0.001 &&                     \
            Abs(cfing[k].ya[n]-chcam[i].ya[j])<0.001 break
          enddo
          if n>=cfing[k].ncal || cfing[k].err[n]!=0 then
            fprintf(hlog,"          -      -\n")
          else
            fprintf(hlog,"      %6.1f %6.1f\n",                                \
            (cfing[k].xm[n]-chcam[i].xm[j])*1000.0,                            \
            (cfing[k].ym[n]-chcam[i].ym[j])*1000.0)
          endif
        enddo
      enddo
    else if headcams!=0 && (boardtype==1 || boardtype==2) && vverifytype==0 then
      // Head cameras are verified on glass on the same points as camera
      // calibration. Compare head deviations with head camera corrections.
      Memcpy(c,chcam,Sizeof(c))        // Restore head camera calibration data
      for i=0,i<32,i++ do
        // For each head camera.
        if chcam[i].ncal==0 continue
        if c[i].asymmetric then
          Correctasym(i,1)             // Calculate head camera corections
        else
          Correctfinger(i,1)           // Calculate head camera corections
        endif
        for k=(i&0xFE),k<=(i|0x01),k++ do
          // For each head on the same rail.
          if cfing[k].ncal==0 continue
          fprintf(hlog,                                                        \
            "Differences between head %i%s and camera %i%s\n",                 \
            k/2,(k & 1?"R":"L"),i/2,(i & 1?"R":"L"))
          fprintf(hlog,                                                        \
            "  :    X, mm    Y, mm     dX, um   dY, um\n")
          for j=0,j<cfing[k].ncal,j++ do
            fprintf(hlog,"  : %8.3f %8.3f ",cfing[k].xa[j],cfing[k].ya[j])
            if cfing[k].err[n]!=0 then
              fprintf(hlog,"        -        -\n")
            else
              Getcorr(i,1,cfing[k].xa[j],cfing[k].ya[j],&deltax,&deltay)
              fprintf(hlog,"  %8.1f %8.1f\n",                                  \
              (cfing[k].xm[j]-cfing[k].xa[j]-deltax)*1000.0,                   \
              (cfing[k].ym[j]-cfing[k].ya[j]-deltay)*1000.0)
            endif
          enddo
        enddo
      enddo
    endif
  endif
restart:
  // Create controls to display measured deviations.
  change hinfo limits=0,0
  if adjusted then
    change hinfo text="Corrections adjusted"
  else
    change hinfo text="Results of verification"
  endif
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  if adjusted then
    draw text="Corrections adjusted. Displayed deviations are non-committal "
    draw text="estimates."
  else if camrel then
    draw text="Verification finished. Displayed deviations are relative to "
    draw text="the top camera."
  else
    draw text="Verification finished. Table below displays individual "
    draw text="deviations for each tested head."
  endif
  draw show
  if headcams==0 then
    htable=control CHILD
      window=hright
      position=10,(vcorvalid>=0?68:73),RIGHTX-20,(vcorvalid>=0?192:204)
      mode=M_VSCROLL
      help=(camrel?"Mean deviations relative to the top video camera":         \
        "Individual mean deviations")
      bkcolor=PINK
      size=8192
    endc
    hraw=control BUTTON
      window=hright
      position=5,(vcorvalid>=0?USERY-10:USERY+10),40,24
      text="Raw"
      help="Press to view raw data"
    endc
    hxy=control BUTTON
      window=hright
      position=50,(vcorvalid>=0?USERY-10:USERY+10),40,24
      text="X-Y"
      help="Press to view X-Y data"
    endc
    hrofi=control BUTTON
      window=hright
      position=95,(vcorvalid>=0?USERY-10:USERY+10),40,24
      text="RoFi"
      help="Press to view Ro-Fi data"
    endc
    htype=NULL
    hfile=control BUTTON
      window=hright
      position=140,(vcorvalid>=0?USERY-10:USERY+10),55,24
      name="Save"
      help="Press to save table and pictures to .RTF file"
    endc
    hfinish=control BUTTON
      window=hright
      position=200,(vcorvalid>=0?USERY-10:USERY+10),60,24
      name="Finish"
      help="Press to finish verification"
    endc
    if adjusted then
      hadjust=NULL                     // Only once!
    else
      hadjust=control BUTTON
        window=hright
        position=5,USERY+20,RIGHTX-10,24
        text="Adjust corrections"
        help="DOUBLECLICK to adjust correction tables and finish verification"
        mode=M_DBLCLICK
      endc
      if vcorvalid!=1 disable hadjust
    endif
  else
    htable=control CHILD
      window=hright
      position=10,68,RIGHTX-20,192
      mode=M_VSCROLL
      help="Individual mean deviations"
      bkcolor=PINK
      size=8192
    endc
    hraw=control BUTTON
      window=hright
      position=8,USERY-10,37,24
      text="Raw"
      help="Press to view raw data"
    endc
    hxy=control BUTTON
      window=hright
      position=49,USERY-10,37,24
      text="X-Y"
      help="Press to view X-Y data"
    endc
    hrofi=control BUTTON
      window=hright
      position=90,USERY-10,38,24
      text="RoFi"
      help="Press to view Ro-Fi data"
    endc
    htype=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-10,120,24
      name="Show head cams"
      help="Press to toggle between heads and head cameras"
    endc
    hfile=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+20,120,24
      name="To file"
      help="Press to save table and pictures to .RTF file"
    endc
    hfinish=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+20,120,24
      name="Finish"
      help="Press to finish verification"
    endc
    hadjust=NULL
  endif
  setfocus htable
  // View corrections.
  Memcpy(c,cfing,Sizeof(c))            // Restore head calibration data
  Rotatemeasurements(dx,dy,dfi)
  datatype=0
  redraw=1; currdraw=-1                // Force redraw
  Showcurrscan(1,1)
  while 1 do
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hraw) then
      redraw=0
    else if Pressed(hxy) then
      redraw=1
    else if Pressed(hrofi) then
      redraw=2
    else if htype!=NULL && Pressed(htype) then
      datatype=1-datatype
      if datatype==0 then
        Memcpy(c,cfing,Sizeof(c))      // Restore head calibration data
        Rotatemeasurements(dx,dy,dfi)
        change htype name="Show cameras"
      else
        Memcpy(c,chcam,Sizeof(c))      // Restore head camera calibration data
        Rotatemeasurements(dx,dy,dfi)
        change htype name="Show heads"
      endif
      currdraw=-1                      // Force update
      statredraw=1                     // Force redraw in Showcurrscan()
    else if Pressed(hfile) then
      Strcpy(s,"verify.rtf");
      if SYS.Browse(hmain,s,"Specify file to save verification data",0)!=0 then
        if ROpen(s)!=0 then
          change hinfo color=LIGHTRED
          change hinfo text="Unable to create file!"
        else
          RParagraph(RTF_CENTERED)
          RFmt(RTF_TIMES,RTF_BOLD|RTF_UL,24)
          if adjusted then
            RAddtext("Estimated adjusted deviations\n")
          else
            RAddtext("Verification results\n")
          endif
          RFmt(RTF_TIMES,RTF_NORMAL,12)
          Strtime(s,"\nVerified on: %a %d-%b-%Y, %H:%M\n\n",0,0)
          RAddtext(s)
          for datatype=0,datatype<2,datatype++ do
            if datatype==0 then
              Memcpy(c,cfing,Sizeof(c))
              Rotatemeasurements(dx,dy,dfi)
              if headcams!=0 then
                RFmt(RTF_TIMES,RTF_BOLD,16)
                RAddtext("Heads\n")
              endif
            else if headcams==0 then
              break
            else
              Memcpy(c,chcam,Sizeof(c))
              Rotatemeasurements(dx,dy,dfi)
              RFmt(RTF_TIMES,RTF_BOLD,16)
              RAddtext("Head cameras\n")
            endif
            RFmt(RTF_TIMES,RTF_BOLD,9)
            RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,7.0)
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,15.0)
            RAddtext(datatype==0?"Head":"Head camera")
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,15.0)
            RAddtext("dX, ")
            RFmt(RTF_SYMBOL,RTF_BOLD,9); RAddtext("m")
            RFmt(RTF_TIMES,RTF_BOLD,9); RAddtext("m")
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,15.0)
            RAddtext("dY, ")
            RFmt(RTF_SYMBOL,RTF_BOLD,9); RAddtext("m")
            RFmt(RTF_TIMES,RTF_BOLD,9); RAddtext("m")
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,15.0)
            RAddtext("Sigma, ")
            RFmt(RTF_SYMBOL,RTF_BOLD,9); RAddtext("m")
            RFmt(RTF_TIMES,RTF_BOLD,9); RAddtext("m")
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,18.0)
            RAddtext("Rot, deg")
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,15.0)
            RAddtext("dR, ")
            RFmt(RTF_SYMBOL,RTF_BOLD,9); RAddtext("m")
            RFmt(RTF_TIMES,RTF_BOLD,9); RAddtext("m")
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,18.0)
            RAddtext("dFi, deg")
            RFmt(RTF_TIMES,RTF_NORMAL,9)
            for i=0,i<32,i++ do
              if c[i].ncal==0 continue
              RTable(RTF_CENTERED|RTF_BORDER,0.0,0.0)
              RCell(RTF_LEFT|RTF_THINBRD|RTF_SPACE,15.0)
              if i==$LAY.nfing*2 then
                Strcpy(s,"Top")
              else if i==$LAY.nfing*2+1 then
                Strcpy(s,"Bottom")
              else
                sprintf(s,"%i%c",i/2,(i & 1?'R':'L'))
              endif
              RAddtext(s)
              RCell(RTF_RIGHT|RTF_THINBRD|RTF_SPACE,15.0)
              RAddfmt("%8.2f ",c[i].dx*1000.0)
              RCell(RTF_RIGHT|RTF_THINBRD|RTF_SPACE,15.0)
              RAddfmt("%8.2f ",c[i].dy*1000.0)
              RCell(RTF_RIGHT|RTF_THINBRD|RTF_SPACE,15.0)
              RAddfmt("%8.2f ",                                                \
                Sqrt(c[i].sigmax*c[i].sigmax+c[i].sigmay*c[i].sigmay)*1000.0)
              RCell(RTF_RIGHT|RTF_THINBRD|RTF_SPACE,18.0)
              RAddfmt("%7.4f ",c[i].dfi*180.0/PI)
              RCell(RTF_RIGHT|RTF_THINBRD|RTF_SPACE,15.0)
              if i<$LAY.nfing*2 RAddfmt("%8.2f ",c[i].dr*1000.0)
              RCell(RTF_RIGHT|RTF_THINBRD|RTF_SPACE,18.0)
              if i<$LAY.nfing*2 RAddfmt("%8.5f ",                              \
                (c[i].dteta-dteta[datatype])*180.0/PI)
              ;
            enddo
            REndtable()
            RParagraph(RTF_CENTERED)
            RFmt(RTF_TIMES,RTF_BOLD,9)
            if redraw==0 then
              // Save raw (but corrected) deviations.
              for i=0,i<32,i++ do
                if c[i].ncal==0 continue
                Showcurrscan(2,i)
                RAddpiczoom(hstatg,0,0,LEFTX,270,1,1.0)
                if i==$LAY.nfing*2 then
                  RAddtext("\nTop camera\n\n")
                else if i==$LAY.nfing*2+1 then
                  RAddtext("\nBottom camera\n\n")
                else
                  RAddfmt("\nHead %i%s\n\n",i/2,(i & 1?"R":"L"))
                endif
              enddo
            else
              // Save per-rail deviations.
              for i=0,i<=$LAY.nfing,i++ do
                if i==$LAY.nfing && $LAY.cameras==0 continue
                Showcurrscan(2,i*2)
                RAddpiczoom(hstatg,0,0,LEFTX,270,1,1.0)
                RAddfmt("\nRail %i\n\n",i)
              enddo
            endif
          enddo
          RClose()
          datatype=0
          Memcpy(c,cfing,Sizeof(c))    // Restore head calibration data
          Rotatemeasurements(dx,dy,dfi)
          change htype name="Show cameras"
          currdraw=-1                  // Force update
          statredraw=1                 // Force redraw in Showcurrscan()
          change hinfo color=BLACK
          change hinfo text="Results of verification"
        endif
      endif
    else if Pressed(hfinish) then
      ret=0; break
    else if hadjust!=NULL && Pressed(hadjust) &&                               \
      headcams==0 && vcorvalid==1 && corrsource==CS_FILE then
      // Adjustment of corrections is currently appliable only to the testers
      // with dedicated cameras. Moreover, currently it's limited only to S3.
      i=Readoldcorr(RC_AUTOLOAD)
      if i<0 return -1
      if i!=0 continue
      // Adjust existing corrections.
      for head=0,head<32,head++ do
        for i=0,i<CORRX,i++ do
          for j=0,j<CORRY,j++ do
            corr[head][i][j].dx=corr[head][i][j].dx+cnew[head][i][j].dx
            corr[head][i][j].dy=corr[head][i][j].dy+cnew[head][i][j].dy
          enddo
        enddo
      enddo
      // Save adjusted correction tables to the disc. Fine corrections are not
      // supported! Only 3-D optional corrections are kept!
      for head=0,head<32,head++ do
        for i=0,i<4,i++ do
          cext[head].optdata[i]=0
        enddo
        for i=0,i<4,i++ do
          if copt[head][i].key==COPT_3D break
        enddo
        if i<4 then
          Memcpy(c3dnew[head],copt[head][i],256)
        else
          Memset(c3dnew[head],0,256)
        endif
        cext[head].mode=cext[head].mode & (~CE_FINE)
        cext[head].caldate=$LAY.caldate
      enddo
      i=Savecorr()
      if i==0 then
        diskvalid=1                    // Layout matches corrections on disk
        Loadcorr(-1,0,1)               // Send new corrections to tester
      endif
      // Apply adjustments to the head calibration data. This data will be
      // displayed as 'expected accuracy'. The procedure is the same as above,
      // only simplified.
      Memcpy(c,cfing,Sizeof(c))
      for head=0,head<32,head++ do
        for i=0,i<c[head].ncal,i++ do
          if c[head].err[i]!=0 continue
          Getcorr(head,2,c[head].xm[i],c[head].ym[i],&deltax,&deltay)
          c[head].xm[i]=c[head].xm[i]-deltax
          c[head].ym[i]=c[head].ym[i]-deltay
        enddo
      enddo
      i=Corrall(0,0)                   // Calculate radius and angle
      if i<0 return i                  // Operator interrupted process
      for head=0,head<32,head++ do
        c[head].corrok=0               // Don't display corrections
      enddo
      Memcpy(cfing,c,Sizeof(c))
      Findbestfit(-1,&dx,&dy,&dfi)
      Rotatemeasurements(dx,dy,dfi)
      for head=0,head<32,head++ do
        Findheadfit(head,&hx,&hy,&hfi)
        cfing[head].dx=hx
        cfing[head].dy=hy
        cfing[head].dfi=hfi
        cfing[head].sigmax=c[head].sigmax
        cfing[head].sigmay=c[head].sigmay
      enddo
      // Adjustment of corrections can be done only once.
      adjusted=1
      vcorvalid=0
      goto restart
    endif
    if redraw!=currdraw then
      change hraw color=(redraw==0?LIGHTRED:BLACK)
      change hraw bkcolor=(redraw==0?YELLOW:GRAY)
      change hxy color=(redraw==1?LIGHTRED:BLACK)
      change hxy bkcolor=(redraw==1?YELLOW:GRAY)
      change hrofi color=(redraw==2?LIGHTRED:BLACK)
      change hrofi bkcolor=(redraw==2?YELLOW:GRAY)
      Showcurrscan(-1,0)
      Showcurrscan(1,(redraw==1 || redraw==2?1:0))
      y0=0; y=24
      draw window=htable color=WHITE bkcolor=WHITE clear
      if headcams!=0 then
        draw color=BLACK at 0,y to 229,y
        draw font=MAINFONT mode=M_CENTERED at 115,y-5
        if datatype==0 then
          draw text="Heads"
        else
          draw text="Head cameras"
        endif
        y0=y; y=y+24
      endif
      draw font=INFOFONT mode=M_LEFT color=BLACK at 0,y to 229,y
      if datatype==0 then
        draw at 5,y-5 text="Head"
      else
        draw at 8,y-5 text="Cam"
      endif
      if redraw==0 || redraw==1 then   // Display X-Y data
        draw at 55,y-5 text="dX,um"
        draw at 115,y-5 text="dY,um"
        draw at 179,y-5 text="Sigma"
        draw font=FIXEDSYS
        for i=0,i<32,i++ do
          if c[i].ncal==0 continue
          y=y+18
          draw at 5,y color=DARKGRAY text=format("%2i%c",i/2,(i & 1?'R':'L'))
          draw at 50,y color=BLACK text=format("%6.2f",c[i].dx*1000.0)
          draw at 110,y text=format("%6.2f",c[i].dy*1000.0)
          draw at 170,y text=format("%6.2f",                                   \
            Sqrt(c[i].sigmax*c[i].sigmax+c[i].sigmay*c[i].sigmay)*1000.0)
          draw at 0,y to 229,y
        enddo
        draw at 45,y0 to 45,y
        draw at 105,y0 to 105,y
        draw at 165,y0 to 165,y
      else                             // Display R-Fi data
        draw at 55,y-5 text="Rot,deg"
        draw at 115,y-5 text="dR,um"
        draw at 175,y-5 text="dFi,deg"
        draw font=FIXEDSYS
        for i=0,i<$LAY.nfing*2,i++ do  // Cameras are not included
          if c[i].ncal==0 continue
          y=y+18
          draw at 5,y color=DARKGRAY text=format("%2i%c",i/2,(i & 1?'R':'L'))
          draw at 50,y color=BLACK
          draw text=format("%6.3f",c[i].dfi*180.0/PI)
          draw at 110,y text=format("%6.2f",c[i].dr*1000.0)
          draw at 170,y
          draw text=format("%6.3f",(c[i].dteta-dteta[datatype])*180.0/PI)
          draw at 0,y to 229,y
        enddo
        draw at 45,y0 to 45,y
        draw at 105,y0 to 105,y
        draw at 165,y0 to 165,y
      endif
      draw at 228,0 to 228,y
      change htable limits=1,y
      change htable mode=M_VSCROLL
      draw show
      currdraw=redraw
    endif
    Showcurrscan(0,0)
    wait
  enddo
  Showcurrscan(-1,1)
  return ret
end

// Returns percent of measurement points on the slowest rail.
function float Wavescan()
  int rail,side,finger,head,ref,next,step,nwave
  float percent,minpercent,x,y,w
  char s[256],longmode[16],buf[128]
  minpercent=100.0
  for rail=0,rail<$LAY.nfing,rail++ do // Go over all rails
    percent=0.0
    side=($LAY.side[rail]!=0)
    for finger=0,finger<2,finger++ do
      head=rail*2+finger
      ref=rail*2+(1-finger)
      next=c[head].next
      step=c[head].step
      nwave=c[head].nwave
      if c[head].ncal==0 || next>=nwave then
        percent=percent+50.0           // Head already calibrated or excluded
        continue
      else
        percent=percent+(next*2+step)*25.0/nwave
      endif
      // In demo mode, emulate scanning results.
      if demo then
        c[head].wavedy[next]=                                                  \
          Random(accuracy)+Random(accuracy)-Random(accuracy)-Random(accuracy)
        c[head].waveerr[next]=0
        c[head].next=next+1
        delay 10                       // Otherwise not visible
        break
      endif
      // Process answer from the tester.
      if c[head].pending==0 then
        ;                              // We expect no answer
      else if $A[head].length==0 then
        break                          // Still no answer from head
      else if $A[head].answer==S_ERROR && $A[head].subcmd==E_PADNOTFOUND then
        c[head].pending=0              // Pad not found, retry
        c[head].attempt=c[head].attempt+1
      else if $A[head].answer==S_READY then
        c[head].pending=0              // Simple movement
      else if $A[head].answer!=S_CALIBRATE then
        c[head].pending=0              // Wrong answer
        c[head].attempt=c[head].attempt+1
      else
        c[head].pending=0              // Correct answer, check for accuracy
        y=($int4($A[head]+17)+$int4($A[head]+13))/2000.0
        w=Abs($int4($A[head]+17)-$int4($A[head]+13))/1000.0
        if (w<linewidth*(kelvinscan==1?0.2:0.4) || w>linewidth*2.5) &&         \
          c[head].attempt==0 then      // Suspicious line width, retry once
          c[head].attempt=c[head].attempt+1
        else if step==0 then
          c[head].yt=y
          c[head].step=1
          c[head].attempt=0
        else                           // Point calibrated
          c[head].wavedy[next]=(y+c[head].yt)/2.0-c[head].waveya[next]
          c[head].waveerr[next]=0
          // Save coordinates of found point to log file.
          if hlog!=NULL then
            fprintf(hlog,"  %i%c:   %8.3f %8.3f  dY=%6.3f\n",                  \
            head/2,(head & 1?'R':'L'),                                         \
            c[head].wavexa[next],c[head].waveya[next],c[head].wavedy[next])
          endif
          next++                       // Continue with the next cross
          c[head].next=next
          c[head].step=0
          c[head].attempt=0
        endif
      endif
      if next>=nwave break             // Head finished
      // Do we have some problem with the cross?
      if c[head].attempt>3 then
        c[head].waveerr[next]=1        // Multiple attempts to scan cross were
        if hlog!=NULL then             // unsuccessfull. Skip it.
          fprintf(hlog,"  %i%c:   %8.3f %8.3f  Not measured\n",                \
          head/2,(head & 1?'R':'L'),c[head].wavexa[next],c[head].waveya[next])
        endif
        next++
        c[head].next=next
        c[head].step=0
        c[head].attempt=0
        break
      endif
      // OK to send next scan command.
      if step==0 then
        x=c[head].wavexa[next]-0.025  // 50 um distance between scans
        y=c[head].waveya[next]
      else
        x=c[head].wavexa[next]+0.025
        y=c[head].yt
      endif
      if c[head].attempt==1 then
        w=linewidth*0.75
      else if c[head].attempt==2 then
        w=linewidth*1.33
      else
        w=linewidth
      endif
      if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||       \
        testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||         \
        testertype==TT_A7 || testertype==TT_A8                                 \
      then
        if c[head].attempt==0 then
          longmode[0]='\0'
        else
          Strcpy(longmode,",LONG")
        endif
        if kelvinscan==1 then
          sprintf(s,"M %i(%f,%fA%iV%iP%i) %i(Z) CAL(%i,%iW%iD%i,K%s)",         \
          head,x,y,acc,v,p,ref,head,ref,Max(w*1000.0,1.0),                     \
          (c[head].step==0?64:192),longmode)
        else if kelvinscan==3 then
          sprintf(s,"M %i(%f,%fA%iV%iP%i) %i(Z) CAL(%i,32W%iD%i%s)",           \
          head,x,y,acc,v,p,ref,head,Max(w*1000.0,1.0),                         \
          (c[head].step==0?64:192),longmode)
        else
          sprintf(s,"M %i(%f,%fA%iV%iP%i) %i[%f,%fV%iP%i] CAL(%i,%iW%iD%i%s)", \
          head,x,y,acc,v,p,ref,c[ref].refx,c[ref].refy,v,p,                    \
          head,ref,Max(w*1000.0,1.0),(c[head].step==0?64:192),longmode)
        endif
        if SERV.Cmdimm(head,s)>0 then
          c[head].pending=1            // Hurrah, command sent!
          c[head].infield=1
          c[ref].infield=0
        endif
      else
        buf[0]=S_CALIBRATE
        buf[1]=side                    // Side
        $int3(buf+2)=x*1000.0          // Initial X coordinate
        $int3(buf+5)=y*1000.0          // Initial Y coordinate
        $uint2(buf+8)=w*1000.0         // Expected width of the line
        buf[10]=255                    // Delay (reflects expected accuracy)
        buf[11]=(c[head].step==0?64:192) // Direction of scanning
        buf[12]=side                   // Same side for reference pad
        $int3(buf+13)=c[ref].refx*1000.0 // X coordinate of reference pad
        $int3(buf+16)=c[ref].refy*1000.0 // Y coordinate of reference pad
        $uint2(buf+19)=0               // Must be zero
        if SYS.Sendimm(head,21,buf)>0 then
          c[head].pending=1            // Hurrah, command sent!
          c[head].infield=1
          c[ref].infield=0
        endif
      endif
      break                            // Opposite head is reference
    enddo
    minpercent=Min(minpercent,percent)
  enddo
  return minpercent
end

// Scans electrically central lines to measure waveness of rails. If handle
// hremain of type GRAPH or CHILD is specified, Runwavescan() displays elapsed
// and remaining time in this window. If hinterrupt of type BUTTON is not NULL
// and pressed, function returns 2; if hview of type BUTTON is not NULL and
// pressed, statistics window appears.
function int Runwavescan(handle hremain,handle hinterrupt,handle hview)
  int i,j,nerr,t,tstep,testimated,tupdate,dt,viewon,nwave,ret
  char s[128]
  float xc,x0,x1,xstart,xend,percent,prevpercent,wavedist
  xstart=fromxloc
  xend=toxloc
  if testertype==TT_A7 && smallboard==0 && boardtype==1 then
    while xstart<$LAY.xoffset/1000.0-232.5 do
      xstart=xstart+xstep
    enddo
    while xend>$LAY.xoffset/1000.0+232.5 do
      xend=xend-xstep
    enddo
  endif
  nwave=(xend-xstart)*NSUBWAVE/xstep
  nwave=nwave & 0xFFFFFFFE
  nwave=Min(nwave,NWAVEL)
  if wavenesstype==0 nwave=Min(nwave,NWAVE)
  xc=$LAY.xoffset/1000.0+boardshift
  while xc+((nwave/NSUBWAVE)/2)*xstep>xend do
    xc=xc-xstep
  enddo
  while xc-((nwave/NSUBWAVE)/2)*xstep<xstart do
    xc=xc+xstep
  enddo
  x0=Max(xstart,xc-((nwave/NSUBWAVE)/2)*xstep)
  x1=Min(xc+((nwave/NSUBWAVE)/2)*xstep,xend)
  nwave=(x1-x0)*NSUBWAVE/xstep
  nwave=nwave & 0xFFFFFFFE
  nwave=Min(nwave,NWAVEL)
  if wavenesstype==0 nwave=Min(nwave,NWAVE)
  wavedist=(Random(0.4)-0.2)*xstep/NSUBWAVE
  for i=0,i<$LAY.nfing*2,i++ do        // Fill calibrators
    if c[i].ncal==0 continue
    c[i].next=0
    c[i].pending=0
    c[i].attempt=0
    for j=0,j<nwave,j++ do
      c[i].wavexa[j]=x0+(j+0.5)*xstep/NSUBWAVE+wavedist
//      if boardtype==0 then
        c[i].waveya[j]=c[i].ym[0]+wavenessvdist
//      else if boardtype==1 && smallboard!=0 && testertype==TT_A7 then
//        c[i].waveya[j]=c[i].ym[0]
//      else                             // Central line on glass is unusable
//        c[i].waveya[j]=c[i].ym[0]-ystep
//      endif
      c[i].wavedy[j]=0.0
      c[i].waveerr[j]=0
    enddo
    c[i].nwave=nwave
    c[i].waveok=0
  enddo
  change hinfo limits=0,0              // Text is set by caller
  if hremain!=NULL clear hremain
  tstep=Time()
  tupdate=tstep
  viewon=0
  testimated=MAXINT
  prevpercent=-1.0
  if demo==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      SYS.Killimm(i)                   // Remove pending commands, if any
      $A[i].length=1                   // Invalid non-zero length
    enddo
  endif
  while 1 do
    percent=Wavescan()
    if percent!=prevpercent then
      prevpercent=percent
      change hinfo limits=percent*10.0,1000
    endif
    if percent>=100.0 then
      ret=0; break
    else if Pressed(hexit) then
      ret=-1; break                    // Operator interrupted calibration
    endif
    if hinterrupt!=NULL then
      if Pressed(hinterrupt) then
        disable hinterrupt
        if demo==0 then
          change hinfo limits=0,0
          change hinfo text="Wait..."
          t=Time()+20000               // Wait 20 s for answers
          while Time()<t do
            for i=0,i<$LAY.nfing*2,i++
              if c[i].ncal==0 continue
              if $A[i].length==0 break
            enddo
            if i>=$LAY.nfing*2 break   // Aha, all answers already here!
            wait
          enddo
          for i=0,i<$LAY.nfing*2,i++ do
            SYS.Killimm(i)             // Remove pending commands, if any
            if c[i].ncal==0 continue
            sprintf(s,"M %i(Z) NOP",i)
            SERV.Cmdimm(i,s)
          enddo
          while Time()<t do
            for i=0,i<$LAY.nfing*2,i++
              if c[i].ncal==0 continue
              if $A[i].length==0 break
            enddo
            if i>=$LAY.nfing*2 break   // Aha, all answers already here!
            wait
          enddo
        endif
        ret=2; break                   // Operator interrupted the scanning
      endif
    endif
    if hview!=NULL then
      if Pressed(hview) then
        if viewon==0 then
          Showwavescan(1,0)
          viewon=1
        else
          Showwavescan(-1,0)
          viewon=0
        endif
      endif
      if viewon==1 Showwavescan(0,0)
    endif
    if hremain!=NULL then
      dt=Time()-tstep
      if (percent>5.0 && dt>45000) || percent>25.0 then
        t=dt*(100.0-percent)/percent
        if t<testimated-500 || t>testimated+30000 testimated=t
      endif
      if Time()>=tupdate then
        clear hremain
        draw window=hremain
        t=Time()-tstart+500
        draw at 8,22 color=BLUE text="Elapsed time:"
        draw at 120,22 text=format("%2im %02is",t/60000,(t/1000)%60)
        t=Time()-tstep+500
        draw at 8,42 color=RED text="Step time:"
        draw at 120,42 text=format("%2im %02is",t/60000,(t/1000)%60)
        draw at 8,82 text="Bad points:"
        nerr=0
        for i=0,i<$LAY.nfing*2,i++ do
          if c[i].ncal==0 continue
          for j=0,j<nwave,j++ do
            if c[i].waveerr[j]!=0 nerr++
          enddo
        enddo
        draw at 120,82 text=format(" %i",nerr)
        draw at 8,62 text="Remains:"
        if testimated==MAXINT then
          draw at 120,62 color=DARKGRAY text=" ?"
        else
          draw at 120,62 color=RED
          draw text=format("%2im %02is",testimated/60000,(testimated/1000)%60)
        endif
        draw show
        tupdate=tupdate+1000
      endif
    endif
    wait
  enddo
  if viewon==1 Showwavescan(-1,0)
  return ret
end

// Returns -1 if operator interrupted waveness measurements, 1 if there is an
// error in calibration data and 2 if interrupt button is pressed. Calibrators
// must be filled with center data and scanned before calling this function!
function int Measurewaves()
  int i
  handle hremain,hinterrupt,hview
  change hinfo limits=0,0
  change hinfo text="Waveness test"
  if hlog!=NULL fprintf(hlog,"Waveness test...\n")
  Drawcalboard(0,0,0,DR_HEAD)          // Show calibration board in shuttle
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Fingers now scan central lines and measure waveness of rails. "
  draw text="Have a cup of coffee. If something goes bad, doubleclick button "
  draw font=MAINFONT text="Interrupt" font=TIMESFONT text=" below."
  draw show
  hremain=control GRAPH                // GRAPH to avoid redrawing problems
    window=hright
    position=(RIGHTX-200)/2,120,200,85
    help="Duration of scanning and estimated time till end of current step"
    bkcolor=PINK
    font=MEDIUMFONT
  endc
  hinterrupt=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt measurements and change board position"
    mode=M_DBLCLICK
  endc
  hview=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Statistics"
    help="Press to display or hide waveness statistics"
  endc
  i=Runwavescan(hremain,hinterrupt,hview)
  return i
end

// Calculates best fit and displays results of waveness measurements.
function int Fitwaves()
  int i,j,n,y,nwave,tofile,ret
  float a,b,x,fi,dx,dy,dfi,dteta,r,xoffset
  float xfit[NWAVEL],yfit[NWAVEL],xout[NWAVEL],yout[NWAVEL]
  char s[260]
  handle htable,hfile,hfileext,hfinish
  xoffset=$LAY.xoffset/1000.0
  change hinfo limits=0,0
  change hinfo text="Fitting data..."
  if hlog!=NULL fprintf(hlog,"Fitting waveness data...\n")
  clear hleft
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text=format("Verification now caclulates %g-mm Fourier ",WAVEDX)
  draw text="component of measured vertical deviations from horizontal line "
  draw text="in the middle of calibration board. Please wait..."
  draw show
  // Find best approximation for measured deviations with 50-mm sine wave.
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue
    nwave=c[i].nwave
    // Subtract linear part.
    for j=0,j<nwave,j++ do
      xfit[j]=j; yfit[j]=c[i].wavedy[j]
      xout[j]=j
    enddo
    r=1.0
    SYS.Linfit(nwave,xfit,yfit,&r,nwave,xout,yout)
    for j=0,j<nwave,j++ do
      c[i].wavedy[j]=c[i].wavedy[j]-yout[j]
    enddo
    // Get Fourier component.
    a=0.0; b=0.0
    for j=0,j<nwave,j++ do
      x=(j-nwave/2+0.5)*xstep/NSUBWAVE
      fi=x/WAVEDX*TWOPI
      a=a+c[i].wavedy[j]*Sin(fi)
      b=b+c[i].wavedy[j]*Cos(fi)
    enddo
    c[i].wavea=2.0*Sqrt(a*a+b*b)/nwave
    c[i].wavefi=Atan2(b,a)
    c[i].waveok=1
  enddo
  // Done, now display data.
  change hinfo limits=0,0
  change hinfo text="Results of wave test"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Wave test finished. Table below displays amplitudes and phases "
  draw text=format("of %g-mm waves.",WAVEDX)
  draw show
  htable=control CHILD
    window=hright
    position=40,55,RIGHTX-80,208
    mode=M_VSCROLL
    help="Individual peak-to-peak wave amplitudes and phases"
    bkcolor=PINK
    size=8192
  endc
  // Display measured deviations.
  setfocus htable
  hfile=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="To file"
    help="Press to save table and pictures to .RTF file"
  endc
  hfileext=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="Ext file"
    help="Press to save table, pictures and points to .RTF file"
  endc
  hfinish=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="Finish"
    help="Press to finish verification"
  endc
  if hlog!=NULL then
    fprintf(hlog,"Phases and peak-to-peak amplitudes of %g-mm waves:\n",WAVEDX)
    for i=0,i<$LAY.nfing*2,i++ do
      if c[i].ncal==0 continue
      fprintf(hlog,"  %i%c:    A=%7.4f mm\n   Phase=%4.0f mm",                 \
      i/2,(i & 1?'R':'L'),c[i].wavea*2.0,c[i].wavefi/TWOPI*WAVEDX)
    enddo
  endif
  // Fill table.
  y=24
  draw window=htable color=WHITE bkcolor=WHITE clear
  draw font=INFOFONT color=BLACK at 0,y to 169,y
  draw at 5,19 text="Head"
  draw at 61,19 text="A,mm"
  draw at 119,19 text="Ph,mm"
  draw font=FIXEDSYS
  for i=0,i<$LAY.nfing*2,i++ do
    if c[i].ncal==0 continue
    y=y+18
    draw at 5,y color=DARKGRAY text=format("%2i%c",i/2,(i & 1?'R':'L'))
    draw at 53,y color=BLACK text=format("%6.3f",c[i].wavea*2.0)
    draw at 110,y text=format("%6.0f",c[i].wavefi/TWOPI*WAVEDX)
    draw at 0,y to 169,y
  enddo
  draw at 45,0 to 45,y
  draw at 111,0 to 111,y
  draw at 168,0 to 168,y
  change htable limits=1,y+1
  change htable mode=M_VSCROLL
  draw show
  // View waves.
  Showwavescan(1,0)
  while 1 do
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hfile) then
      tofile=1
    else if Pressed(hfileext) then
      tofile=2
    else if Pressed(hfinish) then
      ret=0; break
    endif
    if tofile then
      Strcpy(s,"waveness.rtf");
      if SYS.Browse(hmain,s,"Specify file to save waveness data",0)!=0 then
        if ROpen(s)!=0 then
          change hinfo color=LIGHTRED
          change hinfo text="Unable to create file!"
        else
          RParagraph(RTF_CENTERED)
          RFmt(RTF_TIMES,RTF_BOLD|RTF_UL,24)
          RAddtext("Waveness test results\n")
          RFmt(RTF_TIMES,RTF_NORMAL,12)
          Strtime(s,"\nMeasured on: %a %d-%b-%Y, %H:%M\n\n",0,0)
          RAddtext(s)
          RFmt(RTF_TIMES,RTF_BOLD,9)
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,7.0)
          RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,15.0)
          RAddtext("Head")
          RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,15.0)
          RAddtext("Ampl, mm")
          RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,15.0)
          RAddtext("Phase, mm")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          for i=0,i<$LAY.nfing*2,i++ do
            if c[i].ncal==0 continue
            RTable(RTF_CENTERED|RTF_BORDER,0.0,0.0)
            RCell(RTF_LEFT|RTF_THINBRD|RTF_SPACE,15.0)
            RAddfmt("%i%c",i/2,(i & 1?'R':'L'))
            RCell(RTF_RIGHT|RTF_THINBRD|RTF_SPACE,15.0)
            RAddfmt("%7.3f ",c[i].wavea*2.0)
            RCell(RTF_RIGHT|RTF_THINBRD|RTF_SPACE,15.0)
            RAddfmt("%7.0f ",c[i].wavefi/TWOPI*WAVEDX)
          enddo
          REndtable()
          RAddtext("\n\n")
          for i=0,i<$LAY.nfing*2,i++ do
            if c[i].ncal==0 continue
            if tofile==2 then
              RFmt(RTF_TIMES,RTF_BOLD,9)
              RTable(RTF_CENTERED|RTF_BORDER,0.0,0.0)
              RCell(RTF_CENTERED|RTF_THINBRD,30.0)
              RAddfmt(" %i%c",i/2,(i & 1?'R':'L'))
              RTable(RTF_CENTERED|RTF_BORDER,0.0,0.0)
              RCell(RTF_LEFT|RTF_THINBRD,15.0)
              RAddtext("X, mm")
              RCell(RTF_LEFT|RTF_THINBRD,15.0)
              RAddtext("dY, mm")
              RFmt(RTF_TIMES,RTF_NORMAL,9)
              for j=0,j<nwave,j++ do
                RTable(RTF_CENTERED|RTF_BORDER,0.0,0.0)
                RCell(RTF_LEFT|RTF_THINBRD,15.0)
                RAddfmt("%.2f",c[i].wavexa[j])
                RCell(RTF_LEFT|RTF_THINBRD,15.0)
                if c[i].waveerr[j]!=0 then
                  RAddtext("???")
                else
                  RAddfmt("%.3f",c[i].wavedy[j])
                endif
              enddo
              REndtable()
              RAddtext("\n")
            endif
            Showwavescan(2,i)
            RParagraph(RTF_CENTERED)
            RAddpiczoom(hstatg,0,0,LEFTX,270,1,1.0)
            RFmt(RTF_TIMES,RTF_BOLD,9)
            RAddfmt("\n %i%c\n\n",i/2,(i & 1?'R':'L'))
          enddo
          RClose()
          change hinfo color=BLACK
          change hinfo text="Results of wave test"
        endif
      endif
      tofile=0
    endif
    Showwavescan(0,0)
    wait
  enddo
  Showwavescan(-1,0)
  return ret
end

// Returns 0 on success or -1 if operator decided to interrupt the calibration.
function int Rotatecalboard(int firsttime)
  int i,t,portdata,prevdata,ident
  char s[256],buf[128]
  handle hstatus,hunlock,hok
  clear hleft
  Drawcalboard(0,0,0,(firsttime?DR_ROTATE:0))
  clear hright
  change hinfo limits=0,0
  change hinfo text="Rotate calibration board"
  hstatus=control TEXT
    window=hright
    name="Unknown shuttle status"
    position=9,190,RIGHTX-17,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  if isauto then
    hunlock=NULL
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="OK"
      help="Press if calibration board is correctly installed"
    endc
  else
    hunlock=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Unlock"
      help="Press to unlock the shuttle"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="OK"
      help="Press if calibration board is correctly installed"
    endc
  endif
  disable hok
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if firsttime then
    draw text="Please rotate calibration board in shuttle by 180 degrees, "
    draw color=LIGHTRED text="but don't flip it! " color=BLACK text="Top side "
    draw text="must remain on the top! "
  else
    draw text="Please correct position of calibration board in the shuttle. "
    draw color=LIGHTRED text="Don't turn it back! " color=BLACK
  endif
  if hunlock!=NULL then
    draw text="Press " font=MAINFONT text="Unlock " font=TIMESFONT
    draw text="to unlock the shuttle. "
  endif
  draw text="Press " font=MAINFONT text="OK " font=TIMESFONT
  if firsttime then
    draw text="when calibration board is rotated."
  else
    draw text="when ready."
  endif
  draw show
  // Move all heads in home position, otherwise shuttle release doesn't work.
  // This movement is not critical, so I don't check for possible errors.
  if demo==0 then
    for i=0,i<$LAY.nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()+10000                     // Wait 10 s for answers
    while (1) do
      for i=0,i<$LAY.nfing,i++
        if c[i*2].ncal==0 continue
        if $A[i].length==0 break       // Some answers are still not here
      enddo
      if i>=$LAY.nfing break           // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()>t break                // No answer within timeout
      wait
    enddo
  endif
  portdata=-1; prevdata=portdata; t=0
  while 1 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if i==0x20 then                  // Shuttle locked in test position
        enable hok
        change hstatus text="Shuttle locked"
      else if (i & 0x10)==0 then
        disable hok
        change hstatus text="Shuttle in"
      else
        disable hok
        change hstatus text="Shuttle out"
      endif
      prevdata=portdata
    endif
    if hunlock!=NULL && Pressed(hunlock) && demo==0 then
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else if Pressed(hok) && (portdata & 0x35)==0x20 then
      break
    else if Pressed(hexit) then
      return -1
    endif
    if demo then                       // Emulate locked shuttle
      portdata=0x20
    else if t==0 then                  // Send next port query
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      ident=SYS.Sendimm(0,3,buf)
      t=Time()+5000                    // Timeout 5 seconds
    else if $A[0].length>0 then
      if $A[0].answer==S_INPORT then
        portdata=$A[0].inport          // Correct answer
      endif
      t=0
    else if t<Time() then
      SYS.Killsend(ident); t=0         // No answer from tester
    endif
    wait
  enddo
  return 0
end

// Using cameras, measures top-to-bottom shift. It corresponds to shift of
// bottom grid relatively to the top grid in the original (non-rotated) board
// position. Returns 0 on success, -1 if operator decided to cancel calibration,
// 1 to retry scanning, 2 to replace board and 3 to cancel shift measurements.
function int Scantopbottom(float *shiftdx,float *shiftdy)
  int i,k,n,err,oldcameramode
  float dx,dy,oldaccuracy
  handle hview,hlivevideo,hinterrupt
  handle hretry,hreplace,hskip
  if cameras!=0x03 return 0            // Needs two dedicated cameras
  change hinfo limits=0,0
  change hinfo text="Scanning offset"
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  Bccreate(hview,-1,-1,-1,1,0)
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Measurements of the offset between top and bottom grids will "
  draw text="take only a few seconds. If something goes bad or you want to "
  draw text="change board placement, doubleclick button "
  draw font=MAINFONT text="Interrupt" font=TIMESFONT text=" below."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Interrupt"
    help="DOUBLECLICK to interrupt scanning and change board position"
    mode=M_DBLCLICK
  endc
  // Set maximal possible scanning accuracy.
  oldaccuracy=accuracy; accuracy=Min(accuracy,0.005)
  oldcameramode=cameramode; cameramode=0;
  // Scan fiducials.
  i=Runvideoscan(NULL,hinterrupt,NULL,hview,hlivevideo,500)
  // Restore previous accuracy.
  accuracy=oldaccuracy
  cameramode=oldcameramode
  if i!=0 return i
  // Check whether we have enough pairs to calculate shift.
  k=$LAY.nfing*2
  n=0; dx=0.0; dy=0.0; err=0
  for i=0,i<c[k].ncal,i++ do
    if c[k].xa[i]!=c[k+1].xa[i] || c[k].ya[i]!=c[k+1].ya[i] then
      err=5; continue                  // Invalid scan sets
    else if Abs(c[k].xm[i]-c[k+1].xm[i])>2.0 ||                                \
      Abs(c[k].ym[i]-c[k+1].ym[i])>2.0 then
      err=Max(err,4); continue         // Incredibly high offset
    else if c[k].err[i]!=0 || c[k+1].err[i]!=0 then
      err=Max(err,3); continue         // Top or bottom fiducial not found
    endif
    dx=dx+c[k].xm[i]-c[k+1].xm[i]      // Top minus bottom
    dy=dy+c[k].ym[i]-c[k+1].ym[i]
    n++
  enddo
  if n>c[k].ncal/2 then
    shiftdx[0]=dx/(n*2)
    shiftdy[0]=dy/(n*2)
    return 0                           // Full success
  endif
  // We have a problem, ask what to do next.
  change hinfo limits=0,0
  change hinfo text="Scanning problem"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==3 then
    if hlog!=NULL fprintf(hlog,"ERROR: Some fiducials were not found\n");
    draw text="Some fiducials were not found. "
    draw color=BLACK text=""
  else if err==4 then
    if hlog!=NULL fprintf(hlog,"ERROR: High top-to-bottom offsets\n");
    draw text="High top-to-bottom offset. "
    draw color=BLACK text=""
  else if err==5 then
    if hlog!=NULL fprintf(hlog,"ERROR: Different points on top and bottom\n");
    draw text="Different points on top and bottom. "
    draw color=BLACK text="This is an internal error, please report atg. "
  else
    if hlog!=NULL fprintf(hlog,"ERROR: Too few points for reliable offset\n");
    draw text="Too few points for reliable offset. "
    draw color=BLACK text="This is an internal error, please report atg. "
  endif
  draw show
  if err==3 || err==4 then
    hretry=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name="Retry"
      help="Press to retry scanning once more"
    endc
    hreplace=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="Replace"
      help="Press to change placement of the calibration board"
    endc
    hskip=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="Skip"
      help="Press to skip top-to-bottom offset measurements"
    endc
  else
    hretry=NULL
    hreplace=NULL
    hskip=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Skip offset"
      help="Press to skip top-to-bottom offset measurements"
    endc
  endif
  while 1 do
    if hretry!=NULL && Pressed(hretry) then
      return 1
    else if hreplace!=NULL && Pressed(hreplace) then
      return 2
    else if Pressed(hskip) then
      return 3
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Measures X-Y offset between the grids on the top and bottom side of the
// calibration board using video cameras. Returns 0 on success and -1 if
// operator interrupted the calibration.
function int Topbottomoffset()
  int i,j,head,valid,useold,firsttime
  float dx,dy,topbottomx,topbottomy
  handle hmeasure,huseold,hskip
  // Offset compensation is not supported for A2/3/4 or single camera.
  if cameras!=0x3 return 0
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return 0
  valid=0
  getini("Calibration","Top-to-bottom offset","%i,%f,%f",                      \
    &valid,&topbottomx,&topbottomy)
  if (Abs(topbottomx)>1.0 || Abs(topbottomy)>1.0) then
    valid=0                            // Offset is incredibly high
  endif
  clear hleft
  Drawcalboard(0,0,0,0)
  change hinfo text="Top-to-bottom offset"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="You have the option to measure and correct small offset between "
  draw text="the grids on the top and bottom side of the calibration board. "
  draw text="This will improve the accuracy of the one-side scanning and "
  draw text="enable quick replacement of needles."
  if valid then
    draw text="\nIf your calibration board is the same, you may use old "
    draw text="offset."
  endif
  draw text=" Skipping this step will have no adverse influence on the test."
  if valid then
    draw font=INFOFONT color=DARKGRAY
    draw at 16,190 text="X offset:"
    draw at 100,190 text=format("%7.3f mm",topbottomx)
    draw at 16,210 text="Y offset:"
    draw at 100,210 text=format("%7.3f mm",topbottomy)
  endif
  draw show
  if hlog!=NULL fprintf(hlog,"Measuring offset between top and bottom...\n")
  hmeasure=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="Measure"
    help="Press to measure and apply top-to-bottom offset"
  endc
  huseold=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="Use old"
    help="Press to apply old top-to-bottom offset"
  endc
  if valid==0 disable huseold
  hskip=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="Skip"
    help="Press to skip this step"
  endc
  while 1 do
    if Pressed(hmeasure) then
      useold=0
      break
    else if Pressed(huseold) then
      if hlog!=NULL then
        fprintf(hlog,"  Operator decided to use old offset\n")
      endif
      useold=1
      break
    else if Pressed(hskip) then
      if hlog!=NULL fprintf(hlog,"Offset measurements skipped by operator\n")
      return 0                         // Skip offset measurements
    else if Pressed(hexit) then
      return -1                        // Operator interrupted measurements
    endif
    wait
  enddo
  if useold==0 then
    firsttime=1
    // Request operator to rotate calibration board.
  replace:
    i=Rotatecalboard(firsttime)        // Rotate calibration board
    firsttime=0
    if i<0 return -1                   // Operator interrupted calibration
    // Load video corrections. Heads are not used on this step.
    i=Loadcorr($LAY.nfing*2,0,1)
    if i<0 return -1                   // Operator interrupted measurements
    i=Loadcorr($LAY.nfing*2+1,0,1)
    if i<0 return -1                   // Operator interrupted measurements
    // Select points to scan. As cameras are accurate, we need only few points.
  retry:
    i=Fillcalibrators(C_PRECAL,FILL_VIDEO)
    if i<0 return -1                   // Operator interrupted measurements
    if i>0 return 0                    // Give up and skip offset measurements
    // Scan selected fiducials.
    i=Scantopbottom(&topbottomx,&topbottomy)
    if i<0 return -1                   // Operator interrupted measurements
    if i==1 goto retry                 // Operator decided to repeat scanning
    if i==2 goto replace
    if i==3 then
      if hlog!=NULL then
        fprintf(hlog,"  Operator decided to cancel offset measurements\n")
      endif
      return 0
    endif
  endif
  // We have valid offsets, apply them to the correction data.
  if hlog!=NULL then
    fprintf(hlog,"  X top-to-bottom offset: %8.3f mm\n",topbottomx)
    fprintf(hlog,"  Y top-to-bottom offset: %8.3f mm\n",topbottomy)
  endif
  setini("Calibration","Top-to-bottom offset","1,%f,%f",topbottomx,topbottomy)
  // Apply corrections.
  for head=0,head<$LAY.nfing*2+2,head++ do
    if c[head].ncal==0 continue
    if head==$LAY.nfing*2 then         // Top camera
      dx=topbottomx/2.0
      dy=topbottomy/2.0
    else if head==$LAY.nfing*2+1 then  // Bottom camera
      dx=-topbottomx/2.0
      dy=-topbottomy/2.0
    else if $LAY.side[head/2]==0 then  // Top head
      dx=topbottomx/2.0
      dy=topbottomy/2.0
    else                               // Bottom head
      dx=-topbottomx/2.0
      dy=-topbottomy/2.0
    endif
    for i=0,i<CORRX,i++ do
      for j=0,j<CORRY,j++ do
       corr[head][i,j].dx=corr[head][i,j].dx+Floor(dx*1000.0+0.5)
       corr[head][i,j].dy=corr[head][i,j].dy+Floor(dy*1000.0+0.5)
      enddo
    enddo
    cext[head].corrcount=5             // Allow max 5 quick corrections
    cext[head].caldate=$LAY.caldate
    cext[head].mode=cext[head].mode | (CE_VALID|CE_QUICK)
  enddo
  return 0                             // Report success
end

// Returns 0 on success or -1 if operator decided to interrupt the calibration.
function int Removeboards()
  int i,t,portdata,prevdata,ident
  char s[256],buf[128]
  handle hstatus,hunlock,hok
  Drawcalboard(0,0,0,DR_EMPTY)
  clear hright
  change hinfo limits=0,0
  change hinfo text="Remove all boards"
  hstatus=control TEXT
    window=hright
    name="Unknown shuttle status"
    position=9,190,RIGHTX-17,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  hunlock=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Unlock"
    help="Press to unlock the shuttle"
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="OK"
    help="Press if shuttle is empty and locked"
  endc
  disable hok
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="Please remove all boards from the shuttle and move back holder "
  draw text="away from the working area. Press " font=MAINFONT text="Unlock "
  draw font=TIMESFONT text="to unlock the shuttle. Press " font=MAINFONT
  draw text="OK " font=TIMESFONT text="when shuttle is empty. " color=LIGHTRED
  draw text="ATTENTION, failing to clear the central area may lead to "
  draw text="serious head damages!"
  draw show
  // Move all heads in home position, otherwise shuttle release doesn't work.
  // This movement is not critical, so I don't check for possible errors.
  if demo==0 then
    for i=0,i<$LAY.nfing,i++
      if c[i*2].ncal==0 continue       // Rail is excluded from calibration
      sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()+10000                     // Wait 10 s for answers
    while (1) do
      for i=0,i<$LAY.nfing,i++
        if c[i*2].ncal==0 continue
        if $A[i].length==0 break       // Some answers are still not here
      enddo
      if i>=$LAY.nfing break           // All answers came
      if Pressed(hexit) return -1      // Operator interrupted calibration
      if Time()>t break                // No answer within timeout
      wait
    enddo
  endif
  portdata=-1; prevdata=portdata; t=0
  while 1 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if i==0x20 then                  // Shuttle locked in test position
        enable hok
        change hstatus text="Shuttle locked"
      else if (i & 0x10)==0 then
        disable hok
        change hstatus text="Shuttle in"
      else
        disable hok
        change hstatus text="Shuttle out"
      endif
      prevdata=portdata
    endif
    if Pressed(hunlock) && demo==0 then
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else if Pressed(hok) && (portdata & 0x35)==0x20 then
      break
    else if Pressed(hexit) then
      return -1
    endif
    if demo then                       // Emulate locked shuttle
      portdata=0x20
    else if t==0 then                  // Send next port query
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      ident=SYS.Sendimm(0,3,buf)
      t=Time()+5000                    // Timeout 5 seconds
    else if $A[0].length>0 then
      if $A[0].answer==S_INPORT then
        portdata=$A[0].inport          // Correct answer
      endif
      t=0
    else if t<Time() then
      SYS.Killsend(ident); t=0         // No answer from tester
    endif
    wait
  enddo
  return 0
end

// Checks whether quick corrections are allowed and warns if not. Returns 1 if
// quick corrections are allowed, 0 if not and -1 if operator has cancelled
// calibration.
function int Isquickallowed()
  handle hcalibrate,hquit
  if cameras==0x3 &&                                                           \
    (cext[$LAY.nfing*2].mode & (CE_VALID|CE_QUICK))==(CE_VALID|CE_QUICK) &&    \
    (cext[$LAY.nfing*2+1].mode & (CE_VALID|CE_QUICK))==(CE_VALID|CE_QUICK) then
    return 1                           // OK for quick corrections
  endif
  clear hleft
  Drawtesterview()
  clear hright
  change hinfo text="Quick corrections disabled"
  change hinfo limits=0,0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED text="Oops! " color=BLACK
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    draw text="Quick corrections are not allowed for tester with head "
    draw text="cameras."
  else if $LAY.cameras!=0x3 then
    draw text="Quick corrections are enabled only for testers with two "
    draw text="video cameras."
  else if cameras!=0x3 then
    draw text="Quick corrections are possible only if both cameras are "
    draw text="enabled."
  else
    draw text="Quick corrections are enabled only if there is no offset "
    draw text="between top and bottom heads and cameras. Please calibrate this "
    draw text="tester with FR4 board and, when asked, correct top-to-bottom "
    draw text="offset (involves rotation of the calibration board in shuttle)."
  endif
  draw show
  hcalibrate=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Calibrate"
    help="Press to calibrate tester with calibration board"
  endc
  hquit=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Quit"
    help="Press to quit calibration"
  endc
  while 1 do
    if Pressed(hquit) then
      return -1                        // Quit calibration
    else if Pressed(hexit) then
      return -1                        // Quit calibration
    else if Pressed(hcalibrate) then
      return 0
    endif
    wait
  enddo
end

// Selects head for quick correction. Possible only if both head and opposite
// camera are corrected for top-to-bottom shift of the calibration board.
// Returns -1 if operator decided to interrupt calibration, 256 on request to
// run ordinary calibration and head number otherwise.
function int Quickselecthead()
  int i,j,head,x,y,dy,somecorrected
  handle hhead[32],hcalibrate,hquit
  change hinfo text="Select head"
  change hinfo limits=0,0
  clear hleft
  draw window=hleft color=BLACK mode=M_CENTERED font=MEDIUMFONT
  draw at LEFTX/2,30 text="Head selection"
  draw color=DARKGRAY mode=M_LEFT font=MAINFONT
  somecorrected=0
  y=55; dy=0
  for j=0,j<$LAY.nfing,j++ do
    for i=0,i<2,i++ do
      head=j*2+i
      if $LAY.side[j]!=0 dy=8
      x=60+(LEFTX/2-20)*i
      hhead[head]=control BUTTON
        window=hleft
        position=x,y+dy,40,21
        text=format("%i%s",j,(i==0?"L":"R"))
        help=format("Press to correct head %i%s",j,(i==0?"L":"R"))
        bkcolor=(quickcorrected[head]==0?GRAY:LIGHTGREEN)
      endc
      if ($LAY.excludedrails & (1<<j))!=0 then
        disable hhead[head]
      else
        draw at x+50,y+dy+18 text=format("[%i]",cext[head].corrcount)
        if cext[head].corrcount==0 disable hhead[head]
        if quickcorrected[head]!=0 somecorrected=1
      endif
    enddo
    y=y+26
  enddo
  draw show
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please select which head you are going to correct. If counter "
  draw text="next to the button is zero, then number of allowed quick "
  draw text="corrections for this head is exhauseted and you must calibrate "
  draw text="tester with the calibration board. "
  if somecorrected==0 then
    draw text="In this case, press " font=MAINFONT text="Full calibration"
    draw font=TIMESFONT text=". "
  endif
  draw text="Press " font=MAINFONT text="Done " font=TIMESFONT
  draw text="to finish correction."
  if somecorrected then
    draw text=" Green buttons indicate processed heads."
  endif
  draw show
  if somecorrected==0 then
    hcalibrate=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Full calibration"
      help="Press to calibrate tester with calibration board"
    endc
    hquit=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Done"
      help="Press to finish calibration"
    endc
  else
    hcalibrate=NULL
    hquit=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Done"
      help="Press to finish calibration"
    endc
  endif
  while 1 do
    for head=0,head<$LAY.nfing*2,head++ do
      if Pressed(hhead[head]) return head
    enddo
    if hcalibrate!=NULL && Pressed(hcalibrate) then
      return 256
    else if Pressed(hquit) then
      return -1
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end

// Service function, applies settings to video viewer. Intended to work with
// dedicated cameras.
function int Videocontrols(int channel,handle hvideo,handle hzoom,int force)
  float zoom
  Bcsetcam(channel,1)
  if Bcupdate(1)!=0 then
    force=1
  else if hzoom!=NULL && Pressed(hzoom) then
    zoomin=Status(hzoom)
    force=1
  endif
  if force then
    zoom=Getzoom(channel)
    SYS.Videoangle(hvideo,channel,channel,                                     \
    (hzoom==NULL?zoom:(zoomin?zoom*4.0:zoom*2.0)),                             \
    Bcgetbri(channel,1),Bcgetctr(channel,1),(channel<0?0:2)|(longexp?4:0),0.0)
  endif
end

// On the basis of X-Y coordinates of two scan points and measured errors,
// calculates deviations of head parameters from ideal defined by correction
// data. All parameters are in millimeters, except for deltafi in radians.
function int Headparms(int head,float xexp[],float yexp[],float dx[],          \
  float dy[],float *deltar,float *deltafi,float *deltax,float *deltay)
  float sign,yoffset,dsin,dcos,factor,fia,fib
  // Sign is +1 for left and -1 for right heads. Comparing with the general
  // case described in "Electrical scanning", our case is simpler: a=c and b=d.
  sign=(head & 1)==0?1.0:-1.0
  yoffset=$LAY.yoffset[head/2]/1000.0
  fia=Asin(sign*(yexp[0]-yoffset+dy[0])/radius)
  fib=Asin(sign*(yexp[1]-yoffset+dy[1])/radius)
  dsin=Sin(fia)-Sin(fib)
  dcos=Cos(fia)-Cos(fib)
  factor=1.0/(dsin*dsin+dcos*dcos)
  deltar[0]=sign*((dy[1]-dy[0])*dsin+(dx[1]-dx[0])*dcos)*factor
  deltafi[0]=sign/radius*((dy[1]-dy[0])*dcos-(dx[1]-dx[0])*dsin)*factor
  deltax[0]=sign*(radius*Sin(fib)*deltafi[0]-deltar[0]*Cos(fib))-dx[1]
  deltay[0]=-sign*(radius*Cos(fib)*deltafi[0]+deltar[0]*Sin(fib))-dy[1]
end

// Returns 0 on success, 1 as request to remove objects from the shuttle and
// -1 if operator interrupted the calibration.
function int Quickadjusthead(int head)
  int i,j,t,channel,point,err,firsttime,move,zoffset,zchanged,repeat
  float y,fi,sign,xheight,step,xexp[4],yexp[4],dx[4],dy[4]
  float meanx[2],meany[2],meandx[2],meandy[2]
  float deltar,deltafi,deltax,deltay
  char s[256]
  handle hview,hlivevideo,hzoom
  handle hdontask,hcontinue,hshuttle,hcancel
  handle hl,hr,hu,hd,hll,hrr,huu,hdd,hz,hok
  change hinfo limits=0,0
  change hinfo text=format("Head %i%s",head/2,(head & 1?"R":"L"))
  channel=($LAY.side[head/2]==0?1:0)   // Opposite camera
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  Bccreate(hview,-1,-1,-1,1,0)
  hzoom=control CHECKBOX
    window=hview
    position=239,303,80,21
    name="Zoom in"
    help="Check to zoom video image"
    color=BROWN
    font=INFOFONT
    mode=(zoomin?M_CHECKED:0)
  endc
  Videocontrols(channel,hlivevideo,hzoom,1)
  xheight=Min($LAY.top[head/2]-$LAY.yoffset[head/2],                           \
    $LAY.yoffset[head/2]-$LAY.bottom[head/2])/1000.0
  err=0
  // Move all heads from the same side away.
  for i=0,i<$LAY.nfing*2,i++ do
    if i==head continue
    if $LAY.side[head/2]!=$LAY.side[i/2] continue
    sprintf(s,"M %i(Z) NOP",i)
    SERV.Cmdimm(32,s)
  enddo
  SYS.Killimm(head)
  sprintf(s,"Z offset[%i]",head)
  zoffset=0; getini("Needles",s,"%i",&zoffset)
  repeat=0
scanagain:
  for point=0,point<4,point++ do
    dx[point]=0.0; dy[point]=0.0
  enddo
  for point=0,point<4,point++ do
    if point>=2 then
      dx[point]=dx[point-2]
      dy[point]=dy[point-2]
    endif
    disable hzoom
    change hinfo limits=0,0
    change hinfo text=format("Head %i%s point %i",                             \
      head/2,(head & 1?"R":"L"),point+1)
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK text="Wait..." show
    // Select calibration point.
    if point<2 then
      xexp[point]=$LAY.xoffset/1000.0-xstep
    else
      xexp[point]=$LAY.xoffset/1000.0+xstep
    endif
    if (point & 1)==0 then
      yexp[point]=$LAY.yoffset[head/2]/1000.0-xheight*0.7
    else
      yexp[point]=$LAY.yoffset[head/2]/1000.0+xheight*0.7
    endif
    // Move selected finger up.
    sprintf(s,"OUTPORT %i,5",0x8008+(head/2)*256+(head & 1))
    SERV.Cmdimm(32,s)                  // Move finger up
    // Move camera into the calibration point and check that air is free.
    sprintf(s,"M %i(%f,%fA%i) NOP",                                            \
      $LAY.nfing*2+channel,xexp[point],yexp[point],acc)
    if SERV.Cmdimm(head,s)<=0 err=1    // Unable to send command
    t=Time()+10000                     // Timeout 10 seconds
    while err==0 && $A[head].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if t<Time() err=2                // Timeout exhausted
      wait
    enddo
    if err==0 && $A[head].answer!=S_NOP err=3
    if err!=0 break
    if assumeemptyshuttle==0 && repeat==0 then
      clear hright
      draw window=hright font=TIMESFONT color=BLACK wrap=RIGHTX-5 at 6,30
      draw text="Please confirm that shuttle does not cover the area visible "
      draw text="by the camera. " color=LIGHTRED text="If needle can collide "
      draw text="with any object, press " color=BLACK font=MAINFONT
      draw text="Shuttle" font=TIMESFONT color=LIGHTRED text=", or finger may "
      draw text="be severely damaged! " color=BLACK text="Press " font=MAINFONT
      draw text="Continue " font=TIMESFONT text="when ready."
      draw show
      hdontask=control CHECKBOX
        window=hright
        position=15,210,RIGHTX-25,24
        text="I'm experienced, don't ask again!"
        help="Assume that shuttle is clear and never ask again"
      endc
      hcontinue=control BUTTON
        window=hright
        position=5,USERY,RIGHTX/3-5,24
        name="Continue"
        help="Press if area is clear"
      endc
      hshuttle=control BUTTON
        window=hright
        position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
        name="Shuttle"
        help="Press to remove objects from the shuttle"
      endc
      hcancel=control BUTTON
        window=hright
        position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
        name="Cancel"
        help="Press to interrupt head correction"
      endc
      firsttime=1
      while 1 do
        if Pressed(hexit) then
          return -1
        else if Pressed(hcontinue) then
          assumeemptyshuttle=Status(hdontask)
          break
        else if Pressed(hshuttle) then
          return 1
        else if Pressed(hcancel) then
          return 0
        endif
        Videocontrols(channel,hlivevideo,NULL,firsttime)
        firsttime=0
        wait
      enddo
    endif
    enable hzoom
    // Move head into the point and ask operator to find the tip.
    clear hright
    draw window=hright font=TIMESFONT color=BLACK wrap=RIGHTX-5 at 6,30
    if repeat==0 then
      draw text="Please locate the exact position of the tip of the needle as "
      draw text="precisely as possible. Use Z slider to change vertical "
      draw text="coordinate. "
    else
      draw text="Measured deviation was higher than 500 um. To assure "
      draw text="sufficient accuracy, please repeat tip location again. "
    endif
    draw text="Press " font=MAINFONT text="Continue " font=TIMESFONT
    draw text="when ready."
    draw font=MEDIUMFONT at RIGHTX-60,110 text="Z"
    draw at RIGHTX/2-63,110 text="Position"
    draw color=GRAY bkcolor=LIGHTGRAY
    draw at RIGHTX/2-100,110 fillrect RIGHTX/2+40,250
    draw show
    huu=control BUTTON
      window=hright
      position=RIGHTX/2-50,110,40,16
      help="Press and hold to move finger up (accelerated)"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hu=control BUTTON
      window=hright
      position=RIGHTX/2-50,125,40,35
      name="U"
      help="Press and hold to move finger up"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hll=control BUTTON
      window=hright
      position=RIGHTX/2-100,160,16,40
      help="Press and hold to move finger to the left (accelerated)"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hl=control BUTTON
      window=hright
      position=RIGHTX/2-85,160,35,40
      name="L"
      help="Press and hold to move finger to the left"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hr=control BUTTON
      window=hright
      position=RIGHTX/2-10,160,35,40
      name="R"
      help="Press and hold to move finger to the right"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hrr=control BUTTON
      window=hright
      position=RIGHTX/2+24,160,16,40
      help="Press and hold to move finger to the right (accelerated)"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hd=control BUTTON
      window=hright
      position=RIGHTX/2-50,200,40,35
      name="D"
      help="Press and hold to move finger down"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hdd=control BUTTON
      window=hright
      position=RIGHTX/2-50,234,40,16
      help="Press and hold to move finger down (accelerated)"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hz=control VSCROLL
      window=hright
      position=RIGHTX-70,110,30,140
      help="Move to adjust Z coordinate"
      limits=-50,50
    endc
    change hz select=zoffset
    hcontinue=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Continue"
      help="Press when tip is precisely located"
    endc
    hcancel=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Break"
      help="Press to select different finger"
    endc
    SYS.Killimm(head); $A[head].length=0
    sprintf(s,"M %i(%f,%fA%iH64) NOP",head,xexp[point],yexp[point],acc)
    if SERV.Cmdimm(head,s)<=0 err=1    // Unable to send command
    t=Time()
    while err==0 && $A[head].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Time()-t>5000 err=2           // Timeout exhausted
      wait
    enddo
    if err==0 && $A[head].answer!=S_NOP err=3
    if err!=0 break
    // Search for finger tip with the camera. I assume that corrections
    // change slowly and move camera instead of finger.
    firsttime=1; move=1
    zchanged=0; t=Time()-500           // Z movement 500 ms after start
    $A[head].length=5
    while 1 do
      step=(Status(hzoom)?0.002:0.005)
      if Pressed(hexit) then
        return -1
      else if Pressed(hu) then
        dy[point]=dy[point]+step; move=1
      else if Pressed(hl) then
        dx[point]=dx[point]-step; move=1
      else if Pressed(hr) then
        dx[point]=dx[point]+step; move=1
      else if Pressed(hd) then
        dy[point]=dy[point]-step; move=1
      else if Pressed(huu) then
        dy[point]=dy[point]+step*5; move=1
      else if Pressed(hll) then
        dx[point]=dx[point]-step*5; move=1
      else if Pressed(hrr) then
        dx[point]=dx[point]+step*5; move=1
      else if Pressed(hdd) then
        dy[point]=dy[point]-step*5; move=1
      else if Pressed(hz) then
        zoffset=Status(hz); zchanged=1
      else if Pressed(hcontinue) then
        break
      else if Pressed(hcancel) then
        return 0
      endif
      if move && $A[head].length>0 then
        dx[point]=Max(-1.5,Min(dx[point],1.5))
        dy[point]=Max(-1.5,Min(dy[point],1.5))
        sprintf(s,"M %i(%f,%fA%iH64) NOP",$LAY.nfing*2+channel,                \
          xexp[point]-dx[point],yexp[point]-dy[point],acc)
        SERV.Cmdimm(head,s)
        move=0
      endif
      if Time()-t>1000 then            // Illumination on
        sprintf(s,"OUTPORT %i,%i",0x2004+($LAY.side[head/2]==1?0:1),1)
        SERV.Cmdimm(32,s)
        t=Time()
        zchanged=1
      endif
      if zchanged then
        sprintf(s,"OUTPORT %i,%i",                                             \
          0x8008+(head/2)*256+(head & 1),90+zoffset)
        SERV.Cmdimm(32,s)
        zchanged=0
      endif
      Videocontrols(channel,hlivevideo,hzoom,firsttime)
      firsttime=0
      wait
    enddo
  enddo
  if err==0 then
    sprintf(s,"Z offset[%i]",head)
    setini("Needles",s,"%i",zoffset)
    // Check measured offsets for reliability and calculate means. I allow for
    // 100 um difference, but this is already too much...
    for point=0,point<2,point++ do
      if Abs(dx[point]-dx[point+2])>0.100 err=4
      meanx[point]=(xexp[point]+xexp[point+2])/2.0
      meandx[point]=(dx[point]+dx[point+2])/2.0
      if Abs(dy[point]-dy[point+2])>0.100 err=4
      meany[point]=(yexp[point]+yexp[point+2])/2.0
      meandy[point]=(dy[point]+dy[point+2])/2.0
    enddo
    // Calculate deviations (radius, angle, offset), correct corrections, save
    // them to disk and load into the tester.
    if err==0 then
      Headparms(head,meanx,meany,meandx,meandy,&deltar,&deltafi,&deltax,&deltay)
      if hlog!=NULL then
        if repeat==0 then
          fprintf(hlog,"Manual correction for head %i%c\n",                    \
          head/2,(head & 1?'R':'L'))
        else
          fprintf(hlog,"  Deviations exceed 500 um, repeating scan...\n")
        endif
        for point=0,point<4,point++ do
          fprintf(hlog,"  Point %i (X=%7.3f, Y=%7.3f mm):  ",                  \
            point,xexp[point],yexp[point])
          fprintf(hlog,"dX=%7.3f, dY=%7.3f mm\n",dx[point],dy[point])
        enddo
        fprintf(hlog,"  Calculated parameters: dR=%7.3f mm, dFi=%8.5f rad, ",  \
          deltar,deltafi)
        fprintf(hlog,"dX=%7.3f, dy=%7.3f mm\n",deltax,deltay)
      endif
      sign=((head & 1)==0?1.0:-1.0)
      for i=0,i<CORRX,i++ do
        for j=0,j<CORRY,j++ do
          y=(j-CORRY/2)*ystep
          fi=sign*Asin(y/radius)
          corr[head][i,j].dx=corr[head][i,j].dx+Floor(                         \
            (sign*radius*Cos(fi)-sign*(radius+deltar)*Cos(fi+deltafi)-deltax)* \
            1000.0+0.5)
          corr[head][i,j].dy=corr[head][i,j].dy+Floor(                         \
            (sign*radius*Sin(fi)-sign*(radius+deltar)*Sin(fi+deltafi)-deltay)* \
            1000.0+0.5)
          ;
        enddo
      enddo
      // Quick head correction invalidates fine correction tables.
      cext[head].mode=cext[head].mode & (~CE_FINE)
      corrvalid=0
      if Abs(dx[0])>0.500 || Abs(dy[0])>0.500 ||                               \
        Abs(dx[1])>0.500 || Abs(dy[1])>0.500 then
        repeat=1                       // High deviation, scan again
      else
        repeat=0
      endif
      if Loadcorr(head,0,(repeat==0))<0 return -1
      if repeat then
        delay 500                      // Psychological delay
        goto scanagain
      endif
      if cext[head].corrcount>0 cext[head].corrcount=cext[head].corrcount-1
      if Savecorr()<0 return -1
      corrvalid=1
      quickcorrected[head]=1
      return 0                         // Report success
    endif
  endif
  // Report error.
  change hinfo limits=0,0
  change hinfo text="Adjustment problem"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Unable to send command!"
  else if err==2 then
    draw text="No answer from tester!"
  else if err==3 then
    draw text="Command executed incorrectly!"
  else
    draw text="Offsets are too different!"
  endif
  draw at 6,60 wrap=RIGHTX-5 color=BLACK
  draw text="For this reason, head was not corrected. Please try again. "
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="OK"
    help="Press to retry"
  endc
  while 1 do
    if Pressed(hok) return 0
    if Pressed(hexit) return -1      // Quit calibration
    wait
  enddo
end

// If some head was quickly corrected, warn about low accuracy. No return,
// because calibration is anyway finished.
function int Quickheadwarning()
  int head,somecorrected
  handle hcont
  somecorrected=0
  for head=0,head<$LAY.nfing*2,head++ do
    if quickcorrected[head]!=0 somecorrected=1
  enddo
  if somecorrected==0 return
  clear hleft
  Drawtesterview()
  change hinfo text="Low tester accuracy"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="Attention, low tester accuracy!"
  draw at 6,60 color=BLACK
  draw text="You have manually correceted one or several heads. This art of "
  draw text="calibration is inaccurate. If you experience problems with fine-"
  draw text="pitch boards, please run full calibration."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="OK"
    help="Press to continue"
  endc
  while 1 do
    if Pressed(hexit) return
    if Pressed(hcont) return
    wait
  enddo
end

// Gets lists of features supported by crate controller and measurement card.
// If any command fails, list is zeroed assuming only basical functionality.
function int Getfeatures()
  int t
  char buf[256]
  cratefeatures=0
  measfeatures=0
  measfeatures2=0
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return
  // Get features of Crate controller.
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10000012             // Query crate features
  SYS.Sendimm(0,6,buf)
  t=Time()
  while $A[0].length==0 do
    if Time()-t>1500 break             // Timeout
    wait
  enddo
  if $A[0].answer==S_INPORT32 then
    cratefeatures=$uint4($A[0]+5)
    // If Ollytest is old and does not support nanometer accuracy, remove this
    // feature from the list.
    if SERV.Parsecmd("M 0:(0,0) NOP",buf)<0 then
      cratefeatures=cratefeatures & (~CF_NANOMETER)
    endif
  endif
  // Get features of measurement card.
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x1002001F             // Query features of measurement card
  SYS.Sendimm(0,6,buf)
  t=Time()
  while $A[0].length==0 do
    if Time()-t>1500 return            // Timeout
    wait
  enddo
  if $A[0].answer==S_INPORT32 then
    measfeatures=$uint4($A[0]+5)
  endif
  // Get new features of measurement card.
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10020021             // Query features, set 2
  SYS.Sendimm(0,6,buf)
  t=Time()
  while $A[0].length==0 do
    if Time()-t>1500 return            // Timeout
    wait
  enddo
  if $A[0].answer==S_INPORT32 then
    measfeatures2=$uint4($A[0]+5)
  endif
  // If tester is S3, get Y step of camera corrections.
  if testertype==TT_S3 then
    buf[0]=S_INPORT32
    buf[1]=0xFF                        // Crate controller
    $uint4(buf+2)=0x10000302           // Query Y corrections step for camera
    SYS.Sendimm(0,6,buf)
    t=Time()
    while $A[0].length==0 do
      if Time()-t>1500 break             // Timeout
      wait
    enddo
    if $A[0].answer==S_INPORT32 then
      videoyfromcrate=$uint4($A[0]+5)/1000.0
      if videoyfromcrate==0.0 videoyfromcrate=77.5
    else
      videoyfromcrate=0.0
    endif
  else
    videoyfromcrate=0.0
  endif
end

// Gets offsets of encoders on the left and right shuttle and applies them to
// the layout.
function int Getsplitencoders()
  int t,err
  char buf[64]
  handle hretry,hquit
  if testertype!=TT_S3 || ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO              \
    return 0                           // Does not apply
  if hlog!=NULL                                                                \
    fprintf(hlog,"Getting offsets of split shuttle encoders...\n")
  SYS.Killimm(0)
  SYS.Killimm(1)
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10000330             // Encoder base for left split shuttle
  SYS.Sendimm(0,6,buf)
  $uint4(buf+2)=0x10000331             // Encoder base for right split shuttle
  SYS.Sendimm(1,6,buf)
  err=0
  t=Time()
  while $A[0].length==0 || $A[1].length==0 do
    if Time()-t>1500 then
      err=1; break                     // Timeout
    endif
    if Pressed(hexit) return -1        // Operator interrupted calibration
    wait
  enddo
  if err==0 && ($A[0].answer!=S_INPORT32 || $A[0].answer!=S_INPORT32)          \
    err=2                              // Invalid answer
  if err==0 then
    // Note that both INPORT32 and $EXT0 report offsets in 1/256th of
    // micrometer, so additional conversion is not necessary.
    $int4($EXT0+582)=$int4($A[0]+5)
    $int4($EXT0+586)=$int4($A[1]+5)
    if hlog!=NULL then
      fprintf(hlog,"  Left shuttle:  %9.4f mm\n",$int4($EXT0+582)/256000.0)
      fprintf(hlog,"  Right shuttle: %9.4f mm\n",$int4($EXT0+586)/256000.0)
    endif
    return 0
  endif
  // Display error message.
  change hinfo text="Unable to get shuttle offsets"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="Unable to get offsets of shuttle encoders. " color=BLACK
  if err==1 then
    if hlog!=NULL fprintf(hlog,"  Timeout while executing commands\n")
    draw text="Request timeouted. "
  else
    if hlog!=NULL fprintf(hlog,"  Invalid answer from tester\n")
    draw text="Crate returned invalid answer. "
  endif
  draw text="Corrections depending on shuttle position are no longer "
  draw text="possible. Please decide what to do."
  hretry=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Check status"
    help="Press to restart calibration"
  endc
  hquit=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Quit"
    help="Press to quit calibration"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hretry) return 1
    if Pressed(hquit) return -1
    wait
  enddo
end

// Checks that preload force of splinogramms is in the green area. If parameter
// makereset is non-zero, will make soft reset to measure new preload forces.
// Returns 0 if splinogramms are OK, preload test is not possible  or operator
// has accepted the measured values, 1 if user requested retest and -1 if
// operator interrupted the calibration.
function int Checkpreload(int makereset)
  int i,j,t,y,head,nused,limitsent,limit,value[32],vbad[32],warn,err
  char s[256]
  handle htable,hretry,hskip,hquit
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
    return 0                           // Preload force test not supported
  if ($EXTLAY.zheadtype & (HCZ_VALID|HCZ_TESTPRLD))!=(HCZ_VALID|HCZ_TESTPRLD)  \
    return 0                           // Preload force test turned off
  if ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSPL &&                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTHSPL                           \
    return 0                           // Only splinogramms can be tested
  err=0
  warn=0
  if hlog!=NULL fprintf(hlog,"Splino preload force test...\n")
  if makereset then
    Drawtesterview()
    change hinfo limits=0,0
    change hinfo text="Soft reset"
    clear hright
    SYS.Softimm(0)
    t=Time(); i=0
    while $A[0].length==0 do
      if Pressed(hexit) return -1      // Operator interrupted calibration
      j=(Time()-t)/1000
      if i!=j then
        change hinfo text=format(" - %i s",j)
        i=j
      endif
      if j>15 break
      wait
    enddo
    if $A[0].length==0 then
      err=1                            // Timeout waiting for soft reset
    else if $A[0].answer==S_ERROR then
      err=2                            // Invalid answer
    endif
  endif
  // Read test results (all heads) and expected limit (first available head).
  limitsent=0
  nused=0
  for head=0,head<$LAY.nfing*2 && err==0,head++ do
    if c[head].ncal==0 continue
    sprintf(s,"INPORT32 HEAD(%i),0x10000118",head)
    SERV.Cmdimm(head,s)
    if limitsent==0 then
      sprintf(s,"INPORT32 HEAD(%i),0x10000119",head)
      SERV.Cmdimm(32,s)
      limitsent=1
    endif
    nused++
  enddo
  if limitsent==0 then
    if hlog!=NULL fprintf(hlog,"  All heads are excluded from the test\n")
    return 0                           // All heads excluded?
  endif
  // Wait for answers.
  t=Time()
  while err==0 do
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>3000 err=1             // Timeout
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      if $A[head].length==0 break
    enddo
    if head>=$LAY.nfing*2 && $A[32].length!=0 break
    wait
  enddo
  // Analyse answers.
  if err==0 then
    if $A[32].answer!=S_INPORT32 then
      err=2
    else if $uint4($A[32]+5)==0 then
      if hlog!=NULL fprintf(hlog,"  Force test seems to be unsupported\n")
      return 0
    endif
  endif
  if err==0 then
    limit=$uint4($A[32]+5)
    for head=0,head<$LAY.nfing*2 && err==0,head++ do
      if c[head].ncal==0 continue
      if $A[head].answer!=S_INPORT32 then
        err=2
      else
        value[head]=$uint4($A[head]+5) & 0x7FFFFFFF
        vbad[head]=$uint4($A[head]+5) & 0x80000000
        if value[head]>limit/2 warn=Max(warn,1)
        if vbad[head] warn=2
        if hlog!=NULL then
          fprintf(hlog,"  Head %i%s: ",head/2,head & 1?"R":"L")
          fprintf(hlog,"pressure sensor signal %5i bits, ",value[head])
          fprintf(hlog,"limit %i",limit)
          if vbad[head] then
            fprintf(hlog," (BAD)\n")
          else if value[head]>limit/2 then
            fprintf(hlog," (WEAK)\n")
          else
            fprintf(hlog,"\n")
          endif
        endif
      endif
    enddo
  endif
  if err==0 && warn==0 return 0        // Success
  // Report problem.
  clear hright
  if err!=0 || warn==2 then
    change hinfo text="Needle preload test error"
  else
    change hinfo text="Weak preload force"
  endif
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==0 && warn!=0 then
    if hlog!=NULL fprintf(hlog,"  Some needles are too weak\n")
    draw text="Some needles are too weak. " color=BLACK
    draw text="If soft touch needle has no or too low preload pressure, "
    draw text="contacting is unreliable and head may detect contact high over "
    draw text="the PCB surface, thus missing the short. "
    if warn==2 then
      draw color=LIGHTRED text="Replace needles marked as bad and restart "
      draw text="the calibration." color=BLACK
    else
      draw color=LIGHTRED text="We recommend to replace suspicious needles. "
      draw color=BLACK text="Please decide what to do."
    endif
    htable=control CHILD
      window=hright
      position=15,135,RIGHTX-30,145
      limits=RIGHTX-60,nused*20+38
      mode=M_VSCROLL
      help=("Results of pressure sensor test")
      bkcolor=PINK
      size=4096
    endc
    y=30
    draw window=htable font=INFOFONT color=DARKGRAY
    draw at 5,5 to 208,5
    draw at 5,5 to 5,32 at 24,26 text="Head"
    draw at 75,5 to 75,32 at 95,26 text="Amplitude / limit"
    draw at 208,5 to 208,33
    draw at 5,32 to 208,32
    draw font=FIXEDSYS
    for head=0,head<$LAY.nfing*2,head++ do
      if c[head].ncal==0 continue      // Head excluded from calibration
      y=y+20
      draw color=DARKGRAY
      draw at 5,y-18 to 5,y+2 to 208,y+2 to 208,y-18
      draw at 75,y-18 to 75,y+2
      draw at 25,y color=BLACK
      draw text=format("%2i%c",head/2,(head & 1?'R':'L'))
      draw at 79,y
      if vbad[head] then
        draw color=LIGHTRED
      else if value[head]>limit/2 then
        draw color=RED
      else
        draw color=BLACK
      endif
      draw text=format("%4i/%i",value[head],limit)
      if vbad[head] then
        draw text=" BAD"
      else if value[head]>limit/2 then
        draw text=" WEAK"
      endif
    enddo
    draw show
    setfocus htable
    draw window=hright
  else if err==1 then
    if hlog!=NULL fprintf(hlog,"  Timeout while executing command\n")
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
    draw text="Preload force test interrupted. Please decide what to do."
  else if err==2 then
    if hlog!=NULL fprintf(hlog,"  Unexpected answer from crate\n")
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate differs from expected. "
    draw text="Preload force test interrupted. Please decide what to do."
  else
    draw text="Internal error"
    draw at 6,60 color=BLACK
    draw text="Preload force test interrupted. Please decide what to do."
  endif
  draw show
  hretry=control BUTTON
    window=hright
    position=5,USERY+10,RIGHTX/3-5,24
    name="Try again"
    help="Press to repeat Soft reset"
  endc
  hskip=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY+10,RIGHTX/3-5,24
    name="Continue"
    help="Skip rigidness test of micro needles and continue calibration"
  endc
  if warn==2 disable hskip
  hquit=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY+10,RIGHTX/3-9,24
    name="Quit"
    help="Press to quit calibration"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hretry) return 1
    if Pressed(hskip) then
      if hlog!=NULL fprintf(hlog,"  Operator decided to skip test\n")
      return 0
    endif
    if Pressed(hquit) return -1
    wait
  enddo
end

// If glass board is installed, initialize HV source in order to allow HV
// contact conditioning during the test. Errors are not reported.
function int Inithvconditioning()
  int t
  char buf[32]
  if USEHVCOND==0 || (boardtype!=1 && boardtype!=2) then
    usehvconditioning=0
    return                             // HV conditioning is not necessary
  endif
  // Set fastest possible parameters.
  buf[0]=S_HVINIT                      // HV initialization
  $uint2(buf+1)=30                     // Conditioning voltage, volts
  $uint2(buf+3)=0                      // Mode
  $uint2(buf+5)=1000                   // Maximal current, uA
  $uint2(buf+7)=100                    // Maximal resistance, MOhm
  $uint4(buf+9)=2                      // Sustain time, ms
  $uint4(buf+13)=1000                  // Rising speed, V/ms
  $uint2(buf+17)=0                     // Duration of initialization
  $uint4(buf+19)=0                     // Reserved, must be zero
  $uint4(buf+23)=0                     // Reserved, must be zero
  $uint4(buf+27)=0                     // Reserved, must be zero
  // Send command.
  SYS.Killimm(32)
  SYS.Sendimm(32,31,buf)
  // Wait for answer.
  t=Time()
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>6000 return            // Timeout
    wait
  enddo
  if $A[32].answer!=S_HVINIT return    // Unsupported command
  if $int4($A[32]+5)!=0 return         // Initialization was unsuccessfull
  usehvconditioning=1                  // OK to use HV conditioning
end

// Resets all statistics gathered by crate and heads.
function int Resetallstat()
  int i
  char buf[32]
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return
  if demo return
  buf[0]=S_DEBUG
  buf[1]=0x2F                          // Statistical data
  buf[3]=1                             // Reset statistics
  $int2(buf+4)=0                       // Page 0: reset all statistics at once
  $int4(buf+6)=0
  // Reset crate statistics.
  buf[2]=0xFF                          // Crate controller
  SYS.Sendimm(32,10,buf)
  // Reset head statistics.
  for i=0,i<$LAY.nfing*2,i++ do
    buf[2]=i                           // Head
    SYS.Sendimm(32,10,buf)
  enddo
  // Reset statistics of video cameras.
  if $LAY.cameras & 1 then
    buf[2]=$LAY.nfing*2                // Top video camera
    SYS.Sendimm(32,10,buf)
  endif
  if $LAY.cameras & 2 then
    buf[2]=$LAY.nfing*2+1              // Bottom video camera
    SYS.Sendimm(32,10,buf)
  endif
  // Reset statistics of measurement card.
  buf[2]=0x80                          // Measurement card
  SYS.Sendimm(32,10,buf)
end

// Writes statistical data to log. If some head is significantly worser than
// others, warns operator. On error, simply quits with answer 0. Returns -1 if
// operator interrupted calibration.
function int Processstat()
  int i,t,head
  float tvibrx[32],tvibry[32],accx[32],accy[32]
  float tvibrz[32],tdown[32],tup[32],contup[32]
  char buf[32]
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return
  if demo || hlog==NULL return         // Statistics comes to log only!
  // Get statistics for all heads that participated in calibration.
  Fillcalibrators(C_CENTER,FILL_MECH)
  for head=0,head<$LAY.nfing*2,head++ do
    if c[head].ncal==0 continue
    SYS.Killimm(0)
    SYS.Killimm(1)
    SYS.Killimm(2)
    // Ask for statistical data.
    buf[0]=S_DEBUG
    buf[1]=0x2F                        // Statistical data
    buf[2]=head                        // Crate controller
    buf[3]=0                           // Don't reset statistics
    $int4(buf+6)=0                     // Reserved fields
    $int2(buf+4)=0x22                  // Page 0x22 (X movements)
    SYS.Sendimm(0,10,buf)
    $int2(buf+4)=0x23                  // Page 0x23 (Y movements)
    SYS.Sendimm(1,10,buf)
    $int2(buf+4)=0x24                  // Page 0x24 (Z movements)
    SYS.Sendimm(2,10,buf)
    // Wait for answers.
    t=Time()
    while 1 do
      if Time()-t>5000 return 0        // Timeout, skip statistics
      for i=0,i<3,i++ do
        if $A[i].length==0 break
      enddo
      if i>=3 break
      if Pressed(hexit) return -1      // Operator interrupted calibration
      wait
    enddo
    for i=0,i<3,i++ do
      if $A[i].answer!=S_DEBUG break
    enddo
    if i<3 return 0                    // Invalid answer
    // Extract data of interest.
    tvibrx[head]=$int4($A[0]+5+0*4)/1000.0
    tvibry[head]=$int4($A[1]+5+0*4)/1000.0
    accx[head]=$int4($A[0]+5+2*4)
    accy[head]=$int4($A[1]+5+2*4)
    tvibrz[head]=$int4($A[2]+5+0*4)/1000.0
    tdown[head]=$int4($A[2]+5+2*4)/1000.0
    tup[head]=$int4($A[2]+5+3*4)/1000.0
    contup[head]=$int4($A[2]+5+4*4)
  enddo
  // Write statistics to log file.
  fprintf(hlog,"Statistics of X-Y movements:\n")
  fprintf(hlog,"  Head  X vibr, ms    Y vibr, ms    X acc, um    Y acc, um\n")
  for head=0,head<$LAY.nfing*2,head++ do
    if c[head].ncal==0 continue
    fprintf(hlog," %2i%c    %10.2f    %10.2f    %9.1f    %9.1f\n",             \
    head/2,(head & 1?'R':'L'),tvibrx[head],tvibry[head],accx[head],accy[head])
  enddo
  fprintf(hlog,"Statistics of Z movements:\n")
  fprintf(hlog,"  Head  T vibr, ms    T down, ms     T up, ms    Hcont, um\n")
  for head=0,head<$LAY.nfing*2,head++ do
    if c[head].ncal==0 continue
    fprintf(hlog," %2i%c    %10.2f    %10.2f    %9.2f    %9.1f\n",             \
    head/2,(head & 1?'R':'L'),tvibrz[head],tdown[head],tup[head],contup[head])
  enddo
  // Analyse statistics.
end

// Verifies that points with the maximal possible individual corrections are
// reachable by all heads in all positions. May be not the case if calibration
// board had too high offset. Returns 0 on success, -1 if operator interrupted
// calibration and 2 if operator decided to repeat calibration.
function int Verifylimits(int standalone)
  int i,j,k,n,p,t,rail,head,opp,nfing,step,isneg,diffsupported
  int limit[32][3],nlimit,onlimit[32],err
  float y,xp[32],yp[32],xt[32],yt[32],xc[32],yc[32],r1,r2,delta
  char s[256],buf[32]
  handle htest,hskip,htable,hrepeat,hcont
  if calmode==MODE_CADJ return 0       // C adjust does not need this routine
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_A7 && testertype!=TT_A8 return 0
  nfing=$LAY.nfing
  // Ask whether user wants limit verification.
  Drawtesterview()
  if standalone==0 then
    change hinfo text="Verification of limits"
    change hinfo limits=0,0
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK
    draw text="Printed circuit boards in the shuttle always have some offset. "
    draw text="If calibration board was shifted in the same direction, total "
    draw text="offset may exceed the capabilities of mechanics. In this case, "
    draw text="points at the rail borders will be physically unreachable. Do "
    draw text="you want to verify the mechanical limits?"
    draw show
    htest=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Verify"
      help="Press to verify the limits"
    endc
    hskip=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Skip"
      help="Press to skip limits verification"
    endc
    while 1 do
      if Pressed(htest) then
        break
      else if Pressed(hskip) then
        if hlog!=NULL then
          fprintf(hlog,"Verification of limits is skipped by operator\n")
        endif
        return 0
      else if Pressed(hexit) then
        return -1
      endif
      wait
    enddo
  endif
  // Check whether head controllers support new ports which are better suitable
  // for limit test than oscilloscope.
  diffsupported=1
  for head=0,head<nfing*2,head++ do
    if c[head].ncal==0 continue        // Head is excluded from the calibration
    sprintf(s,"INPORT32 HEAD(%i),0x1000021F",head)
    SERV.Cmdimm(head,s)
  enddo
  t=Time()
  while 1 do
    if Pressed(hexit) return -1
    for head=0,head<nfing*2,head++ do
      if c[head].ncal==0 continue
      if $A[head].length==0 break
    enddo
    if head>=nfing*2 break
    if Time()-t>2000 then
      diffsupported=0; break
    endif
    wait
  enddo
  for head=0,head<nfing*2 && diffsupported!=0,head++ do
    if c[head].ncal==0 continue
    if $A[head].answer!=S_INPORT32 diffsupported=0
    if ($int4($A[head]+5) & 0x80000030)!=0x80000030 diffsupported=0
  enddo
repeat:
  // Just for the case, restore full accelerations.
  if Setaccel(0.0,0.0,0.0,0.0)<0 return -1
  change hinfo text="Verification of limits"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="The script will verify whether points with maximal allowed "
  draw text="individual corrections "
  draw text=format("(%g mm in X and %g mm in Y ",MAXCORRX,MAXCORRY)
  draw text="direction) are physically reachable. This may be not the case if "
  draw text="calibration board was placed with offset."
  draw show
  err=0
  nlimit=0
  Memset(limit,0,Sizeof(limit))
  if hlog!=NULL fprintf(hlog,"Checking that border points are reachable...\n")
  n=0
  // I verify first all left heads, then all right.
  for p=0,p<2 && err==0,p++ do
    if demo then
      delay 500
      continue
    endif
    // 3 coordinates in X direction.
    for i=0,i<3 && err==0,i++ do
      // 3 coordinates in Y direction.
      for j=0,j<3 && err==0,j++ do
        // Middle point is always excluded.
        if i==1 && j==1 continue
        // Right middle point is excluded for the left head.
        if p==0 && i==2 && j==1 continue
        // Left middle point is excluded for the right head.
        if p==1 && i==0 && j==1 continue
        // Leftmost middle point is excluded for the A7 automate because its
        // working area is extended beyond the left stopper.
        if testertype==TT_A7 && $LAY.rightlimit-$LAY.leftlimit>610000 &&       \
          i==0 && j==1 continue
        change hinfo limits=n,14
        n++
        // Calculate coordinates of the test point on the border (xp/yp:
        // preliminary, xt/yt: test, xc/yc: test point corrections) and make
        // full speed movements into the preliminary position. This position
        // is always reachable... I hope...
        for rail=0,rail<nfing && err==0,rail++ do
          head=rail*2+p
          opp=rail*2+(1-p)
          if c[head].ncal==0 continue  // Head is excluded from the calibration
          if i==0 then                 // Left
            xp[head]=$LAY.leftlimit/1000.0+3.0
            xt[head]=$LAY.leftlimit/1000.0
            xc[head]=(j==1?0.002-MAXCORRX:0.0)
            if testertype==TT_A7 && $LAY.rightlimit-$LAY.leftlimit>610000 then
              xp[head]=xp[head]+20.0
              xt[head]=xt[head]+20.0
            endif
          else if i==1 then            // Middle
            xp[head]=$LAY.xoffset/1000.0
            xt[head]=$LAY.xoffset/1000.0
            xc[head]=0.0
          else                         // Right
            xp[head]=$LAY.rightlimit/1000.0-3.0
            xt[head]=$LAY.rightlimit/1000.0
            xc[head]=(j==1?MAXCORRX-0.002:0.0)
          endif
          if j==0 then                 // Bottom
            yp[head]=$LAY.bottom[rail]/1000.0+3.0
            yt[head]=$LAY.bottom[rail]/1000.0
            yc[head]=0.002-MAXCORRY
          else if j==1 then            // Middle
            yp[head]=$LAY.yoffset[rail]/1000.0
            yt[head]=$LAY.yoffset[rail]/1000.0
            yc[head]=0.0
          else                         // Top
            yp[head]=$LAY.top[rail]/1000.0-3.0
            yt[head]=($LAY.top[rail]-1)/1000.0
            yc[head]=MAXCORRY-0.002
          endif
          onlimit[head]=0
          // Heads in A5L are on the limit, don't check too thoroughly.
          if testertype==TT_A5L xc[head]=xc[head]/2.0
          SYS.Killimm(head)
          sprintf(s,"M %i(%g,%gA250H99) %i(Z) NOP",head,xp[head],yp[head],opp)
          SERV.Cmdimm(head,s)
        enddo
        // Wait till preliminary movements are finished.
        t=Time()
        while err==0 do
          for rail=0,rail<nfing,rail++ do
            head=rail*2+p
            if c[head].ncal==0 continue
            if $A[head].length==0 break
          enddo
          if rail>=nfing break         // All answers are here
          if Time()-t>5000 err=1       // Timeout
          if Pressed(hexit) err=-1     // Operator interrupted calibration
          wait
        enddo
        // Request very slow (100 mm/s^2) movements.
        if err==0 && Setaccel(0.1,0.1,0.0,0.0)<0 err=-1
        // The distance to the final point is approximately 6-8 mm. To avoid
        // lost phase messages, I divide it into NLIMSTEP substeps.
        for step=1,step<=NLIMSTEP && err==0,step++ do
          Memset(notreached,0,Sizeof(notreached))
          // Make slow movement to the test point.
          r2=(step*1.0)/NLIMSTEP; r1=1.0-r2
          for rail=0,rail<nfing && err==0,rail++ do
            head=rail*2+p
            if c[head].ncal==0 continue
            if onlimit[head] then
              sprintf(s,"M %i(%g,%gA255H99) NOP",head,xp[head],yp[head])
            else
              sprintf(s,"M %i(%.3f:%g,%.3f:%gA255H99) NOP",head,               \
              xp[head]*r1+xt[head]*r2,xc[head]*r2,                             \
              yp[head]*r1+yt[head]*r2,yc[head]*r2)
            endif
            SERV.Cmdimm(head,s)
          enddo
          // Wait for answer or message that accuracy is not reached. Note: no
          // 'wait' operator in this and following loops.
          t=Time()
          while err==0 do
            for rail=0,rail<nfing,rail++ do
              head=rail*2+p
              if c[head].ncal==0 continue
              if $A[head].length==5 continue
              if notreached[head] then
                onlimit[head]=step
              else
                break
              endif
            enddo
            if rail>=nfing break       // All answers are here
            if Time()-t>5000 err=1     // Timeout
            if Pressed(hexit) err=-1   // Operator interrupted calibration
          enddo
          // Use special ports (available in the new embedded software) or A5
          // oscilloscope (available in all SHARC-based testers) to measure the
          // difference between expected and real X and Y coordinates.
          if diffsupported then
            // Use port I/O. They are faster and are not influenced by stand-
            // alone oscilloscope windows.
            for rail=0,rail<nfing && err==0,rail++ do
              head=rail*2+p
              if c[head].ncal==0 continue
              if onlimit[head] continue
              sprintf(s,"INPORT32 HEAD(%i),0x10000204",head)
              SERV.Cmdimm(head,s)
              sprintf(s,"INPORT32 HEAD(%i),0x10000205",head)
              SERV.Cmdimm(head+1,s)
            enddo
            t=Time()
            while err==0 do
              for head=0,head<nfing*2 && err==0,head++ do
                if c[head].ncal==0 continue
                if onlimit[head] continue
                if $A[head].length==0 break
              enddo
              if head>=nfing*2 break
              if Time()-t>5000 err=1   // Timeout
              if Pressed(hexit) err=-1 // Operator interrupted calibration
            enddo
            for rail=0,rail<nfing && err==0,rail++ do
              head=rail*2+p
              if c[head].ncal==0 continue
              if onlimit[head] continue
              if $A[head].answer!=S_INPORT32 ||                                \
                $A[head+1].answer!=S_INPORT32 then
                err=2
              else if Abs($int4($A[head]+5))>25 ||                             \
                Abs($int4($A[head+1]+5))>25 then
                onlimit[head]=step
              endif
            enddo
          else
            // Use oscilloscope.
            Memset(oscvalid,0,Sizeof(oscvalid))
            for rail=0,rail<nfing && err==0,rail++ do
              head=rail*2+p
              if c[head].ncal==0 continue
              if onlimit[head] continue
              buf[0]=S_TEST
              buf[1]=0x03              // Setup A5 oscilloscope
              buf[2]=head              // Head
              buf[3]=1                 // Trigger: start immediately
              $uint2(buf+4)=1          // Compression: none
              $uint2(buf+6)=NOSCDATA   // Count
              buf[8]=1                 // Current X coordinate
              buf[9]=4                 // Expected X coordinate
              buf[10]=2                // Current Y coordinate
              buf[11]=5                // Expected Y coordinate
              SYS.Sendimm(head,12,buf)
            enddo
            // Wait for answers.
            t=Time()
            while err==0 do
              for rail=0,rail<nfing,rail++ do
                head=rail*2+p
                if c[head].ncal==0 continue
                if $A[head].length>0 continue
                if onlimit[head]==0 break
              enddo
              if rail>=nfing break     // All answers are here
              if Time()-t>5000 err=1   // Timeout
              if Pressed(hexit) err=-1 // Operator interrupted calibration
            enddo
            // Now wait for oscillogramms.
            while err==0 do
              for rail=0,rail<nfing,rail++ do
                head=rail*2+p
                if c[head].ncal==0 continue
                if onlimit[head] continue
                for k=0,k<4,k++ do
                  if oscvalid[head][k]==0 break
                enddo
                if k<4 break
                if Abs(oscmean[head][0]-oscmean[head][1])>25.0 ||              \
                  Abs(oscmean[head][2]-oscmean[head][3])>25.0 then
                  onlimit[head]=step
                endif
              enddo
              if rail>=nfing break     // All answers are here
              if Time()-t>5000 err=2   // Timeout
              if Pressed(hexit) err=-1 // Operator interrupted calibration
            enddo
          endif
        enddo
        // Move back to the preliminary position.
        for rail=0,rail<nfing && err==0,rail++ do
          head=rail*2+p
          opp=rail*2+(1-p)
          if c[head].ncal==0 continue  // Head is excluded from the calibration
          sprintf(s,"M %i(%g,%gA255H99) %i(Z) NOP",head,xp[head],yp[head],opp)
          SERV.Cmdimm(head,s)
        enddo
        // Wait till movements are finished.
        t=Time()
        while err==0 do
          for rail=0,rail<nfing,rail++ do
            head=rail*2+p
            if c[head].ncal==0 continue
            if $A[head].length==0 break
          enddo
          if rail>=nfing break         // All answers are here
          if Time()-t>5000 err=1       // Timeout
          if Pressed(hexit) err=-1     // Operator interrupted calibration
          wait
        enddo
        // Restore full speed movements.
        if Setaccel(0.0,0.0,0.0,0.0)<0 err=-1
        // If this is the last movement for the finger, move it away from the
        // opposite head. Note that I move only one finger.
        if i==2 && j==2 then
          for rail=0,rail<nfing && err==0,rail++ do
            head=rail*2+p
            if c[head].ncal==0 continue
            sprintf(s,"M %i(Z) NOP",head)
            SERV.Cmdimm(head,s)
          enddo
          t=Time()
          while err==0 do
            for rail=0,rail<nfing,rail++ do
              head=rail*2+p
              if c[head].ncal==0 continue
              if $A[head].length==0 break
            enddo
            if rail>=nfing break       // All answers are here
            if Time()-t>5000 err=1     // Timeout
            if Pressed(hexit) err=-1   // Operator interrupted calibration
            wait
          enddo
        endif
        for rail=0,rail<nfing,rail++ do
          head=rail*2+p
          if c[head].ncal==0 continue
          if limit[head][j]==0 then
            limit[head][j]=onlimit[head]
          else if onlimit[head]!=0 then
            limit[head][j]=Min(limit[head][j],onlimit[head])
          endif
          if onlimit[head] nlimit++
        enddo
      enddo
    enddo
    // For security, make soft reset.
    SYS.Killimm(32)
    SYS.Softimm(32)
    t=Time()
    while err==0 do
      if $A[32].length!=0 break
      if Time()-t>10000 err=1          // Timeout
      if Pressed(hexit) err=-1         // Operator interrupted calibration
      wait
    enddo
  enddo
  if err<0 return -1                   // Operator interrupted calibration
  if err==0 && nlimit==0 then
    if hlog!=NULL fprintf(hlog,"  No problems detected\n")
    if calmode==MODE_CAL return 0      // Full success
  endif
  // Report errors.
  clear hright
  change hinfo limits=0,0
  if nlimit==0 && (err==1 || err==2) then
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if hlog!=NULL fprintf(hlog,"  Timeout while waiting for answer\n")
    change hinfo text="Timeout!"
    draw text="Unable to check limits!"
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from the tester within the expected "
      draw text="timeout. "
    else if err==2 then
      draw text="Script received unexpected answer from the tester. "
    else
      draw text="Script was unable to measure head coordinate. If "
      draw text="oscilloscope is running, please close it. "
    endif
    draw text="Press " font=MAINFONT text="Repeat " font=TIMESFONT
    draw text="to repeat test, or " font=MAINFONT
    draw text=(calmode==MODE_CAL?"Continue ":"Finish ")
    draw font=TIMESFONT text="to accept this fact."
    draw show
  else
    if calmode==MODE_CAL || nlimit!=0 then
      htable=control CHILD
        window=hright
        position=9,115,RIGHTX-18,155
        limits=RIGHTX-50,2*nfing*20+38
        mode=M_VSCROLL
        help="List of unreachable points"
        bkcolor=PINK
        size=4096
      endc
    else
      htable=control CHILD
        window=hright
        position=9,50,RIGHTX-18,215
        limits=RIGHTX-50,2*nfing*20+38
        mode=M_VSCROLL
        help="List of unreachable points"
        bkcolor=PINK
        size=4096
      endc
    endif
    k=30
    draw window=htable font=INFOFONT color=DARKGRAY mode=M_CENTERED
    draw at 5,5 to 225,5
    draw at 5,5 to 5,32 at 25,26 text="Head"
    draw at 45,5 to 45,32 at 75,26 text="Bottom Y"
    draw at 105,5 to 105,32 at 135,26 text="X"
    draw at 165,5 to 165,32 at 195,26 text="Top Y"
    draw at 225,5 to 225,33
    draw at 5,32 to 225,32
    draw font=FIXEDSYS
    isneg=0
    for head=0,head<nfing*2,head++ do
      if c[head].ncal==0 continue
      k=k+20
      draw color=DARKGRAY
      draw at 5,k-18 to 5,k+2 to 225,k+2 to 225,k-18
      draw at 45,k-18 to 45,k+2
      draw at 105,k-18 to 105,k+2
      draw at 165,k-18 to 165,k+2
      draw at 25,k color=BLACK
      draw text=format("%2i%c",head/2,(head & 1)==0?'L':'R')
      if hlog!=NULL fprintf(hlog,"  Head %2i%c: ",head/2,(head & 1)==0?'L':'R')
      for j=0,j<3,j++ do
        if hlog!=NULL then
          if j==0 fprintf(hlog," Bottom=")
          if j==1 fprintf(hlog," X=")
          if j==2 fprintf(hlog," Top=")
        endif
        draw at 75+j*60,k
        if limit[head][j]==0 then
          if hlog!=NULL fprintf(hlog,"OK   ")
          draw color=DARKGRAY text="OK"
        else
          r2=(limit[head][j]*1.0)/NLIMSTEP; r1=1.0-r2
          if j==0 || j==2 then
            delta=MAXCORRY*r2-3.0*r1
          else if testertype==TT_A5L then
            delta=MAXCORRY/2.0*r2-3.0*r1
          else
            delta=MAXCORRY*r2-3.0*r1
          endif
          if delta<=(-0.1) isneg=1
          if hlog!=NULL fprintf(hlog,"%4.1f mm",delta)
          draw color=LIGHTRED text=format("%.1f mm",delta)
        endif
      enddo
      if hlog!=NULL fprintf(hlog,"\n")
    enddo
    draw show
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if nlimit!=0 then
      if hlog!=NULL fprintf(hlog,"  Some points are not reachable:\n")
      change hinfo text="Unreachable points!"
      draw text="Some points are not reachable! "
      if isneg==0 draw at 6,60
      draw color=BLACK
      if calmode==MODE_CAL then
        draw text="Please consult the table below and decide whether you "
        draw text="want to shift board and recalibrate."
        if isneg==0 then
          draw text="Unreachable limits don't influence the accuracy."
        endif
      else
        draw text="Please consult the table below and determine which heads "
        draw text="are unable to reach extended limits of the working area."
      endif
      if isneg then
        draw color=LIGHTRED 
        draw text=" Note: negative values mean that even the 'official' "
        draw text="limits are out of reach!"
      endif
    else
      change hinfo text="All limits are reachable"
      draw color=BLACK
      draw text="Test finished. All limits are reachable:"
    endif
    draw show
    setfocus htable
  endif
  hrepeat=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+10,120,24
    name="Repeat"
    help=(nlimit==0?"Press to repeat test":"Press to repeat calibration")
  endc
  if calmode==MODE_CAL then
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Continue"
      help="Press to continue calibration"
    endc
  else
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+10,120,24
      name="Finish"
      help="Press to finish verification"
    endc
  endif
  while 1 do
    if Pressed(hrepeat) then
      if nlimit==0 goto repeat
      return 2
    else if Pressed(hcont) then
      break
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
  return 0
end

// Warns operator that layout and/or corrections are not loaded or don't match
// each other.
function int Warnoperator()
  int i
  handle hcont,hboot,hcorr
  if layvalid && corrvalid && diskvalid then
    return 0                           // Tester is in defined state
  endif
  clear hleft
  Drawtesterview()
  change hinfo text="Undefined tester state!"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text="Attention, tester is not ready for test!"
  draw at 6,60 color=BLACK
  draw text="Calibration script is about to quit, but "
  if diskvalid==0 then
    draw text="layout and corrections on the disk do not match each other. "
    draw text="Either repeat calibration, or restore layout and corrections "
    draw text="from backup and reload tester!"
    hcont=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="Oops..."
      help="Press to finish the calibration"
    endc
  else if layvalid then
    draw text="corrections are not loaded to the tester. Do you want to "
    draw text="reload them right now?"
    hcorr=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Reload now"
      help="Press to reload corrections"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Close"
      help="Press to finish the calibration"
    endc
  else
    draw text="layout loaded to tester does not match layout on the disk. "
    draw text="Please reboot tester!"
    hboot=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Reboot now"
      help="Press to make Hard reset, finish calibration and start Loader"
    endc
    hcont=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Close"
      help="Press to finish the calibration"
    endc
  endif
  draw show
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hcont) then
      return 0
    else if Pressed(hcorr) then
      i=Readoldcorr(0)
      if i!=0 return i
      return Loadcorr(-1,0,1)
    else if Pressed(hboot) then
      SYS.Broadcast(11,"HARD RESET")   // Inform others to stop activity
      SYS.Hardimm(0)                   // Hard reset
      change hinfo text="Hard reset..."
      clear hright
      hcont=control BUTTON
        window=hright
        position=(RIGHTX-120)/2,USERY,120,24
        name="Finish"
        help="Press to finish the calibration"
      endc
      while $A[0].length==0 do
        if Pressed(hexit) return -1
        if Pressed(hcont) break
        wait
      enddo
      SYS.Start("LOADER",0,"")
      return 0
    endif
    wait
  enddo
end

// Unloads board from the shuttle. Used in the case of L&M automation. Returns
// -1 if user interrupted the script and 0 in any other case.
function int Unloadboard()
  int i,j,glass,t
  char buf[256],errtxt[256]
  if demo!=0 || (($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                       \
    ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO) then
    return 0                           // Does not apply
  endif
  // Check whether there is a board in the shuttle. It may happen that previous
  // test was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  if $A[32].answer==S_INPORT && ($A[32].inport & 0x35)==0 then
//    return 0                           // Shuttle is empty
  endif
  Drawcalboard(0,0,0,0)                // Show calibration board in shuttle
  // Make soft reset before sending commands to automation directly: heads may
  // still move!
  clear hright
  change hinfo limits=0,0
  change hinfo text="Soft reset"
  SYS.Softimm(32)
  t=Time(); i=0
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format(" - %i s",j)
      i=j
    endif
    if j>15 return 0                   // Too long soft reset
    wait
  enddo
  change hinfo limits=0,0
  change hinfo text="Unloading calibration board..."
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Calibration board will be unloaded. To avoid damages, please "
  draw text=format("remove it from the %s.",boardtype==0?"band":"shuttle")
  draw show
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO &&           \
    pulledshuttle>=0                                                           \
  then
    sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i",pulledshuttle)
    i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
    if i<0 return -1
    pulledshuttle=-1
  endif
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                   \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO) &&                                \
    ((boardtype==1 && (testertype==TT_A7 || smallboard!=0)) || boardtype==2)   \
  then
    if isglassboard then
      i=Sendlmcommand("MECH.Para.IsGlassBoard=0","",errtxt,5)
      isglassboard=0
    endif
  else
    // For the case that tester is for some reason in the adjustment mode. May
    // be too dangerous when handling glass.
    i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,5)
  endif
  if i<0 return -1
  SYS.Killimm(32)
  buf[0]=S_LOCKDOOR
  buf[1]=0                             // Unlock door
  SYS.Sendimm(32,2,buf)
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  return 0
end

// Warns user about unloading board from the shuttle. Used in the case of EPCOS
// tester. Returns -1 if user interrupted the script and 0 in any other case.
function int UnloadboardEPCOS()
  handle hok
  if ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO then
    return 0                           // Does not apply
  endif
  change hinfo limits=0,0
  change hinfo text="Please remove holder!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please don't forget to remove calibration board and its holder "
  draw text="from the shuttle. " color=LIGHTRED text="Attempt to unlock table "
  draw text="when holder is installed may seriously damage the tester!"
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="OK"
    help="Press to continue"
  endc
  while 1 do
    if Pressed(hexit) return -1        // Interrupt
    if Pressed(hok) break
    wait
  enddo
  return 0
end

// Asks operator if he wants to run C adjustment with the calibration board.
// Returns 0 if no, 1 if yes and -1 if operator interrupted the calibration.
function int Confirmcadjust()
  handle hadjust,hskip
  clear hleft
  Drawcalboard(0,0,0,DR_HEAD)
  change hinfo text="Capacity adjustment"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Would you like to adjust the input capacities of the on-head "
  draw text="boards? Please note that such adjustment is not as precise as "
  draw text="with the dedicated board (EL337) and doesn't include MSD "
  draw text="alignment, but is sufficient for all kinds of PCBs."
  draw show
  hadjust=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Adjust"
    help="Press to adjust input capacities"
  endc
  hskip=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Skip"
    help="Press to omit capacity adjustment"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hadjust) then
      return 1
    else if Pressed(hskip) then
      return 0
    endif
    wait
  enddo
end

// Scans central crosses on the calibration board to find position of the C
// adjustment pads. Returns 0 on success, 1 if crosses are not found, 2 if
// actual options are invalid or contradictory and -1 if operator interrupted
// the calibration.
function int Headcamscancadjust()
  int i,err,nfing,ntop,toplist,nbot,botlist,x,y,dx
  float sn,sx,sy,sxx,sxy,det
  handle hview,hlivevideo,htext,hrotate,hselect[34],hok
  if headcams==0 err=2                 // Works only with head cameras
  if calmode!=MODE_CADJ err=2
  if err!=0 goto error
  nfing=$LAY.nfing
  change hinfo limits=0,0
  change hinfo text="Scanning board..."
  if hlog!=NULL fprintf(hlog,"Scanning board for capacity adjustment...\n")
  i=Fillcalibrators(C_CENTER,FILL_HCAM)
  if i<0 return i                      // Operator interrupted calibration
  if i>0 err=2                         // Error in parameters (impossible!)
  if err!=0 goto error
  clear hleft
  hview=control CHILD                  // Create video viewer
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    help="Video viewer"
    bkcolor=VIDEOFILL
  endc
  draw color=LIGHTRED at (LEFTX-10)/2-20,144 to (LEFTX-10)/2-5,144
  draw color=LIGHTRED at (LEFTX-10)/2+20,144 to (LEFTX-10)/2+5,144
  draw color=LIGHTRED at (LEFTX-10)/2,144-20 to (LEFTX-10)/2,144-5
  draw color=LIGHTRED at (LEFTX-10)/2,144+20 to (LEFTX-10)/2,144+5
  draw show
  htext=control TEXT
    window=hview
    position=2,296,LEFTX-4,22
    help="Currently selected head camera"
    bkcolor=LIGHTYELLOW
    color=BLACK
    font=MEDIUMFONT
    mode=M_CENTERED
  endc
  hrotate=control CUSTOMBOX
    window=hview
    position=24,330,LEFTX-48,20
    text="Rotate live video according to head position"
    help="Check to rotate picture to tester X-Y coordinates"
    font=INFOFONT
    mode=(rotateimage?M_CHECKED:0)
  endc
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Calibration script scans central crosses on the board in order "
  draw text="to find locations of the capacity adjustment pads."
  draw show
  // Create camera selection buttons.
  ntop=0; toplist=0; nbot=0; botlist=0
  for i=0,i<nfing*2,i++ do
    if (headcams & (1<<i))==0 continue // No camera on the head
    if $LAY.side[i/2]==0 then
      toplist=toplist | (1<<i)
      ntop++
    else
      botlist=botlist | (1<<i)
      nbot++
    endif
  enddo
  dx=(RIGHTX-15)/Max(ntop,nbot)-5
  if dx>50 dx=50
  y=(ntop!=0 && nbot!=0?198:208)
  if ntop>0 then
    x=(RIGHTX-(dx+5)*ntop+5)/2
    for i=0,i<nfing*2,i++ do
      if (toplist & (1<<i))==0 continue
      hselect[i]=control BUTTON
        window=hright
        position=x,y,dx,22
        name=format("%i%c",i/2,i & 1?'R':'L')
        help=format("Press to inspect head camera %i%c",i/2,i & 1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      x=x+dx+5
    enddo
    y=y+25
  endif
  if nbot>0 then
    x=(RIGHTX-(dx+5)*nbot+5)/2
    for i=0,i<nfing*2,i++ do
      if (botlist & (1<<i))==0 continue
      hselect[i]=control BUTTON
        window=hright
        position=x,y,dx,22
        name=format("%i%c",i/2,i & 1?'R':'L')
        help=format("Press to inspect head camera %i%c",i/2,i & 1?'R':'L')
        color=BLACK
        bkcolor=GRAY
      endc
      x=x+dx+5
    enddo
    y=y+25
  endif
  if ntop+nbot>0 then
    dx=Max(100,2*dx+5)
    hselect[32]=control BUTTON
      window=hright
      position=(RIGHTX-dx)/2,y,dx,22
      name="Show all"
      help="Press to view live video from ALL cameras"
      color=BLACK
      bkcolor=GRAY
    endc
  endif
  i=Runheadcamscan(NULL,NULL,NULL,hview,hlivevideo,htext,hrotate,hselect,-1,500)
  if i<0 return -1                     // Operator interrupted calibration
  if i==0 then
    // Interpolate center coordinates using linear regression, as a function of
    // the expected Y pad coordinate. The resulting accuracy is sufficient for
    // our needs. First I interpolate X coordinates.
    sn=0; sx=0; sy=0; sxx=0; sxy=0; sxy=0
    for i=0,i<nfing,i++ do
      if c[i].ncal==0 || c[i].err[0]!=0 continue
      sn=sn+1.0
      sx=sx+c[i].ya[0]; sy=sy+c[i].xm[0]
      sxx=sxx+c[i].ya[0]*c[i].ya[0]; sxy=sxy+c[i].ya[0]*c[i].xm[0]
    enddo
    det=sx*sx-sn*sxx
    if det==0.0 then
      err=1
    else
      cadjax=(sx*sy-sn*sxy)/det
      cadjbx=(sx*sxy-sxx*sy)/det
    endif
    // Then I interpolate the Y coordinate.
    sn=0; sx=0; sy=0; sxx=0; sxy=0; sxy=0
    for i=0,i<nfing,i++ do
      if c[i].ncal==0 || c[i].err[0]!=0 continue
      sn=sn+1.0
      sx=sx+c[i].ya[0]; sy=sy+c[i].ym[0]
      sxx=sxx+c[i].ya[0]*c[i].ya[0]; sxy=sxy+c[i].ya[0]*c[i].ym[0]
    enddo
    det=sx*sx-sn*sxx
    if det==0.0 then
      err=1
    else
      cadjay=(sx*sy-sn*sxy)/det
      cadjby=(sx*sxy-sxx*sy)/det
    endif
  endif
  if err==0 return 0                   // Success
error:
  // Report error.
  change hinfo limits=0,0
  change hinfo text="Scanning problem"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Unable to scan calibration board!"
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    draw text="Number of recognized crosses is not sufficient to determine "
    draw text="the position of the capacity adjustment points. Please try to "
    draw text="reposition the calibration board in the shuttle."
  else if err==2 then
    draw text="Conflicting parameters!"
    draw at 6,60 wrap=RIGHTX-5 color=BLACK
    draw text="This situation is completely unexpected. It looks like "
    draw text="internal error in the calibration script. Try to select "
    draw text="different parameters; if this does not help, please contact "
    draw text="atg."
  endif
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="OK"
    help="Press to retry"
  endc
  while 1 do
    if Pressed(hok) return err
    if Pressed(hexit) return -1      // Quit calibration
    wait
  enddo
end

// Adjsuts on-head capacities using special pads on the A6 FR4 calibration
// board. Returns 0 on success, 1 if adjustment was unsuccessful, 2 if operator
// pressed Cancel and -1 if operator interrupted the calibration. Attention,
// will fail if bottom rails do not coincide with top!
function int Makecadjust(int stopatlimit)
  int i,j,k,m,n,t,u,ly,nfing,allowz,err,dx,ypos,ndispl,ystep,delta
  int ant,gnd1,gnd2,base,head,maxsin,good,recalibrate,firstmove
  int psminhead,psmaxhead,pcminhead,pcmaxhead
  int fixed[32],valid[8]
  float x,y,xa,ya,xg,yg,xt,yt,xu,yu,groupx,groupy,deltax,deltay
  float p,q,r,ss,smin,smax,cs,cmin,cmax,zc,zr,psmin,psmax,pcmin,pcmax
  float ps[32],pc[32],fstat[8][5],cstat[8][5],fs[8],fc[8],cc[8]
  char s[256]
  handle hgraph,herr,hmsg,hcancel,hcont
  nfing=$LAY.nfing
  change hinfo limits=0,0
  change hinfo text="Input capacity adjustment"
  hgraph=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="Results of input capacity adjustment"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  herr=control TEXT
    window=hgraph
    position=5,LEFTY-122,LEFTX-10,40
    color=RED
    font=MEDIUMFONT
    mode=M_CENTERED
  endc
  hmsg=control TEXT
    window=hgraph
    position=5,LEFTY-77,LEFTX-10,20
    color=RED
    font=MEDIUMFONT
    mode=M_CENTERED
  endc
  change hleft position=-1000,*,*,*
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  if hlog!=NULL then
    fprintf(hlog,"\nAdjusting input capacities of on-head boards...\n")
  endif
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) && ($LAY.config & 0x800)!=0        \
  then
    allowz=1
  else
    allowz=0
  endif
  draw text="Now adjusting input capacities of on-head boards. The goal is "
  draw text="to reduce "
  if allowz then
    draw text="sine and cosine differences "
  else
    draw text="sine difference "
  endif
  draw text="between any two heads to not more than "
  draw text=format("%i ADC bits. Please wait...",DADJLIMIT)
  hcancel=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Cancel"
    help="Press to interrupt input capacity adjustment"
  endc
  ly=100
  // Create legend at Y coordinate ly.
  draw color=BLACK bkcolor=BLACK at 63,ly fillrect 88,ly+17
  draw at 68,ly+16 font=TIMESFONT color=WHITE text="0L"
  draw color=PINK bkcolor=PINK at 63,ly+21 fillrect 88,ly+21+17
  draw color=LIGHTGRAY at 63,ly+42 rect 88,ly+42+17
  draw at 68,ly+58 font=TIMESFONT color=LIGHTRED text="99"
  draw color=LIGHTGRAY at 63,ly+63 rect 88,ly+63+17
  draw at 65,ly+79 font=TIMESFONT color=LIGHTBLUE text="-99"
  draw color=BLACK at 63,ly+84 rect 88,ly+84+17
  draw at 67,ly+100 font=TIMESFONT color=BLACK text=format("%.1f",DADJLIMIT*0.7)
  draw color=BLACK font=INFOFONT
  draw at 8,ly+16  text="Legend:"
  draw at 93,ly+16  text="- last measured field"
  draw at 93,ly+37  text="- invalid or unstable field"
  draw at 93,ly+58  text="- field is too high"
  draw at 93,ly+79  text="- field is too low"
  draw at 93,ly+100 text="- maximal sine deviation"
  draw show
  err=0; ant=0
  for k=0,k<nfing*2,k++ do             // For all heads
    ps[k]=256.0                        // Initial sine potentiometer setting
    pc[k]=256.0                        // Initial cosine potentiometer setting
    fixed[k]=0
  enddo
  // We need the positions of the reference pads and excluded rails.
  Fillcalibrators(C_CENTER,FILL_MECH)
  deltax=Random(DELTA)-DELTA/2.0
  deltay=Random(DELTA)-DELTA/2.0
restart:
  clear herr
  if lasttop-firsttop>2 then
    base=(firsttop+1)*2
  else
    base=firsttop*2
  endif
  recalibrate=0
  // Main loop.
nextbase:
  for head=0,head<8,head++ do
    valid[head]=0                      // 0: excluded, 1: valid, <0: invalid
    // Clear statistical data.
    Initsigma(fstat[head])
    Initsigma(cstat[head])
  enddo
  good=0
  firstmove=1
  while err==0 do
    // Write new data to Dallas potentiometers. Note: changes extended layout!
    for k=0,k<nfing*2,k++ do
      sprintf(s,"OUTPORT %i,%i",0x80E0+(k/2)*0x0100+(k & 1)*0x0002,ps[k])
      SERV.Cmdimm(32,s)              // No need to wait for answer
      if allowz then
        sprintf(s,"OUTPORT %i,%i",0x80E4+(k/2)*0x0100+(k & 1)*0x0002,pc[k])
        SERV.Cmdimm(32,s)
      endif
    enddo
    // This cycle measures input capacities of group of 8 heads (4 for single-
    // sided or handicapped tester) on the same C-adjust pad.
    y=$LAY.top[base/2]/1000.0
    groupx=cadjax*y+cadjbx-37.5
    groupy=cadjay*y+cadjby
    for head=0,head<8 && err==0,head++ do
      if Pressed(hcancel) then
        change hleft position=4,4,LEFTX,LEFTY
        destroy hgraph
        return 2
      endif
      // K is the ID of head to test.
      if head<4 then
        k=base+head                    // Top (or, in general, first) side
      else if testersides!=0x3 then
        continue                       // Single-sided tester
      else
        k=base+nfing+(head-4)          // Opposite side
      endif
      if c[k].ncal==0 continue         // Head is excluded from test
      // Decide which heads serves this time as antennae. Signal comes from
      // the first head in the group from the opposite side. Ground antennas
      // are the right heads on the first free rail or, if unavailable, the
      // single head in the group that follows signal antenna.
      if head<4 then
        ant=base+nfing                 // In group on the opposite (bot) side
      else
        ant=base                       // In group on the same side
      endif
      gnd1=-1; gnd2=-1
      for i=1,i<nfing,i=i+2 do
        if c[i].ncal==0                                                        \
          continue                     // Rail excluded from the calibration
        if (i>=base && i<base+4)                                               \
          continue                     // Head belongs to the set being tested
        gnd1=i
        gnd2=i+nfing
        break
      enddo
      if gnd1<0 then
        gnd1=ant+1
        gnd2=ant+1
      endif
      // Move heads in requested positions.
      for i=0,i<nfing*2 && err==0,i++ do
        if c[i].ncal==0 continue
        if i==k then                   // Head under test
          x=groupx
          y=groupy
          sprintf(s,"M %i[%g,%gH50V%iP%i] NOP",i,x,y,v,p)
        else if i==ant then            // Antenna finger
          xa=groupx
          ya=groupy
          sprintf(s,"M %i[%g,%gH50V%iP%i] NOP",i,xa,ya,v,p)
        else if i==gnd1 || i==gnd2 then// Ground fingers
          xg=c[i].refx0
          yg=c[i].refy0
          sprintf(s,"M %i[%g,%gH50V%iP%i] NOP",i,xg,yg,v,p)
        else if (i>=base && i<base+4) || (i>=base+nfing && i<base+nfing+4) then
          // Head belongs to the set being tested.
          if (i & 1)==0 then
            xt=groupx-3.0
          else
            xt=groupx+3.0
          endif
          if (i>=base && i<base+2) || (i>=base+nfing && i<base+nfing+2) then
            yt=groupy-3.0
          else
            yt=groupy+3.0
          endif
          if firstmove then
            sprintf(s,"M %i[%g,%gH50V%iP%i] NOP",i,xt,yt,v,p)
          else
            sprintf(s,"M %i[%g,%gV%iP%i] NOP",i,xt,yt,v,p)
          endif
        else if (i & 1)==0 then        // Any remaining left head
          xt=groupx-25.0
          yt=$LAY.yoffset[i/2]/1000.0
          sprintf(s,"M %i[%g,%gH50V%iP%i] NOP",i,xt,yt,v,p)
        else                           // Any remaining right head
          xt=groupx+25.0
          yt=$LAY.yoffset[i/2]/1000.0
          sprintf(s,"M %i[%g,%gH50V%iP%i] NOP",i,xt,yt,v,p)
        endif
        if err!=0 break
        if SERV.Cmdimm(i,s)<0 err=2    // Send command
      enddo
      firstmove=0
      // Wait till all heads reached requested positions.
      t=Time()
      for i=0,i<nfing*2 && err==0,i++ do
        if c[i].ncal==0 continue
        while err==0 do
          if Time()-t>10000 err=1
          if Pressed(hexit) err=-1
          if $A[i].length!=0 break
          wait
        enddo
        if (err==0 && $A[i].answer!=S_NOP) err=3
      enddo
      // Field measurement. To reach stable measurements, I repeat field up to
      // 3 times and ignore first 4 fields from ant in every measurement.
      j=sprintf(s,"M %i[%g:%g,%g:%gH50V%iP%i] %i[%g,%gH50V%iP%i] ",            \
        k,x,deltax,y,deltay,v,p,gnd1,xg,yg,v,p)
      j=j+sprintf(s+j,"%i[%g,%gH50V%iP%i] %i[%g,%gH50V%iP%i]",                 \
        gnd2,xg,yg,v,p,ant,xa,ya,v,p)
      j=j+sprintf(s+j,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",                   \
        k,gnd1,gnd2,ant,ant,ant,ant,ant,ant,ant,ant)
      j=j+sprintf(s+j,"%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",      \
        ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant,ant)
      sprintf(s+j,"%i,%i,%i,%i)",ant,ant,ant,ant) // Total of 28*ant
      for m=0,m<3 && err==0,m++ do
        if SERV.Cmdimm(0,s)<0 err=2    // Send command
        t=Time()                       // Wait for answer
        while err==0 do
          if Time()-t>10000 err=1
          if Pressed(hexit) err=-1
          if $A[0].length!=0 break
          wait
        enddo
        if (err==0 && ($A[0].answer!=S_MOVE || $A[0].subansw!=S_FIELD)) err=3
        if err!=0 break
        ss=0.0; smin=9e99; smax=-9e99
        cs=0.0; cmin=9e99; cmax=-9e99
        for j=0,j<24,j++ do
          ss=ss+$int2($A[0]+52+4*j)
          smin=Min(smin,$int2($A[0]+52+4*j))
          smax=Max(smax,$int2($A[0]+52+4*j))
          cs=cs+$int2($A[0]+54+4*j)
          cmin=Min(cmin,$int2($A[0]+54+4*j))
          cmax=Max(cmax,$int2($A[0]+54+4*j))
        enddo
        fs[head]=ss/24.0
        fc[head]=cs/24.0
        SERV.Convertfield($A[0],&zc,&zr)
        cc[head]=zc;
        Addsigma(cstat[head],zc)
        if smax-smin>=FNOISE || cmax-cmin>=FNOISE then
          valid[head]=-1               // High noise
        else if smin<SINMIN || smax>SINMAX then
          valid[head]=-2               // Invalid sine amplitude
        else if cmin<COSMIN || cmax>COSMAX then
          valid[head]=-3               // Invalid cosine amplitude
        else
          valid[head]=1
        endif
        // Start updating graph window.
        draw window=hgraph color=BLACK bkcolor=WHITE clear
        // Display set of rails used on current step.
        draw at LEFTX/2,LEFTY-40 mode=M_CENTERED font=TIMESFONT
        draw text=format("Testing rails: %i, %i, %i and %i",                   \
          base/2,base/2+1,(base+nfing)/2,(base+nfing)/2+1)
        // Calculate mean sine and cosine. To reduce influence of random faults,
        // I exclude highest sine deviation.
        ss=0.0; cs=0.0; n=0
        for i=0,i<8,i++ do
          if valid[i]==0 continue
          ss=ss+fs[i]; cs=cs+fc[i]; n++
        enddo
        maxsin=-1
        if n>0 then
          ss=ss/n; cs=cs/n             // Mean sine and cosine
          r=0.0
          for i=0,i<8,i++ do
            if valid[i]==0 continue    // Head is absent or excluded
            if Abs(fs[i]-ss)>r then
              maxsin=i                 // Head with highest deviation from mean
              r=Abs(fs[i]-ss)
            endif
          enddo
          if n>=4 then
            ss=0.0; cs=0.0; n=0
            for i=0,i<8,i++ do
              if valid[i]==0 continue
              if i==maxsin continue
              ss=ss+fs[i]; cs=cs+fc[i]; n++
            enddo
            ss=ss/n; cs=cs/n
          endif
        endif
        if n>0 then
          draw at LEFTX/2,LEFTY-15 mode=M_CENTERED font=TIMESFONT
          draw text=format("Mean sine: %.1f, cosine: %.1f bits",ss,cs)
        endif
        // Display field differences.
        draw window=hgraph color=BLACK mode=M_CENTERED font=MEDIUMFONT
        draw at LEFTX/2,30 text="Field differences"
        draw mode=M_LEFT font=SMALLFONT color=DARKGRAY
        dx=LEFTX/2+11
        for j=0,j<2,j++ do
          draw at 4+dx*j,63 text="Hd"
          draw mode=M_RIGHT
          draw at 62+dx*j,63 text="Sine"
          draw at 105+dx*j,63 text="Cosine"
          draw mode=M_LEFT
          draw at 119+dx*j,63 text="Pot"
        enddo
        ndispl=0
        ystep=(allowz?27:22)
        for i=0,i<8,i++ do
          draw font=TIMESFONT
          if i<4 then
            k=base+i                   // Top (or, in general, first) side
            delta=0
          else
            k=base+nfing+(i-4)         // Opposite side
            delta=20
          endif
          if c[k].ncal==0 continue     // Head is excluded from test
          ypos=90+ystep*(ndispl/2)+delta
          j=i & 1
          if i==head then
            draw color=BLACK bkcolor=BLACK at 2+dx*j,ypos-16
            draw fillrect 22+dx*j,ypos+1
            draw color=WHITE
          else
            draw color=WHITE bkcolor=WHITE at 2+dx*j,ypos-16
            draw fillrect 22+dx*j,ypos+1
            draw color=DARKGRAY
          endif
          draw at 4+dx*j,ypos text=format("%i%c",k/2,(i& 1?'R':'L'))
          if valid[i]!=0 then
            if maxsin==i then
              draw color=BLACK bkcolor=(valid[i]<0?PINK:WHITE)
            else if valid[i]<0 then
              draw color=PINK bkcolor=PINK
            else
              draw color=WHITE bkcolor=WHITE
            endif
            draw mode=M_RIGHT
            draw at 24+dx*j,ypos-16 fillrect 115+dx*j,ypos+1
            if fs[i]-ss<(-DADJLIMIT*0.7) then
              draw color=LIGHTBLUE
            else if fs[i]-ss>DADJLIMIT*0.7 then
              draw color=LIGHTRED
            else
              draw color=BLACK
            endif
            draw at 62+dx*j,ypos text=format("%.1f",fs[i]-ss)
            if fc[i]-cs<(-DADJLIMIT*0.7) then
              draw color=LIGHTBLUE
            else if fc[i]-cs>DADJLIMIT*0.7 then
              draw color=LIGHTRED
            else
              draw color=BLACK
            endif
            draw at 105+dx*j,ypos text=format("%.1f",fc[i]-cs)
            draw mode=M_LEFT
            draw color=(fixed[k]?DARKGRAY:BLACK)
            if allowz==0 then
              draw at 117+dx*j,ypos text=format("%.0f",ps[k])
            else
              draw font=SMALLFONT
              draw at 119+dx*j,ypos-7 text=format("%.0f",ps[k])
              draw at 119+dx*j,ypos+5 text=format("%.0f",pc[k])
            endif
          endif
          ndispl++
        enddo
        draw show
        if valid[head]==1 break        // Stable valid measurement, accept it
      enddo
      if err!=0 break
    enddo
    // The full cycle of measurements is finished. Add field deviations to
    // statistic.
    ss=0.0; cs=0.0; n=0; j=0; u=0
    for i=0,i<8,i++ do
      if valid[i]==0 continue
      if i<4 then
        k=base+i                       // Top (or, in general, first) side
      else
        k=base+nfing+(i-4)             // Opposite side
      endif
      if stopatlimit &&                                                        \
        (ps[k]<2.0 || ps[k]>509.0 || pc[k]<2.0 || pc[k]>509.0) then
        continue                       // At limit, exclude from mean
      endif
      ss=ss+fs[i]; cs=cs+fc[i]; n++
      if valid[i]<=0 then
        if hlog!=NULL fprintf(hlog,"  %i%c: ",k/2,k & 1?'R':'L')
        if valid[i]==(-1) then
          fprintf(hlog,"High noise\n")
        else if valid[i]==(-2) then
          fprintf(hlog,"Invalid sine field component\n")
        else if valid[i]==(-3) then
          fprintf(hlog,"Invalid cosine field component\n")
        else
          fprintf(hlog,"Invalid field\n")
        endif
        j=1
      endif
      if cc[i]<CMIN || cc[i]>CMAX then
        if hlog!=NULL fprintf(hlog,"  %i%c: Bad capacity (%.1f pF)\n",         \
          k/2,k & 1?'R':'L',cc[i])
        u=1
      endif
    enddo
    if n>0 then                        // Get mean values
      ss=ss/n
      cs=cs/n
    endif
    if j!=0 then                       // Some fields recognized as bad
      change hmsg text="Bad fields!"
    else if ss<1000 then
      change hmsg text="Low mean field!"
      if hlog!=NULL fprintf(hlog,"  Low mean field (%.1f bits)\n",ss)
    else if u!=0 then
      change hmsg text="Bad capacities!"
    endif
    // Readjust potentiometers.
    if j!=0 || ss<1000 || u!=0 then    // Some fields or Cs are bad or low
      good=0; continue
    endif
    psminhead=-1; psmaxhead=-1
    psmin=1.0e99; psmax=-1.0e99
    smin=1.0e99; smax=-1.0e99
    pcminhead=-1; pcmaxhead=-1
    pcmin=1.0e99; pcmax=-1.0e99
    cmin=1.0e99; cmax=-1.0e99
    for i=0,i<8,i++ do                 // Check for correctness
      if i<4 then
        k=base+i                       // Top (or, in general, first) side
      else
        k=base+nfing+(i-4)             // Opposite side
      endif
      if c[k].ncal==0 continue         // Head is excluded from test
      if stopatlimit &&                                                        \
        (ps[k]<2.0 || ps[k]>509.0 || pc[k]<2.0 || pc[k]>509.0)                 \
        continue
      if fixed[k] then
        p=ps[k]
        q=pc[k]
      else
        p=ps[k]-(fs[i]-ss)/ss*DADJA5S
        q=pc[k]-(fc[i]-cs)/ss*DADJA5C
        if stopatlimit then
          p=Max(1.0,Min(p,510.0))
          q=Max(1.0,Min(q,510.0))
        endif
      endif
      if p<psmin then
        psminhead=k; psmin=p
      endif
      if p>psmax then
        psmaxhead=k; psmax=p
      endif
      if q<pcmin then
        pcminhead=k; pcmin=q
      endif
      if q>pcmax then
        pcmaxhead=k; pcmax=q
      endif
      if fixed[k]==0 then              // Exclude calibrated heads
        smin=Min(smin,fs[i])
        smax=Max(smax,fs[i])
        cmin=Min(cmin,fc[i])
        cmax=Max(cmax,fc[i])
      endif
    enddo
    if psmax-psmin>499.0 then
      // Unable to adjust sine potentiometers.
      change hmsg text="Input capacities are too different!"
      if hlog!=NULL fprintf(hlog,"  Input capacities are too different\n")
      if stopatlimit==0 then
        good=0; continue
      endif
    endif
    if allowz && pcmax-pcmin>499.0 then
      // Unable to adjust cosine potentiometers.
      change hmsg text="Phase shifts are too different!"
      if hlog!=NULL fprintf(hlog,"  Phase shifts are too different\n")
      if stopatlimit==0 then
        good=0; continue
      endif
    endif
    if psmin<1.0 then
      sprintf(s,"Head %i%c at limit, will restart with shift",                 \
        psminhead/2,psminhead & 1?'R':'L')
      change herr text=s
      if hlog!=NULL fprintf(hlog,"  %s\n",s)
      r=1.0-psmin+20.0
      for i=0,i<32,i++ do
        ps[i]=ps[i]+r
        fixed[i]=0
      enddo
      good=0
      recalibrate=1
    else if psmax>510.0 then
      sprintf(s,"Head %i%c at limit, will restart with shift",                 \
        psmaxhead/2,psmaxhead & 1?'R':'L')
      change herr text=s
      if hlog!=NULL fprintf(hlog,"  %s\n",s)
      r=510.0-psmax-20.0
      for i=0,i<32,i++ do
        ps[i]=ps[i]+r
        fixed[i]=0
      enddo
      good=0
      recalibrate=1
    endif
    if allowz && pcmin<1.0 then
      sprintf(s,"Head %i%c at limit, will restart with shift",                 \
        pcminhead/2,pcminhead & 1?'R':'L')
      change herr text=s
      if hlog!=NULL fprintf(hlog,"  %s\n",s)
      r=1.0-pcmin+20.0
      for i=0,i<32,i++ do
        pc[i]=pc[i]+r
        fixed[i]=0
      enddo
      good=0
      recalibrate=1
    else if allowz && pcmax>510.0 then
      sprintf(s,"Head %i%c at limit, will restart with shift",                 \
        pcmaxhead/2,pcmaxhead & 1?'R':'L')
      change herr text=s
      if hlog!=NULL fprintf(hlog,"  %s\n",s)
      r=510.0-pcmax-20.0
      for i=0,i<32,i++ do
        pc[i]=pc[i]+r
        fixed[i]=0
      enddo
      good=0
      recalibrate=1
    endif
    if stopatlimit==0 clear hmsg
    if smax-smin<DADJLIMIT*1.2 &&                                              \
      Abs(smax-ss)<DADJLIMIT*0.7 && Abs(ss-smin)<DADJLIMIT*0.7 &&              \
      (allowz==0 || (cmax-cmin<DADJLIMIT*1.2 &&                                \
      Abs(cmax-cs)<DADJLIMIT*0.7 && Abs(cs-cmin)<DADJLIMIT*0.7))               \
    then
      good++
      if good>=4 then                  // Set of nonce heads adjusted
        if recalibrate then
          goto restart
        endif
        if hlog!=NULL then
          fprintf(hlog,"  Group starting at head %i%c is adjusted:\n",         \
          base/2,base & 1?'R':'L')
        endif
        for i=0,i<8,i++ do
          if i<4 then
            k=base+i                   // Top (or, in general, first) side
          else
            k=base+nfing+(i-4)         // Opposite side
          endif
          if c[k].ncal==0 continue     // Head is excluded from test
          if hlog!=NULL then
            if allowz then
              fprintf(hlog,                                                    \
              "  %i%c:  dSin=%6.1f, dCos=%6.1f  sinadj=%3i, cosadj=%3i\n",     \
              k/2,k & 1?'R':'L',fs[i]-ss,fc[i]-cs,ps[k],pc[k])
            else
              fprintf(hlog,                                                    \
              "  %i%c:  dSin=%6.1f, dCos=%6.1f  sinadj=%3i\n",                 \
              k/2,k & 1?'R':'L',fs[i]-ss,fc[i]-cs,ps[k])
            endif
          endif
          fixed[k]=1
        enddo
        for i=0,i<2*nfing,i++ do
          if c[i].ncal==0 continue
          if fixed[i]==0 break
        enddo
        if i>=2*nfing then
          draw window=hgraph color=BLACK bkcolor=WHITE clear
          draw show
          change hmsg text="Input capacities adjusted"
          // Move heads in pause positions.
          for i=0,i<nfing*2,i=i+2 do
            if c[i].ncal==0 continue
            xt=groupx-25.0
            yt=$LAY.yoffset[i/2]/1000.0
            xu=groupx+25.0
            yu=$LAY.yoffset[i/2]/1000.0
            sprintf(s,"M %i(%g,%gH50V%iP%i) %i(%g,%gH50V%iP%i) NOP",           \
              i,xt,yt,v,p,i+1,xu,yu,v,p)
            SERV.Cmdimm(32,s)
          enddo
          for k=0,k<nfing*2,k++ do
            $EXTLAY.sinadj[k]=ps[k]    // Apply changes to extended layout
            if allowz $EXTLAY.cosadj[k]=pc[k]
          enddo
          // Apply current C adjust date to layout.
          Strtime(s,"%d,%m,%Y",0,0)
          sscanf(s,"%i,%i,%i",&i,&j,&k)
          $uint2($EXTLAY+586)=(i+j*32+(k-1980)*512) & 0xFFFF
          i=Savelayout()
          if i<0 err=-1
          break
        else if i==firsttop*2 || i==firsttop*2+nfing then
          base=firsttop*2
        else if i>=nfing then
          base=i-nfing-2
        else
          base=i-2
        endif
        goto nextbase
      endif
      if good>1 continue               // Don't adjust, simply wait longer
    else
      good=0
    endif
    for i=0,i<8,i++ do                 // Adjust potentiometers
      if i<4 then
        k=base+i                       // Top (or, in general, first) side
      else
        k=base+nfing+(i-4)             // Opposite side
      endif
      if c[k].ncal==0 continue         // Head is excluded from test
      if fixed[k]==0 then
        ps[k]=Max(0.1,Min(ps[k]-(fs[i]-ss)/ss*DADJA5S,511.9))
        if allowz then
          pc[k]=Max(0.1,Min(pc[k]-(fc[i]-cs)/ss*DADJA5C,511.9))
        endif
      endif
    enddo
    clear hmsg
  enddo
  change hleft position=4,4,LEFTX,LEFTY
  destroy hgraph
  if err==0 return 0                   // Full success
  if err<0 return -1                   // Operator cancelled script
  // Report problem.
  clear hright
  change hinfo text="C adjustment error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    if hlog!=NULL fprintf(hlog,"  Timeout while executing command\n")
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    if hlog!=NULL fprintf(hlog,"  Command execution error\n")
    draw text="Command execution error!"
    draw at 6,60 color=BLACK
    draw text="Tester or tester support routine rejected command sent by "
    draw text="this routine. "
  else if err==3 then
    if hlog!=NULL fprintf(hlog,"  Unexpected answer from crate\n")
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  else if err==4 then
    if hlog!=NULL fprintf(hlog,"  Internal error detected\n")
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Script is unable to select heads that will work as antennas. "
  endif
  draw text="Adjustment interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="Continue"
    help="Press to continue"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////// REPLAY OF EXISTING CALIBRATION ////////////////////////

char   *replay                         // Copy of replay file, text form
int    replaylen                       // Length of replay data

// Service function, looks for the first appearance of the specified text
// string in the replay buffer starting at offset. On success, returns offset
// of the first non-space byte that follows the found string. On error, or if
// string does not exist, returns 0.
function int Findreplayoffset(int offset,char *text)
  int l,k
  if replaylen==0 return 0             // No data
  l=Strlen(text)
  if l==0 return 0                     // Empty string
  k=Strstr(replay+offset,text)
  if k<0 return 0                      // String not found
  offset=offset+k+l
  while replay[offset]==' ' || replay[offset]=='\t' do
    offset++
  enddo
  return offset
end

// Service function, reads single line from the replay buffer, starting at the
// specified offset. Returns offset of the first byte of the next line, or 0
// on error.
function int Getreplayline(int offset,char *s)
  int n
  if offset<0 || offset>=replaylen then
    s[0]='\0'
    return 0
  endif
  while replay[offset]==' ' || replay[offset]=='\t' do
    offset++
  enddo
  n=0
  while replay[offset]!='\0' && replay[offset]!='\r'  && replay[offset]!='\n' do
    s[n]=replay[offset]
    n++; offset++
  enddo
  s[n]='\0'
  while replay[offset]=='\r' || replay[offset]=='\n' do
    offset++
  enddo
  return offset
end

// Replays existing calibration from the protocol file. Returns 0 on success,
// 1 if user cancels action and -1 if user cancels script.
function int Replaycalibration()
  int i,n,len,offs,prevoffs,head,verify,mode,point,valid[81],ny,hasy,err
  float x,y,dx,dy,z,shy,step
  float xshift[81],yshift[81],angle[81]
  char path[260],s[512]
  handle f,hretry,hcancel
  Strcpy(path,"calibr.txt")
  getini("Calibration","Replay file","%s",path)
retry:
  if replaylen!=0 then
    Free(replay)
    replaylen=0
  endif
  Drawtesterview()
  change hinfo limits=0,0
  change hinfo text="Replay calibration"
  clear hright
  if SYS.Browse(hmain,path,"Specify name of existing protocol file",0)==0 then
    return 1
  endif
  err=0
  f=Fopen(path,"rb")
  // Open file.
  if f==NULL then
    err=1                              // File does not exist?
  endif
  // Determine file length.
  if err==0 then
    Fseek(f,0,2)
    len=Ftell(f)
    if len==0 err=2                    // Something is wrong
  endif
  // Allocate memory.
  if err==0 then
    if Alloc(replay,len+1)==0 then
      err=3                            // Low memory
    else
      replaylen=len+1
    endif
  endif
  // Read contents.
  if err==0 then
    Fseek(f,0,0)
    if Fread(replay,len,f)!=len err=4  // Unable to read file
    replay[len]=0
  endif
  if f!=NULL then
    Fclose(f)
    f=NULL
  endif
  // Verify that this is a calibration protocol.
  if err==0 then
    if Findreplayoffset(0,"3 - D   C A L I B R A T I O N   L O G")!=0 then
      verify=0
      calmode=MODE_3DCAL
    else if Findreplayoffset(0,"C A L I B R A T I O N   L O G")!=0 then
      verify=0
      calmode=MODE_CAL
    else if Findreplayoffset(0,"V E R I F I C A T I O N   L O G")!=0 then
      verify=1
      calmode=MODE_VER
    else
      err=5                            // Not calibration/verification protocol
    endif
  endif
  if err!=0 then
    // Show error to user.
    if replaylen!=0 then
      Free(replay)
      replaylen=0
    endif
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    if err==1 then
      draw at 6,30 color=LIGHTRED text="File does not exist"
      draw at 6,60 color=BLACK
      draw text="Script was unable to open the specified file. Most probably, "
      draw text="file does not exist. "
    else if err==2 then
      draw at 6,30 color=LIGHTRED text="File has zero length"
      draw at 6,60 color=BLACK
      draw text="It looks like the file you are trying to replay is 0 bytes "
      draw text="long. This also may mean that you are trying to open a "
      draw text="device. "
    else if err==3 then
      draw at 6,30 color=LIGHTRED text="Low memory"
      draw at 6,60 color=BLACK
      draw text="Calibration script was unable to read replay file. Maybe it "
      draw text="is too large, or system is out of memory. "
    else if err==4 then
      draw at 6,30 color=LIGHTRED text="Unable to read replay file"
      draw at 6,60 color=BLACK
      draw text="Script was unable to read the specified file. Most probably, "
      draw text="this file is corrupted or there is a permanent I/O error. "
    else
      draw at 6,30 color=LIGHTRED text="Not a calibration file"
      draw at 6,60 color=BLACK
      draw text="The file you have selected is not a valid calibration log "
      draw text="file. "
    endif
    draw text=""
    draw show
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="Try again"
      help="Press to select different log file"
    endc
    hcancel=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="Cancel"
      help="Press to close calibration script"
    endc
    while 1 do
      if Pressed(hretry) then
        goto retry
      else if Pressed(hcancel) then
        return 1
      else if Pressed(hexit) then
        return -1
      endif
      wait
    enddo
  endif
  // Data is successfully read.
  setini("Calibration","Replay file","%s",path)
  err=0
  // Extract important parameters.
  if err==0 then
    encdist=0.0
    offs=Findreplayoffset(0,"Distance from center:")
    if offs!=0 then
      offs=Getreplayline(offs,s)
      sscanf(s,"%f",&encdist)
      if encdist==0.0 then
        err=1                          // Unable to read calibration parameter
      endif
    endif
  endif
  Openlogfile(4)
  // Fill calibrators.
  if err==0 then
    if calmode==MODE_3DCAL then
      i=Fillcalibrators(C_VERAREA,FILL_BOTH)
    else if verify then
      i=Selectverification(1)
      if i!=0 then
        if replaylen!=0 then
          Free(replay)
        endif
        return i
      endif
      i=Fillcalibrators(C_CALIBR+hverifytype,FILL_MECH)
      i=i|Fillcalibrators(C_VER3+vverifytype,FILL_VIDEO)
      mode=RC_ZERO|RC_KEEP             // Load old corrections or keep current
      if (hverifytype==4 || hverifytype==5) &&                                 \
        (vverifytype==0 || vverifytype==2) &&                                  \
        (testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||        \
        testertype==TT_A7 || testertype==TT_A8)                                \
      then
        // Adjustment is possible.
        mode=mode|RC_ADJUST
        i=i|Readoldcorr(mode)
      endif
    else
      i=Fillcalibrators(C_CALIBR,FILL_BOTH)
    endif
    if i!=0 then
      err=2                            // Unable to generate calibration data
    else
      for head=0,head<32,head++ do
        c[head].next=c[head].ncal
        for i=0,i<c[head].ncal,i++ do
          c[head].err[i]=1
        enddo
      enddo
    endif
  endif
  // Read head calibration data.
  if err==0 then
    if verify then
      offs=Findreplayoffset(offs,"Electrical verification...")
    else
      offs=Findreplayoffset(offs,"Electrical calibration...")
    endif
    if offs==0 err=3                   // Missing head calibration data
  endif
  while err==0 do
    offs=Getreplayline(offs,s)
    if s[0]=='\0' continue
    // Check whether error message.
    if Memcmp(s,"ERROR",5)==0 continue
    // Check whether debugging data.
    if s[0]=='>' || s[0]=='*' || s[0]=='/' continue
    if Isdigit(s[0])==0 break
    head=s[0]-'0'; i=1
    if Isdigit(s[1]) then
      head=head*10+s[1]-'0'; i=2
    endif
    if s[i]=='L' then
      head=head*2+0
    else if s[i]=='R' then
      head=head*2+1
    else
      err=4; continue                  // Invalid data format
    endif
    i++
    if s[i]!=':' then
      err=4; continue
    endif
    i++
    n=sscanf(s+i,"%f %f %f %f Z=%f",&x,&y,&dx,&dy,&z)
    if n!=2 && n!=4 && n!=5 then
      err=4; continue
    endif
    for i=0,i<c[head].ncal,i++ do
      if Abs(c[head].xa[i]-x)<0.010 && Abs(c[head].ya[i]-y)<0.010 break
    enddo
    if i>=c[head].ncal continue


//if x<12 || x>303 continue


    c[head].xa[i]=x
    c[head].ya[i]=y
    if n==2 then
      // Most probably, not calibrated.
      c[head].xm[i]=x
      c[head].ym[i]=y
      c[head].err[i]=1
      c[head].z[i]=0
    else
      c[head].xm[i]=x+dx
      c[head].ym[i]=y+dy
      c[head].err[i]=0
      if n==5 then
        c[head].z[i]=z
      else
        c[head].z[i]=0
      endif
    endif
  enddo
  // Read data for dedicated cameras.
  if err==0 && $LAY.cameras!=0 then
    if verify then
      offs=Findreplayoffset(0,"Optical verification...")
    else
      offs=Findreplayoffset(0,"Optical calibration...")
    endif
    if offs==0 err=3                   // Missing camera calibration data
    while err==0 do
      offs=Getreplayline(offs,s)
      if s[0]=='\0' continue
      // Check whether error message.
      if Memcmp(s,"ERROR",5)==0 continue
      // Check whether debugging data.
      if s[0]=='>' || s[0]=='*' || s[0]=='/' continue
      if Strncmp(s,"VTop",4)==0 then
        head=$LAY.nfing*2+0; i=4
      else if Strncmp(s,"VBot",4)==0 then
        head=$LAY.nfing*2+1; i=4
      else
        break
      endif
      if s[i]!=':' then
        err=4; continue
      endif
      i++
      n=sscanf(s+i,"%f %f %f %f",&x,&y,&dx,&dy)
      if n!=2 && n!=4 then
        err=4; continue
      endif
      for i=0,i<c[head].ncal,i++ do
        if Abs(c[head].xa[i]-x)<0.010 && Abs(c[head].ya[i]-y)<0.010 break
      enddo
      if i>=c[head].ncal continue
      c[head].xa[i]=x
      c[head].ya[i]=y
      if n==2 then
        // Most probably, not calibrated
        c[head].xm[i]=x
        c[head].ym[i]=y
        c[head].err[i]=1
      else
        c[head].xm[i]=x+dx
        c[head].ym[i]=y+dy
        c[head].err[i]=0
      endif
    enddo
  endif
  if err==0 && adjustcorr!=0 && $LAY.cameras==0 && $LAY.headcameras!=0 then
    // Corrections adjustment for tester with head cameras is active. Refine
    // and load head camera corrections.
    i=Adjustcorrections(0)
    if i<0 err=-1                      // Operator interrupted calibration
  endif
  if err==0 && calmode==MODE_3DCAL then
    i=Readoldcorr(0)                   // Load old corrections, no zeroing
    if i<0 err=-1                      // Operator interrupted calibration
    if err==0 Calculate3dfactors()
  endif
  // Calculate correction tables for heads.
  if err==0 && calmode==MODE_CAL then
    i=Corrall(2,0)
    if i<0 err=-1
    if err==0 then
      i=Checkcenters()
      if i<0 err=-1
    endif
  endif
  Memcpy(cfing,c,Sizeof(c))            // Make backup of finger data
  // Read head camera calibration data.
  if err==0 && $LAY.cameras==0 && $LAY.headcameras!=0 then
    if verify then
      i=Fillcalibrators(C_VER3+vverifytype,FILL_HCAM)
    else
      i=Fillcalibrators(C_CALIBR,FILL_HCAM)
    endif
    if i!=0 then
      err=2                            // Unable to generate calibration data
    else
      for head=0,head<32,head++ do
        c[head].next=c[head].ncal
        for i=0,i<c[head].ncal,i++ do
          c[head].err[i]=1
        enddo
      enddo
    endif
    if err==0 then
      if verify then
        offs=Findreplayoffset(offs,"Head camera verification...")
      else
        offs=Findreplayoffset(offs,"Head camera calibration...")
      endif
      if offs==0 err=3                 // Missing head camera calibration data
    endif
    while err==0 do
      offs=Getreplayline(offs,s)
      if s[0]=='\0' continue
      // Check whether error message.
      if Memcmp(s,"ERROR",5)==0 continue
      // Check whether debugging data.
      if s[0]=='>' || s[0]=='*' || s[0]=='/' continue
      if s[0]!='H' break
      if Isdigit(s[1])==0 then
        err=4; continue                // Invalid data format
      endif
      head=s[1]-'0'; i=2
      if Isdigit(s[2]) then
        head=head*10+s[2]-'0'; i=3
      endif
      if s[i]=='L' then
        head=head*2+0
      else if s[i]=='R' then
        head=head*2+1
      else
        err=4; continue
      endif
      i++
      if s[i]!=':' then
        err=4; continue
      endif
      i++
      if sscanf(s+i,"%f %f %f %f",&x,&y,&dx,&dy)!=4 then
        err=4; continue
      endif
      for i=0,i<c[head].ncal,i++ do
        if Abs(c[head].xa[i]-x)<0.010 && Abs(c[head].ya[i]-y)<0.010 break
      enddo
      if i>=c[head].ncal continue
      c[head].xa[i]=x
      c[head].ya[i]=y
      c[head].xm[i]=x+dx
      c[head].ym[i]=y+dy
      c[head].err[i]=0
    enddo
    // Calculate correction tables for head cameras.
    if err==0 && calmode==MODE_CAL then
      i=Corrall(2,1)
      if i<0 err=-1
    endif
    Memcpy(chcam,c,Sizeof(c))          // Make backup of head camera data
  endif
  if verify && err==0 && calmode!=MODE_3DCAL then
    verification=0                     // Yes, that's true...
    i=Fitcalibration()                 // Verify existing corrections
    if i<0 err=-1
  endif
  // Read optional shuttle Y calibration data.
  if err==0 && verify==0 then
    Memset(valid,0,Sizeof(valid))
    offs=0
    step=1.0e99
    ny=0
    hasy=0
    while 1 do
      offs=Findreplayoffset(offs,"Shuttle Y calibration at SHY=")
      if offs==0 break
      hasy=1                           // Shuttle Y data present
      offs=Getreplayline(offs,s)
      shy=0.0; point=0; sscanf(s,"%f mm (point %i)...",&shy,&point)
      if shy==0.0 || point<(-40) || point==0 || point>40 break
      step=shy/point
      ny=Max(ny,Abs(point))
      point=point+40
      Fillcalibrators(C_SHY,FILL_MECH)
      while err==0 do
        prevoffs=offs
        offs=Getreplayline(offs,s)
        if s[0]=='\0' continue
        // Check whether error message.
        if Memcmp(s,"ERROR",5)==0 continue
        // Check whether debugging data.
        if s[0]=='>' || s[0]=='*' || s[0]=='/' continue
        if Isdigit(s[0])==0 then
          offs=prevoffs; break
        endif
        head=s[0]-'0'; i=1
        if Isdigit(s[1]) then
          head=head*10+s[1]-'0'; i=2
        endif
        if s[i]=='L' then
          head=head*2+0
        else if s[i]=='R' then
          head=head*2+1
        else
          err=4; continue                  // Invalid data format
        endif
        i++
        if s[i]!=':' then
          err=4; continue
        endif
        i++
        n=sscanf(s+i,"%f %f %f %f Z=%f",&x,&y,&dx,&dy,&z)
        if n!=2 && n!=4 && n!=5 then
          err=4; continue
        endif
        for i=0,i<c[head].ncal,i++ do
          if Abs(c[head].xa[i]-x)<0.010 && Abs(c[head].ya[i]-y)<0.010 break
        enddo
        if i>=c[head].ncal continue
        c[head].xa[i]=x
        c[head].ya[i]=y
        if n==2 then
          // Most probably, not calibrated.
          c[head].xm[i]=x
          c[head].ym[i]=y
          c[head].err[i]=1
          c[head].z[i]=0
        else
          c[head].xm[i]=x+dx
          c[head].ym[i]=y+dy
          c[head].err[i]=0
          if n==5 then
            c[head].z[i]=z
          else
            c[head].z[i]=0
          endif
        endif
      enddo
      valid[point]=Fitshuttley(xshift+point,yshift+point,angle+point)
    enddo
    if hasy then
      if err==0 && (ny==0 || step>10000.0) then
        err=4                          // Invalid data
      endif
      if err==0 then
        if Processshuttley(0,ny,step,xshift+(40-ny),yshift+(40-ny),            \
          angle+(40-ny),valid+(40-ny))!=0 then
          err=4
        endif
      endif
    endif
  endif
  if replaylen!=0 then
    Free(replay)
    replaylen=0
  endif
  if err==0 then
    return verify                      // Don't postprocess if verification
  endif
  if err<0 return -1
  // Show error to user.
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  if err==1 then
    draw at 6,30 color=LIGHTRED text="Unable to read parameters"
    draw at 6,60 color=BLACK
    draw text="Script was unable to extract some important parameter. "
  else if err==2 then
    draw at 6,30 color=LIGHTRED text="Unable to fill calibrators"
    draw at 6,60 color=BLACK
    draw text="Script was unable to initialize an important structure that "
    draw text="describes the calibration process. "
  else if err==3 then
    draw at 6,30 color=LIGHTRED text="Missing data"
    draw at 6,60 color=BLACK
    draw text="Calibration data is missing in the file. Probably the "
    draw text="calibration was interrupted. "
  else if err==4 then
    draw at 6,30 color=LIGHTRED text="Invalid data format"
    draw at 6,60 color=BLACK
    draw text="When parsing log file, calibration script has encountered "
    draw text="data which it can't understand. Probebly the file was "
    draw text="generated by the very old script, or it was edited manually. "
  else
    draw at 6,30 color=LIGHTRED text="Can't process calibration file"
    draw at 6,60 color=BLACK
    draw text="An error was detected that makes replay impossible. "
  endif
  draw text=""
  draw show
  hretry=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="Try again"
    help="Press to select different log file"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="Cancel"
    help="Press to close calibration script"
  endc
  while 1 do
    if Pressed(hretry) then
      goto retry
    else if Pressed(hcancel) then
      return 1
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// MAIN ROUTINE /////////////////////////////////

// Main calibration routine.
function int main()
  int i,j,k,head,caltype,checkstat,accelinvalid,lowaccelset,mode
  char s[256]
  hmain=control WINDOW
    window=NULL
    position=10,10,MAINX,MAINY
    name=format("Flying Probe Tester Calibration v%s",VERSION)
    help=" "
    size=128
  endc
  hleft=control CHILD
    window=hmain
    position=5,5,LEFTX,LEFTY
    help=" "
    color=DARKGRAY
    size=65536
  endc
  hserv=control CHILD
    window=hmain
    position=SPLIT,5,RIGHTX,SERVY
    help="Current status of calibration"
    color=DARKGRAY
  endc
  hright=control CHILD
    window=hmain
    position=SPLIT,10+SERVY,RIGHTX,RIGHTY
    help=" "
    color=DARKGRAY
    size=2048
  endc
  hinfo=control PROGRESS
    window=hserv
    position=-1,-1,RIGHTX+2,SERVY+2
    text="Welcome!"
    help="Current status of calibration"
    mode=M_PERCENT
    font=MEDIUMFONT
    limits=0,0
  endc
  hexit=control BUTTON
    window=hmain
    position=MAINX-84,MAINY-SERVY,80,SERVY-3
    name="Close"
    help="DOUBLECLICK to terminate calibration and close this window"
    mode=M_DBLCLICK
  endc
  draw window=hmain bitmap=0,0,1,"bkground" show
  SYS.Version(&i,&j,&k)
  if i>=1 || j>=98 then
    flashthru=1                        // OllyTest supports flash shinethru
  else
    flashthru=0
  endif
  tstart=Time()
  startlayout=0
  warnradius=1
  loadchanged=0
  layoutchanged=0
  operator=1
  autoconfirm=1
  quickcorrdisabled=0
  caltype=0
  getini("Calibration","Type","%i",&caltype)
  if ((caltype<0 || caltype>4) && caltype!=6 && caltype!=7) caltype=0
  firsttop=-1
  firstbot=-1
  boardtype=0
  throwaway=0
  precisey=PRY_STD
  interlace=-1
  illumination=0
  cameramode=-1
  autoverify=1
  autoverified=0
  measureoffset=0
  lowspeed=0
  acc=5                                // Preliminary setting
  globalerr=0
  idealboard=1
  statscale=3                          // Default correction viewer scale
  statzoom=1                           // Default correction viewer zoom
  softtouch=0
  accelinvalid=1
  lowaccelset=0
  isglassboard=0
  disable3d=0
  for i=0,i<32,i++
    oversurface[i]=0
  enddo
  checkstat=0
  verifymode=VERIFY_ACC
  adjustcorr=0
  wavenesstype=1
  wavenessdir=0
  wavenessvdist=0.0
  wavenessvdist=0.0
  individualbc=1                       // Individual brightness and contrast
  illtype=0x07                         // Top illumunation
  updatefocus[0]=1                     // Focus is not yet set
  updatefocus[1]=1
  headcamfidtype=0
  headcamtypevalid=0
  rotateimage=1
  usehvconditioning=0
  unloadboard=1                        // Whether to unload board after test
  camrvalid[0]=0
  camrvalid[1]=0
  pulledshuttle=-1
  getini("Calibration","Move shuttle","%i,%i",&i,&unloadboard)
  Bcgetini()                           // Read brightness & contrast from .ini
  change hleft help="!"
  draw window=hleft
  draw at 70,40 bitmap=0,0,0,"logo"
  draw color=DARKGRAY font=LARGEFONT mode=M_CENTERED
  draw at LEFTX/2,280 text=""
  draw font=MEDIUMFONT
  draw at LEFTX/2,305 text=format(" %s",VERSION)
  draw font=INFOFONT
  draw at LEFTX/2,330 text=" "
  draw at LEFTX/2,350 text=" "
  draw show
  if Preparescripts()!=0 goto quit     // Compile modules with subroutines
  layvalid=1                           // Assume that valid layout is loaded
  corrvalid=1                          // Assume valid corrections loaded
  corrsource=CS_OLD
  diskvalid=1                          // Assume layout and corrections match
recheck:
  if Loadtester()!=0 goto quit         // Make sure that tester is loaded
  if Embedded()!=0 then
    SERV.Cmdimm(32,"$LIGHTS TESTING")  // Show calibration on traffic lights
  endif
  i=Getlayout()                        // Get actually loaded layout
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto recheck                  // Try to reload tester
  globalerr=globalerr & (~GE_BOOT)     // Tester is just loaded
  i=Checkgloberrors()                  // Check for errors except boot errors
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto recheck                  // Try to reload tester
  Recognizetester()                    // Determine type of the tester
  if testertype==TT_WRONG goto quit    // Don't know how to calibrate
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8 then
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,1")
  endif
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8 then
    Getfeatures()                      // Get tester features
    Resetallstat()                     // Reset movement statistics
  else
    cratefeatures=0                    // Feature lists are not supported
    measfeatures=0
    measfeatures2=0
  endif
  if testertype==TT_A5L && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    smallboard=1
  else if testertype==TT_A7 && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    smallboard=0
  else
    smallboard=0
  endif
  if testertype==TT_A5L || (testertype==TT_S2 && $LAY.nfing<=4) ||             \
    testertype==TT_A7 then
    getini("Calibration","Small board","%i",&smallboard)
    largeboard=0
  else if testertype==TT_A7 then
    smallboard=0
    getini("Calibration","Large board","%i",&largeboard)
  else
    smallboard=0                       // Not supported
    largeboard=0
  endif
  Getautomationtype()                  // Get type of automation
  i=Checklayout()                      // Check for disabled rails etc.
  if i<0 goto quit                     // Operator interrupted calibration
  Disableautoset()                     // Disable auto brightness and contrast
  // Tester is loaded, $LAY structure is the same as in tester.
choosetype:
  Drawtesterview()                     // Show general view of the tester
  caltype=Selectcaltype(caltype)       // Select general type of calibration
  if caltype<0 goto quit               // Operator interrupted calibration
  if caltype==5 goto headadjust        // Make quick head adjustment
  setini("Calibration","Type","%i",caltype)
  if calmode==MODE_3DCAL then          // 3-D calibration selected
    i=Check3dlayoutdate()              // Check that it makes sense at all
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto choosetype             // Select different mode
  endif
  i=Selectneedle()                     // Ask to verify or change needle type
  if i<0 goto quit                     // Operator interrupted calibration
  Drawtesterview()                     // Show general view of the tester
  i=Presetparm(caltype)                // Set calibration parameters
  if i<0 goto quit                     // Operator interrupted calibration
customparm:
  if caltype==4 then                   // Custom calibration selected
    i=Customparm()                     // Allow operator to change parameters
  else
    i=Customstroke()                   // Allow operator to change stroke
  endif
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto choosetype               // Select another type of calibration
  Drawtesterview()                     // Show general view of the tester
  acc=Max(1.0,Min(accuracy*1000,1.0))  // Set positioning accuracy
  setini("Calibration","Small board","%i",smallboard)
  if testertype==TT_A7 setini("Calibration","Large board","%i",largeboard)
  Getheadcamshinethru()                // Read shinethru corrections from ini
  Setboardsize()
  if (boardtype==1 || boardtype==2) && headcamtypevalid==0 then
    i=Setfidtype()                     // Set fiducial type
    if i<0 goto quit                   // Operator interrupted calibration
    headcamtypevalid=1
  endif
  if calmode==MODE_VER then            // Verification of existing corrections
    i=Selectverification(0)            // Select points for verification
    if i==1 then                       // Customize
      caltype=4                        // Proceed with custom calibration
      goto customparm
    endif
    if i<0 goto quit                   // Operator interrupted calibration
    if verifymode==VERIFY_REPLAY then
      goto replaycal                   // Special branch: replay calibration
    endif
  endif
  i=Fillcalibrators(C_CALIBR,FILL_BOTH)// Check only that parameters correct,
  if i<0 goto quit                     // we need another parms on first step.
  if i>0 goto choosetype               // Error in parameters, retry
  zscan=z                              // Set (preliminary) scanning Z height
  i=Setdefboard()                      // Report board size to tester
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto recheck                  // Bad or no answer, try to reload tester
  if demo==0 then                      // No log file in demo mode
    i=Openlogfile(caltype)             // Create log file and write parameters
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  // If in calibration mode, zero corrections. Otherwise, load old corrections.
  if calmode==MODE_CAL then
    i=Loadcorr(-1,1,1)                 // Send zero correction data to tester
    corrvalid=0                        // Tester corrections are zeroed
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Bad or no answer, try to reload tester
  else
    if calmode==MODE_3DCAL then        // 3-D calibration
      i=Readoldcorr(0)                 // Load old corrections, no zeroing
    else if calmode==MODE_VER then     // Verification
      if verifymode==VERIFY_ZALIGN then
        i=Readoldcorr(RC_ZEROASK)      // Load old corrections, accept zeroing
      else if verifymode==VERIFY_NEEDLES then
        i=Readoldcorr(0)               // Load old corrections, no zeroing
      else
        mode=RC_ZERO|RC_KEEP           // Load old corrections or keep current
        if (hverifytype==4 || hverifytype==5) &&                               \
          (vverifytype==0 || vverifytype==2) &&                                \
          (testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||      \
          testertype==TT_A7 || testertype==TT_A8) && verifymode==VERIFY_ACC    \
          mode=mode|RC_ADJUST          // Adjustment is possible
        i=Readoldcorr(mode)
      endif
    else if calmode==MODE_CADJ then    // Only C adjust
      i=Readoldcorr(RC_ZERO)           // Load old corrections, zeroing OK
    else
      i=0                              // In fact, internal error
    endif
    if i<0 goto quit                   // Operator interrupted calibration
    if i==0 then                       // Do not keep existing corrections
      if calmode==MODE_3DCAL then
        i=Check3doldcorr()             // Check that calibration Z is here
        if i<0 goto quit               // Operator interrupted calibration
        if i>0 then
          disable3d=1
          goto choosetype              // Choose different type of calibration
        endif
      endif
      if calmode==MODE_3DCAL then      // 3-D calibration
        i=Loadcorr(-1,2,1)             // Send old corrections, disable 3-D
        corrvalid=0                    // Corrections are partially invalid
      else
        i=Loadcorr(-1,0,1)             // Send old corrections to tester
        corrvalid=1                    // Corrections are valid again
      endif
      if i<0 goto quit                 // Operator interrupted calibration
      if i>0 goto recheck              // Bad or no answer, try to reload tester
    endif
  endif
  if calmode==MODE_CAL || calmode==MODE_3DCAL ||                               \
    (calmode==MODE_VER && verifymode==VERIFY_ACC) then
    i=Checktemp()                      // Check tester temperature
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto recheck               // Bad or no answer, try to reload tester
  endif
  k=0
reppreload:
  if demo==0 && preloadok==0 &&                                                \
    (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_A7 || testertype==TT_A8 || testertype==TT_S1 ||             \
    testertype==TT_S2 || testertype==TT_S3) &&                                 \
    ($EXTLAY.zheadtype & (HCZ_VALID|HCZ_TESTPRLD))==(HCZ_VALID|HCZ_TESTPRLD) &&\
    (($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL ||                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL) && (calmode!=MODE_VER || \
    (verifymode!=VERIFY_ZMARKS && verifymode!=VERIFY_CAMSTAB)) then
    i=Checkpreload(k)                  // Check preload force of splinogramms
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 then                        // Test preload force once again
      k=1                              // Make soft reset
      goto reppreload
    endif
    preloadok=1                        // User accepted preload test results
  endif
  goto noinstall                       // Skip reset for the first time
  // Calibration parameters set. Install board and check its position.
install:
  if demo==0 && (testertype==TT_A2 || testertype==TT_A2L ||                    \
    testertype==TT_A2H || testertype==TT_A3 || testertype==TT_A3L ||           \
    testertype==TT_A4)                                                         \
  then
    SYS.Softreset(0)                   // Otherwise shuttle will not unlock
  endif
noinstall:
  if calmode!=MODE_VER ||                                                      \
    (verifymode!=VERIFY_LIMITS && verifymode!=VERIFY_ZMARKS)                   \
  then
    // If glass, prepare for HV conditioning.
    if boardtype==1 || boardtype==2 then
      i=Inithvconditioning()
      if i<0 goto quit                 // Operator interrupted calibration
    endif
    if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&       \
      (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                 \
      ($LAY.config & LC_LDMASK)==LC_SPLITAUTO) &&                              \
      ((boardtype==1 && (testertype==TT_A7 || smallboard!=0)) ||               \
      boardtype==2) then
      i=InstallglassboardLM(0)         // Install glass board in L&M shuttle
    else if testertype==TT_A8 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO &&     \
      ((boardtype==1 && smallboard!=0) || boardtype==2) then
      i=InstallglassboardLM(0)         // Install glass board in L&M shuttle
    else if testertype==TT_A8 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO then
      i=InstallcalboardLM()            // Install board in L&M shuttle
    else if testertype==TT_S2 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO &&     \
      (automationtype==AUTO_S2LMSEMI || automationtype==AUTO_S2LMFULL) then
      i=InstallcalboardLM()            // Install board in S2 shuttle
    else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
      i=InstallglassboardLM(0)         // Install board in S3 split shuttle
    else if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&  \
      (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                 \
      ($LAY.config & LC_LDMASK)==LC_SPLITAUTO) then
      i=InstallcalboardLM()            // Install board in L&M shuttle
    else if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
      i=InstallcalboardEPCOS()         // Install board in EPCOS shuttle
    else
      i=Installcalboard()              // Install calibration board
    endif
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Bad or no answer, try to reload tester
    i=Checkgloberrors()                // Check for errors except boot errors
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Try to reload tester
    Drawcalboard(0,0,0,0)              // Redraw board without offset
    Activatesoftlanding(softland)      // Set soft landing
    // Update shuttle encoder offsets if tester is S3 with split shuttle and
    // we are going to calibrate tester.
    if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO &&         \
      calmode==MODE_CAL then
      i=Getsplitencoders()             // Get encoder offsets
      if i<0 goto quit                 // Operator interrupted calibration
      if i>0 goto recheck              // Bad or no answer, try to reload tester
    endif
  endif
  // Check for board placement and mux connection order is not necessary if all
  // heads are excluded, if there are no references, if reference is external
  // antenna, or if the sole task is to verify limits.
chkplace:
  if usesides!=0 && kelvinscan!=2 && kelvinscan!=3 &&                          \
    (calmode==MODE_CAL || calmode==MODE_3DCAL ||                               \
    (calmode==MODE_VER && verifymode!=VERIFY_CAMSTAB &&                        \
    verifymode!=VERIFY_LIMITS && verifymode!=VERIFY_ZMARKS))                   \
  then
    i=Checkplacement()                 // Check that board is electrically ok
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto recheck               // Bad or no answer, try to reload tester
    if i==2 goto chkplace              // Retry check of calibration board
    if i==3 goto install               // Change placement of the board
  endif
chkorder:
  if usesides!=0 && kelvinscan!=2 && kelvinscan!=3 &&                          \
    (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) &&                                 \
    (calmode==MODE_CAL || (calmode==MODE_VER && verifymode==VERIFY_ACC))       \
  then
    i=Checkorder()                     // Check order of mux connections
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto recheck               // Bad or no answer, try to reload tester
    if i==2 goto chkorder              // Retry check of mux connections
    if i==3 goto install               // Change placement of the board
  endif
  // Check that needle shields are connected to the on-head boards and that
  // analog cables have no (position-dependent) shortcut to ground.
retestc:
  if calmode==MODE_CAL && usesides!=0 &&                                       \
    ($LAY.config & LC_OHTYPE)!=LC_NOFIELD                                      \
  then
    i=Checkshields()                   // Check needle and cable shields
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto retestc               // Retry check of shieldings
  endif
chkbending:
  // Check for bending or shift measurements are not necessary if either all
  // heads are excluded, or manual verification is active, or sole task is to
  // verify limits.
  if usesides!=0 && (calmode!=MODE_VER || (verifymode!=VERIFY_LIMITS &&        \
    verifymode!=VERIFY_MANUAL && verifymode!=VERIFY_ZALIGN &&                  \
    verifymode!=VERIFY_CAMSTAB && verifymode!=VERIFY_ZMARKS &&                 \
    verifymode!=VERIFY_REPLAY))                                                \
  then
    i=Checkbending()                   // Check that board is not bent
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto recheck               // Bad or no answer, try to reload tester
    if i==2 goto chkbending            // Retry check of board bending
    if i==3 goto install               // Change placement of the board
    if calmode==MODE_CAL then          // New calibration
      i=Measureshifts()                // Check placement of calibration board
      if i<0 goto quit                 // Operator interrupted calibration
      if i==1 goto choosetype          // Error in parameters (impossible!)
      if i==2 goto install             // Change placement of the board
      if i==3 goto skipheat            // Operator skipped shifts and heating
      if ((testertype!=TT_A5L && testertype!=TT_A7) ||                         \
        (($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                               \
        ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO)) &&                           \
        (testertype!=TT_S2 || ($LAY.config & LC_LDMASK)!=LC_LMS2AUTO ||        \
        (automationtype!=AUTO_S2LMSEMI && automationtype!=AUTO_S2LMFULL)) &&   \
        (testertype!=TT_A8 || ($LAY.config & LC_LDMASK)!=LC_LMS2AUTO ||        \
        (automationtype!=AUTO_A8LMMAN && automationtype!=AUTO_A8LMSEMI &&      \
        automationtype!=AUTO_A8LMFULL))                                        \
      then
        i=Saveboardposition()          // Save X-Y board coordinates
        if i<0 goto quit               // Operator interrupted calibration
      endif
    endif
    if calmode==MODE_CAL || calmode==MODE_3DCAL || (calmode==MODE_VER &&       \
      (verifymode==VERIFY_ACC || verifymode==VERIFY_WAVE)) then
      i=Heatfingers(warmuptime)        // Make warmup & shake calibration board
      if i<0 goto quit                 // Operator interrupted calibration
    endif
  endif
skipheat:
  if calmode==MODE_CADJ goto scanoffsets
  if usesides!=0 && (calmode!=MODE_VER || (verifymode!=VERIFY_LIMITS &&        \
    verifymode!=VERIFY_CAMSTAB && verifymode!=VERIFY_ZMARKS &&                 \
    verifymode!=VERIFY_REPLAY))                                                \
  then
    i=Checksurfdet()                   // Check if Z contact detection good
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  // Dedicated verification of limits.
repeatlimits:
  if calmode==MODE_VER && verifymode==VERIFY_LIMITS then
    i=Verifylimits(1)                  // Verify limits of working area
    if i<0 goto quit                   // Operator interrupted calibration
    if i==2 goto repeatlimits          // Operator decided to repeat test
    i=0; goto quit                     // Test finished
  endif
  // Verification of Z end marks.
repeatzzeros:
  if calmode==MODE_VER && verifymode==VERIFY_ZMARKS then
    i=Checkzzeros(1)                   // Check zero marks on A7/A8 Z axes
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto repeatzzeros           // Operator decided to repeat test
    goto quit                          // Test finished
  endif
rescanwave:
  // Waveness measurements.
  if calmode==MODE_VER && verifymode==VERIFY_WAVE then
    i=Scanoffsets(1)                   // Measure offsets of central points
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Error in parameters (impossible!)
    if i==2 goto install               // Change placement of the board
    if i==3 goto rescanwave            // Repeat scanning
    i=Measurewaves()
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Error in parameters (impossible!)
    if i==2 goto install               // Change placement of the board
    Fitwaves()                         // Display waves
    i=0; goto quit
  endif
  // Manual verification or camera stability test.
  if calmode==MODE_VER &&                                                      \
    (verifymode==VERIFY_MANUAL || verifymode==VERIFY_CAMSTAB) then
    if cameras!=0 then
      if illumination!=0 && (boardtype==1 || boardtype==2) then
        i=Manualoppdist()              // Adjust shinethrough offset
        if i<0 goto quit               // Operator interrupted calibration
      endif
      i=Manualcenters(0)               // Adjust brightness and contrast
      if i<0 goto quit                 // Operator interrupted calibration
      while 1 do
        i=Videomagnification()         // Measure camera magnification
        if i<0 goto quit               // Operator interrupted calibration
        if i==0 break                  // Magnification measured correctly
        if i==1 goto choosetype        // Error in parameters (impossible!)
        if i==2 goto install           // Change placement of the board
        if i==3 then                   // Request to find centers manually
          i=Manualcenters(1)           // Find centers manually
          if i<0 goto quit             // Operator interrupted calibration
        endif
      enddo
      i=Definefiducials(1,-1)          // Define fiducials
      if i<0 goto quit                 // Operator interrupted calibration
      if i==1 goto choosetype          // Unable to define fiducial
      verification=0                   // Main test
    else if headcams!=0 then
      Getheadcamscales()               // Get old/default camera magnifications
      i=Headcamfiducials(1,-1)         // Define fiducials, also alternative
      if i<0 goto quit                 // Operator interrupted calibration
      i=Headcambrightness(0,0)         // Adjust brightness and contrast
      if i<0 goto quit                 // Operator interrupted calibration
    endif
    if verifymode==VERIFY_MANUAL then
      Verifymanually()
    else
      Verifycamerastability()
    endif
    goto quit
  endif
  // Z alignment test.
repeatzalign:
  if calmode==MODE_VER && verifymode==VERIFY_ZALIGN then
    i=Verifyzalignment()
    if i==2 goto install               // Change placement of the board
    if i==3 goto repeatzalign          // Repeat Z alignment test
    goto quit
  endif
repeatpadjust:
  // If tester is A5, A6 or S1 equipped with microprobes, adjust pressure
  // sensors.
  if (calmode==MODE_CAL || calmode==MODE_VER && verifymode==VERIFY_NEEDLES) && \
    (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) &&                                 \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP                            \
  then
    i=Adjustpressure()
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto repeatpadjust         // Repeat pressure adjust
    if calmode==MODE_VER && verifymode==VERIFY_NEEDLES goto quit
  endif
  // If tester is equipped with Kelvin needles and board is FR4, calibrate
  // needle resistances (loop resistance from on-head board to pin and from
  // second pin back to on-head), used by LATEST and other high-I measurements.
  if boardtype==0 && (calmode==MODE_CAL || calmode==MODE_VER) &&               \
    (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) &&                                 \
    $LAY.probetype!=0 && (measfeatures2 & MF2_LACONT)!=0 && kelvinscan==0      \
  then
    i=Needleresistance()
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  // If tester is S1, correct and flash Z microstep.
  if calmode==MODE_CAL &&                                                      \
    (testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3) then
    i=Correctzmicrostep()
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  // If tester is A5, A6 or S1 equipped with soft splinogramms or microprobes,
  // adjust individual pressures. This improves soft landing.
  if calmode==MODE_CAL && (testertype==TT_A5 || testertype==TT_A5L ||          \
    testertype==TT_A6 || testertype==TT_A7 || testertype==TT_A8) &&            \
    (($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL ||                        \
    ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP)                           \
  then
    i=Adjustsoftlanding()
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  // Update temperature and pressure corrections in tester's layout. As
  // reloading layout for A2 is lengthy, I do it only for A5/A6.
  if calmode==MODE_CAL &&                                                      \
    (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8)                                    \
  then
    Applyoffsets(1)                    // Apply actual temperature to layout
    i=Loadlayout(1)                    // Reload corrected layout into tester
    if testertype==TT_S3 then
      SYS.Softreset(0)                 // To apply changes in shuttle position
    endif
    layvalid=0                         // Layout in tester differs from disk
    corrvalid=0                        // Corrections in tester are zeroed
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Bad or no answer, try to reload tester
    Activatesoftlanding(softland)      // Set soft landing
    accelinvalid=Getaccel(&axhead,&ayhead,&axcam,&aycam)
    if accelinvalid<0 goto quit        // Operator interrupted calibration
  endif
  // Correct right Y encoder of S3 shuttle.
  if calmode==MODE_CAL && testertype==TT_S3 && testersides==0x03 &&            \
    ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO                                    \
  then
    i=Correctshuttleyencoder()
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  // Adjust brightness and correct centers in layout for dedicated cameras.
  if calmode!=MODE_CADJ && cameras!=0 then
    if illumination!=0 && (boardtype==1 || boardtype==2) then
      i=Manualoppdist()                // Adjust shinethrough offset
      if i<0 goto quit                 // Operator interrupted calibration
    endif
    i=Manualcenters(0)                 // Adjust brightness and contrast
    if i<0 goto quit                   // Operator interrupted calibration
    while 1 do
      i=Videomagnification()           // Measure camera magnification
      if i<0 goto quit                 // Operator interrupted calibration
      if i==0 break                    // Magnification measured correctly
      if i==1 goto choosetype          // Error in parameters (impossible!)
      if i==2 goto install             // Change placement of the board
      if i==3 then                     // Request to find centers manually
        i=Manualcenters(1)             // Find centers manually
        if i<0 goto quit               // Operator interrupted calibration
      endif
    enddo
    if calmode==MODE_VER && testertype==TT_S3 && boardtype==1 then
      i=Definefiducials(1,-1)          // Define both crosses and left rects
    else
      i=Definefiducials(0,-1)          // Define standard fiducials
    endif
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Unable to define fiducial
    verification=0                     // Main test
  endif
  // Measure offsets of dedicated video cameras. Head cameras have no own
  // centers and must be checked and adjusted after the fingers are corrected
  // electrically.
  if calmode==MODE_CAL && cameras!=0 then
    while 1 do
      i=Videooffsets()                 // Correct camera centers in layout
      if i<0 goto quit                 // Operator interrupted calibration
      if i==0 break                    // Centers corrected successfully
      if i==1 goto choosetype          // Error in parameters (impossible!)
      if i==2 goto install             // Change placement of the board
      if i==4 then                     // Request to find centers manually
        i=Manualcenters(1)             // Find centers manually
        if i<0 goto quit               // Operator interrupted calibration
      endif
    enddo
  endif
scanoffsets:
  verification=0                       // Main test
  if calmode==MODE_CAL then            // New calibration
    if usesides!=0 then                // No head movements if all excluded
      i=Scanoffsets(0)                 // Correct centers in layout
      if i<0 goto quit                 // Operator interrupted calibration
      if i==1 goto choosetype          // Error in parameters (impossible!)
      if i==2 goto install             // Change placement of the board
      if i==3 goto scanoffsets         // Repeat scanning
    endif
    Applyoffsets(0)                    // Apply offsets/temperature to layout
    i=Savelayout()                     // Save corrected layout to file
    diskvalid=0                        // Layout & corrs on disk don't match
    if i<0 goto quit                   // Operator interrupted calibration
    i=Loadlayout(0)                    // Reload corrected layout into tester
    layvalid=1                         // Layout in tester is valid
    corrvalid=0                        // Corrections in tester are zeroed
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Bad or no answer, try to reload tester
    if testertype==TT_S3 then
      i=Checkfocushysteresis()         // Check focus-related hysteresis on S3
      if i<0 goto quit                 // Operator interrupted calibration
    endif
    Activatesoftlanding(softland)      // Set soft landing
  else if calmode==MODE_3DCAL then
    Activatesoftlanding(softland)      // Set soft landing
    i=Fillcalibrators(C_VERAREA,FILL_MECH)
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto choosetype             // Error in parameters, retry
  else if calmode==MODE_VER then       // Prepare for video in same points
    i=Fillcalibrators(C_CALIBR+hverifytype,FILL_MECH)
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto choosetype             // Error in parameters, retry
  endif
  // Corrected layout is loaded to the tester. If tester is equipped with head
  // cameras, set brightness and contrast, verify camera adjustment and measure
  // X magnifications (assumed to be the same as Y).
  if headcams!=0 then
    Getheadcamscales()                 // Get old/default camera magnifications
  endif
  if (calmode==MODE_CAL || calmode==MODE_3DCAL) && headcams!=0 then
    while 1 do
      i=Headcambrightness(0,1)         // Adjust brightness and contrast
      if i<0 goto quit                 // Operator interrupted calibration
      i=Headcamcenters()               // Measure head camera offsets
      if i<0 goto quit                 // Operator interrupted calibration
      if i==0 break                    // Offsets measured corectly
    enddo
  else if calmode==MODE_VER && headcams!=0 then
    i=Headcambrightness(0,0)           // Adjust brightness and contrast
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  // If only C adjust is requested, skip unnecessary steps.
repeatelectro:
  if calmode==MODE_CADJ goto cadjonly
  // If requested, lower accelerations.
  if (calmode==MODE_CAL || calmode==MODE_3DCAL) &&                             \
    lowspeed!=0 && accelinvalid==0 then
    i=Setaccel(axhead/4.0,ayhead/4.0,axcam/4.0,aycam/4.0)
    if i<0 goto quit                   // Operator interrupted calibration
    if i==0 lowaccelset=1
  endif
  // Start electrical calibration.
  if usesides!=0 then                  // No head movements if all excluded
    i=Calibrateheads(0)                // Electrical calibration
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Error in parameters (impossible!)
    if i==2 goto install               // Change placement of the board
    if adjustcorr!=0 && $LAY.cameras==0 && headcams!=0 then
      // Corrections adjustment for tester with head cameras is active. Refine
      // and load head camera corrections.
      i=Adjustcorrections(0)
      if i<0 goto quit                 // Operator interrupted calibration
    endif
  endif
  // Start video calibration with dedicated cameras.
  if cameras!=0 then
    if demo==0 && (testertype==TT_A2 || testertype==TT_A2L ||                  \
      testertype==TT_A2H || testertype==TT_A3 || testertype==TT_A3L ||         \
      testertype==TT_A4)                                                       \
    then
      SYS.Softreset(0)                 // Otherwise deadlock is possible
    endif
    i=Calibratevideo(0)                // Video calibration
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Error in parameters (impossible!)
    if i==2 goto install               // Change placement of the board
  endif
  checkstat=1                          // Request to gather statistics on exit
  // Restore full accelerations.
  if lowaccelset!=0 then
    i=Setaccel(0.0,0.0,0.0,0.0)
    if i<0 goto quit                   // Operator interrupted calibration
    if i==0 lowaccelset=0
  endif
  // Currently 3-D calibration does not support head cameras. The reason is
  // simple: there is no single axis to align to.
  if calmode==MODE_3DCAL then
    Calculate3dfactors()               // Calculate tilts of Y and Z axii
    i=Check3dactive()                  // Ensure that 3-D corrections allowed
    if i<0 goto quit                   // Operator interrupted calibration
    i=Savelayout()                     // Save corrected layout to file
    diskvalid=1                        // Note that corrections are not changed
    if i<0 goto quit                   // Operator interrupted calibration
    i=Loadlayout(0)                    // Reload corrected layout into tester
    layvalid=1                         // Layout in tester is valid
    corrvalid=0                        // Corrections in tester are zeroed
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Bad or no answer, try to reload tester
    i=Loadcorr(-1,0,1)                 // Send new corrections to tester
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Bad or no answer, try to reload tester
    corrvalid=1                        // Corrections in tester are valid
    if hlog!=NULL fprintf(hlog,"3-D calibration finished\n")
    switch (caltype)                   // Report to calibrationlog.txt
      case 0,2: Strcpy(s,"precise")
      case 1,3: Strcpy(s,"fast")
      case 4:   Strcpy(s,"custom")
      default:  Strcpy(s,"undefined")
    endsw
    Addcalibrationrecord("3-D calibration successful (%s%s, %s mode)",         \
      smallboard?"small ":"",boardtype==0?"FR4":"glass",s)
    goto quit
  endif
  // Calculate correction files.
  if calmode==MODE_CAL then
    i=Corrall(1,0)                     // Correct fingers and cameras
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto repeatelectro         // Operator decided to repeat step
    i=Checkcenters()
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  Memcpy(cfing,c,Sizeof(c))            // Make backup of finger calibration
repeatcameras:
  // In case of head cameras, we must load head corrections to the tester and
  // zero headcam corrections. Then we can calibrate head cameras optically.
  if headcams!=0 then
    if calmode==MODE_CAL then
      for i=0,i<32,i++ do
        cext[i].mode=0                 // Effectively kills old headcam corrs
      enddo
      i=Loadcorr(-1,0,1)               // Send new finger corrections to tester
      if i<0 goto quit                 // Operator interrupted calibration
      if i>0 goto recheck              // Bad or no answer, try to reload tester
    endif
    i=Headcamfiducials(0,-1)           // Define head camera fiducials
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Unable to define fiducial
    i=Calibrateheadcams()              // Optical calibration of head cameras
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Error in parameters (impossible!)
    if i==2 goto install               // Change placement of the board
    if calmode==MODE_CAL then
      i=Corrall(1,1)                   // Correct head cameras
      if i<0 goto quit                 // Operator interrupted calibration
      if i==1 then                     // Operator decided to repeat step
        i=Headcambrightness(0,1)       // Re-adjust brightness and contrast
        if i<0 goto quit               // Operator interrupted calibration
        goto repeatcameras
      endif
    endif
    Memcpy(chcam,c,Sizeof(c))          // Make backup of head camera calibration
    Memcpy(c,cfing,Sizeof(c))          // Restore head calibration data
  endif
  // In verification mode, compare old and new calibrations and finish.
  if calmode==MODE_VER then
    verification=0                     // Yes, that's true...
    Fitcalibration()                   // Verify existing corrections
    i=0; goto quit                     // Verification finished
  endif
  Memset(shycor,0,Sizeof(shycor))      // Clear existing shuttle Y corrections
  i=Loadcorr(-1,0,1)                   // Send new corrections to tester
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto recheck                  // Bad or no answer, try to reload tester
  // If shuttle is positionable, calibrate shuttle.
shuttley:
  if testertype==TT_S3 then
    i=Calibrateshuttley(0)
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto shuttley               // Repeat shuttle Y calibration
    // During shuttle Y calibration with high offset the number of scan points
    // for some or even all rails may be set to zero. Savecorr() interpretes
    // this as not calibrated rail.
    Fillcalibrators(C_CALIBR,FILL_BOTH)
  endif
  if twostep==0 goto skipsteptwo
  // Case of two-step calibration: left shuttle is calibrated, repeat essential
  // steps with the right shuttle and match corrections.
  Drawcalboard(0,0,0,0)                // Redraw board without offset
  Memcpy(corrl,corr,Sizeof(corr))      // Preserve corrections for left shuttle
  Memcpy(hcaml,hcam,Sizeof(hcam))
  i=Loadcorr(-1,1,1)                   // Send zero correction data to tester
  corrvalid=0                          // Tester corrections are zeroed
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto recheck                  // Bad or no answer, try to reload tester
  // Ask user to replace the calibration board.
  Calculateboardshift(1)
  Fillcalibrators(C_CALIBR,FILL_BOTH)
  if twostep==2 goto repeatel2         // Second board is installed and checked
install2:
  i=InstallglassboardLM(1)             // Install board in S3 right shuttle
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto recheck                  // Bad or no answer, try to reload tester
chkplace2:
  Drawcalboard(0,0,0,0)                // Redraw board without offset
  i=Checkplacement()                   // Check that board is electrically ok
  if i<0 goto quit                     // Operator interrupted calibration
  if i==1 || i==2 goto chkplace2       // Retry check of calibration board
  if i==3 goto install2                // Change placement of the board
chkbending2:
  i=Checkbending()                     // Check that board is not bent
  if i<0 goto quit                     // Operator interrupted calibration
  if i==1 || i==2 goto chkbending2     // Retry check of board bending
  if i==3 goto install2                // Change placement of the board
  i=Heatfingers(warmuptime)            // Make warmup & shake calibration board
  if i<0 goto quit                     // Operator interrupted calibration
scanoffsets2:
  i=Checkoffsets()                     // Verify board placement
  if i<0 goto quit                     // Operator interrupted calibration
  if i==2 goto install2                // Change placement of the board
  if i==3 goto scanoffsets2            // Repeat scanning
repeatel2:
  if lowspeed!=0 && accelinvalid==0 then
    i=Setaccel(axhead/4.0,ayhead/4.0,axcam/4.0,aycam/4.0)
    if i<0 goto quit                   // Operator interrupted calibration
    if i==0 lowaccelset=1
  endif
  i=Calibrateheads(1)                  // Electrical calibration
  if i<0 goto quit                     // Operator interrupted calibration
  if i==1 goto choosetype              // Error in parameters (impossible!)
  if i==2 goto install2                // Change placement of the board
  if cameras!=0 then
    if demo==0 && (testertype==TT_A2 || testertype==TT_A2L ||                  \
      testertype==TT_A2H || testertype==TT_A3 || testertype==TT_A3L ||         \
      testertype==TT_A4)                                                       \
    then
      SYS.Softreset(0)                 // Otherwise deadlock is possible
    endif
    i=Calibratevideo(1)                // Video calibration
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Error in parameters (impossible!)
    if i==2 goto install2              // Change placement of the board
  endif
  // Restore full accelerations.
  if lowaccelset!=0 then
    i=Setaccel(0.0,0.0,0.0,0.0)
    if i<0 goto quit                   // Operator interrupted calibration
    if i==0 lowaccelset=0
  endif
  // Note that corrections in the central point for the right shuttle may be
  // very high. I don't call Checkcenters() after corrections are calculated.
  i=Corrall(1,0)                       // Correct fingers and cameras
  if i<0 goto quit                     // Operator interrupted calibration
  if i==1 goto repeatel2               // Operator decided to repeat step
  Memcpy(cfing,c,Sizeof(c))            // Make backup of finger calibration
repeatcam2:
  if headcams!=0 then
    for i=0,i<32,i++ do
      cext[i].mode=0                   // Effectively kills old headcam corrs
    enddo
    i=Loadcorr(-1,0,1)                 // Send new finger corrections to tester
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Bad or no answer, try to reload tester
    i=Headcamfiducials(0,-1)           // Define head camera fiducials
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 goto choosetype            // Unable to define fiducial
    i=Calibrateheadcams()              // Optical calibration of head cameras
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 || i==2 goto install2      // Change placement of the board
    i=Corrall(1,1)                     // Correct head cameras
    if i<0 goto quit                   // Operator interrupted calibration
    if i==1 then                       // Operator decided to repeat step
      i=Headcambrightness(0,1)         // Re-adjust brightness and contrast
      if i<0 goto quit                 // Operator interrupted calibration
      goto repeatcam2
    endif
    Memcpy(chcam,c,Sizeof(c))          // Make backup of head camera calibration
    Memcpy(c,cfing,Sizeof(c))          // Restore head calibration data
  endif
  // Fit correction data sets together.
  Matchsteps()
  // If shuttle is positionable, calibrate shuttle.
shuttley2:
  if testertype==TT_S3 then
    i=Loadcorr(-1,0,1)                 // Send new corrections to tester
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto recheck                // Bad or no answer, try to reload tester
    i=Calibrateshuttley(1)
    if i<0 goto quit                   // Operator interrupted calibration
    if i>0 goto shuttley2              // Repeat shuttle Y calibration
    // During shuttle Y calibration with high offset the number of scan points
    // for some or even all rails may be set to zero. Savecorr() interpretes
    // this as not calibrated rail.
    Fillcalibrators(C_CALIBR,FILL_BOTH)
  endif
skipsteptwo:
  // Ask to correct offset between top and bottom fingers and cameras.
  if measureoffset!=0 && cameras==0x3 && (testertype==TT_A5 ||                 \
    testertype==TT_A5L || testertype==TT_A6 || testertype==TT_S1 ||            \
    testertype==TT_S2 || testertype==TT_A7 || testertype==TT_A8) then
    i=Topbottomoffset()
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  i=Savecorr()                         // Save corrections to disk
  if i<0 goto quit                     // Operator interrupted calibration
  diskvalid=1                          // Layout matches corrections on disk
  corrvalid=1                          // Corrections in tester are valid
  if hlog!=NULL fprintf(hlog,"Calibration finished\n")
  switch (caltype)                     // Report to calibrationlog.txt
    case 0,2: Strcpy(s,"precise")
    case 1,3: Strcpy(s,"fast")
    case 4:   Strcpy(s,"custom")
    case 6:   Strcpy(s,"two-step")
    case 7:   Strcpy(s,"two-board")
    default:  Strcpy(s,"undefined")
  endsw
  Addcalibrationrecord("Calibration successful (%s%s, %s mode)",               \
    smallboard?"small ":"",boardtype==0?"FR4":"glass",s)
  // Last check for A5/A6 (but not S1): verify that points with maximal alowed
  // deviations are reachable.
  if testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 then
    i=Verifylimits(0)                  // Verify limits of working area
    if i<0 goto quit                   // Operator interrupted calibration
    if i==2 goto install               // Operator decided to repeat calibration
  endif
cadjonly:
  // Make optional capacity adjustment, allowed only for two-sided A6/8+ with
  // headcams on FR4 board.
  if calmode!=MODE_VER && testertype==TT_A6 && boardtype==0 &&                 \
    headcams!=0 && usesides==0x3 && lasttop>firsttop &&                        \
    firstbot==firsttop+$LAY.nfing/2 && lastbot==lasttop+$LAY.nfing/2           \
  then
    if calmode==MODE_CAL then
      i=Confirmcadjust()               // Ask operator to make C adjust
      if i==0 goto nocadj              // Operator doesn't want C adjust
      cadjax=0.0                       // Linear regression factors for X
      cadjbx=$LAY.xoffset/1000.0
      cadjay=1.0                       // Linear regression factors for Y
      cadjby=0.0
    else
      i=Headcamfiducials(0,-1)         // Define head camera fiducials
      if i<0 goto quit                 // Operator interrupted calibration
      if i==1 goto choosetype          // Unable to define fiducial
      i=Headcamscancadjust()           // Scan board for C adjust
      if i==1 goto install             // Unable to find crosses
      if i==2 goto choosetype          // Unable to scan board
    endif
    if i<0 goto quit                   // Operator interrupted calibration
    i=Makecadjust(0)                   // Adjust on-head capacities
    if i<0 goto quit                   // Operator interrupted calibration
    if i==2 goto install               // Operator pressed Cancel button
  endif
  if calmode==MODE_CADJ then           // C adjustment only
    Activatesoftlanding(0)             // Set default soft landing state
    goto quit
  endif
nocadj:
  // Calibration as such is finished. Run verification and/or view results.
  if calmode==MODE_CAL && autoverify!=0 then
    autoverified=1                     // Calibration data unusable
    verification=1                     // Display verification data
    if usesides!=0 then                // No head movements if all excluded
      i=Verifyscan()                   // Verify electrical calibration
      if i<0 goto quit                 // Operator interrupted verification
      Memcpy(cfing,c,Sizeof(c))        // Make backup of finger verification
    endif
    if i==0 then
      if cameras!=0 then
        i=Verifyvideo()                // Verify dedicated cameras
        Memcpy(cfing,c,Sizeof(c))      // Make backup of camera verification
      else if headcams!=0 then
        i=Calibrateheadcams()          // Verify head cameras
        Memcpy(chcam,c,Sizeof(c))      // Make backup of head camera calibration
      endif
    endif
    if i==0 then
      Memcpy(c,cfing,Sizeof(c))        // Restore head calibration data
      i=Viewresults()                  // View results of verification
      if i<0 goto quit                 // Operator interrupted verification
    endif
  endif
  while 1 do
    j=Postprocess(0)                   // Ask what to do next
    if j==1 then                       // Electrical verification
      verification=1                   // Display verification data
      autoverified=1                   // Calibration data unusable
      Memcpy(c,cfing,Sizeof(c))        // Restore head calibration data
      i=Verifyscan()                   // Verify electrical calibration
      Memcpy(cfing,c,Sizeof(c))        // Make backup of finger verification
      if i==0 i=Viewresults()          // View results of verification
    else if j==2 then                  // Optical verification
      verification=1                   // Display verification data
      autoverified=1                   // Calibration data unusable
      if cameras!=0 then
        Memcpy(c,cfing,Sizeof(c))      // Restore head calibration data
        i=Verifyvideo()                // Verify optical calibration
        Memcpy(cfing,c,Sizeof(c))      // Make backup of finger verification
      else if headcams!=0 then
        i=Calibrateheadcams()          // Verify head cameras
        Memcpy(chcam,c,Sizeof(c))      // Make backup of headcam verification
      endif
      if i==0 i=Viewresults()          // View corrections
    else if j==3 then                  // View results of verification/scanning
      Memcpy(c,cfing,Sizeof(c))        // Restore head calibration data
      verification=0                   // Display correction data
      i=Viewresults()                  // View corrections
    else if j==4 then                  // View head system data
      Memcpy(c,cfing,Sizeof(c))        // Restore head calibration data
      i=Viewinterna()                  // View internal calibration data
    else if j==5 then
      Memcpy(c,chcam,Sizeof(c))        // Restore head camera calibration data
      verification=0                   // Display correction data
      i=Viewresults()                  // View head camera corrections
    else if j==6 then                  // View head camera system data
      Memcpy(c,chcam,Sizeof(c))        // Restore head camera calibration data
      i=Viewinterna()                  // View internal head camera data
    else if j==7 then                  // Verify selected crosses manually
      i=Verifymanually()               // Manual verification
    else if j==8 then                  // View Y encoder data
      i=Viewyencoder()                 // View internal Y encoder data
    else
      break                            // End of calibration
    endif
    if i<0 break                       // Operator interrupted verification
  enddo
  Activatesoftlanding(0)               // Set default soft landing state
  goto quit
  // Quick head adjustment: corrects head corrections using opposite camera.
headadjust:
  assumeemptyshuttle=0                 // Check that shuttle is empty
  i=Presetparm(0)                      // Preset parms like radius or cameras
  if i<0 goto quit                     // Operator interrupted calibration
  acc=Max(1.0,Min(accuracy*1000,1.0))  // Set positioning accuracy
  Fillcalibrators(C_CORNER,FILL_MECH)  // Preset other important parameters
  if demo==0 then                      // No log file in demo mode
    i=Openlogfile(caltype)             // Create log file and write parameters
    if i<0 goto quit                   // Operator interrupted calibration
  endif
  i=Readoldcorr(0)                     // Load old corrections from disk
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto recheck                  // Bad or no answer, try to reload tester
  i=Isquickallowed()                   // Check whether quick corrs allowed
  if i<0 goto quit                     // Operator interrupted calibration
  if i==0 then                         // Quick corrections are not allowed
    quickcorrdisabled=1                // Disable quick head corrections
    caltype=0; goto choosetype         // Start ordinary calibration
  endif
  i=Loadcorr(-1,0,1)                   // Send old corrections to tester
  if i<0 goto quit                     // Operator interrupted calibration
  if i>0 goto recheck                  // Bad or no answer, try to reload tester
  corrvalid=1                          // Corrections are valid again
headshuttle:
  i=Removeboards()                     // Remove boards from shuttle
  if i<0 goto quit                     // Operator interrupted calibration
nexthead:
  head=Quickselecthead()               // Select head to correct
  if head<0 goto quithead              // Operator finished the calibration
  if head>=$LAY.nfing*2 then
    caltype=0; goto choosetype         // Start ordinary calibration
  endif
  i=Quickadjusthead(head)
  if i<0 goto quit                     // Operator interrupted calibration
  if i==1 goto headshuttle
  goto nexthead
  // Calibration replay: troubleshooting using protocol file.
replaycal:
  i=Replaycalibration()
  if i!=0 goto quit                    // Operator interrupted calibration
  operator=0
  i=Savecorr()                         // Save corrections to disk
  if i<0 goto quit                     // Operator interrupted calibration
  while 1 do
    j=Postprocess(1)                   // Ask what to do next
    if j==3 then                       // View results of verification/scanning
      Memcpy(c,cfing,Sizeof(c))        // Restore head calibration data
      verification=0                   // Display correction data
      i=Viewresults()                  // View corrections
    else if j==4 then                  // View head system data
      Memcpy(c,cfing,Sizeof(c))        // Restore head calibration data
      i=Viewinterna()                  // View internal calibration data
    else if j==5 then
      Memcpy(c,chcam,Sizeof(c))        // Restore head camera calibration data
      verification=0                   // Display correction data
      i=Viewresults()                  // View head camera corrections
    else if j==6 then                  // View head camera system data
      Memcpy(c,chcam,Sizeof(c))        // Restore head camera calibration data
      i=Viewinterna()                  // View internal head camera data
    else if j==8 then                  // View Y encoder data
      i=Viewyencoder()                 // View internal Y encoder data
    else
      break                            // End of calibration
    endif
    if i<0 break                       // Operator interrupted verification
  enddo
  goto quit
quithead:
  Quickheadwarning()                   // Warn about low accuracy
quit:
  Bcsetini()                           // Save brightness & contrast to .ini
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8 then
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,0")
    SERV.Cmdimm(32,"OUTPORT32 ALL 0x10010003,0")
  endif
  if checkstat && (testertype==TT_A5 || testertype==TT_A5L ||                  \
    testertype==TT_A6 || testertype==TT_S1 || testertype==TT_S2 ||             \
    testertype==TT_S3 || testertype==TT_A7 || testertype==TT_A8) then
    Processstat()                      // Process movement statistics
  endif
  if layvalid==0 || corrvalid==0 || diskvalid==0 then
    Warnoperator()                     // Warn to reboot tester
  endif
  if hlog!=NULL then                   // Close log file
    if i<0 then
      fprintf(hlog,"Script interrupted:        ")
    else
      fprintf(hlog,"Script finished:           ")
    endif
    Strtime(s,   "%a %d-%b-%Y %H:%M",0,0)
    fprintf(hlog,"%s\nBye!\n\n",s)
    Fclose(hlog)
  endif
  if lowaccelset!=0 then
    Setaccel(0.0,0.0,0.0,0.0)          // Restore old accelerations
  endif
  if ((testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&        \
    unloadboard!=0 && (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                 \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO)) ||                               \
    (testertype==TT_A8 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO) ||           \
    (testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO) then
    Unloadboard()                      // Unload board if L&M shuttle
  else
    if demo==0 SYS.Softreset(0)
  endif
  if Embedded()!=0 then
    SERV.Cmdimm(32,"$LIGHTS WAITING")  // Indicate that calibration is finished
  endif
  if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    destroy hexit                      // Psychology...
    hexit=NULL
    UnloadboardEPCOS()                 // Ask to remove board if EPCOS shuttle
  endif
  if startlayout then
    SYS.Compile("layout.scr",1)
    SYS.Start("LAYOUT",0,"")
  endif
end

