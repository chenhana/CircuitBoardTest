#include "ls.icl"                  // System definitions and functions
#include "or.icl"                // Command & error mnemonics
#include "pa.icl"                  // Rich Text Format extentions
#cmdbuff 34                            // 32+2 command buffers
#zeroid                                // Intercept tester answers with zero ID

#define VERSION        "19.02"
#define DESCRIPTION    "Verification of ultralow R measurements"

// 1.01: Needle verification.
// 1.02: Bugfix in needle histogramm gathering.
// 1.03: Scanning of pads instead of crosses.
// 1.04: Support for L&M automation.
// 1.05: Certification mode.
// 1.06: Protocolling of single measurements.
// 1.07: Corrected bug in correction of the own resistance of wires.
// 1.08: Customer name and additional information.
// 1.09: Calibration of line resistance.
// 1.10: Support for S1 and S2.
// 1.11: Bugfixes (string overflow, missing alternative position).
// 1.12: Increased distance between the needles on the same pad (new board).
// 1.13: Correction of inductance measurements.
// 1.14: Support for combo R/C board.
// 1.15: Range 1 phase of inductance measurements on combo R/C board.
// 1.16: Adjustment of individual needle resistances.
// 1.17: Support for A7/A8.
// 1.18: Drawboard() draws shuttle by itself.
// 1.19: Basic support for A7a.
// 1.20: Takes into account different line width on combo board.
// 1.21: Basic support for A8a.
// 1.22: Support for A7/20 and EL208-1.
// 1.23: Support for S3 and additional layout extentions.
// 1.24: Uses external USB temperature sensor if internal is absent.
// 1.25: Bug: wrong contact positions for A7/16.
// 1.26: Synchronous head movements in Kelvin tests.
// 1.27: L&M shuttle settings are not restored when test is finished.
// 1.28: Optional 1 mOhm resistor instead of 10 Ohm.
// 1.29: Bugfix for A7/16 with XXL board.
// 1.30: Support for testers with split shuttle.
// 1.31: Focus for S3.
// 1.32: Test options (duration, delay, current).
// 1.33: Support for S3 split shuttle.
// 1.34: Another bugfix for A7/16 with XXL board.
// 1.35: Crash while unloading board via Parameter Server.

// Used resources.
#bitmap "logo"<"guoke.bmp"               // All bitmaps are compressed
#bitmap "bkground"<"aluminum.bmp"      // Alternative: "pcb1.bmp"
#bitmap "unknown"<"unknown.bmp"
#bitmap "r-rcsel"<"r-rcsel.bmp"

// Dimensions of test window.
#define MAINX          600
#define MAINY          400
#define SPLIT          330
#define SERVY          25
#define LEFTX          320             // (SPLIT-10)
#define LEFTY          365             // (MAINY-SERVY-10)
#define GRAPHY         280
#define RIGHTX         265             // (MAINX-SPLIT-5)
#define RIGHTY         335             // (MAINY-SERVY-SERVY-15)
#define USERY          250

// Constants determining tester type.
#define TT_WRONG       (-1)
#define TT_UNDEF       0
#define TT_A1          1
#define TT_A2          2
#define TT_A2L         3
#define TT_A2H         4
#define TT_A3          5
#define TT_A3L         6
#define TT_A4          7
#define TT_A5          8
#define TT_A5L         9
#define TT_A6          10
#define TT_S1          11
#define TT_S2          12
#define TT_A7          13
#define TT_A8          14
#define TT_S3          15
#define TT_M2          16

// Extract from the header of extended layout.
#define HCZ_VALID      0x80000000      // Z axis type in layout valid
#define HCZ_CONTMASK   0x0000FF00      // Mask to extract Z contact sensor
#define   HCZ_CONTDEF  0x00000000      // Default needle, no contact sensor
#define   HCZ_CONTSPL  0x00000100      // Soft splinogramm with opto sensor
#define   HCZ_CONTHSPL 0x00000200      // Hard splinogramm with opto sensor
#define   HCZ_CONTEMU  0x00000400      // Standard needle on soft touch adapter
#define   HCZ_CONTHPS  0x00000500      // Hard touch needle with opto sensor
#define   HCZ_CONTSTD  0x00000800      // Standard needle, developed by IBM
#define   HCZ_CONTSKP  0x00001000      // Soft Kelvin with two parallelogramms

// Options of measurement card.
#define HCM_HV1MA      0x00000001      // Force 1 mA during HV measurements
#define HCM_STRICT     0x00000002      // 20% stricter self-test
#define HCM_NOCTCHK    0x00000004      // Don't check contacts (except ExactR)
#define HCM_PARCONT    0x00000008      // Check influence of parallel contacting
#define HCM_NOACCEL    0x00000010      // Do not accelerate reed relays
#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements
#define HCM_CTOEXT     0x00000040      // Calibrate capacity to shuttle (extant)
#define HCM_ISOEANT    0x00000080      // External antennas isolated
#define HCM_FILTMASK   0x00000F00      // Mask to extract signal filtering
#define   HCM_FNONE    0x00000000      // No signal filtering
#define   HCM_F500K    0x00000100      // 500 kHz filter
#define   HCM_F100K    0x00000200      // 100 kHz filter
#define   HCM_F20K     0x00000300      // 20/50 kHz filter
#define HCM_FILTERC    0x00001000      // Filter C measurements over 300 pF
#define HCM_EXRLONG    0x00002000      // Long EXACTR with 300 mA source
#define HCM_AUTOEANT   0x00004000      // Automatic antenna 1 for all C
#define HCM_HVTYPE     0x000F0000      // Mask to extract type of HV elecronics
#define   HCM_HV500    0x00000000      // Card is capable of 500 V HV
#define   HCM_HV1000   0x00010000      // Card is capable of 1000 V HV
#define   HCM_HVAUTO   0x00070000      // Autodetect HV capabilities
#define HCM_DISCONN    0x00100000      // Disconnect from bus after measurement
#define HCM_EXRNOISY   0x00200000      // Accept noisy EXACTR measurements

// Definition of global error bits.
#define GE_BOOT        0x0001          // Tester must be rebooted
#define GE_HARDWARE    0x0002          // Pneumatics/shuttle out of order
#define GE_IOERROR     0x0004          // I/O error detected
#define GE_COMMAND     0x0008          // Command sending error
#define GE_MEAS        0x0010          // Resistance measurements impossible

// Layout configuration bits in $LAY.config.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae

// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMSPLIT     0x20000000      // L&M auto split shuttle
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_SPLITAUTO   (LC_LMSPLIT|LC_A2LOADER)
#define LC_LMAUTO      (LC_LM|LC_A2LOADER)
#define LC_LMS2AUTO    (LC_LMS2|LC_A2LOADER)
#define LC_EPCOSAUTO   (LC_EPCOS|LC_A2LOADER)

// Type of automation.
#define AUTO_UNKNOWN   (-1)            // Unknown type of automation
#define AUTO_NONE      0x00            // Manual mode
#define AUTO_ERROR     0x01            // Attempt to get type was unsuccessfull
#define AUTO_DAMAGED   0x80            // Automation out of order
#define AUTO_SHUTTLE   0x81            // Automatic A2/A4/A6 shuttle
#define AUTO_A2        0x82            // Automatic A2 loader connected
#define AUTO_A4SEMI    0x83            // A4 output unit connected
#define AUTO_A4FULL    0x84            // Full A4 automation
#define AUTO_A6SEMI    0x85            // A6 output unit connected
#define AUTO_A6FULL    0x86            // Full A6 automation
#define AUTO_A5LMMAN   0x90            // A5 L&M automation in manual mode
#define AUTO_A5LMSEMI  0x91            // A5 L&M semiautomat
#define AUTO_A5LMFULL  0x92            // Full A5 L&M automation
#define AUTO_S2LMMAN   0x98            // S2 with manual shuttle
#define AUTO_S2LMSEMI  0x99            // S2 L&M in manual load/unload mode
#define AUTO_S2LMFULL  0x9A            // Full robotic S2 L&M automation
#define AUTO_S2LMDCF   0x9B            // S2 with double CF shuttle
#define AUTO_A7LMMAN   0xB0            // A7 L&M automation in manual mode
#define AUTO_A7LMSEMI  0xB1            // A7 L&M semiautomat
#define AUTO_A7LMFULL  0xB2            // Full A7 L&M automation
#define AUTO_A7LMNONE  0xB3            // A7 L&M pure manual mode
#define AUTO_A8LMMAN   0xB4            // A8a L&M automation in manual mode
#define AUTO_A8LMSEMI  0xB5            // A8a L&M semiautomat
#define AUTO_A8LMFULL  0xB6            // Full A8a L&M automation
#define AUTO_SPLITMAN  0xB8            // Split shuttle automation, manual mode
#define AUTO_SPLIT     0xBA            // Full split shuttle automation
#define AUTO_SPLNONE   0xBB            // Split shuttle automation, pure manual

// Features supported by measurement card.
#define MF_CONTAIR     0x00000001      // Contact check corrections supported
#define MF_CRT         0x00000002      // CRT measurements supported
#define MF_KELVSCAN    0x00000004      // Kelvin scan supported
#define MF_FIXCDC      0x00000008      // Forcing charge-discharge in FastC
#define MF_CCORR       0x00000010      // Calibration of capacitive phase
#define MF_SLAVE       0x00000020      // Supports second measurement card
#define MF_CPHASE      0x00000040      // C phase corrections from layout
#define MF_MULTIC      0x00000080      // Multiple C supported
#define MF_DSCAN       0x00000100      // Charge-discharge scan supported
#define MF_CRTCONCE    0x00000200      // Permanent CRT calibration in air
#define MF_UNIC        0x00000400      // Universal C supported
#define MF_CONCE       0x00000800      // Permanent C calibration in air
#define MF_HVINITEX    0x00001000      // Extended HV initialization (meas card)
#define MF_POSTAIR     0x00002000      // C in air after M_FASTC (meas card)
#define MF_EXTMEAS     0x00004000      // External measurement device
// Measurement features supported by crate.
#define MF_EXTLAINIT   0x01000000      // Extended S_LAINIT supported
#define MF_RETEST      0x02000000      // Instant retest (M_LIMITHI, M_LIMITLO)
#define MF_HVCRATEEX   0x04000000      // Extended HV initialization (crate)
#define MF_POSTCRATE   0x08000000      // C in air after M_FASTC (crate)
#define MF_RLINIT      0x10000000      // S_RLINIT supported (crate)
// Reserved for high-level software, not used by crate.
#define MF_VALID       0x80000000      // Features valid

// Supported external devices.
#define EXTD_NONE      0               // No external device attached
#define EXTD_HM8118    1               // Hameg HM8118 bridge

// Layout of version of external measurements.
#define EXTM_VERSION   0xFFFFFF00      // Mask to extract version of ext corrs
#define EXTM_RLCORR    0x00000004      // Whether extern R-L corrections valid

#define NPOINT         8               // Number of pads in X direction
#define VSTEP          0.5             // Camera moves in 0.5 mm steps
#define MAXERR         4.5             // Maximal error in fiducial position

// Random deviation, in order to prevent pads from wearing out. Pads are at
// least 2*DISTX+2*DELTA wide and 2*DISTY+2*DELTA high.
#define DELTA          0.25            // Random deviation, millimeters
#define DISTXOLD       0.35            // X distance between needles, mm
#define DISTYOLD       0.40            // Y distance from border, millimeters
#define DISTXNEW       1.00            // X distance between needles, mm
#define DISTYNEW       1.00            // Y distance from border, millimeters

// Electrical parameters.
#define RLINED         0.00001613      // R of dedicated line, Ohm/mm
#define RLINEC         0.00002142      // R of combo line, Ohm/mm
#define ESIGMA         0.0005          // Expected dispersion for needle test
#define BESTLIM        90              // Limit for very good quality
#define GOODLIM        60              // Limit for good quality
#define POORLIM        40              // Limit for poor quality
// Certification limits.
#define KABSERR        0.002           // Kelvin R error 0.002 Ohm + 1%
#define KRELERR        0.01
#define EABSERR        0.100           // Exact R error 0.100 Ohm + 2%
#define ERELERR        0.02
#define MAXOPEN        2               // Max number of high resistances
#define MAXSHORT       10              // Max number of pin shorts per cell/head
#define MAXNOCT        4               // Max number of no cont per cell/head
#define MAXBAD         5               // Max number of bad meas per R value
#define MAXRERR        2               // Max number of out-of-range per cell
// Inductance adjustment.
#define LCORR          0.000452        // Inductance of 1 mm of wire, uH
#define LRANGE         0.070           // Max interrange difference, uH
#define LSIGMA         0.015           // Max dispersion for range adjust, uH

typedef struct t_layout $LAY           // Create layout-compatible types
typedef struct t_extlay $EXTLAY

char   xnamed[NPOINT][25] = {        \ // Components on dedicated BEL373-1
  "R00    -56    0    1.000",        \ // Leftmost pad
  "NC1    -42    0    1.000",        \ // Left no contact
  "R01    -28    0    1.000",        \ // R 0.010 Ohm
  "R10    0      0    1.000",        \ // R 0.100 Ohm
  "1R0    28     0    1.000",        \ // R 1.000 Ohm
  "NC2    42     0    1.000",        \ // Right no contact
  "10R    56     0    1.000",        \ // R 10.00 Ohm or 0.001 Ohm
  "***    56     0    1.000" }         // Dummy pad definition

char   xnamec[NPOINT][25] = {        \ // Components on combo R/C board
  "R00    -19.55 0    0.357",        \ // Leftmost pad
  "NC1    -10    0    1.000",        \ // Left no contact
  "R01    0      0    1.070",        \ // R 0.010 Ohm
  "R10    19.55  0    1.000",        \ // R 0.100 Ohm
  "1R0    39.10  0    1.000",        \ // R 1.000 Ohm
  "NC2    49.10  0    1.000",        \ // Right no contact
  "10R    58.65  0    0.948",        \ // R 10.00 Ohm or 0.001 Ohm
  "30R    78.20  0    1.000" }         // R 30.00 Ohm

char   xnamex[NPOINT][25] = {        \ // Components on XXL board
  "R00    -19.55 0    0.400",        \ // Leftmost pad
  "NC1    -10    0    1.000",        \ // Left no contact
  "R01    0      0    1.050",        \ // R 0.010 Ohm
  "R10    19.55  0    1.000",        \ // R 0.100 Ohm
  "1R0    39.10  0    1.000",        \ // R 1.000 Ohm
  "NC2    49.10  0    1.000",        \ // Right no contact
  "10R    58.65  0    1.000",        \ // R 10.00 Ohm or 0.001 Ohm
  "30R    78.20  0    1.050" }         // R 30.00 Ohm

char   xname[NPOINT][25]

float  xpos[NPOINT]                    // Extracted X coordinate of the pad
float  value[NPOINT]                   // Extracted value associated with pad
float  linefactor[NPOINT]              // Resistance multiplier for rline
int    scanrail=-1                     // -1: scan crosses, >=0: scan pads
int    is1mohm                         // 0: 10 Ohm, 1: 1 mOhm resistor
float  crossx[2]                       // Board X coordinates of 2 scan crosses
float  crossy[2]                       // Board Y coordinates of 2 scan crosses
int    crosstype                       // Crosses used for scanning
float  crossdist                       // Expected distance between crosses

handle hmain                           // Main window
handle hexit                           // Button "Close"
handle hserv,hleft,hright              // Left and right subwindows
handle hinfo                           // Current status of test
handle hlog                            // Log file (text format)
int    txtok                           // Non-zero if .TXT log file open
int    rtfok                           // Non-zero if .RTF log file open
char   expl[80]                        // Buffer for .TXT explanation line
int    nexpl                           // Number of chars in explanation line
int    largeexplanation                // Explanation in large font

char   crateversion[128]               // Version of loaded crate software
char   layoutversion[128]              // Version of loaded layout
char   headversion[128]                // Version of loaded head software
int    features                        // Features of measurement card, MF_xxx
int    maxcurrent                      // Max current for ExactR, mA
int    duration                        // Measurement: 0-S, 1-LONG, 2-XL, 3-XXL
int    contactdelay                    // Index of delay after contact, ms
int    testcurrent                     // Index of test current
int    automationtype                  // Type of automation, AUTO_xxx
int    isauto                          // Whether half- or full-automate
int    layoutchanged                   // Layout is changed
int    loadchanged                     // Loader is closed
int    oversurface[32]                 // No. of contacts over surface per head
int    used[32]                        // Head is allowed for adjustment
int    globalerr                       // Global asynchronous error recognized
int    boardtype                       // 0: old, 1: new combined, 2: A7 XXL
float  rowdist                         // Distance between rows of pads, mm
int    islargepads                     // 1 if large pads (ca. 6x6 mm)
float  ypos[32]                        // Y coordinate of pads (board coords)
float  yalt[32]                        // Alternative Y coordinate (board)
float  yshift                          // Vertical shift of test board
int    testertype                      // Type of tester (TT_xxx)
int    testersides                     // Bit 0x1: top, 0x2: bottom rails
int    usesides                        // Bit 0x1: top, 0x2: bottom rails
int    firstrail                       // First rail on the top side
int    lastrail                        // Last rail on the top side
int    maxrail                         // Highest rail on the top side
float  leftvlimit                      // Left X limit for video camera
float  rightvlimit                     // Right X limit for video camera
float  pos1x,pos1y                     // First ref cross (tester coordinates)
float  pos2x,pos2y                     // Second ref cross (tester coordinates)
float  linewidth                       // Expected width of cross, 200 or 300 um
float  headcamradius                   // Radius of head cameras, millimeters
char   lmteachin[5][256]               // Learned shuttle settings
int    nlmteachin                      // Number of valid lmteachin
int    protall                         // Protocol all measurements
char   customer[80]                    // Name of the customer
char   extra[510]                      // Additional information
float  rline                           // Resistance of 155/250-mm line, Ohm
int    pulledshuttle                   // Shuttle for A8eaPreparePullCalib or -1

int    strokev=50                      // Stroke, mm/s
int    strokep=50                      // Pressure, gramm or units
float  strokez=6.0                     // Height, millimeters
float  pfactor=1.0                     // Pressure factor (1 or 10)

float  shuttlex,shuttley               // Position of board in shuttle
float  convsfi,convcfi                 // Board rotation and shrinkage
float  convdx,convdy                   // Board offset

#define NSLOT          5               // Number of resistors to test
#define NTOTAL         6               // Number of resistors and opens to test
#define NSTROKE        3               // Number of strokes to test
#define NSTROKE1       4               // (NSTROKE+1)
#define NHIST          131             // Number of bars in histogram

int vlist[NSTROKE] = {               \ // Strokes
  40, 50, 60 }
int plist[NSTROKE] = {               \ // Pressures
  30, 50, 80 }

handle hgraph                          // Histogram
handle hrail[17]                       // Rail selection (16: all rails)
handle hslot[NTOTAL]                   // Resistance selection
handle hstroke[NSTROKE1]               // Stroke selection and summary
handle hhead[32]                       // Head selection

// Individual per-camera brightness and contrast.
int    individualbc                    // Whether individual brightness/contrast
handle hbrititle                       // Brightness title
handle hbrightness                     // Brightness control
handle hctrtitle                       // Contrast title
handle hcontrast                       // Contrast control
handle hilltop                         // Top illumination control
handle hillskew                        // Skew illumination control
handle hilllong                        // Long exposition control
handle hfoctitle                       // Focus title
handle hfocusup                        // Focus up
handle hfocus                          // Z camera position
handle hfocusdn                        // Focus down

int    cameras                         // Dedicated cameras used in test
int    headcams                        // Head cameras used in test
int    illtype                         // Illumination (0x3:on,0x4:top,0x8:skew)
int    longexp                         // Long exposition
int    brightness[32]                  // Individual brightness settings
int    contrast[32]                    // Individual contrast settings
int    bchead                          // Head selected for individual bri/ctr
int    focus[2]                        // Focus position of dedicated camera
int    updatefocus[2]                  // Set focus of dedicated camera

int    selectionmode                   // 0: rails, 1: heads
float  rexp[2][NTOTAL]                 // Expected R, 10 Ohm/1 mOhm modi
float  histstep                        // Histogram step, Ohms
// Resuls of resistance (rail) test.
int    showrail                        // Statistics for rail (16: all rails)
int    showslot                        // Statistics for resistance
int    rhist[NTOTAL][17][NHIST]        // Histograms for rails
float  rstat[NTOTAL][17][5]            // Rail resistance statistics
int    rbad[NTOTAL][17]                // Number of bad measurements for rails
int    ropens[NTOTAL][17]              // Number of opens (R>100 Ohm) for rails
int    rnoct1[NTOTAL][17]              // Number of nocontacts left for rails
int    rnoct2[NTOTAL][17]              // Number of nocontacts right for rails
// Results of verification (head test).
int    showhead                        // Statistics for head
int    showstroke                      // Statistics for stroke (NSTROKE: summ)
int    fhist[NSTROKE][32][NHIST]       // Histograms for heads
float  fstat[NSTROKE][32][5]           // Head resistance statistics
int    fbad[NSTROKE][32]               // Number of bad measurements for heads
int    fopens[NSTROKE][32]             // Number of opens (R>100 Ohm) for heads
int    fnoct[NSTROKE][32]              // Number of nocontacts for heads
int    fshortscu[NSTROKE][32]          // Number of shorts at copper for heads
int    fshortsfr[NSTROKE][32]          // Number of shorts at FR4 for heads
int    fquality[NSTROKE][32]           // Quality of needle
int    fresult[32]                     // Final results (-1: bad, 1: good)

// Variables used by inductance adjustment.
int    intladjusted                    // Internal inductivity adjusted


char meas[2][NTOTAL][32] = { {       \ // List of meas tasks/values, 10/.001 Ohm
  "R00 R00 0.00000 内短",           \ // Shortcut
  "R00 R01 0.01000 10 mOhm",         \ // 0.01 Ohm
  "R01 R10 0.10000 0.1 Ohm",         \ // 0.1 Ohm
  "R10 1R0 1.00000 1 Ohm",           \ // 1 Ohm
  "1R0 10R 10.0000 10 Ohm",          \ // 10 Ohm
  "NC1 NC2 0.00000 开路" }, {        \ // Full open
  "R00 R00 0.00000 内短",           \ // Shortcut
  "R00 R01 0.01000 10 mOhm",         \ // 0.01 Ohm
  "R01 R10 0.10000 0.1 Ohm",         \ // 0.1 Ohm
  "R10 1R0 1.00000 1 Ohm",           \ // 1 Ohm
  "1R0 10R 0.00100 1 mOhm",          \ // 1 mOhm
  "NC1 NC2 0.00000 Open" } }           // Full open

#define NERR 16                        // Max number of listed errors per rail

char   errlist[17][NERR][80]           // List of rail-related errors

// Interrupt handler, receives and processes asynchronous messages and errors.
function int Answerproc(char *answer,int info)
  int i
  if answer[4]==0xF0 then              // Internal OLLYTEST message
    if Stricmp(answer+5,"CHG LAY")==0 layoutchanged=1
    if Stricmp(answer+5,"CHG LOAD")==0 loadchanged=1
    return
  else if answer[4]==S_ERROR then      // Error messages, also with zero ID
    switch answer[5]
    case E_NOCRATDATA,E_NOFINGDATA:
      globalerr=globalerr|GE_BOOT
    case E_ZMOVEMENT:
      if answer[9]==2 && answer[7]!=0xFF then
        i=answer[7]*2+((answer[8] & 0x4C)==0?1:0)
        oversurface[i]++               // Count number of contacts over PCB
      endif
    case E_COMMUTATOR:
      i=$uint2(answer+10)
      if (i & 0x0300)!=0 globalerr=globalerr|GE_MEAS
    case E_TMEAS:
      if answer[9]>=2 globalerr=globalerr|GE_MEAS
    case E_IOERROR:
      // Serial I/O errors are considered non-critical for A5.
      if testertype!=TT_A5 && testertype!=TT_A5L &&                            \
        testertype!=TT_A6 && testertype!=TT_S1 && testertype!=TT_S2 &&         \
        testertype!=TT_S3 && testertype!=TT_A7 && testertype!=TT_A8 then
        globalerr=globalerr|GE_IOERROR
      endif
    case E_WRONGCOORD,E_BADCOMMAND,E_BADCMDSIZE,E_TABLEOVERF,E_BADDATA:
      globalerr=globalerr|GE_COMMAND
    case E_SYNC,E_DIVBYZERO:
      globalerr=globalerr|GE_COMMAND
    case E_CONTACT,E_HISHIFT,E_SHORTCUT:
      globalerr=globalerr|GE_MEAS
    case E_INITMEAS:
      i=$uint2(answer+10)
      if (i & 0x7D)!=0 globalerr=globalerr|GE_MEAS
    case E_BOXSENS,E_PNEUMOSENS,E_PNEUMOSYS:
      globalerr=globalerr|GE_HARDWARE
    endsw
  endif
end

function int Initsigma(float disp[])
  disp[0]=0.0
  disp[1]=0.0
  disp[2]=0.0
  disp[3]=0.0
  disp[4]=0.0
end

// Function adds next measured value to array disp[5] which accumulates data
// necessary to calculate normal dispersion, mean, minimal and maximal.
function int Addsigma(float disp[],float value)
  if disp[0]<=0.0 then
    disp[0]=1.0                        // First point, data is still undefined
    disp[1]=value
    disp[2]=value*value
    disp[3]=value
    disp[4]=value
  else
    disp[0]=disp[0]+1.0
    disp[1]=disp[1]+value
    disp[2]=disp[2]+value*value
    disp[3]=Min(disp[3],value)
    disp[4]=Max(disp[4],value)
  endif
end

// Function returns number of data items gathered by Addsigma().
function int Getcount(float disp[])
  return disp[0]
end

// Function calculates mean value based on data gathered by Addsigma().
function float Getmean(float disp[])
  if disp[0]<1.0 then
    return 0.0
  else
    return disp[1]/disp[0]
  endif
end

// Function calculates mean value based on data gathered by Addsigma(). If
// number of measurements is 8 or more, minimum and maximum are not taken into
// account.
function float Getxmean(float disp[])
  if disp[0]<1.0 then
    return 0.0
  else if disp[0]>=8.0 then
    return (disp[1]-disp[3]-disp[4])/(disp[0]-2.0)
  else
    return disp[1]/disp[0]
  endif
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmin(float disp[])
  return disp[3]
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmax(float disp[])
  return disp[4]
end

// Function calculates normal dispersion based on data gathered by Addsigma().
function float Getsigma(float disp[])
  float r
  if disp[0]<2.0 then
    return 0.0
  else
    r=(disp[0]*disp[2]-disp[1]*disp[1])/disp[0]/(disp[0]-1.0)
    if r<=0 then
      return 0.0
    else
      return Sqrt(r)
    endif
  endif
end

// Writes record to c:\hardware\calibrationlog.txt. Returns 0 on success and -1
// on error.
function int Addcalibrationrecord(format message)
  handle f
  char s[256]
  f=Fopen("c:\\hardware\\calibrationlog.txt","at")
  if f==NULL return -1
  Strtime(s,"%a %d-%b-%Y %H:%M",0,0)
  fprintf(f,"%s  Lowrtest v%s  %s\n",s,VERSION,message)
  Fclose(f)
  return 0
end

// Similar to SERV.Ohmstotext(), but returns more decimal places.
function int Ohmstotext(float r,int status,char *s)
  int i,units
  if (status & 0x0100)!=0 r=r*1.0e-6   // Resistance in microOhms
  while Abs(r)>1000.0 && units<3 do
    r=r/1000.0; units++
  enddo
  if Abs(r)<10 then
    i=Sprintf(s,"%8.5f",r)
  else if Abs(r)<100 then
    i=Sprintf(s,"%8.4f",r)
  else
    i=Sprintf(s,"%8.3f",r)
  endif
  if units==0 i=i+Sprintf(s+i,"  Ohm")
  if units==1 i=i+Sprintf(s+i," kOhm")
  if units==2 i=i+Sprintf(s+i," MOhm")
  if units==3 i=i+Sprintf(s+i," GOhm")
  return i
end

// Given video channel, returns head that carries corresponding video camera,
// or -1 if channel is invalid or not assigned.
function int Headfromchannel(int channel)
  int head,n
  if $LAY.cameras!=0 then
    if channel==0 return $LAY.nfing*2
    if channel==1 return $LAY.nfing*2+1
  else
    n=0
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      if channel==n return head
      n++
    enddo
  endif
  return -1
end

// Given head, returns associated video channel, or -1 if head is invalid or
// carries no camera.
function int Channelfromhead(int head)
  int i,channel
  if $LAY.cameras!=0 then
    if head==$LAY.nfing*2 return 0
    if head==$LAY.nfing*2+1 return 1
  else if ($LAY.headcameras & (1<<head))!=0 then
    channel=0
    for i=0,i<head,i++ do
      if ($LAY.headcameras & (1<<i))!=0 channel++
    enddo
    return channel
  endif
  return -1
end

// Given Y coordinate in millimeters, selects camera controller and
// corresponding video channel. Returns head on success, and -1 on any error.
function int Camerafromy(float y,int *channel,int *side,float *angle)
  int head
  float h
  if $LAY.cameras!=0 then
    if ($LAY.cameras & 0x3)==0x1 then
      channel[0]=0
    else if ($LAY.cameras & 0x3)==0x2 then
      channel[0]=1
    else if ($int2($LAY+764) & 0x4000)!=0 then
      channel[0]=1
    else
      channel[0]=0
    endif
    side[0]=channel[0]
    angle[0]=0.0
    return $LAY.nfing*2+channel[0]
  else if $LAY.headcameras!=0 then
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      if ($LAY.excludedrails & (1<<(head/2)))!=0 continue
      if scanrail>=0 then
        if scanrail==head/2 break
      else
        if $LAY.top[head/2]/1000.0<=y continue
        if $LAY.bottom[head/2]/1000.0>y continue
        break
      endif
    enddo
    if head>=$LAY.nfing*2 return -1
    channel[0]=Channelfromhead(head)
    side[0]=$LAY.side[head/2]
    h=y-$LAY.yoffset[head/2]/1000.0
    angle[0]=(Abs(h)>0.9*headcamradius?0.0:Asin(h/headcamradius))
    if side[0]!=0 angle[0]=-angle[0]
    if (head & 1)!=0 angle[0]=-angle[0]
    return head
  else
    return -1                          // No cameras
  endif
end

// Reads individual per-camera brightness, contrast, illumination type and
// focal coordinate from .ini file.
function int Bcgetini()
  int head,bri,ctr
  char key[32]
  // Get defaults for the first run.
  illtype=0x03; longexp=0;
  getini("Video","Illumination type","%i,%i",&illtype,&longexp)
  bri=0; getini("ScrollAutoSave","Brightness","%i",&bri)
  ctr=0; getini("ScrollAutoSave","Contrast","%i",&ctr)
  focus[0]=-1000; getini("Video","Ctest focus[0]","%i",focus+0)
  focus[1]=-1000; getini("Video","Ctest focus[1]","%i",focus+1)
  for head=0,head<32,head++ do
    brightness[head]=bri
    contrast[head]=ctr
    if individualbc then
      sprintf(key,"Brightness[%i]",head)
      getini("Video",key,"%i",brightness+head)
      sprintf(key,"Contrast[%i]",head)
      getini("Video",key,"%i",contrast+head)
    endif
  enddo
end

// Saves individual per-camera brightness and contrast values to .ini file
function int Bcsetini()
  int head
  char key[32]
  setini("Video","Illumination type","%i,%i",illtype,longexp)
  setini("Video","Ctest focus[0]","%i",focus[0])
  setini("Video","Ctest focus[1]","%i",focus[1])
  if individualbc==0 then
    // No individual settings.
    setini("ScrollAutoSave","Brightness","%i",brightness[0])
    setini("ScrollAutoSave","Contrast","%i",contrast[0])
  else
    // Individual per-camera settings.
    for head=0,head<($LAY.nfing+1)*2,head++ do
      if cameras!=0 then
        if head<$LAY.nfing*2 continue
        if (cameras & (1<<(head-$LAY.nfing*2)))==0 continue
      else
        if (headcams & (1<<head))==0 continue
      endif
      sprintf(key,"Brightness[%i]",head)
      setini("Video",key,"%i",brightness[head])
      sprintf(key,"Contrast[%i]",head)
      setini("Video",key,"%i",contrast[head])
    enddo
  endif
end

// Connects brightness and contrast controls to the specified head.
function int Bcsetcam(int channel)
  int head
  if individualbc==0 return
  head=Headfromchannel(channel)
  if head==bchead then
    return
  else if head>=0 && head<32 then
    if hbrightness!=NULL change hbrightness select=brightness[head]
    if hcontrast!=NULL change hcontrast select=contrast[head]
    if hfocus!=NULL && (head==$LAY.nfing*2 || head==$LAY.nfing*2+1) then
      change hfocus text=format(" %i",focus[head-$LAY.nfing*2])
    endif
    bchead=head
  else
    bchead=-1
  endif
end

// Creates brightness, contrast and illumination or focus controls at the
// specified location (default location if x and y are -1).
function int Bccreate(handle hparent,int x,int y,int channel,int mode)
  if x<0 x=5
  if y<0 y=303
  if mode!=0 then
    if testertype==TT_S3 then
      mode=2                           // Create focus controls
    else if (testertype==TT_A7 || testertype==TT_A8) then
      mode=1                           // Create illumination controls
    else
      mode=0
    endif
  endif
  hbrititle=control TEXT
    window=hparent
    position=x,y+4,27,16
    name="增益"
    help=" "
    font=INFOFONT
  endc
  hbrightness=control HSCROLL
    window=hparent
    position=x+32,y+2,(mode?120:150),21
    name=(individualbc?"":"亮度")
    help=format("调整所选相机%s",                                  \
      individualbc?" 的图像增益":"")
    limits=-100,100
  endc
  hctrtitle=control TEXT
    window=hparent
    position=x,y+31,27,16
    name="高度"
    help=" "
    font=INFOFONT
  endc
  hcontrast=control HSCROLL
    window=hparent
    position=x+32,y+29,(mode?120:150),21
    name=(individualbc?"":"对比度")
    help=format("调整所选相机%s",                       \
      individualbc?" 的图像曝光时间":"")
    limits=-100,100
  endc
  if mode==1 then
    // Illumination controls.
    hilltop=control CHECKBOX
      window=hparent
      position=x+160,y,50,18
      name="正面"
      help="打开顶部照明，对所有相机都有效"
      font=INFOFONT
      mode=((illtype & 0x0C)==0 || (illtype & 0x4)!=0?M_CHECKED:0)
    endc
    hillskew=control CHECKBOX
      window=hparent
      position=x+160,y+18,55,18
      name="反差"
      help="打开侧面照明，对所有相机都有效"
      font=INFOFONT
      mode=((illtype & 0x08)!=0?M_CHECKED:0)
    endc
    hilllong=control CHECKBOX
      window=hparent
      position=x+160,y+36,55,18
      name="高亮"
      help="长时间曝光，仅适用于选定的相机"
      font=INFOFONT
      mode=(longexp?M_CHECKED:0)
    endc
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  else if mode==2 then
    // Focus controls.
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=control TEXT
      window=hparent
      position=x+160,y+31,45,16
      name="聚焦"
      help=" "
      font=INFOFONT
    endc
    hfocusup=control BUTTON
      window=hparent
      position=x+205,y+29,21,21
      name="-"
      help="按住可向上移动相机"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hfocus=control TEXT
      window=hparent
      position=x+225,y+29,62,21
      help="当前相机的Z坐标，微米"
      font=MEDIUMFONT
      mode=M_BORDER
      bkcolor=LIGHTYELLOW
      color=DARKGRAY
    endc
    hfocusdn=control BUTTON
      window=hparent
      position=x+286,y+29,21,21
      name="+"
      help="按住可向下移动相机"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
  else
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  endif
  bchead=-1
  Bcsetcam(channel)
end

// Checks whether user has changed brightness, contrast or illumination and
// updates data. Returns combination of 0x01 (if brightness or contrast was
// changed) and 0x02 (if illumination type was changed). Additionally, sets
// S3 focus.
function int Bcupdate()
  int head,cam,changed,n
  char s[80]
  if individualbc==0 then
    head=0
  else if bchead<0 || bchead>=32 then
    return 0
  else
    head=bchead
  endif
  changed=0
  if hbrightness!=NULL && Pressed(hbrightness) then
    brightness[head]=Status(hbrightness)
    changed=changed | 0x01
  endif
  if hcontrast!=NULL && Pressed(hcontrast) then
    contrast[head]=Status(hcontrast)
    changed=changed | 0x01
  endif
  if hilltop!=NULL && Pressed(hilltop) then
    if Status(hilltop)!=0 then
      illtype=illtype|0x04
    else
      illtype=illtype & (~0x04)
      if (illtype & 0x0C)==0 then
        illtype=0x0B
        change hillskew mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hillskew!=NULL && Pressed(hillskew) then
    if Status(hillskew)!=0 then
      illtype=illtype|0x08
    else
      illtype=illtype & (~0x08)
      if (illtype & 0x0C)==0 then
        illtype=0x07
        change hilltop mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hilllong!=NULL && Pressed(hilllong) then
    longexp=Status(hilllong)
    changed=changed | 0x01
  endif
  if hfocus!=NULL then
    n=Min(Pressed(hfocusdn),3)
    n=n-Min(Pressed(hfocusup),3)
    cam=head-$LAY.nfing*2
    if n!=0 && (cam==0 || cam==1) then
      focus[cam]=Max(-8000,Min(focus[cam]+n*20,8000))
      change hfocus text=format(" %i",focus[cam])
      updatefocus[cam]=1
    endif
  endif
  if testertype==TT_S3 then
    if ($LAY.cameras & 0x1)!=0 && updatefocus[0]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+0,focus[0])
      SERV.Cmdimm(32,s)
      updatefocus[0]=0
    endif
    if ($LAY.cameras & 0x2)!=0 && updatefocus[1]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+1,focus[1])
      SERV.Cmdimm(32,s)
      updatefocus[1]=0
    endif
  endif
  return changed
end

// Deletes brightness and contrast controls. It's not a sin to forget to call
// this function, but then better not call any Bcxxx() except Bccreate() or
// Bcdisable().
function int Bcdelete()
  if bchead<0 return
  destroy hbrititle; hbrititle=NULL
  destroy hbrightness; hbrightness=NULL
  destroy hctrtitle; hctrtitle=NULL
  destroy hcontrast; hcontrast=NULL
  bchead=-1
  if hilltop!=NULL then
    destroy hilltop; hilltop=NULL
    destroy hillskew; hillskew=NULL
    destroy hilllong; hilllong=NULL
  endif
  if hfocus!=NULL then
    destroy hfoctitle; hfoctitle=NULL
    destroy hfocusup; hfocusup=NULL
    destroy hfocus; hfocus=NULL
    destroy hfocusdn; hfocusdn=NULL
  endif
end

// Disables brightness and contrast processing in the case that corresponding
// controls were not deleted by Bcdelete()
function int Bcdisable()
  hbrititle=NULL
  hbrightness=NULL
  hctrtitle=NULL
  hcontrast=NULL
  bchead=-1
  hilltop=NULL
  hillskew=NULL
  hilllong=NULL
  hfoctitle=NULL
  hfocusup=NULL
  hfocus=NULL
  hfocusdn=NULL
end

// Returns current brightness (-100..100) for the specified channel.
function int Bcgetbri(int channel)
  int head
  if individualbc==0 then
    return brightness[0]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return brightness[head]
  endif
end

// Returns current contrast (-100..100) for the specified head.
function int Bcgetctr(int channel)
  int head
  if individualbc==0 then
    return contrast[0]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return contrast[head]
  endif
end

// Clears contact-over-surface counters
function int Clearoversurface()
  int i
  for i=0,i<32,i++
    oversurface[i]=0
  enddo
end

// Reports (if necessary) how many contacts over surface detected.
function int Oversurface()
  int i,n,badheads
  for i=0,i<$LAY.nfing*2,i++
    n=n+oversurface[i]
    if oversurface[i]>0 badheads++
  enddo
  if n==0 return                       // No contacts over surface
  if hlog!=NULL then
    fprintf(hlog,"\n\nATTENTION, tester detected ")
    fprintf(hlog,"%i contact%s over surface ",n,(n==1?"":"s"))
    fprintf(hlog,"on the following head%s:\n\n",badheads==1?"":"s")
    for i=0,i<$LAY.nfing*2,i++ do
      if oversurface[i]==0 continue
      fprintf(hlog,"      Head %2i%c    - %4i contact%c over surface\n",       \
      i/2,((i & 1)==0?'L':'R'),oversurface[i],oversurface[i]==1?' ':'s')
    enddo
    fprintf(hlog,"\nFor this reason, measurements above may be unreliable.\n\n")
  endif
  Clearoversurface()
end

// Assures that tester is loaded and that debug mode does not make test void.
function int Loadtester()
  int i,j,t,err,nframes
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="软件复位"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK
  draw at 6,30 text="载入测试机,请稍等... "
  draw show
  delay 500
  SYS.Softimm(0)
  t=Time(); i=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("等待软件复位 - %i s",j)
      i=j
    endif
    if j>15 break
    wait
  enddo
  clear hright
  draw window=hright font=TIMESFONT
  if $A[0].length==0 then
    change hinfo name="机箱无应答"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is off\n"
    draw text="- Flying Debugger or Test Player is running\n"
    draw text="- Crash in embedded software\n"
    draw text="- Optocable is pulled out\n"
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    while 1 do
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      wait
    enddo
  else if $A[0].answer==S_ERROR &&                                             \
    ($A[0].subcmd==E_NOCRATDATA || $A[0].subcmd==E_NOFINGDATA) then
    change hinfo name="测试器未加载"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="The Flying Probe Tester is not loaded. Of course, it "
    draw color=LIGHTRED text="must " color=BLACK
    draw text="be loaded before you can start test. Typically, all you "
    draw text="need is to press 'Load all' in the appearing window. "
    if $GLOBAL.disabledrails!=0 then
      draw text="Please check for rails disabled in the Debug mode. "
    endif
    if ($GLOBAL.debugmode & 0x20BF)!=0 || ($GLOBAL.videomode & 0x20BF)!=0 ||   \
      $uint4($GLOBAL+280)!=0 then
      draw color=LIGHTRED
      draw text="Please also check that current Debug mode really allows you "
      draw text="to make measurements!"
    endif
    err=SYS.Videosize(0,&i,&j,&nframes);
    if err!=0 || nframes==0 then
      draw color=BLACK
      draw text="\nNote also that frame grabber in your system is not "
      draw text="accessible. Either it is absent, or not installed, or "
      draw text="OllyTest was unable to locate support DLLs."
    else if nframes<4 then
      draw color=BLACK
      draw text="\nNote also that amount of memory allocated to frame grabber "
      draw text="is too low which may cause problems during the test. We "
      draw text="recommend that you set frame buffer to 2 Mb."
    endif
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if $A[0].answer!=S_RESET then
    change hinfo name="软重置错误"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="Flying Probe Tester returned some unexpected answer. Normally, "
    draw text="this never happens. All I may suggest is to press Hard Reset "
    draw text="and then reboot the tester. "
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  endif
  return 0
end

// Check whether some critical error was detected, such as broken cable, absent
// measurement card, damaged locks etc. Returns 0 if test should continue, 1 if
// tester to be rebooted, or -1 if operator decided to interrupt the test.
function int Checkgloberrors()
//////////////!!! ADD (smart) SOFT RESET HERE
  int err
  handle hcont,hboot
  if globalerr==0 return 0
  change hinfo limits=0,0
  change hinfo text="侦测到错误"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED text="Critical error detected!"
  draw at 6,60 color=BLACK
  if globalerr & GE_BOOT then
    draw text="Tester is not booted. Perharps somebody pressed emergency "
    draw text="switch, or surge caused crash of embedded software. "
    err=1
  else if globalerr & GE_HARDWARE then
    draw text="Embedded software discovered some problems with shuttle. Please "
    draw text="check sensors and pneumatics. "
    err=0
  else if globalerr & GE_IOERROR then
    draw text="Embedded software detected serial transmission error. Please "
    draw text="check optical cable and connections to the ground. "
    err=2
  else if globalerr & GE_COMMAND then
    draw text="Embedded software rejected some command. Please check the "
    draw text="version of C_PROG.BIN. "
    err=2
  else if globalerr & GE_MEAS then
    draw text="Self-test has detected severe error in measurement electronics. "
    draw text="Correct measurements seem to be impossible. Please check "
    draw text="measurement hardware. "
    err=2
  else
    draw text="Some internal error occured. "
    err=2
  endif
  globalerr=0                          // Two errors at once? Hardly possible.
  hboot=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="重启"
    help="按下可以重新加载飞针测试机程序"
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="继续"
    help="按下继续测试风险自负"
  endc
  if err==0 then                       // No serious error
    draw text="Press 'Continue' to continue test."
    disable hboot
  else if err==1 then
    draw text="You must reboot the tester and begin test again."
    disable hcont
  else
    draw text="\nContinuation of test may result in strange tester behaviour. "
    draw text="Try to reboot tester or continue at your own risk!"
  endif
  draw show
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hboot) then
      return 1
    else if Pressed(hcont) then
      return 0
    endif
    wait
  enddo
end

function int Getlayout()
  int i,j,t,ident,err
  char buf[16]
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="获取布局"
  delay 300
  buf[0]=S_LAYOUT
  buf[1]=0x03                          // Read layout with corrected phases
  ident=SYS.Sendimm(0,2,buf)
  t=Time(); i=0; err=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("等待布局 - %i s",j)
      i=j
    endif
    if j>15 break
    wait
  enddo
  if $A[0].length==0 then
    err=2
  else if $A[0].answer!=S_LAYOUT || $A[0].length!=774 then
    err=1
  else
    // Layout received. Get layout extentions.
    Memcpy($LAY,$A[0]+6,768)
    for i=0,i<16,i++                   // Same offsets in tester & inner copy
      $LAYCORR.leftzerox[i]=$LAY.leftzerox[i]
      $LAYCORR.leftzeroy[i]=$LAY.leftzeroy[i]
      $LAYCORR.rightzerox[i]=$LAY.rightzerox[i]
      $LAYCORR.rightzeroy[i]=$LAY.rightzeroy[i]
    enddo
    if $LAY.extlay>=1 then
      buf[0]=S_LAYOUT
      buf[1]=15                        // Read main layout extention
      SYS.Sendimm(0,2,buf)
    endif
    for j=1,j<$LAY.extlay && j<5,j++ do
      buf[0]=S_LAYOUT
      buf[1]=20                        // Read additional layout extention
      $int4(buf+2)=j-1                 // Index
      SYS.Sendimm(j,6,buf)
    enddo
    i=-1
    while 1 do
      for j=0,j<$LAY.extlay && j<5,j++ do
        if $A[j].length==0 break
        if $A[j].answer!=S_LAYOUT || $A[j].length!=(j==0?774:778) then
          err=1; break                 // Invalid answer
        endif
      enddo
      if err!=0 || j>=$LAY.extlay break
      if Pressed(hexit) return -1
      j=(Time()-t)/1000
      if i!=j then
        change hinfo text=format("等待布局 - %i s",j)
        i=j
      endif
      if j>15 then
        err=2; break                   // Timeout!
      endif
      wait
    enddo
    if err==0 then
      Memcpy($EXTLAY,$A[0]+6,768)
      if $LAY.extlay>=2 then
        Memcpy($EXT0,$A[1]+10,768)
      else
        Memset($EXT0,0,768)
      endif
      if $LAY.extlay>=3 then
        Memcpy($EXT1,$A[2]+10,768)
      else
        Memset($EXT1,0,768)
      endif
      if $LAY.extlay>=4 then
        Memcpy($EXT2,$A[3]+10,768)
      else
        Memset($EXT2,0,768)
      endif
      if $LAY.extlay>=5 then
        Memcpy($EXT3,$A[4]+10,768)
      else
        Memset($EXT3,0,768)
      endif
    endif
    SYS.Broadcast(8,"CHG LAY")         // Inform others that layout changed
  endif
  if err==0 then
    buf[0]=S_DUMP                      // Get version of embedded software
    buf[1]=255                         // Request to crate controller
    buf[2]=0x14                        // Get software version
    $uint2(buf+3)=0                    // Number of items
    $uint2(buf+5)=0                    // Start item
    ident=SYS.Sendimm(0,7,buf)
    change hinfo text="获取软件版本"
    delay 300
    t=Time(); i=0; err=0
    while $A[0].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as an interrupt
      if (Time()-t)>5000 break         // Timeout 5 seconds
      wait
    enddo
    if $A[0].length==0 then
      err=2
    else if $A[0].answer==S_DUMP then  // Correct answer, extract subfields
      j=5
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(crateversion,$A[0]+j)
      j=i
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(layoutversion,$A[0]+j)
      j=i
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(headversion,$A[0]+j)
    else
      err=3
    endif
  endif
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if err==1 || err==3 then
    if err==1 then
      change hinfo text="Error getting layout"
      draw text="The script was unable to get layout correctly. "
    else
      change hinfo text="Error getting version"
      draw text="The script was unable to get version of loaded software. "
    endif
    draw text="This error is absolutely unexpected here. Perharps, the best "
    draw text="way to recover is to reboot the tester. If you select this "
    draw text="option, then in the appearing window first press 'Hard reset', "
    draw text="then 'Load all'. After the tester is loaded, try again."
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="呼叫加载器"
      help="按下可以重新加载飞针测试机程序"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="重试"
      help="按下可以重新尝试获取布局或读取软件版本"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if err==2 then
    change hinfo text="No answer from crate"
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is off\n"
    draw text="- Flying Debugger or Test Player is running\n"
    draw text="- Crash in embedded software\n"
    draw text="- Optocable is pulled out\n"
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="按下可以重新尝试连接"
    endc
    while 1 do
      if Pressed(hretry) break
      if Pressed(hexit) return -1
      wait
    enddo
  else
    leftvlimit=($LAY.leftlimit+$LAY.videodeadx)/1000.0+MAXERR
    rightvlimit=($LAY.rightlimit-$LAY.videodeadx)/1000.0-MAXERR
  endif
  return err
end

// Function writes corrected layout to disk and, if specified, loads corrected
// measurement parameters and layout extentions to the tester.
function int Loadlayoutmeas(char *layout,char *extention,int reload)
  int i,j,len,err,t,nextent,maxextent,flashtime
  char s[260],buf[774]
  handle f,hlayoutname,hbrowse,hwrite,hcancel,hretry
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="配置参数已成功校正。"
  draw text="请选择文件来保存数据。"
  draw show
  hlayoutname=control COMBOEDIT
    window=hright
    position=5,USERY-130,RIGHTX-10,120
    name="布局文件"
    help="包含主测试机布局的文件"
    mode=M_VSCROLL
  endc
  hbrowse=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="浏览"
    help="浏览布局名称"
  endc
  hwrite=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="保存"
    help="将更正的布局保存到指定文件"
  endc
  hcancel=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="取消"
    help="放弃所有对布局的更改"
  endc
  flashtime=1
  while 1 do
    if flashtime!=0 && flashtime<Time() then
      change hinfo color=BLACK
      change hinfo text="保存配置文件"
      flashtime=0
    endif
    if Pressed(hbrowse) then
      Text(hlayoutname,s)
      if SYS.Browse(hmain,s,"Specify layout name",0)!=0 then
        change hlayoutname text=s
      endif
    else if Pressed(hwrite) then
      confirm hlayoutname
      Text(hlayoutname,s)
      if s[0]=='\0' then
        change hinfo color=LIGHTRED
        change hinfo text="Invalid name!"
        flashtime=Time()+1000
      else
        err=0
        f=Fopen(s,"wb")
        if f==NULL err=1
        // Save main layout.
        if err==0 && Fwrite(layout,768,f)!=768 err=2
        // Determine number of layout extentions to save.
        nextent=0
        if err==0 then
          for i=4,i<768,i++ do         // First 4 bytes are validity marker
            if $char($EXT3+i)!=0 break
          enddo
          if i<768 nextent=5
          if nextent==0 then
            for i=4,i<768,i++ do
              if $char($EXT2+i)!=0 break
            enddo
            if i<768 nextent=4
          endif
          if nextent==0 then
            for i=4,i<768,i++ do
              if $char($EXT1+i)!=0 break
            enddo
            if i<768 nextent=3
          endif
          if nextent==0 then
            for i=4,i<768,i++ do
              if $char($EXT0+i)!=0 break
            enddo
            if i<768 nextent=2
          endif
          if nextent==0 then
            for i=0,i<768,i++
              if extention[i]!=0 break
            enddo
            if i<768 nextent=1
          endif
        endif
        if err==0 && nextent>=1 then
          if Fwrite(extention,768,f)!=768 err=2
        endif
        if err==0 && nextent>=2 then
          $int4($EXT0)=0x30747845
          if Fwrite($EXT0,768,f)!=768 err=2
        endif
        if err==0 && nextent>=3 then
          $int4($EXT1)=0x31747845
          if Fwrite($EXT1,768,f)!=768 err=2
        endif
        if err==0 && nextent>=4 then
          $int4($EXT2)=0x32747845
          if Fwrite($EXT2,768,f)!=768 err=2
        endif
        if err==0 && nextent>=5 then
          $int4($EXT3)=0x33747845
          if Fwrite($EXT3,768,f)!=768 err=2
        endif
        Fclose(f)
        if err==1 then
          change hinfo color=LIGHTRED
          change hinfo text="Error saving layout to file!"
          flashtime=Time()+1000
        else if err==2 then
          change hinfo color=LIGHTRED
          change hinfo text="Unable to create file!"
          flashtime=Time()+1000
        else
          break
        endif
      endif
    else if Pressed(hcancel) then
      change hinfo color=BLACK
      return 1
    endif
    wait
  enddo
  Memcpy($LAY,layout,768)
  Memcpy($EXTLAY,extention,768)
  SYS.Broadcast(8,"CHG LAY")           // Inform others that layout changed
  if reload==0 return 0
  change hinfo text="Reloading layout"
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Now reloading corrected layout and layout extentions to tester."
  draw show
  err=0
  // Reload measurement parameters. Answer indicates whether and how many
  // additional layout extentions are supported. Layout may be larger than
  // tester accepts!
  buf[0]=S_LOADRUN
  buf[1]=4                             // Reload measurement parameters
  $int4(buf+2)=0                       // Dummy zero bytes
  Memcpy(buf+6,layout,768)
  if SYS.Sendimm(0,774,buf)<=0 err=1   // Unable to send command
  t=Time(); i=-1
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("Reloading layout - %i s",j)
      i=j
    endif
    if j>=120 then
      SYS.Killimm(0)
      err=2; break                     // Timeout
    endif
    wait
  enddo
  if err==0 && $A[0].answer!=S_LOADRUN then
    err=3
  endif
  // Calculate total number of layout extentions to load.
  nextent=0
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 then
    maxextent=1
  else if $A[0].length>=7 then
    maxextent=$char($A[0]+6)
  else
    maxextent=1
  endif
  if maxextent>=5 then
    for i=4,i<768,i++ do               // First 4 bytes are validity marker
      if $char($EXT3+i)!=0 break
    enddo
    if i<768 nextent=5
  endif
  if nextent==0 && maxextent>=4 then
    for i=4,i<768,i++ do
      if $char($EXT2+i)!=0 break
    enddo
    if i<768 nextent=4
  endif
  if nextent==0 && maxextent>=3 then
    for i=4,i<768,i++ do
      if $char($EXT1+i)!=0 break
    enddo
    if i<768 nextent=3
  endif
  if nextent==0 && maxextent>=2 then
    for i=4,i<768,i++ do
      if $char($EXT0+i)!=0 break
    enddo
    if i<768 nextent=2
  endif
  if nextent==0 then
    for i=0,i<768,i++ do
      if $char($EXTLAY+i)!=0 break
    enddo
    if i<768 nextent=1
  endif
  // Send additional layout extentions. Note that main extention is sent
  // afterwards, this is the recommended order (although this does not matter
  // if tester was completely loaded before).
  for j=1,j<nextent && err==0,j++ do   // Note: nextent<=5
    buf[0]=S_LOADRUN
    buf[1]=20                          // Load additional layout extention
    $int4(buf+2)=j-1                   // Index
    if j==1 then
      Memcpy(buf+6,$EXT0,768)
    else if j==2 then
      Memcpy(buf+6,$EXT1,768)
    else if j==3 then
      Memcpy(buf+6,$EXT2,768)
    else
      Memcpy(buf+6,$EXT3,768)
    endif
    if SYS.Sendimm(j,774,buf)<=0 err=1 // Unable to send command
  enddo
  // Send main layout extention.
  if err==0 && nextent>=1 then
    buf[0]=S_LOADRUN
    buf[1]=15                          // Load main layout extention
    $int4(buf+2)=0                     // Dummy zero bytes
    Memcpy(buf+6,$EXTLAY,768)
    if SYS.Sendimm(0,774,buf)<=0 err=1 // Unable to send command
  endif
  i=-1
  while err==0 do
    for j=0,j<nextent,j++ do
      if $A[j].length==0 break
      if $A[j].answer!=S_LOADRUN err=3
    enddo
    if j>=nextent break                // All answers are back
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("Reloading layout - %i s",j)
      i=j
    endif
    if j>=120 then
      for j=0,j<nextent,j++ do
        SYS.Killimm(j)
      enddo
      err=2; break                     // Timeout
    endif
    wait
  enddo
  i=Checkgloberrors()                  // Necessary after measurement test
  if err==0 || i!=0 return i
  change hinfo text="Communication problem!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Unable to send command!"
  else if err==2 then
    draw text="No answer within 90 seconds!"
  else
    draw text="Command executed incorrectly!"
  endif
  draw at 6,60 wrap=RIGHTX-5 color=BLACK
  hretry=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="检查状态"
    help="按下重新检查测试机状态"
  endc
  draw text="Script was unable to load tester with corrected layout. It is "
  draw text="necessary to re-check the status of the tester."
  draw show
  while 1 do
    if Pressed(hretry) return 1        // Check tester status again
    if Pressed(hexit) return -1        // Quit script
    wait
  enddo
end

// Gets list of features (MF_xxx) and maximal resistance current supported by
// the measurement card. If command fails, list is zeroed assuming only basical
// functionality.
function int Getfeatures()
  int t
  char buf[32]
  features=0
  maxcurrent=270
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x1002001F             // Query features of measurement card
  SYS.Sendimm(0,6,buf)
  buf[1]=0x80                          // Measurement card (master)
  $uint4(buf+2)=0x10020020             // Query maximal ExactR current
  SYS.Sendimm(1,6,buf)
  t=Time()
  while $A[0].length==0 || $A[1].length==0 do
    if Time()-t>1500 return            // Timeout
    wait
  enddo
  if $A[0].answer==S_INPORT32 then
    features=$uint4($A[0]+5)
  else
    features=0
  endif
  if $A[0].answer==S_INPORT32 then
    maxcurrent=$uint4($A[0]+5)
    if maxcurrent==(-1) then
      maxcurrent=90
    else if maxcurrent==0 then
      maxcurrent=270
    endif
  else
    maxcurrent=270
  endif
end

// This function checks layout and sets global variables testertype and
// testersides. If tester is not recognized or not supported, function displays
// corresponding message.
function int Recognizetester()
  int i,w,h,rail,zheadtype
  float ya,yb,ymin,ymax
  handle hok
  clear hright
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,60 wrap=RIGHTX-5
  w=($LAY.rightlimit-$LAY.leftlimit)/1000
  h=Min($LAY.top[0]-$LAY.yoffset[0],$LAY.yoffset[0]-$LAY.bottom[0])/500
  testersides=0
  ymin=9.9e99
  ymax=-9.9e99
  firstrail=9999
  lastrail=-9999
  maxrail=-9999
  for i=0,i<$LAY.nfing,i++
    if $LAY.side[i]==0 then
      testersides=testersides|1
    else
      testersides=testersides|2
    endif
    if $LAY.side[i]==$LAY.side[0] then
      maxrail=Max(maxrail,i)
      if ($LAY.excludedrails & (1<<i))==0 then
        firstrail=Min(firstrail,i)
        lastrail=Max(lastrail,i)
      endif
    endif
    ymin=Min(ymin,$LAY.top[i]/1000.0)
    ymax=Max(ymax,$LAY.bottom[i]/1000.0)
  enddo
  cameras=$LAY.cameras
  if ($LAY.config & LC_VACUUMBOX)!=0 cameras=cameras & 0x01
  if ($LAY.excludedrails & 0x4000)!=0 cameras=cameras & 0x02
  if ($LAY.excludedrails & 0x8000)!=0 cameras=cameras & 0x01
  headcams=0
  if $LAY.cameras==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if ($LAY.headcameras & (1<<i))==0 continue
      if ($LAY.config & LC_VACUUMBOX)!=0 && $LAY.side[i/2]!=0 continue
      if ($LAY.excludedrails & (1<<(i/2)))!=0 continue
      headcams=headcams | (1<<i)
    enddo
  endif
  if $LAY.nfing<=0 || $LAY.nfing>=16 then
    testertype=TT_WRONG                // Wrong layout
    draw text=format("Number of rails specified in the layout (%i) ",$LAY.nfing)
    draw text="is wrong. "
  else if w<=0 || h<=0 then
    testertype=TT_WRONG                // Wrong layout
    draw text="The size of the working area is wrong. "
  else if $LAY.cameras==0 && $LAY.headcameras==0 then
    testertype=TT_WRONG                // At least one camera must be present
    draw text="There are no video cameras on the tester. "
  else if ($LAY.config & 0x80)!=0 then
    if h==45 then
      testertype=TT_WRONG;             // M2 - not supported
      draw text="M2 tester is not supported by this script. "
    else
      testertype=TT_WRONG;             // Contradiction in layout
      draw text="The tester is declared as M2 in the layout, but the height "
      draw text=format("of the rail is %i millimeters instead of 45. ",h)
    endif
  else if testersides==2 then
    testertype=TT_WRONG                // Single-side tester
    draw text="Layout states that this tester is single-sided and that all "
    draw text="heads are from the bottom. "
  else if testersides==3 && $LAY.nfing<4 then
    testertype=TT_WRONG                // Too few rails
    draw text="Double-sided testers with less than 4 rails are not supported. "
  else if testersides==1 && $LAY.nfing<2 then
    testertype=TT_WRONG                // Too few rails
    draw text="Single-sided testers with less than 2 rails are not supported. "
  else if ymax-ymin>750.5 && $LAY.software==0xB7 then
    testertype=TT_WRONG                // Board does not cover all rails
    draw text="It is impossible to place board so that it covers all "
    draw text="available rails. "
  else if ymax-ymin>310.5 && $LAY.software!=0xB7 then
    testertype=TT_WRONG                // Board does not cover all rails
    draw text="It is impossible to place board so that it covers all "
    draw text="available rails. "
  else if h==155 && ($LAY.config & 3)==2 then
    if w==600 && $LAY.software==0x84 then
      testertype=TT_A2;                // A1 or A2 with linear motors
    else if w==600 && $LAY.software==0x86 then
      testertype=TT_A2;                // A1 or A2 with belts
    else if w==600 && $LAY.software==0x8A then
      testertype=TT_A2H;               // A2 (MCM modification)
    else if w==600 && $LAY.software==0x8E then
      testertype=TT_A4;                // A4
    else if w==600 && testersides==0x01 &&                                     \
      ($LAY.software==0xA7 || ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S1;                // S1 tester
    else if w>=310 && w<=600 && testersides==0x03 &&                           \
      ($LAY.software==0xA7 || $LAY.software==0xA8 ||                           \
      ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S2;                // S2 tester
    else if $LAY.software==0xA9 || $LAY.software==0xAA ||                      \
      ($LAY.config & LC_TYPEMASK)==LC_S3 then
      testertype=TT_S3;                // S3 tester
    else if $LAY.software==0xB8 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A8;                // A8 tester
    else if w==600 && ($LAY.software==0xA5 || $LAY.software==0xA6) then
      testertype=TT_A6;                // A6 tester
    else if w==800 && $LAY.software==0x84 then
      testertype=TT_A2L;               // A1L or A2L with linear motors
    else if w==800 && $LAY.software==0x86 then
      testertype=TT_A2L;               // A1L or A2L with belts
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 600 or 800 for A2/A4/A6 tester. "
    endif;
  else if h==215 && $LAY.software==0xA5 then
    testertype=TT_A5;                  // A5 special model
  else if h==200 then
    if w==520 && $LAY.software==0xA5 then
      testertype=TT_A5;                // A5
    else if w==450 then
      testertype=TT_A3;                // A3
    else if w==520 then
      testertype=TT_A3L;               // A3L
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 450 or 520 for A3/A5 testers. "
    endif
  else if h==225 || h==230 || h==240 then
    if w==610 && $LAY.software==0xA5 then
      testertype=TT_A5L;               // A5L
    else if w>=610 && w<=625 && $LAY.software==0xA5 &&                         \
      ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      testertype=TT_A5L;               // A5A (L&M automate)
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 610 for A5L testers. "
    endif
  else if h>=250 && h<=260 then
    if $LAY.software==0xB7 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A7;                // A7
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text="Unable to recognize the type of the tester. "
    endif
  else
    testertype=TT_WRONG;               // Tester not recognized
    draw text="Unable to recognize the type of the tester. "
    if h!=155 && h!=200 then
      draw color=BLACK text="Strange height of the rail "
      draw text=format("(%i millimeters instead of expected 155, ",h)
      draw text="200, 230, 240 or 255) is encountered. "
    endif
  endif
  if testertype==TT_WRONG || testertype==TT_UNDEF || testertype==TT_M2 then
    draw color=BLACK
    draw text="Therefore I don't know how to run the test. Please "
    if testertype!=TT_M2 && $LAY.cameras!=0 then
      draw text="check the settings in the layout and correct them, or "
    endif
    draw text="use different test procedure which supports given machine."
    draw at 6,30 color=LIGHTRED text="Unrecoverable error detected!"
    draw show
    clear hleft
    change hleft help="无法使用这种测试机"
    draw window=hleft color=DARKGRAY font=LARGEFONT mode=M_CENTERED
    draw at 95,70 bitmap=0,0,0,"unknown"
    draw show
    change hinfo limits=0,0
    change hinfo text="Unable to test"
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="！！..."
      help="按下可以终止测试"
    endc
    while Pressed(hok)==0 && Pressed(hexit)==0 do
      wait
    enddo
    testertype=TT_WRONG
  else if testertype==TT_A2 || testertype==TT_A2L || testertype==TT_A2H ||     \
    testertype==TT_A4 || testertype==TT_A6 || testertype==TT_S1 ||             \
    testertype==TT_S3 || (testertype==TT_S2 && $LAY.nfing>4) ||                \
    (testertype==TT_A8 && $LAY.nfing>4)                                        \
  then
    if firstrail==0 && lastrail==0 then
      yshift=$LAY.bottom[0]/1000.0
    else if testertype==TT_S3 && maxrail==1 then
      yshift=$LAY.bottom[0]/1000.0
    else
      yshift=$LAY.top[0]/1000.0        // Pads on the border between two rails
    endif

    //////////////////////////////////ADD MORE OPTIONS! -----===================

    for i=0,i<$LAY.nfing*2,i++ do
      if $LAY.top[i/2]/1000.0<=ymax then
        ypos[i]=$LAY.top[i/2]/1000.0-yshift
      else
        ypos[i]=$LAY.bottom[i/2]/1000.0-yshift
      endif
    enddo
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=118.0
    endif
  else if testertype==TT_S2 then       // S2/8
    yshift=$LAY.top[0]/1000.0-155.0
    for i=0,i<$LAY.nfing*2,i++ do
      ypos[i]=155.0;
    enddo
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=118.0
    endif
  else if testertype==TT_A7 && testersides==0x03 && $LAY.nfing>=6 then
    // Note: XXL A7 board needed (boardtype=2).
    if $LAY.nfing<=8 then
      yshift=$LAY.top[0]/1000.0-250.0  // Second row between rails 0 and 1
      for i=0,i<$LAY.nfing*2,i++ do
        ypos[i]=$LAY.yoffset[i/2]/1000.0-yshift+125.0
        while ypos[i]>875.0 do
          ypos[i]=ypos[i]-250.0
        enddo
      enddo
    else
      yshift=$LAY.top[0]/1000.0        // First row between rails 0 and 1
      for i=0,i<$LAY.nfing*2,i++ do
        ypos[i]=$LAY.yoffset[i/2]/1000.0-yshift+125.0
        while ypos[i]>875.0 do
          ypos[i]=ypos[i]-250.0
        enddo
      enddo
    endif
/*
    // Note: XXL A7 board needed (boardtype=2).
    if $LAY.nfing<=8 then
      yshift=$LAY.top[0]/1000.0-250.0  // Second row between rails 0 and 1
      for i=0,i<$LAY.nfing*2,i++ do
        if $LAY.top[i/2]/1000.0<=ymax then
          ypos[i]=$LAY.yoffset[i/2]/1000.0-yshift+125.0
        else
          ypos[i]=$LAY.yoffset[i/2]/1000.0-yshift-125.0
        endif
      enddo
    else
      yshift=$LAY.top[0]/1000.0        // First row between rails 0 and 1
      for i=0,i<$LAY.nfing*2,i++ do
        ypos[i]=$LAY.yoffset[i/2]/1000.0-yshift+125.0
      enddo
    endif
*/

    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=183.0
    endif
  else                                 // A3/A5/A7 modifications
    yshift=$LAY.top[0]/1000.0-155.0
    for i=0,i<$LAY.nfing*2,i++ do
      if boardtype==1 then
        ypos[i]=155.0
      else if $LAY.yoffset[i/2]/1000.0<155.0 then
        ypos[i]=0.0
      else
        ypos[i]=310.0;
      endif
    enddo
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=153.0
    endif
  endif
  zheadtype=$EXTLAY.zheadtype
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) &&                                 \
    (((zheadtype & HCZ_VALID)!=0 &&                                            \
    ((zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL ||                                \
    (zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL ||                                \
    (zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP)) ||                               \
    ((zheadtype & HCZ_VALID)==0 && ($LAY.config & 0x00000100)!=0)) then
    pfactor=10.0
  else
    pfactor=1.0
  endif
  // Find alternative Y positions within the wire.
  for i=0,i<$LAY.nfing*2,i++ do
    rail=i/2
    if testertype==TT_A7 && testersides==0x03 && $LAY.nfing>=6 then
      // Board type 2
      ya=ypos[i]-250.0
      yb=ypos[i]+250.0
    else
      ya=ypos[i]-155.0
      yb=ypos[i]+155.0
    endif
    if ya>=0.0 && ya<=(boardtype==2?750.0:310.0) &&                            \
      ya+yshift<=$LAY.top[rail]/1000.0 &&                                      \
      ya+yshift>=$LAY.bottom[rail]/1000.0 then
      yalt[i]=ya
    else if yb>=0.0 && yb<=(boardtype==2?750.0:310.0) &&                       \
      yb+yshift<=$LAY.top[rail]/1000.0 &&                                      \
      yb+yshift>=$LAY.bottom[rail]/1000.0 then
      yalt[i]=yb
    else
      yalt[i]=-9.9e99
    endif
  enddo
end

// Sets handicaps. Returns 0 on success or -1 if user interrupted test.
function int Setmode()
  int i
  handle hboth,htop,hbottom,hframe,hall,hselected,hfrom,hto,hok
  usesides=testersides
  clear hright
  change hinfo limits=0,0
  change hinfo text="轨道设置"
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="如果一些轨道被屏蔽或者不校验的选部分\n轨道."
  draw text="校验所有测试头就选择" font=INFOFONT text="双面/全部"
  draw font=TIMESFONT text="然后点 " font=MAINFONT text="确定"
  //draw font=TIMESFONT text=" to test all heads."
  draw at 6,116 font=INFOFONT text="面:"
  hboth=control RADIO
    window=hright
    position=56,100,140,18
    name="双面"
    help="选择做测试机的双面测试(默认)"
    font=INFOFONT
  endc
  htop=control RADIO
    window=hright
    position=56,119,140,18
    name="仅顶面"
    help="选择仅做正面测试头测试"
    font=INFOFONT
  endc
  hbottom=control RADIO
    window=hright
    position=56,138,140,18
    name="仅底面"
    help="选择仅做背面测试头测试"
    font=INFOFONT
  endc
  if testersides==0x1 then
    change htop mode=M_CHECKED
    disable hbottom
    disable hboth
  else if testersides==0x2 then
    change hbottom mode=M_CHECKED
    disable htop
    disable hboth
  else
    change hboth mode=M_CHECKED
  endif
  draw show
  hframe=control CHILD
    window=hright
    position=0,170,RIGHTX,50
    help=" "
    color=WHITE
    bkcolor=WHITE
    size=256
  endc
  draw window=hframe font=INFOFONT color=BLACK
  draw at 6,17 text="轨道:"
  hall=control RADIO
    window=hframe
    position=56,1,140,19
    name="全"
    help="选择测试被选中的面的所有轨道"
    font=INFOFONT
  endc
  hselected=control RADIO
    window=hframe
    position=56,24,48,19
    name="从"
    help="选择仅去测试被选中的那组轨道"
    font=INFOFONT
  endc
  hfrom=control COMBOLIST
    window=hframe
    position=109,21,59,90
    mode=M_VSCROLL
  endc
  draw at 172,40 text="到"
  hto=control COMBOLIST
    window=hframe
    position=189,21,59,90
    mode=M_VSCROLL
  endc
  if testersides==0x3 then
    for i=0,i<$LAY.nfing/2,i++
      add hfrom text=format(" %i (%i)",i,i+$LAY.nfing/2)
      add hto text=format(" %i (%i)",i,i+$LAY.nfing/2)
    enddo
    change hfrom help="从正面（背面）轨道开始测试"
    change hto help="用于测试的截至轨道正面（背面）"
  else
    for i=0,i<$LAY.nfing,i++
      add hfrom text=format("  %i",i)
      add hto text=format("  %i",i)
    enddo
    change hfrom help="Start test from the rail"
    change hto help="Last rail included into the test"
  endif
  change hfrom select=firstrail
  change hto select=lastrail
  if $LAY.excludedrails==0 then
    change hall mode=M_CHECKED
  else
    change hselected mode=M_CHECKED
  endif
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+30,120,24
    name="确定"
    help="Confirm settings and proceed with the test"
  endc
  while 1 do
    if Pressed(hexit)!=0 then
      return -1
    else if Pressed(hok) then
      break
    else if Pressed(hboth) then
      usesides=0x3
    else if Pressed(htop) then
      usesides=0x1
    else if Pressed(hbottom) then
      usesides=0x2
    else if Pressed(hfrom) then
      change hselected mode=M_CHECKED
      firstrail=Status(hfrom)
      lastrail=Status(hto)
      if lastrail<firstrail lastrail=firstrail
      change hfrom select=firstrail
      change hto select=lastrail
    else if Pressed(hto) then
      change hselected mode=M_CHECKED
      firstrail=Status(hfrom)
      lastrail=Status(hto)
      if lastrail<firstrail firstrail=lastrail
      change hfrom select=firstrail
      change hto select=lastrail
    endif
    wait
  enddo
  if Status(hall)!=0 then
    firstrail=0
    lastrail=maxrail
  else
    firstrail=Status(hfrom)
    lastrail=Status(hto)
  endif
  if lastrail<firstrail firstrail=lastrail
  // Set list of heads allowed for the low resistance test.
skipsetmode:
  for i=0,i<$LAY.nfing*2,i++ do
    if i<=maxrail*2+1 && (i<firstrail*2 || i>lastrail*2+1) then
      used[i]=0
    else if i>=$LAY.nfing &&                                                   \
      (i<firstrail*2+$LAY.nfing || i>lastrail*2+$LAY.nfing+1) then
      used[i]=0
    else if $LAY.side[i/2]==0 && (usesides & 0x1)!=0 then
      used[i]=1
    else if $LAY.side[i/2]!=0 && (usesides & 0x2)!=0 then
      used[i]=1
    else
      used[i]=0
    endif
  enddo
  return 0
end

// Selects crosses that will be used to scan board position. Assumes that board
// type, yshift and handicaps are already set.
function int Setcrosses()
  int i,j,channel,side
  float y0,y1,angle
  crosstype=-1
  if boardtype==0 then
    // On the dedicated (old) board we have no choice.
    crossx[0]=0.0; crossy[0]=-30.0
    crossx[1]=0.0; crossy[1]=340.0
    crosstype=0
  else if boardtype==1 then
    // New (combo) board, try 7 combinations.
    for i=1,i<8,i++ do
      switch i
      case 1:                          // Full-length vertical base
        crossx[0]=0.0; crossy[0]=7.0; crossx[1]=0.0; crossy[1]=303.0
      case 2:                          // Half-length vertical base bottom
        crossx[0]=0.0; crossy[0]=7.0; crossx[1]=0.0; crossy[1]=141.0
      case 3:                          // Half-length vertical base top
        crossx[0]=0.0; crossy[0]=169.0; crossx[1]=0.0; crossy[1]=303.0
      case 4:                          // Horizontal base center (lower)
        crossx[0]=0.0; crossy[0]=141.0; crossx[1]=78.2; crossy[1]=141.0
      case 5:                          // Horizontal base center (upper)
        crossx[0]=0.0; crossy[0]=169.0; crossx[1]=78.2; crossy[1]=169.0
      case 6:                          // Horizontal base bottom
        crossx[0]=0.0; crossy[0]=7.0; crossx[1]=78.2; crossy[1]=7.0
      case 7:                          // Horizontal base top
        crossx[0]=0.0; crossy[0]=303.0; crossx[1]=78.2; crossy[1]=303.0
      endsw
      // Check whether combination is acceptable.
      y0=crossy[0]+yshift
      y1=crossy[1]+yshift
      if $LAY.cameras!=0 && y0>=$LAY.bottom[$LAY.nfing]/1000.0 &&              \
        y1<$LAY.top[$LAY.nfing]/1000.0 then
        crosstype=i
        break
      else if $LAY.cameras==0 && $LAY.headcameras!=0 &&                        \
        Camerafromy(y0,&channel,&side,&angle)>=0 &&                            \
        Camerafromy(y1,&channel,&side,&angle)>=0 then
        crosstype=i
        break
      endif
    enddo
  else
    // XXL board for A7.
    for i=1,i<13,i++ do
      switch i
      case 1:                          // Full-length vertical base
        crossx[0]=-78.2; crossy[0]=0.0
        crossx[1]=-78.2; crossy[1]=750.0
      case 2,3:                        // Two-third vertical base
        crossx[0]=-78.2; crossy[0]=250.0*(i-2)
        crossx[1]=-78.2; crossy[1]=250.0*(i-0)
      case 4,5,6:                      // One-third vertical base
        crossx[0]=-78.2; crossy[0]=250.0*(i-4)
        crossx[1]=-78.2; crossy[1]=250.0*(i-3)
      case 7:                          // Horizontal base (bottom)
        crossx[0]=-78.2; crossy[0]=0.0
        crossx[1]=78.2; crossy[1]=7.0
      case 8:                          // Horizontal base (top)
        crossx[0]=-78.2; crossy[0]=750.0
        crossx[1]=78.2; crossy[1]=743.0
      case 9,10:                       // Horizontal base (up-oriented)
        crossx[0]=-78.2; crossy[0]=250.0*(i-8)
        crossx[1]=78.2; crossy[1]=250.0*(i-8)+14.0
      case 11,12:                      // Horizontal base (down-oriented)
        crossx[0]=-78.2; crossy[0]=250.0*(i-10)
        crossx[1]=78.2; crossy[1]=250.0*(i-10)-14.0
      endsw
      // Check whether combination is acceptable.
      y0=crossy[0]+yshift
      y1=crossy[1]+yshift
      if $LAY.cameras!=0 && y0>=$LAY.bottom[$LAY.nfing]/1000.0 &&              \
        y1<$LAY.top[$LAY.nfing]/1000.0 then
        crosstype=i
        break
      else if $LAY.cameras==0 && $LAY.headcameras!=0 &&                        \
        Camerafromy(y0,&channel,&side,&angle)>=0 &&                            \
        Camerafromy(y1,&channel,&side,&angle)>=0 then
        crosstype=i
        break
      endif
    enddo
  endif
end

// Reads current tester temperature (in 1/10-th of degree). If necessary, uses
// USB sensor. If operator interrupted C adjust, returns -1. if there was a
// command sending or receiving error, returns 1. Otherwise, returns
// temperature in the range 10..999, which corresponds to 1..99.9 degrees. It
// is the responsibility of caller to display and process errors.
function int Readtemperature()
  int ident,t,temp
  char s[128]
  float etemp
  if ($EXTLAY.measopt & HCM_TMEASOFF) then
    temp=220                           // Default temperature
  else
    sprintf(s,"INPORT %i",0x2011)      // Read effective (smoothed) temperature
    ident=SERV.Cmdimm(32,s)
    if ident<=0 return 1               // Unable to send command
    t=Time()                           // Timeout 5 seconds
    while $A[32].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Time()-t>5000 return 1        // Timeout exhausted
      wait
    enddo
    if $A[32].length!=7 return 1       // Bad length of answer
    if $A[32].answer!=S_INPORT return 1// Bad answer
    temp=$uint2($A[32]+5)
  endif
  if temp==220 then                    // Default temperature, try USB sensor
    if SYS.Exttemperature(&etemp)==0 then
      temp=Floor(etemp*10.0+0.5)
    endif
  endif
  return Min(999,Max(10,temp))
end

// Splits string s in two on the space so that the length of string s1 does not
// exceed limit characters.
function int Splittext(char *s,int limit,char *s1,char *s2)
  int i
  i=Strlen(s)
  if i<=limit then
    Strcpy(s1,s)
    s2[0]='\0'
  else
    for i=limit,i>1,i-- do
      if s[i]==' ' break
    enddo
    Memcpy(s1,s,i); s1[i]='\0'
    Strcpy(s2,s+i+1)
  endif
end

// Creates log file (text format) and writes header with tester information.
function int Createlogfile()
  int j,n,t
  char s[256],s1[128],s2[128],type[64]
  hlog=Fopen("lowrtest.txt","wt")
  if hlog!=NULL then
    txtok=1
    if testertype==TT_A2 then
      j=sprintf(type,"A2/%i",$LAY.nfing*2)
    else if testertype==TT_A2L then
      j=sprintf(type,"A2/%iL",$LAY.nfing*2)
    else if testertype==TT_A2H then
      j=sprintf(type,"A2/%iM",$LAY.nfing*2)
    else if testertype==TT_A3 || testertype==TT_A3L then
      j=sprintf(type,"A3/%i",$LAY.nfing*2)
    else if testertype==TT_A4 then
      j=sprintf(type,"A4/%i",$LAY.nfing*2)
    else if testertype==TT_A5 then
      j=sprintf(type,"A5/%i",$LAY.nfing*2)
    else if testertype==TT_A5L then
      j=sprintf(type,"A5/%iL",$LAY.nfing*2)
    else if testertype==TT_A6 then
      j=sprintf(type,"A6/%i",$LAY.nfing*2)
    else if testertype==TT_S1 then
      j=sprintf(type,"S1/%i",$LAY.nfing*2)
    else if testertype==TT_S2 then
      j=sprintf(type,"S2/%i",$LAY.nfing*2)
    else if testertype==TT_S3 then
      j=sprintf(type,"S3/%i",$LAY.nfing*2)
    else if testertype==TT_A7 then
      j=sprintf(type,"A7/%i",$LAY.nfing*2)
    else if testertype==TT_A8 then
      j=sprintf(type,"A8/%i",$LAY.nfing*2)
    else
      j=sprintf(type,"Unknown")
    endif
    if $LAY.cameras==1 || $LAY.cameras==2 then
      j=j+sprintf(type+j," with 1 camera")
    else if $LAY.cameras==3 then
      j=j+sprintf(type+j," with 2 cameras")
    endif
    fprintf(hlog,"\n                ")
    fprintf(hlog,"L O W   R E S I S T A N C E  M E A S U R E M E N T S\n\n")
    fprintf(hlog,"                                  ")
    fprintf(hlog,"Version %s\n\n",VERSION)
    fprintf(hlog,"      Tester type:        %s\n",type)
    Splittext(crateversion,50,s1,s2)
    fprintf(hlog,"      Crate controller:   %s\n",s1)
    if s2[0]!='\0' fprintf(hlog,"                          %s\n",s2)
    Splittext(layoutversion,50,s1,s2)
    fprintf(hlog,"      Layout:             %s\n",s1)
    if s2[0]!='\0' fprintf(hlog,"                          %s\n",s2)
    Splittext(headversion,50,s1,s2)
    fprintf(hlog,"      Head controller:    %s\n",s1)
    if s2[0]!='\0' fprintf(hlog,"                          %s\n",s2)
    fprintf(hlog,"      Probes:             ")
    if ($EXTLAY.zheadtype & HCZ_VALID)==0 then
      fprintf(hlog,"Default")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTDEF then
      fprintf(hlog,"Default")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL then
      fprintf(hlog,"Soft splinogramm")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL then
      fprintf(hlog,"Hard splinogramm")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTEMU then
      fprintf(hlog,"Hard on adapter")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSTD then
      fprintf(hlog,"Hard")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
      fprintf(hlog,"Soft Kelvin")
    endif
    if ($LAY.probetype & 1)!=0 &&                                              \
      ($EXTLAY.zheadtype & HCZ_CONTMASK)!=HCZ_CONTSKP                          \
    then
      fprintf(hlog," Kelvin")
    endif
    fprintf(hlog,"\n")
    if boardtype==0 then
      fprintf(hlog,"      Test tool:          BEL373\n")
    else if boardtype==1 then
      fprintf(hlog,"      Test tool:          Combo R-C board\n")
    else
      fprintf(hlog,"      Test tool:          Combo R-C board XXL\n")
    endif
    Strtime(s,   "      Start on:           %a %d-%b-%Y %H:%M\n",0,0)
    fprintf(hlog,"%s",s)
    t=Readtemperature()
    fprintf(hlog,"      Tester temperature: ")
    if t>=10 && t<990 then
      fprintf(hlog,"%.1f C\n",t/10.0)
    else
      fprintf(hlog,"Unable to measure\n")
    endif
    fprintf(hlog,"\n      Calibrated resistances:\n")
    for j=0,j<NSLOT,j++ do
      n=fprintf(hlog,"      %s",meas[is1mohm][j]+16)
      for n=n,n<26,n++ do
        fprintf(hlog," ")
      enddo
      if rexp[is1mohm][j]<5.0 then
        fprintf(hlog,"%8.6f Ohm\n",rexp[is1mohm][j])
      else
        fprintf(hlog,"%8.5f Ohm\n",rexp[is1mohm][j])
      endif
    enddo
    fprintf(hlog,"\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
end

// Creates log file (Rich Text format) and writes header with tester
// information.
function int Creatertffile()
  int i,j,k,t
  char s[256],time[256],s1[128],s2[128],type[64]
  if rtfok!=0 return                   // Already open
  i=ROpen("lowrtest.rtf")
  if i==0 then
    rtfok=1
    if testertype==TT_A2 then
      j=sprintf(type,"A2/%i",$LAY.nfing*2)
    else if testertype==TT_A2L then
      j=sprintf(type,"A2/%iL",$LAY.nfing*2)
    else if testertype==TT_A2H then
      j=sprintf(type,"A2/%iM",$LAY.nfing*2)
    else if testertype==TT_A3 || testertype==TT_A3L then
      j=sprintf(type,"A3/%i",$LAY.nfing*2)
    else if testertype==TT_A4 then
      j=sprintf(type,"A4/%i",$LAY.nfing*2)
    else if testertype==TT_A5 then
      j=sprintf(type,"A5/%i",$LAY.nfing*2)
    else if testertype==TT_A5L then
      j=sprintf(type,"A5/%iL",$LAY.nfing*2)
    else if testertype==TT_A6 then
      j=sprintf(type,"A6/%i",$LAY.nfing*2)
    else if testertype==TT_S1 then
      j=sprintf(type,"S1/%i",$LAY.nfing*2)
    else if testertype==TT_S2 then
      j=sprintf(type,"S2/%i",$LAY.nfing*2)
    else if testertype==TT_S3 then
      j=sprintf(type,"S3/%i",$LAY.nfing*2)
    else if testertype==TT_A7 then
      j=sprintf(type,"A7/%i",$LAY.nfing*2)
    else if testertype==TT_A8 then
      j=sprintf(type,"A8/%i",$LAY.nfing*2)
    else
      j=sprintf(type,"Unknown")
    endif
    if $LAY.cameras==1 || $LAY.cameras==2 then
      j=j+sprintf(type+j," with 1 camera")
    else if $LAY.cameras==3 then
      j=j+sprintf(type+j," with 2 cameras")
    endif
    Strtime(time,"%a %d-%b-%Y %H:%M",0,0)
    RParagraph(RTF_CENTERED|RTF_HEADER|RTF_FIRST)
    RFmt(RTF_TIMES,RTF_ITALIC,12)
    RAddtext(" ")
    RParagraph(RTF_CENTERED|RTF_HEADER|RTF_THINBRD)
    RFmt(RTF_TIMES,RTF_ITALIC,9)
    RAddfmt("Low resistance measurements %s - page ",time)
    RAddpagenumber()
    RParagraph(RTF_CENTERED|RTF_SPACE)
    RFmt(RTF_ARIAL,RTF_BOLD|RTF_UL,18)
    RAddtext("Low resistance measurements")
    RFmt(RTF_ARIAL,RTF_BOLD,14)
    RAddfmt("\n\nVersion %s",VERSION)
    RParagraph(RTF_LEFT)
    RFmt(RTF_TIMES,RTF_NORMAL,12)
    RAddfmt("\n\tTester type:\t\t%s\n",type)
    Splittext(crateversion,50,s1,s2)
    RAddfmt("\tCrate controller:\t%s\n",s1)
    if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
    Splittext(layoutversion,50,s1,s2)
    RAddfmt("\tLayout:\t\t%s\n",s1)
    if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
    Splittext(headversion,50,s1,s2)
    RAddfmt("\tHead controller:\t%s\n",s1)
    if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
    if ($EXTLAY.zheadtype & HCZ_VALID)==0 then
      j=Strcpy(s,"Default")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTDEF then
      j=Strcpy(s,"Default")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL then
      j=Strcpy(s,"Soft splinogramm")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL then
      j=Strcpy(s,"Hard splinogramm")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTEMU then
      j=Strcpy(s,"Hard on adapter")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSTD then
      j=Strcpy(s,"Hard")
    else if ($EXTLAY.zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP then
      j=Strcpy(s,"Micro probes")
    else
      j=Strcpy(s,"Unknown")
    endif
    if ($LAY.probetype & 1)!=0 then
      Strcpy(s+j,", Kelvin")
    endif
    RAddfmt("\tProbes:\t\t%s\n",s)
    if boardtype==0 then
      RAddtext("\tTest tool:\t\tBEL373\n")
    else if boardtype==1 then
      RAddtext("\tTest tool:\t\tCombo R-C board\n")
    else
      RAddtext("\tTest tool:\t\tCombo R-C board XXL\n")
    endif
    RAddfmt("\tStart on:\t\t%s\n",time)
    t=Readtemperature()
    RAddtext("\tTester temperature:\t")
    if t>=10 && t<990 then
      RAddfmt("%.1f °C\n",t/10.0)
    else
      RAddtext("Unable to measure\n")
    endif
    RAddfmt("\n")
    RFmt(RTF_TIMES,RTF_BOLD,12)
    RAddfmt("\tCalibrated resistances:\n")
    RFmt(RTF_TIMES,RTF_NORMAL,12)
    for k=0,k<NSLOT,k++ do
      if rexp[is1mohm][k]<5.0 then
        sprintf(s,"%8.6f Ohm",rexp[is1mohm][k])
      else
        sprintf(s,"%8.5f Ohm",rexp[is1mohm][k])
      endif
      RAddfmt("\t%-10s\t\t%s\n",meas[is1mohm][k]+16,s)
    enddo
    RAddfmt("\n")
    RFmt(RTF_TIMES,RTF_BOLD,12)
    RAddfmt("\tResistance of connecting lines:\n")
    RFmt(RTF_TIMES,RTF_NORMAL,12)
    if boardtype==2 then
      RAddfmt("\t%-10s\t\t%8.6f Ohm\n","250-mm wire",rline)
    else
      RAddfmt("\t%-10s\t\t%8.6f Ohm\n","155-mm wire",rline)
    endif
  endif
end

// Closes log file(s).
function int Closelogfiles()
  char s[128]
  Strtime(s,"%a %d-%b-%Y %H:%M\n",0,0)
  if hlog!=NULL then
    fprintf(hlog,"\n      Finished on:        %s",s)
    Fclose(hlog)
    hlog=NULL
    txtok=0
  endif
  if rtfok then
    RParagraph(RTF_LEFT)
    RFmt(RTF_TIMES,RTF_NORMAL,12)
    RAddfmt("\n\tFinished on:\t\t%s\n",s)
    RClose()
    rtfok=0
  endif
end

// Initializes error list.
function int Initerrlist()
  Memset(errlist,0,Sizeof(errlist))
end

// Adds error to rail. To add general errors, set rail=-1.
function int Adderr(int rail,format text)
  int i
  if rail<0 || rail>16 rail=16
  for i=0,i<NERR,i++ do
    if errlist[rail,i][0]=='\0' then
      Strcpy(errlist[rail,i],text)
      break
    else if Strcmp(errlist[rail,i],text)==0 then
      break                            // Identical string
    endif
  enddo
end

// Writes error list to protocols.
function int Flusherrlist()
  int i,j,rail,nlines
  nlines=0
  for i=-1,i<16,i++ do
    rail=(i<0?16:i)
    for j=0,j<NERR,j++ do
      if errlist[rail,j][0]=='\0' break
      if nlines==0 then                // List begins
        if txtok then
          fprintf(hlog,"\n\n     List of errors detected during this test:\n")
        endif
        if rtfok then
          RParagraph(RTF_FORMAT|RTF_INDENT); RFmt(RTF_TIMES,RTF_BOLD,9)
          RAddtext("\nList of errors detected during this test:\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
      endif
      if txtok then
        if j>0 then                    // Next rail-related line
          fprintf(hlog,"               ")
        else if rail==16 then          // General message
          fprintf(hlog,"\n     General:  ")
        else                           // Rail
          fprintf(hlog,"\n     Rail %2i:  ",rail)
        endif
        fprintf(hlog,"%s%s\n",errlist[rail,j],(j==NERR-1?"...":""))
      endif
      if rtfok then
        if j>0 then                    // Next rail-related line
          RAddtext("\t")
        else if rail==16 then          // General message
          RFmt(RTF_TIMES,RTF_NORMAL,3); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddtext("General:  ")
        else                           // Rail
          RFmt(RTF_TIMES,RTF_NORMAL,3); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddfmt("Rail %2i:   ",rail)
        endif
        RAddfmt("\t%s%s\n",errlist[rail,j],(j==NERR-1?"...":""))
      endif
      nlines++
      if nlines>50 then                // Limit number of messages
        if txtok then
          fprintf(hlog,"\n     Number of errors exceeds 50. ")
          fprintf(hlog,"All remaining messages are discarded.\n")
        endif
        if rtfok then
          RFmt(RTF_TIMES,RTF_NORMAL,3); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_BOLD,9)
          RAddtext("Number of errors exceeds 50. ")
          RAddtext("All remaining messages are discarded.")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
        return
      endif
    enddo
  enddo
end

// Starts legend in open TXT and RTF protocols.
function int Startexplanation(int largefont)
  if txtok then
    fprintf(hlog,"\n")
    Strcpy(expl,"     "); nexpl=5
  endif
  if rtfok then
    RParagraph(RTF_FORMAT)
    if largefont then
      RFmt(RTF_TIMES,RTF_NORMAL,12)
    else
      RFmt(RTF_TIMES,RTF_NORMAL,9)
    endif
    largeexplanation=largefont
    RAddtext("\n\t")
  endif
end

// Adds legend (explanation) to open TXT (with formatting) and RTF protocols.
// The formatting itself is rudimentary, don't use too long words.
function int Explain(int bold,format text)
  int i,j,k,changed,nonspace
  char s[1024]
  if txtok then
    i=0
    while text[i]!='\0' do
      if text[i]=='\n' then
        expl[nexpl]='\0'
        fprintf(hlog,"%s\n",expl)      // Flush and begin the new line
        Strcpy(expl,"     "); nexpl=5
        i++
        continue
      endif
      for j=i,text[j]!='\0' && text[j]!=' ' && text[j]!='\n',j++ do; enddo
      if (i==j && text[j]==' ') j++    // Single blank is allowed
      if nexpl+j-i>77 then
        while nexpl>1 && expl[nexpl-1]==' ' do nexpl--; enddo
        while nexpl<77 do              // Insert spaces for nice alignment
          k=0; changed=0; nonspace=0
          while nexpl<77 && k<nexpl do
            if expl[k]!=' ' then
              nonspace=1
            else if nonspace then
              Memcpy(expl+k+1,expl+k,nexpl-k)
              expl[k]=' '; k++
              while k<nexpl && expl[k]==' ' do k++; enddo
              nexpl++; changed=1
            endif
            k++
          enddo
        enddo
        expl[nexpl]='\0'
        fprintf(hlog,"%s\n",expl)      // Flush and begin the new line
        while text[i]==' ' do i++; enddo
        nexpl=0
      endif
      if j>i then
        Memcpy(expl+nexpl,text+i,j-i)
        nexpl=nexpl+j-i; i=j
      endif
    enddo
  endif
  if rtfok then
    RFmt(RTF_TIMES,bold?RTF_BOLD:RTF_NORMAL,largeexplanation?12:9)
    j=0
    for i=0,text[i]!='\0',i++ do
      s[j]=text[i]; j++
      if text[i]=='\n' then
        s[j]='\t'; j++
      endif
    enddo
    s[j]='\0'
    RAddtext(s)
  endif
end

// Adds centered text in big bold letters to protocols.
function int Texttolog(format text)
  int i,n
  if txtok then
    fprintf(hlog,"\n")
    n=Strlen(text)
    for i=0,i<(77-n)/2,i++ do
      fprintf(hlog," ")
    enddo
    fprintf(hlog,"%s\n\n",text)
  endif
  if rtfok then
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddtext("\n")
    RAddtext(text)
    RAddtext("\n")
  endif
end

// Finishes legend in open TXT file (RTF file is self-formatting).
function int Endexplanation()
  if txtok && nexpl>0 then
    expl[nexpl]='\0'
    fprintf(hlog,"%s\n",expl)      // Flush and begin new line
    nexpl=0
  endif
end

// Draws board in the shuttle.
function int Drawboard()
  int x0,x1,y,yl
  char s[256]
  clear hleft
  draw window=hleft color=WHITE bkcolor=WHITE clear
  if testertype==TT_A5L && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    if boardtype==0 then
      draw at 2,10 bitmap=0,0,0,"a5artest"
    else
      draw at 2,10 bitmap=0,0,0,"a5arctst"
    endif
  else if testertype==TT_A7 && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    if boardtype==0 then
      draw at 2,10 bitmap=0,0,0,"a7artest"
    else
      draw at 2,10 bitmap=0,0,0,"a7arctst"
    endif
  else if boardtype==2 then
    draw color=GRAY bkcolor=GRAY
    draw at 67,2 fillrect 88,318
    draw at 234,2 fillrect 254,318
    draw color=BLACK bkcolor=WHITE
    draw at 87,2 to 87,318
    draw at 87,8 fillrect 99,312
    draw at 233,2 to 233,318
    draw at 222,8 fillrect 234,312
    if $LAY.nfing<=8 then
      yl=205
      Strcpy(s,"Align with border between rails 0 and 1")
    else
      yl=294
      Strcpy(s,"Align with border between rails 0 and 1")
    endif
    draw at 98,6 bitmap=0,0,0,"rclarge"
    draw color=LIGHTRED
    draw at 92,yl to 33,yl to 33,325 to 63,325
    draw at 227,yl to 283,yl to 283,325 to 253,325
    draw font=SMALLFONT color=LIGHTRED mode=M_CENTERED at 160,332 text=s
  else if testertype==TT_S3 && $LAY.nfing==2 then
    draw color=DARKGRAY bkcolor=GRAY
    draw at 70,40 fillrect 250,220
    draw at 74,44 rect 246,216
    y=38
    if boardtype==0 then
      x0=127; x1=193
      draw at x0+2,y+15 clip x1-2,y+169 at x0,y bitmap=0,0,0,"c-rcsel"
    else
      x0=100; x1=221
      draw at x0+2,y+15 clip x1-2,y+169 at x0,y bitmap=0,0,0,"rcboard"
    endif
    if yshift==$LAY.bottom[0]/1000.0 then
      // Align bottom row with the bottom of the test area.
      yl=195
      Strcpy(s,"Align with the bottom of test area")
    else if yshift==$LAY.top[0]/1000.0 then
      // Align bottom row with the border between rails 0 and 1.
      yl=153
      Strcpy(s,"Align with border between rails 0 and 1")
    else
      // Align middle row with the border between rails 0 and 1.
      yl=88
      Strcpy(s,"对齐中间边界线")
    endif
    draw clip=NULL
    draw color=LIGHTRED
    draw at x0+10,yl to 33,yl to 33,250 to 63,250
    draw at x1-10,yl to 287,yl to 287,250 to 253,250
    draw font=SMALLFONT color=BLACK mode=M_CENTERED at 160,256 text=s
  else
    draw color=GRAY bkcolor=GRAY
    draw at 10,10 fillrect 310,288
    draw color=DARKGRAY bkcolor=WHITE
    draw at 23,22 fillrect 297,275
    if yshift==$LAY.bottom[0]/1000.0 then
      // Align bottom row with the bottom of the test area.
      y=98; yl=255
      Strcpy(s,"Align with the bottom of test area")
    else if yshift==$LAY.top[0]/1000.0 then
      // Align bottom row with the border between rails 0 and 1.
      y=56; yl=213
      Strcpy(s,"Align with border between rails 0 and 1")
    else
      // Align middle row with the border between rails 0 and 1.
      y=56; yl=148
      Strcpy(s,"对齐中间边界线")
    endif
    if boardtype==0 then
      x0=117; x1=204
      draw at x0+2,y+2 clip x1-2,y+182 at x0,y bitmap=0,0,0,"r-rcsel"
    else
      x0=100; x1=221
      draw at x0+2,y+2 clip x1-2,y+182 at x0,y bitmap=0,0,0,"rcboard"
    endif
    draw clip=NULL
    draw color=DARKGRAY bkcolor=WHITE
    draw at x0-10,28 fillrect x0+4,270
    draw at x1-4,28 fillrect x1+10,270
    draw color=DARKGRAY bkcolor=GRAY
    draw at x0-20,13 fillrect x0-2,285
    draw at x1+2,13 fillrect x1+20,285
    draw color=LIGHTRED
    draw at x0+10,yl to 33,yl to 33,300 to 63,300
    draw at x1-10,yl to 287,yl to 287,300 to 253,300
    draw font=SMALLFONT color=BLACK mode=M_CENTERED at 160,306 text=s
  endif
  draw show
  if boardtype==0 then
    change hleft help="Position of BEL373 in the shuttle"
  else
    change hleft help="Position of combo R-C board in the shuttle"
  endif
end

// Returns 0 on success, >0 in case of communication error or -1 if operator
// decided to interrupt the test.
function int Installboard(int isa4)
  int i,t,err,x,y,head,side,channel,portdata,prevdata,ident
  int movecamera,delta,videoon,videosizex,videosizey,changed
  float zoom,defzoom,xcoord,angle
  char s[256],buf[128]
  handle hold,hnew,hstatus,hlock,hunlock,hvideo,hok,hl,hc,hr
  handle hview,hlivevideo,hzoom
  handle hshuttlex,hshxscr,hshuttley,hshyscr
  clear hright
  change hinfo limits=0,0
  change hinfo text="放置板件"
  if testertype==TT_A2L then
    shuttlex=38
    shuttley=39
  else if testertype==TT_A3 then
    shuttlex=20
    shuttley=46
  else if testertype==TT_A3L || testertype==TT_A5 || testertype==TT_A5L then
    shuttlex=24
    shuttley=46
  else
    shuttlex=28
    shuttley=39
  endif
  if ($LAY.config & 0x0001C040)==0x00008040 then
    shuttlex=0.0                       // Automatical shuttle
  else if ($LAY.config & 0x0001C000)==0x0000C000 then
    shuttlex=28                        // A5 wide shuttle
  endif
  getini("LowRtest","Shuttle","%g,%g",&shuttlex,&shuttley)
  if boardtype==0 then
    hold=control RADIO
      window=hright
      position=9,140,RIGHTX-17,21
      name="旧版板件(小焊盘 1x2 mm)"
      font=MAINFONT
      help="Check if you have older board version"
      font=INFOFONT
      mode=(islargepads?0:M_CHECKED)
    endc
    hnew=control RADIO
      window=hright
      position=9,164,RIGHTX-17,21
      name="新版板件 (大焊盘 6x6 mm)"
      font=MAINFONT
      help="Check if you have new version of the low R test board"
      font=INFOFONT
      mode=(islargepads?M_CHECKED:0)
    endc
  else
    hold=NULL
    hnew=NULL
    islargepads=1
  endif
  if isa4 then
    hstatus=NULL
  else
    hstatus=control TEXT
      window=hright
      name="未知架板框状态"
      position=5,180,RIGHTX-10,21
      font=MEDIUMFONT
      color=BLACK
      bkcolor=PINK
      mode=M_CENTERED|M_BORDER
    endc
  endif
  if testertype==TT_S2 then
    hlock=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY-30,120,24
      name="锁定"
      help="Press to unlock the shuttle"
    endc
    hunlock=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY-30,120,24
      name="解锁"
      help="Press to lock the shuttle"
    endc
    hvideo=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="视频"
      help="Press to adjust Y board position using video camera"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="确定"
      help="Press when board is correctly installed"
    endc
  else
    hlock=NULL
    hunlock=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name=(isa4?"原位":"解锁")
      help=(isa4?"Press to home video camera":"Press to unlock the shuttle")
    endc
    hvideo=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="视频"
      help="Press to adjust Y board position using video camera"
    endc
    hok=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="确定"
      help="Press when board is correctly installed"
    endc
  endif
  draw window=hleft color=BLACK font=INFOFONT
  draw at 15,LEFTY-12 text="位置: X="
  draw at 220,LEFTY-12 text="Y="
  draw show
  hshuttlex=control EDIT
    window=hleft
    position=150,LEFTY-30,45,23
    text=format(" %.1f",shuttlex)
    help="X position of board in shuttle, shuttle units"
    font=MEDIUMFONT
  endc
  hshxscr=control VSCROLL
    window=hleft
    position=195,LEFTY-30,18,23
    help="Use to change shuttle X position for future use"
    limits=1,-1
  endc
  if ($LAY.config & 0x0001C040)==0x00008040 then
    disable hshuttlex
    disable hshxscr
  endif
  hshuttley=control EDIT
    window=hleft
    position=245,LEFTY-30,45,23
    text=format(" %.1f",shuttley)
    help="Y position of board in shuttle, shuttle units"
    font=MEDIUMFONT
  endc
  hshyscr=control VSCROLL
    window=hleft
    position=290,LEFTY-30,18,23
    help="Use to change shuttle Y position for future use"
    limits=1,-1
  endc
  if testertype!=TT_S3 then
    disable hvideo
    disable hok
  endif
  head=Camerafromy(yshift+rowdist,&channel,&side,&angle)
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if boardtype==0 then
    draw text="请放入左侧显示的精准电阻测试板(BEL373), "
  else
    draw text="请按左侧图片显示位置放置复合电阻电容"
  endif
  draw text="测试板。"
  if isa4 then
    draw text="When camera is over the board, press " font=MAINFONT text="Home"
    draw font=TIMESFONT text=" before you can open shuttle. "
  else if hlock!=NULL && hunlock!=NULL then
    draw text="Press " font=MAINFONT text="Lock " font=TIMESFONT
    draw text="and " font=MAINFONT text="Unlock " font=TIMESFONT
    draw text="to move the shuttle. "
  else
    draw text="可点 " font=MAINFONT text="解锁 " font=TIMESFONT
    draw text="松开架板框。\n"
    if head>=0 then
      draw text="架板框锁定时,可用" font=MAINFONT text="视频"
      draw font=TIMESFONT text="和机台上的'释放'\n按钮"
      draw text="调整板件Y方向的位置。"
    endif
  endif
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S2 && testertype!=TT_S3 && testertype!=TT_A7 &&             \
    testertype!=TT_A8 then
    draw text="Don't forget to update position of the board in shuttle; "
    draw text="this will help you to install board next time. "
  endif
    draw text="板件位置正"
    draw text="确后点"
    draw text="" font=MAINFONT text="确定." font=TIMESFONT
  //draw text="when board is correctly installed. "
  draw show
  t=0; err=0; videoon=0
  portdata=-1; prevdata=portdata
  while err==0 do
    if portdata!=prevdata then
      if isa4 then
        if head>=0 enable hvideo
        enable hok
      else
        i=portdata & 0x35
        if i==0x20 then                // Shuttle locked in test position
          if head>=0 || testertype==TT_S3 enable hvideo
          enable hok
          change hstatus text="架板框锁止"
        else if (i & 0x10)==0 && testertype!=TT_S1 &&                          \
          testertype!=TT_S2 then
          if testertype==TT_S3 then
            enable hvideo
            enable hok
          else
            disable hvideo
            disable hok
          endif
          change hstatus text="架板框进入中"
        else
          if testertype==TT_S3 then
            enable hvideo
            enable hok
          else
            disable hvideo
            disable hok
          endif
          change hstatus text="Shuttle out"
        endif
      endif
      prevdata=portdata
    endif
    if Pressed(hold) then
      islargepads=Status(hnew)
    else if Pressed(hnew) then
      islargepads=Status(hnew)
    else if hlock!=NULL && Pressed(hlock) then
      buf[0]=S_LOCKDOOR; buf[1]=1      // Lock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else if Pressed(hunlock) then
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      if videoon!=0 then
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        videoon=0
      endif
    else if head>=0 && Pressed(hvideo) then
      if videoon==0 then
        disable hshuttlex
        disable hshxscr
        disable hshuttley
        disable hshyscr
        hl=control BUTTON
          window=hright
          position=5,USERY+30,RIGHTX/3-5,24
          name="<< 向左"
          help="Move camera 2.5 mm to the left"
        endc
        hc=control BUTTON
          window=hright
          position=5+RIGHTX/3,USERY+30,RIGHTX/3-5,24
          name="中心"
          help="Quickly move camera to the center"
        endc
        hr=control BUTTON
          window=hright
          position=5+2*(RIGHTX/3),USERY+30,RIGHTX/3-9,24
          name="向右 >>"
          help="Move camera 2.5 mm to the right"
        endc
        hview=control CHILD            // Video is not yet here, create controls
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          bkcolor=VIDEOFILL
        endc
        Bccreate(hview,-1,-1,channel,1)
        hzoom=control CUSTOMBOX
          window=hview
          position=235,303,80,21
          name="缩放"
          help="Check to increase magnification by a factor of 2"
          color=BROWN
        endc
        SYS.Videosize(channel,&videosizex,&videosizey,&i)
        if videosizex==0 || videosizey==0 then
          defzoom=0.5
        else
          defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
        endif
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
          Bcgetbri(channel),Bcgetctr(channel),                                 \
          (channel<0?0:2)|(longexp?4:0),angle)
        movecamera=1; xcoord=$LAY.xoffset/1000.0
        x=(LEFTX-10)/2; y=288/2
        draw window=hlivevideo color=LIGHTRED
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        videoon=1
      else
        Bcdelete()                     // Video is already here, remove controls
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        enable hshuttlex
        enable hshxscr
        enable hshuttley
        enable hshyscr
        videoon=0
      endif
    else if Pressed(hok) && ((portdata & 0x35)==0x20 || testertype==TT_S3) then
      break
    else if Pressed(hexit) then
      err=-1
    else if Pressed(hshuttlex) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      shuttlex=Min(60.0,Max(0.0,shuttlex))
      change hshuttlex text=format(" %.1f",shuttlex)
    else if Pressed(hshxscr) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      delta=Status(hshxscr)
      shuttlex=Min(60.0,Max(0.0,shuttlex+delta*0.5))
      change hshuttlex text=format(" %.1f",shuttlex)
      change hshxscr select=0
    else if Pressed(hshuttley) then
      Text(hshuttley,s); sscanf(s,"%f",&shuttley);
      shuttley=Min(60.0,Max(0.0,shuttley))
      change hshuttley text=format(" %.1f",shuttley)
    else if Pressed(hshyscr) then
      Text(hshuttley,s); sscanf(s,"%f",&shuttley);
      delta=Status(hshyscr)
      shuttley=Min(60.0,Max(0.0,shuttley+delta*0.5))
      change hshuttley text=format(" %.1f",shuttley)
      change hshyscr select=0
    endif
    if videoon then
      changed=Bcupdate()
      if (changed & 0x01)!=0 || Pressed(hzoom) then
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      endif
      if Pressed(hc) then
        xcoord=$LAY.xoffset/1000.0
        movecamera=1
      else if Pressed(hl) then
        xcoord=Max(xcoord-2.5,leftvlimit)
        movecamera=1
      else if Pressed(hr) then
        xcoord=Min(xcoord+2.5,rightvlimit)
        movecamera=1
      endif
      if movecamera!=0 && head>=0 then
        if $LAY.cameras!=0 then
          sprintf(buf,"M %i(%g,%g) NOP",                                       \
          $LAY.nfing*2+channel,xcoord,yshift+rowdist)
        else if $LAY.headcameras!=0 then
          SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
          sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          SERV.Cmdimm(33,buf)
          sprintf(buf,"M @%i[%g,%g] NOP",head,xcoord,yshift+rowdist)
        endif
        SERV.Cmdimm(32,buf)            // Move camera to middle row of pads
        movecamera=0
      endif
    endif
    if t==0 then                       // Send next port query
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      ident=SYS.Sendimm(0,3,buf)
      t=Time()+10000                   // Timeout 10 seconds
    else if $A[0].length>0 then
      if $A[0].answer==S_INPORT then
        portdata=$A[0].inport          // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if t<Time() then
      SYS.Killsend(ident)
      err=1                            // No answer from tester
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  if videoon!=0 then
    Bcdelete()
    destroy hview
    destroy hl
    destroy hc
    destroy hr
    enable hshxscr
    enable hshyscr
  endif
  if err>0 then
    if head>=0 then
      sprintf(buf,"M %i(Z) NOP",head)
      SERV.Cmdimm(32,buf)              // Move camera in home position
    endif
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="Press to check tester status"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED text="Communication error! "
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from tester within 10 seconds. "
    else
      draw text="Test procedure received unexpected answer. "
    endif
    if err!=2 draw text="Please check connection with crate controller. "
    draw text="Press " font=MAINFONT text="Retry " font=TIMESFONT
    draw text="to check tester status and, eventually, reboot it."
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  if err==0 setini("LowRtest","Shuttle","%g,%g",shuttlex,shuttley)
  setini("LowRtest","Board type","%i,%i,%i",islargepads,boardtype,is1mohm)
  return err
end

// Asks L&M for the value of the specified parameter. Sets value to the received
// string <parm>=<answer> (i.e. parm and equation sign are included). Returns 0
// on success, 1 on failure and -1 if user cancelled test.
function int Getlmparameter(char *parm,char *value)
  int i,n
  char buf[768]
  SYS.Killimm(33)
  buf[0]=S_LMAUTO
  buf[1]=3                             // Get parameter
  n=2+sprintf(buf+2,"%s",parm)
  SYS.Sendimm(33,n,buf)
  while $A[33].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[33].answer!=S_LMAUTO return 1  // Bad answer
  for i=0,i<$A[33].length-6,i++ do
    value[i]=$char($A[33]+6+i)
  enddo
  value[i]='\0'
  return 0
end

// Sends text command to L&M automation and waits for answer. Returns 1 on
// success, 0 on failure, 2 on timeout and -1 if user cancelled test.
function int Sendlmcommand(char *cmd,char *answer,char *error,int timeout)
  int m,n,status
  char buf[768]
  SYS.Killimm(32)
  buf[0]=S_LMAUTO
  buf[1]=4                             // Send command
  $uint2(buf+2)=timeout                // Timeout, seconds
  n=4+sprintf(buf+4,"%s\n",cmd)
  n=n+sprintf(buf+n,"%s",answer)
  SYS.Sendimm(32,n,buf)
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[32].answer!=S_LMAUTO return 0  // Bad answer
  status=$uint2($A[32]+6)
  if (status & 0x01) return 2          // Timeout
  if $char($A[32]+8)=='1' then
    n=8
    m=0                                // Success
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      error[m]=$char($A[32]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 1
  else
    n=8                                // Error
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      n++
    enddo
    if $char($A[32]+n)=='\n' && n<$A[32].length n++
    m=0
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      error[m]=$char($A[32]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 0
  endif
end

// Gets actual teachin settings for L&M hardware. Settings are saved to the
// array lmteachin[], prefix MECH.Teachin is replaced by MECH.Para. Returns 0
// on success, >0 in the case of communication error or -1 if operator decided
// to interrupt the test.
function int Getteachinsettings()
  int i
  nlmteachin=0
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO return 0
  i=Getlmparameter("MECH.Teachin.ShuttleX",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  i=Getlmparameter("MECH.Teachin.ShuttleY",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  i=Getlmparameter("MECH.Para.BoardH",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  i=Getlmparameter("MECH.Para.BoardW",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  i=Getlmparameter("MECH.Para.UseCatcherOnly",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  return 0
end

// Installs low resistance test board in L&M automatical shuttle. Returns 0 on
// success, >0 in case of communication error or -1 if operator decided to
// interrupt the test.
function int InstallboardLM()
  int i,t,nfing,preset,prevdata,portdata,adjusting,adjusted,shuttle,delta,err
  char s[512],buf[256],errtxt[256]
  handle f,hold,hnew,hstatus,hload,hunload,hpreset,hadjust,hok,hyes,hno
  handle hshuttlex,hshxscr
  nfing=$LAY.nfing
  shuttle=0
  clear hright
  change hinfo limits=0,0
  getini("Cadjust","Shuttle","%g,%g",&shuttlex,&shuttley)
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  for i=0,i<nfing,i++
    if used[i*2]==0 continue           // Rail is excluded from calibration
    sprintf(buf,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,buf)
  enddo
  t=Time()
  while (1) do
    for i=0,i<nfing,i++
      if used[i*2]==0 continue
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=nfing break                  // All answers came
    if Pressed(hexit) return -1        // Operator interrupted test
    if Time()-t>10000 break            // No answer within 10 s timeout
    wait
  enddo
  // Check whether there is a board in the shuttle. It may happen that previous
  // test was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  if $A[32].length==7 && $A[32].answer==S_INPORT then
    portdata=$A[32].inport
  else
    portdata=0
  endif
  if (portdata & 0x35)!=0x20 then
    // Set positions of L&M actuators for low R test board.
    if boardtype==0 then
      f=Fopen("c:\\hardware\\shuttle_kelvin.txt","rb")
      if f!=NULL then
        Fclose(f)
        change hinfo text="Setting up shuttle..."
        i=Sendlmcommand("PS.Cmd=FileRead c:/hardware/shuttle_kelvin.txt",      \
          "PS.Ready.FileRead",errtxt,5)
        if i<0 return -1
        preset=(i==1)
      else
        preset=0                       // Shuttle positions not set
      endif
    else
      f=Fopen("c:\\hardware\\shuttle_comborc.txt","rb")
      if f!=NULL then
        Fclose(f)
        change hinfo text="Setting up shuttle..."
        i=Sendlmcommand("PS.Cmd=FileRead c:/hardware/shuttle_comborc.txt",     \
          "PS.Ready.FileRead",errtxt,5)
        if i<0 return -1
        preset=(i==1)
      else
        preset=0                       // Shuttle positions not set
      endif
    endif
  else
    preset=0
  endif
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    draw window=hleft color=BLACK font=INFOFONT
    draw at 15,LEFTY-12 text="位置: X="
    draw show
    hshuttlex=control EDIT
      window=hleft
      position=150,LEFTY-30,45,23
      text=format(" %.1f",shuttlex)
      help="X position of board in shuttle, shuttle units"
      font=MEDIUMFONT
    endc
    hshxscr=control VSCROLL
      window=hleft
      position=195,LEFTY-30,18,23
      help="Use to change shuttle X position for future use"
      limits=1,-1
    endc
  else
    hshuttlex=NULL
    hshxscr=NULL
  endif
  // Set manual automation mode.
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    change hinfo text="Setting pure manual mode..."
    if pulledshuttle<0 then
      i=Sendlmcommand("MECH.Cmd=SetMode 5","MECH.Ready.SetMode",errtxt,20)
    else
      i=0
    endif
    if i>=0 then
      if pulledshuttle<0 then
        sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i 2",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
      else
        sprintf(buf,"MECH.Cmd=A8eaRepositionPullCalib %i 2",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaRepositionPullCalib",errtxt,0xFFFF)
      endif
      if i>=0 pulledshuttle=shuttle
    endif
  else
    change hinfo text="Switching to manual mode..."
    i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,20)
  endif
  if i<0 return -1
  // Installation controls.
  change hinfo text="放置板件"
  if boardtype==0 then
    hold=control RADIO
      window=hright
      position=9,100,RIGHTX-17,21
      name="旧版板件(小焊盘 1x2 mm)"
      font=MAINFONT
      help="Check if you have older board version"
      font=INFOFONT
      mode=(islargepads?0:M_CHECKED)
    endc
    hnew=control RADIO
      window=hright
      position=9,124,RIGHTX-17,21
      name="新版板件 (大焊盘 6x6 mm)"
      font=MAINFONT
      help="Check if you have new version of the low R test board"
      font=INFOFONT
      mode=(islargepads?M_CHECKED:0)
    endc
  else
    hold=NULL
    hnew=NULL
    islargepads=1
  endif
  hstatus=control TEXT
    window=hright
    name="未知架板框状态"
    position=9,190,RIGHTX-17,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  hload=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY-15,120,24
    name="加载"
    help="Press to load low R test board from the rollband"
  endc
  hunload=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY-15,120,24
    name="卸载"
    help="Press to unload low R test board from the shutle"
  endc
  if preset==0 then
    hpreset=control BUTTON
      window=hright
      position=8,USERY+20,RIGHTX/3-8,24
      name="设置寸"
      help="Get board dimensions from the file shuttle_kelvin.txt"
    endc
    hadjust=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY+20,RIGHTX/3-5,24
      name="调试"
      help="Press to adjust shuttle using manual control box"
    endc
    hok=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY+20,RIGHTX/3-12,24
      name="确定"
      help="Press if low R test board is correctly installed"
    endc
  else
    hadjust=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY+20,120,24
      name="调试"
      help="Press to adjust shuttle using manual control box"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+20,120,24
      name="确定"
      help="Press if low R test board is correctly installed"
    endc
  endif
  disable hadjust
  disable hok
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if boardtype==0 then
    draw text="Now install the low R test board (BEL373-1). "
  else
    draw text="Now install the combo R-C test board. "
  endif
  draw text="Press " font=MAINFONT text="OK " font=TIMESFONT
  draw text="when board is correctly locked in the shuttle."
  draw show
  // Main loop.
  prevdata=-1
  adjusting=0
  adjusted=0
  t=0
  while err==0 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if adjusting then
        change hstatus text="Adjustment mode"
        enable hload
        disable hunload
        disable hadjust
        disable hok
        if preset==0 enable hpreset
      else if i==0x20 then             // Shuttle locked in test position
        change hstatus text="Board in the shuttle"
        disable hload
        enable hunload
        disable hadjust
        enable hok
        if preset==0 disable hpreset
      else
        change hstatus text="Shuttle out"
        enable hload
        enable hunload
        disable hadjust
        disable hok
        if preset==0 enable hpreset
      endif
      prevdata=portdata
    endif
    if Pressed(hold) then
      islargepads=Status(hnew)
    else if Pressed(hnew) then
      islargepads=Status(hnew)
    else if Pressed(hload) then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
        if pulledshuttle!=shuttle then
          pulledshuttle=shuttle
          sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i 2",shuttle)
          i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
          if i<0 return -1
        endif
      endif
      buf[0]=S_LOCKDOOR
      if testertype!=TT_S3 || ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
        buf[1]=1                       // Lock door
      else if shuttle==0 then
        buf[1]=80                      // Load board in left shuttle
      else
        buf[1]=81                      // Load board in right shuttle
      endif
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else if Pressed(hunload) then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then      ////////////////////CHECK, ALSO SEQUENCE
        sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i 2",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
        if i<0 return -1
        pulledshuttle=-1
      endif
    else if Pressed(hpreset) && preset==0 then
      f=Fopen("c:\\hardware\\shuttle_kelvin.txt","rb")
      if f!=NULL then
        Fclose(f)
        i=Sendlmcommand("PS.Cmd=FileRead c:/hardware/shuttle_kelvin.txt",      \
          "PS.Ready.FileRead",errtxt,5)
        if i<0 return -1
        preset=(i==1)
      else
        preset=0                         // Shuttle positions not set
      endif
      disable hpreset
/*
    else if Pressed(hadjust) then
      i=Sendlmcommand("MECH.Cmd=SetMode 4","MECH.Ready.SetMode",errtxt,60)
      if i<0 return -1
      i=Sendlmcommand("MECH.Para.Teachin=1","",errtxt,10)
      if i<0 return -1
      adjusting=1
      adjusted=1
      prevdata=-1
*/
    else if hshuttlex!=NULL && Pressed(hshuttlex) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      shuttlex=Min(100.0,Max(0.0,shuttlex))
      change hshuttlex text=format(" %.1f",shuttlex)
    else if hshxscr!=NULL && Pressed(hshxscr) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      delta=Status(hshxscr)
      shuttlex=Min(100.0,Max(0.0,shuttlex+delta*0.5))
      change hshuttlex text=format(" %.1f",shuttlex)
      change hshxscr select=0
    else if Pressed(hok) && (portdata & 0x35)==0x20 then
      setini("Cadjust","Shuttle","%g,%g",shuttlex,shuttley)
      if adjusted!=0 then
        // Shuttle settings were probably changed, ask to update file.
        clear hright
        change hinfo limits=0,0
        change hinfo text="Save shuttle settings"
        draw window=hright color=BLACK font=TIMESFONT
        draw at 6,30 wrap=RIGHTX-5
        draw text="Would you like to save the actual shuttle settings to the "
        draw text="disk, so that the next low R test will automatically use "
        draw text="them?\n\n" color=GRAY text="Note: board size and catchers "
        draw text="remain unchanged; if necessary, edit them directly in the "
        draw text="file c:\\hardware\\shuttle_kelvin.txt."
        hyes=control BUTTON
          window=hright
          position=RIGHTX/2-124,USERY,120,24
          name="是"
          help="Press to save shuttle settings to the file"
        endc
        hno=control BUTTON
          window=hright
          position=RIGHTX/2+5,USERY,120,24
          name="否"
          help="Press to use new shuttle settings in the current session only"
        endc
        while 1 do
          if Pressed(hexit) then
            return -1
          else if Pressed(hno) then
            break
          else if Pressed(hyes) then
            Getteachinsettings()
            if nlmteachin>0 then
              f=Fopen("c:\\hardware\\shuttle_kelvin.txt","wt")
              if f!=NULL then
                for i=0,i<nlmteachin,i++ do
                  fprintf(f,"%s\n",lmteachin[i])
                enddo
                Fclose(f)
              endif
            endif
            break
          endif
          wait
        enddo
      endif
      break
    else if Pressed(hexit) then
      return -1
    endif
    if t==0 then                       // Send next port query
      SYS.Killimm(32)
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      SYS.Sendimm(32,3,buf)
      t=Time()                         // Timeout 5 seconds
    else if $A[32].length>0 then
      if $A[32].answer==S_INPORT then
        portdata=$A[32].inport         // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if Time()-t>5000 then
      t=0
      err=1                            // No answer from tester
    endif
    wait
  enddo
  setini("LowRtest","Board type","%i,%i,%i",islargepads,boardtype,is1mohm)
end

// Installs low R test board in EPCOS automatical shuttle. Returns 0 on success,
// >0 in case of communication error or -1 if operator decided to interrupt the
// test.
function int InstallboardEPCOS()
  int i,t,nfing,err,head,channel,side,x,y,videoon,movecamera
  int videosizex,videosizey,changed
  float angle,xcoord,zoom,defzoom
  char s[512],errtxt[256],buf[64]
  handle hvideo,hold,hnew,hok,hl,hc,hr
  handle hview,hlivevideo,hzoom
  nfing=$LAY.nfing
  err=0
  videoon=0
  clear hright
  change hinfo limits=0,0
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  for i=0,i<nfing,i++
    if used[i*2]==0 continue           // Head is excluded from test
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,s)
  enddo
  t=Time()
  while (1) do
    for i=0,i<nfing,i++
      if used[i*2]==0 continue
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=nfing break                  // All answers came
    if Pressed(hexit) return -1        // Operator interrupted test
    if Time()-t>10000 break            // No answer within 10 s timeout
    wait
  enddo
  if ($GLOBAL.debugmode & 0x40)==0 then
    // Move shuttle into the test position.
    change hinfo text="Setting manual mode..."
    errtxt[2]=0
    i=Sendlmcommand("MECH.Cmd=SetMode","MECH.Ready.SetMode",errtxt,10)
    if i<0 return -1
    if errtxt[2]!='2' then
      i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,10)
      if i<0 return -1
    endif
    change hinfo text="Moving up vacuum plate..."
    i=Sendlmcommand("MECH.Cmd=LifterToTestPos",                                \
      "MECH.Ready.LifterToTestPos",errtxt,20)
    if i<0 return -1
    if i==2 err=1                      // Timeout
    if i==0 err=2                      // Unable to move plate
    // May happen that answer to Vacuum won't come. Therefore I ignore the
    // possible timeout.
    i=Sendlmcommand("MECH.Cmd=Vacuum 0",                                       \
      "MECH.Ready.Vacuum",errtxt,5)
    if i<0 return -1
    if i==0 err=2                      // Unable to turn off vacuum
  endif
  if err==0 then
    change hinfo text="放置板件"
    if boardtype==0 then
      hold=control RADIO
        window=hright
        position=9,140,RIGHTX-17,21
        name="旧版板件(小焊盘 1x2 mm)"
        font=MAINFONT
        help="Check if you have older board version"
        font=INFOFONT
        mode=(islargepads?0:M_CHECKED)
      endc
      hnew=control RADIO
        window=hright
        position=9,164,RIGHTX-17,21
        name="新版板件 (大焊盘 6x6 mm)"
        font=MAINFONT
        help="Check if you have new version of the low R test board"
        font=INFOFONT
        mode=(islargepads?M_CHECKED:0)
      endc
    else
      hold=NULL
      hnew=NULL
      islargepads=1
    endif
    hvideo=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="视频"
      help="Press to check Y board position using video camera"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="确定"
      help="Press when board is correctly installed"
    endc
    head=Camerafromy(yshift+rowdist,&channel,&side,&angle)
    draw window=hright color=BLACK font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text="Please install holder and test board, as shown "
    draw text="on the left picture. Use video camera to check its position. "
    draw text="Press " font=MAINFONT text="OK " font=TIMESFONT text="when "
    draw text="board is correctly installed."
    draw show
  endif
  while err==0 do
    if Pressed(hold) then
      islargepads=Status(hnew)
    else if Pressed(hnew) then
      islargepads=Status(hnew)
    else if head>=0 && Pressed(hvideo) then
      if videoon==0 then
        hl=control BUTTON
          window=hright
          position=8,USERY+30,RIGHTX/3-8,24
          name="<< 左"
          help="Move camera 2.5 mm to the left"
        endc
        hc=control BUTTON
          window=hright
          position=5+RIGHTX/3,USERY+30,RIGHTX/3-5,24
          name="中心"
          help="Quickly move camera to the center"
        endc
        hr=control BUTTON
          window=hright
          position=5+2*(RIGHTX/3),USERY+30,RIGHTX/3-12,24
          name="<<右"
          help="Move camera 2.5 mm to the right"
        endc
        hview=control CHILD            // Video is not yet here, create controls
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          bkcolor=VIDEOFILL
        endc
        Bccreate(hview,-1,-1,channel,0)
        hzoom=control CUSTOMBOX
          window=hview
          position=235,303,80,21
          name="缩放"
          help="Check to increase magnification by a factor of 2"
          color=BROWN
        endc
        SYS.Videosize(channel,&videosizex,&videosizey,&i)
        if videosizex==0 || videosizey==0 then
          defzoom=0.5
        else
          defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
        endif
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
          Bcgetbri(channel),Bcgetctr(channel),                                 \
          (channel<0?0:2)|(longexp?4:0),angle)
        movecamera=1; xcoord=$LAY.xoffset/1000.0
        x=(LEFTX-10)/2; y=288/2
        draw window=hlivevideo color=LIGHTRED
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        videoon=1
      else
        Bcdelete()                     // Video is already here, remove controls
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        videoon=0
      endif
    else if Pressed(hok) then
      break
    else if Pressed(hexit) then
      err=-1
    endif
    if videoon then
      changed=Bcupdate()
      if (changed & 0x01)!=0 || Pressed(hzoom) then
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      endif
      if (changed & 0x02)!=0 then
        movecamera=1
      endif
      if Pressed(hc) then
        xcoord=$LAY.xoffset/1000.0
        movecamera=1
      else if Pressed(hl) then
        xcoord=Max(xcoord-2.5,leftvlimit)
        movecamera=1
      else if Pressed(hr) then
        xcoord=Min(xcoord+2.5,rightvlimit)
        movecamera=1
      endif
      if movecamera!=0 && head>=0 then
        if $LAY.cameras!=0 then
          sprintf(buf,"M %i(%g,%g) NOP",                                       \
          $LAY.nfing*2+channel,xcoord,yshift+rowdist)
        else if $LAY.headcameras!=0 then
          SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
          sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          SERV.Cmdimm(33,buf)
          sprintf(buf,"M @%i[%g,%g] NOP",head,xcoord,yshift+rowdist)
        endif
        SERV.Cmdimm(32,buf)            // Move camera to middle row of pads
        movecamera=0
      endif
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  if videoon!=0 then
    Bcdelete()
    destroy hview
    destroy hl
    destroy hc
    destroy hr
  endif
  if err>0 then
    if head>=0 then
      sprintf(buf,"M %i(Z) NOP",head)
      SERV.Cmdimm(32,buf)              // Move camera in home position
    endif
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="重试"
      help="Press to check tester status"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED text="Communication error! "
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from tester within expected timeout. "
    else
      draw text="Tester was unable to move up the vacuum plate. "
    endif
    if err!=2 draw text="Please check connection with crate controller. "
    draw text="Press " font=MAINFONT text="Retry " font=TIMESFONT
    draw text="to check tester status and, eventually, reboot it."
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  setini("LowRtest","Board type","%i,%i,%i",islargepads,boardtype,is1mohm)
  return err
end

// Allows to find rough position of the board in the shuttle. Returns -1 if
// operator interrupted test, 0 if both crosses are found correctly and
// automatical scanning is requested, 1 if both crosses are found correctly and
// operator decided to omit automatical scanning and 2 if operator requested to
// change board placement.
function int Positionboard()
  int i,ret,channel,side,x,y,x1,y1,x2,y2,head,prevhead,type
  int showcrosses,iscrosses,videosizex,videosizey,selected
  int changepos,changed,firstpos,newvideo,newlights,reach1,reach2
  float tx,ty,centerx,posx,posy,vstep,defzoom,zoom,angle,r1,r2
  char buf[256]
  handle hmanual,hpos1,hpos2,hpos,hok,hrepos,hu,hl,hr,hd,hx,hy
  handle hview,hlivevideo,hzoom,hcrosses
  clear hleft
  clear hright
  wait; wait; wait                     // Force redraw to avoid overlapping
  change hinfo limits=0,0
  change hinfo text="查找位置"
  ret=0
  showcrosses=(boardtype!=0)
  iscrosses=-1
  // Check whether we can use crosses.
  scanrail=-1
  if Camerafromy(yshift+crossy[0],&channel,&side,&angle)<0 ||                  \
    Camerafromy(yshift+crossy[1],&channel,&side,&angle)<0                      \
  then
    for i=0,i<$LAY.nfing,i++ do
      if $LAY.side[i]!=0 break
      if $LAY.cameras==0 && $LAY.headcameras!=0 &&                             \
        ($LAY.headcameras & (3<<(i*2)))==0 continue
      if ($LAY.excludedrails & (1<<i))!=0 continue
      scanrail=i
      break
    enddo
  endif
  if scanrail<0 then
    pos1x=0.0; pos1y=0.0; type=-1
    getini("LowRtest","Left cross","%g,%g,%i",&pos1x,&pos1y,&type)
    pos2x=0.0; pos2y=0.0
    getini("LowRtest","Right cross","%g,%g",&pos2x,&pos2y)
    r1=Sqrt((pos2x-pos1x)*(pos2x-pos1x)+(pos2y-pos1y)*(pos2y-pos1y))
    r2=Sqrt((crossx[1]-crossx[0])*(crossx[1]-crossx[0])+                       \
      (crossy[1]-crossy[0])*(crossy[1]-crossy[0]))
    if type!=crosstype || r1>r2*1.05 || r2>r1*1.05 ||                          \
      Abs(crossy[0]+yshift-pos1y)>3.0 || Abs(crossy[1]+yshift-pos2y)>3.0       \
    then
      if testertype==TT_A5L && ($LAY.config & LC_LDMASK)==LC_LMAUTO then
        if boardtype==0 then
          pos1x=$LAY.rightlimit/1000.0-(crossx[1]-crossx[0])/2.0-10.0
        else
          pos1x=$LAY.rightlimit/1000.0+crossx[0]-90.0
        endif
      else
        if boardtype==0 then
          pos1x=$LAY.xoffset/1000.0-(crossx[1]-crossx[0])/2.0
        else
          pos1x=$LAY.xoffset/1000.0+crossx[0]
        endif
      endif
      pos2x=pos1x+crossx[1]-crossx[0]
      pos1y=yshift+crossy[0]
      pos2y=yshift+crossy[1]
    endif
  else
    crossx[0]=-56.0
    crossx[1]=56.0
    if boardtype==2 then
      crossy[0]=250.0*(scanrail>3?3:scanrail)
      crossy[1]=250.0*(scanrail>3?3:scanrail)
    else
      crossy[0]=155.0*(scanrail>2?2:scanrail)
      crossy[1]=155.0*(scanrail>2?2:scanrail)
    endif
    pos1x=$LAY.xoffset/1000.0+crossx[0]
    pos1y=yshift+crossy[0]
    pos2x=$LAY.xoffset/1000.0+crossx[1]
    pos2y=yshift+crossy[1]
    tx=pos1x; ty=pos1y; getini("LowRtest","Left pad","%g,%g",&tx,&ty)
    if Abs(ty-pos1y)<10.0 then
      pos1x=tx
      pos1y=ty
    endif
    tx=pos2x; ty=pos2y; getini("LowRtest","Right pad","%g,%g",&tx,&ty)
    if Abs(ty-pos2y)<10.0 then
      pos2x=tx
      pos2y=ty
    endif
  endif
  crossdist=Sqrt((crossx[1]-crossx[0])*(crossx[1]-crossx[0])+                  \
    (crossy[1]-crossy[0])*(crossy[1]-crossy[0]))
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  reach1=Camerafromy(pos1y,&channel,&side,&angle)
  reach2=Camerafromy(pos2y,&channel,&side,&angle)
  if $LAY.cameras==0 && $LAY.headcameras!=0 && (reach1<0 || reach2<0) then
    if reach1<0 && reach2<0 then
      draw text="Fiducials (crosses on the top and bottom of the board) are "
      draw text="not reachable by head cameras. The only way to position the "
      draw text="board is by trials and errors. Press "
    else if reach1<0 then
      draw text="Bottom fiducial (cross) on the board is not reachable by "
      draw text="head camera. Use trials and errors to guess the position "
      draw text="of the top cross. Press "
    else
      draw text="Top fiducial (cross) on the board is not reachable by "
      draw text="head camera. Use trials and errors to guess the position "
      draw text="of the bottom cross. Press "
    endif
  else if scanrail<0 then
    draw text="按左边图片的位置，"
    if boardtype==0 then
      //draw text=" (crosses on the top and bottom of the board). "
      draw text="查找两个基准点。 "
    else
      draw text="查找两个基准点。"
    endif
    draw text="按" font=MAINFONT text="十字1" font=TIMESFONT
    draw text="或" font=MAINFONT text="十字2" font=TIMESFONT
    draw text="根据视频找到基准点中心."
  else
    draw text="Now find rough positions of two fiducials (leftmost and "
    draw text="rightmost pads) on the board. Press " font=MAINFONT text="Pad 1 "
    draw font=TIMESFONT text="or " font=MAINFONT text="Pad 2 " font=TIMESFONT
    draw text="to select pad, then "
  endif
  //draw font=MAINFONT text="OK " font=TIMESFONT text="when fiducials are "
  //draw text="located or " font=MAINFONT text="Replace " font=TIMESFONT
  draw text="按重放置释放架板框可以更改校验板位置。"
  draw color=DARKGRAY font=INFOFONT at 18,USERY-81 text="当前 X="
  i=0
  getini("LowRtest","Skip autoscan","%i",&i)
  hmanual=control CUSTOMBOX
    window=hright
    position=10,USERY-130,RIGHTX-20,22
    name="无需自动扫描基准点"
    help="Check to omit automatical scanning of positioning fiducials"
    mode=(i==0 && reach1>=0 && reach2>=0?0:M_CHECKED)
  endc
  hx=control TEXT
    window=hright
    position=83,USERY-100,54,22
    help="Actual X coordinate of the video camera"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 140,USERY-81 text=", Y="
  hy=control TEXT
    window=hright
    position=168,USERY-100,54,22
    help="Actual Y coordinate of the video camera"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 227,USERY-81 text="mm"
  draw show
  hu=control BUTTON
    window=hright
    position=60,USERY-58,40,40
    name="上"
    help="Press to move camera up"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hl=control BUTTON
    window=hright
    position=18,USERY-15,40,40
    name="左"
    help="Press to move camera to the left"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hr=control BUTTON
    window=hright
    position=102,USERY-15,40,40
    name="右"
    help="Press to move camera to the right"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hd=control BUTTON
    window=hright
    position=60,USERY+27,40,40
    name="下"
    help="Press to move camera down"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  y=(boardtype==1?USERY-61:USERY-57)
  hpos1=control BUTTON
    window=hright
    position=166,y,RIGHTX-180,24
    name=(scanrail<0?"十字1":"测点 1")
    help="Press to find position of the first fiducial"
    color=LIGHTRED
    bkcolor=YELLOW
  endc
  y=y+(boardtype==1?26:30)
  selected=1
  hpos2=control BUTTON
    window=hright
    position=166,y,RIGHTX-180,24
    name=(scanrail<0?"十字2":"测点 2")
    help="Press to find position of the second fiducial"
  endc
  y=y+(boardtype==1?28:40)
  if boardtype==1 then
    hpos=control BUTTON
      window=hright
      position=166,y,RIGHTX-180,24
      name="方案"
      help="Press to show which crosses to be used"
    endc
    y=y+28
  endif
  hok=control BUTTON
    window=hright
    position=166,y,RIGHTX-180,24
    name="确定"
    help="Press when rough position of board is found"
  endc
  disable hok
  y=y+(boardtype==1?26:30)
  hrepos=control BUTTON
    window=hright
    position=166,y,RIGHTX-180,24
    name="重放置"
    help="Press if you need to change placement of the board"
  endc
  disable hrepos
  // Initially hidden window that displays crosses on the combo R/C board
  // used for scanning.
  hcrosses=control CHILD
    window=hleft
    position=1000,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=1024
  endc
  if boardtype==1 then
    draw window=hcrosses at 100,50 bitmap=0,0,0,"rcboard"
    switch crosstype
    case 1:                            // Full-length vertical base
      x1=62; y1=150; x2=62; y2=34
    case 2:                            // Half-length vertical base bottom
      x1=62; y1=150; x2=62; y2=105
    case 3:                            // Half-length vertical base top
      x1=62; y1=79; x2=62; y2=34
    case 4:                            // Horizontal base center (lower)
      x1=62; y1=105; x2=111; y2=105
    case 5:                            // Horizontal base center (upper)
      x1=62; y1=79; x2=111; y2=79
    case 6:                            // Horizontal base bottom
      x1=62; y1=150; x2=111; y2=150
    case 7:                            // Horizontal base top
      x1=62; y1=34; x2=111; y2=34
    endsw
    x1=x1+100; y1=y1+50; x2=x2+100; y2=y2+50
  else
    draw window=hcrosses at 100,5 bitmap=0,0,0,"rclarge"
    x1=174.0+crossx[0]/1.80
    y=Floor(crossy[0]/250.0+0.5)*250.0
    y1=292.0-y/2.84-(crossy[0]-y)/1.80
    x2=174.0+crossx[1]/1.80
    y=Floor(crossy[1]/250.0+0.5)*250.0
    y2=292.0-y/2.84-(crossy[1]-y)/1.80
  endif
  draw color=LIGHTRED font=LARGEFONT
  if reach1>=0 then
    draw at x1-7,y1-7 rect x1+8,y1+8
    draw at x1-8,y1-8 rect x1+9,y1+9
    draw at x1-9,y1-9 rect x1+10,y1+10
    draw at x1+13,y1+18 text="1"
  endif
  if reach2>=0 then
    draw at x2-7,y2-7 rect x2+8,y2+8
    draw at x2-8,y2-8 rect x2+9,y2+9
    draw at x2-9,y2-9 rect x2+10,y2+10
    draw at x2+13,y2+18 text="2"
  endif
  draw font=TIMESFONT color=BLACK wrap=LEFTX-5
  draw at 10,(boardtype==2?341:300)
  draw text="+用于扫描对位。点 " font=MAINFONT
  draw text="十字1 " font=TIMESFONT text="或 " font=MAINFONT
  draw text="十字2 " font=TIMESFONT text="显示实时视频"
  draw show
  hview=control CHILD
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    bkcolor=VIDEOFILL
    help="Live image from video camera"
  endc
  Bccreate(hview,-1,-1,channel,1)
  hzoom=control CUSTOMBOX
    window=hview
    position=235,303,80,21
    name="缩放"
    help="Check to increase magnification by a factor of 2"
    color=BROWN
  endc
  x=(LEFTX-10)/2; y=288/2
  draw window=hlivevideo color=LIGHTRED
  draw at x-20,y to x-5,y at x+6,y to x+21,y
  draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
  if scanrail>=0 then
    if islargepads then
      draw at x-100,y-100 rect x+101,y+101
    else
      draw at x-30,y-30 rect x+31,y+31
    endif
  endif
  draw show
  changepos=1                          // Force camera movement
  firstpos=1                           // Change second offset simultaneously
  SYS.Killimm(32); $A[32].length=1     // Mark answer as available
  newvideo=1                           // Change camera settings
  newlights=1                          // Change illumination settings
  prevhead=-1
  SYS.Videosize(channel,&videosizex,&videosizey,&i)
  if videosizex==0 || videosizey==0 then
    defzoom=0.5
  else
    defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
  endif
  while 1 do
    changed=Bcupdate()
    if (changed & 0x01)!=0 newvideo=1
    if (changed & 0x02)!=0 then
      changepos=1
      newlights=1
    endif
    if showcrosses!=iscrosses then
      if showcrosses==1 then
        change hcrosses position=-1,-1,LEFTX,LEFTY
        change hview position=1000,-1,LEFTX,LEFTY
        change hpos2 color=BLACK
        change hpos2 bkcolor=GRAY
        change hpos1 color=BLACK
        change hpos1 bkcolor=GRAY
        change hpos color=LIGHTRED
        change hpos bkcolor=YELLOW
      else
        change hcrosses position=1000,-1,LEFTX,LEFTY
        change hview position=-1,-1,LEFTX,LEFTY
        if selected==1 then
          change hpos1 color=LIGHTRED
          change hpos1 bkcolor=YELLOW
          change hpos2 color=BLACK
          change hpos2 bkcolor=GRAY
        else
          change hpos2 color=LIGHTRED
          change hpos2 bkcolor=YELLOW
          change hpos1 color=BLACK
          change hpos1 bkcolor=GRAY
        endif
        if boardtype!=0 then
          change hpos color=BLACK
          change hpos bkcolor=GRAY
        endif
      endif
      iscrosses=showcrosses
    endif
    if showcrosses==0 && changepos==0 && $A[32].length>1 then
      enable hok
      enable hrepos
    endif
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hok) then
      if scanrail<0 then
        setini("LowRtest","Left cross","%g,%g,%i",pos1x,pos1y,crosstype)
        setini("LowRtest","Right cross","%g,%g",pos2x,pos2y)
      else
        setini("LowRtest","Left pad","%g,%g",pos1x,pos1y)
        setini("LowRtest","Right pad","%g,%g",pos2x,pos2y)
      endif
      ret=Status(hmanual);
      setini("LowRtest","Skip autoscan","%i",ret)
      break
    else if Pressed(hrepos) then
      for head=0,head<$LAY.nfing*2,head++ do
        sprintf(buf,"M %i(Z) NOP",head)
        SERV.Cmdimm(32,buf)
      enddo
      ret=2; break
    else if Pressed(hpos1) then
      showcrosses=0
      if selected!=1 then
        change hpos1 color=LIGHTRED
        change hpos1 bkcolor=YELLOW
        change hpos2 color=BLACK
        change hpos2 bkcolor=GRAY
        if boardtype!=0 then
          change hpos color=BLACK
          change hpos bkcolor=GRAY
        endif
        selected=1; changepos=1; firstpos=0
      endif
    else if Pressed(hpos2) then
      showcrosses=0
      if selected!=2 then
        change hpos2 color=LIGHTRED
        change hpos2 bkcolor=YELLOW
        change hpos1 color=BLACK
        change hpos1 bkcolor=GRAY
        if boardtype!=0 then
          change hpos color=BLACK
          change hpos bkcolor=GRAY
        endif
      endif
      selected=2; changepos=1; firstpos=0
    else if Pressed(hpos) then
      showcrosses=1
    else if Pressed(hzoom) then
      newvideo=1
    endif
    if selected==1 then
      posx=pos1x; posy=pos1y
    else
      posx=pos2x; posy=pos2y
    endif
    vstep=VSTEP
    if Status(hmanual)==1 vstep=vstep/10.0
    if Pressed(hu) then
      if (firstpos) pos2y=pos2y+vstep
      posy=posy+vstep; changepos=1
    else if Pressed(hl) then
      if (firstpos) pos2x=pos2x-vstep
      posx=posx-vstep; changepos=1
    else if Pressed(hr) then
      if (firstpos) pos2x=pos2x+vstep
      posx=posx+vstep; changepos=1
    else if Pressed(hd) then
      if (firstpos) pos2y=pos2y-vstep
      posy=posy-vstep; changepos=1
    endif
    if changepos!=0 then
      if selected==1 then
        pos1x=posx; pos1y=posy
      else
        pos2x=posx; pos2y=posy
      endif
      if scanrail<0 then
        pos1x=Max(leftvlimit,Min(rightvlimit-(crossx[1]-crossx[0]),pos1x))
        pos1y=Max(yshift+crossy[0]-MAXERR,Min(yshift+crossy[0]+MAXERR,pos1y))
        pos2x=Max(leftvlimit+(crossx[1]-crossx[0]),Min(rightvlimit,pos2x))
        pos2y=Max(yshift+crossy[1]-MAXERR,Min(yshift+crossy[1]+MAXERR,pos2y))
      else
        centerx=$LAY.xoffset/1000.0
        pos1x=Max(centerx+crossx[0]-120.0,Min(centerx+crossx[0]+20.0,pos1x))
        pos1y=Max(yshift+crossy[0]-MAXERR,Min(yshift+crossy[0]+MAXERR,pos1y))
        pos2x=Max(centerx+crossx[1]-120.0,Min(centerx+crossx[1]+20.0,pos2x))
        pos2y=Max(yshift+crossy[1]-MAXERR,Min(yshift+crossy[1]+MAXERR,pos2y))
      endif
      if selected==1 then
        posx=pos1x; posy=pos1y
      else
        posx=pos2x; posy=pos2y
      endif
      change hx text=format("%5.1f",posx)
      change hy text=format("%5.1f",posy)
      if $A[32].length!=0 then
        // Previous movement is finished, start new.
        head=Camerafromy(posy,&channel,&side,&angle)
        if $LAY.cameras!=0 then        // Dedicated camera
          sprintf(buf,"M %i(%g,%g) NOP",head,posx,posy)
        else                           // Head camera, move other heads away
          if head!=prevhead || newlights then
            for i=0,i<$LAY.nfing*2,i++ do
              if i==head continue
              sprintf(buf,"M %i(Z) NOP",i)
              SERV.Cmdimm(33,buf)
            enddo
            if prevhead>=0 then
              sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,0",prevhead)
              SERV.Cmdimm(33,buf)
            endif
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
            SERV.Cmdimm(33,buf)
            prevhead=head
            newlights=0
          endif
          sprintf(buf,"M @%i[%g,%g] NOP",head,posx,posy)
          newvideo=1
        endif
        SERV.Cmdimm(32,buf)
        changepos=0
      endif
    endif
    if newvideo then
      Camerafromy(posy,&channel,&side,&angle)
      zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
      Bcsetcam(channel)
      SYS.Videoangle(hlivevideo,channel,side,zoom,                             \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      newvideo=0
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  Bcdelete()
  destroy hview
  return ret
end

// Searches for the fiducial in the vicinity of the given coordinates. Returns
// -1 if operator decided to interrupt the test, 2 if procedure was unable to
// define fiducial, 3 if fiducial was not found, 4 if camera was unable to
// reach the fiducial, and 0 if fiducial was found correctly and posx and posy
// are assigned corrected coordinates.
function int Searchcross(handle hlivevideo,float *posx,float *posy)
  int i,j,t,head,active,channel,videox,videoy,side,clip
  int attempts,nfound,videosizex,videosizey,err
  float x,y,dx,dy,bestx,besty,angle,xsc,ysc,found[4][3],corrmax,zoom
  char s[512]
  handle hfid[5]
  x=posx[0]; y=posy[0]
  attempts=8; err=0
  active=-1                            // Active head is yet undefined
  SYS.Videosize(channel,&videosizex,&videosizey,&i)
  if videosizex==0 || videosizey==0 then
    zoom=0.5
  else
    zoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
  endif
  SYS.Killimm(32)                      // Recover from previous scanning
  while (attempts>0 && err==0) do
    attempts--
    Bcsetcam(channel)
    head=Camerafromy(y,&channel,&side,&angle)
    if head<0 then
      err=1; break
    endif
    SYS.Videoangle(hlivevideo,channel,side,zoom,                               \
      Bcgetbri(channel),Bcgetctr(channel),                                     \
      (channel<0?0:2)|(longexp?4:0),angle)
    if head!=active then
      // Define fiducials for new camera, first deleting existing ones.
      for j=0,j<5,j++ do
        if hfid[j]!=NULL SYS.Deletemodel(hfid[j])
      enddo
      sprintf(s,"Video scale[%i]",side)
      xsc=6.4; ysc=6.4                 // Default video magnification
      getini("System",s,"%f,%f",&xsc,&ysc)
      xsc=Max(1.0,Min(12.0,xsc))
      ysc=Max(1.0,Min(12.0,ysc))
      for j=0,j<5,j++ do               // Different thickness
        if scanrail<0 then
          hfid[j]=SYS.Syntmodel(channel,SYNT_CROSS,                            \
          512.0/xsc,512.0*linewidth/xsc*(j+3.0)/6.0,0,0,0)
        else
          hfid[j]=SYS.Syntmodel(channel,SYNT_RECT,                             \
          64.0*0.9*(j+6)/xsc,64.0*1.8*(j+6)/xsc,0,0,0)
        endif
        if hfid[j]==NULL err=2         // Unable to define fiducial
      enddo
      if err!=0 break
    endif
    // Move camera into the coordinates. In case of head cameras, all other
    // heads must be moved away.
    if $LAY.cameras!=0 then            // Dedicated camera
      sprintf(s,"M %i(%g,%gA5) NOP",head,x,y)
      clip=0
    else                               // Head camera, move other heads away
      if head!=active then
        for i=0,i<$LAY.nfing*2,i++ do
          if i==head continue
          sprintf(s,"M %i(Z) NOP",i)
          SERV.Cmdimm(33,s)
        enddo
        if active>=0 then
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",active)
          SERV.Cmdimm(33,s)
        endif
        sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,3",head)
        SERV.Cmdimm(33,s)
      endif
      sprintf(s,"M @%i[%g,%g] NOP",head,x,y)
      clip=((head^side) & 1?1:-1)
    endif
    SERV.Cmdimm(32,s)
    active=head
    t=Time()
    while $A[32].length==0 && err==0 do
      if Pressed(hexit) err=-1         // Operator interrupted test
      if Time()-t>10000 err=1          // Timeout
      wait
    enddo
    if err!=0 break
    if $A[32].answer!=S_NOP then
      err=1; break
    endif
    delay 200                          // Some additional delay for camera
    SYS.Nextframe(channel)
    SYS.Videosize(channel,&videox,&videoy,&j)
    corrmax=0.0
    for j=0,j<5,j++ do
      if hfid[j]==NULL continue
      nfound=SYS.Recognangle(hfid[j],0,0,videox,videoy,found,angle,clip)
      if nfound==0 continue
      if found[0,2]>corrmax then
        bestx=found[0,0]
        besty=found[0,1]
        corrmax=found[0,2]
      endif
    enddo
    dx=(bestx-videox/2)*xsc/512.0
    dy=(besty-videoy/2)*ysc/512.0
    // Offsets dx and dy are given in millimeters along the camera
    // axes. We must rotate them into the tester coordinates.
    x=x+(dx*Cos(angle)+dy*Sin(angle))*(side==0?1.0:-1.0)
    y=y-(dy*Cos(angle)-dx*Sin(angle))
    if Abs(dx)<0.1 && Abs(dy)<0.1 then
      posx[0]=x                        // Fiducial found exactly
      posy[0]=y
      break
    endif
  enddo
  if attempts<=0 err=3
  // Clean up and report result.
  for j=0,j<5,j++ do
    if hfid[j]!=NULL SYS.Deletemodel(hfid[j])
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  return err
end

// Function converts board coordinates xb,yb into tester coordinates xt,yt.
// Then it adds random offset limited to (-delta,+delta). In-place conversion
// is also allowed here.
function int Convert(float *xt,float *yt,float xb,float yb,float delta)
  float x,y
  x=xb*convcfi-yb*convsfi+convdx
  y=xb*convsfi+yb*convcfi+convdy
  if delta>0.0 then
    x=x+Random(delta)+Random(delta)-delta
    y=y+Random(delta)+Random(delta)-delta
  endif
  xt[0]=x
  yt[0]=y
end

// Function calculates tester coordinates xt,yt of pad name for given head.
// Then it adds random offset limited to (-delta,+delta). Returns -1.0 if pad
// is not found and non-negative related value if coordinates are calculated.
function float Convertpad(float *xt,float *yt,char *name,int head,float delta)
  int i
  float x,y
  for i=0,i<NPOINT,i++ do
    if Strcmp(name,xname[i])==0 break
  enddo
  if i>=NPOINT return -1.0
  x=xpos[i]*convcfi-ypos[head]*convsfi+convdx
  y=xpos[i]*convsfi+ypos[head]*convcfi+convdy
  if Strcmp(name,"NC1")==0 || Strcmp(name,"NC2")==0 then
    if y<$LAY.yoffset[head/2]/1000.0 then
      y=y+15.0
    else
      y=y-15.0
    endif
  endif
  if delta>0.0 then
    x=x+Random(delta)+Random(delta)-delta
    y=y+Random(delta)+Random(delta)-delta
  endif
  xt[0]=x
  yt[0]=y
  return value[i]
end

// For line with given name, returns line resistance factor. This is the value
// that must be multiplied by rline to get resistance of vertical 155/250-mm
// line.
function float Getlinefactor(char *name)
  int i
  for i=0,i<NPOINT,i++ do
    if Strcmp(name,xname[i])==0 break
  enddo
  if i>=NPOINT return 1.0              // Safest default
  if linefactor[i]<=0.0 return 1.0     // Must not happen
  return linefactor[i]
end

// Function calculates tester coordinates xt,yt of pad name for given head at
// the alternative Y position. Then it adds random offset limited to (-delta,
// +delta). Returns -1 if pad is not found and 0 if coordinates are calculated.
function int Convertalt(float *xt,float *yt,char *name,int head,float delta)
  int i
  float x,y
  if yalt[head]<(-1.0e10) || yalt[head]>1.0e10 then
    return -1                          // No alternative coordinate
  endif
  for i=0,i<NPOINT,i++ do
    if Strcmp(name,xname[i])==0 break
  enddo
  if i>=NPOINT return -1
  x=xpos[i]*convcfi-yalt[head]*convsfi+convdx
  y=xpos[i]*convsfi+yalt[head]*convcfi+convdy
  if Strcmp(name,"NC1")==0 || Strcmp(name,"NC2")==0 then
    if y<$LAY.yoffset[head/2]/1000.0 then
      y=y+15.0
    else
      y=y-15.0
    endif
  endif
  if delta>0.0 then
    x=x+Random(delta)+Random(delta)-delta
    y=y+Random(delta)+Random(delta)-delta
  endif
  xt[0]=x
  yt[0]=y
  return 0
end

// Gets type of attached automation (half-automate, automate etc.) into the
// global variables automationtype and isauto. As these parameters are not
// important for the test, there is no error processing.
function int Getautomationtype()
  int t
  char buf[32]
  buf[0]=S_DEBUG
  buf[1]=0x14                          // Query type of the automation
  SYS.Sendimm(32,2,buf)
  t=Time()
  automationtype=AUTO_UNKNOWN
  isauto=0
  while $A[32].length==0 do
    if Time()-t>2000 then
      SYS.Killimm(32)                  // Timeout, automation type is unknown
      return
    endif
    wait
  enddo
  if $A[32].answer!=S_DEBUG || $A[32].length!=9 return
  automationtype=$uint2($A[32]+5)
  if automationtype==AUTO_A2 || automationtype==AUTO_A4SEMI ||                 \
    automationtype==AUTO_A4FULL || automationtype==AUTO_A6SEMI ||              \
    automationtype==AUTO_A6FULL || automationtype==AUTO_A5LMSEMI ||            \
    automationtype==AUTO_A5LMFULL || automationtype==AUTO_S2LMMAN ||           \
    automationtype==AUTO_S2LMSEMI || automationtype==AUTO_S2LMFULL ||          \
    automationtype==AUTO_S2LMDCF || automationtype==AUTO_A7LMSEMI ||           \
    automationtype==AUTO_A7LMFULL || automationtype==AUTO_A8LMMAN ||           \
    automationtype==AUTO_A8LMSEMI || automationtype==AUTO_A8LMFULL ||          \
    automationtype==AUTO_SPLIT                                                 \
  then
    isauto=1
  else
    isauto=0
  endif
end

// Given rough fiducial coordinates, this function scans board optically
// and calculates necessary coordinate conversion coefficients.
function int Scanboard(int manualonly)
  int i,err,x,y
  float r,xsc,ysc,xmin,xmax,ymin,ymax
  char s[512]
  handle hview,hlivevideo,hreplace,hfinish
  clear hright
  change hinfo limits=0,0
  change hinfo text="Checking coordinates..."
  r=Sqrt((pos1x-pos2x)*(pos1x-pos2x)+(pos1y-pos2y)*(pos1y-pos2y))
  delay 500                            // Merchantizing...
  if (r<crossdist-MAXERR || r>crossdist+MAXERR) then
    err=1                              // Wrong distance between crosses
  endif
  if err==0 then
    hview=control CHILD
      window=hleft
      position=0,0,LEFTX,LEFTY
      help=" "
      color=BROWN
      bkcolor=LIGHTYELLOW
      size=128
    endc
    hlivevideo=control GRAPH
      window=hview
      position=5,5,LEFTX-10,288
      bkcolor=VIDEOFILL
      help="Live image from video camera"
    endc
    x=(LEFTX-10)/2; y=288/2
    draw window=hlivevideo color=LIGHTRED
    draw at x-20,y to x-5,y at x+6,y to x+21,y
    draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
    draw show
  endif
  if manualonly==0 then
    if err==0 then
      change hinfo text="寻找基准点..."
      err=Searchcross(hlivevideo,&pos1x,&pos1y)
      if err<0 return -1               // Operator interrupted test
    endif
    if err==0 then
      err=Searchcross(hlivevideo,&pos2x,&pos2y)
      if err<0 return -1               // Operator interrupted test
    endif
  endif
  if err==0 then
    r=Sqrt((pos1x-pos2x)*(pos1x-pos2x)+(pos1y-pos2y)*(pos1y-pos2y))
    if (r<crossdist-MAXERR/2.0 || r>crossdist+MAXERR/2.0) err=1
  endif
  // Move heads and cameras into the home positions.
  for i=0,i<$LAY.nfing*2,i++ do
    sprintf(s,"M %i(Z) NOP",i)
    SERV.Cmdimm(32,s)
  enddo
  delay 1000                           // Psychologically necessary delay
  if hview!=NULL destroy hview
  if err==0 then
    if scanrail<0 then
      setini("LowRtest","Left cross","%g,%g,%i",pos1x,pos1y,crosstype)
      setini("LowRtest","Right cross","%g,%g",pos2x,pos2y)
    else
      setini("LowRtest","Left pad","%g,%g",pos1x,pos1y)
      setini("LowRtest","Right pad","%g,%g",pos2x,pos2y)
    endif
    r=(crossx[1]-crossx[0])*(crossx[1]-crossx[0])+                             \
      (crossy[1]-crossy[0])*(crossy[1]-crossy[0])
    convcfi=((crossx[1]-crossx[0])*(pos2x-pos1x)+                              \
      (crossy[1]-crossy[0])*(pos2y-pos1y))/r
    convsfi=((crossx[1]-crossx[0])*(pos2y-pos1y)-                              \
      (crossy[1]-crossy[0])*(pos2x-pos1x))/r
    convdx=pos1x-crossx[0]*convcfi+crossy[0]*convsfi
    convdy=pos1y-crossx[0]*convsfi-crossy[0]*convcfi
    if boardtype==0 then
      Convert(&xmin,&ymin,-65.0,-25.0,0.0);
      Convert(&xmax,&ymax,65.0,335.0,0.0);
    else if boardtype==1 then
      Convert(&xmin,&ymin,-80.0,-5.0,0.0);
      Convert(&xmax,&ymax,80.0,315.0,0.0);
    else
      Convert(&xmin,&ymin,-80.0,-5.0,0.0);
      Convert(&xmax,&ymax,80.0,755.0,0.0);
    endif
    sprintf(s,"默认板 %g,%g,%g,%g",xmin,ymin,xmax,ymax)
    SERV.Cmdimm(32,s)                  // Allow whole board
    // For A5/A6/S1 with splinogramms, increase pressure to 70 parrots.
    if (($LAY.config & 0x100)!=0 &&                                            \
      (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||         \
      testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||           \
      testertype==TT_A7 || testertype==TT_A8)) strokep=70
    sprintf(s,"STROKE %i,%i,%g",strokev,strokep,strokez)
    SERV.Cmdimm(32,s)                  // Set default stroke
    Strcpy(s,"EXACTINIT 0,0,0")
    SERV.Cmdimm(32,s)                  // No power/current limitations
    return 0                           // No errors, pads found correctly
  endif
  change hinfo text="Scanning error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Bad distance between crosses!"
    draw at 6,60 color=BLACK
    draw text="The distance between positioning crosses on the board is "
    draw text=format("%.0f mm. However, measured distance is ",crossdist)
    draw text=format("%.1f mm.",r)
  else if err==2 then
    draw text="Unable to define fiducial!"
    draw at 6,60 color=BLACK
    draw text="Either you have no frame grabber, or some other script uses "
    draw text="all available fiducial handles, or magnification of the camera "
    draw text="in file OLLYTEST.INI is wrong. "
  else if err==3 then
    draw text="Unable to find cross!"
    draw at 6,60 color=BLACK
    draw text="Either you selected wrong place, or picture is too unclear, or "
    draw text="magnification of the camera in file OLLYTEST.INI is wrong. "
  else if err==4 then
    draw text="Unable to move camera!"
    draw at 6,60 color=BLACK
    draw text="Video camera cannot reach specified pad. "
  endif
  draw text="Please decide what to do next."
  draw show
  hreplace=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="重放置"
    help="Press to repeat scanning or replace the board"
  endc
  hfinish=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="放弃"
    help="Press to quit test"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1                        // Operator interrupted test
    else if Pressed(hreplace) then
      return 1                         // Change board placement or rescan
    else if Pressed(hfinish) then
      return 2                         // Operator stopped test
    endif
    wait
  enddo
end

// Checks placement of the board electrically. Returns -1 if operator
// interrupted test, 1 if it is necessary to check load status of the tester,
// 2 if it is necessary to repeat electrical test, and 0 if test is OK.
function int Electrocheck()
  int i,t,err,head,prev,sent[32][2]
  float x1,y1,x2,y2,r
  char s[512]
  handle hretry,hreplace,hcont
  clear hright
  change hinfo limits=0,0
  change hinfo text="检查校验板..."
  prev=0
  for i=2,i<$LAY.nfing*2,i=i+2 do
    if used[prev]==0 then
      prev=i; continue
    endif
    if used[i]==0 continue
    SYS.Killimm(i)
    Convertpad(&x1,&y1,(prev & 1?"1R0":"R01"),prev,0.0)
    Convertpad(&x2,&y2,(i & 1?"1R0":"R01"),i,0.0)
    if y1<$LAY.yoffset[prev/2]/1000.0 then
      y1=y1+(islargepads?DISTYNEW:DISTYOLD)
    else
      y1=y1-(islargepads?DISTYNEW:DISTYOLD)
    endif
    if y2<$LAY.yoffset[i/2]/1000.0 then
      y2=y2+(islargepads?DISTYNEW:DISTYOLD)
    else
      y2=y2-(islargepads?DISTYNEW:DISTYOLD)
    endif
    sprintf(s,"M %i[%g,%gH50] %i[%g,%gH50] R(%i,%i)",                          \
      prev,x1,y1,i,x2,y2,prev,i)
    SERV.Cmdimm(i,s)
    sent[i][0]=prev
    sent[i][1]=i
    Convertpad(&x1,&y1,((prev+1) & 1?"1R0":"R01"),prev+1,0.0)
    Convertpad(&x2,&y2,((i+1) & 1?"1R0":"R01"),i+1,0.0)
    if y1<$LAY.yoffset[prev/2]/1000.0 then
      y1=y1+(islargepads?DISTYNEW:DISTYOLD)
    else
      y1=y1-(islargepads?DISTYNEW:DISTYOLD)
    endif
    if y2<$LAY.yoffset[i/2]/1000.0 then
      y2=y2+(islargepads?DISTYNEW:DISTYOLD)
    else
      y2=y2-(islargepads?DISTYNEW:DISTYOLD)
    endif
    sprintf(s,"M %i[%g,%gH50] %i[%g,%gH50] R(%i,%i)",                          \
      prev+1,x1,y1,i+1,x2,y2,prev+1,i+1)
    SERV.Cmdimm(i+1,s)
    sent[i+1][0]=prev+1
    sent[i+1][1]=i+1
    prev=i
  enddo
  t=Time()
  while 1 do                           // Wait till all answers come back
    if Pressed(hexit) return -1        // Operator interrupted test
    for i=2,i<$LAY.nfing*2,i++ do
      if sent[i][1]==0 continue
      if $A[i].length==0 break
    enddo
    if i>=$LAY.nfing*2 break           // All answers came
    if Time()-t>10000 then
      err=1; break                     // Timeout 10 seconds
    endif
    wait
  enddo
  if err==0 then
    for i=2,i<$LAY.nfing*2,i++ do
      if sent[i][1]==0 continue
      if $A[i].answer==S_ERROR then
        err=2; break                   // Some error
      else if $A[i].answer!=S_MOVE || $A[i].subansw!=S_RMEAS then
        err=3; break                   // Unbelievable, wrong answer
      endif
      r=$A[i].r
      if ($A[i].status & 0x0100) r=r*1.0e-6
      if r<(-3.0) || r>20.0 then
        head=i; err=4; break           // Bad resistance (>20 Ohm or negative)
      endif
    enddo
  endif
  if err==0 return 0                   // Electrical check passed
  change hinfo text="Contacting error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within 10 seconds. "
  else if err==2 then
    draw text="Tester reports error!"
    draw at 6,60 color=BLACK
    draw text="Embedded software was unable to execute measurement command "
    draw text="correctly. The exact reason is displayed in red in the main "
    draw text="Ollytest window. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Embedded software returned unexpected answer. "
  else if err==4 then
    draw text="高电阻!"
    draw at 6,60 color=BLACK
    draw text="根据计算校验板上不存在20欧姆的线\n路阻值."
    draw text="测试头"
    draw text=format("%i%c 和",sent[head][0]/2,sent[head][0] & 1?'R':'L')
    draw text=format("%i%c ",sent[head][1]/2,sent[head][1] & 1?'R':'L')
    draw text="测量的值为"
    if r<1000 then
      draw text=format("%.3g 欧姆. ",r)
    else if r<1.0e6 then
      draw text=format("%.3g 千欧姆. ",r/1000.0)
    else
      draw text=format("%.3g 兆欧姆 ",r/1.0e6)
      draw text=(r>=200.0e6?"(clean open). ":".")
    endif
  endif
  draw text="\n请决定下面做什么."
  draw show
  hretry=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="重试"
    help="Press to measure resistance once more"
  endc
  hreplace=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="重放置"
    help="Press to change placement of low resistance test board"
  endc
  hcont=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="继续"
    help="Continue at your own risk"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hretry) return 2
    if Pressed(hreplace) return 1
    if Pressed(hcont) return 0
    wait
  enddo
end

// Sets type of the test board. Returns 0 on success or -1 if user interrupted
// test.
function int Selectboard()
  int x,y,x0,y0,x1,y1,redraw
  handle hchild,hdedicated,hcombined,hok
  clear hright
  change hinfo limits=0,0
  change hinfo text="选取板件"
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="请选择校验板件：专用板(只能用于低阻"
  draw text="校验)或者多用板(可用于低阻和电容校"
  draw text="验)。"
  draw show
  clear hleft
  hchild=control GRAPH
    window=hleft
    position=5,5,LEFTX-10,250
    help=" "
    color=WHITE
    bkcolor=YELLOW/////////WHITE
  endc
  hdedicated=control RADIO
    window=hleft
    position=46,260,(LEFTX-90)/2,22
    name="专用板"
    help="点击选择专用校验板 (老版本，仅电阻测试)"
    mode=(boardtype==0?M_CHECKED:0)
  endc
  hcombined=control RADIO
    window=hleft
    position=(LEFTX-90)/2+76,260,(LEFTX-90)/2,22
    name="多用板"
    help="点击选择复合校验板 (新版本,电阻测试和电容校正)"
    mode=(boardtype!=0?M_CHECKED:0)
  endc
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="确定"
    help="点击确认选择"
  endc
  redraw=1
  y0=27; y1=217
  while 1 do
    if Pressed(hdedicated) then
      boardtype=0
      redraw=1
    else if Pressed(hcombined) then
      boardtype=1
      redraw=1
    else if Pressed(hok) then
      Drawboard()
      return 0
    else if Pressed(hchild) then
      x=Limit0(hchild)
      y=Limit1(hchild)
      if y>=y0 && y<y1 then
        if x>=37 && x<130 then
          change hdedicated mode=M_CHECKED
          boardtype=0
          redraw=1
        else if x>=164 && x<291 then
          change hcombined mode=M_CHECKED
          boardtype=1
          redraw=1
        endif
      endif
    else if Pressed(hexit) then
      Drawboard()
      return -1
    endif
    if redraw then
      if boardtype==0 then
        x0=37; x1=130
      else
        x0=164; x1=291
      endif
      draw window=hchild color=WHITE bkcolor=WHITE clear
      draw at 40,30 bitmap=0,0,0,"r-rcsel"
      draw color=LIGHTRED bkcolor=LIGHTRED
      draw at x0-5,y0-5 fillrect x0,y1+5
      draw at x0-5,y0-5 fillrect x1+5,y0
      draw at x1,y0-5 fillrect x1+5,y1+5
      draw at x0-5,y1 fillrect x1+5,y1+5
      draw show
      redraw=0
    endif
    wait
  enddo
end

// Adjust expected resistances of on-board components. Returns 0 on success and
// -1 if operator interrupted the test.
function int Correctresistors()
  int slot,y
  float r[2][NSLOT]
  char s[512],key[32]
  handle h10ohm,hvalue[NSLOT],hok
  // Get expected resistances.
  for slot=0,slot<NSLOT,slot++ do
    Strncpy(s,meas[0][slot]+8,7); s[7]='\0'
    Sscanf(s,"%f",rexp[0]+slot)
    Strncpy(s,meas[1][slot]+8,7); s[7]='\0'
    Sscanf(s,"%f",rexp[1]+slot)
  enddo
  clear hright
  change hinfo limits=0,0
  change hinfo text="纠正电阻值"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="阻值测试板有被精准设备校验过.请将板"
  draw text="件上精准的值填入下列空格.准备好后点"
  draw text="击 " font=MAINFONT text="确定."
  //draw font=TIMESFONT text="when ready."
  y=130
  draw font=MAINFONT color=BLACK
  for slot=0,slot<NSLOT,slot++ do
    if slot==4 then
      h10ohm=control COMBOLIST
        window=hright
        position=23,y-19,82,100
        help="Value of 4th resistor"
      endc
      add h10ohm text="10 Ohm:"
      add h10ohm text="1 mOhm:"
      change h10ohm select=is1mohm
    else
      draw at 29,y text=format("%s:",meas[is1mohm][slot]+16)
    endif
    sprintf(key,"Value[%i]",slot)
    r[0][slot]=rexp[0][slot]; r[1][slot]=rexp[1][slot]
    if slot==4 then
      getini("LowRtest",key,"%f,%f",r[0]+slot,r[1]+slot)
    else
      getini("LowRtest",key,"%f",r[0]+slot); r[1][slot]=r[0][slot]
    endif
    if Abs(r[0][slot]-rexp[0][slot]>0.050+rexp[0][slot]*0.05) then
      r[0][slot]=rexp[0][slot]
    endif
    if Abs(r[1][slot]-rexp[1][slot]>0.050+rexp[1][slot]*0.05) then
      r[1][slot]=rexp[1][slot]
    endif
    hvalue[slot]=control EDIT
      window=hright
      text=format(" %g",r[is1mohm][slot])
      position=104,y-19,91,24
      help=format("%s",meas[is1mohm][slot]+16)
      font=MEDIUMFONT
    endc
    draw at 203,y text="Ohm"
    y=y+30
  enddo
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+30,120,24
    name="确定"
    help="确认电阻值并进行测试"
  endc
  while 1 do
    if Pressed(h10ohm) then
      is1mohm=Status(h10ohm)
      change hvalue[4] help=format(                                            \
        "%s元件精准阻值",meas[is1mohm][4]+16)
      change hvalue[4] text=format(" %g",r[is1mohm][4])
    else if Pressed(hok) then
      break
    else if Pressed(hexit) then
      return -1
    endif
    wait
  enddo
  for slot=0,slot<NSLOT,slot++ do
    sprintf(key,"Value[%i]",slot)
    Text(hvalue[slot],s)
    if slot==4 then
      rexp[0][slot]=r[0][slot]
      rexp[1][slot]=r[1][slot]
      sscanf(s,"%g",rexp[is1mohm]+slot)
      setini("LowRtest",key,"%f,%f",rexp[0][slot],rexp[1][slot])
    else
      sscanf(s,"%g",rexp[0]+slot)
      rexp[1][slot]=rexp[0][slot]
      setini("LowRtest",key,"%f",rexp[0][slot])
    endif
  enddo
end

// Adjust expected resistances of 155/250-mm lines. Returns 0 on success and -1
// if operator interrupted the test.
function int Correctlines()
  int i,m,n,t,rail,head,nrail,canmeasure,pending[16],err
  float r,x1,y1,x2,y2,x3,y3,x4,y4,dx,dy,temp,factor
  float rzero[5],roffset,rwire[5]
  char s[512]
  char wire[5][4] = { "R00", "R01", "R10", "1R0", "10R" }
  handle hvalue,huse,hmeasure,hok,hinterrupt
  nrail=$LAY.nfing
  if ($LAY.probetype & 1)!=0 then
    canmeasure=1                       // Kelvin probes
  else if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&      \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_A7 &&             \
    testertype!=TT_A8 && testertype!=TT_S3 then
    canmeasure=0                       // 4-wire measurements not supported
  else
    canmeasure=0
    Memcpy(s,meas[0][0],3); s[3]='\0';
    for rail=0,rail<nrail-1,rail++ do
      if used[rail*2]==0 || used[rail*2+2]==0 continue
      if $LAY.side[rail]!=$LAY.side[rail+1] continue
      if Convertalt(&x1,&y1,s,rail*2,0.0)!=0 &&                                \
        Convertalt(&x1,&y1,s,rail*2+2,0.0)!=0 continue
      canmeasure=1                     // Two adjacent rails on same side
      break
    enddo
  endif
retry:
  clear hright
  change hinfo limits=0,0
  change hinfo text="纠正线路阻值"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="校验板上细线路会有差异。如果校验板 "
  draw text="上有已知精准值，请填入空格内，"
  if canmeasure draw text="同时\n也可以用机台量测。"
  draw text="准备好点击" font=MAINFONT text="确定." font=TIMESFONT
  //draw text="when ready."
  if boardtype==0 then
    rline=RLINED*rowdist
    getini("LowRtest","Rline","%g",&rline)
    if rline<=0.0 || rline>0.010 rline=RLINED*rowdist
  else if boardtype==1 then
    rline=RLINEC*rowdist
    getini("LowRtest","Rline combo","%g",&rline)
    if rline<=0.0 || rline>0.010 rline=RLINEC*rowdist
  else if boardtype==2 then
    rline=RLINEC*rowdist
    getini("LowRtest","Rline XXL","%g",&rline)
    if rline<=0.0 || rline>0.010 rline=RLINEC*rowdist
  endif
  if canmeasure then
    huse=control RADIO
      window=hright
      position=15,120,100,24
      text="使用已知值"
      help="Use known value"
      font=INFOFONT
      mode=M_CHECKED
    endc
  else
    huse=NULL
    draw at 15,138 text="Use known:"
  endif
  hvalue=control EDIT
    window=hright
    text=format(" %g",rline*1000.0)
    position=117,120,81,24
    help=format("%.0f-mm 线路精准电阻, 毫欧",rowdist)
    font=MEDIUMFONT
  endc
  draw font=MEDIUMFONT at 203,141 text="mOhm"
  if canmeasure then
    hmeasure=control RADIO
      window=hright
      position=15,160,100,24
      text="立即测量"
      help=format("测量 %.0f-mm 线路阻值",rowdist)
      font=INFOFONT
    endc
  else
    hmeasure=NULL
  endif
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+30,120,24
    name="确定"
    help="Confirm ressitance and proceed with the test"
  endc
  draw show
  while 1 do
    rline=0.0; Text(hvalue,s); sscanf(s,"%g",&rline); rline=rline/1000.0
    if (rline<=0.0 || rline>0.010) && Status(huse)!=0 then
      disable hok
    else
      enable hok
    endif
    if Pressed(hok) break
    if Pressed(hexit) return -1
    wait
  enddo
  if hlog!=NULL then
    fprintf(hlog,"\n      Resistance of connecting lines:\n")
  endif
  if canmeasure && Status(huse)==0 then
    // Request to measure resistance.
    clear hright
    change hinfo limits=0,0
    change hinfo text="校验线路阻值"
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK
    draw text="线路阻值校验中。. "
    if ($LAY.probetype & 1)==0 then
      draw text="To improve accuracy, script uses 4-were measurements. "
    endif
    draw text="请稍等..."
    draw show
    if hlog!=NULL fprintf(hlog,"      Calibrating...\n")
    hinterrupt=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="终止"
      help="Press to interrupt test"
    endc
    err=0
    Initsigma(rzero)
    Initsigma(rwire)
    // First, measure resistance of shortcut (100 measurements per rail).
    for n=0,n<100 && err==0,n=n+2 do
      change hinfo limits=n,300        // This step is fast
      for rail=0,rail<nrail && err==0,rail++ do
        pending[rail]=0
        if used[rail*2]==0 continue
        Memcpy(s,meas[0][0],3); s[3]='\0'
        dx=Random(DELTA)+Random(DELTA)-DELTA
        dy=Random(DELTA)+Random(DELTA)-DELTA
        if ($LAY.probetype & 1)!=0 then
          // Kelvin measurements.
          Convertpad(&x1,&y1,s,rail*2,0.0)
          x1=x1+dx; y1=y1+dy
          x1=x1-(islargepads?DISTXNEW:DISTXOLD)
          if y1<$LAY.yoffset[rail]/1000.0 then
            y1=y1+(islargepads?DISTYNEW:DISTYOLD)
          else
            y1=y1-(islargepads?DISTYNEW:DISTYOLD)
          endif
          Memcpy(s,meas[0][0]+4,3); s[3]='\0';
          Convertpad(&x2,&y2,s,rail*2+1,0.0)
          x2=x2+dx; y2=y2+dy
          x2=x2+(islargepads?DISTXNEW:DISTXOLD)
          if y2<$LAY.yoffset[rail]/1000.0 then
            y2=y2+(islargepads?DISTYNEW:DISTYOLD)
          else
            y2=y2-(islargepads?DISTYNEW:DISTYOLD)
          endif
          // Send two commands.
          m=sprintf(s,"M %i[%.3f,%.3fA20V%iP%iH%g] %i[%.3f,%.3f20V%iP%iH%g] ", \
            rail*2,x1,y1,strokev,strokep,strokez,                              \
            rail*2+1,x2,y2,strokev,strokep,strokez)
          sprintf(s+m,"E(%i,%i)",rail*2,rail*2+1)
          SERV.Cmdimm(rail*2,s)
          sprintf(s+m,"E(%i,%i)",rail*2+1,rail*2)
          SERV.Cmdimm(rail*2+1,s)
          pending[rail]=1
        else
          // 4-wire measurements.
          if rail==nrail-1 continue
          if used[rail*2+2]==0 continue
          if $LAY.side[rail]!=$LAY.side[rail+1] continue
          if Convertalt(&x1,&y1,s,rail*2,0.0)!=0 &&                            \
            Convertalt(&x2,&y2,s,rail*2+2,0.0)!=0 continue
          Convertpad(&x1,&y1,s,rail*2,0.0)
          x1=x1+dx; y1=y1+dy
          Convertpad(&x2,&y2,s,rail*2+1,0.0)
          x2=x2+dx; y2=y2+dy
          if y1<$LAY.top[rail]/1000.0-5.0 then
            if Convertalt(&x1,&y1,s,rail*2,0.0)!=0 continue
            x1=x1+dx; y1=y1+dy
            if Convertalt(&x2,&y2,s,rail*2+1,0.0)!=0 continue
            x2=x2+dx; y2=y2+dy
          endif
          if y1<$LAY.top[rail]/1000.0-5.0 continue
          Convertpad(&x3,&y3,s,rail*2+2,0.0)
          x3=x3+dx; y3=y3+dy
          Convertpad(&x4,&y4,s,rail*2+3,0.0)
          x4=x4+dx; y4=y4+dy
          if y3>$LAY.bottom[rail+1]/1000.0+5.0 then
            if Convertalt(&x3,&y3,s,rail*2+2,0.0)!=0 continue
            x3=x3+dx; y3=y3+dy
            if Convertalt(&x4,&y4,s,rail*2+3,0.0)!=0 continue
            x4=x4+dx; y4=y4+dy
          endif
          if y3>$LAY.bottom[rail+1]/1000.0+5.0 continue
          if y3-y1>10.0 continue
          x1=x1-(islargepads?DISTXNEW:DISTXOLD)
          y1=y1-(islargepads?DISTYNEW:DISTYOLD)
          x2=x2+(islargepads?DISTXNEW:DISTXOLD)
          y2=y2-(islargepads?DISTYNEW:DISTYOLD)
          x3=x3-(islargepads?DISTXNEW:DISTXOLD)
          y3=y3+(islargepads?DISTYNEW:DISTYOLD)
          x4=x4+(islargepads?DISTXNEW:DISTXOLD)
          y4=y4+(islargepads?DISTYNEW:DISTYOLD)
          // Send two commands.
          m=sprintf(s,                                                         \
            "M %i[%.3f,%.3fA20V%iP%iH%g] %i[%.3f,%.3fA20V%iP%iH%g] ",          \
            rail*2,x1,y1,strokev,strokep,strokez,                              \
            rail*2+1,x2,y2,strokev,strokep,strokez)
          m=m+sprintf(s+m,                                                     \
            "%i[%.3f,%.3fA20V%iP%iH%g] %i[%.3f,%.3fA20V%iP%iH%g] ",            \
            rail*2+2,x3,y3,strokev,strokep,strokez,                            \
            rail*2+3,x4,y4,strokev,strokep,strokez)
          sprintf(s+m,"Q(%i,%i,%i,%i)",                                        \
            rail*2,rail*2+1,rail*2+3,rail*2+2)
          SERV.Cmdimm(rail*2,s)
          sprintf(s+m,"Q(%i,%i,%i,%i)",                                        \
            rail*2+1,rail*2,rail*2+2,rail*2+3)
          SERV.Cmdimm(rail*2+1,s)
          pending[rail]=1
        endif
      enddo
      // Wait for answers.
      t=Time()
      while err==0 do
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hinterrupt) then
          err=3; break
        endif
        for rail=0,rail<nrail,rail++ do
          if pending[rail]==0 continue
          if $A[rail*2].length==0 break
          if $A[rail*2+1].length==0 break
        enddo
        if rail>=nrail break           // All answers came
        if Time()-t>10000 then
          err=1; break                 // Timeout 10 seconds
        endif
        wait
      enddo
      if err break
      // Process answers.
      for head=0,head<nrail*2,head++ do
        if pending[head/2]==0 continue
        if $A[head].answer!=S_MOVE continue
        if ($A[head].status & 0x8E00)!=0 continue
        r=$A[head].r
        if ($A[head].status & 0x0100) r=r*1.0e-6
        if r<(-0.005) || r>0.005 continue
        Addsigma(rzero,r)
      enddo
    enddo
    if err==0 && Getcount(rzero)<50 then
      err=2                            // Too few measurements
    endif
    roffset=Getsigma(rzero)
    // Now, measure the resistance of the lines.
    for n=0,n<100 && err==0,n=n+2 do
      change hinfo limits=n*2+100,300
      factor=Getlinefactor(wire[n%5])
      for rail=0,rail<nrail && err==0,rail++ do
        pending[rail]=0
        if used[rail*2]==0 continue
        if ($LAY.probetype & 1)!=0 then
          // Kelvin measurements.
          if Convertalt(&x1,&y1,wire[n%5],rail*2,0.0)!=0                       \
            continue                   // No alternative point
          Convertpad(&x2,&y2,wire[n%5],rail*2+1,0.0)
          if x1>x2 then
            temp=x1; x1=x2; x2=temp
            temp=y1; y1=y2; y2=temp
          endif
          dx=Random(DELTA)-Random(DELTA)
          x1=x1+dx-(islargepads?DISTXNEW:DISTXOLD)
          if y1<$LAY.yoffset[rail]/1000.0 then
            y1=y1+(islargepads?DISTYNEW:DISTYOLD)
          else
            y1=y1-(islargepads?DISTYNEW:DISTYOLD)
          endif
          x2=x2+dx+(islargepads?DISTXNEW:DISTXOLD)
          if y2<$LAY.yoffset[rail]/1000.0 then
            y2=y2+(islargepads?DISTYNEW:DISTYOLD)
          else
            y2=y2-(islargepads?DISTYNEW:DISTYOLD)
          endif
          // Send two commands.
          m=sprintf(s,"M %i[%.3f,%.3fA20V%iP%iH%g] %i[%.3f,%.3fA20V%iP%iH%g] ",\
            rail*2,x1,y1,strokev,strokep,strokez,                              \
            rail*2+1,x2,y2,strokev,strokep,strokez)
          sprintf(s+m,"E(%i,%i)",rail*2,rail*2+1)
          SERV.Cmdimm(rail*2,s)
          sprintf(s+m,"E(%i,%i)",rail*2+1,rail*2)
          SERV.Cmdimm(rail*2+1,s)
          pending[rail]=1
        else
          // 4-wire measurements.
          if rail==nrail-1 continue
          if used[rail*2+2]==0 continue
          if $LAY.side[rail]!=$LAY.side[rail+1] continue
          for i=0,i<4,i++ do
            dx=Random(DELTA)+Random(DELTA)-DELTA
            dy=Random(DELTA)+Random(DELTA)-DELTA
            if i==0 || i==1 then
              Convertpad(&x1,&y1,wire[n%5],rail*2,0.0)
              Convertpad(&x2,&y2,wire[n%5],rail*2+1,0.0)
            else
              if Convertalt(&x1,&y1,wire[n%5],rail*2,0.0)!=0 continue
              if Convertalt(&x2,&y2,wire[n%5],rail*2+1,0.0)!=0 continue
            endif
            x1=x1+dx; y1=y1+dy
            x2=x2+dx; y2=y2+dy
            if i==0 || i==2 then
              Convertpad(&x3,&y3,wire[n%5],rail*2+2,0.0)
              Convertpad(&x4,&y4,wire[n%5],rail*2+3,0.0)
            else
              if Convertalt(&x3,&y3,wire[n%5],rail*2+2,0.0)!=0 continue
              if Convertalt(&x4,&y4,wire[n%5],rail*2+3,0.0)!=0 continue
            endif
            x3=x3+dx; y3=y3+dy
            x4=x4+dx; y4=y4+dy
            if y3-y1<10.0 continue
            if boardtype==2 && y3-y1>300.0 continue
            if boardtype!=2 && y3-y1>170.0 continue
            break
          enddo
          if i>=4 continue
          x1=x1-(islargepads?DISTXNEW:DISTXOLD)
          y1=y1-(islargepads?DISTYNEW:DISTYOLD)
          x2=x2+(islargepads?DISTXNEW:DISTXOLD)
          y2=y2-(islargepads?DISTYNEW:DISTYOLD)
          x3=x3-(islargepads?DISTXNEW:DISTXOLD)
          y3=y3+(islargepads?DISTYNEW:DISTYOLD)
          x4=x4+(islargepads?DISTXNEW:DISTXOLD)
          y4=y4+(islargepads?DISTYNEW:DISTYOLD)
          // Send two commands.
          m=sprintf(s,                                                         \
            "M %i[%.3f,%.3fA20V%iP%iH%g] %i[%.3f,%.3fA20V%iP%iH%g] ",          \
            rail*2,x1,y1,strokev,strokep,strokez,                              \
            rail*2+1,x2,y2,strokev,strokep,strokez)
          m=m+sprintf(s+m,                                                     \
            "%i[%.3f,%.3fA20V%iP%iH%g] %i[%.3f,%.3fA20V%iP%iH%g] ",            \
            rail*2+2,x3,y3,strokev,strokep,strokez,                            \
            rail*2+3,x4,y4,strokev,strokep,strokez)
          sprintf(s+m,"Q(%i,%i,%i,%i)",                                        \
            rail*2,rail*2+1,rail*2+3,rail*2+2)
          SERV.Cmdimm(rail*2,s)
          sprintf(s+m,"Q(%i,%i,%i,%i)",                                        \
            rail*2+1,rail*2,rail*2+2,rail*2+3)
          SERV.Cmdimm(rail*2+1,s)
          pending[rail]=1
        endif
      enddo
      // Wait for answers.
      t=Time()
      while err==0 do
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hinterrupt) then
          err=3; break
        endif
        for rail=0,rail<nrail,rail++ do
          if pending[rail]==0 continue
          if $A[rail*2].length==0 break
          if $A[rail*2+1].length==0 break
        enddo
        if rail>=nrail break           // All answers came
        if Time()-t>10000 then
          err=1; break                 // Timeout 10 seconds
        endif
        wait
      enddo
      if err break
      // Process answers.
      for head=0,head<nrail*2,head++ do
        if pending[head/2]==0 continue
        if $A[head].answer!=S_MOVE continue
        if ($A[head].status & 0x8E00)!=0 continue
        r=$A[head].r
        if ($A[head].status & 0x0100) r=r*1.0e-6
        r=(r-roffset)/factor           // Takes line width into account
        if boardtype==0 then
          if r<(-0.005+RLINED*rowdist) || r>0.005+RLINED*rowdist continue
        else
          if r<(-0.005+RLINEC*rowdist) || r>0.005+RLINEC*rowdist continue
        endif
        Addsigma(rwire,r)
      enddo
    enddo
    if err==0 && Getcount(rwire)<50 then
      err=2                            // Too few measurements
    endif
    if err==0 then
      rline=Getmean(rwire)
      if rline<=0.0 || rline>0.010 err=4
    endif
    clear hright
    change hinfo limits=0,0
    if err!=0 then
      change hinfo text="Unable to calibrate!"
      draw window=hright font=TIMESFONT wrap=RIGHTX-5
      draw at 6,30 color=LIGHTRED
      draw text="Unable to calibrate wires!"
      draw at 6,60 color=BLACK
      draw text="Script was unable to calibrate the resistance of lines on "
      draw text="board"
      if err==1 then
        draw text=" due to timeout. "
        if hlog!=NULL fprintf(hlog,"      Timeout!\n")
      else if err==2 then
        draw text=". The measurements are either invalid or out of range. "
        if hlog!=NULL fprintf(hlog,"      Invalid measurements!\n")
      else if err==3 then
        draw text=" due to interrupt by operator. "
        if hlog!=NULL fprintf(hlog,"      Interrupted by operator!\n")
      else if err==4 then
        draw text=". The measured wire resistance is outside the expected "
        draw text="limits. "
        if hlog!=NULL fprintf(hlog,"      Resistance outside the limits!\n")
      else
        draw text=". "
      endif
      draw text="Please try again."
      draw show
      hok=control BUTTON
        window=hright
        position=(RIGHTX-120)/2,USERY+30,120,24
        name="确定"
        help="Repeat calibration"
      endc
      while 1 do
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hok) goto retry
        wait
      enddo
    endif
  endif
  if hlog!=NULL then
    n=fprintf(hlog,"      Wire resistance")
    for n=n,n<26,n++ do
      fprintf(hlog," ")
    enddo
    fprintf(hlog,"%8.6f Ohm\n",rline)
  endif
  if boardtype==1 then
    setini("LowRtest","Rline combo","%g",rline)
  else if boardtype==2 then
    setini("LowRtest","Rline XXL","%g",rline)
  else
    setini("LowRtest","Rline","%g",rline)
  endif
end

// Displays histogram for given rail (16: cumulative) and measured value.
function int Displayrhist(int rail,int slot)
  int i,k,n,x,y,x0,y0,xstep,ystep,hsum,hmax
  float yscale,rx
  // Update buttons.
  if rail!=showrail then
    if showrail>=0 then
      change hrail[showrail] color=BLACK
      change hrail[showrail] bkcolor=GRAY
    endif
    showrail=rail
    change hrail[showrail] color=LIGHTRED
    change hrail[showrail] bkcolor=YELLOW
  endif
  if slot!=showslot then
    if showslot>=0 then
      change hslot[showslot] color=BLACK
      change hslot[showslot] bkcolor=GRAY
    endif
    showslot=slot
    change hslot[showslot] color=LIGHTRED
    change hslot[showslot] bkcolor=YELLOW
  endif
  // Calculate maximum of selected histogram and total number of measurements.
  hsum=0; hmax=0
  for i=0,i<NHIST,i++ do
    hsum=hsum+rhist[slot][rail][i]
    hmax=Max(hmax,rhist[slot][rail][i])
  enddo
  // Calculate parameters of histogram.
  x0=35
  y0=GRAPHY-80
  xstep=(LEFTX-x0-5)/NHIST
  for i=10000,i>0,i=i/10 do
    k=5; if hmax+10>=3*k*i break
    k=2; if hmax+10>=3*k*i break
    k=1; if hmax+10>=3*k*i break
  enddo
  ystep=i*k
  yscale=(y0-22)/(10.0+hmax)           // Pixels per unit
  // Clear histogram.
  draw window=hgraph bkcolor=WHITE clear
  draw font=MEDIUMFONT color=DARKGRAY mode=M_CENTERED
  draw at x0+(NHIST/2)*xstep+xstep/2,25
  if rail==16 then
    draw text=format("所有轨道, %s",meas[is1mohm][slot]+16)
  else
    draw text=format("Rail %i, %s",rail,meas[is1mohm][slot]+16)
  endif
  if slot<NSLOT then
    // Draw X axis.
    draw color=DARKGRAY at x0,y0 to x0+NHIST*xstep+5,y0
    draw font=SMALLFONT mode=M_CENTERED
    for i=0,i<NHIST,i++ do
      if (i-NHIST/2+100)%20!=0 continue
      k=(rexp[is1mohm][slot]+(i-NHIST/2)*histstep)*1000
      rx=k/1000.0
      x=x0+i*xstep+xstep/2
      draw color=DARKGRAY at x,y0 to x,y0+5
      draw color=BLACK at x,y0+16 text=format("%.3f",rx)
    enddo
    x=x0+(NHIST/2)*xstep+xstep/2
    draw color=GRAY at x,y0-1 to x,28
    // Draw Y axis.
    draw color=DARKGRAY at x0,y0 to x0,14
    draw font=SMALLFONT mode=M_RIGHT
    for i=0,i<100,i++ do
      y=y0-i*ystep*yscale
      if y<22 break
      draw color=DARKGRAY at x0,y to x0-5,y
      draw color=BLACK at x0-7,y+6 text=format("%i",i*ystep)
    enddo
    // Draw data.
    draw color=BLACK bkcolor=DARKGRAY
    for i=0,i<NHIST,i++ do
      x=x0+i*xstep
      y=y0-rhist[slot][rail][i]*yscale
      draw at x,y0 fillrect x+xstep+1,y
    enddo
  endif
  // Display statistics.
  draw font=TIMESFONT mode=M_LEFT color=BLUE
  if slot<NSLOT then
    draw at 30,GRAPHY-37 text=format("良好: %i, 坏: ",hsum)
    draw color=(rbad[slot][rail]==0?BLUE:LIGHTRED)
    draw text=format("%i",rbad[slot][rail])
    draw color=BLUE text=", 开路: "
    draw color=(ropens[slot][rail]==0?BLUE:LIGHTRED)
    draw text=format("%i",ropens[slot][rail])
    draw color=BLUE text=", 未接触: "
    draw color=(rnoct1[slot][rail]==0 && rnoct2[slot][rail]==0?BLUE:LIGHTRED)
    if rail==16 then
      draw text=format("%i",rnoct1[slot][rail]+rnoct2[slot][rail])
    else
      draw text=format("%i/%i",rnoct1[slot][rail],rnoct2[slot][rail])
    endif
  else
    n=Getcount(rstat[slot][rail])+rbad[slot][rail]+ropens[slot][rail]
    draw at 30,GRAPHY-37 text=format("错误接触 (左/右): ")
    draw color=(rnoct1[slot][rail]==n && rnoct2[slot][rail]==n?BLUE:LIGHTRED)
    if rail==16 then
      draw text=format("%i",2*n-rnoct1[slot][rail]-rnoct2[slot][rail])
    else
      draw text=format("%i/%i",n-rnoct1[slot][rail],n-rnoct2[slot][rail])
    endif
  endif
  draw color=BLUE at 30,GRAPHY-22 text=format("中值 R = %.5f ?%.5f Ohm",      \
    Getmean(rstat[slot][rail]),Getsigma(rstat[slot][rail]))
  draw at 30,GRAPHY-7 text=format("最下值 = %.5f, 最大值 = %.5f Ohm",            \
    Getmin(rstat[slot][rail]),Getmax(rstat[slot][rail]))
  draw show
end

// Displays histogram for given head and stroke (NSTROKE: summary).
function int Displayfhist(int head,int stroke)
  int i,j,k,x,y,x0,y0,nrail,xstep,ystep,hsum,hmax
  float rx,yscale
  // Update buttons.
  if head!=showhead || stroke!=showstroke then
    if showhead>=0 then
      change hhead[showhead] color=BLACK
      change hhead[showhead] bkcolor=GRAY
    endif
    showhead=head
    if stroke!=NSTROKE then
      change hhead[showhead] color=LIGHTRED
      change hhead[showhead] bkcolor=YELLOW
    endif
  endif
  if stroke!=showstroke then
    if showstroke>=0 then
      change hstroke[showstroke] color=BLACK
      change hstroke[showstroke] bkcolor=GRAY
    endif
    showstroke=stroke
    change hstroke[showstroke] color=LIGHTRED
    change hstroke[showstroke] bkcolor=YELLOW
  endif
  if stroke==NSTROKE then
    // Display summary.
    nrail=$LAY.nfing
    draw window=hgraph bkcolor=WHITE clear
    draw font=MEDIUMFONT color=DARKGRAY mode=M_CENTERED
    draw at LEFTX/2,28 text="汇总"
    draw font=TIMESFONT color=BLACK mode=M_LEFT
    for i=0,i<2,i++ do
      x=10+(LEFTX/2-5)*i
      for k=0,k<NSTROKE,k++ do
        draw at x+25+30*k,56 text=format("%g g",plist[k]/10.0)
      enddo
    enddo
    for j=0,j<nrail,j++ do
      y=80+j*22
      for i=0,i<2,i++ do
        x=10+(LEFTX/2-5)*i
        draw font=TIMESFONT
        draw color=BLACK at x,y text=format("%i%c",j,i==0?'L':'R')
        for k=0,k<NSTROKE,k++ do
          draw font=SMALLFONT
          draw at x+25+30*k,y
          if fquality[k][j*2+i]==0 then
            draw color=BLACK text=" ---"
            continue
          else if fquality[k][j*2+i]>=BESTLIM then
            draw color=GREEN
          else if fquality[k][j*2+i]>=GOODLIM then
            draw color=BLUE
          else if fquality[k][j*2+i]>=POORLIM then
            draw color=RED
          else
            draw color=LIGHTRED
          endif
          draw text=format("%i%%",fquality[k][j*2+i])
        enddo
        draw at x+25+30*NSTROKE,y
        if fresult[j*2+i]<0 then
          draw color=LIGHTRED text="Bad"
        else if fresult[j*2+i]>0 then
          draw color=BLACK text="确定"
        endif
      enddo
    enddo
  else
    // Display individual needle statistics.
    hsum=0; hmax=0
    // Calculate maximum of selected histogram and total number of measurements.
    for i=0,i<NHIST,i++ do
      hsum=hsum+fhist[stroke][head][i]
      hmax=Max(hmax,fhist[stroke][head][i])
    enddo
    // Calculate parameters of histogram.
    x0=35
    y0=GRAPHY-80
    xstep=(LEFTX-x0-5)/NHIST
    for i=10000,i>0,i=i/10 do
      k=5; if hmax+10>=3*k*i break
      k=2; if hmax+10>=3*k*i break
      k=1; if hmax+10>=3*k*i break
    enddo
    ystep=i*k
    yscale=(y0-22)/(10.0+hmax)         // Pixels per unit
    // Clear histogram.
    draw window=hgraph bkcolor=WHITE clear
    draw font=MEDIUMFONT color=DARKGRAY mode=M_CENTERED
    draw at x0+(NHIST/2)*xstep+xstep/2,25
    draw text=format("手臂 %i%c, %g 克",                                    \
      head/2,head & 1?'R':'L',plist[stroke]/10.0)
    // Draw X axis.
    draw color=DARKGRAY at x0,y0 to x0+NHIST*xstep+5,y0
    draw font=SMALLFONT mode=M_CENTERED
    for i=0,i<NHIST,i++ do
      if (i-NHIST/2+100)%20!=0 continue
      k=(rexp[is1mohm][0]+(i-NHIST/2)*histstep)*1000
      rx=k/1000.0
      x=x0+i*xstep+xstep/2
      draw color=DARKGRAY at x,y0 to x,y0+5
      draw color=BLACK at x,y0+16 text=format("%.3f",rx)
    enddo
    x=x0+(NHIST/2)*xstep+xstep/2
    draw color=GRAY at x,y0-1 to x,28
    // Draw Y axis.
    draw color=DARKGRAY at x0,y0 to x0,14
    draw font=SMALLFONT mode=M_RIGHT
    for i=0,i<100,i++ do
      y=y0-i*ystep*yscale
      if y<22 break
      draw color=DARKGRAY at x0,y to x0-5,y
      draw color=BLACK at x0-7,y+6 text=format("%i",i*ystep)
    enddo
    // Draw data.
    draw color=BLACK bkcolor=DARKGRAY
    for i=0,i<NHIST,i++ do
      x=x0+i*xstep
      y=y0-fhist[stroke][head][i]*yscale
      draw at x,y0 fillrect x+xstep+1,y
    enddo
    // Show statistics.
    draw font=TIMESFONT mode=M_LEFT
    draw color=BLUE at 30,GRAPHY-37
    draw text=format("良好: %i, 未接触: ",Getcount(fstat[stroke][head]))
    draw color=(fnoct[stroke][head]==0?BLUE:LIGHTRED)
    draw text=format("%i",fnoct[stroke][head])
    draw color=BLUE text=", 针尖绝缘板上短路: "
    draw color=(fshortsfr[stroke][head]==0?BLUE:LIGHTRED)
    draw text=format("%i",fshortsfr[stroke][head])
    draw color=BLUE at 30,GRAPHY-22
    draw text=format("中值 R = %.5f ?%.5f Ohm",                               \
      Getmean(fstat[stroke][head]),Getsigma(fstat[stroke][head]))
    draw color=BLUE at 30,GRAPHY-7
    draw text=format("品质 = %i%% ",fquality[stroke][head])
    if fquality[stroke][head]==0 then
      draw color=BLACK text="(NOT TESTED)"
    else if fquality[stroke][head]>=BESTLIM then
      draw color=GREEN text="(BEST)"
    else if fquality[stroke][head]>=GOODLIM then
      draw color=BLUE text="(GOOD)"
    else if fquality[stroke][head]>=POORLIM then
      draw color=RED text="(POOR)"
    else
      draw color=LIGHTRED text="(BAD)"
    endif
  endif
  draw show
end

// Checks for requests to display different resistance and rail.
function int Checkrequest()
  int i,rail,slot,head,stroke,pressed
  if selectionmode==0 then
    // Rail display.
    rail=showrail
    slot=showslot
    for i=0,i<17,i++ do
      if Pressed(hrail[i])==0 continue
      rail=i
      pressed=1
    enddo
    for i=0,i<NTOTAL,i++ do
      if Pressed(hslot[i])==0 continue
      slot=i
      pressed=1
    enddo
    if pressed Displayrhist(rail,slot)
  else if selectionmode==1 then
    // Finger display.
    head=showhead
    stroke=showstroke
    for i=0,i<32,i++ do
      if Pressed(hhead[i])==0 continue
      head=i
      pressed=1
    enddo
    for i=0,i<NSTROKE+1,i++ do
      if Pressed(hstroke[i])==0 continue
      stroke=i
      pressed=1
    enddo
    if pressed Displayfhist(head,stroke)
  endif
end

// Calibrates individual needle resistances and applies new parameters to
// layout. Returns -1 if operator interrupted test and 0 otherwise (even if
// adjustment was unsuccessful).
function int Adjustneedleresist()
  int i,j,k,m,n,t,attempt,ntest,rejected,badhead,maxbad,err
  int nappr[32],nbad[32]
  float x[32],y[32],r,r0,rdata[32,32,5],rmean[32,32],rappr[32],rind[32]
  char s[256]
  struct t_layout l
  struct t_extlay xl
  handle hlist,hcancel,hcont
  change hinfo text="单个电阻"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="校准头部电阻将确定每个针的单个电阻,"
  draw text="并确保其保存到布局.这种校准大大提高"
  draw text="了非开尔文测量的准确性."
  hcancel=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="终止"
    help="Press to interrupt individual resistance calibration"
  endc
  draw show
  clear hleft
  hlist=control LIST                   // Intermediate protocol in window
    window=hleft
    position=-1,-1,LEFTX+2,LEFTY+2
    help="过程测试结果"
    font=TERMINALFONT
    mode=M_VSCROLL
    size=65536
  endc
  change hlist color=RED
  add hlist text="  单个手臂上电阻的校正"
  add hlist text=""
  err=0
  attempt=0
nextattempt:
  attempt++
  for i=0,i<$LAY.nfing*2-1,i++ do
    for j=i+1,j<$LAY.nfing*2,j++ do
      Initsigma(rdata[i,j])
    enddo
  enddo
  ntest=8                              // 8 measurements for reliability
  for m=0,m<ntest && err==0,m++ do
    for i=0,i<$LAY.nfing,i++ do        // Calculate new coordinates
      Convertpad(x+i*2,y+i*2,"R01",i*2,DELTA/4.0)
      x[i*2]=x[i*2]-(islargepads?DISTXNEW:DISTXOLD)
      if y[i*2]<$LAY.yoffset[i]/1000.0 then
        y[i*2]=y[i*2]+(islargepads?DISTYNEW:DISTYOLD)
      else
        y[i*2]=y[i*2]-(islargepads?DISTYNEW:DISTYOLD)
      endif
      Convertpad(x+i*2+1,y+i*2+1,"R01",i*2+1,DELTA/4.0)
      x[i*2+1]=x[i*2+1]+(islargepads?DISTXNEW:DISTXOLD)
      if y[i*2+1]<$LAY.yoffset[i]/1000.0 then
        y[i*2+1]=y[i*2+1]+(islargepads?DISTYNEW:DISTYOLD)
      else
        y[i*2+1]=y[i*2+1]-(islargepads?DISTYNEW:DISTYOLD)
      endif
    enddo
    // Move fingers to contacts. First measurement after contact is reached
    // is less reliable. To assure better stability, I make two dummy
    // measurements per rail.
    for i=0,i<$LAY.nfing*2,i++ do      // Move fingers
      SYS.Killimm(i)                   // Recover from previous test
      sprintf(s,"M %i[%.3f,%.3fA15] %i[%.3f,%.3fA15] E(%i,%i)",                \
        i,x[i],y[i],i^1,x[i^1],y[i^1],i,i^1)
      if SERV.Cmdimm(i,s)<0 err=1      // Unable to send command
    enddo
    t=Time()
    while err==0 do                    // Wait till all answers come back
      if Pressed(hexit) return -1      // Operator interrupted test
      for i=0,i<$LAY.nfing*2,i++ do
        if $A[i].length==0 break
      enddo
      if i>=$LAY.nfing*2 break         // All answers came
      if Time()-t>15000 err=1          // Timeout 15 seconds
      wait
    enddo
    delay 200                          // Additional delay to improve contact
    if protall then
      if txtok then
        fprintf(hlog,"\nIndividual head resistance adjustment:\n")
      endif
      if rtfok then
        RParagraph(RTF_LEFT|RTF_INDENT)
        RFmt(RTF_COURIER,RTF_BOLD,8)
        RAddfmt("\nIndividual head resistance adjustment:\n")
        RFmt(RTF_COURIER,RTF_NORMAL,8)
      endif
    endif
    // Measure resistances: each finger against each other.
    k=0
    for i=0,i<$LAY.nfing*2-1 && err==0,i++ do
      for j=i+1,j<$LAY.nfing*2 && err==0,j++ do
        t=$LAY.nfing*2
        change hinfo limits=t/2*(t-1)*m+k,t/2*(t-1)*ntest
        sprintf(s,"M %i[%.3f,%.3fA15] %i[%.3f,%.3fA15] E(%i,%i)",              \
          i,x[i],y[i],j,x[j],y[j],i,j)
        if SERV.Cmdimm(0,s)<0 err=1    // Unable to send command
        if SERV.Cmdimm(1,s)<0 err=1
        sprintf(s,"M %i[%.3f,%.3fA15] %i[%.3f,%.3fA15] E(%i,%i)",              \
          i,x[i],y[i],j,x[j],y[j],j,i)
        if SERV.Cmdimm(2,s)<0 err=1    // Unable to send command
        if SERV.Cmdimm(3,s)<0 err=1
        t=Time()
        while err==0 do                // Wait till all answers come back
          if Pressed(hexit) return -1
          for n=0,n<4,n++ do
            if $A[n].length==0 break
          enddo
          if n>=4 break                // All answers came
          if Time()-t>10000 err=1      // Timeout 10 seconds
          wait
        enddo
        for n=0,n<4 && err==0,n++ do
          if $A[n].answer==S_ERROR then
            err=2; break               // Some error
          else if $A[n].answer!=S_MOVE then
            err=3; break               // Unbelievable, wrong answer
          endif
          r=$A[n].r; if ($A[n].status & 0x0100) r=r*1.0e-6
          if Abs(r)>1000.0 || ($A[n].status & 0x8E00)!=0 then
            rejected=1
          else
            rejected=0
            Addsigma(rdata[i,j],r)
          endif
          if protall then
            sprintf(s,"  Exact R, heads %2i - %2i: %8.5g Ohm, status %04X%s",  \
              (n<2?i:j),(n<2?j:i),r,$A[n].status,(rejected?" - rejected":""))
            lprintf(GREEN,"%s",s)
            if txtok!=0 then
              fprintf(hlog,"%s\n",s)
            endif
            if rtfok!=0 then
              RAddfmt("%s\n",s)
            endif
          endif
        enddo
        k++
      enddo
    enddo
  enddo
  for i=0,i<$LAY.nfing*2,i++ do
    nbad[i]=0
  enddo
  for i=0,i<$LAY.nfing*2-1,i++ do
    for j=i+1,j<$LAY.nfing*2,j++ do
      rmean[i,j]=Getmean(rdata[i,j])
      if Getmin(rdata[i,j])<(-10.0) || Getmax(rdata[i,j])>20.0 ||              \
        Getsigma(rdata[i,j])>0.5 || Getcount(rdata[i,j])<10 then
        err=4
        nbad[i]++; nbad[j]++
        n=Sprintf(s,"%i%c to %i%c: Rmin",                                      \
          i/2,(i & 1?'R':'L'),j/2,(j & 1?'R':'L'))
        r=Getmin(rdata[i,j])
        if r<(-10.0) then n=n+Sprintf(s+n,"<-10.0, Rmax");
        else if (r>100.0) then n=n+Sprintf(s+n,">100.0, Rmax");
        else n=n+Sprintf(s+n,"=%5.3g, Rmax",r); endif
        r=Getmax(rdata[i,j])
        if r<(-10.0) then n=n+Sprintf(s+n,"<-10.0, Sigma");
        else if (r>100.0) then n=n+Sprintf(s+n,">100.0, Sigma");
        else n=n+Sprintf(s+n,"=%5.3g, Sigma",r); endif
        r=Getsigma(rdata[i,j])
        if (r>100.0) then Sprintf(s+n,">100.0 Ohm");
        else Sprintf(s+n,"=%5.3g Ohm",r); endif
        change hlist color=LIGHTRED
        add hlist text=s
      endif
    enddo
  enddo
  maxbad=0; badhead=-1
  for i=0,i<$LAY.nfing*2,i++ do
    if nbad[i]>maxbad then
      maxbad=nbad[i]
      badhead=i
    endif
  enddo
  if err==4 && attempt<3 then
    err=0                              // Retry if measurements unsuccessfull
    change hinfo text="重测电阻值"
    add hlist text=""
    change hlist color=RED
    add hlist text="     RETRYING INDIVIDUAL FINGER RESISTANCES"
    add hlist text=""
    goto nextattempt
  endif
  // It is hardly possible, if at all, to solve appearing overdefined system
  // of equations analytically. Let us try subsequent approximations.
  for i=0,i<$LAY.nfing*2,i++ do
    rind[i]=0.0
  enddo
  for m=0,m<20 && err==0,m++ do
    for i=0,i<$LAY.nfing*2,i++ do
      rappr[i]=0.0; nappr[i]=0
    enddo
    for i=0,i<$LAY.nfing*2-1,i++ do
      for j=i+1,j<$LAY.nfing*2,j++ do
        rappr[i]=rappr[i]+rmean[i,j]/2.0
        nappr[i]++
        rappr[j]=rappr[j]+rmean[i,j]/2.0
        nappr[j]++
      enddo
    enddo
    for i=0,i<$LAY.nfing*2,i++ do
      if nappr[i]!=0 rappr[i]=rappr[i]/nappr[i]
      rind[i]=rind[i]+rappr[i]
    enddo
    for i=0,i<$LAY.nfing*2-1,i++ do
      for j=i+1,j<$LAY.nfing*2,j++ do
        rmean[i,j]=rmean[i,j]-rappr[i]-rappr[j]
      enddo
    enddo
  enddo
  // Make all individual corrections small non-negative numbers. Common part
  // of resistance will come into rzero.
  r0=1.0e30
  for i=0,i<$LAY.nfing*2,i++ do
    rind[i]=rind[i]+$EXTLAY.radj[i]/1.0e6
    if r0>rind[i] r0=rind[i]
  enddo
  for i=0,i<$LAY.nfing*2,i++ do
    rind[i]=rind[i]-r0
  enddo
  if err!=0 goto reporterror
  // Report individual corrections and update layout.
  change hlist color=RED
  add hlist text="  Head-independent shortcut resistance:"
  change hlist color=BLACK
  add hlist text=""
  add hlist text=format("  Old resistance   %.3f Ohm",$LAY.rzero*1.0e-6)
  add hlist text=format("  New resistance   %.3f Ohm",$LAY.rzero*1.0e-6+r0)
  add hlist text=""
  change hlist color=RED
  add hlist text="  Individual head resistances, Ohms:"
  add hlist text=""
  add hlist text="Head     Previous R     Corrected R        Sigma"
  change hlist color=BLACK
  add hlist text=""
  // Calculate mean dispersions, the most sound value here.
  for i=0,i<$LAY.nfing*2,i++ do
    rappr[i]=0.0; nappr[i]=0
  enddo
  for i=0,i<$LAY.nfing*2-1,i++ do
    for j=i+1,j<$LAY.nfing*2,j++ do
      rappr[i]=rappr[i]+Getsigma(rdata[i,j])
      nappr[i]++
      rappr[j]=rappr[j]+Getsigma(rdata[i,j])
      nappr[j]++
    enddo
  enddo
  for i=0,i<$LAY.nfing*2,i++ do
    if nappr[i]!=0 rappr[i]=rappr[i]/nappr[i]
    add hlist text=format("%2i%c       %9.3g       %9.3g      %7.3g",          \
    i/2,(i & 1)==0?'L':'R',                                                    \
    $EXTLAY.radj[i]/1.0e6,rind[i],rappr[i])
  enddo
  add hlist text=""
  if txtok!=0 then                     // Write results to .TXT protocol
    fprintf(hlog,"\n\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
    fprintf(hlog,"\n                 Adjustment of individual finger ")
    fprintf(hlog,"resistances\n\n")
    fprintf(hlog,"                 Old shortcut resistance  %.3f Ohm\n",       \
      $LAY.rzero*1.0e-6)
    fprintf(hlog,"                 New shortcut resistance  %.3f Ohm\n",       \
      $LAY.rzero*1.0e-6+r0)
    fprintf(hlog,"\n                          --------")
    fprintf(hlog," Correction, Ohms --------\n                 ")
    fprintf(hlog,"Head     Previous      Adjusted       Sigma\n\n")
    for i=0,i<$LAY.nfing*2,i++ do
      fprintf(hlog,"         %10i%c      %8.3g      %8.3g     %7.3g\n",        \
      i/2,(i & 1)==0?'L':'R',                                                  \
      $EXTLAY.radj[i]/1.0e6,rind[i],rappr[i])
    enddo
  endif
  if rtfok!=0 then                     // Write results to .RTF protocol
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddtext("\nAdjustment of individual finger resistances")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RParagraph(RTF_LEFT|RTF_KEEPNEXT)
    RAddfmt("\n\tOld shortcut resistance:  %.3f Ohm\n",$LAY.rzero*1.0e-6)
    RAddfmt("\tNew shortcut resistance:  %.3f Ohm\n",$LAY.rzero*1.0e-6+r0)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Head")
    RCell(RTF_CENTERED|RTF_THINBRD,28.0); RAddtext("Previous correction, ")
    RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RCell(RTF_CENTERED|RTF_THINBRD,28.0); RAddtext("Adjusted correction, ")
    RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RCell(RTF_CENTERED|RTF_THINBRD,20.0)
    RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("s")
    RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext(", ")
    RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    for i=0,i<$LAY.nfing*2,i++ do
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,12.0)
      RAddfmt("%i%c",i/2,(i & 1)==0?'L':'R')
      RCell(RTF_CENTERED|RTF_THINBRD,28.0)
      RAddfmt("%.3g",$EXTLAY.radj[i]/1.0e6)
      RCell(RTF_CENTERED|RTF_THINBRD,28.0)
      RAddfmt("%.3g",rind[i])
      RCell(RTF_CENTERED|RTF_THINBRD,20.0)
      RAddfmt("%.3g",rappr[i])
    enddo
    REndtable()
  endif
  Startexplanation(0)
  Explain(0,"Comments to the table above: Each finger has its own internal ")
  Explain(0,"resistance which adds to the resistance of the component. ")
  Explain(0,"Calibration of individual resistances drastically improves ")
  Explain(0,"accuracy for low-ohmical components.")
  Endexplanation()
  Oversurface()
  if txtok then
    fprintf(hlog,"\n\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  // Apply corrections to layuot.
  Memcpy(l,$LAY,768)
  Memcpy(xl,$EXTLAY,768)
  l.rzero=l.rzero+r0*1.0e6
  for i=0,i<$LAY.nfing*2,i++ do
    xl.radj[i]=rind[i]*1.0e6
  enddo
  if Loadlayoutmeas(l,xl,1)!=0 then
    err=5
    goto reporterror
  endif
  change hinfo text="校验完成"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 at 6,30 color=BLACK
  draw text="单个电阻校验已完成,新的校正文件"
  draw text="将储存在布局中."
  goto confirmexit
reporterror:
  change hlist color=LIGHTRED
  add hlist text="Calibration unsuccessfull!"
  clear hright
  change hinfo text="校验错误"
  change hinfo limits=0,0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    draw text="Command execution error!"
    draw at 6,60 color=BLACK
    draw text="Tester rejected command sent by this routine. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  else if err==4 then
    draw text="测量错误!"
    draw at 6,60 color=BLACK
    draw text="某些测试头测量的电阻超出允许范围或"
    draw text="非常不稳定。"
  else if err==5 then
    draw text="Unable to save layout!"
    draw at 6,60 color=BLACK
    draw text="Script was unable to write new layout to tester and/or save "
    draw text="it to disk. "
  endif
  draw text="校验进程被终止."
  draw show
confirmexit:
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="继续"
    help="Press to continue"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 0
    wait
  enddo
end

// Calibrates inductivity measurement parameters, applies new parameters to
// layout and flash on measurement card. If extmeas is 1, measurements are done
// by external device, if 0 - by measurement card. Requires embedded software
// with S_RLMEAS support. Returns -1 if operator interrupted test and 0
// otherwise (even if adjustment was unsuccessful).
function int Adjustinductivity(int extmeas)
  int i,j,k,m,n,p,t,freq,err,attempt,ntest,status,rejected,flashvalid
  int oldkey,newkey,fhead[32],pressure,range,freqindex[2],oldfreq[2]
  float x[32],y[32]
  float r,rexpected,ref,l,lcorr,extlr,extlrangecorr,rangediff
  float lpair[32,32][5],lmean[5],rmean[5],refmean[5],rphase[3][5],lphase[3][5]
  float lrange[2][32][5],oldflash[32,32],newflash[32,32]
  char s[1024],buf[256]
  handle hlist,hfreq[2],hstart,hcancel,hcont
  struct t_extlay xl
  int freqset[12] = {                                                          \
    10000, 15000, 20000, 25000, 30000, 40000,                                  \
    75000, 100000, 120000, 150000, 180000, 200000 }
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
  then
    return 0                           // Only A5/A6/S1 support RL measurement
  endif
  if extmeas!=0 && (features & MF_RLINIT)==0 then
    err=14
    goto reporterror
  else
    err=0
  endif
  clear hright
  change hinfo limits=0,0
  change hinfo text="电感值校验"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  if extmeas==0 then
    draw text="此校验测量每个测试头的电感值以提升"
    draw text="电感测试的准确性.然后调整设置中的参"
    draw text="数以及刷新测量卡中对应的矫正值。"
    draw text=""
  else
    draw text="请选择外部设备的测试频率。选择的频率"
    draw text="必须与实际测试时一样，否则测试结果会"
    draw text="有 100..200 uH的差异。选择好后点" font=MAINFONT text="开始."
    //draw font=TIMESFONT text="when ready."
  endif
  if extmeas!=0 && intladjusted==0 then
    draw color=LIGHTRED text="\n\n注意: 强烈建议在外部测试 "
    draw text="前调整内部电感值!" color=BLACK
  endif
  if extmeas!=0 then
    freqindex[0]=8
    freqindex[1]=11
    // Get old frequencies for external measurements.
    for freq=0,freq<2,freq++ do
      $A[0].length=0
      s[0]=S_DEBUG
      s[1]=0x25                        // Get individual parameter
      s[2]=0x80                        // Measurement card
      if freq==0 then
        $uint2(s+3)=4                  // External frequency 1, Hz
      else
        $uint2(s+3)=5                  // External frequency 2, Hz
      endif
      SYS.Sendimm(0,5,s)
      t=Time()+10000
      while t>Time() do
        if $A[0].length!=0 break
        wait
      enddo
      if $A[0].length==9 && $A[0].command==S_DEBUG then
        oldfreq[freq]=$int4($A[0]+5)
      else
        oldfreq[freq]=0
      endif
    enddo
    // Set test frequencies. I attempt to use the same frequencies as in flash.
    for freq=0,freq<2,freq++ do
      draw at 20,180+30*freq font=INFOFONT
      if freq==0 then
        draw text="默认频率:"
      else
        draw text="第二频率:"
      endif
      hfreq[freq]=control COMBOLIST
        window=hright
        position=133,161+30*freq,100,250
        help=format("Frequency %i for external device, Hz",freq+1)
      endc
      for i=0,i<12,i++ do
        add hfreq[freq] text=format("%g kHz",freqset[i]/1000.0)
        if freqset[i]==oldfreq[freq] freqindex[freq]=i
      enddo
      change hfreq[freq] select=freqindex[freq]
    enddo
  endif
  hstart=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+30,120,24
    name="开始"
    help="点击开始电感测试的校验"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+30,120,24
    name="取消"
    help="点击返回前一界面"
  endc
  draw show
  clear hleft
  hlist=control LIST                   // Intermediate protocol in window
    window=hleft
    position=-1,-1,LEFTX+2,LEFTY+2
    help="过程测试结果"
    font=TERMINALFONT
    mode=M_VSCROLL
    size=65536
  endc
  while 1 do
    if Pressed(hcancel) return 0       // Operator cancelled calibration
    if Pressed(hexit) return -1
    if extmeas!=0 && (Pressed(hfreq[0]) || Pressed(hfreq[1])) then
      freqindex[0]=Status(hfreq[0])
      freqindex[1]=Status(hfreq[1])
      if freqindex[0]==freqindex[1] then
        disable hstart
      else
        enable hstart
      endif
    endif
    if Pressed(hstart) break
    wait
  enddo
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="电感校验进程运行中。"
  draw show
  hcancel=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="终止"
    help="点击终止电感校验"
  endc
  // Recalculate head numbers in flash to those in layout.
  for i=0,i<32,i++ do
    fhead[i]=-1
  enddo
  for i=0,i<$LAY.nfing*2,i++ do
    if $LAY.side[i/2]==0 then
      fhead[i]=i
    else
      fhead[i]=i-$LAY.nfing+16
    endif
  enddo
  flashvalid=1
  // Get old version of flash corrections.
  if flashvalid then
    $A[0].length=0
    s[0]=S_DEBUG
    s[1]=0x25                          // Get individual parameter
    s[2]=0x80                          // Measurement card
    if extmeas==0 then
      $uint2(s+3)=0                    // Internal version key
    else
      $uint2(s+3)=3                    // External version key
    endif
    SYS.Sendimm(0,5,s)
    t=Time()+10000
    while t>Time() do
      if $A[0].length!=0 break
      wait
    enddo
    if $A[0].length==9 && $A[0].command==S_DEBUG then
      oldkey=$int4($A[0]+5)
    else
      oldkey=0
    endif
  endif
  // Stable contacts is a must during the L calibration.
  pressure=Max(80,strokep)
  // Make local copy of extended layout.
  Memcpy(xl,$EXTLAY,Sizeof(xl))
  // If external calibration, repeat it for all specified frequencies.
  for freq=0,freq<2 && err==0 ,freq++ do
    if extmeas==0 && freq>=1 break
    add hlist text=""
    add hlist text=""
    change hlist color=RED
    if extmeas==0 then
      add hlist text="    电感值测量校验"
    else
      add hlist text=format("       EXTERNAL INDUCTIVITY AT F=%g KHZ",         \
      freqset[freqindex[freq]]/1000.0)
    endif
    add hlist text=""
    // Force internal or external mode.
    if (features & MF_RLINIT) then
      buf[0]=0x35                      // S_RLINIT
      if extmeas then
        $uint2(buf+1)=0x8000           // Mode
      else
        $uint2(buf+1)=0x4000
      endif
      $uint4(buf+3)=freqset[freqindex[freq]]
      $uint4(buf+7)=0                  // Default voltage
      $uint4(buf+11)=0
      $uint4(buf+15)=0
      $uint4(buf+19)=0
      $uint4(buf+23)=0
      SYS.Sendimm(32,27,buf)
    endif
    // Get old individual corrections from the flash, solely to display them in
    // the table for comparison. (Rather senseless if different frequency).
    for i=0,i<$LAY.nfing*2 && flashvalid==1,i++ do
      for j=0,j<$LAY.nfing*2,j++ do    // Send commands to whole row at once
        $A[j].length=0
        s[0]=S_DEBUG
        s[1]=0x25                      // Get individual parameter
        s[2]=0x80                      // Measurement card
        if extmeas==0 then             // Internal corrections
          $uint2(s+3)=64+fhead[i]*32+fhead[j]
        else if freq==0 then           // External corrections 1
          $uint2(s+3)=1313+fhead[i]*32+fhead[j]
        else                           // External corrections 2
          $uint2(s+3)=2339+fhead[i]*32+fhead[j]
        endif
        SYS.Sendimm(j,5,s)
      enddo
      t=Time()+10000
      while t>Time() do
        for j=0,j<$LAY.nfing*2,j++ do
          if $A[j].length==0 break
        enddo
        if j==$LAY.nfing*2 break
        if Pressed(hexit) return -1    // Operator interrupted test
        wait
      enddo
      for j=0,j<$LAY.nfing*2,j++ do
        if $A[j].length==9 && $A[j].command==S_DEBUG then
          oldflash[i,j]=$float4($A[j]+5)/1000.0
        else
          flashvalid=0
          if extmeas!=0 err=13
        endif
      enddo
    enddo
    // Get old resistance correction for external measurements.
    if flashvalid!=0 && extmeas!=0 then
      $A[0].length=0
      s[0]=S_DEBUG
      s[1]=0x25                        // Get individual parameter
      s[2]=0x80                        // Measurement card
      if freq==0 then
        $uint2(s+3)=1312               // External R correction 1, Ohm
      else
        $uint2(s+3)=2338               // External R correction 2, Ohm
      endif
      SYS.Sendimm(0,5,s)
      t=Time()+10000
      while t>Time() do
        if $A[0].length!=0 break
        wait
      enddo
      if $A[0].length==9 && $A[0].command==S_DEBUG then
        extlr=$float4($A[0]+5)
      else
        extlr=0.0
      endif
    endif
    // Get old shift between the ranges for external measurements.
    if flashvalid!=0 && extmeas!=0 then
      $A[0].length=0
      s[0]=S_DEBUG
      s[1]=0x25                        // Get individual parameter
      s[2]=0x80                        // Measurement card
      if freq==0 then
        $uint2(s+3)=2337               // Interrange L correction 1, nanohenry
      else
        $uint2(s+3)=3363               // Interrange L correction 2, nanohenry
      endif
      SYS.Sendimm(0,5,s)
      t=Time()+10000
      while t>Time() do
        if $A[0].length!=0 break
        wait
      enddo
      if $A[0].length==9 && $A[0].command==S_DEBUG then
        extlrangecorr=$float4($A[0]+5)/1000.0
      else
        extlrangecorr=0.0
      endif
    endif
    // Initialize statistics.
    Initsigma(lmean)
    Initsigma(rmean)
    Initsigma(refmean)
    for i=0,i<3,i++ do
      Initsigma(rphase[i])
      Initsigma(lphase[i])
    enddo
    for i=0,i<$LAY.nfing*2,i++ do
      for j=0,j<$LAY.nfing*2,j++ do
        Initsigma(lpair[i,j])
      enddo
      Initsigma(lrange[0][i])
      Initsigma(lrange[1][i])
    enddo
    Clearoversurface()
    if extmeas==0 then
      change hinfo text="相位矫正"
    else
      change hinfo text=format("Inductance at %i Hz",freqset[freqindex[freq]])
    endif
    change hinfo limits=0,0
    attempt=0
  nextphase:
    attempt++
    // Measure resistors 1 and 10 Ohm (range 0) to correct phase. If one uses
    // dedicated board, I can't calibrate range 2 and will leave this phase
    // unchanged. Combo R/C boad has additional resistor 30 Ohm and range 1
    // calibration is possible. Each loop is repeated twice to increase
    // reliability. Phase corrections are not necessary for external device.
    for m=0,m<6 && err==0 && extmeas==0,m++ do
      if m>=4 && boardtype!=1 continue
      for i=0,i<$LAY.nfing,i++ do      // Calculate new coordinates
        if m==0 || m==1 then
          Convertpad(x+i*2,y+i*2,"R00",i*2,DELTA)
          Convertpad(x+i*2+1,y+i*2+1,"R01",i*2+1,DELTA)
          rexpected=1.0
        else if m==2 || m==3 then
          Convertpad(x+i*2,y+i*2,"1R0",i*2,DELTA)
          Convertpad(x+i*2+1,y+i*2+1,"10R",i*2+1,DELTA)
          rexpected=10.0
        else
          Convertpad(x+i*2,y+i*2,"1R0",i*2,DELTA)
          Convertpad(x+i*2+1,y+i*2+1,"30R",i*2+1,DELTA)
          rexpected=40.0
        endif
        // As this script is used mainly for resistance measurements, it does
        // not correct Y coordinates to allow two different rails to contact
        // the same pad. I correct it here manually.
        if y[i*2]<$LAY.yoffset[i]/1000.0 then
          y[i*2]=y[i*2]+(islargepads?DISTYNEW:DISTYOLD)
        else
          y[i*2]=y[i*2]-(islargepads?DISTYNEW:DISTYOLD)
        endif
        if y[i*2+1]<$LAY.yoffset[i]/1000.0 then
          y[i*2+1]=y[i*2+1]+(islargepads?DISTYNEW:DISTYOLD)
        else
          y[i*2+1]=y[i*2+1]-(islargepads?DISTYNEW:DISTYOLD)
        endif
      enddo
      for i=0,i<$LAY.nfing*2,i++ do    // Move fingers
        sprintf(s,"M %i[%.3f,%.3fA15] NOP",i,x[i],y[i])
        if SERV.Cmdimm(i,s)<0 err=1    // Unable to send command
      enddo
      t=Time()
      while err==0 do                  // Wait till all answers come back
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hcancel) then
          err=5; break
        endif
        for i=0,i<$LAY.nfing*2,i++ do
          if $A[i].length==0 break
        enddo
        if i>=$LAY.nfing*2 break       // All answers came
        if Time()-t>25000 err=1        // Timeout 25 seconds
        wait
      enddo
      // Measure inductivities: each right finger against each left.
      k=0
      for i=0,i<$LAY.nfing*2 && err==0,i=i+2 do
        for j=1,j<$LAY.nfing*2 && err==0,j=j+2 do
          t=$LAY.nfing*$LAY.nfing
          change hinfo limits=t*m+k+1,t*6
          sprintf(s,"M %i[%.3f,%.3fA15P%i] %i[%.3f,%.3fA15P%i] RL(%i,%i)",     \
            i,x[i],y[i],pressure,j,x[j],y[j],pressure,i,j)
          if SERV.Cmdimm(0,s)<0 err=1  // Unable to send command
          if SERV.Cmdimm(1,s)<0 err=1  // Unable to send command
          t=Time()
          while err==0 do              // Wait till all answers come back
            if Pressed(hexit) return -1
            if Pressed(hcancel) then
              err=5; break
            endif
            for n=0,n<2,n++ do
              if $A[n].length==0 break
            enddo
            if n>=2 break              // All answers came
            if Time()-t>10000 err=1    // Timeout 10 seconds
            wait
          enddo
          // Get results of RL measurements.
          for n=0,n<2 && err==0,n++ do
            if $A[n].answer==S_ERROR then
              err=2; break             // RL measurements unsupported?
            else if $A[n].answer!=S_MOVE then
              err=3; break             // Unbelievable, wrong answer
            endif
            if ($A[n].status & 0x4000)!=0 err=11
            r=$float4($A[n]+8); if ($A[n].status & 0x0100) r=r*1.0e-6
            l=$float4($A[n]+12)/1000.0 // Convert to microhenry
            // In my analysis, I use only the differences between the measured
            // inductivities, so Y zero and connection between components are
            // unimportant.
            lcorr=l+(y[i]+y[j])/2.0*LCORR
            rejected=(($A[n].status & 0x8800)!=0 ||                            \
              Abs(r-rexpected)>5.0+rexpected*0.05)
            if rejected==0 then        // Add only good measurements
              Addsigma(rphase[m/2],r)
              Addsigma(lphase[m/2],lcorr)
            endif
          enddo
          k++
        enddo
      enddo
    enddo
    // Check that statistics of measurements is good enough (at least 60% of
    // good measurements).
    if err==0 && extmeas==0 then
      rejected=0
      for i=0,i<(boardtype==1?3:2),i++ do
        if Getcount(lphase[i])<$LAY.nfing*$LAY.nfing*4*0.6 rejected=1
      enddo
      if rejected then
        if attempt>=3 then             // Forget it, no chance
          err=4
        else
          change hinfo text="重试相位"
          goto nextphase
        endif
      endif
    endif
    // Correct phases in extended layout and change version of flash
    // corrections, effectively zeroing them in all subsequent measurements.
    // This must be done only once, on the first frequency. Unfortunately,
    // second phase can't be measured and therefore remains unchanged.
    if err==0 && freq==0 then
      if extmeas==0 then
        xl.lphase1=xl.lphase1+(Getxmean(lphase[1])-Getxmean(lphase[0]))/       \
          (Getxmean(rphase[1])-Getxmean(rphase[0]))
        if boardtype==1 then
          xl.lphase2=xl.lphase2+(Getxmean(lphase[2])-Getxmean(lphase[0]))/     \
            (Getxmean(rphase[2])-Getxmean(rphase[0]))
          ;
        endif
      endif
      while 1 do
        newkey=Random(0x7FFFFFFF)      // MSB is always 0
        if extmeas==0 then
          if newkey!=0 && newkey!=oldkey && newkey!=xl.lcorrversion break
        else
          newkey=(newkey & EXTM_VERSION) | EXTM_RLCORR
          if newkey!=0 && newkey!=oldkey && newkey!=$int4(xl+456) break
        endif
      enddo
      if extmeas==0 then
        xl.lcorrversion=newkey
      else
        $int4(xl+456)=newkey
      endif
      s[0]=0x06                        // S_LOADRUN
      s[1]=15                          // Reload layout extention
      $int4(s+2)=0                     // Dummy operand
      Memcpy(s+6,xl,Sizeof(xl))        // Layout extention
      SYS.Send(6+Sizeof(xl),s,0)
    endif
    // Interrange L correction, only external device HM8118.
    if extmeas!=0 && $uint2($EXTLAY+468)==EXTD_HM8118 &&                       \
      (features & MF_RLINIT)!=0                                                \
    then
      change hinfo text=format("Range shift at %g kHz",                        \
        freqset[freqindex[freq]]/1000.0)
      for range=0,range<2 && err==0, range++ do
        // Set range.
        buf[0]=0x35                    // S_RLINIT
        if range==0 then
          $uint2(buf+1)=0x8010         // Range 1
        else
          $uint2(buf+1)=0x8020         // Range 2
        endif
        $uint4(buf+3)=freqset[freqindex[freq]]
        $uint4(buf+7)=0                // Default voltage
        $uint4(buf+11)=0
        $uint4(buf+15)=0
        $uint4(buf+19)=0
        $uint4(buf+23)=0
        SYS.Sendimm(32,27,buf)
        // Make measurements, same rail only.
        for m=0,m<8 && err==0,m++ do   // Repeat for reliability
          change hinfo limits=range*8+m,16
          for i=0,i<$LAY.nfing,i++ do  // Calculate coordinates and measure
            Convertpad(x+i*2,y+i*2,"R10",i*2,DELTA/4.0)
            x[i*2]=x[i*2]-0.35
            if y[i*2]<$LAY.yoffset[i]/1000.0 then
              y[i*2]=y[i*2]+(islargepads?DISTYNEW:DISTYOLD)
            else
              y[i*2]=y[i*2]-(islargepads?DISTYNEW:DISTYOLD)
            endif
            Convertpad(x+i*2+1,y+i*2+1,"R10",i*2+1,DELTA/4.0)
            x[i*2+1]=x[i*2+1]+0.35
            if y[i*2+1]<$LAY.yoffset[i]/1000.0 then
              y[i*2+1]=y[i*2+1]+(islargepads?DISTYNEW:DISTYOLD)
            else
              y[i*2+1]=y[i*2+1]-(islargepads?DISTYNEW:DISTYOLD)
            endif
            sprintf(s,"M %i[%.3f,%.3fA15P%i] %i[%.3f,%.3fA15P%i] RL(%i,%i)",   \
              i*2,x[i*2],y[i*2],pressure,                                      \
              i*2+1,x[i*2+1],y[i*2+1],pressure,i*2,i*2+1)
            SYS.Killimm(i*2)           // Recover from previous test
            SYS.Killimm(i*2+1)
            SERV.Cmdimm(32,s)          // Dummy measurement
            if SERV.Cmdimm(i*2,s)<0 err=1
            if SERV.Cmdimm(i*2+1,s)<0 err=1
          enddo
          t=Time()
          while err==0 do              // Wait till all answers come back
            if Pressed(hexit) return -1
            if Pressed(hcancel) then
              err=5; break
            endif
            for i=0,i<$LAY.nfing*2,i++ do
              if $A[i].length==0 break
            enddo
            if i>=$LAY.nfing*2 break   // All answers came
            if Time()-t>25000 err=1    // Timeout 25 seconds
            wait
          enddo
          for i=0,i<$LAY.nfing*2,i++ do
            if $A[i].answer!=S_MOVE continue
            status=$A[i].status
            if (status & 0x4000)==0 err=12
            r=$float4($A[i]+8); if (status & 0x0100) r=r*1.0e-6
            l=$float4($A[i]+12)/1000.0 // Convert to microhenry
            rejected=((status & 0x8800)!=0 || r<(-3.0) || r>5.0)
            if rejected==0 then
              Addsigma(lrange[range][i & 0xFE],l)
            endif
          enddo
        enddo
      enddo
      // Process results. I discard rails with too high dispersion of data.
      Initsigma(lmean)
      for i=0,i<$LAY.nfing,i++ do
        if Getsigma(lrange[0][i*2])>LSIGMA || Getsigma(lrange[1][i*2])>LSIGMA  \
          continue                     // Measurements are too unstable
        if Abs(Getxmean(lrange[1][i*2])-Getxmean(lrange[0][i*2]))>LRANGE       \
          continue                     // Difference is too high
        Addsigma(lmean,Getxmean(lrange[1][i*2])-Getxmean(lrange[0][i*2]))
      enddo
      if err!=0 || Getcount(lmean)==0 then
        rangediff=0.0
      else
        rangediff=Getxmean(lmean)
        $A[0].length=0
        s[0]=S_DEBUG
        s[1]=0x26                      // Write individual parameter
        s[2]=0x80                      // Measurement card
        if freq==0 then
          $uint2(s+3)=2337             // Interrange L correction 1, nanohenry
        else
          $uint2(s+3)=3363             // Interrange L correction 2, nanohenry
        endif
        $float4(s+5)=rangediff*1000.0
        SYS.Sendimm(0,9,s)
        t=Time()+5000
        while t>Time() do
          if Pressed(hexit) return -1
          if Pressed(hcancel) then
            err=5; break
          endif
          if $A[0].length!=0 break
          wait
        enddo
      endif
    else
      rangediff=0.0
    endif
    // Shortcut measurements, expected R and L are near zero. To reduce errors,
    // I send left and right fingers to the same pad roughly in the middle of
    // the working area.
    if extmeas==0 then
      change hinfo text="电感值补偿"
    else
      change hinfo text=format("补偿到 %i Hz",freqset[freqindex[freq]])
      buf[0]=0x35                      // S_RLINIT
      $uint2(buf+1)=0x8020             // Range 2
      $uint4(buf+3)=freqset[freqindex[freq]]
      $uint4(buf+7)=0                  // Default voltage
      $uint4(buf+11)=0
      $uint4(buf+15)=0
      $uint4(buf+19)=0
      $uint4(buf+23)=0
      SYS.Sendimm(32,27,buf)
    endif
    change hinfo limits=0,0
    attempt=0
    if extmeas==0 then
      ntest=5                          // 5 loops for reliability
    else
      ntest=2                          // External measurements are slower
    endif
    Initsigma(lmean)
  nextshortcut:
    attempt++
    for m=0,m<ntest && err==0,m++ do
      for i=0,i<$LAY.nfing,i++ do      // Calculate new coordinates
        Convertpad(x+i*2,y+i*2,"R10",i*2,DELTA/4.0)
        x[i*2]=x[i*2]-(islargepads?DISTXNEW:DISTXOLD)
        if y[i*2]<$LAY.yoffset[i]/1000.0 then
          y[i*2]=y[i*2]+(islargepads?DISTYNEW:DISTYOLD)
        else
          y[i*2]=y[i*2]-(islargepads?DISTYNEW:DISTYOLD)
        endif
        Convertpad(x+i*2+1,y+i*2+1,"R10",i*2+1,DELTA/4.0)
        x[i*2+1]=x[i*2+1]+(islargepads?DISTXNEW:DISTXOLD)
        if y[i*2+1]<$LAY.yoffset[i]/1000.0 then
          y[i*2+1]=y[i*2+1]+(islargepads?DISTYNEW:DISTYOLD)
        else
          y[i*2+1]=y[i*2+1]-(islargepads?DISTYNEW:DISTYOLD)
        endif
      enddo
      for i=0,i<$LAY.nfing*2,i++ do    // Move fingers
        SYS.Killimm(i)                 // Recover from previous test
        sprintf(s,"M %i[%.3f,%.3fA15] NOP",i,x[i],y[i])
        if SERV.Cmdimm(i,s)<0 err=1    // Unable to send command
      enddo
      t=Time()
      while err==0 do                  // Wait till all answers come back
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hcancel) then
          err=5; break
        endif
        for i=0,i<$LAY.nfing*2,i++ do
          if $A[i].length==0 break
        enddo
        if i>=$LAY.nfing*2 break       // All answers came
        if Time()-t>25000 err=1        // Timeout 25 seconds
        wait
      enddo
      // Measure inductivities: each finger against each other.
      k=0
      for i=0,i<$LAY.nfing*2-1 && err==0,i++ do
        for j=i+1,j<$LAY.nfing*2 && err==0,j++ do
          t=$LAY.nfing*2
          change hinfo limits=t/2*(t-1)*m+k+1,t/2*(t-1)*ntest
          p=sprintf(s,"M %i[%.3f,%.3fA15P%i] %i[%.3f,%.3fA15P%i] ",            \
            i,x[i],y[i],pressure,j,x[j],y[j],pressure)
          // Note: first resistance, then inductivity to increase stability of
          // the (more important) inductivity measurements.
          sprintf(s+p,"E(%i,%i)",i,j)
          if SERV.Cmdimm(0,s)<0 err=1  // Unable to send command
          sprintf(s+p,"E(%i,%i)",j,i)
          if SERV.Cmdimm(1,s)<0 err=1  // Unable to send command
          sprintf(s+p,"RL(%i,%i)",i,j)
          if SERV.Cmdimm(2,s)<0 err=1  // Unable to send command
          sprintf(s+p,"RL(%i,%i)",j,i)
          if SERV.Cmdimm(3,s)<0 err=1  // Unable to send command
          sprintf(s+p,"RL(%i,%i)",i,j)
          if SERV.Cmdimm(4,s)<0 err=1  // Unable to send command
          sprintf(s+p,"RL(%i,%i)",j,i)
          if SERV.Cmdimm(5,s)<0 err=1  // Unable to send command
          t=Time()
          while err==0 do              // Wait till all answers come back
            if Pressed(hexit) return -1
            if Pressed(hcancel) then
              err=5; break
            endif
            for n=0,n<6,n++ do
              if $A[n].length==0 break
            enddo
            if n>=6 break              // All answers came
            if Time()-t>10000 err=1    // Timeout 10 seconds
            wait
          enddo
          // Get results of RL and reference R measurements.
          for n=0,n<6 && err==0,n++ do
            if $A[n].answer==S_ERROR                                           \
              continue                 // Shit happens
            if $A[n].answer!=S_MOVE then
              err=3; break             // Unbelievable, wrong answer
            endif
            status=$A[n].status
            if n<2 then                // Resistance measurements
              ref=$A[n].r; if (status & 0x0100) ref=ref*1.0e-6
              rejected=((status & 0x8800)!=0 || ref<(-3.0) || ref>5.0)
              if rejected==0 Addsigma(refmean,ref)
            else                       // Inductivity measurements
              if extmeas==0 && (status & 0x4000)!=0 err=11
              if extmeas!=0 && (status & 0x4000)==0 err=12
              r=$float4($A[n]+8); if (status & 0x0100) r=r*1.0e-6
              l=$float4($A[n]+12)/1000.0 // Convert to microhenry
              // Take into account the inductivity of the line on OlliBoard.
              lcorr=l-Abs(y[i]-y[j])*LCORR
              rejected=((status & 0x8800)!=0 || r<(-3.0) || r>5.0)
              if rejected==0 then
                Addsigma(lmean,lcorr)
                Addsigma(lpair[i,j],lcorr)
                Addsigma(lpair[j,i],lcorr)
                Addsigma(rmean,r)
              endif
            endif
          enddo
          k++
        enddo
      enddo
    enddo
    // Move all heads in home positions.
    for i=0,i<$LAY.nfing*2,i++ do
      sprintf(s,"M %i(Z) NOP",i)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()
    while 1 do                         // Wait till all answers come back
      if Pressed(hexit) return -1      // Operator interrupted test
      if Pressed(hcancel) then
        err=5; break
      endif
      for i=0,i<$LAY.nfing*2,i++ do
        if $A[i].length==0 break
      enddo
      if i>=$LAY.nfing*2 break         // All answers came
      if Time()-t>5000 then
        err=1; break                   // Timeout 5 seconds
      endif
      wait
    enddo
    // Check if measurements are valid. I expect that at least 50% of all
    // measurements are good, otherwise we must repeat test (in this case old
    // statistics is not discarded).
    if err==0 then
      rejected=0
      if Getcount(refmean)<$LAY.nfing*($LAY.nfing*2-1)*ntest rejected=1
      if Getcount(lmean)<$LAY.nfing*2*($LAY.nfing*2-1)*ntest rejected=1
      for i=0,i<$LAY.nfing*2-1,i++ do
        for j=i+1,j<$LAY.nfing*2,j++ do
          if Getcount(lpair[i,j])<=ntest*2 rejected=1
        enddo
      enddo
      if rejected then
        if attempt>=3 then             // Forget it, no chance
          err=4
        else
          change hinfo text="重试电感值置零"
          goto nextshortcut
        endif
      endif
    endif
    // Write new data to flash.
    if err==0 && flashvalid then
      if extmeas==0 then
        lcorr=Getxmean(lmean)
      else
        lcorr=0.0
      endif
      for i=0,i<$LAY.nfing*2 && err==0,i++ do
        for j=0,j<$LAY.nfing*2,j++ do  // Send commands to whole row at once
          if i==j then
            newflash[i,j]=0.0          // Measurements with one finger?..
          else                         // Increase reported L by 5.0 nanohenry
            newflash[i,j]=Getxmean(lpair[i,j])-lcorr-0.005
          endif
          $A[j].length=0
          s[0]=S_DEBUG
          s[1]=0x26                    // Write individual parameter
          s[2]=0x80                    // Measurement card
          if extmeas==0 then           // Internal corrections
            $uint2(s+3)=64+fhead[i]*32+fhead[j]
          else if freq==0 then         // External corrections 1
            $uint2(s+3)=1313+fhead[i]*32+fhead[j]
          else                         // External corrections 2
            $uint2(s+3)=2339+fhead[i]*32+fhead[j]
          endif
          $float4(s+5)=newflash[i,j]*1000.0
          SYS.Sendimm(j,9,s)
        enddo
        t=Time()+5000
        while t>Time() do
          if Pressed(hexit) return -1
          if Pressed(hcancel) then
            err=5; break
          endif
          for j=0,j<$LAY.nfing*2,j++ do
            if $A[j].length==0 break
          enddo
          if j==$LAY.nfing*2 break
          wait
        enddo
        for j=0,j<$LAY.nfing*2,j++ do
          if $A[j].length==0 || $A[j].command!=S_DEBUG err=6
        enddo
      enddo
      if err==0 && extmeas!=0 then
        $A[0].length=0
        s[0]=S_DEBUG
        s[1]=0x26                      // Write individual parameter
        s[2]=0x80                      // Measurement card
        if freq==0 then
          $uint2(s+3)=1312             // External R correction 1, Ohm
        else
          $uint2(s+3)=2338             // External R correction 2, Ohm
        endif
        $float4(s+5)=Getxmean(rmean)-Getxmean(refmean)
        SYS.Sendimm(0,9,s)
        t=Time()+5000
        while t>Time() do
          if Pressed(hexit) return -1
          if Pressed(hcancel) then
            err=5; break
          endif
          if $A[0].length!=0 break
          wait
        enddo
      endif
      if err==0 && extmeas!=0 then
        $A[0].length=0
        s[0]=S_DEBUG
        s[1]=0x26                      // Write individual parameter
        s[2]=0x80                      // Measurement card
        if freq==0 then
          $uint2(s+3)=4                // External frequency 1, Hz
        else
          $uint2(s+3)=5                // External frequency 2, Hz
        endif
        $int4(s+5)=freqset[freqindex[freq]]
        SYS.Sendimm(0,9,s)
        t=Time()+5000
        while t>Time() do
          if Pressed(hexit) return -1
          if Pressed(hcancel) then
            err=5; break
          endif
          if $A[0].length!=0 break
          wait
        enddo
      endif
    endif
    // Update layout (first pass only) and log results.
    if err==0 then
      change hlist color=RED
      add hlist text="Adjusted parameter    Old value New value  Units"
      add hlist text=""
      change hlist color=BLACK
      if extmeas==0 then
        lcorr=Getxmean(lmean)
        xl.lzero=xl.lzero+lcorr*1000.0
        xl.lrshift=xl.lrshift+(Getxmean(rmean)-Getxmean(refmean))*1.0e6
        add hlist text=format("%-22.22s%9.3f%10.3f  uH",                       \
          "Residual inductivity",$EXTLAY.lzero/1000.0,xl.lzero/1000.0)
        if boardtype==1 then
          add hlist text=format("%-22.22s%9.4f%10.4f  uH/Ohm",                 \
          "Phase correction x1",$EXTLAY.lphase2,xl.lphase2)
        else
          add hlist text=format("%-22.22s%9.4f   -------  uH/Ohm",             \
          "Phase correction x1",$EXTLAY.lphase2)
        endif
        add hlist text=format("%-22.22s%9.4f%10.4f  uH/Ohm",                   \
          "Phase correction x10",$EXTLAY.lphase1,xl.lphase1)
        add hlist text=format("%-22.22s%9.3f%10.3f  Ohm",                      \
          "Resistance shift",$EXTLAY.lrshift/1.0e6,xl.lrshift/1.0e6)
        add hlist text=""
      else
        add hlist text=format("%-22.22s%9i%10i  Hz",                           \
          "Frequency",oldfreq[freq],freqset[freqindex[freq]])
        add hlist text=format("%-22.22s%9.3f%10.3f  Ohm",                      \
          "Resistance shift",extlr,Getxmean(rmean)-Getxmean(refmean))
        add hlist text=format("%-22.22s%9.3f%10.3f  uH",                       \
          "Range offset",extlrangecorr,rangediff)
        add hlist text=""
      endif
      if extmeas==0 intladjusted=1
      if txtok!=0 then                 // Write results to .TXT protocol
        if extmeas==0 then
          fprintf(hlog,"\n          Calibration of internal resistance/")
          fprintf(hlog,"inductivity measurements\n\n")
        else
          fprintf(hlog,"\n             Calibration of external inductivity ")
          fprintf(hlog,"at F=%i Hz\n\n",freqset[freqindex[freq]])
        endif
        fprintf(hlog," Parameter             Old value  New value     Sigma")
        fprintf(hlog,"  Units\n\n")
        if extmeas==0 then
          fprintf(hlog,                                                        \
            " Residual inductivity   %8.4g   %8.4g   %7.4g  uH\n",             \
            $EXTLAY.lzero/1000.0,xl.lzero/1000.0,Getsigma(lmean))
          if boardtype==1 then
            fprintf(hlog,                                                      \
            " Phase correction x1    %8.4g   %8.4g            uH/Ohm\n",       \
            $EXTLAY.lphase2,xl.lphase2)
          else
            fprintf(hlog,                                                      \
            " Phase correction x1    %8.4g     ------            uH/Ohm\n",    \
            $EXTLAY.lphase2)
          endif
          fprintf(hlog,                                                        \
            " Phase correction x10   %8.4g   %8.4g            uH/Ohm\n",       \
            $EXTLAY.lphase1,xl.lphase1)
          fprintf(hlog,                                                        \
            " Resistance shift       %8.4g   %8.4g            Ohm\n",          \
            $EXTLAY.lrshift/1.0e6,xl.lrshift/1.0e6)
          ;
        else
          fprintf(hlog,                                                        \
            " Frequency              %8i   %8i            Hz\n",               \
            oldfreq[freq],freqset[freqindex[freq]])
          fprintf(hlog,                                                        \
            " Resistance shift       %8.4g   %8.4g            Ohm\n",          \
            extlr,Getxmean(rmean)-Getxmean(refmean))
          fprintf(hlog,                                                        \
            " Range offset           %8.4g   %8.4g            uH\n",           \
            extlrangecorr,rangediff)
          ;
        endif
        fprintf(hlog," Flash key              %08X   %08X\n",oldkey,newkey)
        fprintf(hlog,"\n\n                      Individual inductivity ")
        fprintf(hlog,"corrections\n                        (All values ")
        fprintf(hlog,"are in microhenry)\n\n")
        for n=0,n<$LAY.nfing*2,n=n+8 do
          fprintf(hlog," Head        ")
          for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
            fprintf(hlog,"   %4i%c",i/2,i & 1?'R':'L')
          enddo
          for j=0,j<$LAY.nfing*2,j++ do
            fprintf(hlog,"\n\n %2i%c   New   ",j/2,j & 1?'R':'L')
            for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
              if i==j then
                fprintf(hlog,"     -  ")
              else
                fprintf(hlog," %7.3g",newflash[i,j])
              endif
            enddo
            fprintf(hlog,"\n       Old   ")
            for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
              if i==j then
                fprintf(hlog,"        ")
              else
                fprintf(hlog," %7.3g",oldflash[i,j])
              endif
            enddo
          enddo
          fprintf(hlog,"\n\n")
        enddo
      endif
      Creatertffile()
      if rtfok!=0 then                 // Write results to .RTF protocol
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_BOLD,14)
        RAddtext("\n")
        if extmeas==0 then RAddtext(                                           \
          "Calibration of internal resistance/inductivity measurements")
        else RAddfmt("Calibration of external inductivity at F=%i Hz",         \
          freqset[freqindex[freq]])
        endif
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,35.0); RAddtext("Parameter")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("Old value")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("New value")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0); RFmt(RTF_SYMBOL,RTF_NORMAL,9)
        RAddtext("s"); RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Units")
        if extmeas==0 then
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Residual inductivity")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",$EXTLAY.lzero/1000.0)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9);
          RAddfmt("%.4g",xl.lzero/1000.0)
          RFmt(RTF_TIMES,RTF_NORMAL,9);
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",Getsigma(lmean))
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H")
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Phase correction x1")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",$EXTLAY.lphase2)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9);
          if boardtype==1 then
            RAddfmt("%.4g",xl.lphase2)
          else
            RAddfmt("------")
          endif
          RFmt(RTF_TIMES,RTF_NORMAL,9);
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H/")
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("W")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Phase correction x10")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",$EXTLAY.lphase1)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9);
          RAddfmt("%.4g",xl.lphase1)
          RFmt(RTF_TIMES,RTF_NORMAL,9);
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H/")
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("W")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        else
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Frequency")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%i",oldfreq[freq])
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9)
          RAddfmt("%i",freqset[freqindex[freq]])
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RAddtext("Hz")
        endif
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Resistance shift")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        if extmeas==0 then
          RAddfmt("%.4g",$EXTLAY.lrshift/1.0e6)
        else
          RAddfmt("%.4g",extlr)
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RFmt(RTF_TIMES,RTF_BOLD,9)
        if extmeas==0 then
          RAddfmt("%.4g",xl.lrshift/1.0e6)
        else
          RAddfmt("%.4g",Getxmean(rmean)-Getxmean(refmean))
        endif
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("W")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        if extmeas!=0 then
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Range offset")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",extlrangecorr)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9)
          RAddfmt("%.4g",rangediff)
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H")
        endif
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Flash key")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RAddfmt("%08X",oldkey)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddfmt("%08X",newkey)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        REndtable()
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_BOLD,14)
        RAddtext("\nIndividual inductivity corrections")
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_ITALIC,10)
        RAddtext("(All values are in microhenry)")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        for n=0,n<$LAY.nfing*2,n=n+8 do
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
          RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddtext("Head")
          RCell(RTF_CENTERED|RTF_THINBRD,12.0)
          for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,17.0)
            RAddfmt("%i%c",i/2,i & 1?'R':'L')
          enddo
          for j=0,j<$LAY.nfing*2,j++ do
            RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
            RCell(RTF_CENTERED|RTF_THINBRD,11.0)
            RAddfmt("%i%c",j/2,j & 1?'R':'L')
            RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("New\nOld")
            for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
              if i==j then
                RCell(RTF_CENTERED|RTF_SPACE|RTF_THINBRD,17.0)
                RAddtext("-")
              else
                RCell(RTF_CENTERED|RTF_THINBRD,17.0)
                RAddfmt("%.3g\n%.3g",newflash[i,j],oldflash[i,j])
              endif
            enddo
          enddo
          REndtable()
        enddo
      endif
    endif
  enddo
  // Restore default L measurement mode.
  if (features & MF_RLINIT) then
    buf[0]=0x35                        // S_RLINIT
    $uint2(buf+1)=0x0000               // Default mode
    $uint4(buf+3)=0                    // Default frequency
    $uint4(buf+7)=0                    // Default voltage
    $uint4(buf+11)=0
    $uint4(buf+15)=0
    $uint4(buf+19)=0
    $uint4(buf+23)=0
    SYS.Sendimm(32,27,buf)
  endif
  // Write new key and flash data.
  if err==0 && flashvalid then
    change hinfo text="进行校验..."
    change hinfo limits=0,0
    if extmeas==0 then
      lcorr=Getxmean(lmean)
    else
      lcorr=0.0                        // Flash tables are biased
    endif
    $A[0].length=0
    s[0]=S_DEBUG
    s[1]=0x26                          // Write individual parameter
    s[2]=0x80                          // Measurement card
    if extmeas==0 then
      $uint2(s+3)=0                    // Internal version key
    else
      $uint2(s+3)=3                    // External version key
    endif
    $uint4(s+5)=newkey
    SYS.Sendimm(0,9,s)
    t=Time()+5000
    while t>Time() do
      if Pressed(hexit) return -1
      if Pressed(hcancel) then
        err=5; break
      endif
      if $A[0].length!=0 break
      wait
    enddo
    if $A[0].length==0 || $A[0].command!=S_DEBUG err=6
    if err==0 then
      $A[0].length=0
      s[0]=S_DEBUG
      s[1]=0x27                        // Write parameters from memory to flash
      s[2]=0x80                        // Measurement card
      SYS.Sendimm(0,3,s)
      t=Time()+10000
      while t>Time() do
        if Pressed(hexit) return -1
        if Pressed(hcancel) then
          err=5; break
        endif
        if $A[0].length!=0 break
        wait
      enddo
      if ($A[0].length==0 || $A[0].command!=S_DEBUG || $A[0].subcmd!=0) err=6
    endif
  endif
  if err==0 then
    Flusherrlist()
    Startexplanation(0)
    Explain(0,"Comments to the tables above: To reach maximal accuracy for ")
    Explain(0,"inductivity measurements, especially in low area, calibration ")
    Explain(0,"measures common correction factors and saves them to layout. ")
    if flashvalid then
      Explain(0,"Additionally, for each pair of heads it measures inductivity ")
      Explain(0,"offset and saves it to flash memory on the measurement card. ")
    endif
    Explain(0,"Script takes into account that thin printed lines between ")
    Explain(0,"adjacent pads on the OlliBoard have own inductivity of ")
    Explain(0,"%.3f microhenry.",LCORR*rowdist)
    if (extmeas==0) then
      Explain(0,"\n\nNote that correction of inductance phase on range 1 ")
      Explain(0,"(high inductance and/or resistance) with low R test board ")
      Explain(0,"is not possible. This phase remains unchanged.")
    endif
    Endexplanation()
    Oversurface()
    i=Loadlayoutmeas($LAY,xl,1)
    if i<0 return i
    if i>0 err=7
    if err==0 then
      if txtok then
        fprintf(hlog,"\n\n--------------------------------------------------")
        fprintf(hlog,"---------------------------\n-------------------------")
        fprintf(hlog,"----------------------------------------------------\n")
      endif
      return 0                         // Inductivity calibration finished
    endif
  endif
reporterror:
  change hlist color=LIGHTRED
  add hlist text="校验进程被终止!"
  Startexplanation(0)
  Explain(0,"ATTENTION, L adjustment procedure detected critical error ")
  if err==1 then
    Explain(0,"(timeout or command execution error) ")
  else if err==2 then
    Explain(0,"(command execution error) ")
  else if err==3 then
    Explain(0,"(unexpected answer) ")
  else if err==4 then
    Explain(0,"(wrong measurements) ")
  else if err==6 then
    Explain(0,"unable to flash data) ")
  else if err==7 then
    Explain(0,"(unable to load or save layout) ")
  else if err==11 || err==12 then
    Explain(0,"(invalid measurement device) ")
  else if err==13 then
    Explain(0,"(unable to read flash data) ")
  else if err==14 then
    Explain(0,"(unsupported external measurements) ")
  endif
  Explain(0,"and was unable to finish inductivity calibration.")
  if err!=7 Explain(0," Tester layout on the hard disk was not updated.")
  Endexplanation()
  if txtok then
    fprintf(hlog,"\n\n--------------------------------------------------")
    fprintf(hlog,"---------------------------\n-------------------------")
    fprintf(hlog,"----------------------------------------------------\n")
  endif
  clear hright
  change hinfo text="校验错误"
  change hinfo limits=0,0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    draw text="Command execution error!"
    draw at 6,60 color=BLACK
    draw text="Tester rejected command sent by this routine. Probably it "
    draw text="doesn't understand inductivity measurements. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  else if err==4 then
    draw text="错误的测量值!"
    draw at 6,60 color=BLACK
    draw text="部分测试头测量的电感或电阻要么超"
    draw text="范围"
    draw text="要么非常不稳定。"
  else if err==6 then
    draw text="Error flashing data!"
    draw at 6,60 color=BLACK
    draw text="Measurement card was unable to flash individual corrections. "
  else if err==7 then
    draw text="Unable to save layout!"
    draw at 6,60 color=BLACK
    draw text="Script was unable to write new layout to tester and/or save "
    draw text="it to disk. "
  else if err==11 then
    draw text="无效的测量设备!"
    draw at 6,60 color=BLACK
    draw text="Script makes calibration of internal inductivity measurements "
    draw text="but answer comes from the external measurement device. "
  else if err==12 then
    draw text="无效的测量设备!"
    draw at 6,60 color=BLACK
    draw text="脚本设定外部电感校验,"
    draw text="但响应来自测"
    draw text="量"
    draw text="卡."
    draw text="请检查外部设备是否接入。"
  else if err==13 then
    draw text="Inaccessible flash data!"
    draw at 6,60 color=BLACK
    draw text="Corrections for external inductivity measurements in flash on "
    draw text="the measurement card are not accessible. Probably the version "
    draw text="of embedded software (f_prog.bin) is too old and does not "
    draw text="support external corrections. "
  else if err==14 then
    draw text="Unsupported measurements!"
    draw at 6,60 color=BLACK
    draw text="Embedded software does not support external inductivity "
    draw text="measurements. Please update. "
  endif
  draw text="\n校验进程被终止。"
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="继续"
    help="Press to continue"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 0
    wait
  enddo
end

// Function asks for new stroke and pressure. Returns 0 on success and -1 if
// operator interrupted test.
function int Changestroke()
  int newv,newp,redraw
  char s[512]
  handle hvelo,hvscr,hpres,hpscr,hok,hcancel
  clear hright
  change hinfo limits=0,0
  change hinfo text="设置新的扎针参数"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="轻微后面的所有测试选择Z扎针速度和压力，"
  draw text="然后点击" font=MAINFONT text="确定" font=TIMESFONT text="应用所选"
  draw text="或者点击" font=MAINFONT text="取消"
  draw font=TIMESFONT text="恢复之前的参数。"
  draw at 30,134 font=INFOFONT text="速度"
  hvelo=control TEXT
    window=hright
    position=94,114,45,24
    help="Specify Z down velocity, millimeters per second"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hvscr=control VSCROLL
    window=hright
    position=139,114,20,24
    help="Press to change Z velocity"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 167,134 text="mm/s"
  draw at 30,164 text="压力"
  hpres=control TEXT
    window=hright
    position=94,144,45,24
    help="Specify Z pressure, gramm"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hpscr=control VSCROLL
    window=hright
    position=139,144,20,24
    help="Press to change Z pressure"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 167,164 text="gramm"
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="确定"
    help="Press to confirm your selection"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="取消"
    help="Press to discard changes"
  endc
  draw show
  newv=strokev
  newp=strokep
  redraw=1
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hvscr) then
      newv=newv+Status(hvscr)*10; change hvscr select=0
      redraw=1
    else if Pressed(hpscr) then
      newp=newp+Status(hpscr)*10; change hpscr select=0
      redraw=1
    else if Pressed(hok) then
      strokev=newv
      strokep=newp
      break
    else if Pressed(hcancel) then
      break
    endif
    if redraw then
      newv=Max(10,Min(newv,120))
      newp=Max(10,Min(newp,120))
      change hvelo text=format(" %i",newv)
      if pfactor==1.0 then
        change hpres text=format(" %i",newp)
      else
        change hpres text=format(" %.1f",newp/pfactor)
      endif
      redraw=0
    endif
    wait
  enddo
  return 0
end

// Service function, prints floating point value to the log file so that it
// takes exactly 10 places (among them, at least two spaces).
function int Logvalue10(float value)
  if hlog==NULL return
  if value<0 then
    if value<(-99.9) then
      fprintf(hlog,"%10.3f",value)
    else if value<(-9.99) then
      fprintf(hlog,"%10.4f",value)
    else
      fprintf(hlog,"%10.5f",value)
    endif
  else
    if value>99.9 then
      fprintf(hlog," %9g",value)
    else if value>9.00 then
      fprintf(hlog,"%10.4f",value)
    else
      fprintf(hlog,"%10.5f",value)
    endif
  endif
end

// Estimates needle quality in percent (0 - definitely bad, 100 - definitely
// good) according to the results of measurements. Here p is the pressure in
// internal units (1/10 gramm), noct is the number of no contacts on the
// copper, opens is the number of resistances above 100 Ohm (note that this
// may be due to the opposite head), shorts is the number of shorts between
// the pins on bare FR4, hist is the histogramm and stat is the statistics of
// exact R measurements. Variable shortscu receives estimated number of shorts
// on copper.
function int Headquality(int p,int noct,int bad,                               \
  int opens,int shorts,int *hist,float *stat,int *shortscu)
  int i,j,ngood,nbad
  float q,n,expcu,expfr
  n=Getcount(stat)
  if n<3.0 return 0                     // No statistics as yet?
  q=100.0
  if (p<30) p=30
  // Opens and bad measurements. Every percent of bad measurements reduces
  // quality by 2.5%.
  q=q-(bad+opens)/n*250.0
  // Pin shorts on bare FR4. Number of allowed shorts depends on pressure.
  expfr=Max(0.05,(p-15)/75.0)
  q=q-1.0/expfr*(shorts/n*100.0)
  // Histogramm. 1 step equals by definition to 1/2 of expected dispersion.
  expcu=Max(0.05,(p-15)/30.0)          // Expected part of touches on copper
  j=(Getmean(stat)-rexp[is1mohm][0])/histstep+NHIST/2
  ngood=0; nbad=0
  for i=0,i<NHIST,i++ do
    if i==0 || i==NHIST-1 then
      nbad=nbad+hist[i]
    else if Abs(i-j)>=6 then           // Everything over 3 sigma
      nbad=nbad+hist[i]
    else
      ngood=ngood+hist[i]
    endif
  enddo
  q=q-1.0/expcu*(nbad/n*100)
  shortscu[0]=nbad
  return Max(1,q)
end

// Verifies needles.
function int Verifyneedles(int ntest)
  int i,j,k,q,x,y,dx,t,head,stroke,nrail,nopp,ref,err
  int opp[3],noct[3],bad[3],opens[3],hist[3][NHIST],shortsfr,shortscu
  int qmax,refmax
  float r,xtest,ytest,xopp[3],yopp[3],xnoct,ynoct,xfree
  float stat[3][5]
  char s[512]
  handle hinterrupt,hok
  nrail=$LAY.nfing
  change hinfo limits=0,0
  change hinfo text="四线检查中"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="测试进行中.可点" font=MAINFONT text="终止"
  draw font=TIMESFONT text="来停止当前测试回"
  draw text="到选择菜单，也可点左侧窗口的按钮查看"
  draw text="实时"
  draw text="结果。"
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="终止"
    help="Press to interrupt test"
  endc
  change hleft bkcolor=LIGHTGRAY
  clear hleft
  // Create histogram window.
  hgraph=control GRAPH
    window=hleft
    position=-1,-1,LEFTX+2,GRAPHY
    help="Results of kelvin verification"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  y=GRAPHY+9
  // Create stroke selection buttons.
  dx=(LEFTX-10-4*NSTROKE)/(NSTROKE+1)
  x=(LEFTX-dx*(NSTROKE+1)-4*NSTROKE)/2
  for stroke=0,stroke<NSTROKE,stroke++ do
    hstroke[stroke]=control BUTTON
      window=hleft
      position=x,y,dx,20
      name=format("V=%i, P=%g",vlist[stroke],plist[stroke]/10.0)
      help=format("Press to display statistics for %g g, %i mm/s stroke",      \
        plist[stroke]/10.0,vlist[stroke])
      font=SMALLFONT
    endc
    x=x+dx+4
  enddo
  // Create Summary button.
  hstroke[NSTROKE]=control BUTTON
    window=hleft
    position=x,y,dx,20
    name="汇总"
    help="Show verification results"
    font=SMALLFONT
  endc
  y=y+25
  // Create head selection buttons.
  dx=(LEFTX-10-4*(nrail-1))/nrail
  x=(LEFTX-dx*nrail-4*(nrail-1))/2
  for i=0,i<nrail,i++ do
    for j=0,j<2,j++ do
      hhead[i*2+j]=control BUTTON
        window=hleft
        position=x,y+j*25,dx,20
        name=format("%i%c",i,j==0?'L':'R')
        help=format("Press to display statistics for head %i%c",i,j==0?'L':'R')
        font=SMALLFONT
      endc
    enddo
    x=x+dx+4
  enddo
  selectionmode=1
  // Clear data.
  Memset(fhist,0,Sizeof(fhist))
  for j=0,j<NSTROKE,j++ do
    for i=0,i<32,i++ do
      Initsigma(fstat[j,i])
    enddo
  enddo
  Memset(fbad,0,Sizeof(fbad))
  Memset(fopens,0,Sizeof(fopens))
  Memset(fnoct,0,Sizeof(fnoct))
  Memset(fshortscu,0,Sizeof(fshortscu))
  Memset(fshortsfr,0,Sizeof(fshortsfr))
  Memset(fresult,0,Sizeof(fresult))
  // Prepare for test.
  showhead=-1
  showstroke=-1
  Displayfhist(0,NSTROKE)
  Clearoversurface()
  err=0
  // Main test.
  for head=0,head<nrail*2 && err==0,head++ do
    if used[head]==0 continue
    // We can't make measurements with the single head and need counterpart.
    // But this counterpart itself may be damaged or have bad contact or
    // shortcut between the pins. Therefore I select up to 3 reference heads
    // and make measurements agains all of them. At the end, I take the best
    // result. Opposite heads do not move.
    nopp=0
    for i=0,i<3,i++ do
      if i==0 then
        j=head^1                       // Opposite head is always available
      else if i==1 then
        j=(head>nrail?head-nrail:head+nrail)
      else
        j=(head>nrail?head-nrail:head+nrail)^1
      endif
      if used[j]==0 continue
      opp[nopp]=j
      Convertpad(xopp+nopp,yopp+nopp,"R01",j,0)
      if (j & 1)==0 then
        xopp[nopp]=xopp[nopp]-(islargepads?DISTXNEW:DISTXOLD)
      else
        xopp[nopp]=xopp[nopp]+(islargepads?DISTXNEW:DISTXOLD)
      endif
      if yopp[nopp]<$LAY.yoffset[j/2]/1000.0 then
        yopp[nopp]=yopp[nopp]+(islargepads?DISTYNEW:DISTYOLD)
      else
        yopp[nopp]=yopp[nopp]-(islargepads?DISTYNEW:DISTYOLD)
      endif
      nopp++
    enddo
    // Also calculate no contact coordinates for the opposite finger.
    if (head & 1)==0 then
      Convertpad(&xnoct,&ynoct,"NC2",head^1,0)
    else
      Convertpad(&xnoct,&ynoct,"NC1",head^1,0)
    endif
    // Move all free heads into the defined positions.
    for j=0,j<nrail*2,j++ do
      if j==head continue
      for ref=0,ref<nopp,ref++ do
        if j==opp[ref] break
      enddo
      if ref<nopp continue
      xfree=(j & 1?convdx+80.0:convdx-80.0)
      sprintf(s,"M %i(%g,%gA255) NOP",j,xfree,$LAY.yoffset[j/2]/1000.0)
      SERV.Cmdimm(32,s);
    enddo
    // Make tests for all specified strokes.
    for stroke=0,stroke<NSTROKE && err==0,stroke++ do
      change hinfo limits=head*NSTROKE+stroke,nrail*2*NSTROKE
      Initsigma(stat[0])
      Initsigma(stat[1])
      Initsigma(stat[2])
      Memset(noct,0,Sizeof(noct))
      Memset(bad,0,Sizeof(bad))
      Memset(opens,0,Sizeof(opens))
      Memset(hist,0,Sizeof(hist))
      shortsfr=0
      shortscu=0
      // Make resistance measurements on the copper.
      for i=0,i<ntest && err==0,i++ do
        // Select coordinates for head under test.
        Convertpad(&xtest,&ytest,"R01",head,DELTA)
        if (head & 1)==0 then
          xtest=xtest-(islargepads?DISTXNEW:DISTXOLD)
        else
          xtest=xtest+(islargepads?DISTXNEW:DISTXOLD)
        endif
        if ytest<$LAY.yoffset[head/2]/1000.0 then
          ytest=ytest+(islargepads?DISTYNEW:DISTYOLD)
        else
          ytest=ytest-(islargepads?DISTYNEW:DISTYOLD)
        endif
        // Measure resistance against each reference.
        for ref=0,ref<nopp,ref++ do
          sprintf(s,"M %i[%f,%fA20V%iP%iH%f] %i[%f,%fA20V40P40H%f] E(%i,%i)",  \
            head,xtest,ytest,vlist[stroke],plist[stroke],strokez,              \
            opp[ref],xopp[ref],yopp[ref],strokez,head,opp[ref])
          SERV.Cmdimm(ref,s)
        enddo
        // Wait for answers.
        t=Time()
        while 1 do
          Checkrequest()
          if Pressed(hexit) return -1  // Operator interrupted test
          if Pressed(hinterrupt) then
            err=3; break
          endif
          for ref=0,ref<nopp,ref++ do
            if $A[ref].length==0 break
          enddo
          if ref>=nopp break           // All answers came
          if Time()-t>10000 then
            err=1; break               // Timeout 10 seconds
          endif
          wait
        enddo
        if err break
        // Process answers.
        for ref=0,ref<nopp && err==0,ref++ do
          if $A[ref].answer!=S_MOVE err=2
          if $A[ref].status & 0x0400 continue
          if $A[ref].status & 0x0200 noct[ref]++
          r=$A[ref].r
          if ($A[ref].status & 0x0100) r=r*1.0e-6
          if $A[ref].status & 0x8800 then
            bad[ref]++
          else if r>100.0 then
            opens[ref]++
          else
            Addsigma(stat[ref],r)
            j=(r-rexp[is1mohm][0])/histstep+NHIST/2
            j=Max(0,Min(j,NHIST-1))
            hist[ref][j]++
          endif
        enddo
      enddo
      // Measurements on the copper finished. Make tests on FR4.
      for i=0,i<ntest && err==0,i++ do
        // Select coordinates for head under test.
        if (head & 1)==0 then
          Convertpad(&xtest,&ytest,"NC1",head,DELTA)
        else
          Convertpad(&xtest,&ytest,"NC2",head,DELTA)
        endif
        // Make measurement.
        sprintf(s,"M %i[%f,%fA20V%iP%iH%f] %i[%f,%fA20V40P40H%f] E(%i,%i)",    \
          head,xtest,ytest,vlist[stroke],plist[stroke],strokez,                \
          head^1,xnoct,ynoct,strokez,head,head^1)
        SERV.Cmdimm(0,s)
        // Wait for answer.
        t=Time()
        while 1 do
          Checkrequest()
          if Pressed(hexit) return -1  // Operator interrupted test
          if Pressed(hinterrupt) then
            err=3; break
          endif
          if $A[0].length!=0 break
          if Time()-t>10000 then
            err=1; break               // Timeout 10 seconds
          endif
          wait
        enddo
        if err break
        // Process answer. We are interested only in shorts between the pins.
        if $A[0].answer!=S_MOVE err=2
        if ($A[0].status & 0x0200)==0 shortsfr++
      enddo
      // OK, now select the best set of measurements.
      qmax=-1; refmax=0
      for ref=0,ref<nopp && err==0,ref++ do
        j=Headquality(plist[stroke],                                           \
          noct[ref],bad[ref],opens[ref],shortsfr,hist[ref],stat[ref],&k)
        if j>qmax then
          qmax=j
          refmax=ref
          shortscu=k
        endif
      enddo
      // Copy best set of measurement to statistics.
      Memcpy(fhist[stroke][head],hist[refmax],Sizeof(hist[refmax]))
      Memcpy(fstat[stroke][head],stat[refmax],Sizeof(stat[refmax]))
      fbad[stroke][head]=bad[refmax]
      fopens[stroke][head]=opens[refmax]
      fnoct[stroke][head]=noct[refmax]
      fshortsfr[stroke][head]=shortsfr
      fshortscu[stroke][head]=shortscu
      fquality[stroke][head]=qmax
      Checkrequest()
      Displayfhist(head,stroke)
    enddo
    // Get needle quality.
    j=0
    for stroke=0,stroke<NSTROKE && err==0,stroke++ do
      if fquality[stroke][head]<POORLIM then
        j=1
      else
        q=q+fquality[stroke][head]
        if stroke==0 q=q+fquality[stroke][head]
      endif
    enddo
    if j!=0 then
      fresult[head]=-1                 // At least POORLIM is expected
    else if q/(NSTROKE+1)<GOODLIM then
      fresult[head]=-1
    else
      fresult[head]=1
    endif
  enddo
  // Check for errors.
  if err!=0 then
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==3 then
      draw text="测试被终止."
    else
      draw text="Error detected!"
    endif
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer to the measurement command within the "
      draw text="10-second timeout. "
    else if err==2 then
      draw text="Tester returned unexpected answer to the measured command. "
      draw text="Please check that tester is loaded. "
    endif
    draw text="收集的数据不会写入到根目录文件.\n 点 "
    draw font=MAINFONT text="确定 " font=TIMESFONT text="继续."
    draw show
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="确定"
      help="Press to continue"
    endc
    while 1 do
      Checkrequest()
      if Pressed(hok) return 0
      if Pressed(hexit) return -1
      wait
    enddo
  endif
  Displayfhist(0,NSTROKE)              // Display summary
  if hlog==NULL return 0
  // Protocol data.
  fprintf(hlog,"\n\n                         VERIFICATION OF KELVIN NEEDLES")
  fprintf(hlog,"\n\n        Height%10g mm\n",strokez)
  fprintf(hlog,"         Tests%10i per head\n\n",ntest)
  fprintf(hlog," Head       Stroke    ")
  for i=0,i<NSTROKE,i++ do
    fprintf(hlog," P=%3.1f,V=%2.0f    ",plist[i]/10.0,vlist[i])
  enddo
  fprintf(hlog,"    Result\n\n")
  for head=0,head<nrail*2,head++ do
    if used[head]==0 continue
    // Mean value.
    fprintf(hlog,"%2i%c         Mean R",head/2,head & 1?'R':'L')
    for i=0,i<NSTROKE,i++ do
      fprintf(hlog,"     ")
      Logvalue10(Getmean(fstat[i][head]))
    enddo
    if fresult[head]==0 then
      fprintf(hlog,"           ---\n")
    else if fresult[head]<0 then
      fprintf(hlog,"           BAD\n")
    else
      fprintf(hlog,"          GOOD\n")
    endif
    // Minimal value.
    fprintf(hlog,"           Minimum")
    for i=0,i<NSTROKE,i++ do
      fprintf(hlog,"     ")
      Logvalue10(Getmin(fstat[i][head]))
    enddo
    fprintf(hlog,"\n")
    // Maximal value.
    fprintf(hlog,"           Maximum")
    for i=0,i<NSTROKE,i++ do
      fprintf(hlog,"     ")
      Logvalue10(Getmax(fstat[i][head]))
    enddo
    fprintf(hlog,"\n")
    // Dispersion.
    fprintf(hlog,"             Sigma")
    for i=0,i<NSTROKE,i++ do
      fprintf(hlog,"     ")
      Logvalue10(Getsigma(fstat[i][head]))
    enddo
    fprintf(hlog,"\n")
    // No contacts.
    fprintf(hlog,"           No cont")
    for i=0,i<NSTROKE,i++ do
      fprintf(hlog,"     %10i",fnoct[i][head])
    enddo
    fprintf(hlog,"\n")
    // High R.
    fprintf(hlog,"         R>100 Ohm")
    for i=0,i<NSTROKE,i++ do
      fprintf(hlog,"     %10i",fopens[i][head])
    enddo
    fprintf(hlog,"\n")
    // Pin shorts on copper.
    fprintf(hlog,"         Shorts Cu")
    for i=0,i<NSTROKE,i++ do
      fprintf(hlog,"     %10i",fshortscu[i][head])
    enddo
    fprintf(hlog,"\n")
    // Pin shorts on FR4.
    fprintf(hlog,"        Shorts FR4")
    for i=0,i<NSTROKE,i++ do
      fprintf(hlog,"     %10i",fshortsfr[i][head])
    enddo
    fprintf(hlog,"\n")
    // Quality.
    fprintf(hlog,"           Quality")
    for i=0,i<NSTROKE,i++ do
      if fquality[i][head]>=BESTLIM then
        fprintf(hlog,"    %3i%% (BEST)",fquality[i][head])
      else if fquality[i][head]>=GOODLIM then
        fprintf(hlog,"    %3i%% (GOOD)",fquality[i][head])
      else if fquality[i][head]>=POORLIM then
        fprintf(hlog,"    %3i%% (POOR)",fquality[i][head])
      else
        fprintf(hlog,"     %3i%% (BAD)",fquality[i][head])
      endif
    enddo
    fprintf(hlog,"\n\n")
  enddo
  fprintf(hlog,"--------------------------------------")
  fprintf(hlog,"---------------------------------------\n")
  Oversurface()
  return 0
end

// Tests low resistance ohmical measurements.
function int Maketest()
  int i,j,n,t,slot,rail,x,y,btnx,nrail,nusedrail,iskelvin,exactr,testopen
  int ntestsel,ntest,nleft,nright,nopen,nbad,err,testpassed,firstprotall
  int outlim[NTOTAL][17],passed[NTOTAL][17]
  float x1,y1,x2,y2,dx,dy,r,rcorr,rfactor,maxerr
  char s[512],q1[256],q2[256],rmode[64]
  handle hntest,hprotall,hverify,hexact,hstd
  handle hcertify,hadjr,hlint,hlext,hstroke,hfinish,hinterrupt,hok
  handle hduration[4],hdelay,hcurrent,hcustomer,hextra
  char sduration[4][8] = { "默认", "L", "XL", "XXL" }
  int contdelay[13]= { 0, 1, 2, 3, 5, 7, 10, 12, 15, 20, 25, 30, 50 }
  int current[9] = { 0, 30, 50, 70, 90, 150, 270, 500, 800 }
  nrail=$LAY.nfing
  iskelvin=$LAY.probetype & 1
  usesides=usesides & testersides
  ntestsel=1
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="选择项目"
  draw window=hright color=BLACK font=MAINFONT at 20,30
  draw text="每个轨道测试数:"
  draw show
  hntest=control COMBOLIST
    window=hright
    position=140,11,104,200
    help="设定每组规定测量步骤数"
  endc
  add hntest text="20"
  add hntest text="50"
  add hntest text="100"
  add hntest text="200"
  add hntest text="500"
  add hntest text="1000"
  add hntest text="2000"
  add hntest text="5000"
  change hntest select=ntestsel
  hprotall=control CHECKBOX
    window=hright
    position=20,41,RIGHTX-40,20
    name="完成所有测试项目"
    help="Check to write results of every single measurement to the log file"
    font=INFOFONT
    mode=(protall==0?0:M_CHECKED)
  endc
  if hlog==NULL then
    disable hprotall
  endif
  y=70
  hverify=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="检查各针头"
    help="Press to verify that needles allow reliable Kelvin measurements"
  endc
  if iskelvin==0 disable hverify
  y=y+33
  hexact=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="测量精准电阻值"
    help="点击测量精准电阻值（慢速）"
  endc
  y=y+26
  hstd=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="测量标准电阻值"
    help="点击测量标准电阻值（快速）"
  endc
  y=y+26
  hcertify=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="核实精准电阻值"
    help="点击开始核准低阻测量值"
  endc
  y=y+33
  hadjr=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="调整各针头阻值"
    help="点击校验针头内部阻值"
    bkcolor=PINK
  endc
  if iskelvin!=0 disable hadjr
  y=y+26
  hlint=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="校验内部电感值"
    help="点击使用测量卡校验内部电感值"
    bkcolor=PINK
  endc
  if is1mohm disable hlint
  y=y+26
  hlext=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="校验外部电感值"
    help="Press to calibrate inductance measurements with external device"
    bkcolor=PINK
  endc
  if is1mohm disable hlext
  y=y+33
  hstroke=control BUTTON
    window=hright
    position=20,y,RIGHTX-40,22
    name="设置扎针参数"
    help="点击设置Z扎针参数"
  endc
  hfinish=control BUTTON
    window=hright
    position=20,303,RIGHTX-40,22
    name="完成"
    help="点击结束低阻测试"
  endc
  while 1 do
    if Pressed(hverify) then
      histstep=ESIGMA/2.0              // Exact Kelvin only
      ntestsel=Status(hntest)
      Text(hntest,s); ntest=50; sscanf(s,"%i",&ntest)
      i=Verifyneedles(ntest)
      if i<0 return -1                 // Operator interrupted test
      goto repeat
    else if Pressed(hprotall) then
      protall=Status(hprotall)
    else if Pressed(hexact) then
      change hinfo text="Exact resistance test"
      if iskelvin then
        histstep=0.00025
      else
        histstep=0.01
      endif
      exactr=1; break
    else if Pressed(hstd) then
      change hinfo text="Standard resistance test"
      if iskelvin then
        histstep=0.001
      else
        histstep=0.02;
      endif
      exactr=0; break
    else if Pressed(hcertify) then
      change hinfo text="精准电阻核实"
      if iskelvin then
        histstep=0.00025
      else
        histstep=0.01
      endif
      exactr=2; break
    else if hadjr!=NULL && Pressed(hadjr) then
      i=Adjustneedleresist()
      if i<0 return -1                 // Operator interrupted test
      Drawboard()
      goto repeat
    else if Pressed(hlint) then
      i=Adjustinductivity(0)
      if i<0 return -1                 // Operator interrupted test
      Drawboard()
      goto repeat
    else if Pressed(hlext) then
      i=Adjustinductivity(1)
      if i<0 return -1                 // Operator interrupted test
      Drawboard()
      goto repeat
    else if Pressed(hstroke) then
      i=Changestroke()
      if i<0 return -1                 // Operator interrupted test
      sprintf(s,"STROKE %i,%i,%g",strokev,strokep,strokez)
      SERV.Cmdimm(32,s)                // Set default stroke
      goto repeat
    else if Pressed(hfinish) then
      return 0
    else if Pressed(hexit) then
      return -1
    endif
    Checkrequest()
    wait
  enddo
  // Ask for measurement options.
  if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||          \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8) && exactr!=2                       \
  then
    change hinfo text="设置测试选项"
    clear hright
    draw window=hright font=MAINFONT mode=M_LEFT color=BLACK
    draw at 6,20 text="测试持续时间:"
    for i=0,i<4,i++ do
      hduration[i]=control RADIO
        window=hright
        position=40,23+23*i,80,21
        text=sduration[i]
        help=format("Set duration of measurements to %s",sduration[i])
        mode=(i==duration?M_CHECKED:0)
      endc
    enddo
    draw at 6,133 text="接触延时:"
    hdelay=control COMBOLIST
      window=hright
      position=40,139,100,350
      help="Delay after contact, ms"
      mode=M_VSCROLL
    endc
    add hdelay text="无"
    for i=1,i<13,i++ do
      add hdelay text=format("%i ms",contdelay[i])
    enddo
    change hdelay select=contactdelay
    draw at 6,183 text="测试电流:"
    hcurrent=control COMBOLIST
      window=hright
      position=40,189,100,350
      help="Test current, mA"
      mode=M_VSCROLL
    endc
    add hcurrent text="默认"
    for i=1,i<9,i++ do
      if current[i]>maxcurrent break
      add hcurrent text=format("%i mA",current[i])
    enddo
    if testcurrent>i-1 testcurrent=i-1
    change hcurrent select=testcurrent
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY+35,120,24
      name="确定"
      help="Press to continue with the test"
    endc
    draw show
    while 1 do
      if Pressed(hduration[0]) then
        duration=0
      else if Pressed(hduration[1]) then
        duration=1
      else if Pressed(hduration[2]) then
        duration=2
      else if Pressed(hduration[3]) then
        duration=3
      else if Pressed(hdelay) then
        contactdelay=Status(hdelay)
      else if Pressed(hcurrent) then
        testcurrent=Status(hcurrent)
      else if Pressed(hok) then
        break
      else if Pressed(hexit) then
        return -1
      endif
      wait
    enddo
  else
    // Use default options.
    duration=0
    contactdelay=0
    testcurrent=0
  endif
  // Here test starts.
  testopen=(iskelvin && (exactr!=0 || ($EXTLAY.measopt & HCM_NOCTCHK)==0))
  if exactr==2 then
    change hntest select=3             // Certification mode
  endif
  ntestsel=Status(hntest)
  Text(hntest,s); ntest=50; sscanf(s,"%i",&ntest)
  if exactr==2 then
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
    draw text="如果需要添加客户名和附加信息到附件，"
    draw text="请填入下面空格。"
    draw font=INFOFONT color=BLACK at 6,90 text="客户名:"
    hcustomer=control EDIT
      window=hright
      position=12,95,RIGHTX-18,20
      help="Name of the customer"
      limits=0,79
      mode=M_HSCROLL
    endc
    change hcustomer text=customer
    draw font=INFOFONT color=BLACK at 6,140 text="附加信息:"
    hextra=control EDIT
      window=hright
      position=12,145,RIGHTX-18,120
      help="Additional information to appear in the protocol"
      limits=0,509
      mode=M_VSCROLL
    endc
    change hextra text=extra
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY+35,120,24
      name="确定"
      help="Press to continue with the test"
    endc
    draw show
    while 1 do
      if Pressed(hok) break
      if Pressed(hexit) return -1
      wait
    enddo
    Text(hcustomer,customer)
    Text(hextra,extra)
  endif
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="测试进行中,点击" font=MAINFONT text="终止"
  draw font=TIMESFONT text="停止当前测试并回"
  draw text="到选择菜单,使用左侧按钮查看当前结果."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="终止"
    help="Press to interrupt test"
  endc
  change hleft bkcolor=LIGHTGRAY
  clear hleft
  // Create histogram window.
  hgraph=control GRAPH
    window=hleft
    position=-1,-1,LEFTX+2,GRAPHY
    help="Results of low resistance test"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  y=GRAPHY+9
  // Create resistance selection buttons.
  btnx=(LEFTX-10-4*(NTOTAL-1))/NTOTAL
  x=(LEFTX-btnx*NTOTAL-4*(NTOTAL-1))/2
  for slot=0,slot<NTOTAL,slot++ do
    hslot[slot]=control BUTTON
      window=hleft
      position=x,y,btnx,20
      name=meas[is1mohm][slot]+16
      help=format("Press to display statistics for %s",meas[is1mohm][slot]+16)
      font=SMALLFONT
    endc
    x=x+btnx+4
  enddo
  if testopen==0 disable hslot[NSLOT]
  y=y+25
  // Create rail selection buttons.
  btnx=(LEFTX-10-4*(nrail-1))/nrail
  x=(LEFTX-btnx*nrail-4*(nrail-1))/2
  for i=0,i<nrail,i++ do
    hrail[i]=control BUTTON
      window=hleft
      position=x,y,btnx,20
      name=format("%i",i)
      help=format("Press to display statistics for rail %i",i)
      font=SMALLFONT
    endc
    x=x+btnx+4
  enddo
  y=y+25
  hrail[16]=control BUTTON
    window=hleft
    position=LEFTX/2-btnx-3,y,2*btnx+5,20
    name="所有轨道"
    help="Press to display cumulative statistics"
    font=SMALLFONT
  endc
  selectionmode=0
  // Clear data.
  Memset(rhist,0,Sizeof(rhist))
  for j=0,j<NTOTAL,j++ do
    for i=0,i<17,i++ do
      Initsigma(rstat[j,i])
    enddo
  enddo
  Memset(rbad,0,Sizeof(rbad))
  Memset(ropens,0,Sizeof(ropens))
  Memset(rnoct1,0,Sizeof(rnoct1))
  Memset(rnoct2,0,Sizeof(rnoct2))
  // Prepare for test.
  showslot=-1
  showrail=-1
  Displayrhist(16,0)
  Clearoversurface()
  err=0
  for slot=0,slot<NTOTAL,slot++ do
    for rail=0,rail<=16,rail++ do
      outlim[slot][rail]=0
      passed[slot][rail]=1
    enddo
  enddo
  if err==0 && exactr==2 then
    Creatertffile()
  endif
  // Main test.
  for slot=0,slot<NTOTAL && err==0,slot++ do
    if iskelvin then
      maxerr=KABSERR+rexp[is1mohm][slot]*KRELERR
    else
      maxerr=EABSERR+rexp[is1mohm][slot]*ERELERR
    endif
    if testopen==0 && slot==NSLOT continue
    Displayrhist(showrail,slot)
    firstprotall=1
    // Fast synchronous movements of all heads cause shuttle vibrations and bad
    // measurements. Move heads and wait.
    for rail=0,rail<nrail,rail++ do
      Memcpy(s,meas[is1mohm][slot],3); s[3]='\0';
      Convertpad(&x1,&y1,s,rail*2,0.0)
      if y1<$LAY.yoffset[rail]/1000.0 then
        y1=y1+(islargepads?DISTYNEW:DISTYOLD)
      else
        y1=y1-(islargepads?DISTYNEW:DISTYOLD)
      endif
      Memcpy(s,meas[is1mohm][slot]+4,3); s[3]='\0';
      Convertpad(&x2,&y2,s,rail*2+1,0.0)
      if y2<$LAY.yoffset[rail]/1000.0 then
        y2=y2+(islargepads?DISTYNEW:DISTYOLD)
      else
        y2=y2-(islargepads?DISTYNEW:DISTYOLD)
      endif
      // Correct if same pad.
      if Memicmp(meas[is1mohm][slot],meas[is1mohm][slot]+4,3)==0 then
        x1=x1-(islargepads?DISTXNEW:DISTXOLD)
        x2=x2+(islargepads?DISTXNEW:DISTXOLD)
      endif
      // Send two commands.
      sprintf(s,"M %i[%f,%fA20V%iP%iH%f] %i[%f,%fA20V%iP%iH%f] NOP",           \
        rail*2,x1,y1,strokev,strokep,strokez,                                  \
        rail*2+1,x2,y2,strokev,strokep,strokez)
      SERV.Cmdimm(rail*2,s)
    enddo
    // Wait 1.5 seconds.
    t=Time()
    while Time()-t<1500 do
      Checkrequest()
      if Pressed(hexit) return -1      // Operator interrupted test
      if Pressed(hinterrupt) then
        err=3; break
      endif
      wait
    enddo
    n=0
    rmode[0]='\0'; n=0
    if duration==1 then
      n=n+sprintf(rmode+n,",LONG")
    else if duration==2 then
      n=n+sprintf(rmode+n,",两倍长")
    else if duration==3 then
      n=n+sprintf(rmode+n,",四倍长")
    endif
    if contactdelay>0 then
      n=n+sprintf(rmode+n,",DLY=%i",contdelay[contactdelay])
    endif
    if testcurrent>0 then
      n=n+sprintf(rmode+n,",IMAX=%g",current[testcurrent]/1000.0)
    endif
    for n=0,n<ntest && err==0,n=n+2 do // For the number of tests
      // Send commands.
      for rail=0,rail<nrail,rail++ do  // For all rails
        if used[rail*2]==0 continue
        dx=Random(DELTA)+Random(DELTA)-DELTA
        dy=Random(DELTA)+Random(DELTA)-DELTA
        // Calculate X-Y pad coordinates.
        Memcpy(s,meas[is1mohm][slot],3); s[3]='\0';
        Convertpad(&x1,&y1,s,rail*2,0.0)
        x1=x1+dx; y1=y1+dy
        if y1<$LAY.yoffset[rail]/1000.0 then
          y1=y1+(islargepads?DISTYNEW:DISTYOLD)
        else
          y1=y1-(islargepads?DISTYNEW:DISTYOLD)
        endif
        Memcpy(s,meas[is1mohm][slot]+4,3); s[3]='\0';
        Convertpad(&x2,&y2,s,rail*2+1,0.0)
        x2=x2+dx; y2=y2+dy
        if y2<$LAY.yoffset[rail]/1000.0 then
          y2=y2+(islargepads?DISTYNEW:DISTYOLD)
        else
          y2=y2-(islargepads?DISTYNEW:DISTYOLD)
        endif
        // Correct if same pad.
        if Memicmp(meas[is1mohm][slot],meas[is1mohm][slot]+4,3)==0 then
          x1=x1-(islargepads?DISTXNEW:DISTXOLD)
          x2=x2+(islargepads?DISTXNEW:DISTXOLD)
        endif
        // Send two commands.
        sprintf(s,"M %i[%f,%fA20V%iP%iH%f] %i[%f,%fA20V%iP%iH%f] %s(%i,%i%s)", \
          rail*2,x1,y1,strokev,strokep,strokez,                                \
          rail*2+1,x2,y2,strokev,strokep,strokez,                              \
          (exactr?"E":"R"),rail*2,rail*2+1,rmode)
        SERV.Cmdimm(rail*2,s)
        sprintf(s,"M %i[%f,%fA20V%iP%iH%f] %i[%f,%fA20V%iP%iH%f] %s(%i,%i%s)", \
          rail*2,x1,y1,strokev,strokep,strokez,                                \
          rail*2+1,x2,y2,strokev,strokep,strokez,                              \
          (exactr?"E":"R"),rail*2+1,rail*2,rmode)
        SERV.Cmdimm(rail*2+1,s)
      enddo
      // Wait for answers.
      t=Time()
      while 1 do
        Checkrequest()
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hinterrupt) then
          err=3; break
        endif
        for rail=0,rail<nrail,rail++ do
          if used[rail*2]==0 continue
          if $A[rail*2].length==0 break
          if $A[rail*2+1].length==0 break
        enddo
        if rail>=nrail break           // All answers came
        if Time()-t>10000 then
          err=1; break                 // Timeout 10 seconds
        endif
        wait
      enddo
      if err break
      // Process answers.
      for i=0,i<nrail*2,i++ do
        if used[i]==0 continue
        rail=i/2
        if $A[i].answer!=S_MOVE err=2
        r=$A[i].r
        if ($A[i].status & 0x0100) r=r*1.0e-6
        // If different test lines, correct resistance for twice the resistance
        // of the 155/250-mm line.
        rcorr=0.0
        if Memicmp(meas[is1mohm][slot],meas[is1mohm][slot]+4,3)!=0 then
          if boardtype==2 then
            if r<=100.0 then
              if Abs(ypos[i]-375.0)<187.5 then
                rfactor=0.50           // Half the line
              else
                rfactor=1.25           // One and half line, geometrically less
              endif
              Memcpy(s,meas[is1mohm][slot],3); s[3]='\0';
              rcorr=rline*Getlinefactor(s)*rfactor
              Memcpy(s,meas[is1mohm][slot]+4,3); s[3]='\0';
              rcorr=rcorr+rline*Getlinefactor(s)*rfactor
            endif
          else
            if r<=100.0 && (ypos[i]<10.0 || ypos[i]>300.0) then
              Memcpy(s,meas[is1mohm][slot],3); s[3]='\0';
              rcorr=rline*Getlinefactor(s)
              Memcpy(s,meas[is1mohm][slot]+4,3); s[3]='\0';
              rcorr=rcorr+rline*Getlinefactor(s)
            endif
          endif
        endif
        // Protocol answers on retest.
        if protall!=0 && hlog!=NULL then
          if firstprotall then
            fprintf(hlog,"\nRail\tRaw value, Ohms\tCorrected, Ohms\tStatus\n")
            firstprotall=0
          endif
          Ohmstotext(r,$A[i].status & 0xFEFF,q1)
          Ohmstotext(r-rcorr,$A[i].status & 0xFEFF,q2)
          fprintf(hlog,"%i\t%15s\t%15s\t0x%04X\n",i/2,q1,q2,$A[i].status)
        endif
        // Correct resistance.
        r=r-rcorr
        if $A[i].status & 0x0400 then
          if (i & 1)==0 then
            rnoct1[slot][rail]++
            rnoct1[slot][16]++
          else
            rnoct2[slot][rail]++
            rnoct2[slot][16]++
          endif
        endif
        if $A[i].status & 0x0200 then
          if (i & 1)==0 then
            rnoct2[slot][rail]++
            rnoct2[slot][16]++
          else
            rnoct1[slot][rail]++
            rnoct1[slot][16]++
          endif
        endif
        if $A[i].status & 0x8800 then
          rbad[slot][rail]++
          rbad[slot][16]++
        else if r>100.0 then
          ropens[slot][rail]++
          ropens[slot][16]++
        else
          // More or less good measurement. Note that for Exact R, nocontact
          // automatically means bad measurement.
          Addsigma(rstat[slot][rail],r)
          Addsigma(rstat[slot][16],r)
          j=(r-rexp[is1mohm][slot])/histstep+NHIST/2
          j=Max(0,Min(j,NHIST-1))
          rhist[slot][rail][j]++
          rhist[slot][16][j]++
          if Abs(r-rexp[is1mohm][slot])>maxerr then
            outlim[slot][rail]++
            outlim[slot][16]++
          endif
        endif
      enddo
      Checkrequest()
      Displayrhist(showrail,showslot)
    enddo
  enddo
  // Check for errors.
  if err!=0 then
    clear hright
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED
    if err==3 then
      draw text="测试被终止."
    else
      draw text="Error detected!"
    endif
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer to the measurement command within the "
      draw text="10-second timeout. "
    else if err==2 then
      draw text="Tester returned unexpected answer to the measured command. "
      draw text="Please check that tester is loaded. "
    endif
    draw text="收集的数据不会写入到根目录文件.\n 点 "
    draw font=MAINFONT text="确定 " font=TIMESFONT text="继续."
    draw show
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="确定"
      help="Press to continue"
    endc
    while 1 do
      Checkrequest()
      if Pressed(hok) goto repeat
      if Pressed(hexit) return -1
      wait
    enddo
  endif
  // Check quality of measurements.
  testpassed=1
  nusedrail=0
  Initerrlist()
  for rail=0,rail<nrail && err==0,rail++ do
    if used[rail*2]==0 continue
    nusedrail++
    for slot=0,slot<NSLOT,slot++ do
      if outlim[slot][rail]>MAXRERR then
        if iskelvin then
          maxerr=KABSERR+rexp[is1mohm][slot]*KRELERR
        else
          maxerr=EABSERR+rexp[is1mohm][slot]*ERELERR
        endif
        Adderr(rail,"Resistance out of limits (range %i, %.5f..%.5f Ohm)",     \
          slot+1,rexp[is1mohm][slot]-maxerr,rexp[is1mohm][slot]+maxerr)
        passed[slot][rail]=0
        passed[slot][16]=0
        testpassed=0
      endif
      if rbad[slot][rail]>MAXBAD then
        passed[slot][rail]=0
        passed[slot][16]=0
        testpassed=0
      endif
      if rnoct1[slot][rail]>MAXNOCT || rnoct2[slot][rail]>MAXNOCT then
        if rnoct1[slot][rail]>MAXNOCT then
          Adderr(rail,"More than %i no contacts on copper, left head",MAXNOCT)
        endif
        if rnoct2[slot][rail]>MAXNOCT then
          Adderr(rail,"More than %i no contacts on copper, right head",MAXNOCT)
        endif
        passed[slot][rail]=0
        passed[slot][16]=0
        testpassed=0
      endif
      if ropens[slot][rail]>MAXOPEN then
        Adderr(rail,"More than %i opens (R > 100 Ohm)",MAXOPEN)
        passed[slot][rail]=0
        passed[slot][16]=0
        testpassed=0
      endif
      if rbad[slot][rail]>MAXBAD then
        Adderr(rail,"More than %i bad measurements on range %i (%.5f Ohm)",    \
          MAXBAD,slot+1,rexp[is1mohm][slot])
        passed[slot][16]=0
        testpassed=0
      endif
    enddo
    if testopen!=0 && (ntest-rnoct1[NSLOT][rail]>MAXSHORT ||                   \
      ntest-rnoct2[NSLOT][rail]>MAXSHORT)                                      \
    then
      if ntest-rnoct1[NSLOT][rail]>MAXSHORT then
        Adderr(rail,"More than %i needle shortcuts on solder mask, left head", \
        MAXSHORT)
      endif
      if ntest-rnoct2[NSLOT][rail]>MAXSHORT then
        Adderr(rail,"More than %i needle shortcuts on solder mask, right head",\
        MAXSHORT)
      endif
      passed[NSLOT][rail]=0
      passed[NSLOT][16]=0
      testpassed=0
    endif
  enddo
  // Protocol data.
  if customer[0]!='\0' || extra[0]!='\0' then
    Startexplanation(1)
    if customer[0]!='\0' then
      Explain(1,"Customer:\n")
      Explain(0,"%s\n",customer)
      if extra[0]!='\0' Explain(0,"\n")
    endif
    if extra[0]!='\0' then
      Explain(1,"Additional information:\n")
      Explain(0,"%s\n",extra)
    endif
    Endexplanation()
  endif
  if err==0 && hlog!=NULL then
    // Text protocol.
    if exactr==0 then fprintf(hlog,                                            \
      "\n\n                        ORDINARY RESISTANCE MEASUREMENTS")
    else if exactr==1 then fprintf(hlog,                                       \
      "\n\n                        ACCURATE RESISTANCE MEASUREMENTS")
    else fprintf(hlog,                                                         \
      "\n\n                       ACCURATE RESISTANCE CERTIFICATION")
    endif
    fprintf(hlog,"\n\n         Speed%10g mm/s\n",strokev)
    fprintf(hlog,"      Pressure%10g gramm\n",strokep/pfactor)
    fprintf(hlog,"        Height%10g mm\n",strokez)
    fprintf(hlog,"         Tests%10i per rail\n",ntest)
    fprintf(hlog,"\n              ")
    for slot=0,slot<NSLOT,slot++ do
      fprintf(hlog,"%10.10s",meas[is1mohm][slot]+16)
    enddo
    fprintf(hlog,"  Open  Total\n")
    fprintf(hlog," Rail    R exp")
    for slot=0,slot<NSLOT,slot++ do
      Logvalue10(rexp[is1mohm][slot])
    enddo
    fprintf(hlog,"\n\n")
    for rail=0,rail<=16,rail++ do
      if rail!=16 && used[rail*2]==0 continue
      // Mean values.
      if rail==16 then
        fprintf(hlog,"\n All      Mean")
      else
        fprintf(hlog," %i        Mean",rail)
      endif
      for slot=0,slot<NSLOT,slot++ do
        Logvalue10(Getmean(rstat[slot][rail]))
      enddo
      fprintf(hlog,"\n")
      // Minimal value.
      fprintf(hlog,"       Minimum")
      for slot=0,slot<NSLOT,slot++ do
        Logvalue10(Getmin(rstat[slot][rail]))
      enddo
      fprintf(hlog,"\n")
      // Maximal value.
      fprintf(hlog,"       Maximum")
      for slot=0,slot<NSLOT,slot++ do
        Logvalue10(Getmax(rstat[slot][rail]))
      enddo
      fprintf(hlog,"\n")
      // Dispersion.
      fprintf(hlog,"         Sigma")
      for slot=0,slot<NSLOT,slot++ do
        Logvalue10(Getsigma(rstat[slot][rail]))
      enddo
      fprintf(hlog,"\n")
      // No contacts.
      if rail==16 then
        fprintf(hlog,"          Noct")
        nleft=0
        for slot=0,slot<NSLOT,slot++ do
          fprintf(hlog,"%10i",rnoct1[slot][rail]+rnoct2[slot][rail])
          nleft=nleft+rnoct1[slot][rail]+rnoct2[slot][rail]
        enddo
        if testopen!=0 then
          n=0
          for i=0,i<16,i++ do
            if used[i*2]==0 continue
            n=n+2*ntest
          enddo
          fprintf(hlog,"%6i",n-rnoct1[NSLOT][rail]-rnoct2[NSLOT][rail])
        else
          fprintf(hlog,"      ")
        endif
        fprintf(hlog,"%7i\n",nleft)
      else
        fprintf(hlog,"        Noct L")
        nleft=0
        for slot=0,slot<NSLOT,slot++ do
          fprintf(hlog,"%10i",rnoct1[slot][rail])
          nleft=nleft+rnoct1[slot][rail]
        enddo
        if testopen!=0 then
          fprintf(hlog,"%6i",ntest-rnoct1[NSLOT][rail])
        else
          fprintf(hlog,"      ")
        endif
        fprintf(hlog,"%7i\n",nleft)
        fprintf(hlog,"        Noct R")
        nright=0
        for slot=0,slot<NSLOT,slot++ do
          fprintf(hlog,"%10i",rnoct2[slot][rail])
          nright=nright+rnoct2[slot][rail]
        enddo
        if testopen!=0 then
          fprintf(hlog,"%6i",ntest-rnoct2[NSLOT][rail])
        else
          fprintf(hlog,"      ")
        endif
        fprintf(hlog,"%7i\n",nright)
      endif
      // Opens.
      fprintf(hlog,"         Opens")
      nopen=0
      for slot=0,slot<NSLOT,slot++ do
        nopen=nopen+ropens[slot][rail]
        fprintf(hlog,"%10i",ropens[slot][rail])
      enddo
      fprintf(hlog,"      %7i\n",nopen)
      // Bad measurements.
      fprintf(hlog,"           Bad")
      nbad=0
      for slot=0,slot<NSLOT,slot++ do
        nbad=nbad+rbad[slot][rail]
        fprintf(hlog,"%10i",rbad[slot][rail])
      enddo
      fprintf(hlog,"      %7i\n\n",nbad)
    enddo
    fprintf(hlog,"--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
    Oversurface()
  endif
  if err==0 && rtfok && exactr==2 then
    // RTF protocol.
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddtext("\nAccurate resistance certification")
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RAddtext("\nTest parameters")
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,24.0); RAddtext("Speed")
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,24.0); RAddfmt("%g mm/s",strokev)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,24.0); RAddtext("Pressure")
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,24.0)
    RAddfmt("%g gramm",strokep/pfactor)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,24.0); RAddtext("Height")
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,24.0); RAddfmt("%g mm",strokez)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,24.0); RAddtext("Tests per rail")
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,24.0); RAddfmt("%i",ntest)
    REndtable()
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RAddtext("\nTest results")
    // Table header.
    RFmt(RTF_TIMES,RTF_BOLD,9)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,6.5)
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,15.0); RAddtext("Rail")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RCell(RTF_RIGHT|RTF_SPACE|RTF_THINBRD,20.0); RAddtext("Resistor")
    RFmt(RTF_TIMES,RTF_BOLD,9)
    for slot=0,slot<NSLOT,slot++ do
      RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,20.0);
      RAddtext(meas[is1mohm][slot]+16)
    enddo
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,15.0); RAddtext("Open")
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,15.0); RAddtext("Total")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    // Calibrated resistances.
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,5.5)
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,15.0)
    RCell(RTF_RIGHT|RTF_SPACE|RTF_THINBRD,20.0); RAddtext("Rexp")
    for slot=0,slot<NSLOT,slot++ do
      RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,20.0);
      RAddfmt("%.6f",rexp[is1mohm][slot])
    enddo
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,15.0)
    RCell(RTF_LEFT|RTF_SPACE|RTF_THINBRD,15.0)
    // Rails and summary.
    for rail=0,rail<=16,rail++ do
      if rail!=16 && used[rail*2]==0 continue
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
      RCell(RTF_LEFT|RTF_THINBRD,15.0)
      if rail==16 then
        RAddtext("All")
      else
        RAddfmt("%i",rail)
      endif
      RCell(RTF_RIGHT|RTF_THINBRD,20.0)
      if rail==16 then
        RAddtext("Mean\nMinimum\nMaximum\nSigma\nNoCt\nOpens\nBad")
      else
        RAddtext("Mean\nMinimum\nMaximum\nSigma\nNoCtL\nNoCtR\nOpens\nBad")
      endif
      for slot=0,slot<NSLOT,slot++ do
        RCell(RTF_LEFT|RTF_THINBRD,20.0);
        if passed[slot][rail] then
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        else
          RFmt(RTF_TIMES,RTF_BOLD,9)
        endif
        RAddfmt("%.6g\n",Getmean(rstat[slot][rail]))
        RAddfmt("%.6g\n",Getmin(rstat[slot][rail]))
        RAddfmt("%.6g\n",Getmax(rstat[slot][rail]))
        RAddfmt("%.6g\n",Getsigma(rstat[slot][rail]))
        if rail==16 then
          RAddfmt("%i\n",rnoct1[slot][rail]+rnoct2[slot][rail])
        else
          RAddfmt("%i\n",rnoct1[slot][rail])
          RAddfmt("%i\n",rnoct2[slot][rail])
        endif
        RAddfmt("%i\n",ropens[slot][rail])
        RAddfmt("%i",rbad[slot][rail])
      enddo
      if testopen==0 || rail==16 || passed[NSLOT][rail]!=0 then
        RFmt(RTF_TIMES,RTF_NORMAL,9)
      else
        RFmt(RTF_TIMES,RTF_BOLD,9)
      endif
      RCell(RTF_LEFT|RTF_THINBRD,15.0)
      RAddtext("\n\n\n\n")
      if testopen==0 then
        RAddtext("-\n")
      else if rail==16 then
        n=0
        for i=0,i<16,i++ do
          if used[i*2]==0 continue
          n=n+2*ntest
        enddo
        RAddfmt("%i\n",n-rnoct1[NSLOT][rail]-rnoct2[NSLOT][rail])
      else
        RAddfmt("%i\n",ntest-rnoct1[NSLOT][rail])
        RAddfmt("%i\n",ntest-rnoct2[NSLOT][rail])
      endif
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RCell(RTF_LEFT|RTF_THINBRD,15.0)
      RAddtext("\n\n\n\n")
      if rail==16 then
        nleft=0
        for slot=0,slot<NSLOT,slot++ do
          nleft=nleft+rnoct1[slot][rail]+rnoct2[slot][rail]
        enddo
        RAddfmt("%i\n",nleft)
      else
        nleft=0
        nright=0
        for slot=0,slot<NSLOT,slot++ do
          nleft=nleft+rnoct1[slot][rail]
          nright=nright+rnoct2[slot][rail]
        enddo
        RAddfmt("%i\n",nleft)
        RAddfmt("%i\n",nright)
      endif
      nopen=0
      nbad=0
      for slot=0,slot<NSLOT,slot++ do
        nopen=nopen+ropens[slot][rail]
        nbad=nbad+rbad[slot][rail]
      enddo
      RAddfmt("%i\n",nopen)
      RAddfmt("%i",nbad)
    enddo
    REndtable()
  endif
  if err==0 && exactr==2 then
    Flusherrlist()
    Startexplanation(0)
    Explain(0,"Comments to the table above: Each of %i different ",NSLOT)
    Explain(0,"resistors ")
    if testopen!=0 then
      Explain(0,"and 1 full open (fingers contacting solder mask) ")
    endif
    Explain(0,"is checked %i times by each rail, giving grand total of ",ntest)
    Explain(0,"%i ",(testopen==0?NSLOT:NSLOT+1)*ntest*nusedrail)
    Explain(0,"measurements. ")
    if exactr==2 then
      Explain(0,"Test is passed when:\n")
      Explain(0,"(a) Number of out-of-range measurements per resistor and ")
      Explain(0,"rail does not exceed %i out of %i. ",MAXRERR,ntest)
      Explain(0,"Measurement is out of range if deviation fron the expected ")
      Explain(0,"resistance exceeds %.4f Ohm + ",(iskelvin?KABSERR:EABSERR))
      Explain(0,"%.0f percent of expected ",(iskelvin?KRELERR:ERELERR)*100)
      Explain(0,"resistance;\n")
      Explain(0,"(b) Number of no contacts per head and resistor does not ")
      Explain(0,"exceed %i out of %i;\n",MAXNOCT,ntest)
      Explain(0,"(c) Number of bad measurements per resistor does not ")
      Explain(0,"exceed %i out of %i",MAXBAD,ntest*nusedrail)
      if testopen then
        Explain(0,";\n(d) Number of shorts between the pins of the Kelvin ")
        Explain(0,"needle on the solder mask per head does not exceed ")
        Explain(0,"%i out of %i",MAXSHORT,ntest)
      endif
      Explain(0,".\n")
    endif
    Endexplanation()
  endif
  // Certification conists of single test. Print summary.
  if err==0 && txtok && exactr==2 then
    fprintf(hlog,"\n\n              C E R T I F I C A T I O N     ")
    if testpassed then
      fprintf(hlog,"        P A S S E D\n")
    else
      fprintf(hlog,"N O T   P A S S E D\n")
    endif
    fprintf(hlog,"\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  if err==0 && rtfok && exactr==2 then
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    if testpassed then
      RAddtext("C E R T I F I C A T I O N     P A S S E D\n")
    else
      RAddtext("C E R T I F I C A T I O N     N O T   P A S S E D\n")
    endif
    RFmt(RTF_TIMES,RTF_CENTERED,9)
    RAddtext("\n------------------------------------------------------------")
    RAddtext("--------------------------------------------------------------")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
  endif
  if err==0 && exactr==2 then
    clear hright
    change hinfo limits=0,0
    if testpassed then
      change hinfo text="Certification passed"
      Addcalibrationrecord("Low resistance measurements certified")
    else
      change hinfo text="核实进程未通过"
    endif
    draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
    if testpassed then
      draw text="Certification finished successfully."
    else
      draw text="核实进程已完成。检测到 "
      draw text="相关错误。\n请查阅附属文件" font=INFOFONT
      draw text="lowrtest.txt" font=TIMESFONT text="和" font=INFOFONT
      draw text="lowrtest.rtf" font=TIMESFONT text="."
    endif
    draw show
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="确定"
      help="Press to continue"
    endc
    while 1 do
      Checkrequest()
      if Pressed(hok) goto repeat
      if Pressed(hexit) return -1
      wait
    enddo
  endif
  goto repeat
end

// Unloads board from the shuttle. Used in the case of L&M automation. Returns
// -1 if user interrupted the script and 0 in any other case.
function int UnloadboardLM()
  int i,j,t
  char buf[256],errtxt[256]
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO                                    \
    return 0                           // Does not apply
  // Check whether there is a board in the shuttle. It may happen that previous
  // test was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  Drawboard()
  // Make soft reset before sending commands to automation directly: heads may
  // still move!
  clear hright
  change hinfo limits=0,0
  change hinfo text="软件复位"
  SYS.Softimm(32)
  t=Time(); i=0
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("Waiting for Soft reset - %i s",j)
      i=j
    endif
    if j>15 return 0                   // Too long soft reset
    wait
  enddo
  change hinfo limits=0,0
  change hinfo text="Unloading board..."
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Low resistance test board will be unloaded from the shuttle. To "
  draw text="avoid damages, please remove it from the band."
  draw show
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO &&           \
    pulledshuttle>=0                                                           \
  then
    sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i 2",pulledshuttle)
    i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
    if i<0 return -1
    pulledshuttle=-1
  endif
  // For the case that tester is in the adjustment mode.
  i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,5)
  if i<0 return -1
  SYS.Killimm(32)
  buf[0]=S_LOCKDOOR
  buf[1]=0                             // Unlock door
  SYS.Sendimm(32,2,buf)
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  return 0
end

// Warns user about unloading board from the shuttle. Used in the case of EPCOS
// tester. Returns -1 if user interrupted the script and 0 in any other case.
function int UnloadboardEPCOS()
  handle hok
  if ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO then
    return 0                           // Does not apply
  endif
  change hinfo limits=0,0
  change hinfo text="Please remove holder!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please don't forget to remove low resistance test board and its "
  draw text="holder from the shuttle. " color=LIGHTRED text="Attempt to "
  draw text="unlock table when holder is installed may seriously damage the "
  draw text="tester!"
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="确定"
    help="Press to continue"
  endc
  while 1 do
    if Pressed(hexit) return -1        // Interrupt
    if Pressed(hok) break
    wait
  enddo
  return 0
end

// Main routine.
function int main()
  int i,j
  hmain=control WINDOW
    window=NULL
    position=10,10,MAINX,MAINY
    name=format("精准电阻测试进程 v%s",VERSION)
    help=" "
    size=128
  endc
  hleft=control CHILD
    window=hmain
    position=5,5,LEFTX,LEFTY
    help=" "
    color=DARKGRAY
    size=8192
  endc
  hserv=control CHILD
    window=hmain
    position=SPLIT,5,RIGHTX,SERVY
    help=" "
    color=DARKGRAY
  endc
  hright=control CHILD
    window=hmain
    position=SPLIT,10+SERVY,RIGHTX,RIGHTY
    help=" "
    color=DARKGRAY
    size=1024
  endc
  hinfo=control PROGRESS
    window=hserv
    position=-1,-1,RIGHTX+2,SERVY+2
    text="欢迎使用!"
    help="Current state of R measurement verification"
    mode=M_PERCENT
    font=MEDIUMFONT
    limits=0,0
  endc
  hexit=control BUTTON
    window=hmain
    position=MAINX-84,MAINY-SERVY,80,SERVY-3
    name="关闭"
    help="双击终止测试并关闭窗口"
    mode=M_DBLCLICK
  endc
  draw window=hmain bitmap=0,0,1,"bkground" show
  duration=0
  contactdelay=0
  testcurrent=0.0
  layoutchanged=0
  loadchanged=0
  globalerr=0
  pulledshuttle=-1
  intladjusted=0
  linewidth=0.300
  individualbc=1                       // Individual brightness and contrast
  illtype=0x07                         // Top illumunation
  updatefocus[0]=1                     // Focus is not yet set
  updatefocus[1]=1
  Bcgetini()                           // Read brightness & contrast from .ini
  // If this script is called directly from the Test Player, default parameters
  // may be yet uninitialized.
  if $GLOBAL.defstroke==0 then
    $GLOBAL.defstroke=40
    $GLOBAL.defpressure=30
    $GLOBAL.defheight=5000
    $GLOBAL.defaccuracy=250
  endif
  Clearoversurface()                   // Clear contact-over-surface counters
  change hleft help="Copyright (C) 2007-2014 atg test systems GmbH"
  draw window=hleft
  draw at 70,40 bitmap=0,0,0,"logo"
  draw color=DARKGRAY font=MEDIUMFONT mode=M_CENTERED
  draw at LEFTX/2,285 text="低阻校验程序"
  draw at LEFTX/2,305 text=format("版本 %s",VERSION)
  draw at LEFTX/2,335 text="(包含电感校验程序)"
  draw show
  delay 1500
  islargepads=1                        // Defaults
  boardtype=0
  is1mohm=0
  getini("LowRtest","Board type","%i,%i,%i",&islargepads,&boardtype,&is1mohm)
  if boardtype==1 islargepads=1
reload:
  if Loadtester()!=0 goto quit         // Make sure that tester is loaded
  if Embedded()!=0 then
    SERV.Cmdimm(32,"$LIGHTS TESTING")  // Update state of traffic lights
  endif
  globalerr=globalerr & (~GE_BOOT)     // Tester is just loaded
  i=Checkgloberrors()                  // Check for errors except boot errors
  if i<0 goto quit                     // Operator interrupted the test
  if i>0 goto reload                   // Try to reload tester
  i=Getlayout()                        // Get actually loaded layout
  if i<0 goto quit                     // Operator interrupted the test
  if i>0 goto reload                   // Try to reload tester
  Getautomationtype()                  // Get type of automation
  Recognizetester()                    // Determine type of the tester
  if testertype==TT_WRONG goto quit    // Don't know how to test
  Getfeatures()                        // Get features of measurement card
  if testertype==TT_A7 && testersides==0x03 && $LAY.nfing>=6 then
    boardtype=2                        // Only A7 XXL board suits
    Memcpy(xname,xnamex,Sizeof(xname))
    linewidth=0.200
    rowdist=250.0                      // Distance between rows of pads
  else
    i=Selectboard()                    // Select board type
    if i<0 goto quit                   // Operator interrupted the test
    if boardtype==0 then
      Memcpy(xname,xnamed,Sizeof(xname))
    else
      Memcpy(xname,xnamec,Sizeof(xname))
    endif
    rowdist=155.0                      // Distance between rows of pads
  endif
  for i=0,i<NPOINT,i++ do              // Extract pad coordinates and values
    sscanf(xname[i]+7,"%f %f %f",xpos+i,value+i,linefactor+i)
    for j=0,j<7,j++ do
      if xname[i][j]==' ' break
    enddo
    xname[i][j]='\0'                   // Limit pad names
  enddo
  i=Correctresistors()                 // Adjust expected resistances
  if i<0 goto quit                     // Operator interrupted the test
  Createlogfile()                      // Create log file and print header
  Drawboard()
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8 then
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,1")
  endif
  i=Setmode()                          // Set handicaps
  if i<0 goto quit                     // Operator interrupted the test
  Setcrosses()                         // Choose crosses used for scanning
reinstall:
  scanrail=-1
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    i=InstallboardLM()                 // Install board in L&M shuttle
  else if testertype==TT_S2 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO &&       \
    (automationtype==AUTO_S2LMSEMI || automationtype==AUTO_S2LMFULL) then
    i=InstallboardLM()                 // Install board in S2 shuttle
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    i=InstallboardLM()                 // Install board in split shuttle
  else if testertype==TT_A8 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO &&       \
    (automationtype==AUTO_A8LMMAN || automationtype==AUTO_A8LMSEMI ||          \
    automationtype==AUTO_A8LMFULL) then
    i=InstallboardLM()                 // Install board in A8a shuttle
  else if (testertype==TT_A7 || testertype==TT_A8) &&                          \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    i=InstallboardLM()                 // Install OlliBoard in split shuttle
  else if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    i=InstallboardEPCOS()              // Install board in EPCOS shuttle
  else if ((testertype==TT_A4 || testertype==TT_A6 || testertype==TT_S1) &&    \
    ($LAY.config & 0x0001C040)==0x00008040) then
    i=Installboard(1)                  // Install board on A4/A6 auto
  else
    i=Installboard(0)                  // Install board on other tester
  endif
  if i>0 goto reload                   // Bad or no answer, try to reload tester
  if i<0 goto quit                     // Operator interrupted the test
  i=Positionboard()                    // Manually find position of the board
  if i==2 goto reinstall               // Board position must be changed
  if i<0 goto quit                     // Operator interrupted the test
  i=Scanboard(i)                       // Find exact board position
  if i==1 goto reinstall               // Crosses not found, retry
  if i==2 goto quit                    // Operator stopped the test
  if i<0 goto quit                     // Operator interrupted the test
recheck:
  i=Electrocheck()                     // Check board presence electrically
  if i==1 goto reinstall               // Board position must be changed
  if i==2 goto recheck                 // Repeat electrical presence check
  if i<0 goto quit                     // Operator interrupted the test
  Drawboard()
  i=Correctlines()                     // Adjust resistances of 155/250-mm lines
  if i<0 goto quit                     // Operator interrupted the test
  Maketest()                           // Make hardware test
quit:
  Bcsetini()                           // Save brightness & contrast to .ini
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S1 then
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,0")
  endif
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                   \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO)                                   \
  then
    UnloadboardLM()                    // Unload board if L&M or split shuttle
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    UnloadboardLM()                    // Unload board if S3 split shuttle
  endif
  if Embedded()!=0 then
    SERV.Cmdimm(32,"$LIGHTS WAITING")  // Update state of traffic lights
  endif
  Closelogfiles()
  if (testertype!=TT_A5L && testertype!=TT_A7) ||                              \
    ($LAY.config & LC_LDMASK)!=LC_LMAUTO then
    SYS.Softreset(0)
  endif
  if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    destroy hexit                      // Psychology...
    hexit=NULL
    UnloadboardEPCOS()                 // Ask to remove board if EPCOS shuttle
  endif
end

