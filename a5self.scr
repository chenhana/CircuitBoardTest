#include "ls.icl"
#include "or.icl"
#cmdbuff 36
#zeroid                                // Process answers with zero command ID

#define VERSION        ""
#define DESCRIPTION    "Self-test of A5/A6 measurement card"

// 1.01: Full multiplexer test.
// 1.02: Corrected access to data and numeration of heads in full test mode.
// 1.03: Added two new parameters.
// 1.04: Added HV leakage limits.
// 1.05: Removed parameters added in v1.03.
// 1.06: Added external antennas.
// 1.07: Support for Kelvin probes.
// 1.08: Full HV multiplexer test, connectors.
// 1.09: Check for connection between U/I and PLUS buses.
// 1.10: HV source voltage limit reduced from 285 to 270 volts.
// 1.11: Reswitching speed of relays on the measurement card.
// 1.12: Time used to wait for fast and slow relays.
// 1.13: Support for extended HVINIT (with head test time).
// 1.14: Multiplexer window.
// 1.15: Burn-in test of multiplexer relays.
// 1.16: Option to save relay data in Excel-compatible format.
// 1.17: Speed of temperature sensor relays.
// 1.18: Measurement card window, all settings saved to .ini.
// 1.19: Option to turn HV source ON during the R/C tests.
// 1.20: MSD initialization.
// 1.21: Better distinguishing between 1 mA and 10 mA HV.
// 1.22: LATEST initialization.
// 1.23: Supports K107 (LATEST, DAC to GND).
// 1.24: Allowed minimal fast times changed from 170/200 to 140/160 us.
// 1.25: LATEST in separate range, LATEST parameters adjusted.
// 1.26: Balancing of LATEST current source.
// 1.27: Allowed repeatability changed from 70/100 to 70/150 us.
// 1.28: On-head leakage measurements.
// 1.29: Linearity for low current source.
// 1.30: MSD boards with current sensing.
// 1.31: Supports LATEST highpass filter.
// 1.32: Indicates optional relays as not connected (not 100% correct analysis).
// 1.33: Support for 500 V (250 const + 250 var) CRT.
// 1.34: Leakage is removed.
// 1.35: Support for dual (master/slave) measurement card.
// 1.36: Support for new measurement card (BEL307-5).
// 1.37: Doubled max relay times if acceleration is turned off.
// 1.38: LATEST window.
// 1.39: Common mode amplification of ADC filter.
// 1.40: Forced initialization if minimal time between inits is set in layout.
// 1.41: Support for 300 mA current adjustment.
// 1.42: Voltage on the output of limited high I source at -75 mA.
// 1.43: 500 V support starts at 256 V because new software sets CRTMAX higher.
// 1.44: 1000 V max test voltage if HV1000 is specified in layout.
// 1.45: Better support for bipolar CRT.
// 1.46: Option to add serial number to protocol.
// 1.47: Support for modular multiplexer.
// 1.48: Shortcuts on the free extra outputs of modular multiplexer.
// 1.49: Better support for dual measurement card.
// 1.50: Support for CRT500.
// 1.51: Small corrections for LATEST.
// 1.52: HV parameters adjusted.
// 1.53: Supports K101, K103 and K105 times. Note: times are in extrastat[]!
// 1.54: Support for modular LATEST multiplexer.
// 1.55: Extended accuracy of ADC filter balance.

#define DX             500             // Visible width of test result window
#define DY             490             // Height of test result window
#define SPLIT          270             // Split between hmux and hmuxdata

#define MUXX0          8               // Offset of multiplexer image
#define MUXY0          10
#define MUXSCALE       1.45

// X positions in table, pixels.
#define IX0            5               // Position of parameter
#define IX1            200             // Position of measured value
#define IX2            310             // Position of measured deviation
#define IX3            370             // Position of units
#define IX4            405             // Position of expected value
#define IX5            (DX-3)          // End of table
// X positions in text file, characters.
#define FX0            0               // Position of parameter
#define FX1            30              // Position of measured value
#define FX2            55              // No measured deviation in file
#define FX3            55              // Position of units
#define FX4            62              // Position of expected value
#define FX5            80              // End of table
// X positions in multiplexer, pixels.
#define MX0            20              // Position of parameter
#define MX1            200             // Position of measured value
#define MX3            295             // Position of units
#define MX4            350             // Position of expected value
#define MX5            430             // Position of message

#define NCHAR          80

#define TOFFS          0               // Offset for type and offset in main
#define MMOFFS         4               // Offset for special modifiers in main
#define NOMOFFS        7               // Offset for nominal value in main
#define DIFOFFS        15              // Offset for allowed difference in main
#define UOFFS          23              // Offset for units in main
#define TEXTOFFS       26              // Offset for explanation in main

#define TOMUX          0               // Offset for type and offset in mux
#define MMOMUX         4               // Offset for special modifiers in mux
#define GMINMUX        6               // Offset for lower good limit in mux
#define GMAXMUX        11              // Offset for upper good limit in mux
#define YMINMUX        16              // Offset for lower warn limit in mux
#define YMAXMUX        21              // Offset for upper warn limit in mux
#define DMINMUX        26              // Offset for good max-min difference
#define DMAXMUX        31              // Offset for yellow max-min difference
#define LIMITMUX       36              // Offset for displayed limit in mux
#define UOMUX          41              // Offset for units in mux
#define TEXTOMUX       43              // Offset for explanation in mux

#define HCM_HV1MA      0x00000001      // Force 1 mA during HV measurements
#define HCM_STRICT     0x00000002      // 20% stricter self-test
#define HCM_NOCTCHK    0x00000004      // Don't check contacts (except ExactR)
#define HCM_PARCONT    0x00000008      // Check influence of parallel contacting
#define HCM_NOACCEL    0x00000010      // Do not accelerate reed relays
#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements
#define HCM_CTOEXT     0x00000040      // Calibrate capacity to shuttle (extant)
#define HCM_ISOEANT    0x00000080      // External antennas isolated
#define HCM_FILTMASK   0x00000F00      // Mask to extract signal filtering
#define   HCM_FNONE    0x00000000      // No signal filtering
#define   HCM_F500K    0x00000100      // 500 kHz filter
#define   HCM_F100K    0x00000200      // 100 kHz filter
#define   HCM_F20K     0x00000300      // 20/50 kHz filter
#define HCM_FILTERC    0x00001000      // Filter C measurements over 300 pF
#define HCM_EXRLONG    0x00002000      // Long EXACTR with 300 mA source
#define HCM_HVTYPE     0x000F0000      // Mask to extract type of HV elecronics
#define   HCM_HV500    0x00000000      // Card is capable of 500 V HV
#define   HCM_HV1000   0x00010000      // Card is capable of 1000 V HV
#define   HCM_HVAUTO   0x00070000      // Autodetect HV capabilities

// Type and layout of multiplexer.
#define MUX_TYPEMASK   0xF0000000      // Mask to extract type of multiplexer
#define   MUX_TYPE406  0x00000000      // EL406 (16 outputs)
#define   MUX_TYPE506  0x10000000      // EL506 (modular)
#define MUX_MODCOUNT   0x0F000000      // Mask to extract number of modules
#define MUX_EXTERN5    0x00038000      // Mask for Card2:Ext2, MUXEXT_xxx
#define MUX_EXTERN4    0x00007000      // Mask for Card2:Ext1, MUXEXT_xxx
#define MUX_EXTERN3    0x00000E00      // Mask for Card1:Ext2, MUXEXT_xxx
#define MUX_EXTERN2    0x000001C0      // Mask for Card1:Ext1, MUXEXT_xxx
#define MUX_EXTERN1    0x00000038      // Mask for Card0:Ext2, MUXEXT_xxx
#define MUX_EXTERN0    0x00000007      // Mask for Card0:Ext1, MUXEXT_xxx

#define MUXEXT_NONE    0               // External output is unassigned
#define MUXEXT_TSENS   1               // External output is temperature sensor
#define MUXEXT_ANT1    2               // External output is antenna 1
#define MUXEXT_ANT2    3               // External output is antenna 2
#define MUXEXT_EXTDEV  4               // External output is external device
#define MUXEXT_SHORT   5               // External output is shortcut

typedef struct t_layout $LAY;          // Create compatible layout types
typedef struct t_extlay $EXTLAY;

typedef struct t_relay                 // Relay/head extract
  int            module                // Multiplexer module or -1
  int            head                  // User-readable head number or -1
  int            extant                // User-readable external antenna or -1
  int            extraout              // Extended output or -1
  int            connector             // User-readable connector index or -1
  int            tsensor               // Temperature sensor or -1
  int            meascard              // Measurement card or -1
  int            badlevel              // 0:good, 1:warning, 2:error, -1:absent
  int            jindex                // J-index of first BNC connector
  int            dataindex             // Index in headstat or extrastat
  int            measindex             // Index in measstat or -1
  int            extraindex            // Index in extrastat for R or -1
  int            valid                 // Whether relay is tested
ends

struct t_layout  l                     // Local copy of layout
struct t_extlay  lx                    // Local copy of extended layout

handle           hinfo                 // Window that displays test results
handle           hmuxparent            // Scrollable holder for hmux & hmuxdata
handle           hmux                  // Window that displays multiplexer
handle           hmuxscroll            // Scroll for hmux
handle           hmuxdata              // Window that displays mulx data

handle           hburn                 // Burn-in mode
handle           hburni                // Burn-in current
handle           hburnt                // Burn-in duration
handle           hmeas                 // R/C measurements
handle           hhv                   // HV measurements
handle           hcrt                  // CRT measurements
handle           hla                   // LATEST measurements
handle           hvolt                 // HV voltage
handle           hcurr                 // HV current
handle           htime                 // Duration of HV initialization
handle           hiadj                 // Adjust potentiometers on meas card
handle           hlaadj                // Adjust potentiometers on LATEST card
handle           hext                  // Check unused relays (all outputs)
handle           hhvon                 // HV source on during test

handle           hstart                // Start test
handle           hsingle               // Make single measurement
handle           hget                  // Get results of last initialization

int              ydata                 // Actual Y table coordinate

int              features              // Features supported by the crate
int              nmeascard             // Number of measurement cards in system
int              nmodule               // 0: EL406, >0: no. of EL506 modules
int              half                  // Half of multiplexer outputs
int              headmask              // List of outputs in crate format
int              isnewmeas             // Whether new (BEL407-5) card
int              hvtype                // 1000 if HV1000, 500 otherwise
int              ntest                 // Number of tests
float            measstat[2,256,3]     // Min/max from measurement card
float            extrastat[2,256,3]    // Min/max extra from measurement card
float            headstat[2,32,64,3]   // Min/max from fingers
int              burnin                // Perform mux burn-in test
int              iadj                  // DC current adjustment mode
int              laadj                 // LATEST current adjustment mode
int              testmeas              // Perform electronics test
int              testla                // Perform LA test
int              testhv                // Perform HV test
int              testcrt               // Perform MSD test
int              drawmean              // Display mean instead of min/max
int              fulltest              // Test all multiplexer channels
int              dcwithhv              // HV on during R/C test
int              realheads             // List of heads that must be present
char             protname[260]         // Name of ordinary protocol file
char             relayname[260]        // Name of relay protocol file
char             serial[256]           // Serial number of measurement card

int              running               // Test is running
int              runonce               // Single test

int              muxpos                // X offset of hmux window
int              captured              // 1: mouse "captured" in hmux
int              capturex              // Mouse X coordinate when captured
int              capturelast           // last mouse X coordinate
int              capturemux            // muxpos when captured

// In the case of modular multiplexer, head relays are mapped to positions
// 128..367 (80 slots per module).
struct t_relay   rd[368]               // Relay/head-related data

// T:       type of data, C - card, F - head (finger), X - extra output,
//          %- text, E - end
// OOC:     offset; C='+': cosine component in next line
// MM:      special modifiers; NS - no Kelvin probes, SP - Kelvin probes,
//          10 - disabled if 10 mA current, SL - check slow relays in layout,
//          NC - new measurement card (BEL407-5), N2 - new meas card with 20
//          kHz lowest filter, N5 - new meas card with 50 kHz lowest filter,
//          30 - disabled if 300 mA current source is absent, H5 - only HV500,
//          H1 - only HV1000
// Nominal: expected signal value
// Maxdiff: maximal allowed deviation
// U:       units: B-bits, V-volts, S-bit/us, Z-volts/s, T-us, D-ms, Y-yes/no,
//          O-Ohm, Q-kOhm, P-pf, I-mA, A-arbitrary units, G-degrees,
//          R-CRT (MSD) polarity, K-kiloherz, %-percent, +-large font,
//          0..3-large font, specified number of digits after decimal point
// Text:    explanation
//
// TOOCMM Nominal Maxdiff U  Text...
char init[4,NCHAR] = {                                                         \
  "%0",                                                                        \
  "%B     测量卡参数",                      \
  "%N     循环次数: ",                                          \
  "E" }

char burntitle[5,NCHAR] = {                                                    \
  "%B     Burn-in relays test",                                                \
  "%      Note that prolongated burn-in test with high current",               \
  "%      may permanently damage the multiplexer card",                        \
  "+0     Primary (master) measurement card only",                             \
  "E" }

char burnfinger[5,NCHAR] = {                                                   \
  "%F     Head",                                                               \
  "F26    <1.2    <9      O  Max resistance of U/I and MINUS relays",          \
  "F27    <1.2    <9      O  Max resistance of PLUS and GND relays",           \
  "F28 NS 5.5     4.5     O  Max resistance of on-head relay and analog cable",\
  "E" }

char crate[156,NCHAR] = {                                                      \
  "%B     DC 测量",                                                    \
  "%      如果单元格包含2个值",                 \
  "%      第一个是整的，第二个是赋值的DAC设置",                             \
  "%H     -- HV source is turned ON during the test --",                       \
  "+0     Primary (master) measurement card",                                  \
  "D00    32768   100     B  ADC zero at amplification x1",                    \
  "D01    32768   150     B  ADC zero at amplification x10",                   \
  "D02    2.5     0.1     V  +2.5 V reference",                                \
  "D03    5.0     1.0     V  +5 V analog power",                               \
  "D04    -2.5    0.1     V  -2.5 V reference",                                \
  "D05    -5.0    0.2     V  -5 V reference",                                  \
  "D06    -8064   250     B  +DAC preset to -32256 bits",                      \
  "D07    8064    250     B  -DAC preset to -32256 bits",                      \
  "D08    8064    250     B  +DAC preset to +32256 bits",                      \
  "D09    -8064   250     B  -DAC preset to +32256 bits",                      \
  "D10                    B  +DAC preset to zero",                             \
  "D11                    B  -DAC preset to zero",                             \
  "D12    -7.5    0.25    V  DAC 0A (neg I threshold) preset to 2048 bits",    \
  "D13    0.0     0.2     V  DAC 0A (neg I threshold) preset to 4095 bits",    \
  "D14    -7.5    0.25    V  DAC 0B (pos I threshold) preset to 2048 bits",    \
  "D15    0.0     0.2     V  DAC 0B (pos I threshold) preset to 4095 bits",    \
  "D16    0.0     0.1     V  DAC 0C (I limit of U source) preset to 0",        \
  "D17    5.0     0.15    V  DAC 0C (I limit of U source) preset to 4095 bits",\
  "D18    0.0     0.1     V  DAC 0D (U hysteresis) preset to 0",               \
  "D19    -5.0    0.15    V  DAC 0D (U hysteresis) preset to 4095 bits",       \
  "D20    205     200     B  DAC 0C that limits -I to -50 mA",                 \
  "D21    205     200     B  DAC 0C that limits +I to +50 mA",                 \
  "D22    0       512     B  Zero shift of U source",                          \
  "D23    9.0     0.075   V  9 V DC measured on analog bus",                   \
  "D24    0.9     0.045   V  0.9 V DC measured on bus with amplification x10", \
  "D57+   >9.0            V  Voltage between bus and ground at 30 A",        \
  "D58    >9.0",                                                               \
  "D26    0       512     B  Zero shift of low (2.5 mA) I source",             \
  "D27+   3.0     0.5     V  30 A from low I source on 100 K resistor",      \
  "D28    -3.0    0.5",                                                        \
  "D29+   1.0     0.1     V  1 mA from low I source on 1 K resistor",         \
  "D30    -1.0    0.1",                                                        \
  "D31    0       256     B  Zero shift of high (100 mA) I source",            \
  "A13    -4.5    1.0     V  High I voltage at -75 mA limited to 4.5 V",      \
  "A08+30 65.0    25.0    S  Charging speed from 300 mA I in -6-1 V range",   \
  "A09 30 65.0    25.0",                                                       \
  "A10+30 65.0    25.0    S  Charging speed from 300 mA I in +1+6 V range",   \
  "A11 30 65.0    25.0",                                                       \
  "D32+   75.0    25.0    S  Charging speed from high I in -6-3 V range",     \
  "D33    75.0    25.0",                                                       \
  "D34+   75.0    25.0    S  Charging speed from high I in -1.5+1.5 V range", \
  "D35    75.0    25.0",                                                       \
  "D36+   75.0    25.0    S  Charging speed from high I in +3+6 V range",     \
  "D37    75.0    25.0",                                                       \
  "D46+   90.0    30.0    S  Charging speed from low I in -6-3 V range",      \
  "D47    90.0    30.0",                                                       \
  "D48+   90.0    30.0    S  Charging speed from low I in -1.5+1.5 V range",  \
  "D49    90.0    30.0",                                                       \
  "D50+   90.0    30.0    S  Charging speed from low I in +3+6 V range",      \
  "D51    90.0    30.0",                                                       \
  "D38                    V  +30 mA from high I source on 100 Ohm resistor",   \
  "D39                    Y  Temperature sensor present",                      \
  "D40    0.0     0.1     V  x1 zero of I-U converter",                        \
  "D41    0.0     0.25    V  x10 zero of I-U converter",                       \
  "D42+   5.0     0.5     V  Output of I-U converter at 50 A input current", \
  "D43    -5.0    0.5",                                                        \
  "D52    0.0     20.0    A  Amplitude of 50 Hz at +5 V analog supply",        \
  "D53    0.0     20.0    A  Amplitude of 60 Hz at +5 V analog supply",        \
  "D25                    Y  100 Ohm resistor on output of U source present",  \
  "D59                    Y  Connection K107 between DAC and GND present",     \
  "D54                    Y  Connection K109 between U/I and PLUS present",    \
  "D55    [650    <1000   T  Time to wait for fast relays",                    \
  "D56 SL [4500   <6000   T  Time to wait for slow relays",                    \
  "D60 NC 1.0     0.1        DC amplification factor of ADC filter",           \
  "D61 NC 0.0     1.0     %  Common mode amplification of ADC filter at x10",  \
  "+1     Secondary (slave) measurement card",                                 \
  "D00    32768   100     B  ADC zero at amplification x1",                    \
  "D01    32768   150     B  ADC zero at amplification x10",                   \
  "D02    2.5     0.1     V  +2.5 V reference",                                \
  "D03    5.0     1.0     V  +5 V analog power",                               \
  "D04    -2.5    0.1     V  -2.5 V reference",                                \
  "D05    -5.0    0.2     V  -5 V reference",                                  \
  "D06    -8064   250     B  +DAC preset to -32256 bits",                      \
  "D07    8064    250     B  -DAC preset to -32256 bits",                      \
  "D08    8064    250     B  +DAC preset to +32256 bits",                      \
  "D09    -8064   250     B  -DAC preset to +32256 bits",                      \
  "D10                    B  +DAC preset to zero",                             \
  "D11                    B  -DAC preset to zero",                             \
  "D12    -7.5    0.25    V  DAC 0A (neg I threshold) preset to 2048 bits",    \
  "D13    0.0     0.2     V  DAC 0A (neg I threshold) preset to 4095 bits",    \
  "D14    -7.5    0.25    V  DAC 0B (pos I threshold) preset to 2048 bits",    \
  "D15    0.0     0.2     V  DAC 0B (pos I threshold) preset to 4095 bits",    \
  "D16    0.0     0.1     V  DAC 0C (I limit of U source) preset to 0",        \
  "D17    5.0     0.15    V  DAC 0C (I limit of U source) preset to 4095 bits",\
  "D18    0.0     0.1     V  DAC 0D (U hysteresis) preset to 0",               \
  "D19    -5.0    0.15    V  DAC 0D (U hysteresis) preset to 4095 bits",       \
  "D20    205     200     B  DAC 0C that limits -I to -50 mA",                 \
  "D21    205     200     B  DAC 0C that limits +I to +50 mA",                 \
  "D22    0       512     B  Zero shift of U source",                          \
  "D23    9.0     0.075   V  9 V DC measured on analog bus",                   \
  "D24    0.9     0.045   V  0.9 V DC measured on bus with amplification x10", \
  "D57+   >9.0            V  Voltage between bus and ground at 30 A",        \
  "D58    >9.0",                                                               \
  "D26    0       512     B  Zero shift of low (2.5 mA) I source",             \
  "D27+   3.0     0.5     V  30 A from low I source on 100 K resistor",      \
  "D28    -3.0    0.5",                                                        \
  "D29+   1.0     0.1     V  1 mA from low I source on 1 K resistor",         \
  "D30    -1.0    0.1",                                                        \
  "D31    0       256     B  Zero shift of high (100 mA) I source",            \
  "A13    -4.5    1.0     V  High I voltage at -75 mA limited to 4.5 V",      \
  "A08+30 65.0    25.0    S  Charging speed from 300 mA I in -6-1 V range",   \
  "A09 30 65.0    25.0",                                                       \
  "A10+30 65.0    25.0    S  Charging speed from 300 mA I in +1+6 V range",   \
  "A11 30 65.0    25.0",                                                       \
  "D32+   75.0    25.0    S  Charging speed from high I in -6-3 V range",     \
  "D33    75.0    25.0",                                                       \
  "D34+   75.0    25.0    S  Charging speed from high I in -1.5+1.5 V range", \
  "D35    75.0    25.0",                                                       \
  "D36+   75.0    25.0    S  Charging speed from high I in +3+6 V range",     \
  "D37    75.0    25.0",                                                       \
  "D46+   90.0    30.0    S  Charging speed from low I in -6-3 V range",      \
  "D47    90.0    30.0",                                                       \
  "D48+   90.0    30.0    S  Charging speed from low I in -1.5+1.5 V range",  \
  "D49    90.0    30.0",                                                       \
  "D50+   90.0    30.0    S  Charging speed from low I in +3+6 V range",      \
  "D51    90.0    30.0",                                                       \
  "D38                    V  +30 mA from high I source on 100 Ohm resistor",   \
  "D40    0.0     0.1     V  x1 zero of I-U converter",                        \
  "D41    0.0     0.25    V  x10 zero of I-U converter",                       \
  "D42+   5.0     0.5     V  Output of I-U converter at 50 A input current", \
  "D43    -5.0    0.5",                                                        \
  "D52    0.0     20.0    A  Amplitude of 50 Hz at +5 V analog supply",        \
  "D53    0.0     20.0    A  Amplitude of 60 Hz at +5 V analog supply",        \
  "D25                    Y  100 Ohm resistor on output of U source present",  \
  "D59                    Y  Connection K107 between DAC and GND present",     \
  "D54                    Y  Connection K109 between U/I and PLUS present",    \
  "D55    [650    <1000   T  Time to wait for fast relays",                    \
  "D60 NC 1.0     0.1        DC amplification factor of ADC filter",           \
  "D61 NC 0.0     1.0     %  Common mode amplification of ADC filter at x10",  \
  "+0",                                                                        \
  "%",                                                                         \
  "%B     AC measurements",                                                    \
  "%      First value is sine and second - cosine component",                  \
  "+0     Primary (master) measurement card",                                  \
  "A00+                   B  AC x1 with effective amplitude 1 V",              \
  "A01               ",                                                        \
  "A02+                   B  AC x10 with effective amplitude 0.1 V",           \
  "A03               ",                                                        \
  "A07 NC                 K  Cutoff frequency of the lowest ADC filter",       \
  "A04 NC 2.0     2.0     G  Phase shift of 500 kHz ADC filter at f=16 kHz",   \
  "A05 NC 10.0    4.0     G  Phase shift of 100 kHz ADC filter at f=16 kHz",   \
  "A06 N2 64.0    12.0    G  Phase shift of 20 kHz ADC filter at f=16 kHz",    \
  "A06 N5 32.0    8.0     G  Phase shift of 50 kHz ADC filter at f=16 kHz",    \
  "+1  NC Secondary (slave) measurement card",                                 \
  "A07 NC                 K  Cutoff frequency of the lowest ADC filter",       \
  "A04 NC 2.0     2.0     G  Phase shift of 500 kHz ADC filter at f=16 kHz",   \
  "A05 NC 10.0    4.0     G  Phase shift of 100 kHz ADC filter at f=16 kHz",   \
  "A06 N2 64.0    12.0    G  Phase shift of 20 kHz ADC filter at f=16 kHz",    \
  "A06 N5 32.0    8.0     G  Phase shift of 50 kHz ADC filter at f=16 kHz",    \
  "+0",                                                                        \
  "E" }

char relays[101,NCHAR] = {                                                     \
  "%B     Relays on the measurement card and temperature sensor",              \
  "%      First displayed value is ON, second is OFF time",                    \
  "+0     Primary (master) measurement card",                                  \
  "A24+   [650    <1000   T  Relay connecting temperature sensor to U/I bus",  \
  "A25    [650    <1000",                                                      \
  "A26+   [650    <1000   T  Relay connecting temperature sensor to MINUS bus",\
  "A27    [650    <1000",                                                      \
  "A28+   [650    <1000   T  Relay connecting temperature sensor to PLUS bus", \
  "A29    [650    <1000",                                                      \
  "A30+   [650    <1000   T  Relay connecting temperature sensor to GND bus",  \
  "A31    [650    <1000",                                                      \
  "A58+   [650    <1000   T  K84 (connects U source directly to U/I bus)",     \
  "A59    [650    <1000",                                                      \
  "A48+   [650    <1000   T  K85 (connects I outputs to U/I bus)",             \
  "A49    [650    <1000",                                                      \
  "A56+   [650    <1000   T  K86 (connects I-U converter to PLUS bus)",        \
  "A57    [650    <1000",                                                      \
  "A54+   ?650    <1000   T  K87 (connects I-U converter to MINUS bus)",       \
  "A55    ?650    <1000",                                                      \
  "A32+   [650    <1000   T  K92 (connects U/I bus to ground)",                \
  "A33    [650    <1000",                                                      \
  "A36+   [650    <1000   T  K93 (connects PLUS bus to ground)",               \
  "A37    [650    <1000",                                                      \
  "A34+   [650    <1000   T  K94 (connects MINUS bus to ground)",              \
  "A35    [650    <1000",                                                      \
  "A38+   [650    <1000   T  K95 (connects GND bus to ground)",                \
  "A39    [650    <1000",                                                      \
  "A40+   [650    <1000   T  K96 (connects U/I bus to short/resistors)",       \
  "A41    [650    <1000",                                                      \
  "A44+   [650    <1000   T  K97 (connects PLUS bus to short/resistors)",      \
  "A45    [650    <1000",                                                      \
  "A42+   [650    <1000   T  K98 (connects MINUS bus to short/resistors)",     \
  "A43    [650    <1000",                                                      \
  "A46+   [650    <1000   T  K99 (connects GND bus to short/resistors)",       \
  "A47    [650    <1000",                                                      \
  "X66+   [650    <1000   T  K101 (connects 100 Ohm to short)",                \
  "X67    [650    <1000",                                                      \
  "X68+   [650    <1000   T  K103 (connects 1 kOhm to short)",                 \
  "X69    [650    <1000",                                                      \
  "A60+   [650    <1000   T  K104 (connects U source to U/I via 100 Ohm)",     \
  "A61    [650    <1000",                                                      \
  "X64+   [650    <1000   T  K105 (optional, connects 300 mA to K85)",         \
  "X65    [650    <1000",                                                      \
  "A22+   ?650    <1000   T  K107 (optional, connects DAC to GND bus)",        \
  "A23    ?650    <1000",                                                      \
  "A62+   ?650    <1000   T  K109 (optional, shortcuts U/I bus with PLUS)",    \
  "A63    ?650    <1000",                                                      \
  "A50+   [650    <1000   T  K110 (connects I high to K85)",                   \
  "A51    [650    <1000",                                                      \
  "A52+   [650    <1000   T  K111 (connects I low to K85)",                    \
  "A53    [650    <1000",                                                      \
  "+1     Secondary (slave) measurement card",                                 \
  "A24+   [650    <1000   T  Relay connecting temperature sensor to U/I bus",  \
  "A25    [650    <1000",                                                      \
  "A26+   [650    <1000   T  Relay connecting temperature sensor to MINUS bus",\
  "A27    [650    <1000",                                                      \
  "A28+   [650    <1000   T  Relay connecting temperature sensor to PLUS bus", \
  "A29    [650    <1000",                                                      \
  "A30+   [650    <1000   T  Relay connecting temperature sensor to GND bus",  \
  "A31    [650    <1000",                                                      \
  "A58+   [650    <1000   T  K84 (connects U source directly to U/I bus)",     \
  "A59    [650    <1000",                                                      \
  "A48+   [650    <1000   T  K85 (connects I outputs to U/I bus)",             \
  "A49    [650    <1000",                                                      \
  "A56+   [650    <1000   T  K86 (connects I-U converter to PLUS bus)",        \
  "A57    [650    <1000",                                                      \
  "A54+   ?650    <1000   T  K87 (connects I-U converter to MINUS bus)",       \
  "A55    ?650    <1000",                                                      \
  "A32+   [650    <1000   T  K92 (connects U/I bus to ground)",                \
  "A33    [650    <1000",                                                      \
  "A36+   [650    <1000   T  K93 (connects PLUS bus to ground)",               \
  "A37    [650    <1000",                                                      \
  "A34+   [650    <1000   T  K94 (connects MINUS bus to ground)",              \
  "A35    [650    <1000",                                                      \
  "A38+   [650    <1000   T  K95 (connects GND bus to ground)",                \
  "A39    [650    <1000",                                                      \
  "A40+   [650    <1000   T  K96 (connects U/I bus to short/resistors)",       \
  "A41    [650    <1000",                                                      \
  "A44+   [650    <1000   T  K97 (connects PLUS bus to short/resistors)",      \
  "A45    [650    <1000",                                                      \
  "A42+   [650    <1000   T  K98 (connects MINUS bus to short/resistors)",     \
  "A43    [650    <1000",                                                      \
  "A46+   [650    <1000   T  K99 (connects GND bus to short/resistors)",       \
  "A47    [650    <1000",                                                      \
  "X66+   [650    <1000   T  K101 (connects 100 Ohm to short)",                \
  "X67    [650    <1000",                                                      \
  "X68+   [650    <1000   T  K103 (connects 1 kOhm to short)",                 \
  "X69    [650    <1000",                                                      \
  "A60+   [650    <1000   T  K104 (connects U source to U/I via 100 Ohm)",     \
  "A61    [650    <1000",                                                      \
  "X64+   [650    <1000   T  K105 (optional, connects 300 mA to K85)",         \
  "X65    [650    <1000",                                                      \
  "A22+   ?650    <1000   T  K107 (optional, connects DAC to GND bus)",        \
  "A23    ?650    <1000",                                                      \
  "A62+   ?650    <1000   T  K109 (optional, shortcuts U/I bus with PLUS)",    \
  "A63    ?650    <1000",                                                      \
  "A50+   [650    <1000   T  K110 (connects I high to K85)",                   \
  "A51    [650    <1000",                                                      \
  "A52+   [650    <1000   T  K111 (connects I low to K85)",                    \
  "A53    [650    <1000",                                                      \
  "E" }

char finger[44,NCHAR] = {                                                      \
  "%F     Head",                                                               \
  "+0     Primary (master) measurement card",                                  \
  "F00+   [650    <1000   T  On/Off time of U/I relay",                        \
  "F01    [650    <1000",                                                      \
  "F02+   [650    <1000   T  On/Off time of MINUS relay",                      \
  "F03    [650    <1000",                                                      \
  "F04+   [650    <1000   T  On/Off time of PLUS relay",                       \
  "F05    [650    <1000",                                                      \
  "F06+   [650    <1000   T  On/Off time of GND relay",                        \
  "F07    [650    <1000",                                                      \
  "F12+SL [3500   <6000   T  On/Off time of on-head relay",                    \
  "F13 SL [3500   <6000",                                                      \
  "F08    <1.2    <9      O  On resistance of U/I and MINUS relays in series", \
  "F09    <1.2    <9      O  On resistance of PLUS and GND relays in series",  \
  "F10    >9.0            V  Voltage to shield at 9 A",                       \
  "F11 NS 5.5     4.5     O  Resistance of analog cable",                      \
  "F11 SP >300            O  Resistance between Kelvin probes",                \
  "F14    0.0     0.1     V  DC offset of on-head I-U at 100 K x1",            \
  "F15+   0       100     B  AC zero of on-head I-U at 100 K x1",              \
  "F16    0       100",                                                        \
  "F17+   0       250     B  AC zero of on-head I-U at 100 K x10",             \
  "F18    0       250",                                                        \
  "F19+   0       250     B  AC zero of on-head U at x1",                      \
  "F20    0       250",                                                        \
  "F21    0.0     0.2     V  DC offset of on-head I-U at 10 K x10",            \
  "F22    0.0     0.1     V  Output DC voltage of zeroed on-head",             \
  "F23+   159.0   61.0    O  Resistance of on-head optorelays",                \
  "F24    159.0   61.0",                                                       \
  "F25    3250    1750    P  Capacity of analog cable",                        \
  "+1     Secondary (slave) measurement card",                                 \
  "F00+   [650    <1000   T  On/Off time of U/I relay",                        \
  "F01    [650    <1000",                                                      \
  "F02+   [650    <1000   T  On/Off time of MINUS relay",                      \
  "F03    [650    <1000",                                                      \
  "F04+   [650    <1000   T  On/Off time of PLUS relay",                       \
  "F05    [650    <1000",                                                      \
  "F06+   [650    <1000   T  On/Off time of GND relay",                        \
  "F07    [650    <1000",                                                      \
  "F08    <1.2    <9      O  On resistance of U/I and MINUS relays in series", \
  "F09    <1.2    <9      O  On resistance of PLUS and GND relays in series",  \
  "F10    >9.0            V  Voltage to shield at 9 A",                       \
  "F11 NS 5.5     4.5     O  Resistance of analog cable",                      \
  "F11 SP >300            O  Resistance between Kelvin probes",                \
  "E" }

char extant[16,NCHAR] = {                                                      \
  "%X     External antenna",                                                   \
  "+0     Primary (master) measurement card",                                  \
  "F00+   [650    <1000   T  On/Off time of U/I relay",                        \
  "F01    [650    <1000",                                                      \
  "F02+   [650    <1000   T  On/Off time of MINUS relay",                      \
  "F03    [650    <1000",                                                      \
  "F04+   [650    <1000   T  On/Off time of PLUS relay",                       \
  "F05    [650    <1000",                                                      \
  "F06+   [650    <1000   T  On/Off time of GND relay",                        \
  "F07    [650    <1000",                                                      \
  "F08    <5.0    <9      O  On resistance of U/I and MINUS relays in series", \
  "F09    <5.0    <9      O  On resistance of PLUS and GND relays in series",  \
  "F10    >9.0            V  Voltage to shield at 9 A",                       \
  "F11    5.0     5.0     O  Resistance of analog cable",                      \
  "F25    4750    3250    P  Capacity between shuttle and ground",             \
  "E" }

char output[27,NCHAR] = {                                                      \
  "%G     Output",                                                             \
  "+0     Primary (master) measurement card",                                  \
  "F00+   [650    <1000   T  On/Off time of U/I relay",                        \
  "F01    [650    <1000",                                                      \
  "F02+   [650    <1000   T  On/Off time of MINUS relay",                      \
  "F03    [650    <1000",                                                      \
  "F04+   [650    <1000   T  On/Off time of PLUS relay",                       \
  "F05    [650    <1000",                                                      \
  "F06+   [650    <1000   T  On/Off time of GND relay",                        \
  "F07    [650    <1000",                                                      \
  "F08    <1.2    <9      O  On resistance of U/I and MINUS relays in series", \
  "F09    <1.2    <9      O  On resistance of PLUS and GND relays in series",  \
  "F10    >9.0            V  Voltage to shield at 9 A",                       \
  "+1     Secondary (slave) measurement card",                                 \
  "F00+   [650    <1000   T  On/Off time of U/I relay",                        \
  "F01    [650    <1000",                                                      \
  "F02+   [650    <1000   T  On/Off time of MINUS relay",                      \
  "F03    [650    <1000",                                                      \
  "F04+   [650    <1000   T  On/Off time of PLUS relay",                       \
  "F05    [650    <1000",                                                      \
  "F06+   [650    <1000   T  On/Off time of GND relay",                        \
  "F07    [650    <1000",                                                      \
  "F08    <1.2    <9      O  On resistance of U/I and MINUS relays in series", \
  "F09    <1.2    <9      O  On resistance of PLUS and GND relays in series",  \
  "F10    >9.0            V  Voltage to shield at 9 A",                       \
  "E" }

// Shortcuts on extra outputs of modular multiplexer card.
char muxshort[24,NCHAR] = {                                                    \
  "%E     Shortcut at ",                                                       \
  "+0     Primary (master) measurement card",                                  \
  "X00+   [650    <1000   T  On/Off time of U/I relay",                        \
  "X01    [650    <1000",                                                      \
  "X02+   [650    <1000   T  On/Off time of MINUS relay",                      \
  "X03    [650    <1000",                                                      \
  "X04+   [650    <1000   T  On/Off time of PLUS relay",                       \
  "X05    [650    <1000",                                                      \
  "X06+   [650    <1000   T  On/Off time of GND relay",                        \
  "X07    [650    <1000",                                                      \
  "X08    <5.0    <9      O  On resistance of U/I and MINUS relays in series", \
  "X09    <5.0    <9      O  On resistance of PLUS and GND relays in series",  \
  "+1     Secondary (slave) measurement card",                                 \
  "X00+   [650    <1000   T  On/Off time of U/I relay",                        \
  "X01    [650    <1000",                                                      \
  "X02+   [650    <1000   T  On/Off time of MINUS relay",                      \
  "X03    [650    <1000",                                                      \
  "X04+   [650    <1000   T  On/Off time of PLUS relay",                       \
  "X05    [650    <1000",                                                      \
  "X06+   [650    <1000   T  On/Off time of GND relay",                        \
  "X07    [650    <1000",                                                      \
  "X08    <5.0    <9      O  On resistance of U/I and MINUS relays in series", \
  "X09    <5.0    <9      O  On resistance of PLUS and GND relays in series",  \
  "E" }

char hvinit[82,NCHAR] = {                                                      \
  "%B     HV measurements",                                                    \
  "%      If cell contains two values, first is for positive",                 \
  "%      and second is for negative HV channel",                              \
  "+0     Primary (master) measurement card",                                  \
  "H00                    V  HVMAX (voltage per channel)",                     \
  "H01                    I  HVCUR (max output current)",                      \
  "H02                    O  Resistance of current sensors",                   \
  "H03    <1000   <2000   D  On time of DC-DC HV converter",                   \
  "H04+   >270            V  Supply voltages",                                 \
  "H05    >270",                                                               \
  "H06+H5 0.0     3.0     V  Raw output voltage when DAC is set to 0",         \
  "H07 H5 0.0     3.0",                                                        \
  "H06+H1 5.0     5.0     V  Raw output voltage when DAC is set to 0",         \
  "H07 H1 5.0     5.0",                                                        \
  "H08+   HVMAX   5.0     V  Raw output voltage when DAC is set to HVMAX",     \
  "H09    HVMAX   5.0",                                                        \
  "H10+   0.0     3.0     V  Extrapolated zero of HV sources",                 \
  "H11    0.0     3.0",                                                        \
  "H12+   1.0     0.03       Voltage factor of HV sources",                    \
  "H13    1.0     0.03",                                                       \
  "H14+   HVCUR   %15     I  Current through voltage regulator",               \
  "H15    HVCUR   %15",                                                        \
  "H16+   0       1000    B  Zero of I sensor at amplification x1",            \
  "H17    0       1000",                                                       \
  "H18+   0       1000    B  Zero of I sensor at amplification x10",           \
  "H19    0       1000",                                                       \
  "H20+   0       1000    B  Zero of I sensor at amplification x100",          \
  "H21    0       1000",                                                       \
  "H22+   0       1000    B  Zero of I sensor at amplification x1000",         \
  "H23    0       1000",                                                       \
  "H28+   >30768          B  Max current measured by I sensor",                \
  "H29    >30768",                                                             \
  "H24+10 <5      <100    D  Switching time 10 mA -> 1 mA (HVCUR=10 mA only)", \
  "H25 10 <5      <100",                                                       \
  "H26+10 <5      <100    D  Switching time 1 mA -> 10 mA (HVCUR=10 mA only)", \
  "H27 10 <5      <100",                                                       \
  "H32 H5 0.0     5.0     Q  Zero resistance offset",                          \
  "H32 H1 0.0     15.0    Q  Zero resistance offset",                          \
  "H30    1.0     0.2        Resistance correction factor",                    \
  "H31    <1000   <2000   D  Off time of DC-DC HV converter",                  \
  "+1     Secondary (slave) measurement card",                                 \
  "H00                    V  HVMAX (voltage per channel)",                     \
  "H01                    I  HVCUR (max output current)",                      \
  "H02                    O  Resistance of current sensors",                   \
  "H03    <1000   <2000   D  On time of DC-DC HV converter",                   \
  "H04+   >270            V  Supply voltages",                                 \
  "H05    >270",                                                               \
  "H06+H5 0.0     3.0     V  Raw output voltage when DAC is set to 0",         \
  "H07 H5 0.0     3.0",                                                        \
  "H06+H1 5.0     5.0     V  Raw output voltage when DAC is set to 0",         \
  "H07 H1 5.0     5.0",                                                        \
  "H08+   HVMAX   5.0     V  Raw output voltage when DAC is set to HVMAX",     \
  "H09    HVMAX   5.0",                                                        \
  "H10+   0.0     3.0     V  Extrapolated zero of HV sources",                 \
  "H11    0.0     3.0",                                                        \
  "H12+   1.0     0.03       Voltage factor of HV sources",                    \
  "H13    1.0     0.03",                                                       \
  "H14+   HVCUR   %15     I  Current through voltage regulator",               \
  "H15    HVCUR   %15",                                                        \
  "H16+   0       1000    B  Zero of I sensor at amplification x1",            \
  "H17    0       1000",                                                       \
  "H18+   0       1000    B  Zero of I sensor at amplification x10",           \
  "H19    0       1000",                                                       \
  "H20+   0       1000    B  Zero of I sensor at amplification x100",          \
  "H21    0       1000",                                                       \
  "H22+   0       1000    B  Zero of I sensor at amplification x1000",         \
  "H23    0       1000",                                                       \
  "H28+   >30768          B  Max current measured by I sensor",                \
  "H29    >30768",                                                             \
  "H24+10 <5      <100    D  Switching time 10 mA -> 1 mA (HVCUR=10 mA only)", \
  "H25 10 <5      <100",                                                       \
  "H26+10 <5      <100    D  Switching time 1 mA -> 10 mA (HVCUR=10 mA only)", \
  "H27 10 <5      <100",                                                       \
  "H32 H5 0.0     5.0     Q  Zero resistance offset",                          \
  "H32 H1 0.0     15.0    Q  Zero resistance offset",                          \
  "H30    1.0     0.2        Resistance correction factor",                    \
  "H31    <1000   <2000   D  Off time of DC-DC HV converter",                  \
  "E" }

char hvfinger[20,NCHAR] = {                                                    \
  "%F     Head",                                                               \
  "+0     Primary (master) measurement card",                                  \
  "F32+   0       100     B  Individual leakage at amplification x1",          \
  "F33    0       100",                                                        \
  "F34+   0       100     B  Individual leakage at amplification x10",         \
  "F35    0       100",                                                        \
  "F36+   0       1000    B  Individual leakage at amplification x100",        \
  "F37    0       1000",                                                       \
  "F38+   0       5000    B  Individual leakage at amplification x1000",       \
  "F39    0       5000",                                                       \
  "+1     Secondary (slave) measurement card",                                 \
  "F32+   0       100     B  Individual leakage at amplification x1",          \
  "F33    0       100",                                                        \
  "F34+   0       100     B  Individual leakage at amplification x10",         \
  "F35    0       100",                                                        \
  "F36+   0       1000    B  Individual leakage at amplification x100",        \
  "F37    0       1000",                                                       \
  "F38+   0       5000    B  Individual leakage at amplification x1000",       \
  "F39    0       5000",                                                       \
  "E" }

char hvout[20,NCHAR] = {                                                       \
  "%G     Output",                                                             \
  "+0     Primary (master) measurement card",                                  \
  "F32+   0       100     B  Individual leakage at amplification x1",          \
  "F33    0       100",                                                        \
  "F34+   0       100     B  Individual leakage at amplification x10",         \
  "F35    0       100",                                                        \
  "F36+   0       1000    B  Individual leakage at amplification x100",        \
  "F37    0       1000",                                                       \
  "F38+   0       5000    B  Individual leakage at amplification x1000",       \
  "F39    0       5000",                                                       \
  "+1     Secondary (slave) measurement card",                                 \
  "F32+   0       100     B  Individual leakage at amplification x1",          \
  "F33    0       100",                                                        \
  "F34+   0       100     B  Individual leakage at amplification x10",         \
  "F35    0       100",                                                        \
  "F36+   0       1000    B  Individual leakage at amplification x100",        \
  "F37    0       1000",                                                       \
  "F38+   0       5000    B  Individual leakage at amplification x1000",       \
  "F39    0       5000",                                                       \
  "E" }

char hvant[20,NCHAR] = {                                                       \
  "%X     External antenna",                                                   \
  "+0     Primary (master) measurement card",                                  \
  "F32+   0       100     B  Individual leakage at amplification x1",          \
  "F33    0       100",                                                        \
  "F34+   0       100     B  Individual leakage at amplification x10",         \
  "F35    0       100",                                                        \
  "F36+   0       1000    B  Individual leakage at amplification x100",        \
  "F37    0       1000",                                                       \
  "F38+   0       5000    B  Individual leakage at amplification x1000",       \
  "F39    0       5000",                                                       \
  "+1     Secondary (slave) measurement card",                                 \
  "F32+   0       100     B  Individual leakage at amplification x1",          \
  "F33    0       100",                                                        \
  "F34+   0       100     B  Individual leakage at amplification x10",         \
  "F35    0       100",                                                        \
  "F36+   0       1000    B  Individual leakage at amplification x100",        \
  "F37    0       1000",                                                       \
  "F38+   0       5000    B  Individual leakage at amplification x1000",       \
  "F39    0       5000",                                                       \
  "E" }

char crtinit[12,NCHAR] = {                                                     \
  "%B     MSD measurements",                                                   \
  "%      If cell contains two values, first is for high",                     \
  "%      and second is for low charging resistor",                            \
  "+0     Primary (master) measurement card only",                             \
  "H48                    V  CRTMAX (requested MSD test voltage)",             \
  "H50    <1000   <2000   D  On time of DC-DC HV converter",                   \
  "H49    >270            V  Positive supply voltage",                         \
  "H51 H5 0.0     3.0     V  Raw output voltage when DAC is set to 0",         \
  "H51 H1 5.0     5.0     V  Raw output voltage when DAC is set to 0",         \
  "H52    CRTMAX  5.0     V  Raw output voltage when DAC is set to HVMAX",     \
  "H53    <1000   <2000   D  Off time of DC-DC HV converter",                  \
  "E" }

char crtfinger[15,NCHAR] = {                                                   \
  "%F     Head",                                                               \
  "F60                    V  Maximal allowed test voltage",                    \
  "F48                    R  Polarity",                                        \
  "F49+   0       3.0     V  Zero voltage measured by head",                   \
  "F54    0       3.0",                                                        \
  "F50+   CRTMAX  15      V  CRTMAX measured by head",                         \
  "F55    CRTMAX  15",                                                         \
  "F59    0       150     B  Capacitive disbalance at 1.5 M range",            \
  "F51+   0       5       V  Asymptote of fitting exponent",                   \
  "F56    0       5",                                                          \
  "F52+   250     150     T  Charging time",                                   \
  "F57    60      40",                                                         \
  "F53+   <15.0   <1500   B  Mean error of fitting exponent",                  \
  "F58    <30.0   <1500",                                                      \
  "E" }

char lainit[19,NCHAR] = {                                                      \
  "%B     LATEST measurements",                                                \
  "%      If cell contains two values, first is for positive and second is ",  \
  "%      for negative DAC voltage. LATEST is initialized to 2 A, 1000 Hz",    \
  "+0     Primary (master) measurement card only",                             \
  "L04    32768   250     B  AGND voltage",                                    \
  "L05+   2.25    0.06    V  Raw DIFF x1 voltage when 2.25 V is applied",      \
  "L06    -2.25   0.06",                                                       \
  "L07    0       120     B  Zero of DIFF amplifier at amplification 1/3",     \
  "L11    0       150     B  Zero of voltage sensor",                          \
  "L10    0       250     B  Voltage at R = 1 Ohm when current is zero",       \
  "L12    0.25    0.025   V  Diff voltage at R = 1 Ohm when current is 250 mA",\
  "L13    1.0     0.1     V  Diff voltage at R = 1 Ohm when current is 1 A",   \
  "L14    250     25      I  250 mA current test at R = 1 Ohm",                \
  "L15    1000    50      I  1 A current test at R = 1 Ohm",                   \
  "L16    >12.5           V  Max voltage of current source at 0.25 A",         \
  "L19    <0.5    <10.0   V  Amplitude of 1-kHz signal after highpass filter", \
  "L20    6.1     3.9     V  Amplitude of 2-kHz signal after highpass filter", \
  "L9                     G  Phase shift of highpass filter at 2 kHz",         \
  "E" }

char lafinger[8,NCHAR] = {                                                     \
  "%F     Head",                                                               \
  "F40+   [5000   <5000   T  On/Off time of IOUT relay",                       \
  "F41    [2500   <2500",                                                      \
  "F42+   [5000   <5000   T  On/Off time of AGND relay",                       \
  "F43    [2500   <2500",                                                      \
  "F44    <1.2    <9      O  On resistance of IOUT and MINUS relays in series",\
  "F45    <1.2    <9      O  On resistance of AGND and PLUS relays in series", \
  "E" }

char lafingermod[8,NCHAR] = {                                                  \
  "%F     Head",                                                               \
  "F40+   [1100   <1100   T  On/Off time of IOUT relay",                       \
  "F41    [1100   <1100",                                                      \
  "F42+   [1100   <1100   T  On/Off time of AGND relay",                       \
  "F43    [1100   <1100",                                                      \
  "F44    <1.2    <9      O  On resistance of IOUT and MINUS relays in series",\
  "F45    <1.2    <9      O  On resistance of AGND and PLUS relays in series", \
  "E" }

char laout[8,NCHAR] = {                                                        \
  "%G     Output",                                                             \
  "F40+   [5000   <5000   T  On/Off time of IOUT relay",                       \
  "F41    [2500   <2500",                                                      \
  "F42+   [5000   <5000   T  On/Off time of AGND relay",                       \
  "F43    [2500   <2500",                                                      \
  "F44    <1.2    <9      O  On resistance of IOUT and MINUS relays in series",\
  "F45    <1.2    <9      O  On resistance of AGND and PLUS relays in series", \
  "E" }

char laoutmod[8,NCHAR] = {                                                     \
  "%G     Output",                                                             \
  "F40+   [1100   <1100   T  On/Off time of IOUT relay",                       \
  "F41    [1100   <1100",                                                      \
  "F42+   [1100   <1100   T  On/Off time of AGND relay",                       \
  "F43    [1100   <1100",                                                      \
  "F44    <1.2    <9      O  On resistance of IOUT and MINUS relays in series",\
  "F45    <1.2    <9      O  On resistance of AGND and PLUS relays in series", \
  "E" }

char curradj[21,NCHAR] = {                                                     \
  "%0",                                                                        \
  "%B     Current adjustment of A5/A6 measurement card (BEL407)",              \
  "%      If cell contains two values, first is for positive",                 \
  "%      and second is for negative charging current",                        \
  "%",                                                                         \
  "%",                                                                         \
  "%B     Low (2.5 mA) current source",                                        \
  "D45    0.0     2.0     +  Adjust to zero with first potentiometer",         \
  "%",                                                                         \
  "%",                                                                         \
  "%B     High (100 mA) current source",                                       \
  "D44    0.0     3.0     +  Adjust to zero with second potentiometer",        \
  "%   30",                                                                    \
  "%   30",                                                                    \
  "%B  30 300 mA current source (optional)",                                   \
  "A12 30 0.0     5.0     +  Adjust to zero with 300 mA potentiometer",        \
  "%   NC",                                                                    \
  "%   NC",                                                                    \
  "%B  NC ADC filter balance (optional)",                                      \
  "D61 NC 0.0     1.00    3  Adjust to zero (0.010 for low-R Kelvin)",        \
  "E" }

char curradjms[17,NCHAR] = {                                                   \
  "%0",                                                                        \
  "%B     Current adjustment of A5/A6 measurement card (BEL407)",              \
  "%",                                                                         \
  "+0     Primary (master) measurement card",                                  \
  "%",                                                                         \
  "D45    0.0     2.0     +  Low (2.5 mA) current source",                     \
  "D44    0.0     2.0     +  High (100 mA) current source",                    \
  "A12 30 0.0     5.0     +  300 mA current source (optional)",                \
  "D61 NC 0.0     1.00    3  ADC filter balance (optional)",                   \
  "%",                                                                         \
  "+1     Secondary (slave) measurement card",                                 \
  "%",                                                                         \
  "D45    0.0     2.0     +  Low (2.5 mA) current source",                     \
  "D44    0.0     2.0     +  High (100 mA) current source",                    \
  "A12 30 0.0     5.0     +  300 mA current source (optional)",                \
  "D61 NC 0.0     1.00    3  ADC filter balance (optional)",                   \
  "E" }

char latestadj[13,NCHAR] = {                                                   \
  "%0",                                                                        \
  "%B     Current adjustment of A5/A6 LATEST extention (BEL420)",              \
  "%      If cell contains two values, first is for positive",                 \
  "%      and second is for negative charging current.",                       \
  "%",                                                                         \
  "+0     Primary (master) measurement card only",                             \
  "%B     Balance of LATEST current source",                                   \
  "L18    0.0     5.0     +  Adjust to zero with LATEST potentiometer",        \
  "L00+   200.0   50.0    S  Charging speed in -9-5 V range",                 \
  "L01    200.0   50.0",                                                       \
  "L02+   200.0   50.0    S  Charging speed in +5+9 V range",                 \
  "L03    200.0   50.0",                                                       \
  "E" }

// T:       type of data, R - relay, P - relay pair, F - head, A - temperature
//          sensor, N - relay name, M - measurement card, T- text, X - external
//          shortcut, Y - shortcut resistance, E - end
// OOC:     offset; C='+': cosine component in next line
// MM:      special modifiers; NS - no Kelvin probes, SP - Kelvin probes
// Good0:   minimal allowed good value
// Good1:   maximal allowed good value
// Warn0:   minimal allowed "yellow warning" value
// Warn1:   maximal allowed "yellow warning" value
// Mindf:   maximal allowed good max-min difference
// Maxdf:   maximal allowed "yellow" max-min difference
// Displ:   display limit
// U:       units: B-bits, V-volts, S-bit/us, T-us, ?-us optional, D-ms,
//          Y-yes/no, X-us, O-Ohms, P-pf, I-mA, A-arbitrary units, +-large font
// Text:    explanation
//
// TOOCMMGood0Good1Warn0Warn1MindfMaxdfDisplU Text...
char showmuxhead[5,NCHAR] = {                                                  \
  "R00   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "R01   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "P08   0.1  1.08 0.0  1.2  0.1  0.2  9    O On resistance of selected pair", \
  "B26   0.1  1.08 0.0  1.2  0.1  0.2  9    O Max burn-in resistance of pair", \
  "E" }

char showmuxant[4,NCHAR] = {                                                   \
  "R00   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "R01   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "P08   0.1  4.5  0.0  9.0  0.2  0.3  9    O On resistance of selected pair", \
  "E" }

char showmuxext[4,NCHAR] = {                                                   \
  "X00   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "X01   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "Y00   0.1  4.5  0.0  9.0  0.2  0.3  9    O On resistance of selected pair", \
  "E" }

char showmuxtsens[3,NCHAR] = {                                                 \
  "A24   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "A25   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "E" }

char showmuxconn[4,NCHAR] = {                                                  \
  "R00   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "R01   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "P08   0.1  1.08 0.0  1.2  0.1  0.2  9    O On resistance of selected pair", \
  "E" }

char showmeascard[65,NCHAR] = {                                                \
  "N58                                        connects U to U/I",              \
  "M58   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M59   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N48                                        connects I to U/I",              \
  "M48   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M49   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N56                                        connects I-U to PLUS",           \
  "M56   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M57   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N54                                        connects I-U to MINUS",          \
  "T54   Note: may be not connected on old measurement cards",                 \
  "M54   120  350  100  370  70   150  1000 ? On time of selected relay",      \
  "M55   1    585  1    650  70   150  1000 ? Off time of selected relay",     \
  "N32                                        connects U/I to ground",         \
  "M32   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M33   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N36                                        connects PLUS to ground",        \
  "M36   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M37   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N34                                        connects MINUS to ground",       \
  "M34   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M35   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N38                                        connects GND to ground",         \
  "M38   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M39   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N40                                        connects U/I to short",          \
  "M40   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M41   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N44                                        connects PLUS to short",         \
  "M44   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M45   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N42                                        connects MINUS to short",        \
  "M42   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M43   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N46                                        connects GND to short",          \
  "M46   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M47   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N60                                        connects U to U/I via 100 Ohm",  \
  "M60   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M61   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N62                                        connects U/I to PLUS",           \
  "T62   Note: may be not connected on old measurement cards",                 \
  "M62   120  350  100  370  70   150  1000 ? On time of selected relay",      \
  "M63   1    585  1    650  70   150  1000 ? Off time of selected relay",     \
  "N50                                        connects I high to K85",         \
  "M50   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M51   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N52                                        connects I low to K85",          \
  "M52   120  350  100  370  70   150  1000 T On time of selected relay",      \
  "M53   1    585  1    650  70   150  1000 T Off time of selected relay",     \
  "N22                                        connects DAC to GND",            \
  "T22   Note: optional, used by LATEST measurements only",                    \
  "M22   120  350  100  370  70   150  1000 ? On time of selected relay",      \
  "M23   1    585  1    650  70   150  1000 ? Off time of selected relay",     \
  "O66                                        connects 100 Ohm to short",      \
  "L66   120  350  100  370  70   150  1000 ? On time of selected relay",      \
  "L67   1    585  1    650  70   150  1000 ? Off time of selected relay",     \
  "O68                                        connects 1 kOhm to short",       \
  "L68   120  350  100  370  70   150  1000 ? On time of selected relay",      \
  "L69   1    585  1    650  70   150  1000 ? Off time of selected relay",     \
  "O64                                        connects 300 mA to K85",         \
  "U64   Note: may be not connected on old measurement cards",                 \
  "L64   120  350  100  370  70   150  1000 ? On time of selected relay",      \
  "L65   1    585  1    650  70   150  1000 ? Off time of selected relay",     \
  "E" }

char showlahead[4,NCHAR] = {                                                   \
  "R40   2700 4500 2500 5000 250  500  6000 T On time of selected relay",      \
  "R41   1    2250 1    2500 250  500  6000 T Off time of selected relay",     \
  "P44   0.1  1.76 0.0  2.2  0.1  0.2  9    O On resistance of selected pair", \
  "E" }

char showlamod[4,NCHAR] = {                                                    \
  "R40   400  1000 350  1100 250  500  6000 T On time of selected relay",      \
  "R41   1    1000 1    1100 250  500  6000 T Off time of selected relay",     \
  "P44   0.1  1006 0.0  1.2  0.1  0.2  9    O On resistance of selected pair", \
  "E" }

// T:       type of data, A - relay on main board, M - relay on mux, X - relay
//          on main board in extrastat, E - end
// OO:      offset
// K:       '<' - minimum, '>' - maximum, '=' - mean
// Text:    explanation
//
// TOOK TOOK TOOK TOOK TOOK TOOK Text
char mainrelays[25,NCHAR] = {                                                  \
  "A24< A24> A25< A25>           K64 (connects T sensor to U/I)",              \
  "A26< A26> A27< A27>           K65 (connects T sensor to MINUS)",            \
  "A28< A28> A29< A29>           K66 (connects T sensor to PLUS)",             \
  "A30< A30> A31< A31>           K67 (connects T sensor to GND)",              \
  "A58< A58> A59< A59>           K84 (connects U to U/I)",                     \
  "A48< A48> A49< A49>           K85 (connects I to U/I)",                     \
  "A56< A56> A57< A57>           K86 (connects I-U to PLUS)",                  \
  "A54< A54> A55< A55>           K87 (connects I-U to MINUS)",                 \
  "A32< A32> A33< A33>           K92 (connects U/I to ground)",                \
  "A36< A36> A37< A37>           K93 (connects PLUS to ground)",               \
  "A34< A34> A35< A35>           K94 (connects MINUS to ground)",              \
  "A38< A38> A39< A39>           K95 (connects GND to ground)",                \
  "A40< A40> A41< A41>           K96 (connects U/I to short)",                 \
  "A44< A44> A45< A45>           K97 (connects PLUS to short)",                \
  "A42< A42> A43< A43>           K98 (connects MINUS to short)",               \
  "A46< A46> A47< A47>           K99 (connects GND to short)",                 \
  "X66< X66> X67< X67>           K101 (connects 100 Ohm to short)",            \
  "X68< X68> X69< X69>           K103 (connects 1 kOhm to short)",             \
  "A60< A60> A61< A61>           K104 (connects U to U/I via 100 Ohm)",        \
  "X64< X64> X65< X65>           K105 (connects 300 mA to K85)",               \
  "A22< A22> A23< A23>           K107 (connects DAC to GND)",                  \
  "A62< A62> A63< A63>           K109 (connects U/I to PLUS)",                 \
  "A50< A50> A51< A51>           K110 (connects I high to K85)",               \
  "A52< A52> A53< A53>           K111 (connects I low to K85)",                \
  "E" }

char muxrelays[5,NCHAR] = {                                                    \
  "M00< M00> M01< M01> M08< M08> U/I relay",                                   \
  "M02< M02> M03< M03> M08< M08> MINUS relay",                                 \
  "M04< M04> M05< M05> M09< M09> PLUS relay",                                  \
  "M06< M06> M07< M07> M09< M09> GND relay",                                   \
  "E" }

// Scans floating-point number from text string. Stops at first invalid char.
function float Fnumb(char *s)
  int i,sign
  float f,mult
  if s[i]=='-' then sign=1; i++; endif
  f=0.0
  while Isdigit(s[i]) do f=f*10.0+(s[i]-'0'); i++; enddo
  if s[i]=='.' then
    i++
    mult=1.0
    while Isdigit(s[i]) do
      mult=mult*0.1; f=f+(s[i]-'0')*mult; i++
    enddo
  endif
  if sign return -f
  return f
end

// Scans integer number from text string. Stops at first invalid char.
function int Inumb(char *s)
  int i,sign
  int n
  if s[i]=='-' then sign=1; i++; endif
  while Isdigit(s[i]) do n=n*10+(s[i]-'0'); i++; enddo
  if sign return -n
  return n
end

function int Drawminmax(float smin,float smax,float smean,                     \
  float topmin,float topmax,int drawmean)
  float diff
  smin=Max(topmin,Min(smin,topmax))
  smax=Max(topmin,Min(smax,topmax))
  smean=Max(topmin,Min(smean,topmax))
  diff=smax-smin
  if drawmean then
    smin=smean; smax=smean
  endif
  if smin<=topmin then
    draw at IX1+5,ydata text="<"
  else if smin>=topmax then
    draw at IX1+5,ydata text=">"
  else if smin>=0 then
    draw at IX1+10,ydata
  else
    draw at IX1+5,ydata
  endif
  if Abs(smin)<10.0 && Abs(smax)<10.0 then
    draw text=format("%.3f",smin)
  else if Abs(smin)<100.0 && Abs(smax)<100.0 then
    draw text=format("%.2f",smin)
  else if Abs(smin)<1000.0 && Abs(smax)<1000.0 then
    draw text=format("%.1f",smin)
  else
    draw text=format("%.0f",smin)
  endif
  if smin!=smax then
    draw text=""
    if smax>=topmax draw text=">"
    if Abs(smin)<10.0 && Abs(smax)<10.0 then
      draw text=format("%.3f",smax)
    else if Abs(smin)<100.0 && Abs(smax)<100.0 then
      draw text=format("%.2f",smax)
    else if Abs(smin)<1000.0 && Abs(smax)<1000.0 then
      draw text=format("%.1f",smax)
    else
      draw text=format("%.0f",smax)
    endif
  endif
  if diff!=0.0 then
    draw at IX2+7,ydata
    if Abs(smin)<10.0 && Abs(smax)<10.0 then
      draw text=format("%.4f",diff)
    else if Abs(smin)<100.0 && Abs(smax)<100.0 then
      draw text=format("%.3f",diff)
    else if Abs(smin)<1000.0 && Abs(smax)<1000.0 then
      draw text=format("%.2f",diff)
    else
      draw text=format("%.1f",diff)
    endif
  endif
end

function int Printminmax(char *s,float smin,float smax,float smean,int drawmean)
  int n
  if drawmean then
    smin=smean; smax=smean
  endif
  if Abs(smin)<10.0 && Abs(smax)<10.0 then
    if smin!=smax then
      n=sprintf(s,"%6.3f .. %6.3f",smin,smax)
    else
      n=sprintf(s,"%6.3f",smin)
    endif
  else if Abs(smin)<100.0 && Abs(smax)<100.0 then
    if smin!=smax then
      n=sprintf(s,"%6.2f .. %6.2f",smin,smax)
    else
      n=sprintf(s,"%6.2f",smin)
    endif
  else if Abs(smin)<1000.0 && Abs(smax)<1000.0 then
    if smin!=smax then
      n=sprintf(s,"%6.1f .. %6.1f",smin,smax)
    else
      n=sprintf(s,"%6.1f",smin)
    endif
  else
    if smin!=smax then
      n=sprintf(s,"%6.0f .. %6.0f",smin,smax)
    else
      n=sprintf(s,"%6.0f",smin)
    endif
  endif
  return n
end

// Adds data table to info window. Parameter userhead is head in user notation
// (that is, 0 till 15 for A6/16, 0 till 7 for A5/8) or extra mux output (0..5).
function int Drawdata(char *data,int head,int userhead,int drawmean)
  int i,card,type,dy,y0,y1,istable,line,grayed,conn,extratime,optional
  float r1,r2,goodmin,goodmax,topmin,topmax,smin,smax,smean
  char s[NCHAR],mm[3]
  draw window=hinfo color=BLACK bkcolor=WHITE
  istable=0                            // Not in table
  for line=0,1,line++ do
    Memcpy(s,data+line*NCHAR,NCHAR)
    grayed=0
    extratime=0
    // Modifiers are a kind of conditional operators. Check if there are any.
    mm[0]=s[MMOFFS]; mm[1]=s[MMOFFS+1]; mm[2]='\0'
    if Strcmp(mm,"10")==0 then         // Disable line if HVCUR=10 mA
      if (ntest>0 && measstat[card,129,1]==1.0) grayed=1;
    else if Strcmp(mm,"SP")==0 then    // Kelvin probe only
      if (l.probetype & 0x1)==0 continue
    else if Strcmp(mm,"NS")==0 then    // Non-Kelvin probe only
      if (l.probetype & 0x1)!=0 continue
    else if Strcmp(mm,"SL")==0 then    // Slow relays
      if (l.config & 0x00002000)!=0 extratime=1000
    else if Strcmp(mm,"NC")==0 then    // BEL407-5 only
      if (isnewmeas==0) continue
    else if Strcmp(mm,"N2")==0 then    // BEL407-5 only, 20 kHz filter
      if (isnewmeas==0 || measstat[card,71,0]==50.0) continue
    else if Strcmp(mm,"N5")==0 then    // BEL407-5 only, 50 kHz filter
      if (isnewmeas==0 || measstat[card,71,0]!=50.0) continue
    else if Strcmp(mm,"30")==0 then    // 300 mA add-on
      if measstat[card,72,0]==0 && measstat[card,73,0]==0 &&                   \
      measstat[card,74,0]==0 && measstat[card,75,0]==0 continue
    else if Strcmp(mm,"H5")==0 then    // HV500
      if hvtype==1000 continue
    else if Strcmp(mm,"H1")==0 then    // HV1000
      if hvtype!=1000 continue
    endif
    type=s[TOFFS]
    if istable==1 && (type=='+' || type=='%' || type=='E') then
      // Finish previous table.
      draw color=GRAY
      draw at IX0,y0 to IX0,ydata at IX1,y0 to IX1,ydata
      draw at IX2,y0 to IX2,ydata at IX3,y0 to IX3,ydata
      draw at IX4,y0 to IX4,ydata at IX5,y0 to IX5,ydata
      istable=0
    else if istable==0 &&                                                      \
      (type=='D' || type=='A' || type=='H' || type=='L' || type=='F' ||        \
      type=='X') && (card==0 || (card==1 && nmeascard==2)) then
      // Start new table.
      ydata=ydata+5; y0=ydata
      draw color=GRAY at IX0,ydata to IX5,ydata
      istable=1
    endif
    if type=='E' then
      // End of drawing.
      ydata=ydata+12
      break
    else if type=='+' then
      // Select master or slave measurement card.
      if s[TOFFS+1]=='1' then
        card=1
      else
        card=0
      endif
      if nmeascard==1 continue
      if s[TOFFS+2]!='\0' && s[NOMOFFS]!='\0' then
        ydata=ydata+18
        draw color=GREEN font=INFOFONT mode=M_CENTERED at DX/2,ydata
        draw text=s+NOMOFFS
      endif
    else if card==1 && nmeascard==1 then
      // Skip lines dedicated for slave card if this is unavailable.
      continue
    else if type=='%' then
      // Display line of text.
      if s[1]=='0' then
        draw color=WHITE bkcolor=WHITE clear
        ydata=10                       // Initialize table
      else if s[1]=='B' then
        ydata=ydata+20                 // Bold centered text
        draw color=BLACK font=MEDIUMFONT mode=M_CENTERED at DX/2,ydata
        draw text=s+NOMOFFS
      else if s[1]=='F' then           
        ydata=ydata+20                 // Bold centered text with head
        draw color=BLACK font=MEDIUMFONT mode=M_CENTERED at DX/2,ydata
        draw text=format("%s %i (%i%c)",                                       \
        s+NOMOFFS,userhead,userhead/2,userhead & 1?'R':'L')
      else if s[1]=='X' then
        ydata=ydata+20                 // Bold centered text with extant
        draw color=BLACK font=MEDIUMFONT mode=M_CENTERED at DX/2,ydata
        draw text=format("%s %i",s+NOMOFFS,userhead)
      else if s[1]=='E' then
        ydata=ydata+20                 // Bold centered text with ext mux output
        draw color=BLACK font=MEDIUMFONT mode=M_CENTERED at DX/2,ydata
        draw text=format("%s module %i : External %i",                         \
        s+NOMOFFS,userhead/2,(userhead & 1)+1)
      else if s[1]=='G' then
        ydata=ydata+20                 // Bold centered text with output
        draw color=BLACK font=MEDIUMFONT mode=M_CENTERED at DX/2,ydata
        if headstat[card,head,31,1]==0.0 then
          draw text=format("%s %i",s+NOMOFFS,(head<16?head:head-16+half))
        else
          conn=headstat[card,head,31,1]-1.0
          if nmodule==0 then
            draw text=format("%s %i (connectors JP%i, J%i, J%i)",              \
            s+NOMOFFS,(head<16?head:head-16+half),conn,conn*2+1,conn*2+2)
          else
            draw text=format("%s %i (module %i JP%i, \"%i%s\")",               \
            s+NOMOFFS,(head<16?head:head-16+half),                             \
            ((conn<half?conn:conn-half)>>2) & 0x3,                             \
            (conn & 0x3)+(conn<half?0:4),                                      \
            ((conn>>1) & 0x1)+(conn<half?0:2),(conn & 1?"R":"L"))
          endif
        endif
      else if s[1]=='V' then
        ydata=ydata+17                 // Italic version info
        draw color=BLACK font=INFOFONT mode=M_CENTERED at DX/2,ydata
        draw text=format("%s%s",s+NOMOFFS,VERSION)
      else if s[1]=='H' then
        if dcwithhv==0 continue
        ydata=ydata+17                 // Italic HV ON warning
        draw color=BLACK font=INFOFONT mode=M_CENTERED at DX/2,ydata
        draw text=format("%s",s+NOMOFFS)
      else if s[1]=='N' then
        ydata=ydata+17                 // Italic number of tests
        draw color=BLACK font=INFOFONT mode=M_CENTERED at DX/2,ydata
        draw text=format("%s%i",s+NOMOFFS,ntest)
      else
        ydata=ydata+17                 // Italic centered text
        draw color=BLACK font=INFOFONT mode=M_CENTERED at DX/2,ydata
        draw text=s+NOMOFFS
      endif
    else if type=='D' || type=='A' || type=='H' || type=='L' || type=='F' ||   \
      type=='X' then
      // Display data.
      optional=0
      ydata=ydata+17
      draw color=(grayed?DARKGRAY:BLACK)
      draw font=TIMESFONT mode=M_LEFT at IX0+5,ydata wrap=IX1-5
      draw text=s+TEXTOFFS
      // Get expected signal, deviation and units.
      topmin=-9.9e99; topmax=9.9e99
      if s[NOMOFFS]==' ' then
        goodmin=-1.0e99; goodmax=1.0e99
      else if s[NOMOFFS]=='<' then
        goodmin=-1.0e99
        goodmax=Fnumb(s+NOMOFFS+1)+extratime
        if s[DIFOFFS]=='<' then
          topmax=Fnumb(s+DIFOFFS+1)
        endif
        draw at IX4+5,ydata text=format("< %g",goodmax)
      else if s[NOMOFFS]=='[' then
        goodmin=1.0
        goodmax=Fnumb(s+NOMOFFS+1)+extratime
        if s[DIFOFFS]=='<' then
          topmax=Fnumb(s+DIFOFFS+1)
        endif
        draw at IX4+5,ydata text=format("< %g",goodmax)
      else if s[NOMOFFS]=='?' then
        optional=1
        goodmin=1.0
        goodmax=Fnumb(s+NOMOFFS+1)+extratime
        if s[DIFOFFS]=='<' then
          topmax=Fnumb(s+DIFOFFS+1)
        endif
        draw at IX4+5,ydata text=format("< %g",goodmax)
      else if s[NOMOFFS]=='>' then
        goodmin=Fnumb(s+NOMOFFS+1)
        goodmax=1.0e99
        if s[DIFOFFS]=='>' then
          topmin=Fnumb(s+DIFOFFS+1)
        endif
        draw at IX4+5,ydata text=format("> %g",goodmin)
      else if Memicmp(s+NOMOFFS,"HVMAX",5)==0 then
        r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
        if ntest==0 then
          draw at IX4+5,ydata text=format("HVMAX%.0f",r2)
        else
          r1=measstat[card,128,2]/ntest
          goodmin=r1-r2; goodmax=r1+r2
          draw at IX4+5,ydata text=format("%.1f%.1f",goodmin,goodmax)
        endif
      else if Memicmp(s+NOMOFFS,"HVCUR",5)==0 then
        if ntest>0 r1=measstat[card,129,2]/ntest
        if s[DIFOFFS]=='%' then        // Relative deviation in percent
          r2=Fnumb(s+DIFOFFS+1)/100.0*r1
        else
          r2=Fnumb(s+DIFOFFS)          // Absolute deviation from nominal
        endif
        if ntest==0 then
          if s[DIFOFFS]=='%' && ntest==0 then
            draw at IX4+5,ydata text=format("HVCUR%g%%",Fnumb(s+DIFOFFS+1))
          else
            draw at IX4+5,ydata text=format("HVCUR%g",r2)
          endif
        else
          goodmin=r1-r2; goodmax=r1+r2
          draw at IX4+5,ydata text=format("%g%g",goodmin,goodmax)
        endif
      else if Memicmp(s+NOMOFFS,"CRTMAX",6)==0 then
        r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
        if ntest==0 then
          draw at IX4+5,ydata text=format("CRTMAX%.0f",r2)
        else
          r1=measstat[card,176,2]/ntest
          goodmin=r1-r2; goodmax=r1+r2
          draw at IX4+5,ydata text=format("%.1f%.1f",goodmin,goodmax)
        endif
      else
        r1=Fnumb(s+NOMOFFS)            // Nominal value
        r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
        goodmin=r1-r2; goodmax=r1+r2
        draw at IX4+5,ydata text=format("%g%g",goodmin,goodmax)
      endif
      // Units of measurement.
      switch s[UOFFS]
      case 'A':                        // Arbitrary units
        draw at IX3+5,ydata text="a.u."
      case 'B':                        // ADC bits
        draw at IX3+5,ydata text="bits"
      case 'G':                        // Degrees
        draw at IX3+5,ydata text="deg"
      case 'V':                        // Volts
        draw at IX3+5,ydata text="V"
      case 'S':                        // Bits/microsecond
        draw at IX3+5,ydata text="bit/\ns"
      case 'Z':                        // Volts/second
        draw at IX3+5,ydata text="V/s"
      case 'T':                        // Microseconds
        draw at IX3+5,ydata text="s"
      case 'D':                        // Milliseconds
        draw at IX3+5,ydata text="ms"
      case 'O':                        // Ohms
        draw at IX3+3,ydata text="Ohm"
      case 'Q':                        // kOhms
        draw at IX3+5,ydata text="k"
      case 'P':                        // Picofarades
        draw at IX3+5,ydata text="pF"
      case 'I':                        // Milliamperes
        draw at IX3+5,ydata text="mA"
      case 'K':                        // Kiloherz
        draw at IX3+5,ydata text="kHz"
      case '%':                        // Percent
        draw at IX3+5,ydata text="%"
      endsw
      // Get measured signal.
      if ntest>0 && grayed!=0 then
        draw at IX1+10,ydata color=DARKGRAY text="n/a"
      else if ntest>0 && grayed==0 then
        i=Inumb(s+TOFFS+1)             // Index of data
        if type=='D' then
          smin=measstat[card,i,0]; smax=measstat[card,i,1]
          smean=measstat[card,i,2]/ntest
        else if type=='A' then
          smin=measstat[card,i+64,0]; smax=measstat[card,i+64,1]
          smean=measstat[card,i+64,2]/ntest
        else if type=='H' then
          smin=measstat[card,i+128,0]; smax=measstat[card,i+128,1]
          smean=measstat[card,i+128,2]/ntest
        else if type=='L' then
          smin=measstat[card,i+192,0]; smax=measstat[card,i+192,1]
          smean=measstat[card,i+192,2]/ntest
        else if type=='X' & i>=64 then
          smin=extrastat[card,i,0]; smax=extrastat[card,i,1]
          smean=extrastat[card,i,2]/ntest
        else if type=='X' then
          smin=extrastat[card,head*10+i,0]; smax=extrastat[card,head*10+i,1]
          smean=extrastat[card,head*10+i,2]/ntest
        else
          smin=headstat[card,head,i,0]; smax=headstat[card,head,i,1]
          smean=headstat[card,head,i,2]/ntest
        endif
        if s[UOFFS]=='Y' then
          // Yes or no.
          draw at IX1+10,ydata
          if smin!=smax then
            draw color=LIGHTRED text="Yes/No"
          else if smin<0.5 then
            draw color=LIGHTBLUE text="No"
          else
            draw color=LIGHTBLUE text="Yes"
          endif
        else if s[UOFFS]=='R' then
          // Polarity.
          draw at IX1+10,ydata
          if smin!=smax then
            draw color=LIGHTRED text="Variable"
          else if smin<0 then
            draw color=LIGHTBLUE text="HV at PLUS"
          else if smin==0 then
            draw color=LIGHTRED text="Unknown"
          else
            draw color=LIGHTBLUE text="HV at MINUS"
          endif
        else if s[UOFFS]=='+' || Isdigit(s[UOFFS]) then
          // Adjustment of potentiometer.
          if smean<goodmin then
            draw color=LIGHTBLUE
          else if smean>goodmax then
            draw color=LIGHTRED
          else
            draw color=BLACK
          endif
          draw font=LARGEFONT at IX1+10,ydata+19
          if s[UOFFS]=='0' then
            draw text=format("%.0f",smean)
          else if s[UOFFS]=='1' then
            draw text=format("%.1f",smean)
          else if s[UOFFS]=='2' then
            draw text=format("%.2f",smean)
          else if s[UOFFS]=='3' then
            if Abs(smean>=10.0) then
              draw text=format("%.2f",smean)
            else
              draw text=format("%.3f",smean)
            endif
          else if goodmax-goodmin>1.0 then
            draw text=format("%.1f",smean)
          else
            draw text=format("%.2f",smean)
          endif
          draw font=TIMESFONT
        else
          if (smin>=goodmin && smax<=goodmax) then
            draw color=LIGHTBLUE
            Drawminmax(smin,smax,smean,topmin,topmax,drawmean)
          else if optional && smin==0 && smax==0 then
            draw color=DARKGRAY
            draw at IX1+10,ydata text="Not connected"
            draw color=LIGHTBLUE
          else
            draw color=LIGHTRED
            Drawminmax(smin,smax,smean,topmin,topmax,drawmean)
          endif
        endif
      endif
      // Check if second component available.
      if s[TOFFS+3]=='+' && s[UOFFS]!='Y' then
        ydata=ydata+15
        draw color=(grayed?DARKGRAY:BLACK)
        line++; Memcpy(s,data+line*NCHAR,NCHAR)
        topmin=-9.9e99; topmax=9.9e99
        if s[NOMOFFS]==' ' then
          goodmin=-1.0e99; goodmax=1.0e99
        else if s[NOMOFFS]=='<' then
          goodmin=-1.0e99
          goodmax=Fnumb(s+NOMOFFS+1)+extratime
          if s[DIFOFFS]=='<' then
            topmax=Fnumb(s+DIFOFFS+1)
          endif
          draw at IX4+5,ydata text=format("< %g",goodmax)
        else if s[NOMOFFS]=='[' || s[NOMOFFS]=='?' then
          goodmin=1.0
          goodmax=Fnumb(s+NOMOFFS+1)+extratime
          if s[DIFOFFS]=='<' then
            topmax=Fnumb(s+DIFOFFS+1)
          endif
          draw at IX4+5,ydata text=format("< %g",goodmax)
        else if s[NOMOFFS]=='>' then
          goodmin=Fnumb(s+NOMOFFS+1)
          goodmax=1.0e99
          if s[DIFOFFS]=='>' then
            topmin=Fnumb(s+DIFOFFS+1)
          endif
          draw at IX4+5,ydata text=format("> %g",goodmin)
        else if Memicmp(s+NOMOFFS,"HVMAX",5)==0 then
          r2=Fnumb(s+DIFOFFS)          // Allowed deviation from nominal
          if ntest==0 then
            draw at IX4+5,ydata text=format("HVMAX%.0f",r2)
          else
            r1=measstat[card,128,2]/ntest
            goodmin=r1-r2; goodmax=r1+r2
            draw at IX4+5,ydata text=format("%.1f%.1f",goodmin,goodmax)
          endif
        else if Memicmp(s+NOMOFFS,"HVCUR",5)==0 then
          if ntest>0 r1=measstat[card,129,2]/ntest
          if s[DIFOFFS]=='%' then      // Relative deviation in percent
            r2=Fnumb(s+DIFOFFS+1)/100.0*r1
          else
            r2=Fnumb(s+DIFOFFS)        // Absolute deviation from nominal
          endif
          if ntest==0 then
            if s[DIFOFFS]=='%' && ntest==0 then
              draw at IX4+5,ydata text=format("HVCUR%g%%",Fnumb(s+DIFOFFS+1))
            else
              draw at IX4+5,ydata text=format("HVCUR%g",r2)
            endif
          else
            goodmin=r1-r2; goodmax=r1+r2
            draw at IX4+5,ydata text=format("%g%g",goodmin,goodmax)
          endif
        else if Memicmp(s+NOMOFFS,"CRTMAX",6)==0 then
          r2=Fnumb(s+DIFOFFS)          // Allowed deviation from nominal
          if ntest==0 then
            draw at IX4+5,ydata text=format("CRTMAX%.0f",r2)
          else
            r1=measstat[card,176,2]/ntest
            goodmin=r1-r2; goodmax=r1+r2
            draw at IX4+5,ydata text=format("%.1f%.1f",goodmin,goodmax)
          endif
        else
          r1=Fnumb(s+NOMOFFS)          // Nominal value
          r2=Fnumb(s+DIFOFFS)          // Allowed deviation from nominal
          goodmin=r1-r2; goodmax=r1+r2
          draw at IX4+5,ydata text=format("%.5g%.5g",goodmin,goodmax)
        endif
        if ntest>0 && grayed==0 then
          i=Inumb(s+TOFFS+1)           // Index of cosine data
          if type=='D' then
            smin=measstat[card,i,0]; smax=measstat[card,i,1]
            smean=measstat[card,i,2]/ntest
          else if type=='A' then
            smin=measstat[card,i+64,0]; smax=measstat[card,i+64,1]
            smean=measstat[card,i+64,2]/ntest
          else if type=='H' then
            smin=measstat[card,i+128,0]; smax=measstat[card,i+128,1]
            smean=measstat[card,i+128,2]/ntest
          else if type=='L' then
            smin=measstat[card,i+192,0]; smax=measstat[card,i+192,1]
            smean=measstat[card,i+192,2]/ntest
          else if type=='X' && i>=64 then
            smin=extrastat[card,i,0]; smax=extrastat[card,i,1]
            smean=extrastat[card,i,2]/ntest
          else if type=='X' then
            smin=extrastat[card,head*10+i,0]; smax=extrastat[card,head*10+i,1]
            smean=extrastat[card,head*10+i,2]/ntest
          else
            smin=headstat[card,head,i,0]; smax=headstat[card,head,i,1]
            smean=headstat[card,head,i,2]/ntest
          endif
          if (smin>=goodmin && smax<=goodmax) then
            draw color=LIGHTBLUE
            Drawminmax(smin,smax,smean,topmin,topmax,drawmean)
          else if optional==0 || smin!=0 || smax!=0 then
            draw color=LIGHTRED
            Drawminmax(smin,smax,smean,topmin,topmax,drawmean)
          endif
        endif
        ydata=ydata-15
        draw color=BLACK
      endif
      ydata=ydata+17
      draw at IX0,ydata color=GRAY to IX5,ydata; ydata++
    endif
  enddo
end

// Writes table of data to file in plain text format.
function int Printdata(handle f,char *data,int head,int userhead,int drawmean)
  int i,n,type,dy,y0,y1,conn,istable,line,grayed,ntext,extratime,optional
  int center,underline,linefeed,addserial,card
  float r1,r2,goodmin,goodmax,topmin,topmax,smin,smax,smean
  char s[NCHAR],mm[3],buf1[256],buf2[256],tmp[256]
  if f==NULL || ntest==0 return        // Nothing to do
  istable=0                            // Not in table
  for line=0,1,line++ do
    Memcpy(s,data+line*NCHAR,NCHAR)
    grayed=0
    extratime=0
    // Modifiers are a kind of conditional operators. Check if there are any.
    mm[0]=s[MMOFFS]; mm[1]=s[MMOFFS+1]; mm[2]='\0'
    if Strcmp(mm,"10")==0 then         // Disable line if HVCUR=10 mA
      if (ntest>0 && measstat[card,129,1]==1.0) grayed=1;
    else if Strcmp(mm,"SP")==0 then    // Kelvin probe only
      if (l.probetype & 0x1)==0 continue
    else if Strcmp(mm,"NS")==0 then    // Non-Kelvin probe only
      if (l.probetype & 0x1)!=0 continue
    else if Strcmp(mm,"SL")==0 then    // Slow relays
      if (l.config & 0x00002000)!=0 extratime=1000
    else if Strcmp(mm,"NC")==0 then    // BEL407-5 only
      if (isnewmeas==0) continue
    else if Strcmp(mm,"N2")==0 then    // BEL407-5 only, 20 kHz filter
      if (isnewmeas==0 || measstat[card,71,0]==50.0) continue
    else if Strcmp(mm,"N5")==0 then    // BEL407-5 only, 50 kHz filter
      if (isnewmeas==0 || measstat[card,71,0]!=50.0) continue
    else if Strcmp(mm,"30")==0 then    // 300 mA add-on
      if measstat[card,72,0]==0 && measstat[card,73,0]==0 &&                   \
      measstat[card,74,0]==0 && measstat[card,75,0]==0 continue
    else if Strcmp(mm,"H5")==0 then    // HV500
      if hvtype==1000 continue
    else if Strcmp(mm,"H1")==0 then    // HV1000
      if hvtype!=1000 continue
    endif
    type=s[TOFFS]
    if istable==1 && (type=='%' || type=='E') then
      // Finish previous table.
      fprintf(f,"\n")
      istable=0
    else if istable==0 &&                                                      \
      (type=='D' || type=='A' || type=='H' || type=='L' || type=='F' ||        \
      type=='X') && (card==0 || (card==1 && nmeascard==2)) then
      // Start new table.
      istable=1
    endif
    if type=='E' then
      // End of drawing
      fprintf(f,"\n")
      break
    else if type=='+' then
      // Select master or slave measurement card.
      if s[TOFFS+1]=='1' then
        card=1
      else
        card=0
      endif
      if nmeascard==1 continue
      if s[TOFFS+2]!='\0' && s[NOMOFFS]!='\0' then
        n=sprintf(tmp,"%s",s+NOMOFFS)
        fprintf(f,"\n")
        for i=0,i<(FX5-n)/2,i++ do fprintf(f," "); enddo
        fprintf(f,"%s\n",tmp)
      endif
    else if card==1 && nmeascard==1 then
      // Skip lines dedicated for slave card if this is unavailable.
      continue
    else if type=='%' then
      // Display line of text.
      center=0; underline=0; linefeed=0; addserial=0
      if s[1]=='0' then                // Initialize table
        n=Strtime(tmp,"%a %d-%b-%Y %H:%M",0,0)
        linefeed=1; addserial=1
      else if s[1]=='B' then           // Bold centered text
        n=sprintf(tmp,"%s",s+NOMOFFS)
        center=1; underline=1; linefeed=1
      else if s[1]=='F' then           // Bold centered text with head
        n=sprintf(tmp,"%s %i (%i%c)",                                          \
        s+NOMOFFS,userhead,userhead/2,userhead & 1?'R':'L')
        center=1; underline=1; linefeed=1
      else if s[1]=='X' then           // Bold centered text with extant
        n=sprintf(tmp,"%s %i",s+NOMOFFS,userhead)
        center=1; underline=1; linefeed=1
      else if s[1]=='E' then           // Bold centered text with ext mux output
        n=sprintf(tmp,"%s module %i : External %i",                            \
          s+NOMOFFS,userhead/2,(userhead & 1)+1)
        center=1; underline=1; linefeed=1
      else if s[1]=='G' then           // Bold centered text with output
        if headstat[card,head,31,1]==0.0 then
          n=sprintf(tmp,"%s %i",s+NOMOFFS,(head<16?head:head-16+half))
        else
          conn=headstat[card,head,31,1]-1.0
          if nmodule==0 then
            n=sprintf(tmp,"%s %i (connectors JP%i, J%i, J%i)",                 \
            s+NOMOFFS,(head<16?head:head-16+half),conn,conn*2+1,conn*2+2)
          else
            n=sprintf(tmp,"%s %i (module %i JP%i, \"%i%s\")",                  \
            s+NOMOFFS,(head<16?head:head-16+half),                             \
            ((conn<half?conn:conn-half)>>2) & 0x3,                             \
            (conn & 0x3)+(conn<half?0:4),                                      \
            ((conn>>1) & 0x1)+(conn<half?0:2),(conn & 1?"R":"L"))
          endif
        endif
        center=1; underline=1; linefeed=1
      else if s[1]=='V' then           // Italic version info
        n=sprintf(tmp,"%s%s",s+NOMOFFS,VERSION)
        center=1
      else if s[1]=='H' then
        if dcwithhv==0 continue
        n=sprintf(tmp,"%s",s+NOMOFFS)
        center=1
      else if s[1]=='N' then           // Italic number of tests
        n=sprintf(tmp,"%s%i",s+NOMOFFS,ntest)
        center=1
      else                             // Italic centered text
        n=sprintf(tmp,"%s",s+NOMOFFS)
        center=1
      endif
      if center then
        for i=0,i<(FX5-n)/2,i++ do fprintf(f," "); enddo
      endif
      fprintf(f,"%s\n",tmp)
      if underline then
        if center then
          for i=0,i<(FX5-n)/2,i++ do fprintf(f," "); enddo
        endif
        for i=0,i<n,i++ do fprintf(f,"-"); enddo
        fprintf(f,"\n")
      endif
      if addserial!=0 && serial[0]!='0' then
        fprintf(f,"Serial number: %s\n",serial)
      endif
      if linefeed fprintf(f,"\n")
    else if type=='D' || type=='A' || type=='H' || type=='L' || type=='F' ||   \
      type=='X' then
      // Display data.
      optional=0
      Memset(buf1,' ',FX5); buf1[FX5]='\0'
      Memset(buf2,' ',FX5); buf2[FX5]='\0'
      ntext=Strcpy(tmp,s+TEXTOFFS)
      if ntext>=FX1-FX0-1 then
        n=FX1-FX0-1
        while (n>0 && tmp[n]!=' ') do n--; enddo
      else
        n=ntext
      endif
      for i=0,i<n,i++ do buf1[FX0+i]=tmp[i]; enddo
      while tmp[n]==' 'do n++; enddo
      for i=n,i<ntext,i++ do buf2[FX0+i-n]=tmp[i]; enddo
      // Get expected signal, deviation and units.
      topmin=-9.9e99; topmax=9.9e99
      if s[NOMOFFS]==' ' then
        goodmin=-1.0e99; goodmax=1.0e99
      else if s[NOMOFFS]=='<' then
        goodmin=-1.0e99
        goodmax=Fnumb(s+NOMOFFS+1)+extratime
        if s[DIFOFFS]=='<' then
          topmax=Fnumb(s+DIFOFFS+1)
        endif
        n=sprintf(tmp," < %g",goodmax); Memcpy(buf1+FX4,tmp,n)
      else if s[NOMOFFS]=='[' then
        goodmin=1.0
        goodmax=Fnumb(s+NOMOFFS+1)+extratime
        if s[DIFOFFS]=='<' then
          topmax=Fnumb(s+DIFOFFS+1)
        endif
        n=sprintf(tmp," < %g",goodmax); Memcpy(buf1+FX4,tmp,n)
      else if s[NOMOFFS]=='?' then
        optional=1
        goodmin=1.0
        goodmax=Fnumb(s+NOMOFFS+1)+extratime
        if s[DIFOFFS]=='<' then
          topmax=Fnumb(s+DIFOFFS+1)
        endif
        n=sprintf(tmp," < %g",goodmax); Memcpy(buf1+FX4,tmp,n)
      else if s[NOMOFFS]=='>' then
        goodmin=Fnumb(s+NOMOFFS+1)
        goodmax=1.0e99
        if s[DIFOFFS]=='>' then
          topmin=Fnumb(s+DIFOFFS+1)
        endif
        n=sprintf(tmp," > %g",goodmin); Memcpy(buf1+FX4,tmp,n)
      else if Memicmp(s+NOMOFFS,"HVMAX",5)==0 then
        r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
        r1=measstat[card,128,2]/ntest
        goodmin=r1-r2; goodmax=r1+r2
        n=sprintf(tmp,"%.1f .. %.1f",goodmin,goodmax); Memcpy(buf1+FX4,tmp,n)
      else if Memicmp(s+NOMOFFS,"HVCUR",5)==0 then
        r1=measstat[card,129,2]/ntest
        if s[DIFOFFS]=='%' then        // Relative deviation in percent
          r2=Fnumb(s+DIFOFFS+1)/100.0*r1
        else
          r2=Fnumb(s+DIFOFFS)          // Absolute deviation from nominal
        endif
        goodmin=r1-r2; goodmax=r1+r2
        n=sprintf(tmp,"%5g .. %5g",goodmin,goodmax); Memcpy(buf1+FX4,tmp,n)
      else if Memicmp(s+NOMOFFS,"CRTMAX",6)==0 then
        r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
        r1=measstat[card,176,2]/ntest
        goodmin=r1-r2; goodmax=r1+r2
        n=sprintf(tmp,"%.1f .. %.1f",goodmin,goodmax); Memcpy(buf1+FX4,tmp,n)
      else
        r1=Fnumb(s+NOMOFFS)            // Nominal value
        r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
        goodmin=r1-r2; goodmax=r1+r2
        n=sprintf(tmp,"%5g .. %5g",goodmin,goodmax); Memcpy(buf1+FX4,tmp,n)
      endif
      // Units of measurement.
      switch s[UOFFS]
      case 'A':                        // Arbitrary units
        Memcpy(buf1+FX3,"a.u.",4)
      case 'B':                        // ADC bits
        Memcpy(buf1+FX3,"bits",4)
      case 'G':                        // Degrees
        Memcpy(buf1+FX3,"deg",3)
      case 'V':                        // Volts
        Memcpy(buf1+FX3,"V",1)
      case 'S':                        // Bits/microsecond
        Memcpy(buf1+FX3,"b/us",4)
      case 'Z':                        // Volts/second
        Memcpy(buf1+FX3,"V/s",3)
      case 'T':                        // Microseconds
        Memcpy(buf1+FX3,"us",2)
      case 'D':                        // Milliseconds
        Memcpy(buf1+FX3,"ms",2)
      case 'O':                        // Ohms
        Memcpy(buf1+FX3,"Ohm",1)
      case 'Q':                        // kOhms
        Memcpy(buf1+FX3,"kOhm",4)
      case 'P':                        // Picofarades
        Memcpy(buf1+FX3,"pF",2)
      case 'I':                        // Milliamperes
        Memcpy(buf1+FX3,"mA",2)
      case 'K':                        // Kiloherz
        Memcpy(buf1+FX3,"kHz",3)
      case '%':                        // Percent
        Memcpy(buf1+FX3,"%",1)
      endsw
      // Get measured signal.
      if grayed then
        Memcpy(buf1+FX1,"   n/a",6)
      else
        i=Inumb(s+TOFFS+1)             // Index of data
        if type=='D' then
          smin=measstat[card,i,0]; smax=measstat[card,i,1]
          smean=measstat[card,i,2]/ntest
        else if type=='A' then
          smin=measstat[card,i+64,0]; smax=measstat[card,i+64,1]
          smean=measstat[card,i+64,2]/ntest
        else if type=='H' then
          smin=measstat[card,i+128,0]; smax=measstat[card,i+128,1]
          smean=measstat[card,i+128,2]/ntest
        else if type=='L' then
          smin=measstat[card,i+192,0]; smax=measstat[card,i+192,1]
          smean=measstat[card,i+192,2]/ntest
        else if type=='X' && i>=64 then
          smin=extrastat[card,i,0]; smax=extrastat[card,i,1]
          smean=extrastat[card,i,2]/ntest
        else if type=='X' then
          smin=extrastat[card,head*10+i,0]; smax=extrastat[card,head*10+i,1]
          smean=extrastat[card,head*10+i,2]/ntest
        else
          smin=headstat[card,head,i,0]; smax=headstat[card,head,i,1]
          smean=headstat[card,head,i,2]/ntest
        endif
        if s[UOFFS]=='Y' then          // Yes or no
          if smin!=smax then
            Memcpy(buf1+FX1," Yes/No  !!!",12)
          else if smin<0.5 then
            Memcpy(buf1+FX1,"    No",6)
          else
            Memcpy(buf1+FX1,"   Yes",6)
          endif
        else if s[UOFFS]=='R' then     // Polarity
          if smin!=smax then
            Memcpy(buf1+FX1," Variable!!!",12)
          else if smin<0 then
            Memcpy(buf1+FX1," HV:PLUS",8)
          else if smin==0 then
            Memcpy(buf1+FX1," Unknown !!!",12)
          else
            Memcpy(buf1+FX1," HV:MINUS",9)
          endif
        else if s[UOFFS]=='0' then     // Adjustment of potentiometer
          n=sprintf(tmp,"%.0f",smean); Memcpy(buf1+FX1,tmp,n)
        else if s[UOFFS]=='1' then     // Adjustment of potentiometer
          n=sprintf(tmp,"%.1f",smean); Memcpy(buf1+FX1,tmp,n)
        else if s[UOFFS]=='2' then     // Adjustment of potentiometer
          n=sprintf(tmp,"%.2f",smean); Memcpy(buf1+FX1,tmp,n)
        else if s[UOFFS]=='3' then     // Adjustment of potentiometer
          n=sprintf(tmp,"%.3f",smean); Memcpy(buf1+FX1,tmp,n)
        else if s[UOFFS]=='+' then     // Adjustment of potentiometer
          n=sprintf(tmp,"%.2f",smean); Memcpy(buf1+FX1,tmp,n)
        else
          n=Printminmax(tmp,smin,smax,smean,drawmean); Memcpy(buf1+FX1,tmp,n)
          if (smin<goodmin || smax>goodmax) then
            if optional && smin==0.0 && smax==0.0 then
              Memcpy(buf1+(FX2-4),"OPT",3)
            else
              Memcpy(buf1+(FX2-4),"!!!",3)
            endif
          endif
        endif
      endif
      // Check if second component available.
      if s[TOFFS+3]=='+' && s[UOFFS]!='Y' then
        line++; Memcpy(s,data+line*NCHAR,NCHAR)
        topmin=-9.9e99; topmax=9.9e99
        if s[NOMOFFS]==' ' then
          goodmin=-1.0e99; goodmax=1.0e99
        else if s[NOMOFFS]=='<' then
          goodmin=-1.0e99
          goodmax=Fnumb(s+NOMOFFS+1)+extratime
          if s[DIFOFFS]=='<' then
            topmax=Fnumb(s+DIFOFFS+1)
          endif
          n=sprintf(tmp," < %g",goodmax); Memcpy(buf2+FX4,tmp,n)
        else if s[NOMOFFS]=='[' || s[NOMOFFS]=='?' then
          goodmin=1.0
          goodmax=Fnumb(s+NOMOFFS+1)+extratime
          if s[DIFOFFS]=='<' then
            topmax=Fnumb(s+DIFOFFS+1)
          endif
          n=sprintf(tmp," < %g",goodmax); Memcpy(buf2+FX4,tmp,n)
        else if s[NOMOFFS]=='>' then
          goodmin=Fnumb(s+NOMOFFS+1)
          goodmax=1.0e99
          if s[DIFOFFS]=='>' then
            topmin=Fnumb(s+DIFOFFS+1)
          endif
          n=sprintf(tmp," > %g",goodmin); Memcpy(buf2+FX4,tmp,n)
        else if Memicmp(s+NOMOFFS,"HVMAX",5)==0 then
          r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
          r1=measstat[card,128,2]/ntest
          goodmin=r1-r2; goodmax=r1+r2
          n=sprintf(tmp,"%.1f .. %.1f",goodmin,goodmax); Memcpy(buf2+FX4,tmp,n)
        else if Memicmp(s+NOMOFFS,"HVCUR",5)==0 then
          r1=measstat[card,129,2]/ntest
          if s[DIFOFFS]=='%' then        // Relative deviation in percent
            r2=Fnumb(s+DIFOFFS+1)/100.0*r1
          else
            r2=Fnumb(s+DIFOFFS)          // Absolute deviation from nominal
          endif
          goodmin=r1-r2; goodmax=r1+r2
          n=sprintf(tmp,"%5g .. %5g",goodmin,goodmax); Memcpy(buf2+FX4,tmp,n)
        else if Memicmp(s+NOMOFFS,"CRTMAX",6)==0 then
          r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
          r1=measstat[card,176,2]/ntest
          goodmin=r1-r2; goodmax=r1+r2
          n=sprintf(tmp,"%.1f .. %.1f",goodmin,goodmax); Memcpy(buf2+FX4,tmp,n)
        else
          r1=Fnumb(s+NOMOFFS)            // Nominal value
          r2=Fnumb(s+DIFOFFS)            // Allowed deviation from nominal
          goodmin=r1-r2; goodmax=r1+r2
          n=sprintf(tmp,"%5g .. %5g",goodmin,goodmax); Memcpy(buf2+FX4,tmp,n)
        endif
        if grayed==0 then
          i=Inumb(s+TOFFS+1)           // Index of cosine data
          if type=='D' then
            smin=measstat[card,i,0]; smax=measstat[card,i,1]
            smean=measstat[card,i,2]/ntest
          else if type=='A' then
            smin=measstat[card,i+64,0]; smax=measstat[card,i+64,1]
            smean=measstat[card,i+64,2]/ntest
          else if type=='H' then
            smin=measstat[card,i+128,0]; smax=measstat[card,i+128,1]
            smean=measstat[card,i+128,2]/ntest
          else if type=='L' then
            smin=measstat[card,i+192,0]; smax=measstat[card,i+192,1]
            smean=measstat[card,i+192,2]/ntest
          else if type=='X' && i>=64 then
            smin=extrastat[card,i,0]; smax=extrastat[card,i,1]
            smean=extrastat[card,i,2]/ntest
          else if type=='X' then
            smin=extrastat[card,head*10+i,0]; smax=extrastat[card,head*10+i,1]
            smean=extrastat[card,head*10+i,2]/ntest
          else
            smin=headstat[card,head,i,0]; smax=headstat[card,head,i,1]
            smean=headstat[card,head,i,2]/ntest
          endif
          n=Printminmax(tmp,smin,smax,smean,drawmean); Memcpy(buf2+FX1,tmp,n)
          if (smin<goodmin || smax>goodmax) then
            if optional && smin==0.0 && smax==0.0 then
              Memcpy(buf1+(FX2-4),"OPT",3)
            else
              Memcpy(buf1+(FX2-4),"!!!",3)
            endif
          endif
        endif
      endif
      for i=FX5-1,i>=0,i-- do
        if buf1[i]!=' ' break
      enddo
      buf1[i+1]='\0'
      fprintf(f,"\n%s\n",buf1)
      for i=FX5-1,i>=0,i-- do
        if buf2[i]!=' ' break
      enddo
      if i>0 then
        buf2[i+1]='\0'
        fprintf(f,"%s\n",buf2)
      endif
    endif
  enddo
end

// Writes relays-related data to file in Excel-compatible text format.
// Parameter type determines kind of connector: 0 - real head, 1 - connector,
// 2 - real external antenna.
function int Printrelay(handle f,char *data,int card,int head,                 \
  int index,int type)
  int i,n,line
  char s[NCHAR]
  float rmin,rmean,rmax
  if f==NULL || ntest==0 return        // Nothing to do
  for line=0,1,line++ do
    Memcpy(s,data+line*NCHAR,NCHAR)
    if s[0]=='E' break
    if nmeascard==1 then               // Print explanation
      fprintf(f,"%s",s+30)
    else if card==0 then
      fprintf(f,"Master %s",s+30)
    else
      fprintf(f,"Slave %s",s+30)
    endif
    if s[0]=='M' then
      if type==0 then                  // Real head
        fprintf(f," at %i%c",head/2,(head & 1?'R':'L'))
      else if type==1 then             // Connector in full test
        fprintf(f," at JP%i",(head<16?head:head-16+half))
      else                             // Real external antenna
        fprintf(f," at antenna %i",head)
      endif
    endif
    for i=0,i<6,i++ do
      if s[i*5]!='A' && s[i*5]!='M' && s[i*5]!='X' break
      n=(s[i*5+1]-'0')*10+s[i*5+2]-'0'
      if s[i*5]=='A' then              // Relay on the measurement card
        rmin=measstat[card,n+64,0]
        rmax=measstat[card,n+64,1]
        rmean=measstat[card,n+64,2]/ntest
      else if s[i*5]=='X' then         // Relay on the measurement card in ext
        rmin=extrastat[card,n,0]
        rmax=extrastat[card,n,1]
        rmean=extrastat[card,n,2]/ntest
      else                             // Relay on the multiplexer card
        rmin=headstat[card,index,n,0]
        rmax=headstat[card,index,n,1]
        rmean=headstat[card,index,n,2]/ntest
      endif
      if s[i*5+3]=='<' then
        fprintf(f,"\t%g",rmin)
      else if s[i*5+3]=='>' then
        fprintf(f,"\t%g",rmax)
      else
        fprintf(f,"\t%g",rmean)
      endif
    enddo
    fprintf(f,"\n")
  enddo
end

float k80k111xy[32][4] = {           \ // X, Y, rotated, index in measstat
  { 232.00, 30.59, 0,  -1 },         \ // K80
  { 232.00, 58.17, 0,  -1 },         \ // K81
  { 232.00, 44.38, 0,  -1 },         \ // K82
  { 232.00, 71.97, 0,  -1 },         \ // K83
  { 232.00, 23.69, 0,  58 },         \ // K84
  { 232.00, 16.79, 0,  48 },         \ // K85
  { 309.00, 19.00, 1,  56 },         \ // K86
  { 317.00, 22.00, 1,  54 },         \ // K87
  { 293.00, 53.00, 1,  -1 },         \ // K88
  { 300.00, 53.00, 1,  -1 },         \ // K89
  { 293.00, 22.00, 1,  -1 },         \ // K90
  { 300.00, 22.00, 1,  -1 },         \ // K91
  { 232.00, 37.48, 0,  32 },         \ // K92
  { 232.00, 65.07, 0,  36 },         \ // K93
  { 232.00, 51.28, 0,  34 },         \ // K94
  { 232.00, 78.86, 0,  38 },         \ // K95
  { 264.00, 30.59, 0,  40 },         \ // K96
  { 264.00, 58.17, 0,  44 },         \ // K97
  { 264.00, 44.38, 0,  42 },         \ // K98
  { 264.00, 71.97, 0,  46 },         \ // K99
  { 264.00, 23.69, 0,  -1 },         \ // K100
  { 264.00, 16.79, 0, 322 },         \ // K101 (extrastat+66)
  { 264.00,  9.90, 0,  -1 },         \ // K102
  { 264.00,  3.00, 0, 324 },         \ // K103 (extrastat+68)
  { 264.00, 37.48, 0,  60 },         \ // K104
  { 264.00, 51.28, 0, 320 },         \ // K105 (extrastat+64)
  { 264.00, 65.07, 0,  -1 },         \ // K106
  { 264.00, 78.86, 0,  22 },         \ // K107
  { 311.00, 86.00, 1,  -1 },         \ // K108
  { 303.00, 86.00, 1,  62 },         \ // K109
  { 232.00,  3.00, 0,  50 },         \ // K110
  { 232.00,  9.90, 0,  52 } }        \ // K111

float k80k111xynew[33][4] = {        \ // X, Y, rotated, index in measstat
  { 250.00, 57.50, 0,  -1 },         \ // K80
  { 250.00, 50.00, 0,  -1 },         \ // K81
  { 250.00, 42.50, 0,  -1 },         \ // K82
  { 250.00, 35.00, 0,  -1 },         \ // K83
  { 250.00, 87.60, 0,  58 },         \ // K84
  { 250.00, 80.00, 0,  48 },         \ // K85
  { 250.00, 27.50, 0,  56 },         \ // K86
  { 277.50, 27.50, 0,  54 },         \ // K87
  { 277.50, 19.90, 0,  -1 },         \ // K88
  { 250.00, 19.90, 0,  -1 },         \ // K89
  { 305.00, 65.00, 0,  -1 },         \ // K90
  { 305.00, 72.50, 0,  -1 },         \ // K91
  { 277.50, 57.50, 0,  32 },         \ // K92
  { 277.50, 50.00, 0,  36 },         \ // K93
  { 277.50, 42.50, 0,  34 },         \ // K94
  { 277.50, 35.00, 0,  38 },         \ // K95
  { 305.00, 57.50, 0,  40 },         \ // K96
  { 305.00, 50.00, 0,  44 },         \ // K97
  { 305.00, 42.50, 0,  42 },         \ // K98
  { 305.00, 35.00, 0,  46 },         \ // K99
  { 305.00, 95.20, 0,  -1 },         \ // K100
  { 277.50, 87.60, 0, 322 },         \ // K101 (extrastat+66)
  { 277.50, 95.20, 0,  -1 },         \ // K102
  { 305.00, 87.60, 0, 324 },         \ // K103 (extrastat+68)
  { 277.50, 80.00, 0,  60 },         \ // K104
  { 305.00, 27.50, 0, 320 },         \ // K105 (extrastat+64)
  { 305.00, 80.00, 0,  -1 },         \ // K106
  { 277.50, 72.50, 0,  22 },         \ // K107
  { 250.00, 95.20, 0,  -1 },         \ // K108
  { 277.50, 65.00, 0,  62 },         \ // K109
  { 250.00, 65.00, 0,  50 },         \ // K110
  { 250.00, 72.50, 0,  52 },         \ // K111
  { 305.00, 19.90, 0,  -1 } }        \ // K112 (spare)

float larelayxy[8][4] = {            \ // X, Y, rotated, index in measstat
  { 229.00, 64.00, 0,  -1 },         \ // K32
  { 229.00, 45.00, 0,  -1 },         \ // K33
  { 216.00, 64.00, 0,  -1 },         \ // K34
  { 216.00, 45.00, 0,  -1 },         \ // K35
  { 255.00, 64.00, 0,  -1 },         \ // K36
  { 242.00, 64.00, 0,  -1 },         \ // K37
  { 242.00, 45.00, 0,  -1 },         \ // K38
  { 255.00, 45.00, 0,  -1 } }        \ // K39

// Given K-index of the reed relay on the multiplexer card, returns its
// coordinates in pixels (x0,y0,x1,y1).
function int Getrelayrect(int kindex,int *xy)
  int m
  if kindex>=128 then
    // Pseudoindices for modular multiplexer.
    kindex=kindex-128
    m=kindex/80; kindex=kindex-m*80
    if m>=nmodule || (kindex>=32 && kindex<64) || kindex>=72 then
      xy[0]=0; xy[1]=0; xy[2]=0; xy[3]=0
    else
      if kindex>=64 kindex=(kindex-32)^0x4
      xy[0]=MUXX0+(175.0*m+(kindex/8)*27.0+22.0)*MUXSCALE
      xy[1]=MUXY0+(((kindex & 3)*2+(kindex & 4)/4)*7.6+47.0)*MUXSCALE
      xy[2]=xy[0]+20.0*MUXSCALE
      xy[3]=xy[1]+6.0*MUXSCALE
    endif
  else if kindex<0 || kindex>=(isnewmeas?113:112) then
    // Invalid index.
    xy[0]=0; xy[1]=0; xy[2]=0; xy[3]=0
  else if kindex<64 then
    // Relays K0..K63, connect on-heads to analog buses.
    xy[0]=MUXX0+((kindex & 0x20?60.0:28.0)+((kindex & 0x1F)/8)*64.0)*MUXSCALE
    xy[1]=MUXY0+((kindex & 0x4?54.5:47.0)+(kindex & 0x03)*15.2)*MUXSCALE
    xy[2]=xy[0]+20.0*MUXSCALE
    xy[3]=xy[1]+6.0*MUXSCALE
  else if kindex>=64 && kindex<80 then
    // Relays K64..K79, connect temperature sensor, ext devices and antennas.
    xy[0]=MUXX0+(kindex<72?283.0:315.0)*MUXSCALE
    xy[1]=MUXY0+((kindex & 0x4?47.0:54.5)+(kindex & 0x03)*15.2)*MUXSCALE
    xy[2]=xy[0]+20.0*MUXSCALE
    xy[3]=xy[1]+6.0*MUXSCALE
  else if isnewmeas==0 && kindex>=80 && kindex<112 then
    // Relays on older measurement card. No obvious order, use table.
    xy[0]=MUXX0+k80k111xy[kindex-80][0]*MUXSCALE
    xy[1]=MUXY0+k80k111xy[kindex-80][1]*MUXSCALE
    if k80k111xy[kindex-80][2]==0 then
      xy[2]=xy[0]+20.0*MUXSCALE
      xy[3]=xy[1]+6.0*MUXSCALE
    else
      xy[2]=xy[0]+6.5*MUXSCALE         // Better optics
      xy[3]=xy[1]+19.0*MUXSCALE
    endif
  else if isnewmeas==1 && kindex>=80 && kindex<113 then
    // Relays on new measurement card. No obvious order, use table.
    xy[0]=MUXX0+k80k111xynew[kindex-80][0]*MUXSCALE
    xy[1]=MUXY0+k80k111xynew[kindex-80][1]*MUXSCALE
    if k80k111xynew[kindex-80][2]==0 then
      xy[2]=xy[0]+20.0*MUXSCALE
      xy[3]=xy[1]+6.0*MUXSCALE
    else
      xy[2]=xy[0]+6.5*MUXSCALE         // Better optics
      xy[3]=xy[1]+19.0*MUXSCALE
    endif
  endif
end

// Given K-index of the reed relay on the LATEST card, returns its coordinates
// in pixels (x0,y0,x1,y1).
function int Getlarelayrect(int kindex,int *xy)
  int m
  if kindex>=128 then
    // Pseudoindices for modular LATEST multiplexer.
    kindex=kindex-128
    m=kindex/80; kindex=kindex-m*80
    if m>=nmodule || kindex>=16 then
      xy[0]=0; xy[1]=0; xy[2]=0; xy[3]=0
    else
      xy[0]=MUXX0+                                                             \
        (175.0*m+((kindex & 2)+(kindex/4)*8-(kindex/8)*12)*6.75+22.0)*MUXSCALE
      xy[1]=MUXY0+((kindex & 1)*15.0+54.0)*MUXSCALE
      xy[2]=xy[0]+7.0*MUXSCALE
      xy[3]=xy[1]+12.0*MUXSCALE
    endif
  else if kindex<0 || kindex>=40 then
    xy[0]=0; xy[1]=0; xy[2]=0; xy[3]=0
  else if kindex<32 then
    // Relays K0..K31, connect on-heads to LATEST buses.
    xy[0]=MUXX0+((kindex & 0x1?0.0:13.0)+(kindex & 0x10?34.0:8.0)+             \
      ((kindex>>2) & 0x3)*52.0)*MUXSCALE
    xy[1]=MUXY0+(kindex & 0x2?64.0:45.0)*MUXSCALE
    xy[2]=xy[0]+10.0*MUXSCALE
    xy[3]=xy[1]+16.0*MUXSCALE
  else
    // No obvious order, use table.
    xy[0]=MUXX0+larelayxy[kindex-32][0]*MUXSCALE
    xy[1]=MUXY0+larelayxy[kindex-32][1]*MUXSCALE
    xy[2]=xy[0]+10.0*MUXSCALE
    xy[3]=xy[1]+16.0*MUXSCALE
  endif
end

// Given J-index of the BNC connector on the multiplexer card with 16 outputs,
// returns its coordinates in pixels (x0,y0,x1,y1).
function int Getbncrect(int jindex,int *xy)
  int j
  float ext[16,2] = {                                                          \
    { 27.0, 281.0 }, {  7.0, 281.0 }, { 17.0, 297.0 }, { 37.0, 297.0 },        \
    { 37.0, 281.0 }, { 17.0, 281.0 }, {  7.0, 297.0 }, { 27.0, 297.0 },        \
    { 27.0, 328.5 }, {  7.0, 328.5 }, { 17.0, 313.5 }, { 37.0, 313.5 },        \
    { 37.0, 328.5 }, { 17.0, 328.5 }, {  7.0, 313.5 }, { 27.0, 313.5 } }
  float laext[4,2] = {                                                         \
    { 57.0, 279.0 }, { 47.0, 269.0 }, { 57.0, 269.0 }, { 47.0, 279.0 } }
  if jindex<1 || jindex>52 then
    xy[0]=0; xy[1]=0; xy[2]=0; xy[3]=0
  else if jindex<=32 then
    // Connectors J1..J32, connect on-heads to analog buses.
    j=jindex-1                         // 0..31
    xy[0]=MUXX0+((j & 0x10?57.0:25.0)+(j & 0x0C)*16.0+(j & 0x01)*17.5)*MUXSCALE
    xy[1]=MUXY0+(j & 0x02?37.0:27.0)*MUXSCALE
    xy[2]=xy[0]+7.5*MUXSCALE
    xy[3]=xy[1]+7.5*MUXSCALE
  else if jindex<=48 then
    // Connectors J33..J48, connect temp sensor, ext devices and antennas.
    j=jindex-33
    xy[0]=MUXX0+ext[j,1]*MUXSCALE
    xy[1]=MUXY0+ext[j,0]*MUXSCALE
    xy[2]=xy[0]+7.5*MUXSCALE
    xy[3]=xy[1]+7.5*MUXSCALE
  else
    // Connectors J49..J52 on LATEST card
    j=jindex-49
    xy[0]=MUXX0+laext[j,1]*MUXSCALE
    xy[1]=MUXY0+laext[j,0]*MUXSCALE
    xy[2]=xy[0]+7.5*MUXSCALE
    xy[3]=xy[1]+7.5*MUXSCALE
  endif
end

// Given relay pseudoindex, returns coordinates of the BNC connector on the
// modular multiplexer card.
function int Getmodularbncrect(int kindex,int *xy)
  int m
  kindex=kindex-128
  m=kindex/80; kindex=kindex-m*80
  if m<0 || m>=nmodule || (kindex>=32 && kindex<64) || kindex>=72 then
    xy[0]=0; xy[1]=0; xy[2]=0; xy[3]=0
  else if kindex<32 then
    kindex=kindex & 0xFFFFFFFE
    xy[0]=MUXX0+(175.0*m+(kindex/8)*27.0-(kindex & 2)*6.0+34.0)*MUXSCALE
    xy[1]=MUXY0+((kindex & 4)*2.2+24.0)*MUXSCALE
    xy[2]=xy[0]+7.5*MUXSCALE
    xy[3]=xy[1]+7.5*MUXSCALE
  else
    xy[0]=MUXX0+(175.0*m+(kindex & 1)*12.0+138.0)*MUXSCALE
    xy[1]=MUXY0+((kindex & 6)*4.4+6.4)*MUXSCALE
    xy[2]=xy[0]+7.5*MUXSCALE
    xy[3]=xy[1]+7.5*MUXSCALE
  endif
end

// Given JP-index of the connector on the multiplexer card, returns its
// coordinates in pixels (x0,y0,x1,y1).
function int Getconnrect(int jpindex,int *xy)
  if jpindex<0 || jpindex>=16 then
    xy[0]=0; xy[1]=0; xy[2]=0; xy[3]=0
  else
    xy[0]=MUXX0+(41.0+(jpindex & 0x07)*37.5)*MUXSCALE
    xy[1]=MUXY0+(jpindex & 0x08?147.5:160.5)*MUXSCALE
    xy[2]=xy[0]+28.0*MUXSCALE
    xy[3]=xy[1]+9.0*MUXSCALE
  endif
end

// Given relay pseudoindex, returns coordinates of the connector on the modular
// multiplexer card.
function int Getmodularconnrect(int kindex,int *xy)
  int m
  kindex=kindex-128
  m=kindex/80; kindex=kindex-m*80
  if m<0 || m>=nmodule || kindex>=32 then
    xy[0]=0; xy[1]=0; xy[2]=0; xy[3]=0
  else
    xy[0]=MUXX0+                                                               \
      (175.0*m+((kindex>>2) & 1)*43.0+((kindex>>4) & 1)*86.0+10.0)*MUXSCALE
    xy[1]=MUXY0+(kindex & 0x08?149.5:162.5)*MUXSCALE
    xy[2]=xy[0]+28.0*MUXSCALE
    xy[3]=xy[1]+9.0*MUXSCALE
  endif
end

// Fills relay descriptors and checks limits (good/warning/bad) of measurements.
function int Processmuxdata(int burnin,int testmeas,int testhv)
  int i,j,k,m,line,type,extratime,module,relay,head
  float smin1,smax1,smin2,smax2
  float greenmin,greenmax,yellowmin,yellowmax,diffmin,diffmax
  char s[256],mm[3]
  Memset(rd,0,Sizeof(rd))
  for i=0,i<368,i++ do
    rd[i].module=-1
    rd[i].head=-1
    rd[i].extant=-1
    rd[i].extraout=-1
    rd[i].connector=-1
    rd[i].tsensor=-1
    rd[i].meascard=-1
    rd[i].measindex=-1
    rd[i].extraindex=-1
  enddo
  // Fill data for ordinary head connectors.
  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
    // Modular multiplexer.
    for module=0,module<nmodule,module++ do
      for i=0,i<32,i++ do
        relay=128+module*80+i
        rd[relay].module=module
        rd[relay].connector=((i & 0x04)>>2)+((i & 0x10)>>3)+((i & 0x08)>>1)
        rd[relay].jindex=(i/4)*2
      enddo
    enddo
    for i=0,i<32,i++ do
      k=headstat[0,i,31,1]-1             // Real output
      if k<0 continue
      module=(k/4)%nmodule
      if k<nmodule*4 then
        k=k-module*4
        relay=128+module*80+k*4+(k & 2)*4
      else
        k=k-(module+nmodule-1)*4
        relay=128+module*80+k*4+(k & 2)*4-8
      endif
      head=headstat[0,i,63,1]-1
      if head>=16 head=head-16+l.nfing
      for j=0,j<4,j++ do
        rd[relay+j].head=head
        if fulltest || head<l.nfing*2 rd[relay+j].valid=1
        rd[relay+j].dataindex=i
      enddo
    enddo
    // Fill data for temperature sensor and external antennas, if any.
    for i=0,i<2*nmodule,i++ do
      type=($int4(lx+674)>>(3*i)) & 0x07
      relay=128+(i/2)*80+64+(i & 1)*4
      if type==MUXEXT_TSENS then
        for j=0,j<4,j++ do
          rd[relay+j].tsensor=1
          rd[relay+j].dataindex=0
          rd[relay+j].measindex=j*2+64
          rd[relay+j].valid=1
        enddo
      else if type==MUXEXT_ANT1 && ((lx.extant & 1)!=0 || fulltest) then
        for j=0,j<4,j++ do
          rd[relay+j].extant=0
          rd[relay+j].dataindex=(fulltest?15:l.nfing*2)
          rd[relay+j].valid=1
        enddo
      else if type==MUXEXT_ANT2 && ((lx.extant & 2)!=0 || fulltest) then
        for j=0,j<4,j++ do
          rd[relay+j].extant=((lx.extant & 1)==0 && fulltest==0?0:1)
          rd[relay+j].dataindex=(fulltest?31:l.nfing*2+1)
          rd[relay+j].valid=1
        enddo
      else if type==MUXEXT_SHORT && fulltest!=0 && (features & 0x8)!=0 then
        for j=0,j<4,j++ do
          rd[relay+j].extraout=i
          rd[relay+j].dataindex=i*10+j*2
          rd[relay+j].extraindex=i*10+8+(j/2)
          rd[relay+j].valid=1
        enddo
      endif
    enddo
  else
    // Multiplexer with 16 outputs.
    for i=0,i<64,i++ do
      rd[i].connector=i/4
      rd[i].jindex=(i/4)*2+1             // J-index of first BNC connector
    enddo
    for i=0,i<32,i++ do
      k=headstat[0,i,31,1]-1             // Real output
      if k<0 continue
      for j=0,j<4,j++ do
        if k<8 then
          head=0                         // Head on the top side
          for m=0,m<l.nfing*2,m++ do
            if l.side[m/2]!=0 continue
            if head==k break
            head++
          enddo
        else
          head=8                         // Head on the bottom side
          for m=0,m<l.nfing*2,m++ do
            if l.side[m/2]==0 continue
            if head==k break
            head++
          enddo
        endif
        if m<l.nfing*2 rd[k*4+j].head=m
        if fulltest || i<l.nfing*2 rd[k*4+j].valid=1
        rd[k*4+j].dataindex=i
      enddo
    enddo
    // Fill data for temperature sensor.
    for j=0,j<4,j++ do
      rd[64+j].tsensor=1
      rd[64+j].dataindex=0
      rd[64+j].measindex=j*2+64
      rd[64+j].valid=1
    enddo
    // Fill data for external antennas.
    if (lx.extant & 1)!=0 || fulltest then
      for j=0,j<4,j++ do
        rd[72+j].extant=0
        rd[72+j].valid=1
        rd[72+j].dataindex=(fulltest?15:l.nfing*2)
      enddo
    endif
    if (lx.extant & 2)!=0 || fulltest then
      for j=0,j<4,j++ do
        rd[76+j].extant=((lx.extant & 1)==0 && fulltest==0?0:1)
        rd[76+j].valid=1
        rd[76+j].dataindex=(fulltest?31:l.nfing*2+1)
      enddo
    endif
  endif
  // Fill data for relays on measurement card.
  if (isnewmeas) then
    for i=80,i<113,i++ do
      rd[i].meascard=1
      if k80k111xynew[i-80][3]>=256 then
        rd[i].extraindex=k80k111xynew[i-80][3]-256
        rd[i].valid=1
      else if k80k111xynew[i-80][3]>0 then
        rd[i].measindex=k80k111xynew[i-80][3]
        rd[i].valid=1
      endif
    enddo
  else
    for i=80,i<112,i++ do
      rd[i].meascard=1
      if k80k111xy[i-80][3]>=256 then
        rd[i].extraindex=k80k111xy[i-80][3]-256
        rd[i].valid=1
      else if k80k111xy[i-80][3]>0 then
        rd[i].measindex=k80k111xy[i-80][3]
        rd[i].valid=1
      endif
    enddo
  endif
  if ntest==0 return
  // Here limit checking starts.
  for i=0,i<368,i++ do
    j=rd[i].dataindex
    for line=0,1,line++ do
      if rd[i].valid==0 then
        break
      else if rd[i].head>=0 then
        Memcpy(s,showmuxhead[line],NCHAR)
      else if rd[i].extant>=0 then
        Memcpy(s,showmuxant[line],NCHAR)
      else if rd[i].connector>=0 then
        Memcpy(s,showmuxconn[line],NCHAR)
      else if rd[i].tsensor>=0 then
        Memcpy(s,showmuxtsens[line],NCHAR)
      else if rd[i].extraout>=0 then
        Memcpy(s,showmuxext[line],NCHAR)
      else if rd[i].meascard>=0 then
        Memcpy(s,showmeascard[line],NCHAR)
      else
        break
      endif
      extratime=0
      // Modifiers are a kind of conditional operators, check if any.
      mm[0]=s[MMOMUX]; mm[1]=s[MMOMUX+1]; mm[2]='\0'
      if Strcmp(mm,"10")==0 then       // Disable line if HVCUR=10 mA
        if (ntest>0 && measstat[0,129,1]==1.0) continue
      else if Strcmp(mm,"SP")==0 then  // Kelvin probe only
        if (l.probetype & 0x1)==0 continue
      else if Strcmp(mm,"NS")==0 then  // Non-Kelvin probe only
        if (l.probetype & 0x1)!=0 continue
      else if Strcmp(mm,"SL")==0 then  // Slow relays
        if (l.config & 0x00002000)!=0 extratime=1000
      else if Strcmp(mm,"NC")==0 then  // BEL407-5 only
        if (isnewmeas==0) continue
      else if Strcmp(mm,"N2")==0 then  // BEL407-5 only, 20 kHz filter
        if (isnewmeas==0 || measstat[0,71,0]==50.0) continue
      else if Strcmp(mm,"N5")==0 then  // BEL407-5 only, 50 kHz filter
        if (isnewmeas==0 || measstat[0,71,0]!=50.0) continue
      else if Strcmp(mm,"30")==0 then  // 300 mA add-on
        if measstat[0,72,0]==0 && measstat[0,73,0]==0 &&                       \
        measstat[0,74,0]==0 && measstat[0,75,0]==0 continue
      else if Strcmp(mm,"H5")==0 then  // HV500
        if hvtype==1000 continue
      else if Strcmp(mm,"H1")==0 then  // HV1000
        if hvtype!=1000 continue
      endif
      // Get measured signal.
      type=s[TOMUX]
      k=Inumb(s+TOMUX+1)               // Index of data
      if type=='E' then
        break
      else if type=='R' then
        if testmeas==0 continue
        smin1=headstat[0,j,(i%4)*2+k,0]
        smin2=headstat[1,j,(i%4)*2+k,0]
        smax1=headstat[0,j,(i%4)*2+k,1]
        smax2=headstat[1,j,(i%4)*2+k,1]
      else if type=='F' then
        if testmeas==0 continue
        smin1=headstat[0,j,k,0]
        smin2=headstat[1,j,k,0]
        smax1=headstat[0,j,k,1]
        smax2=headstat[1,j,k,1]
      else if type=='P' then
        if testmeas==0 continue
        smin1=headstat[0,j,((i/2) & 1)+k,0]
        smin2=headstat[1,j,((i/2) & 1)+k,0]
        smax1=headstat[0,j,((i/2) & 1)+k,1]
        smax2=headstat[1,j,((i/2) & 1)+k,1]
      else if type=='B' then
        if burnin==0 continue
        smin1=headstat[0,j,((i/2) & 1)+k,0]
        smin2=headstat[1,j,((i/2) & 1)+k,0]
        smax1=headstat[0,j,((i/2) & 1)+k,1]
        smax2=headstat[1,j,((i/2) & 1)+k,1]
      else if type=='A' then
        if testmeas==0 continue
        smin1=measstat[0,rd[i].measindex+k,0]
        smin2=measstat[1,rd[i].measindex+k,0]
        smax1=measstat[0,rd[i].measindex+k,1]
        smax2=measstat[1,rd[i].measindex+k,1]
      else if type=='V' then
        if testhv==0 continue
        smin1=headstat[0,j,((i/2) & 1)+k,0]
        smin2=headstat[1,j,((i/2) & 1)+k,0]
        smax1=headstat[0,j,((i/2) & 1)+k,1]
        smax2=headstat[1,j,((i/2) & 1)+k,1]
      else if type=='L' then
        if testmeas==0 continue
        if rd[i].extraindex!=k && rd[i].extraindex+1!=k continue
        smin1=extrastat[0,k,0]
        smin2=extrastat[1,k,0]
        smax1=extrastat[0,k,1]
        smax2=extrastat[1,k,1]
      else if type=='M' then
        if testmeas==0 continue
        if rd[i].measindex!=k && rd[i].measindex+1!=k continue
        smin1=measstat[0,64+k,0]
        smin2=measstat[1,64+k,0]
        smax1=measstat[0,64+k,1]
        smax2=measstat[1,64+k,1]
      else if type=='X' then
        if testmeas==0 continue
        smin1=extrastat[0,rd[i].dataindex+k,0]
        smin2=extrastat[1,rd[i].dataindex+k,0]
        smax1=extrastat[0,rd[i].dataindex+k,1]
        smax2=extrastat[1,rd[i].dataindex+k,1]
      else if type=='Y' then
        if testmeas==0 continue
        smin1=extrastat[0,rd[i].extraindex+k,0]
        smin2=extrastat[1,rd[i].extraindex+k,0]
        smax1=extrastat[0,rd[i].extraindex+k,1]
        smax2=extrastat[1,rd[i].extraindex+k,1]
      else if type=='N' then
        continue
      else if type=='O' then
        continue
      else if type=='T' then
        continue
      else if type=='U' then
        continue
      endif
      // Get good and warn signal limits.
      greenmin=Fnumb(s+GMINMUX)
      greenmax=Fnumb(s+GMAXMUX)
      yellowmin=Fnumb(s+YMINMUX)
      yellowmax=Fnumb(s+YMAXMUX)
      diffmin=Fnumb(s+DMINMUX)
      diffmax=Fnumb(s+DMAXMUX)
      // Correct limits if acceleration is turned off.
      if (lx.measopt & HCM_NOACCEL)!=0 then
        if (type=='A' || type=='M' || type=='R') && greenmin>1.0 then
          greenmax=greenmax*2
          yellowmax=yellowmax*2
          diffmin=diffmin*2
          diffmax=diffmax*2
        endif
      endif
      // Check limits.
      if nmeascard==1 then
        smin2=smin1
        smax2=smax1
      endif
      if s[UOMUX]=='?' &&                                                      \
        smin1==0.0 && smin2==0.0 && smax1==0.0 && smax2==0.0 then
        rd[i].badlevel=-1              // Not connected
      else if smin1<yellowmin || smin2<yellowmin ||                            \
        smax1>yellowmax || smax2>yellowmax ||                                  \
        smax1-smin1>diffmax || smax2-smin2>diffmax then
        rd[i].badlevel=2
        break                          // Don't do unnecessary analysis
      else if rd[i].badlevel==0 &&                                             \
        (smin1<greenmin || smin2<greenmin ||                                   \
        smax1>greenmax || smax2>greenmax ||                                    \
        smax1-smin1>diffmin || smax2-smin2>diffmin) then
        rd[i].badlevel=1
      endif
    enddo
  enddo
end

// Draws multiplexer.
function int Drawmuxdata(int meas,int relay,int burnin,int testmeas,int testhv)
  int i,j,k,m,n,ntitle,y,line,type,xy[4],extratime
  int optional,card,firstprint,module
  char title[256],s[256],text[256],mm[3],slow[32],shigh[32]
  float smin,smax,greenmin,greenmax,yellowmin,yellowmax
  float diffmin,diffmax,displmax
  draw window=hmux color=WHITE bkcolor=WHITE clear
  if meas then
    // Measurement card. Draw background.
    draw color=BLACK bkcolor=WHITEGREEN
    draw at MUXX0+6.0*MUXSCALE,MUXY0
    draw fillrect MUXX0+343.0*MUXSCALE,MUXY0+175.0*MUXSCALE
    draw color=BLACK bkcolor=LIGHTGRAY mode=M_LEFT
    draw at MUXX0+337.0*MUXSCALE,MUXY0+48.0*MUXSCALE
    draw fillrect MUXX0+348.0*MUXSCALE,MUXY0+140.0*MUXSCALE
    if (isnewmeas) then
      draw at MUXX0+250.0*MUXSCALE,MUXY0+15.0*MUXSCALE
      draw font=SMALLFONT text="BEL407-5"
    else
      draw at MUXX0+30.0*MUXSCALE,MUXY0+15.0*MUXSCALE
      draw font=SMALLFONT text="BEL407"
    endif
    // Draw reed relays.
    for i=80,i<(isnewmeas?113:112),i++ do
      Getrelayrect(i,xy)
      draw color=(i==relay?BLACK:DARKGRAY)
      if rd[i].valid==0 || rd[i].badlevel==0 then
        draw bkcolor=WHITE
      else if rd[i].badlevel==1 then
        draw bkcolor=PINK
      else if rd[i].badlevel<0 then
        draw bkcolor=WHITEBLUE
      else
        draw bkcolor=LIGHTRED
      endif
      draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
      if i==relay draw at xy[0]-1,xy[1]-1 rect xy[2]+2,xy[3]+2
      if rd[i].valid==0 || rd[i].badlevel<0 then
        draw color=GRAY at xy[0]+1,xy[1]+1 to xy[2]-1,xy[3]-1
        draw color=GRAY at xy[0]+1,xy[3]-1 to xy[2]-1,xy[1]+1
      endif
    enddo
    // Draw Firewire, processor, FPGA, HV, MUX and supply.
    if isnewmeas then
      draw color=BLACK bkcolor=WHITE
      draw at MUXX0+3*MUXSCALE,MUXY0+120*MUXSCALE
      draw fillrect MUXX0+18*MUXSCALE,MUXY0+131*MUXSCALE
      draw at MUXX0+3*MUXSCALE,MUXY0+142*MUXSCALE
      draw fillrect MUXX0+18*MUXSCALE,MUXY0+153*MUXSCALE
      draw color=GRAY bkcolor=LIGHTGRAY
      draw at MUXX0+82*MUXSCALE,MUXY0+105*MUXSCALE
      draw fillrect MUXX0+110*MUXSCALE,MUXY0+133*MUXSCALE
      draw at MUXX0+135*MUXSCALE,MUXY0+137*MUXSCALE
      draw fillrect MUXX0+159*MUXSCALE,MUXY0+161*MUXSCALE
      draw at MUXX0+8*MUXSCALE,MUXY0+10*MUXSCALE
      draw fillrect MUXX0+59*MUXSCALE,MUXY0+60*MUXSCALE
      draw at MUXX0+280*MUXSCALE,MUXY0+147*MUXSCALE
      draw fillrect MUXX0+315*MUXSCALE,MUXY0+159*MUXSCALE
      draw at MUXX0+280*MUXSCALE,MUXY0+159*MUXSCALE
      draw fillrect MUXX0+315*MUXSCALE,MUXY0+171*MUXSCALE
    else
      draw color=BLACK bkcolor=WHITE
      draw at MUXX0+3*MUXSCALE,MUXY0+15*MUXSCALE
      draw fillrect MUXX0+18*MUXSCALE,MUXY0+27*MUXSCALE
      draw at MUXX0+3*MUXSCALE,MUXY0+32*MUXSCALE
      draw fillrect MUXX0+18*MUXSCALE,MUXY0+44*MUXSCALE
      draw color=GRAY bkcolor=LIGHTGRAY
      draw at MUXX0+80*MUXSCALE,MUXY0+10*MUXSCALE
      draw fillrect MUXX0+108*MUXSCALE,MUXY0+38*MUXSCALE
      draw at MUXX0+81*MUXSCALE,MUXY0+52*MUXSCALE
      draw fillrect MUXX0+105*MUXSCALE,MUXY0+76*MUXSCALE
      draw at MUXX0+11*MUXSCALE,MUXY0+120*MUXSCALE
      draw fillrect MUXX0+61*MUXSCALE,MUXY0+170*MUXSCALE
      draw at MUXX0+204*MUXSCALE,MUXY0+18*MUXSCALE
      draw fillrect MUXX0+219*MUXSCALE,MUXY0+55*MUXSCALE
      draw at MUXX0+204*MUXSCALE,MUXY0+58*MUXSCALE
      draw fillrect MUXX0+219*MUXSCALE,MUXY0+95*MUXSCALE
      draw at MUXX0+228*MUXSCALE,MUXY0+157*MUXSCALE
      draw fillrect MUXX0+248*MUXSCALE,MUXY0+172*MUXSCALE
      draw at MUXX0+228*MUXSCALE,MUXY0+165*MUXSCALE
      draw to MUXX0+248*MUXSCALE,MUXY0+165*MUXSCALE
      draw at MUXX0+252*MUXSCALE,MUXY0+157*MUXSCALE
      draw fillrect MUXX0+266*MUXSCALE,MUXY0+172*MUXSCALE
      draw at MUXX0+252*MUXSCALE,MUXY0+165*MUXSCALE
      draw to MUXX0+266*MUXSCALE,MUXY0+165*MUXSCALE
    endif
  else if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
    // Modular multiplexer (EL506).
    for module=0,module<nmodule,module++ do
      // Draw background.
      draw color=BLACK bkcolor=WHITEGREEN
      draw at MUXX0+(175.0*module+6.0)*MUXSCALE,MUXY0
      draw fillrect MUXX0+(175.0*module+170.0)*MUXSCALE,MUXY0+175.0*MUXSCALE
      draw color=BLACK bkcolor=LIGHTGRAY mode=M_LEFT
      draw at MUXX0+175.0*module*MUXSCALE,MUXY0+48.0*MUXSCALE
      draw fillrect MUXX0+(175.0*module+12.0)*MUXSCALE,MUXY0+140.0*MUXSCALE
      draw at MUXX0+(165+175.0*module)*MUXSCALE,MUXY0+48.0*MUXSCALE
      draw fillrect MUXX0+(165+175.0*module+12.0)*MUXSCALE,MUXY0+140.0*MUXSCALE
      draw at MUXX0+(175.0*module+10.0)*MUXSCALE,MUXY0+11.0*MUXSCALE
      draw font=SMALLFONT text="BEL506"
      draw at MUXX0+(68+175.0*module)*MUXSCALE,MUXY0+121.0*MUXSCALE
      draw fillrect MUXX0+(80+175.0*module)*MUXSCALE,MUXY0+133.0*MUXSCALE
      draw at MUXX0+(71+175.0*module)*MUXSCALE,MUXY0+132.0*MUXSCALE
      draw font=FIXEDSYS text=format("%i",module)
      // Draw reed relays.
      for i=128+module*80,i<128+module*80+80,i++ do
        Getrelayrect(i,xy)
        if xy[0]==xy[2] continue
        draw color=(i/4==relay/4?BLACK:DARKGRAY)
        if rd[i].valid==0 || rd[i].badlevel==0 then
          draw bkcolor=WHITE
        else if rd[i].badlevel==1 then
          draw bkcolor=PINK
        else if rd[i].badlevel<0 then
          draw bkcolor=WHITEBLUE
        else
          draw bkcolor=LIGHTRED
        endif
        draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
        if i==relay draw at xy[0]-1,xy[1]-1 rect xy[2]+2,xy[3]+2
        if rd[i].valid==0 || rd[i].badlevel<0 then
          draw color=GRAY at xy[0]+1,xy[1]+1 to xy[2]-1,xy[3]-1
          draw color=GRAY at xy[0]+1,xy[3]-1 to xy[2]-1,xy[1]+1
        endif
      enddo
      // Draw BNC connectors.
      for i=128+module*80,i<128+module*80+80,i++ do
        if i<128+module*80+32 && (i & 1)!=0 continue
        Getmodularbncrect(i,xy)
        if xy[0]==0 && xy[2]==0 continue
        if i==relay || (i<128+module*80+32 && i+1==relay) then
          draw color=BLACK bkcolor=STRANGE
        else
          draw color=DARKGRAY bkcolor=WHITE
        endif
        draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
        draw at (xy[0]+xy[2])/2,(xy[1]+xy[3]+1)/2
        draw bkcolor=WHITE fillellipse xy[2]-xy[0]-4,xy[3]-xy[1]-4
      enddo
      // Draw on-head control connectors.
      for i=128+module*80,i<128+module*80+32,i=i+4 do
        Getmodularconnrect(i,xy)
        if i==(relay & 0xFFFFFFFC) then
          draw color=BLACK bkcolor=STRANGE
        else
          draw color=DARKGRAY bkcolor=WHITE
        endif
        draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
      enddo
    enddo
  else
    // Multiplexer with 16 outputs (EL406).
    draw color=BLACK bkcolor=WHITEGREEN
    draw at MUXX0+6.0*MUXSCALE,MUXY0
    draw fillrect MUXX0+343.0*MUXSCALE,MUXY0+175.0*MUXSCALE
    draw color=BLACK bkcolor=LIGHTGRAY mode=M_LEFT
    draw at MUXX0,MUXY0+48.0*MUXSCALE
    draw fillrect MUXX0+12.0*MUXSCALE,MUXY0+140.0*MUXSCALE
    draw at MUXX0+30.0*MUXSCALE,MUXY0+15.0*MUXSCALE
    draw font=SMALLFONT text="BEL406"
    // Draw reed relays.
    for i=0,i<80,i++ do
      Getrelayrect(i,xy)
      draw color=(i/4==relay/4?BLACK:DARKGRAY)
      if rd[i].valid==0 || rd[i].badlevel==0 then
        draw bkcolor=WHITE
      else if rd[i].badlevel==1 then
        draw bkcolor=PINK
      else if rd[i].badlevel<0 then
        draw bkcolor=WHITEBLUE
      else
        draw bkcolor=LIGHTRED
      endif
      draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
      if i==relay draw at xy[0]-1,xy[1]-1 rect xy[2]+2,xy[3]+2
      if rd[i].valid==0 || rd[i].badlevel<0 then
        draw color=GRAY at xy[0]+1,xy[1]+1 to xy[2]-1,xy[3]-1
        draw color=GRAY at xy[0]+1,xy[3]-1 to xy[2]-1,xy[1]+1
      endif
    enddo
    // Draw BNC connectors.
    for i=0,i<48,i++ do
      Getbncrect(i+1,xy)
      if relay>=0 && relay<80 &&                                               \
        ((i<32 && i/2==relay/4) || (i>=32 && i/4==(relay-32)/4)) then
        draw color=BLACK bkcolor=STRANGE
      else
        draw color=DARKGRAY bkcolor=WHITE
      endif
      draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
      draw at (xy[0]+xy[2])/2,(xy[1]+xy[3]+1)/2
      draw bkcolor=WHITE fillellipse xy[2]-xy[0]-4,xy[3]-xy[1]-4
    enddo
    // Draw on-head control connectors.
    for i=0,i<16,i++ do
      Getconnrect(i,xy)
      if i==relay/4 then
        draw color=BLACK bkcolor=STRANGE
      else
        draw color=DARKGRAY bkcolor=WHITE
      endif
      draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
    enddo
  endif
  draw show
  // Information.
  draw window=hmuxdata color=WHITE bkcolor=WHITE clear
  // Draw number of cycles.
  draw color=BLACK mode=M_CENTERED font=INFOFONT
  draw at DX/2+5,20 text=format("Number of cycles so far: %i",ntest)
  // Draw relay-related information.
  if relay>=0 && relay<368 then
    i=relay
    if relay<128 then
      ntitle=sprintf(title,"Relay K%i",i)
    else
      m=(i-128)/80
      ntitle=sprintf(title,"Module %i relay K%i",m,relay-128-m*80)
    endif
    if rd[i].head>=0 then
      ntitle=ntitle+sprintf(title+ntitle,                                      \
      " (head %i%c)",rd[i].head/2,rd[i].head & 1?'R':'L')
    else if rd[i].extant>=0 then
      ntitle=ntitle+sprintf(title+ntitle," (external antenna %i)",rd[i].extant)
    else if rd[i].tsensor>=0 then
      ntitle=ntitle+sprintf(title+ntitle," (temperature sensor)")
    else if rd[i].extraout>=0 then
      ntitle=ntitle+sprintf(title+ntitle," (External %i)",rd[i].extraout+1)
    endif
    y=70
    for card=0,card<nmeascard,card++ do
      firstprint=0
      draw mode=M_LEFT font=TIMESFONT
      j=rd[i].dataindex
      for line=0,ntest>0 && rd[relay].valid!=0,line++ do
        if rd[i].head>=0 then
          Memcpy(s,showmuxhead[line],NCHAR)
        else if rd[i].extant>=0 then
          Memcpy(s,showmuxant[line],NCHAR)
        else if rd[i].connector>=0 then
          Memcpy(s,showmuxconn[line],NCHAR)
        else if rd[i].tsensor>=0 then
          Memcpy(s,showmuxtsens[line],NCHAR)
        else if rd[i].extraout>=0 then
          Memcpy(s,showmuxext[line],NCHAR)
        else if rd[i].meascard>=0 then
          Memcpy(s,showmeascard[line],NCHAR)
        else
          break
        endif
        extratime=0
        // Modifiers are a kind of conditional operators, check if any.
        mm[0]=s[MMOMUX]; mm[1]=s[MMOMUX+1]; mm[2]='\0'
        if Strcmp(mm,"10")==0 then
          // Disable line if HVCUR=10 mA.
          if (ntest>0 && measstat[card,129,1]==1.0) continue;
        else if Strcmp(mm,"SP")==0 then
          // Kelvin probe only.
          if (l.probetype & 0x1)==0 continue
        else if Strcmp(mm,"NS")==0 then
          // Non-Kelvin probe only.
          if (l.probetype & 0x1)!=0 continue
        else if Strcmp(mm,"SL")==0 then
          // Slow relays.
          if (l.config & 0x00002000)!=0 extratime=1000
        else if Strcmp(mm,"NC")==0 then
          // BEL407-5 only.
          if (isnewmeas==0) continue
        else if Strcmp(mm,"N2")==0 then
          // BEL407-5 only, 20 kHz filter.
          if (isnewmeas==0 || measstat[card,71,0]==50.0) continue
        else if Strcmp(mm,"N5")==0 then
          // BEL407-5 only, 50 kHz filter.
          if (isnewmeas==0 || measstat[card,71,0]!=50.0) continue
        else if Strcmp(mm,"30")==0 then
          // 300 mA add-on.
          if measstat[card,72,0]==0 && measstat[card,73,0]==0 &&               \
          measstat[card,74,0]==0 && measstat[card,75,0]==0 continue
        else if Strcmp(mm,"H5")==0 then
          // HV500.
          if hvtype==1000 continue
        else if Strcmp(mm,"H1")==0 then
          // HV1000.
          if hvtype!=1000 continue
        endif
        // Draw name of measurement card.
        if firstprint==0 && nmeascard==2 then
          draw mode=M_CENTERED color=GREEN
          if card==0 then
            draw at DX/2+5,y text="Primary (master) measurement card"
          else
            y=y+8
            draw at DX/2+5,y text="Secondary (slave) measurement card"
          endif
          y=y+16
          firstprint=1
          draw mode=M_LEFT
        endif
        // Get measured signal.
        type=s[TOMUX]
        k=Inumb(s+TOMUX+1)             // Index of data
        if type=='E' then
          break
        else if type=='R' then
          if testmeas==0 continue
          smin=headstat[card,j,(i%4)*2+k,0]
          smax=headstat[card,j,(i%4)*2+k,1]
        else if type=='F' then
          if testmeas==0 continue
          smin=headstat[card,j,k,0]
          smax=headstat[card,j,k,1]
        else if type=='P' then
          if testmeas==0 continue
          smin=headstat[card,j,((i/2) & 1)+k,0]
          smax=headstat[card,j,((i/2) & 1)+k,1]
        else if type=='B' then
          if burnin==0 continue
          smin=headstat[card,j,((i/2) & 1)+k,0]
          smax=headstat[card,j,((i/2) & 1)+k,1]
        else if type=='A' then
          if testmeas==0 continue
          smin=measstat[card,rd[i].measindex+k,0]
          smax=measstat[card,rd[i].measindex+k,1]
        else if type=='V' then
          if testhv==0 continue
          smin=headstat[card,j,((i/2) & 1)+k,0]
          smax=headstat[card,j,((i/2) & 1)+k,1]
        else if type=='L' then
          if testmeas==0 continue
          if rd[i].extraindex!=k && rd[i].extraindex+1!=k continue
          smin=extrastat[card,k,0]
          smax=extrastat[card,k,1]
        else if type=='M' then
          if testmeas==0 continue
          if rd[i].measindex!=k && rd[i].measindex+1!=k continue
          smin=measstat[card,64+k,0]
          smax=measstat[card,64+k,1]
        else if type=='X' then
          if testmeas==0 continue
          smin=extrastat[card,rd[i].dataindex+k,0]
          smax=extrastat[card,rd[i].dataindex+k,1]
        else if type=='Y' then
          if testmeas==0 continue
          smin=extrastat[card,rd[i].extraindex+k,0]
          smax=extrastat[card,rd[i].extraindex+k,1]
        else if type=='N' then
          if rd[i].measindex==k && card==0 then
            ntitle=ntitle+sprintf(title+ntitle," (%s)",s+TEXTOMUX)
          endif
          continue
        else if type=='O' then
          if rd[i].extraindex==k && card==0 then
            ntitle=ntitle+sprintf(title+ntitle," (%s)",s+TEXTOMUX)
          endif
          continue
        else if type=='T' then
          if card==1 continue
          if rd[i].measindex==k then
            draw color=RED mode=M_CENTERED
            draw at DX/2+5,y+5 text=s+GMINMUX
            draw mode=M_LEFT
            y=y+26
          endif
          continue
        else if type=='U' then
          if card==1 continue
          if rd[i].extraindex==k then
            draw color=RED mode=M_CENTERED
            draw at DX/2+5,y+5 text=s+GMINMUX
            draw mode=M_LEFT
            y=y+26
          endif
          continue
        endif
        // Get good and warn signal limits.
        greenmin=Fnumb(s+GMINMUX)
        greenmax=Fnumb(s+GMAXMUX)
        yellowmin=Fnumb(s+YMINMUX)
        yellowmax=Fnumb(s+YMAXMUX)
        diffmin=Fnumb(s+DMINMUX)
        diffmax=Fnumb(s+DMAXMUX)
        displmax=Fnumb(s+LIMITMUX)
        // Correct limits if acceleration is turned off.
        if (lx.measopt & HCM_NOACCEL)!=0 then
          if (type=='A' || type=='M' || type=='R') && greenmin>1.0 then
            greenmax=greenmax*2
            yellowmax=yellowmax*2
            diffmin=diffmin*2
            diffmax=diffmax*2
            displmax=displmax*2
          endif
        endif
        draw at MX4,y color=BLACK text=format("(%g%g)",yellowmin,yellowmax)
        // Display name of parameter.
        draw at MX0,y color=BLACK text=s+TEXTOMUX
        // Display units of measurements.
        draw at MX3,y color=BLACK
        optional=0
        switch s[UOMUX]
          case 'A':                      // Arbitrary units
            draw text="a.u."
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case 'B':                      // ADC bits
            draw text="bits"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case 'G':                      // Degrees
            draw text="deg"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case 'V':                      // Volts
            draw text="V"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case 'S':                      // Bits/microsecond
            draw text="bit/\ns"
            Strcpy(slow,"fast"); Strcpy(shigh,"slow")
          case 'Z':                      // Volts/second
            draw text="V/s"
            Strcpy(slow,"fast"); Strcpy(shigh,"slow")
          case 'T':                      // Microseconds
            draw text="s"
            Strcpy(slow,"fast"); Strcpy(shigh,"slow")
          case '?':                      // Microseconds, optional
            optional=1
            draw text="s"
            Strcpy(slow,"fast"); Strcpy(shigh,"slow")
          case 'D':                      // Milliseconds
            draw text="ms"
            Strcpy(slow,"fast"); Strcpy(shigh,"slow")
          case 'O':                      // Ohms
            draw text="Ohm"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case 'Q':                      // kOhms
            draw text="k"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case 'P':                      // Picofarades
            draw text="pF"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case 'I':                      // Milliamperes
            draw text="mA"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case 'K':                      // Kiloherz
            draw text="kHz"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          case '%':                      // Percent
            draw text="%"
            Strcpy(slow,"low"); Strcpy(shigh,"high")
          default:
        endsw
        // Display measured data.
        if optional && smin==0.0 && smax==0.0 then
          draw color=LIGHTBLUE
          draw at MX5,y text="Not connected"
        else if smin<yellowmin then
          draw color=LIGHTRED
          draw at MX5,y text=format("Too %s",slow)
        else if smax>yellowmax then
          draw color=LIGHTRED
          draw at MX5,y text=format("Too %s",shigh)
        else if smax-smin>diffmax then
          draw color=LIGHTRED
          draw at MX5,y text="Too unstable"
        else if smin<greenmin then
          draw color=RED
          slow[0]=Toupper(slow[0]); draw at MX5,y text=slow
        else if smax>greenmax then
          draw color=RED
          shigh[0]=Toupper(shigh[0]); draw at MX5,y text=shigh
        else if smax-smin>diffmin then
          draw color=RED
          draw at MX5,y text="Unstable"
        else
          draw color=LIGHTBLUE
        endif
        n=0
        if smin>=displmax then
          n=n+sprintf(text+n,">")
          smin=displmax; smax=displmax
        else if smin>=0 then
          n=n+sprintf(text+n," ")
        endif
        if Abs(smin)<10.0 && Abs(smax)<10.0 then
          n=n+sprintf(text+n,"%.3f",smin)
        else if Abs(smin)<100.0 && Abs(smax)<100.0 then
          n=n+sprintf(text+n,"%.2f",smin)
        else if Abs(smin)<1000.0 && Abs(smax)<1000.0 then
          n=n+sprintf(text+n,"%.1f",smin)
        else
          n=n+sprintf(text+n,"%.0f",smin)
        endif
        if smin!=smax then
          text[n]='?'; n++
          if smax>=displmax n=n+sprintf(text+n,">")
          if Abs(smin)<10.0 && Abs(smax)<10.0 then
            n=n+sprintf(text+n,"%.3f",smax)
          else if Abs(smin)<100.0 && Abs(smax)<100.0 then
            n=n+sprintf(text+n,"%.2f",smax)
          else if Abs(smin)<1000.0 && Abs(smax)<1000.0 then
            n=n+sprintf(text+n,"%.1f",smax)
          else
            n=n+sprintf(text+n,"%.0f",smax)
          endif
        endif
        draw at MX1,y text=text
        y=y+16
      enddo
    enddo
    draw color=BLACK mode=M_CENTERED font=MEDIUMFONT
    draw at DX/2+5,50 text=title
  endif
  draw show
end

// Fills relay descriptors and checks limits (good/warning/bad) of LATEST
// measurements.
function int Processladata()
  int i,j,k,head,line,type,module,relay
  float smin1,smax1
  float greenmin,greenmax,yellowmin,yellowmax,diffmin,diffmax
  char s[256]
  Memset(rd,0,Sizeof(rd))
  for i=0,i<368,i++ do
    rd[i].module=-1
    rd[i].head=-1
    rd[i].extant=-1
    rd[i].extraout=-1
    rd[i].connector=-1
    rd[i].tsensor=-1
    rd[i].meascard=-1
    rd[i].measindex=-1
    rd[i].extraindex=-1
  enddo
  // Fill data for ordinary head connectors.
  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
    // Modular LATEST multiplexer. Currently I support only two modules.
    for module=0,module<nmodule && module<2,module++ do
      for i=0,i<16,i++ do
        relay=128+module*80+i
        rd[relay].module=module
        rd[relay].connector=i/2
      enddo
    enddo
    for i=0,i<32,i++ do                // Head
      k=headstat[0,i,31,1]-1           // Real output as default head
      if k<0 continue
      module=(k/4)%nmodule
      if k<nmodule*4 then
        k=k-module*4
      else
        k=k-(module+nmodule-1)*4
      endif
      relay=128+module*80+k*2
      for j=0,j<2,j++ do
        if i<l.nfing*2 rd[relay+j].head=i
        if fulltest || i<l.nfing*2 rd[relay+j].valid=1
        rd[relay+j].dataindex=i
      enddo
    enddo
  else
    // LATEST multiplexer with 16 outputs.
    for i=0,i<32,i++ do
      rd[i].head=i/2
      rd[i].jindex=(i^1)+1
    enddo
    for i=0,i<32,i++ do
      k=headstat[0,i,31,1]-1           // Real output
      if k<0 continue
      for j=0,j<2,j++ do
        if i<l.nfing*2 rd[k*2+j].head=i
        if fulltest || i<l.nfing*2 rd[k*2+j].valid=1
        rd[k*2+j].dataindex=i
      enddo
    enddo
  endif
  if testla==0 || ntest==0 return
  // Here limit checking starts. Note: two modules limit for the modular card!
  for i=0,i<368,i++ do
    j=rd[i].dataindex
    for line=0,1,line++ do
      if rd[i].valid==0 then
        break
      else if rd[i].head>=0 || rd[i].connector>=0 then
        if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
          Memcpy(s,showlamod[line],NCHAR)
        else
          Memcpy(s,showlahead[line],NCHAR)
        endif
      else
        break
      endif
      // Get measured signal.
      type=s[TOMUX]
      k=Inumb(s+TOMUX+1)               // Index of data
      if type=='E' then
        break
      else if type=='R' then
        smin1=headstat[0,j,(i%2)*2+k,0]
        smax1=headstat[0,j,(i%2)*2+k,1]
      else if type=='P' then
        smin1=headstat[0,j,(i & 1)+k,0]
        smax1=headstat[0,j,(i & 1)+k,1]
      else
        continue
      endif
      // Get good and warn signal limits.
      greenmin=Fnumb(s+GMINMUX)
      greenmax=Fnumb(s+GMAXMUX)
      yellowmin=Fnumb(s+YMINMUX)
      yellowmax=Fnumb(s+YMAXMUX)
      diffmin=Fnumb(s+DMINMUX)
      diffmax=Fnumb(s+DMAXMUX)
      // Check limits.
      if smin1<yellowmin || smax1>yellowmax || smax1-smin1>diffmax then
        rd[i].badlevel=2
        break                          // Don't do unnecessary analysis
      else if rd[i].badlevel==0 &&                                             \
        (smin1<greenmin || smax1>greenmax || smax1-smin1>diffmin) then
        rd[i].badlevel=1
      endif
    enddo
  enddo
end

// Draws LATEST.
function int Drawladata(int relay)
  int i,j,k,m,n,ntitle,y,line,type,module,xy[4],poly[28]
  char title[256],s[256],text[256],slow[32],shigh[32]
  float x,smin,smax,greenmin,greenmax,yellowmin,yellowmax
  float diffmin,diffmax,displmax
  draw window=hmux color=WHITE bkcolor=WHITE clear
  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
    // Modular LATEST (EL520). Currently I support only two modules.
    for module=0,module<nmodule && module<2,module++ do
      // Draw background.
      x=MUXX0+175.0*module*MUXSCALE
      draw color=DARKGRAY bkcolor=WHITE
      draw at x+6.0*MUXSCALE,MUXY0
      draw fillrect x+170.0*MUXSCALE,MUXY0+175.0*MUXSCALE
      poly[0]=x+6.0*MUXSCALE; poly[1]=MUXY0
      poly[2]=x+130.0*MUXSCALE; poly[3]=MUXY0
      poly[4]=x+130.0*MUXSCALE; poly[5]=MUXY0+45.0*MUXSCALE
      poly[6]=x+170.0*MUXSCALE-1; poly[7]=MUXY0+45.0*MUXSCALE
      poly[8]=x+170.0*MUXSCALE-1; poly[9]=MUXY0+147.0*MUXSCALE
      poly[10]=x+136.0*MUXSCALE; poly[11]=MUXY0+147.0*MUXSCALE
      poly[12]=x+136.0*MUXSCALE; poly[13]=MUXY0+160.0*MUXSCALE
      poly[14]=x+126.0*MUXSCALE; poly[15]=MUXY0+160.0*MUXSCALE
      poly[16]=x+126.0*MUXSCALE; poly[17]=MUXY0+147.0*MUXSCALE
      poly[18]=x+50.0*MUXSCALE; poly[19]=MUXY0+147.0*MUXSCALE
      poly[20]=x+50.0*MUXSCALE; poly[21]=MUXY0+160.0*MUXSCALE
      poly[22]=x+40.0*MUXSCALE; poly[23]=MUXY0+160.0*MUXSCALE
      poly[24]=x+40.0*MUXSCALE; poly[25]=MUXY0+147.0*MUXSCALE
      poly[26]=x+6.0*MUXSCALE; poly[27]=MUXY0+147.0*MUXSCALE
      draw color=BLACK bkcolor=WHITEGREEN
      draw polygon poly,14
      draw color=BLACK bkcolor=LIGHTGRAY mode=M_LEFT
      // Draw bus connectors.
      draw at MUXX0+175.0*module*MUXSCALE,MUXY0+48.0*MUXSCALE
      draw fillrect MUXX0+(175.0*module+12.0)*MUXSCALE,MUXY0+140.0*MUXSCALE
      draw at MUXX0+(165+175.0*module)*MUXSCALE,MUXY0+48.0*MUXSCALE
      draw fillrect MUXX0+(165+175.0*module+12.0)*MUXSCALE,MUXY0+140.0*MUXSCALE
      // Draw label.
      draw at x+120.0*MUXSCALE,MUXY0+120.0*MUXSCALE
      draw font=SMALLFONT text="BEL520"
      // Draw address selector.
      draw at x+68*MUXSCALE,MUXY0+101.0*MUXSCALE
      draw fillrect x+80*MUXSCALE,MUXY0+113.0*MUXSCALE
      draw at x+71*MUXSCALE,MUXY0+112.0*MUXSCALE
      draw font=FIXEDSYS text=format("%i",module)
      // Draw LATEST relays.
      for i=128+module*80,i<128+module*80+16,i++ do
        Getlarelayrect(i,xy)
        if xy[0]==xy[2] continue
        draw color=(i/2==relay/2?BLACK:DARKGRAY)
        if rd[i].valid==0 || rd[i].badlevel==0 then
          draw bkcolor=WHITE
        else if rd[i].badlevel==1 then
          draw bkcolor=PINK
        else if rd[i].badlevel<0 then
          draw bkcolor=WHITEBLUE
        else
          draw bkcolor=LIGHTRED
        endif
        draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
        if i==relay draw at xy[0]-1,xy[1]-1 rect xy[2]+2,xy[3]+2
        if rd[i].valid==0 || rd[i].badlevel<0 then
          draw color=GRAY at xy[0]+1,xy[1]+1 to xy[2]-1,xy[3]-1
          draw color=GRAY at xy[0]+1,xy[3]-1 to xy[2]-1,xy[1]+1
        endif
      enddo
      // Draw BNC connectors. Their positions on the LATEST card differ a bit,
      // but who cares?
      for k=0,k<16,k++ do
        j=(k & 0x03)+((k>>1) & 0x04)+((k<<1) & 0x08)
        Getmodularbncrect(128+module*80+j*2,xy)
        if xy[0]==0 && xy[2]==0 continue
        if (128+module*80+k)==relay then
          draw color=BLACK bkcolor=STRANGE
        else
          draw color=DARKGRAY bkcolor=WHITE
        endif
        draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
        draw at (xy[0]+xy[2])/2,(xy[1]+xy[3]+1)/2
        draw bkcolor=WHITE fillellipse xy[2]-xy[0]-4,xy[3]-xy[1]-4
      enddo
      // Draw additional BNC connector on the main multiplexer.
      draw color=DARKGRAY bkcolor=WHITE
      for i=128+module*64+64,i<128+module*80+80,i++ do
        Getmodularbncrect(i,xy)
        if xy[0]==0 && xy[2]==0 continue
        draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
        draw at (xy[0]+xy[2])/2,(xy[1]+xy[3]+1)/2
        draw fillellipse xy[2]-xy[0]-4,xy[3]-xy[1]-4
      enddo
      // Draw on-head control connectors.
      for k=0,k<8,k++ do
        j=(k & 1)+((k>>1) & 0x02)+((k<<1) & 0x04)
        Getmodularconnrect(128+module*80+j*4,xy)
        if (128+module*80+k*2)==(relay & 0xFFFFFFFE) then
          draw color=BLACK bkcolor=STRANGE
        else
          draw color=DARKGRAY bkcolor=WHITE
        endif
        draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
      enddo
    enddo
  else
    // LATEST card with 16 outputs.
    draw color=BLACK bkcolor=WHITEGREEN
    draw at MUXX0+6.0*MUXSCALE,MUXY0
    draw fillrect MUXX0+339.0*MUXSCALE,MUXY0+144.0*MUXSCALE
    draw color=GRAY bkcolor=LIGHTGRAY mode=M_LEFT
    draw at MUXX0+110.0*MUXSCALE,MUXY0+108.0*MUXSCALE
    draw fillrect MUXX0+135.0*MUXSCALE,MUXY0+133.0*MUXSCALE
    draw at MUXX0+196.0*MUXSCALE,MUXY0+100.0*MUXSCALE
    draw fillrect MUXX0+241.0*MUXSCALE,MUXY0+112.0*MUXSCALE
    draw at MUXX0+252.0*MUXSCALE,MUXY0+116.0*MUXSCALE
    draw fillellipse 16.0*MUXSCALE,16.0*MUXSCALE
    draw at MUXX0+270.0*MUXSCALE,MUXY0+116.0*MUXSCALE
    draw fillellipse 16.0*MUXSCALE,16.0*MUXSCALE
    draw at MUXX0+297.0*MUXSCALE,MUXY0+125.0*MUXSCALE
    draw fillellipse 35.0*MUXSCALE,35.0*MUXSCALE
    draw at MUXX0+335.0*MUXSCALE,MUXY0+85.0*MUXSCALE
    draw fillrect MUXX0+350.0*MUXSCALE,MUXY0+130.0*MUXSCALE
    draw at MUXX0+30.0*MUXSCALE,MUXY0+15.0*MUXSCALE
    draw color=BLACK font=SMALLFONT text="BEL420-3"
    // Draw reed relays.
    for i=0,i<40,i++ do
      Getlarelayrect(i,xy)
      draw color=(i==relay || (i<32 && i/2==relay/2)?BLACK:DARKGRAY)
      if rd[i].valid==0 || rd[i].badlevel==0 then
        draw bkcolor=WHITE
      else if rd[i].badlevel==1 then
        draw bkcolor=PINK
      else if rd[i].badlevel<0 then
        draw bkcolor=WHITEBLUE
      else
        draw bkcolor=LIGHTRED
      endif
      draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
      if i==relay draw at xy[0]-1,xy[1]-1 rect xy[2]+2,xy[3]+2
      if rd[i].valid==0 || rd[i].badlevel<0 then
        draw color=GRAY at xy[0]+1,xy[1]+1 to xy[2]-1,xy[3]-1
        draw color=GRAY at xy[0]+1,xy[3]-1 to xy[2]-1,xy[1]+1
      endif
    enddo
    // Draw BNC connectors.
    for i=0,i<52,i++ do
      Getbncrect(i+1,xy)
      if relay>=0 && relay<32 && (i<32 && i/2==relay/2) then
        draw color=BLACK bkcolor=STRANGE
      else if relay>=32 && relay<36 && i>=48 && i<52 then
        draw color=BLACK bkcolor=STRANGE
      else
        draw color=DARKGRAY bkcolor=WHITE
      endif
      xy[1]=xy[1]-3
      xy[3]=xy[3]-3
      draw at xy[0],xy[1] fillrect xy[2]+1,xy[3]+1
      draw at (xy[0]+xy[2])/2,(xy[1]+xy[3]+1)/2
      draw bkcolor=WHITE fillellipse xy[2]-xy[0]-4,xy[3]-xy[1]-4
    enddo
    // Draw reference resistor.
    if relay>=36 && relay<40 then
      draw color=BLACK bkcolor=STRANGE
    else
      draw color=DARKGRAY bkcolor=WHITE
    endif
    draw at MUXX0+269.0*MUXSCALE,MUXY0+66.0*MUXSCALE
    draw fillrect MUXX0+285.0*MUXSCALE,MUXY0+72.0*MUXSCALE
  endif
  draw show
  // Draw relay-related information.
  draw window=hmuxdata color=WHITE bkcolor=WHITE clear
  draw color=BLACK mode=M_CENTERED font=INFOFONT
  draw at DX/2+5,20 text=format("Number of cycles so far: %i",ntest)
  if relay<128 then
    ntitle=sprintf(title,"Relay K%i",relay)
  else
    m=(relay-128)/80
    ntitle=sprintf(title,"Module %i relay K%i",m,relay-128-m*80)
  endif
  if rd[relay].head>=0 then
    ntitle=ntitle+sprintf(title+ntitle,                                        \
    " (head %i%c)",rd[relay].head/2,rd[relay].head & 1?'R':'L')
  else if relay>=32 && relay<36 then
    ntitle=ntitle+sprintf(title+ntitle," (external probes)")
  else if relay>=36 && relay<40 then
    ntitle=ntitle+sprintf(title+ntitle," (calibration resistor)")
  endif
  y=70
  draw mode=M_LEFT font=TIMESFONT
  j=rd[relay].dataindex
  for line=0,ntest>0 && rd[relay].valid!=0,line++ do
    if rd[relay].head>=0 || rd[relay].connector>=0 then
      if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
        Memcpy(s,showlamod[line],NCHAR)
      else
        Memcpy(s,showlahead[line],NCHAR)
      endif
    else
      break
    endif
    // Get measured signal.
    type=s[TOMUX]
    k=Inumb(s+TOMUX+1)                 // Index of data
    if type=='E' then
      break
    else if type=='R' then
      smin=headstat[0,j,(relay%2)*2+k,0]
      smax=headstat[0,j,(relay%2)*2+k,1]
    else if type=='P' then
      smin=headstat[0,j,(relay & 1)+k,0]
      smax=headstat[0,j,(relay & 1)+k,1]
    else
      continue
    endif
    // Get good and warn signal limits.
    greenmin=Fnumb(s+GMINMUX)
    greenmax=Fnumb(s+GMAXMUX)
    yellowmin=Fnumb(s+YMINMUX)
    yellowmax=Fnumb(s+YMAXMUX)
    diffmin=Fnumb(s+DMINMUX)
    diffmax=Fnumb(s+DMAXMUX)
    displmax=Fnumb(s+LIMITMUX)
    draw at MX4,y color=BLACK text=format("(%g?%g)",yellowmin,yellowmax)
    // Display name of parameter.
    draw at MX0,y color=BLACK text=s+TEXTOMUX
    // Display units of measurements.
    draw at MX3,y color=BLACK
    switch s[UOMUX]
      case 'T':                        // Microseconds
        draw text="s"
        Strcpy(slow,"fast"); Strcpy(shigh,"slow")
      case 'O':                        // Ohms
        draw text="Ohm"
        Strcpy(slow,"low"); Strcpy(shigh,"high")
      case 'Q':                        // kOhms
        draw text="k"
        Strcpy(slow,"low"); Strcpy(shigh,"high")
      default:
    endsw
    // Display measured data.
    if smin<yellowmin then
      draw color=LIGHTRED
      draw at MX5,y text=format("Too %s",slow)
    else if smax>yellowmax then
      draw color=LIGHTRED
      draw at MX5,y text=format("Too %s",shigh)
    else if smax-smin>diffmax then
      draw color=LIGHTRED
      draw at MX5,y text="Too unstable"
    else if smin<greenmin then
      draw color=RED
      slow[0]=Toupper(slow[0]); draw at MX5,y text=slow
    else if smax>greenmax then
      draw color=RED
      shigh[0]=Toupper(shigh[0]); draw at MX5,y text=shigh
    else if smax-smin>diffmin then
      draw color=RED
      draw at MX5,y text="Unstable"
    else
      draw color=LIGHTBLUE
    endif
    n=0
    if smin>=displmax then
      n=n+sprintf(text+n,">")
      smin=displmax; smax=displmax
    else if smin>=0 then
      n=n+sprintf(text+n," ")
    endif
    if Abs(smin)<10.0 && Abs(smax)<10.0 then
      n=n+sprintf(text+n,"%.3f",smin)
    else if Abs(smin)<100.0 && Abs(smax)<100.0 then
      n=n+sprintf(text+n,"%.2f",smin)
    else if Abs(smin)<1000.0 && Abs(smax)<1000.0 then
      n=n+sprintf(text+n,"%.1f",smin)
    else
      n=n+sprintf(text+n,"%.0f",smin)
    endif
    if smin!=smax then
      text[n]='?'; n++
      if smax>=displmax n=n+sprintf(text+n,">")
      if Abs(smin)<10.0 && Abs(smax)<10.0 then
        n=n+sprintf(text+n,"%.3f",smax)
      else if Abs(smin)<100.0 && Abs(smax)<100.0 then
        n=n+sprintf(text+n,"%.2f",smax)
      else if Abs(smin)<1000.0 && Abs(smax)<1000.0 then
        n=n+sprintf(text+n,"%.1f",smax)
      else
        n=n+sprintf(text+n,"%.0f",smax)
      endif
    endif
    draw at MX1,y text=text
    y=y+16
  enddo
  draw color=BLACK mode=M_CENTERED font=MEDIUMFONT
  draw at DX/2+5,50 text=title
  draw show
end

// Writes test data to text protocol.
function int Protocoldata(handle hmain)
  int i,j,k,card,nhead,present
  handle f
  nhead=l.nfing*2
  i=SYS.Browse(hmain,protname,"Select file for self-test protocol",0)
  if i==1 && protname[0]!='\0' then
    f=Fopen(protname,"wt")
    if f!=NULL then
      if iadj then
        Printdata(f,nmeascard==2?curradjms:curradj,0,0,drawmean)
      else if laadj then
        Printdata(f,latestadj,0,0,drawmean)
      else
        Printdata(f,init,0,0,drawmean)
        if burnin then
          Printdata(f,burntitle,0,0,drawmean)
          if fulltest then
            j=0
            for i=0,i<32,i++ do
              if ((1<<i) & headmask)==0 continue
              if (1<<i) & realheads then
                Printdata(f,burnfinger,i,j,drawmean)
                j++
              endif
            enddo
          else                                       
            for i=0,i<nhead,i++ do
              Printdata(f,burnfinger,i,i,drawmean)
            enddo
          endif
        endif
        if testmeas then
          Printdata(f,crate,0,0,drawmean)
          Printdata(f,relays,0,0,drawmean)
          if fulltest then
            j=0
            for i=0,i<32,i++ do
              if ((1<<i) & headmask)==0 continue
              if (1<<i) & realheads then
                Printdata(f,finger,i,j,drawmean)
                j++
              else
                Printdata(f,output,i,-1,drawmean)
              endif
            enddo
          else
            for i=0,i<nhead,i++ do
              Printdata(f,finger,i,i,drawmean)
            enddo
          endif
          for i=0,i<2,i++ do
            if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
              present=0
              for k=0,k<18 & k<nmodule*6,k=k+3 do
                if (($int4(lx+674)>>k) & MUX_EXTERN0)==(MUXEXT_ANT1+i) then
                  present=1
                  break
                endif
              enddo
            else
              present=1
            endif
            if present==0 continue
            if fulltest then
              Printdata(f,extant,i*16+15,i,drawmean)
            else
              if ($int4(lx+336) & (1<<i))==0 continue
              Printdata(f,extant,nhead+i,i,drawmean)
            endif
          enddo
          if fulltest && ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 &&        \
            (features & 0x8)!=0 then
            for i=0,i<6,i++ do
              if (($int4(lx+674)>>(i*3)) & MUX_EXTERN0)!=MUXEXT_SHORT          \
                continue
              Printdata(f,muxshort,i,i,drawmean)
            enddo
          endif
        endif
        if testla then
          Printdata(f,lainit,0,0,drawmean)
          if fulltest then
            j=0
            for i=0,i<32,i++ do
              if ((1<<i) & headmask)==0 continue
              if (1<<i) & realheads then
                if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
                  Printdata(f,lafingermod,i,j,drawmean)
                else
                  Printdata(f,lafinger,i,j,drawmean)
                endif
                j++
              else
                if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
                  Printdata(f,laoutmod,i,-1,drawmean)
                else
                  Printdata(f,laout,i,-1,drawmean)
                endif
              endif
            enddo
          else
            for i=0,i<nhead,i++ do
              if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
                Printdata(f,lafingermod,i,i,drawmean)
              else
                Printdata(f,lafinger,i,i,drawmean)
              endif
            enddo
          endif
        endif
        if testhv then
          Printdata(f,hvinit,0,0,drawmean)
          if fulltest then
            j=0
            for i=0,i<32,i++ do
              if ((1<<i) & headmask)==0 continue
              if (1<<i) & realheads then
                Printdata(f,hvfinger,i,j,drawmean)
                j++
              else
                Printdata(f,hvout,i,-1,drawmean)
              endif
            enddo
          else
            for i=0,i<nhead,i++ do
              Printdata(f,hvfinger,i,i,drawmean)
            enddo
          endif
          for i=0,i<2,i++ do
            if fulltest then
              Printdata(f,hvant,i*16+15,i,drawmean)
            else
              if ($int4(lx+336) & (1<<i))==0 continue
              Printdata(f,hvant,nhead+i,i,drawmean)
            endif
          enddo
        endif
        if testcrt then
          Printdata(f,crtinit,0,0,drawmean)
          if fulltest then
            j=0
            for i=0,i<32,i++ do
              if ((1<<i) & headmask)==0 continue
              if (1<<i) & realheads then
                Printdata(f,crtfinger,i,j,drawmean)
                j++
              endif
            enddo
          else
            for i=0,i<nhead,i++ do
              Printdata(f,crtfinger,i,i,drawmean)
            enddo
          endif
        endif
      endif
      Fclose(f)
    endif
  endif
end

// Writes relays data to text protocol.
function int Protocolrelays(handle hmain)
  int i,j,card,nhead
  handle f
  nhead=l.nfing*2
  i=SYS.Browse(hmain,relayname,"Select file for relays protocol",0)
  if i==1 && relayname[0]!='\0' then
    f=Fopen(relayname,"wt")
    if f!=NULL then
      for card=0,card<nmeascard,card++ do
        Printrelay(f,mainrelays,card,0,0,0)
        if fulltest then
          j=0
          for i=0,i<32,i++ do
            if ((1<<i) & headmask)==0 continue
            if (1<<i) & realheads then
              Printrelay(f,muxrelays,card,j,i,0)
              j++
            else
              Printrelay(f,muxrelays,card,i,i,1)
            endif
          enddo
        else
          for i=0,i<nhead,i++ do
            Printrelay(f,muxrelays,card,i,i,0)
          enddo
          for i=0,i<2,i++ do
            if ($int4(lx+336) & (1<<i))==0 continue
            Printrelay(f,muxrelays,card,i,l.nfing*2+i,2)
          enddo
        endif
      enddo
      Fclose(f)
    endif
  endif
end

// Reads layout from tester. If layout is unavailable, uses layout from
// OllyTest. This script does not use additional layout extentions.
function int Getlayout()
  int t
  char buf[16]
  buf[0]=S_LAYOUT
  buf[1]=0x03                          // Read layout
  SYS.Sendimm(0,2,buf)
  buf[0]=S_LAYOUT
  buf[1]=0x0F                          // Read layout extention
  SYS.Sendimm(1,2,buf)
  t=Time()
  while $A[0].length==0 || $A[1].length==0 do
    if Time()-t>2000 break
    wait
  enddo
  if $A[0].answer==S_LAYOUT && $A[0].length==774 then
    Memcpy(l,$A[0]+6,768)
  else
    Memcpy(l,$LAY,768)
  endif
  if $A[1].answer==S_LAYOUT && $A[1].length==774 then
    Memcpy(lx,$A[1]+6,768)
  else
    Memcpy(lx,$EXTLAY,768)
  endif
end

// Service function, creates windows that display measurement card or
// multiplexer and relay data.
function int Createmux(handle hmain)
  int scrolldy,xextent
  if nmodule==4 then
    scrolldy=19
    xextent=2*DX+20
  else if nmodule==3 then
    scrolldy=19
    xextent=DX+DX/2+30
  else
    scrolldy=0
    xextent=DX+20
  endif
  hmuxparent=control CHILD
    window=hmain
    position=6,5,DX+20,DY+13
  endc
  hmux=control GRAPH
    window=hmuxparent
    position=0,0,xextent,SPLIT
    color=WHITE
    bkcolor=WHITE
  endc
  if scrolldy>0 then
    hmuxscroll=control HSCROLL
      window=hmuxparent
      position=0,SPLIT+1,DX+20,scrolldy-2
      help="滚动多路卡"
      limits=0,Max(0,xextent-DX-20)
    endc
  else
    hmuxscroll=NULL
  endif
  hmuxdata=control GRAPH
    window=hmuxparent
    position=0,SPLIT+scrolldy,DX+20,DY+13-SPLIT-scrolldy
    color=WHITE
    bkcolor=WHITE
  endc
end

function int Setcontrols()
  if running!=0 || runonce!=0 || ntest>0 then
    disable(hburn)
    disable(hburni)
    disable(hburnt)
    disable(hmeas)
    disable(hla)
    disable(hext)
    disable(hhvon)
    disable(hhv)
    disable(hcrt)
    disable(hvolt)
    disable(hcurr)
    disable(htime)
    disable(hiadj)
    disable(hlaadj)
  else
    enable(hburn)
    enable(hburni)
    enable(hburnt)
    enable(hmeas)
    enable(hla)
    enable(hext)
    enable(hhvon)
    enable(hhv)
    enable(hcrt)
    enable(hvolt)
    enable(hcurr)
    enable(htime)
    enable(hiadj)
    enable(hlaadj)
  endif
  if running!=0 && runonce==0 then
    change hstart text="停止"
    change hstart help="按此暂停测试"
    change hstart bkcolor=YELLOW
  else
    change hstart text="重复"
    change hstart help="点击开始持续测试"
    change hstart bkcolor=GRAY
  endif
  if testmeas==0 && testhv==0 && testcrt==0 && testla==0 &&                    \
    iadj==0 && laadj==0 then
    // Nothing to do.
    disable(hstart)
    disable(hsingle)
    disable(hget)
  else
    enable(hstart)
    if running!=0 || runonce!=0 || ntest>0 then
      disable(hsingle)
      disable(hget)
    else
      enable(hsingle)
      enable(hget)
    endif
  endif
end

function int main()
  int i,j,k,t,err,card,head,nhead,noinit,redraw
  int extdat,pendlist,sendlist,waitlist,present
  int voltage,testtime,current,drawmux,prevmux,x,y,z,xy[4]
  char s[256],scale[32],buf[1024]
  float r,burncurr
  handle hmain,hclear,hprotocol,hexit,hdrawmean,hdrawmode
  handle hmodal,hserial,hmoddata,hmodrelays,hmodquit
  burnin=0
  testmeas=1
  testla=0
  testhv=0
  testcrt=0
  fulltest=0
  dcwithhv=0
  iadj=0
  laadj=0
  Getlayout()
  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
    nmodule=($int4(lx+674) & MUX_MODCOUNT)>>24
    nmodule=Max(1,Min(nmodule,3))
    if nmodule==4 then
      headmask=0x3FFF3FFF
    else if nmodule==3 then
      headmask=0x0FFF0FFF
    else if nmodule==2 then
      headmask=0x00FF00FF
    else
      headmask=0x000F000F
    endif
    half=nmodule*4
  else
    nmodule=0
    headmask=0x00FF00FF
    half=8
  endif
  getini("Debug","Electronics self-test","%i,%i,%i,%i,%i,%i,%i,%i",            \
    &testmeas,&testhv,&fulltest,&extdat,&burnin,&dcwithhv,&testcrt,&testla)
  if burnin!=0 then
    testmeas=1
  endif
  if testmeas==0 && testhv==0 && testcrt==0 && testla==0 && fulltest==0 then
    testmeas=1
  endif
  Strcpy(protname,"selftest.txt")
  Strcpy(relayname,"relays.txt")
  getini("Debug","A5 electronics protocol",protname)
  getini("Debug","A5 relays protocol",relayname)
  hmain=control WINDOW
    window=NULL
    position=10,10,DX+137,DY+23
    name=format("测量卡多路卡自检%s",VERSION)
    help=" "
    bkcolor=WHITEMAGENTA
    size=512
  endc
  draw window=hmain color=MAGENTA font=INFOFONT
  draw at IX0+15,17 text="参数"
  draw at IX1+15,17 text="测量"
  draw at IX2+15,17 text="偏差"
  draw at IX3+10,17 text="单位"
  draw at IX4+15,17 text="期望值"
  draw at DX+32,17  text="测量:"
  draw color=BLACK mode=M_RIGHT
  draw at DX+65,60 text="I ="
  draw at DX+65,83 text="dT ="
  draw at DX+65,157 text="U ="
  draw at DX+65,180 text="I ="
  draw at DX+65,203 text="Th ="
  draw show
  hinfo=control CHILD
    window=hmain
    position=6,18,DX+20,DY
    help="自检结果"
    mode=M_VSCROLL
    limits=DX,DY+10
    size=262144                        // The amount of data may be very large
  endc
  hburn=control CHECKBOX
    window=hmain
    position=DX+35,20,85,20
    text="老化"
    help="加载高电流到多路卡上的继电器"
    font=INFOFONT
    mode=(burnin?M_CHECKED:0)
  endc
  hburni=control COMBOLIST
    window=hmain
    position=DX+70,41,60,200
    help="用于老化测试的电流"
    font=SMALLFONT
  endc
  add hburni text="30 mA"
  add hburni text="90 mA"
  add hburni text="200 mA"
  add hburni text="500 mA"
  add hburni text="1 A"
  add hburni text="1.5 A"
  Strcpy(s,"1 A")
  getini("Debug","A5 self-test Iburn",s)
  change hburni select=s
  hburnt=control COMBOLIST
    window=hmain
    position=DX+70,65,60,200
    help="每对继电器的老化测试持续时间"
    font=SMALLFONT
  endc
  add hburnt text="5 ms"
  add hburnt text="10 ms"
  add hburnt text="20 ms"
  add hburnt text="50 ms"
  add hburnt text="100 ms"
  add hburnt text="200 ms"
  add hburnt text="500 ms"
  add hburnt text="1 s"
  Strcpy(s,"100 ms")
  getini("Debug","A5 self-test Tburn",s)
  change hburnt select=s
  hmeas=control CHECKBOX
    window=hmain
    position=DX+35,93,45,20
    text="R/C"
    help="测试低压测量(直流和交流)"
    font=INFOFONT
    mode=(testmeas?M_CHECKED:0)
  endc
  hla=control CHECKBOX
    window=hmain
    position=DX+85,93,45,20
    text="LA"
    help="测试LA测量"
    font=INFOFONT
    mode=(testla?M_CHECKED:0)
  endc
  hhv=control CHECKBOX
    window=hmain
    position=DX+35,116,45,20
    text="HV"
    help="测试高压测量"
    font=INFOFONT
    mode=(testhv?M_CHECKED:0)
  endc
  hcrt=control CHECKBOX
    window=hmain
    position=DX+85,116,45,20
    text="MSD"
    help="测试MSD测量"
    font=INFOFONT
    mode=(testcrt?M_CHECKED:0)
  endc
  hvolt=control COMBOLIST
    window=hmain
    position=DX+70,139,60,200
    help="高压测试电压"
    font=SMALLFONT
  endc
  if ($int4(lx+496) & HCM_HVTYPE)==HCM_HV1000 &&                               \
    ($uint2(lx+508)==0 || $uint2(lx+508)==1000) then
    add hvolt text="200 V"
    add hvolt text="300 V"
    add hvolt text="400 V"
    add hvolt text="500 V"
    add hvolt text="600 V"
    add hvolt text="700 V"
    add hvolt text="800 V"
    add hvolt text="900 V"
    add hvolt text="1000 V"
    Strcpy(s,"500 V")
  else
    add hvolt text="100 V"
    add hvolt text="150 V"
    add hvolt text="200 V"
    add hvolt text="250 V"
    add hvolt text="300 V"
    add hvolt text="350 V"
    add hvolt text="400 V"
    add hvolt text="450 V"
    add hvolt text="500 V"
    Strcpy(s,"250 V")
  endif
  getini("Debug","A5 self-test HV U",s)
  change hvolt select=s
  hcurr=control COMBOLIST
    window=hmain
    position=DX+70,162,60,200
    help="高压测试电流"
    font=SMALLFONT
  endc
  add hcurr text="1 mA"
  add hcurr text="10 mA"
  Strcpy(s,"10 mA")
  getini("Debug","A5 self-test HV I",s)
  change hcurr select=s
  htime=control COMBOLIST
    window=hmain
    position=DX+70,185,60,200
    help="测试头初始化的持续时间，对于旧版软件选择默认"
    font=SMALLFONT
  endc
  add htime text="Default"
  add htime text="5 ms"
  add htime text="10 ms"
  add htime text="20 ms"
  add htime text="50 ms"
  add htime text="100 ms"
  add htime text="200 ms"
  add htime text="500 ms"
  add htime text="1 s"
  Strcpy(s,"Default")
  getini("Debug","A5 self-test HV time",s)
  change htime select=s
  hiadj=control CHECKBOX
    window=hmain
    position=DX+35,214,45,20
    text="I DC"
    help="调整测量卡上的电流源"
    font=INFOFONT
  endc
  hlaadj=control CHECKBOX
    window=hmain
    position=DX+85,214,45,20
    text="I LA"
    help="调整LA扩展卡的电流源"
    font=INFOFONT
  endc
  hext=control CHECKBOX
    window=hmain
    position=DX+35,242,85,20
    text="全部输出"
    help="测试多路卡上未使用的继电器"
    font=INFOFONT
    mode=(fulltest?M_CHECKED:0)
  endc
  hhvon=control CHECKBOX
    window=hmain
    position=DX+35,262,85,20
    text="HV开"
    help="在R / C测试期间检查以激活HV源以检查噪声"
    font=INFOFONT
    mode=(dcwithhv?M_CHECKED:0)
  endc
  hdrawmean=control CHECKBOX
    window=hmain
    position=DX+35,282,85,20
    text="显示均值"
    help="显示平均值而不是范围"
    font=INFOFONT
  endc
  hstart=control BUTTON
    window=hmain
    position=DX+32,DY-130-25*2,100,22
    text="重复"
    help="点击开始持续测试"
    bkcolor=GRAY
  endc
  hsingle=control BUTTON
    window=hmain
    position=DX+32,DY-130-25,100,22
    text="单个"
    help="按下测试一次"
  endc
  hget=control BUTTON
    window=hmain
    position=DX+32,DY-130,100,22
    text="最新"
    help="按下即可从内核中获取数据，而无需运行新的初始化程序"
  endc
  draw at DX+32,DY-88 mode=M_LEFT text="显示:"
  hdrawmode=control COMBOLIST
    window=hmain
    position=DX+32,DY-84,100,200
    help="选择显示模式"
    font=MAINFONT
  endc
  add hdrawmode text="表格"
  add hdrawmode text="测量卡"
  add hdrawmode text="多路卡"
  add hdrawmode text="潜在测试"
  change hdrawmode select=0
  hclear=control BUTTON
    window=hmain
    position=DX+32,DY-53,100,22
    text="清除"
    help="按下清除测试窗口"
  endc
  hprotocol=control BUTTON
    window=hmain
    position=DX+32,DY-28,100,22
    text="协议"
    help="将数据写入文本文件"
  endc
  disable(hprotocol)
  hexit=control BUTTON
    window=hmain
    position=DX+32,DY-3,100,22
    text="退出"
    help="按下完成测量卡的自检"
  endc
  nmeascard=1                          // Safe default
  running=0
  runonce=0
  noinit=0
  pendlist=0
  sendlist=0
  waitlist=0
  redraw=1
  realheads=0
  drawmux=0
  for i=0,i<l.nfing,i++ do
    if l.side[i]==0 then
      if i>=nmodule*2 then
        realheads=realheads | (0x00030000<<(i*2))
      else
        realheads=realheads | (0x00000003<<(i*2))
      endif
    else
      realheads=realheads | (0x00030000<<(i*2-l.nfing))
    endif
  enddo
  nhead=l.nfing*2
  // Check version of measurement card (influences presence of built-in filter
  // and position of reed relays).
  SYS.Killimm(0); $A[0].length=0
  buf[0]=S_DEBUG
  buf[1]=0x2E                          // Get version
  buf[2]=0x80                          // Measurement card
  SYS.Sendimm(0,3,buf)
  t=Time()
  while Time()-t<1000 do
    if $A[0].length>0 break
    wait
  enddo
  if $A[0].answer!=S_DEBUG || $A[0].length<45 then
    isnewmeas=0                        // Assume old measurement card
  else if ($uint2($A[0]+5) & 0x8000)==0 then
    isnewmeas=0                        // Old measurement card
  else
    isnewmeas=1                        // New measurement card
  endif
  if ($int4(lx+496) & HCM_HVTYPE)==HCM_HV1000 then
    hvtype=1000
  else
    hvtype=500                         // May be overwritten if autodetect
  endif
  // Get features supported by Crate, may be overriden later.
  SYS.Killimm(0); $A[0].length=0
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x10000012             // Query crate features
  SYS.Sendimm(0,6,buf)
  t=Time()
  while Time()-t<1000 do
    if $A[0].length>0 break
    wait
  enddo
  if $A[0].length>0 then
    if $A[0].answer!=S_INPORT32 then
      features=0                       // Safest default
    else
      features=$uint4($A[0]+5)
    endif
  endif
  // Main loop.
  while 1 do
    if Pressed(hexit) then
      setini("Debug","Electronics self-test","%i,%i,%i,%i,%i,%i,%i,%i",        \
        testmeas,testhv,fulltest,extdat,burnin,dcwithhv,testcrt,testla)
      setini("Debug","A5 electronics protocol",protname)
      setini("Debug","A5 relays protocol",relayname)
      Text(hburni,s); setini("Debug","A5 self-test Iburn",s)
      Text(hburnt,s); setini("Debug","A5 self-test Tburn",s)
      Text(hvolt,s); setini("Debug","A5 self-test HV U",s)
      Text(hcurr,s); setini("Debug","A5 self-test HV I",s)
      Text(htime,s); setini("Debug","A5 self-test HV time",s)
      break
    else if Pressed(hburn) then
      burnin=Status(hburn)
      iadj=0; change hiadj mode=0; Pressed(hiadj)
      laadj=0; change hlaadj mode=0; Pressed(hlaadj)
      redraw=1
    else if Pressed(hmeas) then
      testmeas=Status(hmeas)
      iadj=0; change hiadj mode=0; Pressed(hiadj)
      laadj=0; change hlaadj mode=0; Pressed(hlaadj)
      redraw=1
    else if Pressed(hla) then
      testla=Status(hla)
      iadj=0; change hiadj mode=0; Pressed(hiadj)
      laadj=0; change hlaadj mode=0; Pressed(hlaadj)
      redraw=1
    else if Pressed(hhv) then
      testhv=Status(hhv)
      iadj=0; change hiadj mode=0; Pressed(hiadj)
      laadj=0; change hlaadj mode=0; Pressed(hlaadj)
      redraw=1
    else if Pressed(hcrt) then
      testcrt=Status(hcrt)
      iadj=0; change hiadj mode=0; Pressed(hiadj)
      laadj=0; change hlaadj mode=0; Pressed(hlaadj)
      redraw=1
    else if Pressed(hiadj) then
      iadj=Status(hiadj)
      if iadj!=0 then
        burnin=0; change hburn mode=0; Pressed(hburn)
        testmeas=0; change hmeas mode=0; Pressed(hmeas)
        testla=0; change hla mode=0; Pressed(hla)
        fulltest=0; change hext mode=0; Pressed(hext)
        testhv=0; change hhv mode=0; Pressed(hhv)
        testcrt=0; change hcrt mode=0; Pressed(hcrt)
        laadj=0; change hlaadj mode=0; Pressed(hlaadj)
        change hinfo offset=0,0
      else
        change hmeas mode=M_CHECKED
      endif
      redraw=1
    else if Pressed(hlaadj) then
      laadj=Status(hlaadj)
      if laadj!=0 then
        burnin=0; change hburn mode=0; Pressed(hburn)
        testmeas=0; change hmeas mode=0; Pressed(hmeas)
        testla=0; change hla mode=0; Pressed(hla)
        fulltest=0; change hext mode=0; Pressed(hext)
        testhv=0; change hhv mode=0; Pressed(hhv)
        testcrt=0; change hcrt mode=0; Pressed(hcrt)
        iadj=0; change hiadj mode=0; Pressed(hiadj)
        change hinfo offset=0,0 
      else
        change hmeas mode=M_CHECKED
      endif
      redraw=1
    else if Pressed(hext) then
      fulltest=Status(hext)
      if (iadj!=0 || laadj!=0) change hmeas mode=M_CHECKED
      iadj=0; change hiadj mode=0; Pressed(hiadj)
      laadj=0; change hlaadj mode=0; Pressed(hlaadj)
      redraw=1
    else if Pressed(hhvon) then
      dcwithhv=Status(hhvon)
      redraw=1
    else if Pressed(hdrawmean) then
      redraw=1
    else if Pressed(hdrawmode) then
      t=Status(hdrawmode)
      if t==0 then
        if drawmux!=0 then
          destroy hmuxparent
          destroy hmuxdata
          change hinfo position=5,17,DX+20,DY
          enable hinfo
          drawmux=0
          muxpos=0
        endif
        redraw=1
      else if t==1 then
        if drawmux==0 then
          change hinfo position=-1000,-1000,*,*
          disable hinfo
          Createmux(hmain)
        else if hmuxscroll!=NULL then
          muxpos=0
          change hmuxscroll select=muxpos
          change hmux position=-muxpos,0,*,*
        endif
        change hmux                                                            \
          help="测量卡，将鼠标指针移到继电器上以查看数据"
        change hmuxdata                                                        \
          help="测量卡，将鼠标指针移到继电器上以查看数据"
        drawmux=2
        prevmux=(isnewmeas?89:110)
        redraw=1
      else if t==2 then
        if drawmux==0 then
          change hinfo position=-1000,-1000,*,*
          disable hinfo
          Createmux(hmain)
        else if hmuxscroll!=NULL then
          muxpos=0
          change hmuxscroll select=muxpos
          change hmux position=-muxpos,0,*,*
        endif
        change hmux                                                            \
          help="多路卡，将鼠标指针移到继电器上可以查看数据"
        change hmuxdata                                                        \
          help="多路卡，将鼠标指针移到继电器上可以查看数据"
        drawmux=1
        prevmux=0
        redraw=1
      else if t==3 then
        if drawmux==0 then
          change hinfo position=-1000,-1000,*,*
          disable hinfo
          Createmux(hmain)
        else if hmuxscroll!=NULL then
          muxpos=0
          change hmuxscroll select=muxpos
          change hmux position=-muxpos,0,*,*
        endif
        change hmux                                                            \
          help="LA测试扩展卡，将鼠标指针移到继电器上以查看数据"
        change hmuxdata                                                        \
          help="LA测试扩展卡，将鼠标指针移到继电器上以查看数据"
        drawmux=3
        prevmux=0
        redraw=1
      endif
    else if Pressed(hstart) then
      if running==0 then
        running=1
      else
        running=0; runonce=0; noinit=0
      endif
      Setcontrols()
    else if Pressed(hsingle) then
      runonce=1
      noinit=0
      Setcontrols()
    else if Pressed(hget) then
      runonce=1
      noinit=1
      Setcontrols()
    else if Pressed(hclear) then
      ntest=0
      redraw=1
      Setcontrols()
      disable(hprotocol)
    else if Pressed(hprotocol) then
      hmodal=control WINDOW
        window=hmain
        position=0,0,400,125
        text="选择协议类型"
        help=" "
        bkcolor=YELLOW
        mode=M_MODAL
        size=256
      endc
      draw window=hmodal color=BLACK font=MAINFONT
      draw at 10,20 text="测量卡的序列号:"
      draw at 10,80 text="保存:" show
      hserial=control EDIT
        window=hmodal
        position=10,30,380,25
        name=serial
        help="输入6位数的HC序列号和您要添加的任何注释"
        font=MAINFONT
        mode=M_BORDER
      endc
      hmoddata=control BUTTON
        window=hmodal
        position=10,90,130,25
        text="所有收集数据"
        help="数据显示在主窗口中"
      endc
      hmodrelays=control BUTTON
        window=hmodal
        position=150,90,150,25
        text="继电器-关联数据"
        help="以Excel格式保存继电器参数"
      endc
      if testmeas==0 disable hmodrelays
      hmodquit=control BUTTON
        window=hmodal
        position=310,90,80,25
        text="取消"
        help="不要将数据保存到协议中"
      endc
      while 1 do
        if Pressed(hmoddata) then
          Text(hserial,serial)
          i=1
          break
        else if Pressed(hmodrelays) then
          Text(hserial,serial)
          i=2
          break
        else if Pressed(hmodquit) then
          i=0
          break
        endif
        wait
      enddo
      destroy hmodal
      if i==1 then
        Protocoldata(hmain)
      else if i==2 then
        Protocolrelays(hmain)
      endif
    else if drawmux!=0 && hmuxscroll!=NULL && Pressed(hmuxscroll) then
      muxpos=Status(hmuxscroll)
      change hmux position=-muxpos,0,*,*
    endif
    // Check whether it's time to send commands. Note that if I send soft reset
    // and HVINIT simultaneously, second command will block this script until
    // soft reset is executed, so I separate them in time.
    if (running || runonce) && pendlist==0 then
      // I always check for the support of extended initialization data and
      // for the presence of second measurement card.
      sendlist=sendlist | 0x180
      // Force initialization if necessary.
      if $uint1(lx+451)!=0 then
        sendlist=sendlist | 0x40
      endif
      // Post commands.
      if burnin sendlist=sendlist | 0x01
      if testmeas || iadj sendlist=sendlist | 0x02
      if testhv sendlist=sendlist | 0x04
      if testcrt sendlist=sendlist | 0x08
      if testla || laadj sendlist=sendlist | 0x10
      pendlist=sendlist
      if noinit sendlist=sendlist & 0x180
      runonce=0
    else if sendlist & 0x100 then
      // Request features supported by the crate.
      SYS.Killimm(0); $A[0].length=0
      buf[0]=S_INPORT32
      buf[1]=0xFF                      // Crate controller
      $uint4(buf+2)=0x10000012         // Query crate features
      SYS.Sendimm(0,6,buf)
      sendlist=sendlist & (~0x100)
      waitlist=waitlist | 0x100
    else if waitlist & 0x100 then
      // Wait for the list of features
      if $A[0].length>0 then
        if $A[0].answer!=S_INPORT32 then
          features=0                   // Safest default
        else
          features=$uint4($A[0]+5)
        endif
        waitlist=waitlist & (~0x100)
      endif
    else if sendlist & 0x80 then
      // Request number of measurement cards in the system.
      SYS.Killimm(0); $A[0].length=0
      buf[0]=S_INPORT32
      buf[1]=0xFF                      // Crate controller
      $uint4(buf+2)=0x1002001E         // Query number of measurement cards
      SYS.Sendimm(0,6,buf)
      sendlist=sendlist & (~0x80)
      waitlist=waitlist | 0x80
    else if waitlist & 0x80 then
      // Wait for number of measurement cards.
      if $A[0].length>0 then
        if $A[0].answer!=S_INPORT32 then
          nmeascard=1                  // Safest default
        else
          nmeascard=$uint4($A[0]+5)
          if nmeascard!=2 nmeascard=1  // Safest default
        endif
        waitlist=waitlist & (~0x80)
      endif
    else if sendlist & 0x40 then
      // Force initialization, even if minimal time between inits is active.
      SYS.Killimm(0); $A[0].length=0
      buf[0]=S_OUTPORT32
      buf[1]=0x80                      // Measurement card (master)
      $uint4(buf+2)=0x80000010         // Force initializations
      $uint4(buf+6)=0xFFFFFFFF         // Initialize everything
      SYS.Sendimm(0,10,buf)
      if nmeascard==2 then
        buf[1]=0x81                    // Measurement card (slave)
        SYS.Sendimm(1,10,buf)
      endif
      sendlist=sendlist & (~0x40)
      waitlist=waitlist | 0x40
    else if waitlist & 0x40 then
      // Wait for initialization forced.
      if $A[0].length>0 && (nmeascard!=2 || $A[1].length>0) then
        waitlist=waitlist & (~0x40)
      endif
    else if sendlist & 0x01 then
      // Send burn-in commands.
      burncurr=0.0; Text(hburni,s); sscanf(s,"%f %s",&burncurr,scale)
      if Stricmp(scale,"A")==0 burncurr=burncurr*1000.0
      testtime=0; Text(hburnt,s); sscanf(s,"%i %s",&testtime,scale);
      if Stricmp(scale,"s")==0 testtime=testtime*1000
      for i=0,i<nhead,i++ do
        SYS.Killimm(i); $A[i].length=0
        buf[0]=S_DEBUG
        buf[1]=0x1A                    // Burn-in test
        buf[2]=i                       // Head
        $uint2(buf+3)=burncurr         // Current, mA
        $uint2(buf+5)=testtime         // Test time, ms/pair
        Memset(buf+7,0,12)             // Reserved for the future
        SYS.Sendimm(i,19,buf)
      enddo
      sendlist=sendlist & (~0x01)
      waitlist=waitlist | 0x01
    else if waitlist & 0x01 then
      // Wait for burn-in commands.
      for i=0,i<nhead,i++ do
        if $A[i].length==0 break
      enddo
      if i>=nhead waitlist=waitlist & (~0x01)
    else if sendlist & 0x02 then
      // Send soft reset.
      SYS.Killimm(32); $A[32].length=0
      if iadj then
        Memset(measstat,0,Sizeof(measstat))
        ntest=0
      endif
      sprintf(s,"OUTPORT 8199,%i",                                             \
        (fulltest!=0 && iadj==0 && laadj==0?1:0)+(dcwithhv==0?0:2))
      SERV.Cmdimm(34,s)
      SYS.Softimm(32)
      sendlist=sendlist & (~0x02)
      waitlist=waitlist | 0x02
    else if waitlist & 0x02 then
      // Wait for soft reset.
      if $A[32].length>0 waitlist=waitlist & (~0x02)
    else if sendlist & 0x04 then
      // Send HV init command.
      SYS.Killimm(33); $A[33].length=0
      voltage=0; Text(hvolt,s); sscanf(s,"%i",&voltage)
      current=0; Text(hcurr,s); sscanf(s,"%i",&current)
      testtime=0; Text(htime,s); sscanf(s,"%i %s",&testtime,scale);
      if Stricmp(scale,"s")==0 testtime=testtime*1000
      if voltage!=0 && current!=0 then
        sprintf(s,"OUTPORT 8199,%i",fulltest?1:0)
        SERV.Cmdimm(34,s)
        if testtime==0 then            // "Classical" HV initialization
          buf[0]=S_HVINIT
          $uint2(buf+1)=voltage        // Test voltage
          if current==1 then
            $uint2(buf+3)=100          // Max capacity between nets
          else
            $uint2(buf+3)=30000        // Max capacity between nets
          endif
          $uint2(buf+5)=100            // Requested accuracy, promille
          $uint2(buf+7)=10             // Min time under full voltage, ms
          if current==1 then
            $uint2(buf+9)=50           // Min voltage rise factor, ms/100V
          else
            $uint2(buf+9)=1            // Min voltage rise factor, ms/100V
          endif
          SYS.Sendimm(33,11,buf)
        else                           // Extended init, unsupported by old soft
          buf[0]=S_HVINIT
          $uint2(buf+1)=voltage        // Test voltage
          if current==1 then
            $uint2(buf+3)=100          // Max capacity between nets
          else
            $uint2(buf+3)=30000        // Max capacity between nets
          endif
          $uint2(buf+5)=100            // Requested accuracy, promille
          $uint2(buf+7)=testtime       // Min time under full voltage, ms
          if current==1 then
            $uint2(buf+9)=50           // Min voltage rise factor, ms/100V
          else
            $uint2(buf+9)=1            // Min voltage rise factor, ms/100V
          endif
          $uint2(buf+11)=testtime      // Min head initialization time, ms
          $uint2(buf+13)=0             // Reserved for the future
          SYS.Sendimm(33,15,buf)
        endif
        waitlist=waitlist | 0x04
      endif
      sendlist=sendlist & (~0x04)
    else if waitlist & 0x04 then
      // Wait for HV init.
      if $A[33].length>0 then
        // Voltage returned by HVINIT may be misleading if limited by layout.
        // I change hvtype only if layout specifies autodetect.
        if ($int4(lx+496) & HCM_HVTYPE)==HCM_HVAUTO &&                         \
          $A[33].answer==S_HVINIT && $A[33].length>=13 && $uint2($A[33]+9)>500 \
        then
          hvtype=1000
        endif
        waitlist=waitlist & (~0x04)
      endif
    else if sendlist & 0x08 then
      // Send MSD init command.
      SYS.Killimm(33); $A[33].length=0
      voltage=0; Text(hvolt,s); sscanf(s,"%i",&voltage)
      if voltage!=0 then
        sprintf(s,"CRTINIT %i",voltage)
        SERV.Cmdimm(33,s)
        waitlist=waitlist | 0x08
      endif
      sendlist=sendlist & (~0x08)
    else if waitlist & 0x08 then
      // Wait for MSD init.
      if $A[33].length>0 waitlist=waitlist & (~0x08)
    else if sendlist & 0x10 then
      // Send LATEST initialization command.
      if laadj then
        Memset(measstat,0,Sizeof(measstat))
        ntest=0
      endif
      sprintf(s,"OUTPORT 8199,%i",                                             \
        (fulltest!=0 && iadj==0 && laadj==0?1:0)+(dcwithhv==0?0:2))
      SERV.Cmdimm(34,s)
      SYS.Killimm(33); $A[33].length=0
      buf[0]=S_LAINIT                  // Make LATEST initialization
      $uint2(buf+1)=0                  // Default calibration defect value
      $uint2(buf+3)=0                  // No delay before measurement
      $uint2(buf+5)=100                // Retest threshold
      buf[7]=0                         // No current limit
      buf[8]=0x10                      // Single retest
      SYS.Sendimm(33,9,buf)
      sendlist=sendlist & (~0x10)
      waitlist=waitlist | 0x10
    else if waitlist & 0x10 then
      // Wait for LATEST init.
      if $A[33].length>0 waitlist=waitlist & (~0x10)
    else if pendlist!=0 then
      // Get gathered data.
      err=0
      for card=0,card<nmeascard && err==0,card++ do
        buf[0]=S_DUMP                  // Collect crate data
        buf[1]=255                     // Request to crate controller
        buf[2]=(card==0?0x17:0x19)     // Self-test data
        $long(buf+3)=0                 // Zero (default) length and addr
        SYS.Sendimm(3,7,buf)
        while $A[3].length==0 do
          if Pressed(hstart) then
            err=1; break
          endif
          wait
        enddo
        if $A[3].answer!=S_DUMP err=1  // Unsupported command?
        if err==0 then
          for i=0,i<254,i++
            r=$float4($A[3]+i*4+5)
            if i==128+32 r=r/1000.0    // HV zero R offset, convert to kOhm
            if ntest==0 then
              measstat[card,i,0]=r;
              measstat[card,i,1]=r;
              measstat[card,i,2]=r
            else
              measstat[card,i,0]=Min(measstat[card,i,0],r)
              measstat[card,i,1]=Max(measstat[card,i,1],r)
              measstat[card,i,2]=measstat[card,i,2]+r
            endif
          enddo
        endif
        if features & 0x00000008 then
          // Crate supports extended self-test data, get it.
          buf[0]=S_DUMP                // Collect crate data
          buf[1]=255                   // Request to crate controller
          buf[2]=(card==0?0x1B:0x1C)   // Extended self-test data
          $long(buf+3)=0               // Zero (default) length and addr
          SYS.Sendimm(3,7,buf)
          while $A[3].length==0 do
            if Pressed(hstart) then
              err=1; break
            endif
            wait
          enddo
          if $A[3].answer!=S_DUMP err=1
          if err==0 then
            for i=0,i<254,i++
              r=$float4($A[3]+i*4+5)
              if ntest==0 then
                extrastat[card,i,0]=r;
                extrastat[card,i,1]=r;
                extrastat[card,i,2]=r
              else
                extrastat[card,i,0]=Min(extrastat[card,i,0],r)
                extrastat[card,i,1]=Max(extrastat[card,i,1],r)
                extrastat[card,i,2]=extrastat[card,i,2]+r
              endif
            enddo
          endif
        endif
        for head=0,head<32 && err==0,head++ do
          if fulltest==0 then
            buf[0]=S_DUMP              // Collect crate data
            if head<nhead then         // Ordinary heads
              buf[1]=head/2            // Request to rail
              buf[2]=0x0E | (head & 1) // Self-test data
              $uint2(buf+3)=0          // Zero (default) length
              $uint2(buf+5)=card       // Address is measurement card
            else if head<nhead+2 then  // External antennae
              if ($int4(lx+336) & (1<<(head-nhead)))==0 continue
              buf[1]=0xFF              // Request to crate
              buf[2]=(card==0?0x18:0x1A)// Output of measurement card
              $uint2(buf+3)=0          // Default length
              $uint2(buf+5)=(head-nhead)*16+15 // Output
            else
              break
            endif
          else
            if ((1<<head) & (headmask | 0x80008000))==0 continue
            buf[0]=S_DUMP              // Collect crate data
            buf[1]=0xFF                // Request to crate
            buf[2]=(card==0?0x18:0x1A) // Output of measurement card
            $uint2(buf+3)=0            // Default length
            $uint2(buf+5)=head         // Output
          endif
          SYS.Sendimm(3,7,buf)
          while $A[3].length==0 do
            if Pressed(hstart) then
              err=1; break
            endif
            wait
          enddo
          if $A[3].answer!=S_DUMP err=1
          if err==0 then
            for i=0,i<64,i++
              r=$float4($A[3]+i*4+5)
              if ntest==0 then
                headstat[card,head,i,0]=r;
                headstat[card,head,i,1]=r;
                headstat[card,head,i,2]=r
              else
                headstat[card,head,i,0]=Min(headstat[card,head,i,0],r)
                headstat[card,head,i,1]=Max(headstat[card,head,i,1],r)
                headstat[card,head,i,2]=headstat[card,head,i,2]+r
              endif
            enddo
          endif
        enddo
      enddo
      ntest++
      enable(hprotocol)
      if running==0 && runonce==0 then
        if ntest==0 then
          enable(hburn)
          enable(hburni)
          enable(hburnt)
          enable(hmeas)
          enable(hla)
          enable(hext)
          enable(hhvon)
          enable(hhv)
          enable(hcrt)
          enable(hvolt)
          enable(hcurr)
          enable(htime)
          enable(hiadj)
          enable(hlaadj)
        endif
        enable(hsingle)
        enable(hget)
        change hstart text="重复"
        change hstart help="点击开始持续测试"
        change hstart bkcolor=GRAY
      endif
      pendlist=0
      redraw=1
    endif
    if drawmux then
      // Check whether multiplexer is scrolled by mouse.
      if hmuxscroll!=NULL then
        j=Mousexy(hmuxparent,&x,&y,&z)
        if (z & 0x03)==0 then
          captured=0
        else if captured==0 then
          if x<0 || y<0 || x>=DX+20 || y>=SPLIT then
            captured=2
          else
            captured=1
            capturex=x
            capturelast=x
            capturemux=muxpos
          endif
        else if captured==1 && x!=capturelast then
          capturelast=x
          muxpos=capturemux-x+capturex
          change hmuxscroll select=muxpos
          muxpos=Status(hmuxscroll)
          change hmux position=-muxpos,0,*,*
        endif
      endif
      // If different relay on the multiplexer card is pointed by mouse,
      // redraw multiplexer.
      j=Mousexy(hmux,&x,&y,&z)
      if drawmux==1 && ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
        // Relays on modular multiplexer card.
        for i=128,i<368,i++ do
          Getrelayrect(i,xy)
          if x>=xy[0] && x<=xy[2] && y>=xy[1] && y<xy[3] then
            if prevmux!=i then
              prevmux=i
              redraw=1
            endif
            break
          endif
        enddo
      else if drawmux==1 then
        // Relays on multiplexer card with 16 outputs.
        for i=0,i<80,i++ do
          Getrelayrect(i,xy)
          if x>=xy[0] && x<=xy[2] && y>=xy[1] && y<xy[3] then
            if prevmux!=i then
              prevmux=i
              redraw=1
            endif
            break
          endif
        enddo
      else if drawmux==2 then
        // Relays on measurement card.
        for i=80,i<(isnewmeas?113:112),i++ do
          Getrelayrect(i,xy)
          if x>=xy[0] && x<=xy[2] && y>=xy[1] && y<xy[3] then
            if prevmux!=i then
              prevmux=i
              redraw=1
            endif
            break
          endif
        enddo
      else if drawmux==3 && ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
        // LATEST relays on modular multiplexer card.
        for i=128,i<304,i++ do
          Getlarelayrect(i,xy)
          if x>=xy[0] && x<=xy[2] && y>=xy[1] && y<xy[3] then
            if prevmux!=i then
              prevmux=i
              redraw=1
            endif
            break
          endif
        enddo
      else if drawmux==3 then
        // LATEST relays on multiplexer card with 16 outputs.
        for i=0,i<40,i++ do
          Getlarelayrect(i,xy)
          if x>=xy[0] && x<=xy[2] && y>=xy[1] && y<xy[3] then
            if prevmux!=i then
              prevmux=i
              redraw=1
            endif
            break
          endif
        enddo
      endif
    endif
    // Repaint display.
    if redraw then
      Setcontrols()
      if drawmux==3 then
        // Analyse LATEST data.
        Processladata()
        // Redraw LATEST data.
        Drawladata(prevmux)
      else if drawmux then
        // Analyse data.
        Processmuxdata(burnin,testmeas,testhv)
        // Redraw multiplexer card.
        Drawmuxdata(drawmux==2,prevmux,burnin,testmeas,testhv)
      else
        // Redraw main list.
        disable hinfo                  // Reduces blinking when redrawing
        drawmean=Status(hdrawmean)
        if iadj then
          Drawdata(nmeascard==2?curradjms:curradj,0,0,drawmean)
        else if laadj then
          Drawdata(latestadj,0,0,drawmean)
        else
          Drawdata(init,0,0,drawmean)
          if burnin then
            Drawdata(burntitle,0,0,drawmean)
            if fulltest then
              j=0
              for i=0,i<32,i++ do
                if ((1<<i) & headmask)==0 continue
                if (1<<i) & realheads then
                  Drawdata(burnfinger,i,j,drawmean)
                  j++
                endif
              enddo
            else
              for i=0,i<nhead,i++ do
                Drawdata(burnfinger,i,i,drawmean)
              enddo
            endif
          endif
          if testmeas then
            Drawdata(crate,0,0,drawmean)
            Drawdata(relays,0,0,drawmean)
            if fulltest then
              j=0
              for i=0,i<32,i++ do
                if ((1<<i) & headmask)==0 continue
                if (1<<i) & realheads then
                  Drawdata(finger,i,j,drawmean)
                  j++
                else
                  Drawdata(output,i,-1,drawmean)
                endif
              enddo
            else
              for i=0,i<nhead,i++ do
                Drawdata(finger,i,i,drawmean)
              enddo
            endif
            for i=0,i<2,i++ do
              if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
                present=0
                for k=0,k<18 & k<nmodule*6,k=k+3 do
                  if (($int4(lx+674)>>k) & MUX_EXTERN0)==(MUXEXT_ANT1+i) then
                    present=1
                    break
                  endif
                enddo
              else
                present=1
              endif
              if present==0 continue
              if fulltest then
                Drawdata(extant,i*16+15,i,drawmean)
              else
                if ($int4(lx+336) & (1<<i))==0 continue
                Drawdata(extant,nhead+i,i,drawmean)
              endif
            enddo
            if fulltest && ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 &&      \
              (features & 0x8)!=0 then
              for i=0,i<6,i++ do
                if (($int4(lx+674)>>(i*3)) & MUX_EXTERN0)!=MUXEXT_SHORT        \
                  continue
                Drawdata(muxshort,i,i,drawmean)
              enddo
            endif
          endif
          if testla then
            Drawdata(lainit,0,0,drawmean)
            if fulltest then
              j=0
              for i=0,i<32,i++ do
                if ((1<<i) & headmask)==0 continue
                if (1<<i) & realheads then
                  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
                    Drawdata(lafingermod,i,j,drawmean)
                  else
                    Drawdata(lafinger,i,j,drawmean)
                  endif
                  j++
                else
                  if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
                    Drawdata(laoutmod,i,-1,drawmean)
                  else
                    Drawdata(laout,i,-1,drawmean)
                  endif
                endif
              enddo
            else
              for i=0,i<nhead,i++ do
                if ($int4(lx+674) & MUX_TYPEMASK)==MUX_TYPE506 then
                  Drawdata(lafingermod,i,i,drawmean)
                else
                  Drawdata(lafinger,i,i,drawmean)
                endif
              enddo
            endif
          endif
          if testhv then
            Drawdata(hvinit,0,0,drawmean)
            if fulltest then
              j=0
              for i=0,i<32,i++ do
                if ((1<<i) & headmask)==0 continue
                if (1<<i) & realheads then
                  Drawdata(hvfinger,i,j,drawmean)
                  j++
                else
                  Drawdata(hvout,i,-1,drawmean)
                endif
              enddo
            else
              for i=0,i<nhead,i++ do
                Drawdata(hvfinger,i,i,drawmean)
              enddo
            endif
            for i=0,i<2,i++ do
              if fulltest then
                Drawdata(hvant,i*16+15,i,drawmean)
              else
                if ($int4(lx+336) & (1<<i))==0 continue
                Drawdata(hvant,nhead+i,i,drawmean)
              endif
            enddo
          endif
          if testcrt then
            Drawdata(crtinit,0,0,drawmean)
            if fulltest then
              j=0
              for i=0,i<32,i++ do
                if ((1<<i) & headmask)==0 continue
                if (1<<i) & realheads then
                  Drawdata(crtfinger,i,j,drawmean)
                  j++
                endif
              enddo
            else
              for i=0,i<nhead,i++ do
                Drawdata(crtfinger,i,i,drawmean)
              enddo
            endif
          endif
        endif
        change hinfo limits=DX,ydata
        enable hinfo
        draw window=hinfo show
      endif
      redraw=0
    endif
    wait
  enddo
end

