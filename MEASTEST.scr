#include "ls.icl"                  // System definitions and functions
#include "or.icl"                // Command & error mnemonics
#include "pa.icl"                  // Rich Text Format extentions
#cmdbuff 34                            // 32+2 command buffers
#zeroid                                // Intercept tester answers with zero ID

#define VERSION        "19.02"
#define DESCRIPTION    "Verification of measurements with OlliBoard"

// 1.16: Allowed difference betwen mean and measured C and Z changed from
//       0.06pF+0.5% to 0.03pF+0.25%.
// 1.17: Z differences added to C statistics, individual sigmas removed.
// 1.19: Certification, positioning in shuttle.
// 1.20: More output during individual resistance adjustment.
// 1.21: Higher Z during Ctest, side margins for capacitor 5.5 pF.
// 1.22: Option to make resistance measurements against multiple fingers.
// 1.23: Golden board, positioning accuracy as parameter.
// 1.24: Automatical line width selection during positioning.
// 1.25: HV test allows for 25% of breaks on glow lamp recognized as 75 kOhm.
// 1.26: Logging of individual measurements in R adjust and resistance test.
// 1.27: Autorepeat of selected single test.
// 1.28: Higher capacity of "no contact pad" for A5/A6 splinogramms.
// 1.29: Additional capacity margin for A5/A6 splinogramms.
// 1.32: No contact point for Ctest is moved to another location.
// 1.33: Extra C margins for A5/A6 with ordinary needles instead of splinogramm.
// 1.34: Support for A5 wide shuttle.
// 1.35: RL calibration and measurements.
// 1.36: Bug in correction of nocontact capacity for splinogramms.
// 1.37: Up to 3 attempts during C adjust if measurement is bad/unstable;
//       HV measurements with 1 mA current to stabilize breaks with glow lamp;
//       HV test allows for 50% of breaks to be recognized as resistor.
// 1.38: Option to change stroke.
// 1.39: Test of externally connected components.
// 1.40: List of head-related errors in log file.
// 1.41: Inductivity corrections in flash.
// 1.42: Resistance/inductivity test.
// 1.43: Variable threshold (10 and 50 M) for shorts to antenna.
// 1.44: Improved parameter adjustment, small bugfixes.
// 1.45: Several bad measurements are allowed during certification.
// 1.46: Support of A5L.
// 1.47: Margins for capacitor 5.5 pF and R||C 100M/2.2uF are increased.
// 1.48: Bugfix - tester without splinogramms recognized as such.
// 1.49: Reduced number of HV component measurements for A5/A6.
// 1.50: Additional capacity for splinogramm adapter.
// 1.51: Shorts to antenna on the shortcut (0 Ohm); shorts both for F and A.
// 1.52: Support for head cameras.
// 1.53: Test of low-ohmical Kelvin measurements.
// 1.54: Allowance for A5XXL (240 mm rail height).
// 1.55: Correct illumination for head cameras.
// 1.56: Default headcam radii changed to 118 and 153 mm.
// 1.57: Support for A5L with head cameras.
// 1.58: Check for electrical contact between OlliBoard and shuttle (A5 only).
// 1.59: Some boards have 3.3 pF instead of 4.7 in field area, limits changed.
// 1.60: Option to exclude tests from the certification.
// 1.61: Inductance test checks for the presence of 47 uH component.
// 1.62: Support for A5A L&M automation.
// 1.63: Individual errors and lower requested accuracy for R||C.
// 1.64: Support for EPCOS tester.
// 1.65: Better support for old testers (A2/A3/A4).
// 1.66: Capacity calibration in the air is taken into account.
// 1.67: Shuttle adjustment and restoration support for A5 L&M automation.
// 1.68: Small modifications for EPCOS tester.
// 1.69: Improved inductance calibration and verification.
// 1.70: Possibility to move L&M shuttle out while needles are contacting.
// 1.71: Support for S1.
// 1.72: Limits for 5.5 pF extended, necessary for single-sided A5.
// 1.73: Quality of contacting, protocol of measurement parameters from layout.
// 1.74: Support for S2 and on-heads without field.
// 1.75: Alternative position of no contact (C0PA).
// 1.76: Own capacity of the needle.
// 1.77: Field noise in capacity test, false MAX333 switches.
// 1.78: Capacity verification with Kelvin needles.
// 1.79: Calibration of universal capacity measurements.
// 1.80: Certification of universal capacity measurements.
// 1.81: Certification of CRT measurements.
// 1.82: Inductivity corrections with external device.
// 1.83: Two L frequencies for external device.
// 1.84: Support for A7 and A8.
// 1.85: Pad 5.5 pF is excluded from C test on S2.
// 1.86: Takes into account that LC_PHADJ on-heads may have low phase shift.
// 1.87: Basic support for A7a.
// 1.88: Support for EL204-0.
// 1.89: Kelvin verification on EL204-0.
// 1.90: Support for Dallas ROM.
// 1.91: Wider limits for high capacity measured with AC (on-head I-U).
// 1.92: Support for HV1000 and 1 GOhm resistor.
// 1.93: Password-protected Dallas memory editing.
// 1.94: Basic support for A8a.
// 1,95: Functional CRT certification.
// 1.96: Option to run single tests with certification limits.
// 1.97: Support for A8a.
// 1.98: Support for small S1/4 (Max Planck).
// 1.99: Needle cleaning.
// 2.00: Detection of false opens due to unstable contact in HV test.
// 2.01: Resistance measurements with reduced voltage.
// 2.02: Duration of R and C measurements.
// 2.03: Optionally reduced test voltage for R||C, field and capacity tests.
// 2.04: Direct support for EL304-4 (new 3-row OlliBoard).
// 2.05: Four-wire measurements.
// 2.06: Support for A7/20 and EL504-4.
// 2.07: Optional 4-wire calibration of layout parameters.
// 2.08: Takes into account the scaling of the field if U differs from default.
// 2.09: Geometry of wires (top/bottom connections) in 4-wire R measurements.
// 2.10: Kelvin and 4-wire test with reduced test voltage.
// 2.11: Support for additional layout extentions.
// 2.12: Uses external USB temperature sensor if internal is absent.
// 2.13: Option to save Dallas memory to parameter file.
// 2.14: Tables for individuial heads if bad R||C measurements detected.
// 2.15: Noise test.
// 2.16: Error lists and protocolling for all main measurements.
// 2.17: False shorts in C test separated from bad measurements.
// 2.18: Adjustment of resistance measurements uses quantiles.
// 2.19: Option to replay bad measurements.
// 2.20: Check for different first capacity measurement.
// 2.21: Support for single-sided A8.
// 2.22: Bug in creation and processing of .cal files.
// 2.23: Bug in 4-wire test: false coordinates on open.
// 2.24: Instant retest in the certification.
// 2.25: Better compatibility with A3.
// 2.26: Bug in Ctest(): open/short counters not zeroed for instant retest.
// 2.27: Option to update ROM contents using user-specified coordinates.
// 2.28: SIDER pad excluded on single-sided S3.
// 2.29: Bug with brightness and contrast when going to different camera.
// 2.30: Bug: too short timeout in Getfeatures().
// 2.31: Synchronous head movements in Kelvin and 4-wire tests.
// 2.32: Alternative field nets on EL504.
// 2.33: Accelerated HV certification.
// 2.34: L&M shuttle settings are not restored when test is finished.
// 2.35: Thinner fiducial cross on XXL board.
// 2.36: Manual noise test.
// 2.37: Real measurements and 3-head measurements in manual noise test.
// 2.38: Support for testers with split shuttle.
// 2.39: Support for Tripod certification board.
// 2.40: Check for missing or zeroed main layout extention.
// 2.41: Support for S3 split shuttle.
// 2.42: Bugs when repeating part of resistance certification.
// 2.43: Option to test only selected set of rails.
// 2.44: Support for A7/24.

// Note 1: Width of text line in log file is 77 characters.
// Note 2: Sum of widths of RTF table cells must be equal to 159.

// Used resources.
#bitmap "logo"<"guoke.bmp"               // All bitmaps are compressed
#bitmap "bkground"<"aluminum.bmp"      // Alternative: "pcb1.bmp"
#bitmap "unknown"<"unknown.bmp"
#bitmap "measext"<"measext.bmp"
#bitmap "a5ameas"<"a5ameas.bmp"
// a7ameas is not yet available everywhere, therefore I load it dynamically.
// epcosms is not yet available everywhere, therefore I load it dynamically.
// ollyborg is not yet available everywhere, therefore I load it dynamically.
// ollybord is not yet available everywhere, therefore I load it dynamically.
// ollybrd2 is not yet available everywhere, therefore I load it dynamically.
// ollybrd3 is not yet available everywhere, therefore I load it dynamically.
// ollybrd4 is not yet available everywhere, therefore I load it dynamically.

// Dimensions of test window.
#define MAINX          600
#define MAINY          400
#define SPLIT          330
#define SERVY          25
#define LEFTX          320             // (SPLIT-10)
#define LEFTY          365             // (MAINY-SERVY-10)
#define RIGHTX         265             // (MAINX-SPLIT-5)
#define RIGHTY         335             // (MAINY-SERVY-SERVY-15)
#define USERY          250
#define INFOX          150             // Dimensions of small window with
#define INFOY          64              // type of test or live video.

// Definition of global error bits.
#define GE_BOOT        0x0001          // Tester must be rebooted
#define GE_HARDWARE    0x0002          // Pneumatics/shuttle out of order
#define GE_IOERROR     0x0004          // I/O error detected
#define GE_COMMAND     0x0008          // Command sending error
#define GE_MEAS        0x0010          // Resistance measurements impossible

// Constants determining tester type.
#define TT_WRONG       (-1)
#define TT_UNDEF       0
#define TT_A1          1
#define TT_A2          2
#define TT_A2L         3
#define TT_A2H         4
#define TT_A3          5
#define TT_A3L         6
#define TT_A4          7
#define TT_A5          8
#define TT_A5L         9
#define TT_A6          10
#define TT_S1          11
#define TT_S2          12
#define TT_A7          13
#define TT_A8          14
#define TT_S3          15
#define TT_M2          16

// Constants determining test actions.
#define ACT_QUIT       -1              // Quit test
#define ACT_BACK       0               // Return to previous menu
#define ACT_SELADJ     101             // Select type of adjustment
#define ACT_SELSINGLE  102             // Select single test
#define ACT_SELACCEPT  103             // Select type of acceptance test
#define ACT_RADJ       1               // Adjust precise resistance measurements
#define ACT_FADJ       2               // Adjust input capacities
#define ACT_LADJ       3               // Adjust internal inductivity
#define ACT_LXADJ      4               // Adjust external inductivity
#define ACT_UCADJ      5               // Adjust universal capacity
#define ACT_PROTM      6               // Protocol measurement parameters
#define ACT_EDITROM    7               // Edit contents of Dallas memory
#define ACT_MANNOIS    8               // Make manual noise test
#define ACT_NEEDLES    9               // Check contacting quality
#define ACT_QUICK      10              // Make quick test
#define ACT_LONG       11              // Make long test
#define ACT_ACC250     12              // Make 250 V acceptance test
#define ACT_ACC500     13              // Make 500 V acceptance test
#define ACT_CERTIFY    14              // Certify tester
#define ACT_EXTERN     15              // Test external components
#define ACT_R          16              // Test ordinary resistance
#define ACT_E          17              // Test precise resistance
#define ACT_KELVIN     18              // Test low-ohmical Kelvin measurements
#define ACT_4WIRE      19              // Test low-ohmical 4-wire measurements
#define ACT_MULTI      20              // Test multireference resistance
#define ACT_RC         21              // Test ordinary R||C
#define ACT_EC         22              // Test precise R||C
#define ACT_LOWUR      23              // Test low-U ordinary resistance
#define ACT_LOWUER     24              // Test low-U precise resistance
#define ACT_F          25              // Test field measurements
#define ACT_C          26              // Test capacity measurements
#define ACT_CRT        27              // Test CRT measurements
#define ACT_UNIC       28              // Test universal capacity measurements
#define ACT_OWNC       29              // Test own capacity of the needle
#define ACT_RL         30              // Test inductivity measurements
#define ACT_HV         31              // Test high voltage measurements
#define ACT_NOISE      32              // Find noisy heads
#define ACT_CLEAN      33              // Clean needles
#define ACT_REPLAY     34              // Repeat bad measurement
#define ACT_STROKE     35              // Set stroke

#define NPOINT         63              // Number of (pseudo)pads in X direction
#define VSTEP          0.5             // Camera moves in 0.5 mm steps
#define MAXERR         5.0             // Maximal error in fiducial position
#define MAXDY          3.0             // Maximal Y outside the reail area
#define DELTA          0.6             // Random deviation
#define RMAX           200000000.0     // Maximal measurable resistance
#define HVRMAX         2000000000.0    // Maximal resistance measurable by HV
#define NSUMMARY       48              // Maximal number of summary lines

// Layout configuration bits in $LAY.config.
#define LC_SMASK2      0x20000000      // Extention of LC_SMASK
#define LC_AUTOPROBE   0x10000000      // Autodetect probes (Kelvin or standard)
#define LC_TYPEMASK    0x0B000000      // General type of machine
#define   LC_STD       0x00000000      // LC_TYPEMASK: standard A5/A6 tester
#define   LC_NEWA1     0x01000000      // LC_TYPEMASK: new A1 (slow A5) tester
#define   LC_S1        0x02000000      // LC_TYPEMASK: S1/S2
#define   LC_A8        0x03000000      // LC_TYPEMASK: A7/A8
#define   LC_S3        0x08000000      // LC_TYPEMASK: S3
#define LC_VACUUMBOX   0x04000000      // Disable movements on bottom side
#define LC_MOREMASK    0x00C00000      // Mask for more space bits
#define   LC_MOREBOT   0x00800000      // Give more space on bottom
#define   LC_MORETOP   0x00400000      // Give more space on the top
#define LC_DEADLOCKS   0x00200000      // Autoresolve deadlocks
#define LC_ILLUM       0x00100000      // Auto switch video illumination on/off
#define LC_HARDZ       0x00040000      // Hard Z contacting (A2/A4/A5 only)
#define LC_QUAKE       0x00020000      // Earthquake protection on (M2 only)
#define LC_SMASK1      0x0001C000      // Mask for type of loading system
#define LC_RELAYS      0x00002000      // Slow (LATEST-compatible) relays
#define LC_OHTYPE      0x00001C00      // Mask to extract on-head type
#define   LC_NOFIELD   0x00001000      // On-heads without field amplifier
#define   LC_PHADJ     0x00000C00      // On-heads with adjustable field phase
#define   LC_ACTIVE    0x00000400      // Active on-heads (with Dallas/R1-R4)
#define   LC_PASSIVE   0x00000000      // Passive on-heads (manual C adjust)
#define LC_TRAFFICS    0x00000200      // Hitachi-style traffic lights
#define LC_ZSENSORS    0x00000100      // A series: Z pressure sensors active
#define LC_LOWBAUD     0x00000100      // M2: low AFMCU I/O baud rate
#define LC_ISM2        0x00000080      // M2 tester
#define LC_A2LOADER    0x00000040      // A2-style loader, enables LC_SMASK
#define LC_ENCODERS    0x00000020      // Tester with encoders
#define LC_COVER       0x00000010      // I have forgotten what it means
#define LC_HIGHZ       0x00000008      // Z always moves with full hub (B1)
#define LC_LDELAY      0x00000004      // Wait after light off (obsolete)
#define LC_AMASK       0x00000003      // Mask for type of antennae
#define   LC_EXTANT    0x00000000      // LC_AMASK: external (A1) antennae
#define   LC_INTANT    0x00000001      // LC_AMASK: internal antennae (void)
#define   LC_FINGANT   0x00000002      // LC_AMASK: finger antennae

// Tester types in LC_SMASK=(LC_SMASK2|LC_SMASK1).
#define LC_LMSPLIT     0x20000000      // L&M auto split shuttle
#define LC_LMMAN       0x0001C000      // L&M manual tester
#define LC_LMS2        0x00018000      // L&M for S2a
#define LC_EPCOS       0x00014000      // L&M for EPCOS tester
#define LC_LM          0x00010000      // L&M for A5a
#define LC_A5WIDE      0x0000C000      // A5 wide shuttle
#define LC_AUTOMATE    0x00008000      // Automatical shuttle
#define LC_A2XSHUT     0x00004000      // A2X shuttle
#define LC_A2SHUT      0x00000000      // A2 standard shuttle
// Useful shortcuts and substitutions.
#define LC_SMASK       (LC_SMASK2|LC_SMASK1)
#define LC_LDMASK      (LC_SMASK2|LC_SMASK1|LC_A2LOADER)
#define LC_SPLITAUTO   (LC_LMSPLIT|LC_A2LOADER)
#define LC_LMAUTO      (LC_LM|LC_A2LOADER)
#define LC_LMS2AUTO    (LC_LMS2|LC_A2LOADER)
#define LC_EPCOSAUTO   (LC_EPCOS|LC_A2LOADER)

// Type of automation.
#define AUTO_UNKNOWN   (-1)            // Unknown type of automation
#define AUTO_NONE      0x00            // Manual mode
#define AUTO_ERROR     0x01            // Attempt to get type was unsuccessfull
#define AUTO_DAMAGED   0x80            // Automation out of order
#define AUTO_SHUTTLE   0x81            // Automatic A2/A4/A6 shuttle
#define AUTO_A2        0x82            // Automatic A2 loader connected
#define AUTO_A4SEMI    0x83            // A4 output unit connected
#define AUTO_A4FULL    0x84            // Full A4 automation
#define AUTO_A6SEMI    0x85            // A6 output unit connected
#define AUTO_A6FULL    0x86            // Full A6 automation
#define AUTO_A5LMMAN   0x90            // A5 L&M automation in manual mode
#define AUTO_A5LMSEMI  0x91            // A5 L&M semiautomat
#define AUTO_A5LMFULL  0x92            // Full A5 L&M automation
#define AUTO_S2LMMAN   0x98            // S2 with manual shuttle
#define AUTO_S2LMSEMI  0x99            // S2 L&M in manual load/unload mode
#define AUTO_S2LMFULL  0x9A            // Full robotic S2 L&M automation
#define AUTO_S2LMDCF   0x9B            // S2 with double CF shuttle
#define AUTO_A7LMMAN   0xB0            // A7 L&M automation in manual mode
#define AUTO_A7LMSEMI  0xB1            // A7 L&M semiautomat
#define AUTO_A7LMFULL  0xB2            // Full A7 L&M automation
#define AUTO_A7LMNONE  0xB3            // A7 L&M pure manual mode
#define AUTO_A8LMMAN   0xB4            // A8a L&M automation in manual mode
#define AUTO_A8LMSEMI  0xB5            // A8a L&M semiautomat
#define AUTO_A8LMFULL  0xB6            // Full A8a L&M automation
#define AUTO_SPLITMAN  0xB8            // Split shuttle automation, manual mode
#define AUTO_SPLIT     0xBA            // Full split shuttle automation
#define AUTO_SPLNONE   0xBB            // Split shuttle automation, pure manual

// General options in extended layout.
#define EXT_CHECKZERO  0x00000001      // Correct X-Y zero pulses on soft reset
#define EXT_CONTAIR    0x00000100      // Individual no contact capacity in air
#define EXT_CAIR       0x00000200      // Field/capacity correction in air
#define EXT_CRTAIR     0x00000400      // CRT correction in air

// Z needle types in extended layout.
#define HCZ_VALID      0x80000000      // Z axis type in layout valid
#define HCZ_CONTMASK   0x0000FF00      // Mask to extract Z contact sensor
#define   HCZ_CONTDEF  0x00000000      // Default needle, no contact sensor
#define   HCZ_CONTSPL  0x00000100      // Soft splinogramm with opto sensor
#define   HCZ_CONTHSPL 0x00000200      // Hard splinogramm with opto sensor
#define   HCZ_CONTEMU  0x00000400      // Standard needle on soft touch adapter
#define   HCZ_CONTHPS  0x00000500      // Hard touch needle with opto sensor
#define   HCZ_CONTSTD  0x00000800      // Standard needle, developed by IBM
#define   HCZ_CONTSKP  0x00001000      // Soft Kelvin with two parallelogramms

// Options of measurement card.
#define HCM_HV1MA      0x00000001      // Force 1 mA during HV measurements
#define HCM_STRICT     0x00000002      // 20% stricter self-test
#define HCM_NOCTCHK    0x00000004      // Don't check contacts (except ExactR)
#define HCM_PARCONT    0x00000008      // Check influence of parallel contacting
#define HCM_NOACCEL    0x00000010      // Do not accelerate reed relays
#define HCM_TMEASOFF   0x00000020      // Turn off temperature measurements
#define HCM_CTOEXT     0x00000040      // Calibrate capacity to shuttle (extant)
#define HCM_ISOEANT    0x00000080      // External antennas isolated
#define HCM_FILTMASK   0x00000F00      // Mask to extract signal filtering
#define   HCM_FNONE    0x00000000      // No signal filtering
#define   HCM_F500K    0x00000100      // 500 kHz filter
#define   HCM_F100K    0x00000200      // 100 kHz filter
#define   HCM_F20K     0x00000300      // 20/50 kHz filter
#define HCM_FILTERC    0x00001000      // Filter C measurements over 300 pF
#define HCM_EXRLONG    0x00002000      // Long EXACTR with 300 mA source
#define HCM_AUTOEANT   0x00004000      // Automatic antenna 1 for all C
#define HCM_HVTYPE     0x000F0000      // Mask to extract type of HV elecronics
#define   HCM_HV500    0x00000000      // Card is capable of 500 V HV
#define   HCM_HV1000   0x00010000      // Card is capable of 1000 V HV
#define   HCM_HVAUTO   0x00070000      // Autodetect HV capabilities
#define HCM_DISCONN    0x00100000      // Disconnect from bus after measurement
#define HCM_EXRNOISY   0x00200000      // Accept noisy EXACTR measurements

// Features supported by measurement card.
#define MF_CONTAIR     0x00000001      // Contact check corrections supported
#define MF_CRT         0x00000002      // CRT measurements supported
#define MF_KELVSCAN    0x00000004      // Kelvin scan supported
#define MF_FIXCDC      0x00000008      // Forcing charge-discharge in FastC
#define MF_CCORR       0x00000010      // Calibration of capacitive phase
#define MF_SLAVE       0x00000020      // Supports second measurement card
#define MF_CPHASE      0x00000040      // C phase corrections from layout
#define MF_MULTIC      0x00000080      // Multiple C supported
#define MF_DSCAN       0x00000100      // Charge-discharge scan supported
#define MF_CRTCONCE    0x00000200      // Permanent CRT calibration in air
#define MF_UNIC        0x00000400      // Universal C supported
#define MF_CONCE       0x00000800      // Permanent C calibration in air
#define MF_HVINITEX    0x00001000      // Extended HV initialization (meas card)
#define MF_POSTAIR     0x00002000      // C in air after M_FASTC (meas card)
#define MF_EXTMEAS     0x00004000      // External measurement device
#define MF_DMEM        0x00008000      // Read/write from Dallas memory (meas)
#define MF_RLIM        0x00010000      // Ordinary R with limits (meas)
#define MF_DATA        0x00020000      // Supports F_DATA
#define MF_FSCALE      0x00040000      // Field scales to default voltage
// Measurement features supported by crate.
#define MF_RLIMCRATE   0x00800000      // Ordinary R with limits (crate)
#define MF_EXTLAINIT   0x01000000      // Extended S_LAINIT supported
#define MF_RETEST      0x02000000      // Instant retest (M_LIMITHI, M_LIMITLO)
#define MF_HVCRATEEX   0x04000000      // Extended HV initialization (crate)
#define MF_POSTCRATE   0x08000000      // C in air after M_FASTC (crate)
#define MF_RLINIT      0x10000000      // S_RLINIT supported (crate)
#define MF_DMEMCRATE   0x20000000      // Read/write from Dallas memory (crate)
#define MF_MULTICAL    0x40000000      // M_CALIBRATE supports multiple refs
// Reserved for high-level software, not used by crate.
#define MF_VALID       0x80000000      // Features valid

// Routine-independent ranges of Exactr(), refer to values in layout.
#define RR_UNDEF       0               // Unsupported or undefined
#define RR_300MA       1               // Depends on i300ma
#define RR_100MA       2               // Depends on i100ma
#define RR_30MA        3               // Depends on i30ma
#define RR_10MA        4               // Depends on i10ma
#define RR_3MA         5               // Depends on i3ma
#define RR_1MA         6               // Depends on i1ma
#define RR_300UA       7               // Depends on i300ua
#define RR_100UA       8               // Depends on i100ua
#define RR_30UA        9               // Depends on i30ua
#define RR_10UA        10              // Depends on i10ua
#define RR_9V          12              // Depends on dc9v
#define RR_0V9         13              // Depends on dc0v9
#define RR_R100K       15              // Depends on r100k

// Redirections.
#define EXTS_EXACTR    0x00000001      // Redirect EXACTR to external device
#define EXTS_UNIC      0x00000010      // Redirect UNIC to external device
#define EXTS_RLMEAS    0x00000100      // Redirect RLMEAS to external device

// Supported external devices.
#define EXTD_NONE      0               // No external device attached
#define EXTD_HM8118    1               // Hameg HM8118 bridge

// Layout of version of external measurements.
#define EXTM_VERSION   0xFFFFFF00      // Mask to extract version of ext corrs
#define EXTM_RLCORR    0x00000004      // Whether extern R-L corrections valid

#define NFREQ          6               // Number of supported frequencies

// Allowed failure rate (n*FAILRATE+MAXFAILED) during certification.
#define MAXFAILED      1               // 2%+1 measurement may be bad
#define FAILRATE       0.02
// On-head adjustment factor, multiply by relative deviation to get Dallas bits.
#define DADJFACTOR     15000.0
// Requested accuracy (maximum - minimum) of automatical on-head adjustment.
#define DADJLIMIT      5
// Expected stability of the contacting.
#define NCONT          100             // Number of contacting tests
#define STABRMAX       3.0             // Max resistance to all others, Ohms
#define STABRSIGMA     0.5             // Max allowed dispersion, Ohms
#define STABKLOOP      12.0            // Max resistance of Kelvin loop, Ohms
#define STABKSIGMA     1.0             // Max allowed dispersion, Ohms
// Expected accuracy of ordinary resistance measurements.
#define RFACTORLO      0.10            // 0 to 3 M: 10 % + 1 Ohm accuracy
#define RABSLO         1.0             //
#define RTHRESHOLD     3.0e6           // Add-on threshold
#define RFACTORHI      0.20            // Over 3 M: add 20 % of R over 3 M
#define RCFACTOR       0.1             // Capacity factor, 10% / microfarade
#define RCEXTRA        0.00            // Additional factor for R||C: 0%
// Expected accuracy of exact resistance measurements.
#define EFACTORLO      0.02            // 0 to 3 M: 2 % + 0.5 Ohm accuracy
#define EABSLO         0.5             //
#define ETHRESHOLD     3.0e6           // Add-on threshold
#define EFACTORHI      0.10            // Over 3 M: add 10 % of R over 3 M
#define ECFACTOR       0.075           // Capacity factor, 7.5% / microfarade
#define ECEXTRA        0.02            // Additional factor for R||C: 2%
// Expected accuracy of Kelvin measurements.
#define RKFACTOR       0.03            // Ordinary: 3 % + 100 mOhm accuracy
#define RKABS          0.100
#define EKFACTOR       0.03            // Exact: 3 % + 20 mOhm accuracy
#define EKABS          0.020
#define DKFACTOR       0.03            // Exact on dedicated: 3 % + 1.5 mOhm
#define DKABS          0.0015
#define DKSIGMA        0.01            // Sigma on dedicated: 1 % + 0.3 mOhm
#define DKSABS         0.0003
#define RLINED         0.0000134       // R of single line (dedicated), Ohm/mm
// Resistance corrections.
#define RWIRETIN       0.000271        // Ohms per millimeter of 2-sided wire
#define RWIREGOLD      0.000325
#define RGNDTIN        0.000271
#define RGNDGOLD       0.000019
// Expected results of field measurement test on shielded wires.
#define SINMIN         4000            // Minimal amplitude of sine component
#define SINMAX         9800            // Maximal amplitude of sine component
#define COSMIN         (-1600)         // Minimal amplitude of cosine component
#define COSMAX         (-200)          // Maximal amplitude of cosine component
#define FNOISE         8               // Maximal allowed sine/cosine noise
#define FNOISECERT     15              // Allowed noise in cerification mode
#define FPHASE         0.0020          // Maximal allowed phase difference
#define FEQUAL         10              // Criterium for good capacity alignment
// Expected accuracy of capacity measurements.
#define CFACTOR        0.10            // Difference from nominal capacity
#define CFACTORHI      0.30            // Difference from nominal for C>30 nF
#define CFCTABS        0.20            //
#define CREPEAT        0.0025          // Difference from mean capacity
#define CREPABS        0.03            //
#define CREPOLD        0.0050          // Difference for old (A2/3/4) testers
#define SIDEMARGIN     0.025           // Additional side effects margin
#define SIDERMARGIN    0.600           // Side effects margin for pad SIDER
#define KELVINMARGIN   0.200           // Difference between Kelvin needles, pF
#define SOFTTOUCHCA    0.070           // Additional C for soft touch, A5/A6
#define SOFTTOUCHCS    0.120           // Additional C for soft touch, S1/S2
#define KELVINSKPC     0.260           // Additional C for Kelvin needles
#define ADAPTERC       0.040           // Additional C for splinogramm adapter
#define CREPHIGH       0.005           // Difference for C>30 nF
#define CAIRCORR       0.005           // No contact C if air calibration active
#define PHASEEXP       0.085           // Expected corrected capacity phase
#define PHASEEXPX      0.015           // Same for on-heads without field
#define PHASEDIF       0.035           // Allowed phase difference
// Expected accuracy of CRT measurements.
#define CRTFACTOR      0.005           // Allowed C-CRT difference 100 fF + 0.5%
#define CRTABS         0.10
#define CRTRFACT       0.05            // Allowed R accuracy 5%
// Expected accuracy of universal C measurements.
#define RCPRODUCT      100000.0        // R*C time constant, Ohm*pF
#define UCRFACTOR      0.03            // Accuracy of R in universal C
#define UCRABS         10.0            //
#define UCREPEAT       0.01            // Repeatability of universal C 1%
// Expected accuracy of HV resistance measurements.
#define HVFACTORLO     0.05            // 0 to 10 M: 5 % + 1 kOhm accuracy
#define HVABSLO        1.0e3           //
#define HVVCORR        5.0             // Add 5% by 50 V, 0.5% by 500 V
#define HVTHRESHOLD    1.0e7           // Add-on threshold
#define HVFACTORHI     0.20            // Over 10 M: add 20 % of R over 10 M
#define BRKMIN         75.0            // Minimal ignition voltage of glow lamp
#define BRKMAX         150.0           // Maximal ignition voltage of glow lamp
#define GLOWRMIN       50000.0         // Minimal resistance of glow lamp
#define GLOWRMAX       100000.0        // Maximal resistance of glow lamp
#define NOBREAKS       0.50            // Part of good R's instead of breaks
// Expected accuracy of inductivity measurements.
#define LCORR          0.00110         // Inductance of 1 mm of wire, uH
#define LREPEAT        0.01            // Difference from mean inductivity
#define LREPLOC        0.10            // Difference from mean rail inductivity
#define LREPGLO        1.00            // Difference from mean all inductivity
#define LRESACC        0.003           // Difference due to R, uH/Ohm
#define LFACTOR        0.10            // Difference from nominal inductivity
#define LFACTABS       1.00            //
#define LRANGE         0.070           // Max interrange difference, uH
#define LSIGMA         0.015           // Max dispersion for range adjust, uH

// Tests excluded from verification.
#define EXCL_EXACTR    0x00000001      // Don't certify exact resistance
#define EXCL_RPARC     0x00000002      // Don't certify R||C resistance
#define EXCL_CRT       0x00000004      // Don't certify CRT measurements
#define EXCL_HV        0x00000008      // Don't certify HV measurements
#define EXCL_UNIC      0x00000010      // Don't certify universal C
#define EXCL_KELVIN    0x00000020      // Don't certify Kelvin resistance

// Bits in romdata.features.
#define BF_TYPE        0x00000F00      // Mask to extract board type
#define   BF_STD       0x00000000      // Standard set of components
#define   BF_1000V     0x00000100      // Supports 1000V and resistor 1 GOhm
#define   BF_TRIPOD    0x00000200      // Tripod acceptance board
#define BFTYPESHIFT    8               // Shift to get board type

typedef struct t_layout $LAY;          // Create layout-compatible types
typedef struct t_extlay $EXTLAY;

// All resistances are in Ohms, capacities are in picofarades, inductances are
// in microhenry and voltages are in volts.
typedef struct t_romdata               // Layout of Dallas memory
  // Page 00, offset +000.
  char    magic[4]                     // Expecting "OLLI"
  int     serial                       // Board serial number, same as label
  int     features                     // Board features, set of BF_xxx
  int     date                         // Date of last calibration
  char    operator[4]                  // Initials of certifier
  int     mbz0[3]                      // Reserved, must be 0
  // Page 01, offset +032.
  $float4 r1                           // Top 1 Ohm
  $float4 r3                           // Top 3 Ohm
  $float4 r30                          // Top 30 Ohm
  $float4 r294                         // Top 294 Ohm
  $float4 r2k94                        // Top 2.94 kOhm
  $float4 r8k87                        // Top 8.87 kOhm
  $float4 r29k4                        // Top 29.4 kOhm
  $float4 r88k7                        // Top 88.7 kOhm
  // Page 02, offset +064.
  $float4 r978k                        // Top 978 kOhm
  $float4 r3m32                        // Top 3.32 MOhm
  $float4 r10m                         // Top 10 MOhm
  $float4 r47m                         // Top 47 MOhm
  $float4 r100m                        // Top 100 MOhm
  $float4 r200m                        // Top 200 MOhm
  $float4 rsgl                         // Single-sided thin 155/250-mm wire
  $float4 rwire                        // Resistance of thin 155/250-mm wire
  // Page 03, offset +096.
  $float4 rlow10                       // Low R 10 mOhm
  $float4 rlow100                      // Low R 100 mOhm
  $float4 rlow1000                     // Low R 1 Ohm
  $float4 rlow10000                    // Low R 10 Ohm
  $float4 r1g                          // Top 1 GOhm, optional
  int     mbz3[2]                      // Reserved, must be 0
  $float4 rlowwire                     // Resistance of thick 155/250-mm wire
  // Page 04, offset +128.
  $float4 cfa                          // First field capacitor
  $float4 cfb                          // Second field capacitor
  $float4 c35p                         // Capacitor 27+8 pF
  $float4 c270p                        // Capacitor 270 pF
  $float4 c2n7                         // Capacitor 2.7 nF
  $float4 c22n                         // Capacitor 22 nF
  $float4 c220n                        // Capacitor 220 nF
  $float4 c2u2                         // Capacitor 2.2 uF
  // Page 05, offset +160.
  $float4 c1p[4]                       // 1.0 pF capacitors, [0] - bottom
  $float4 c2p2[4]                      // 2.2 pF capacitors, [0] - bottom
  // Page 06, offset +192.
  $float4 c4p7[4]                      // 4.7 pF capacitors, [0] - bottom
  int     mbz6[4]                      // Reserved, must be 0
  // Page 07, offset +224.
  $float4 lwire                        // Inductance of thin 155/255-mm wire, uH
  $float4 l40u                         // Optional 40 uH inductance
  $float4 c47u                         // Capacitor 47 uF
  $float4 c100u                        // Capacitor 100 uF
  int     mbz7[4]                      // Reserved, must be 0
  // Page 08, offset +256.
  $float4 l470n                        // Inductance 0.47 uH
  $float4 l1u                          // Inductance 1 uH
  $float4 l10u                         // Inductance 10 uH
  $float4 l100u                        // Inductance 100 uH
  $float4 l470u                        // Inductance 470 uH
  $float4 l4m7                         // Inductance 4.7 mH
  int     mbz8[2]                      // Reserved, must be 0
  // Page 09, offset +288.
  int     mbz9[8]                      // Reserved, must be 0
  // Page 10, offset +320.
  int     mbz10[8]                     // Reserved, must be 0
  // Page 11, offset +352.
  int     mbz11[8]                     // Reserved, must be 0
  // Page 12, offset +384.
  int     mbz12[8]                     // Reserved, must be 0
  // Page 13, offset +416.
  int     mbz13[8]                     // Reserved, must be 0
  // Page 14, offset +448.
  int     mbz14[8]                     // Reserved, must be 0
  // Page 15, offset +480.
  int     mbz15[7]                     // Reserved, must be 0
  int     crc                          // CRC (0x04C11DB7) of previous 508 bytes
ends

typedef struct t_replay                // Bad measurement that can be repeated
  int     head                         // Head, -1: separator
  char    err[80]                      // Error message
  char    cmd[768]                     // Command to repeat
ends

handle hmain                           // Main window
handle hexit                           // Button "Close"
handle hserv,hleft,hright              // Left and right subwindows
handle hinfo                           // Current status of test
handle hlist                           // Log window
handle hlog                            // Log file

// Individual per-camera brightness and contrast.
int    individualbc                    // Whether individual brightness/contrast
handle hbrititle                       // Brightness title
handle hbrightness                     // Brightness control
handle hctrtitle                       // Contrast title
handle hcontrast                       // Contrast control
handle hilltop                         // Top illumination control
handle hillskew                        // Skew illumination control
handle hilllong                        // Long exposition control
handle hfoctitle                       // Focus title
handle hfocusup                        // Focus up
handle hfocus                          // Z camera position
handle hfocusdn                        // Focus down

int    illtype                         // Illumination (0x3:on,0x4:top,0x8:skew)
int    longexp                         // Long exposition
int    brightness[32]                  // Individual brightness settings
int    contrast[32]                    // Individual contrast settings
int    bchead                          // Head selected for individual bri/ctr
int    focus[2]                        // Focus position of dedicated camera
int    updatefocus[2]                  // Set focus of dedicated camera
int    boardtype                       // 0:304-2, 1:304-3, 2:304 cut, 3:204-0,
                                       // 4:304-4, 5:504-1
float  rowdist                         // Distance between rows, 155 or 250 mm
char   crateversion[128]               // Version of loaded crate software
char   layoutversion[128]              // Version of loaded layout
char   headversion[128]                // Version of loaded head software
int    automationtype                  // Type of automation, AUTO_xxx
int    isauto                          // Whether half- or full-automate
int    siderail                        // Max rail on the first available side
int    firstrail                       // First rail on the top/only side
int    lastrail                        // Last rail on the top/only side
int    baserail                        // Lowest rail that reaches lowest row
int    used[32]                        // List of used heads
int    nused                           // Total number of used heads
int    layoutchanged                   // Layout is changed
int    loadchanged                     // Loader is closed
int    globalerr                       // Global asynchronous error recognized
int    softreset                       // Soft reset was requested
int    txtok                           // Non-zero if .TXT log file open
int    rtfok                           // Non-zero if .RTF log file open
int    logmode                         // 0: abs., 1: diff., 2: diff.%%
int    usestat                         // 1: supports statistical data
int    extendedlog                     // 1: graphs and heads in acceptance
int    extendederr                     // 1: list of errors after each test
int    longerr                         // 1: long error format
int    allowrepeat                     // 0: no instant repeats, 1: ask, 2: all
int    measadjusted                    // Resistance measurements adjusted
int    intladjusted                    // Internal inductivity adjusted
int    autorep                         // Automatically repeat single test
int    logmeas                         // Show results of every measurement
int    singlecert                      // Certification limits in single test
int    lowvolt                         // Use low voltage in single test
int    differentiall                   // Make differential L measurements
float  utestmax                        // Voltage for R and C measurements
float  rtestmax                        // Max resistance for R measurements
int    allowquickc                     // 1: allow quick C measurements
int    allowvarshort                   // 1: allow short-to-antenna at 50 M
char   expl[80]                        // Buffer for .TXT explanation line
int    nexpl                           // Number of chars in explanation line
int    oversurface[32]                 // No. of contacts over surface per head
int    testertype                      // Type of tester (TT_xxx)
int    testersides                     // Bit 0x1: top, 0x2: bottom rails
float  testerymin,testerymax           // Test area in Y, mm
float  ymin,ymax                       // Y extent of test area, mm
float  ypos0[32]                       // Non-shifted Y coordinate of the pad
float  ypos[32]                        // Y coordinate of the pad (board coords)
float  yalt[32]                        // Alternative Y pad coordinate (board)
float  yshift                          // Vertical shift of OlliBoard
int    onborder                        // Whether pads are on the rail border
int    usepads                         // 0: posxx - cross coordinates, 1: pad
int    useborder                       // Pad between useborder and useborder+1
float  leftvlimit                      // Left X limit for video camera
float  rightvlimit                     // Right X limit for video camera
float  toplimit                        // Top Y limit for video camera
float  bottomlimit                     // Bottom Y limit for video camera
float  shuttlex,shuttley               // Position of board in shuttle
float  pos1x,pos1y                     // First ref cross (tester coordinates)
float  pos2x,pos2y                     // Second ref cross (tester coordinates)
float  linewidth                       // Width of cross (200 or 300 um)
float  headcamradius                   // Radius of head cameras, millimeters
int    softtouch                       // Tester with splinogramms
int    splineemu                       // Tester with splinogramm adapters
int    ccorrected                      // Corrected C for sawed OllyBoard
int    features                        // Features of measurement card, MF_xxx
int    has300ma                        // 1: OK, -1: absent, 0: unsupported
int    supportsoff                     // Whether turning drivers off supported
int    excludetests                    // Tests excluded from verify, EXCL_xxx
char   lmteachin[5][256]               // Learned shuttle settings
int    nlmteachin                      // Number of valid lmteachin
int    pulledshuttle                   // Shuttle for A8eaPreparePullCalib or -1
int    nooem                           // Some 3rd party components present
char   wordofwisdom[64]                // Never mind
float  dallaspad1[2]                   // First user-defined Dallas pad
float  dallaspad2[2]                   // Second user-defined Dallas pad

int    strokev=50                      // Stroke, mm/s
int    strokep=50                      // Pressure, gramm
float  strokez=5.0                     // Height, millimeters
int    acc=20                          // Positioning accuracy, um

float  convsfi,convcfi                 // Rotation and shrinkage of OlliBoard
float  convdx,convdy                   // Offset of OlliBoard

char   runitname[4][5] =             \ // Resistance units
  { "Ohm","kOhm","MOhm","GOhm" }
char   runitshort[4][5] =            \ // Resistance units, short form
  { "?","k","M","G" }
char   cunitname[4][5] =             \ // Capacity units
  { "pF","nF","uF","mF" }
char   cunitshort[4][5] =            \ // Capacity units, short form
  { "p","n","?","m" }

char xname[NPOINT][20] = {           \ // Components on OlliBoard
  "RES0   0     0",                  \ // First reserved pad (X=0 by definition)
  "R1G    0     1.0e9",              \ // Optional resistor 1 GOhm
  "C47U   0     4.7e7",              \ // Optional capacitor 47 uF
  "DALLAS 15    0",                  \ // Optional Dallas memory
  "L47U   30    47.0",               \ // Inductivity 47 uH
  "C100U  30    1.0e8",              \ // Optional capacitor 100 uF
  "LATEST 45    0",                  \ // LATEST defect
  "SIDEL  60    0",                  \ // Left contact to test side effects
  "OWNC   72.5  0",                  \ // Position to test side effects
  "SIDER  85    5.5",                \ // Right contact to test side effects
  "RINF   85    2.0e9",              \ // Resistive open (measured R>200 M)
  "C0P1   90    0.04",               \ // First no contact (measured C=40 fF)
  "NOCT1  95    1.0e9",              \ // First no contact
  "R1     100   1.0",                \ // Resistor 1 Ohm
  "R3     105   3.0",                \ // Resistor 3 Ohm
  "R30    110   30.0",               \ // Resistor 30 Ohm
  "R294   115   294.0",              \ // Resistor 294 Ohm
  "R2K94  120   2940",               \ // Resistor 2.94 kOhm
  "R8K87  125   8870",               \ // Resistor 8.87 kOhm
  "R29K4  130   29400",              \ // Resistor 29.4 kOhm
  "R88K7  135   88700",              \ // Resistor 88.7 kOhm
  "R978K  140   9.78e5",             \ // Resistor 978 kOhm
  "R3M32  145   3.32e6",             \ // Resistor 3.32 MOhm
  "R10M   150   1.0e7",              \ // Resistor 10 MOhm
  "R47M   155   4.7e7",              \ // Resistor 47 MOhm
  "R100M  160   1.0e8",              \ // Resistor 100 MOhm
  "L470N  160   0.47",               \ // Optional inductance 470 nH
  "R200M  165   2.0e8",              \ // Resistor 200 MOhm
  "L1U    165   1.0",                \ // Optional inductance 1 uH
  "GND1   170   0",                  \ // Left ground
  "GND2   175   0",                  \ // Right ground
  "RX0R01 185   0.0106",             \ // Resistor 0.01 Ohm (EL204)
  "F1     190   0",                  \ // Left field contact
  "RX0R1  195   0.1",                \ // Resistor 0.1 Ohm (EL204)
  "F2     200   0",                  \ // Middle field contact
  "RX1R   205   1.0",                \ // Resistor 1 Ohm (EL204)
  "F3     210   0",                  \ // Right field contact
  "RX10R  215   10.0",               \ // Resistor 10 Ohm (EL204)
  "C27P   225   35",                 \ // Capacitor 27 pF + 8..27 pF parasitics
  "NOCT2  234   1.0e9",              \ // Second no contact
  "C0PA   234   0.04",               \ // Alternative no contact
  "C270P  240   270",                \ // Capacitor 270 pF
  "C1P7   247.5 1.7",                \ // Generic for all 1.0+0.7 pF
  "C2N7   255   2700",               \ // Capacitor 2.7 nF
  "C2P9   262.5 2.9",                \ // Generic for all 2.2+0.7 pF
  "C22N   270   2.2e4",              \ // Capacitor 22 nF
  "C5P4   277.5 5.4",                \ // Generic for all 4.7+0.7 pF
  "C220N  285   2.2e5",              \ // Capacitor 220 nF
  "C2U2   300   2.2e6",              \ // Capacitor 2.2 uF
  "HV     315   1.0e9",              \ // Glow lamp for HV test (resistive open)
  "L4M7   315   4.7e3",              \ // Optional inductance 4.7 mH
  "DALALT 330   0",                  \ // Alternative position for Dallas memory
  "P1     330   0",                  \ // First pad with external connector
  "L10U   330   10.0",               \ // Optional inductance 10 uH
  "P2     345   0",                  \ // Second pad with external connector
  "L100U  345   100.0",              \ // Optional inductance 100 uH
  "P3     360   0",                  \ // Third pad with external connector
  "L470U  360   470.0",              \ // Optional inductance 470 uH
  "+Rsgl  0     0.090",              \ // Pseudopad, single-sided thin wire
  "+Rthin 0     0.045",              \ // Pseudopad, thin 155/250-mm wire
  "+Rwide 0     0.004" }               // Pseudopad, wide 155/250-mm wire

float xpos[NPOINT]                     // Extracted X coordinate of the pad
float value[NPOINT]                    // Extracted value associated with pad

// Data structures used for certified boards with calibration data.

#define NKEY 10                        // Number of different calibration keys
char calkey[NKEY][32] = {            \ // '+' means obligatory field
  " CALIBRATIONOBJECT",              \ // Expected: "Diagnostic Board"
  "+MODEL",                          \ // Expected: "BEL304-2" or "BEL304-3"
  " MANUFACTURER",                   \
  "+SERIALNO",                       \
  "+CERTIFICATENO",                  \
  "+CALIBRATIONINDEX",               \
  "+DATEOFCALIBRATION",              \
  "+NEXTCALIBRATION",                \
  " HUMIDITY",                       \
  " TEMPERATURE" }
char calkeydata[NKEY][80]              // Contents of calibration keys

#define NCOMP 34                       // Number of certified components
char calcomp[NCOMP][16] = {          \
  "R1      R1",                      \
  "R2      R3",                      \
  "R3      R30",                     \
  "R4      R294",                    \
  "R5      R2K94",                   \
  "R6      R8K87",                   \
  "R7      R29K4",                   \
  "R8      R88K7",                   \
  "R9+R10  R978K",                   \
  "R11     R3M32",                   \
  "R12     R10M",                    \
  "R13     R47M",                    \
  "R14     R100M",                   \
  "R15     R200M",                   \
  "R24     R1G",                     \
  "R20     RX0R01",                  \
  "R21     RX0R1",                   \
  "R22     RX1R",                    \
  "R23     RX10R",                   \
  "C3      ",                        \ // The exact value is unimportant
  "C4      ",                        \ // The exact value is unimportant
  "C5      C27P",                    \
  "C6      C270P",                   \
  "C7      C2N7",                    \
  "C8      C22N",                    \
  "C9      C220N",                   \
  "C10     C2U2",                    \
  "G1      ",                        \ // The exact value is unimportant
  "R9      ",                        \ // Component never comes alone
  "R10     ",                        \ // Component never comes alone
  "SGL     +Rsgl",                   \
  "DBL     +Rthin",                  \
  "WIDE    +Rwide" }

int    rompresent                      // Dallas ROM present and supported
struct t_romdata romdata               // Copy of Dallas ROM
int    romdatavalid                    // Contents of romdata is valid
int    notcertified                    // Certification expired

float  calibration[NPOINT]             // Values from calibration file
int    calvalid[NPOINT]                // Whether calibration[*] valid or not
char   calname[260],calfile[260]       // Name (short/full) of calibration file
int    boardidcode                     // Identification code of the board
char   summary[NSUMMARY,80]            // Summary information
int    nsummary                        // Number of lines in summary information
int    summarygood                     // Final decision

float  idx[16] = {                   \ // X coordinates of identification bits
  -5.0, -1.0,  3.0,  7.0,            \ // (starting from most significant)
  13.0, 17.0, 21.0, 25.0,            \
  35.0, 39.0, 43.0, 47.0,            \
  53.0, 57.0, 61.0, 65.0 }

float  crossx0[8] = {                \ // Board X coord of scan crosses (EL304)
  55.0,  305.0, -12.0, 372.0,        \ // in order of scanning
  55.0,  305.0, -12.0, 372.0 }
float  crossy0[8] = {                \ // Board Y coord of scan crosses (EL304)
  -42.0, -42.0, -42.0, -42.0,        \ // in order of scanning
  352.0, 352.0, 352.0, 352.0 }

float  crossx1[8] = {                \ // Board X coord of scan crosses (EL204)
  55.0,  305.0, -12.0, 372.0,        \ // in order of scanning
  55.0,  305.0, -12.0, 372.0 }
float  crossy1[8] = {                \ // Board Y coord of scan crosses (EL204)
  -42.0, -42.0, -42.0, -42.0,        \ // in order of scanning
  197.0, 197.0, 197.0, 197.0 }

float  crossx2[8] = {                \ // Board X coord of scan crosses (EL504)
  55.0,  305.0, -12.0, 372.0,        \ // in order of scanning
  55.0,  305.0, -12.0, 372.0 }
float  crossy2[8] = {                \ // Board Y coord of scan crosses (EL504)
  -40.0, -40.0, -40.0, -40.0,        \ // in order of scanning
  790.0, 790.0, 790.0, 790.0 }

float  crossx[8]                       // Scan crosses X coords used in test
float  crossy[8]                       // Scan crosses Y coords used in test

#define NERR 16                        // Max number of listed errors per head
char   errlist[4][33][NERR][80]        // List of head-related errors

char   crterr[32,20]                   // List of E_CRTMEAS errors
int    ncrterr                         // Number of errors in crterr[]

#define NREPLAY 1024                   // Max number of protocolled bad meas
struct t_replay replay[NREPLAY]        // Bad measurement that can be repeated
int    nreplay                         // Number of bad measurements

external int SERV.Convertfield(char *answer,float *zc,float *zr);
external int SERV.Convertfastc(char *answer,float *zc,float *zr);
external int SERV.Convertmultic(char *answer,int n,float *zc,float *zr);
external int SERV.Decodeanswer(char *answer,char *text,char *extra,int mask);
external int SERV.Ohmstotext(float r,int status,char *s)
external int SERV.Pftotext(float c,char *s)
external int SERV.Pfpftotext(float c1,float c2,char *s)


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// INTERRUPT HANDLER ///////////////////////////////

#define OSCCOUNT       4096            // Max length of oscillogramm, 2**N!

int    oscactive                       // 1: triggered, 2: osc valid, -1: error
float  osc[OSCCOUNT]                   // Gathered oscillogramm
int    osccount                        // Requested length of oscillogramm
int    nosc                            // Current length of oscillogramm

// Interrupt handler, receives and processes asynchronous messages and errors.
function int Answerproc(char *answer,int info)
  int i
  if answer[4]==0xF0 then              // Internal OLLYTEST message
    if Stricmp(answer+5,"CHG LAY")==0 layoutchanged=1
    if Stricmp(answer+5,"CHG LOAD")==0 then
      loadchanged=1
      if $GLOBAL.headloaded==1 globalerr=globalerr & (~GE_BOOT)
    endif
    return
  else if answer[4]==S_TEST && oscactive==1 &&                                 \
    answer[5]==3 && answer[6]==0x80 && answer[7]==0x00 then
    if $uint2(answer+10)!=nosc then
      oscactive=-1                     // Out of sync
    else if nosc+$uint2(answer+12)>osccount then
      oscactive=-1                     // Invalid length of oscillogramm
    else
      for i=0,i<$uint2(answer+12),i++ do
        osc[nosc]=$float4(answer+14+i*4)-32768.0
        nosc++
      enddo
      if nosc==osccount then
        oscactive=2                    // Oscillogramm gathered
      endif
    endif
  else if answer[4]==S_ERROR then      // Error messages, also with zero ID
    switch answer[5]
    case E_NOCRATDATA,E_NOFINGDATA:
      globalerr=globalerr|GE_BOOT
    case E_ZMOVEMENT:
      if answer[9]==2 && answer[7]!=0xFF then
        i=answer[7]*2+((answer[8] & 0x4C)==0?1:0)
        oversurface[i]++               // Count number of contacts over PCB
      endif
    case E_COMMUTATOR:
      i=$uint2(answer+10)
      if (i & 0x0300)!=0 globalerr=globalerr|GE_MEAS
    case E_TMEAS:
      if answer[9]>=2 globalerr=globalerr|GE_MEAS
    case E_IOERROR:
      globalerr=globalerr|GE_IOERROR
    case E_WRONGCOORD,E_BADCOMMAND,E_BADCMDSIZE,E_TABLEOVERF,E_BADDATA:
      globalerr=globalerr|GE_COMMAND
    case E_SYNC,E_DIVBYZERO:
      globalerr=globalerr|GE_COMMAND
    case E_CONTACT,E_HISHIFT,E_SHORTCUT:
      globalerr=globalerr|GE_MEAS
    case E_INITMEAS:
      i=$uint2(answer+10)
      if (i & 0x7D)!=0 globalerr=globalerr|GE_MEAS
    case E_BOXSENS,E_PNEUMOSENS,E_PNEUMOSYS:
      globalerr=globalerr|GE_HARDWARE
    endsw
    // MSD initialization errors (E_CRTMEAS) are placed in a buffer and will be
    // reported in the protocol.
    if answer[5]==0x59 && ncrterr<32 then
      Memcpy(crterr[ncrterr],answer,20)
      ncrterr++
    endif
  endif
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////// SERVICE FUNCTIONS: STATISTICS /////////////////////////

// Initializes array disp[5] for statistical calculations.
function int Initsigma(float disp[])
  disp[0]=0.0
  disp[1]=0.0
  disp[2]=0.0
  disp[3]=0.0
  disp[4]=0.0
end

// Function adds next measured value to array disp[5] which accumulates data
// necessary to calculate normal dispersion, mean, minimal and maximal.
function int Addsigma(float disp[],float value)
  if disp[0]<=0.0 then
    disp[0]=1.0                        // First point, data is still undefined
    disp[1]=value
    disp[2]=value*value
    disp[3]=value
    disp[4]=value
  else
    disp[0]=disp[0]+1.0
    disp[1]=disp[1]+value
    disp[2]=disp[2]+value*value
    disp[3]=Min(disp[3],value)
    disp[4]=Max(disp[4],value)
  endif
end

// Function returns number of data items gathered by Addsigma().
function int Getcount(float disp[])
  return disp[0]
end

// Function calculates mean value based on data gathered by Addsigma().
function float Getmean(float disp[])
  if disp[0]<1.0 then
    return 0.0
  else
    return disp[1]/disp[0]
  endif
end

// Function calculates mean value based on data gathered by Addsigma(). If
// number of measurements is 8 or more, minimum and maximum are not taken into
// account.
function float Getxmean(float disp[])
  if disp[0]<1.0 then
    return 0.0
  else if disp[0]>=8.0 then
    return (disp[1]-disp[3]-disp[4])/(disp[0]-2.0)
  else
    return disp[1]/disp[0]
  endif
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmin(float disp[])
  return disp[3]
end

// Function calculates minimal value based on data gathered by Addsigma().
function float Getmax(float disp[])
  return disp[4]
end

// Function calculates normal dispersion based on data gathered by Addsigma().
function float Getsigma(float disp[])
  float r
  if disp[0]<2.0 then
    return 0.0
  else
    r=(disp[0]*disp[2]-disp[1]*disp[1])/disp[0]/(disp[0]-1.0)
    if r<=0 then
      return 0.0
    else
      return Sqrt(r)
    endif
  endif
end

// Function calculates normal dispersion based on data gathered by Addsigma().
// If number of measurements is 8 or more, minimum and maximum are not taken
// into account.
function float Getxsigma(float disp[])
  float r,n,s,ss
  if disp[0]<2.0 return 0.0
  if disp[0]>=8.0 then
    n=disp[0]-2.0
    s=disp[1]-disp[3]-disp[4]
    ss=disp[2]-disp[3]*disp[3]-disp[4]*disp[4]
  else
    n=disp[0]
    s=disp[1]
    ss=disp[2]
  endif
  r=(n*ss-s*s)/n/(n-1.0)
  if r<=0 then
    return 0.0
  else
    return Sqrt(r)
  endif
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////// SERVICE FUNCTIONS: QUANTILES /////////////////////////

// These functions allow to select specified number of minimal values from the
// data set.

// Initializes array data[n] for quantile calculations.
function int Initquantile(float data[],int n)
  if n<3 return -1
  data[0]=0                            // Number of data points
  data[1]=n-2                          // Maximal number of data points
  return 0
end

// Adds value to quantile array.
function int Addquantile(float data[],float value)
  int i,j,m,n
  m=data[0]                            // Number of data points
  n=data[1]                            // Maximal number of data points
  for i=0,i<m,i++ do
    if value<data[i+2] break
  enddo
  if i>=n return                       // Value outside the minimal group
  m=Min(m+1,n)
  for j=m-1,j>i,j-- do
    data[j+2]=data[j+1]
  enddo
  data[i+2]=value
  data[0]=m
end

// Returns number of gathered data points.
function int Quantcount(float data[])
  return data[0]
end

// Returns minimal measured value.
function float Quantmin(float data[])
  if data[0]==0 then
    return 0.0                         // As yet no data
  else
    return data[2]
  endif
end

// Returns maximal registered value. Note that this is NOT the maximal measured
// value!
function float Quantmax(float data[])
  int m
  m=data[0]                            // Number of data points
  if m==0 then
    return 0.0                         // As yet no data
  else
    return data[m+1]
  endif
end

// Calculates mean of at most count smallest added values.
function float Quantmean(float data[],int count)
  int i,m
  float mean
  m=data[0]                            // Number of data points
  if m>count m=count
  mean=0.0
  if m>0 then
    for i=0,i<m,i++ do
      mean=mean+data[i+2]
    enddo
    mean=mean/m
  endif
  return mean
end

// Calculates normal dispersion of at most count smallest added values.
function float Quantsigma(float data[],int count)
  int i,m
  float s,ss,r
  m=data[0]                            // Number of data points
  if m>count m=count
  if m<=1 return 0.0
  s=0.0; ss=0.0
  for i=0,i<m,i++ do
    s=s+data[i+2]
    ss=ss+data[i+2]*data[i+2]
  enddo
  r=(m*ss-s*s)/m/(m-1.0)
  if r<=0 then
    return 0.0
  else
    return Sqrt(r)
  endif
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// SERVICE FUNCTIONS ///////////////////////////////

// Display modal "dialog box" with error message.
function int Error(char *s1,char *s2)
  handle herr,hdummy,hok
  herr=control WINDOW
    window=hmain
    position=0,0,250,135
    name="?"
    mode=M_MODAL
    bkcolor=YELLOW
  endc
  hok=control BUTTON
    window=herr
    position=85,100,80,24
    name="?"
    help="?????????"
  endc
  hdummy=control ICON
    window=herr
    position=5,30,36,36
    name="EXCLAM"
    bkcolor=YELLOW
  endc
  hdummy=control TEXT
    window=herr
    position=41,20,200,24
    name=s1
    bkcolor=YELLOW
    mode=M_CENTERED
  endc
  hdummy=control TEXT
    window=herr
    position=41,45,200,54
    name=s2
    bkcolor=YELLOW
    mode=M_CENTERED
  endc
  while Pressed(hok)==0 do; enddo
  destroy herr
end

// Service function, prints value right-aligned in exactly 8 characters, first
// being space. If value is outside the range [-9999.9,9999.9], prints "<-9999"
// or ">9999". Returns 8 - the length of the printed string.
function int Print8(float value,char *s)
  if value<(-9999.9) then
    sprintf(s,"  <-9999")
  else if value>9999.9 then
    sprintf(s,"   >9999")
  else
    sprintf(s," %7.3g",value)
  endif
  return 8
end

// Writes record to c:\hardware\calibrationlog.txt. Returns 0 on success and -1
// on error.
function int Addcalibrationrecord(format message)
  handle f
  char s[256]
  f=Fopen("c:\\hardware\\calibrationlog.txt","at")
  if f==NULL return -1
  Strtime(s,"%a %d-%b-%Y %H:%M",0,0)
  fprintf(f,"%s  Meastest v%s  %s\n",s,VERSION,message)
  Fclose(f)
  return 0
end

// Clears contact-over-surface counters.
function int Clearoversurface()
  int i
  for i=0,i<32,i++
    oversurface[i]=0
  enddo
end

// Reports (if necessary) how many contacts over surface detected.
function int Oversurface()
  int i,n,badheads
  for i=0,i<$LAY.nfing*2,i++
    n=n+oversurface[i]
    if oversurface[i]>0 badheads++
  enddo
  if n==0 return                       // No contacts over surface
  if hlist!=NULL then                  // Message in message list
    change hlist color=LIGHTRED
    add hlist text=""
    add hlist text=format("Attention, %i contact%s over surface detected!",    \
    n,oversurface[i]==1?"":"s")
  endif
  if txtok!=0 then                     // Message in text file
    fprintf(hlog,"\n\nATTENTION, tester detected ")
    fprintf(hlog,"%i contact%s over surface ",n,(n==1?"":"s"))
    fprintf(hlog,"on the following head%s:\n\n",badheads==1?"":"s")
    for i=0,i<$LAY.nfing*2,i++ do
      if oversurface[i]==0 continue
      fprintf(hlog,"      Head %2i%c    - %4i contact%c over surface\n",       \
      i/2,((i & 1)==0?'L':'R'),oversurface[i],oversurface[i]==1?' ':'s')
    enddo
    fprintf(hlog,"\nFor this reason, measurements above may be unreliable.\n\n")
  endif
  if rtfok!=0 then                    // Message in RTF file
    RParagraph(RTF_FORMAT)
    RFmt(RTF_TIMES,RTF_BOLD,9)
    RAddtext("\nAttention")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RAddfmt(", tester detected %i contact%s over surface ",n,(n==1?"":"s"))
    RAddfmt("on the following head%s:\n\n",badheads==1?"":"s")
    for i=0,i<$LAY.nfing*2,i++ do
      if oversurface[i]==0 continue
      RAddfmt("      Head %2i%c    - %4i contact%c over surface\n",            \
      i/2,((i & 1)==0?'L':'R'),oversurface[i],oversurface[i]==1?' ':'s')
    enddo
    RAddtext("\nFor this reason, measurements above may be unreliable.\n")
  endif
  Clearoversurface()
end

// Check whether some critical error was detected, such as broken cable, absent
// measurement card, damaged locks etc. Returns 0 if test should continue, 1 if
// tester to be rebooted, or -1 if operator decided to interrupt the test.
function int Checkgloberrors()
  int err
  handle hcont,hboot
  if globalerr==0 return 0
  change hinfo limits=0,0
  change hinfo text="?2a??"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED text="Critical error detected!"
  draw at 6,60 color=BLACK
  if globalerr & GE_BOOT then
    draw text="Tester is not booted. Probably emergency switch was activated, "
    draw text="or embedded software crashed. If you have rebooted tester, "
    draw text="please ignore this error and press " font=MAINFONT text="????"
    draw font=TIMESFONT text="."
    err=1
  else if globalerr & GE_HARDWARE then
    draw text="Embedded software discovered some problems with shuttle. Please "
    draw text="check sensors and pneumatics. "
    err=0
  else if globalerr & GE_IOERROR then
    draw text="????t?2a??D????? "
    draw text="???1a?????y3???"
    err=2
  else if globalerr & GE_COMMAND then
    draw text="Embedded software rejected some command. Please check the "
    draw text="version of C_PROG.BIN. "
    err=2
  else if globalerr & GE_MEAS then
    draw text="Self-test has detected severe error in measurement electronics. "
    draw text="Please check the measurement hardware. "
    err=2
  else
    draw text="Some internal error occured. "
    err=2
  endif
  globalerr=0                          // Two errors at once? Hardly possible.
  hboot=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="????"
    help="??????D??????2a??3D"
  endc
  hcont=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="?D?"
    help="???D?2a??????o"
  endc
  if err==0 then                       // No serious error
    draw text="Press 'Continue' to continue test."
    disable hboot
  else if err==1 then
    draw text="You must reboot the tester and restart test."
    disable hcont
  else
    draw text="\n?D?2a??23?1??"
    draw text="????2a?????o3D?D?"
    draw text="2a??????"
  endif
  draw show
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hboot) then
      return 1
    else if Pressed(hcont) then
      return 0
    endif
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
/////////////////////// SERVICE FUNCTIONS: VIDEO CAMERAS ///////////////////////

// Given video channel, returns head that carries corresponding video camera,
// or -1 if channel is invalid or not assigned.
function int Headfromchannel(int channel)
  int head,n
  if $LAY.cameras!=0 then
    if channel==0 return $LAY.nfing*2
    if channel==1 return $LAY.nfing*2+1
  else
    n=0
    for head=0,head<$LAY.nfing*2,head++ do
      if ($LAY.headcameras & (1<<head))==0 continue
      if channel==n return head
      n++
    enddo
  endif
  return -1
end

// Given head, returns associated video channel, or -1 if head is invalid or
// carries no camera.
function int Channelfromhead(int head)
  int i,channel
  if $LAY.cameras!=0 then
    if head==$LAY.nfing*2 return 0
    if head==$LAY.nfing*2+1 return 1
  else if ($LAY.headcameras & (1<<head))!=0 then
    channel=0
    for i=0,i<head,i++ do
      if ($LAY.headcameras & (1<<i))!=0 channel++
    enddo
    return channel
  endif
  return -1
end

// Given Y coordinate in millimeters, selects camera controller and
// corresponding video channel. Returns head on success, and -1 on any error.
function int Camerafromy(float y,int *channel,int *side,float *angle)
  int head
  float h
  if $LAY.cameras!=0 then
    if ($LAY.cameras & 0x3)==0x1 then
      channel[0]=0
    else if ($LAY.cameras & 0x3)==0x2 then
      channel[0]=1
    else if ($int2($LAY+764) & 0x4000)!=0 then
      channel[0]=1
    else
      channel[0]=0
    endif
    side[0]=channel[0]
    angle[0]=0.0
    return $LAY.nfing*2+channel[0]
  else if $LAY.headcameras!=0 then
    for head=0,head<$LAY.nfing*2,head++ do
      if used[head]==0 continue
      if ($LAY.headcameras & (1<<head))==0 continue
      if $LAY.top[head/2]/1000.0<y-MAXDY continue
      if $LAY.bottom[head/2]/1000.0>y+MAXDY continue
      break
    enddo
    if head>=$LAY.nfing*2 return -1
    channel[0]=Channelfromhead(head)
    side[0]=$LAY.side[head/2]
    h=y-$LAY.yoffset[head/2]/1000.0
    angle[0]=(Abs(h)>0.9*headcamradius?0.0:Asin(h/headcamradius))
    if side[0]!=0 angle[0]=-angle[0]
    if (head & 1)!=0 angle[0]=-angle[0]
    return head
  else
    return -1                          // No cameras
  endif
end

// Reads individual per-camera brightness, contrast, illumination type and
// focal coordinate from .ini file.
function int Bcgetini()
  int head,bri,ctr
  char key[32]
  // Get defaults for the first run.
  illtype=0x03; longexp=0;
  getini("Video","Illumination type","%i,%i",&illtype,&longexp)
  bri=0; getini("ScrollAutoSave","Brightness","%i",&bri)
  ctr=0; getini("ScrollAutoSave","Contrast","%i",&ctr)
  focus[0]=-1000; getini("Video","Meastest focus[0]","%i",focus+0)
  focus[1]=-1000; getini("Video","Meastest focus[1]","%i",focus+1)
  for head=0,head<32,head++ do
    brightness[head]=bri
    contrast[head]=ctr
    if individualbc then
      sprintf(key,"Brightness[%i]",head)
      getini("Video",key,"%i",brightness+head)
      sprintf(key,"Contrast[%i]",head)
      getini("Video",key,"%i",contrast+head)
    endif
  enddo
end

// Saves individual per-camera brightness and contrast values to .ini file
function int Bcsetini()
  int head
  char key[32]
  setini("Video","Illumination type","%i,%i",illtype,longexp)
  setini("Video","Meastest focus[0]","%i",focus[0])
  setini("Video","Meastest focus[1]","%i",focus[1])
  if individualbc==0 then
    // No individual settings.
    setini("ScrollAutoSave","Brightness","%i",brightness[0])
    setini("ScrollAutoSave","Contrast","%i",contrast[0])
  else
    // Individual per-camera settings.
    for head=0,head<($LAY.nfing+1)*2,head++ do
      if $LAY.cameras!=0 then
        if head<$LAY.nfing*2 continue
        if ($LAY.cameras & (1<<(head-$LAY.nfing*2)))==0 continue
      else
        if ($LAY.headcameras & (1<<head))==0 continue
      endif
      sprintf(key,"Brightness[%i]",head)
      setini("Video",key,"%i",brightness[head])
      sprintf(key,"Contrast[%i]",head)
      setini("Video",key,"%i",contrast[head])
    enddo
  endif
end

// Connects brightness and contrast controls to the specified head.
function int Bcsetcam(int channel)
  int head
  if individualbc==0 return
  head=Headfromchannel(channel)
  if head==bchead then
    return
  else if head>=0 && head<32 then
    if hbrightness!=NULL change hbrightness select=brightness[head]
    if hcontrast!=NULL change hcontrast select=contrast[head]
    if hfocus!=NULL && (head==$LAY.nfing*2 || head==$LAY.nfing*2+1) then
      change hfocus text=format(" %i",focus[head-$LAY.nfing*2])
    endif
    bchead=head
  else
    bchead=-1
  endif
end

// Creates brightness, contrast and illumination or focus controls at the
// specified location (default location if x and y are -1).
function int Bccreate(handle hparent,int x,int y,int channel,int mode)
  if x<0 x=5
  if y<0 y=303
  if mode!=0 then
    if testertype==TT_S3 then
      mode=2                           // Create focus controls
    else if (testertype==TT_A7 || testertype==TT_A8) then
      mode=1                           // Create illumination controls
    else
      mode=0
    endif
  endif
  hbrititle=control TEXT
    window=hparent
    position=x,y+4,27,16
    name="???"
    help=" "
    font=INFOFONT
  endc
  hbrightness=control HSCROLL
    window=hparent
    position=x+32,y+2,(mode?120:150),21
    name=(individualbc?"":"?")
    help=format("???????%s",                                  \
      individualbc?" ???????":"")
    limits=-100,100
  endc
  hctrtitle=control TEXT
    window=hparent
    position=x,y+31,27,16
    name="??1a"
    help=" "
    font=INFOFONT
  endc
  hcontrast=control HSCROLL
    window=hparent
    position=x+32,y+29,(mode?120:150),21
    name=(individualbc?"":"???")
    help=format("???????%s",                       \
      individualbc?" ??????1a??":"")
    limits=-100,100
  endc
  if mode==1 then
    // Illumination controls.
    hilltop=control CHECKBOX
      window=hparent
      position=x+160,y,50,18
      name="?"
      help="?a?2????????D????DD"
      font=INFOFONT
      mode=((illtype & 0x0C)==0 || (illtype & 0x4)!=0?M_CHECKED:0)
    endc
    hillskew=control CHECKBOX
      window=hparent
      position=x+160,y+18,55,18
      name="D"
      help="?a2?????????D????DD"
      font=INFOFONT
      mode=((illtype & 0x08)!=0?M_CHECKED:0)
    endc
    hilllong=control CHECKBOX
      window=hparent
      position=x+160,y+36,55,18
      name="????"
      help="3????1a??????????"
      font=INFOFONT
      mode=(longexp?M_CHECKED:0)
    endc
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  else if mode==2 then
    // Focus controls.
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=control TEXT
      window=hparent
      position=x+160,y+31,45,16
      name="???1"
      help=" "
      font=INFOFONT
    endc
    hfocusup=control BUTTON
      window=hparent
      position=x+205,y+29,21,21
      name="-"
      help="????????"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
    hfocus=control TEXT
      window=hparent
      position=x+225,y+29,62,21
      help="????Z????"
      font=MEDIUMFONT
      mode=M_BORDER
      bkcolor=LIGHTYELLOW
      color=DARKGRAY
    endc
    hfocusdn=control BUTTON
      window=hparent
      position=x+286,y+29,21,21
      name="+"
      help="?????????"
      font=MEDIUMFONT
      mode=M_REPEAT
    endc
  else
    hilltop=NULL
    hillskew=NULL
    hilllong=NULL
    hfoctitle=NULL
    hfocusup=NULL
    hfocus=NULL
    hfocusdn=NULL
  endif
  bchead=-1
  Bcsetcam(channel)
end

// Checks whether user has changed brightness, contrast or illumination and
// updates data. Returns combination of 0x01 (if brightness or contrast was
// changed) and 0x02 (if illumination type was changed). Additionally, sets
// S3 focus.
function int Bcupdate()
  int head,cam,changed,n
  char s[80]
  if individualbc==0 then
    head=0
  else if bchead<0 || bchead>=32 then
    return 0
  else
    head=bchead
  endif
  changed=0
  if hbrightness!=NULL && Pressed(hbrightness) then
    brightness[head]=Status(hbrightness)
    changed=changed | 0x01
  endif
  if hcontrast!=NULL && Pressed(hcontrast) then
    contrast[head]=Status(hcontrast)
    changed=changed | 0x01
  endif
  if hilltop!=NULL && Pressed(hilltop) then
    if Status(hilltop)!=0 then
      illtype=illtype|0x04
    else
      illtype=illtype & (~0x04)
      if (illtype & 0x0C)==0 then
        illtype=0x0B
        change hillskew mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hillskew!=NULL && Pressed(hillskew) then
    if Status(hillskew)!=0 then
      illtype=illtype|0x08
    else
      illtype=illtype & (~0x08)
      if (illtype & 0x0C)==0 then
        illtype=0x07
        change hilltop mode=M_CHECKED
      endif
    endif
    changed=changed | 0x02
  endif
  if hilllong!=NULL && Pressed(hilllong) then
    longexp=Status(hilllong)
    changed=changed | 0x01
  endif
  if hfocus!=NULL then
    n=Min(Pressed(hfocusdn),3)
    n=n-Min(Pressed(hfocusup),3)
    cam=head-$LAY.nfing*2
    if n!=0 && (cam==0 || cam==1) then
      focus[cam]=Max(-8000,Min(focus[cam]+n*20,8000))
      change hfocus text=format(" %i",focus[cam])
      updatefocus[cam]=1
    endif
  endif
  if testertype==TT_S3 then
    if ($LAY.cameras & 0x1)!=0 && updatefocus[0]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+0,focus[0])
      SERV.Cmdimm(32,s)
      updatefocus[0]=0
    endif
    if ($LAY.cameras & 0x2)!=0 && updatefocus[1]!=0 then
      sprintf(s,"OUTPORT32 HEAD(%i) 0x10010008,%i",$LAY.nfing*2+1,focus[1])
      SERV.Cmdimm(32,s)
      updatefocus[1]=0
    endif
  endif
  return changed
end

// Deletes brightness and contrast controls. It's not a sin to forget to call
// this function, but then better not call any Bcxxx() except Bccreate() or
// Bcdisable().
function int Bcdelete()
  if bchead<0 return
  destroy hbrititle; hbrititle=NULL
  destroy hbrightness; hbrightness=NULL
  destroy hctrtitle; hctrtitle=NULL
  destroy hcontrast; hcontrast=NULL
  bchead=-1
  if hilltop!=NULL then
    destroy hilltop; hilltop=NULL
    destroy hillskew; hillskew=NULL
    destroy hilllong; hilllong=NULL
  endif
  if hfocus!=NULL then
    destroy hfoctitle; hfoctitle=NULL
    destroy hfocusup; hfocusup=NULL
    destroy hfocus; hfocus=NULL
    destroy hfocusdn; hfocusdn=NULL
  endif
end

// Disables brightness and contrast processing in the case that corresponding
// controls were not deleted by Bcdelete()
function int Bcdisable()
  hbrititle=NULL
  hbrightness=NULL
  hctrtitle=NULL
  hcontrast=NULL
  bchead=-1
  hilltop=NULL
  hillskew=NULL
  hilllong=NULL
  hfoctitle=NULL
  hfocusup=NULL
  hfocus=NULL
  hfocusdn=NULL
end

// Returns current brightness (-100..100) for the specified channel.
function int Bcgetbri(int channel)
  int head
  if individualbc==0 then
    return brightness[0]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return brightness[head]
  endif
end

// Returns current contrast (-100..100) for the specified head.
function int Bcgetctr(int channel)
  int head
  if individualbc==0 then
    return contrast[0]
  endif
  head=Headfromchannel(channel)
  if head<0 || head>=32 then
    return 0
  else
    return contrast[head]
  endif
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// BOARD COORDINATES ///////////////////////////////

// Function converts OlliBoard coordinates xb,yb into tester coordinates xt,yt.
// Then it adds random offset limited to (-delta,+delta). In-place conversion
// is also allowed here.
function int Convert(float *xt,float *yt,float xb,float yb,float delta)
  float x,y
  x=xb*convcfi-yb*convsfi+convdx
  y=xb*convsfi+yb*convcfi+convdy
  if delta>0.0 then
    x=x+Random(delta)+Random(delta)-delta
    y=y+Random(delta)+Random(delta)-delta
  endif
  xt[0]=x
  yt[0]=y
end

// Calculates tester coordinates xt,yt of pad name for given head, then adds
// random offset limited to (-delta,+delta). Returns -1.0 if pad is not found
// and non-negative related value if coordinates are calculated.
function float Convertpad(float *xt,float *yt,char *name,int head,float delta)
  int i
  float x,y
  for i=0,i<NPOINT,i++ do
    if Strcmp(name,xname[i])==0 break
  enddo
  if i>=NPOINT return -1.0
  // Pad OWNC is not shiftable.
  if Strcmp(name,"OWNC")==0 then
    x=xpos[i]*convcfi-ypos0[head]*convsfi+convdx
    y=xpos[i]*convsfi+ypos0[head]*convcfi+convdy
  else
    x=xpos[i]*convcfi-ypos[head]*convsfi+convdx
    y=xpos[i]*convsfi+ypos[head]*convcfi+convdy
    if delta>0.0 then
      x=x+Random(delta)+Random(delta)-delta
      y=y+Random(delta)+Random(delta)-delta
    endif
    // When testing no contact, shift contacting point vertically to the center
    // of the rail, to avoid penetration into hole. Hole is OK for normal
    // needles but causes problems for A5/A6 splinogramms.
    if Strcmp(name,"NOCT2")==0 && (boardtype==1 || boardtype==2) then
      if y<$LAY.yoffset[head/2]/1000.0 then
        y=y+5.0
      else
        y=y-5.0
      endif
    endif
  endif
  xt[0]=x
  yt[0]=y
  return value[i]
end

// Given pad name, returns associated value, or negative value on any error.
function float Getvaluebyname(char *name)
  int i
  for i=0,i<NPOINT,i++ do
    if Strcmp(name,xname[i])==0 then
      return value[i]
    endif
  enddo
  return -1.0
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// TESTER AND LAYOUT ///////////////////////////////

// Assure that tester is loaded and that debug mode does not make test void.
function int Loadtester()
  int i,j,t,err,nframes
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="?t???"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK
  draw at 6,30 text="3????????... "
  draw show
  delay 500
  SYS.Softimm(0); softreset=1
  t=Time(); i=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("y?t??? - %i s",j)
      i=j
    endif
    if j>15 break
    wait
  enddo
  clear hright
  draw window=hright font=TIMESFONT
  if $A[0].length==0 then
    change hinfo name="????T|e"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is off\n"
    draw text="- Flying Debugger or Test Player is running\n"
    draw text="- Crash in embedded software\n"
    draw text="- Optocable is pulled out\n"
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="???"
      help="??????D?3???"
    endc
    while 1 do
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      wait
    enddo
  else if $A[0].answer==S_ERROR &&                                             \
    ($A[0].subcmd==E_NOCRATDATA || $A[0].subcmd==E_NOFINGDATA) then
    change hinfo name="2a??????"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="The Flying Probe Tester is not loaded. Of course, it "
    draw color=LIGHTRED text="must " color=BLACK
    draw text="be loaded before you can start test. Typically, all you "
    draw text="need is to press 'Load all' in the appearing window. "
    if $GLOBAL.disabledrails!=0 then
      draw text="Please check for rails disabled in the Debug mode. "
    endif
    if ($GLOBAL.debugmode & 0x20BF)!=0 || ($GLOBAL.videomode & 0x20BF)!=0 ||   \
      $uint4($GLOBAL+280)!=0 then
      draw color=LIGHTRED
      draw text="Please also check that current Debug mode really allows you "
      draw text="to test measurement system!"
    endif
    err=SYS.Videosize(0,&i,&j,&nframes);
    if err!=0 || nframes==0 then
      draw color=BLACK
      draw text="\nNote also that frame grabber in your system is not "
      draw text="accessible. Either it is absent, or not installed, or "
      draw text="OllyTest was unable to locate support DLLs."
    else if nframes<4 then
      draw color=BLACK
      draw text="\nNote also that amount of memory allocated to frame grabber "
      draw text="is too low which may cause problems during the test. We "
      draw text="recommend that you set frame buffer to 2 Mb."
    endif
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="o??D2a??"
      help="?????????2a??3D"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="???"
      help="??????D?3???"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if $A[0].answer!=S_RESET then
    change hinfo name="?????"
    draw at 6,30 wrap=RIGHTX-5 color=BLACK
    draw text="Flying Probe Tester returned some unexpected answer. Normally, "
    draw text="this never happens. All I may suggest is to press Hard Reset "
    draw text="and then reboot the tester. "
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="o??D????"
      help="?????????2a??3D"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="???"
      help="??????D?3???"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  endif
  return 0
end

function int Getlayout()
  int i,j,t,ident,err
  char buf[16]
  handle hload,hretry
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="???2???"
  delay 300
  buf[0]=S_LAYOUT
  buf[1]=0x03                          // Read layout with corrected phases
  ident=SYS.Sendimm(0,2,buf)
  t=Time(); i=0; err=0
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("y2??? - %i s",j)
      i=j
    endif
    if j>15 break
    wait
  enddo
  if $A[0].length==0 then
    err=2
  else if $A[0].answer!=S_LAYOUT || $A[0].length!=774 then
    err=1
  else
    // Layout received. Get layout extentions.
    Memcpy($LAY,$A[0]+6,768)
    for i=0,i<16,i++                   // Same offsets in tester & inner copy
      $LAYCORR.leftzerox[i]=$LAY.leftzerox[i]
      $LAYCORR.leftzeroy[i]=$LAY.leftzeroy[i]
      $LAYCORR.rightzerox[i]=$LAY.rightzerox[i]
      $LAYCORR.rightzeroy[i]=$LAY.rightzeroy[i]
    enddo
    if $LAY.extlay>=1 then
      buf[0]=S_LAYOUT
      buf[1]=15                        // Read main layout extention
      SYS.Sendimm(0,2,buf)
    endif
    for j=1,j<$LAY.extlay && j<5,j++ do
      buf[0]=S_LAYOUT
      buf[1]=20                        // Read additional layout extention
      $int4(buf+2)=j-1                 // Index
      SYS.Sendimm(j,6,buf)
    enddo
    i=-1
    while 1 do
      for j=0,j<$LAY.extlay && j<5,j++ do
        if $A[j].length==0 break
        if $A[j].answer!=S_LAYOUT || $A[j].length!=(j==0?774:778) then
          err=1; break                 // Invalid answer
        endif
      enddo
      if err!=0 || j>=$LAY.extlay break
      if Pressed(hexit) return -1
      j=(Time()-t)/1000
      if i!=j then
        change hinfo text=format("y2??? - %i s",j)
        i=j
      endif
      if j>15 then
        err=2; break                   // Timeout!
      endif
      wait
    enddo
    if err==0 then
      if $LAY.extlay==0 then
        i=0
      else
        for i=0,i<768,i++ do
          if $char($A[0]+6+i)!=0 break
        enddo
      endif
      if i==768 then
        err=4
      else
        Memcpy($EXTLAY,$A[0]+6,768)
        if $LAY.extlay>=2 then
          Memcpy($EXT0,$A[1]+10,768)
        else
          Memset($EXT0,0,768)
        endif
        if $LAY.extlay>=3 then
          Memcpy($EXT1,$A[2]+10,768)
        else
          Memset($EXT1,0,768)
        endif
        if $LAY.extlay>=4 then
          Memcpy($EXT2,$A[3]+10,768)
        else
          Memset($EXT2,0,768)
        endif
        if $LAY.extlay>=5 then
          Memcpy($EXT3,$A[4]+10,768)
        else
          Memset($EXT3,0,768)
        endif
      endif
    endif
    SYS.Broadcast(8,"CHG LAY")         // Inform others that layout changed
  endif
  if err==0 then
    buf[0]=S_DUMP                      // Get version of embedded software
    buf[1]=255                         // Request to crate controller
    buf[2]=0x14                        // Get software version
    $uint2(buf+3)=0                    // Number of items
    $uint2(buf+5)=0                    // Start item
    ident=SYS.Sendimm(0,7,buf)
    change hinfo text="????t??"
    delay 300
    t=Time(); i=0; err=0
    while $A[0].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as an interrupt
      if (Time()-t)>5000 break         // Timeout 5 seconds
      wait
    enddo
    if $A[0].length==0 then
      err=2
    else if $A[0].answer==S_DUMP then  // Correct answer, extract subfields
      j=5
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(crateversion,$A[0]+j)
      j=i
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(layoutversion,$A[0]+j)
      j=i
      for i=j,i<$A[0].length,i++
        if $A[0].rawdata[i]==0x0A then
          $A[0].rawdata[i]='\0'; i++
          break
        endif
      enddo
      Strcpy(headversion,$A[0]+j)
    else
      err=3
    endif
  endif
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if err==1 || err==3 || err==4 then
    if err==1 then
      change hinfo text="Error getting layout"
      draw text="The script was unable to get layout correctly. "
    else if err==3 then
      change hinfo text="Error getting version"
      draw text="The script was unable to get version of loaded software. "
    else
      change hinfo text="Error getting layout"
      draw text="Main layout extention is missing or zeroed. "
    endif
    draw text="This error is absolutely unexpected here. Perharps, the best "
    draw text="way to recover is to reboot the tester. If you select this "
    draw text="option, then in the appearing window first press 'Hard reset', "
    draw text="then 'Load all'. After the tester is loaded, try again."
    draw show
    hload=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="o??D????"
      help="??????D??????2a??3D"
    endc
    hretry=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="???"
      help="??????D?3????2???????t??"
    endc
    loadchanged=0
    while 1 do
      if Pressed(hload) SYS.Start("LOADER",0,"")
      if Pressed(hretry) goto repeat
      if Pressed(hexit) return -1
      if loadchanged!=0 && $GLOBAL.headloaded==1 break
      wait
    enddo
  else if err==2 then
    change hinfo text="No answer from crate"
    draw text="No answer from the Flying Probe Tester. There is a variety of "
    draw text="possible reasons. The most probable are:\n" color=LIGHTRED
    draw text="- Tester is off\n"
    draw text="- Flying Debugger or Test Player is running\n"
    draw text="- Crash in embedded software\n"
    draw text="- Optocable is pulled out\n"
    draw color=BLACK text="Please correct the problem and try again."
    draw show
    hretry=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="???"
      help="??????D?3???"
    endc
    while 1 do
      if Pressed(hretry) break
      if Pressed(hexit) return -1
      wait
    enddo
  else
    leftvlimit=($LAY.leftlimit+$LAY.videodeadx)/1000.0+MAXERR
    rightvlimit=($LAY.rightlimit-$LAY.videodeadx)/1000.0-MAXERR
  endif
  return err
end

// Function writes corrected layout to disk and, if specified, loads corrected
// measurement parameters and layout extentions to the tester.
function int Loadlayoutmeas(char *layout,char *extention,int reload)
  int i,j,len,err,t,nextent,maxextent,flashtime
  char s[260],buf[774]
  handle f,hlayoutname,hbrowse,hwrite,hcancel,hretry
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="????2?y?31|D?y?"
  draw text="?????????t?y?Y?"
  draw show
  hlayoutname=control COMBOEDIT
    window=hright
    position=5,USERY-130,RIGHTX-10,120
    name="2??????t"
    help="o??2a??2???????t"
    mode=M_VSCROLL
  endc
  hbrowse=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="?"
    help="?2?????3?"
  endc
  hwrite=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="?"
    help="????y?2???????????t"
  endc
  hcancel=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="???"
    help="???D??2???????"
  endc
  flashtime=1
  while 1 do
    if flashtime!=0 && flashtime<Time() then
      change hinfo color=BLACK
      change hinfo text="????????t"
      flashtime=0
    endif
    if Pressed(hbrowse) then
      Text(hlayoutname,s)
      if SYS.Browse(hmain,s,"Specify layout name",0)!=0 then
        change hlayoutname text=s
      endif
    else if Pressed(hwrite) then
      confirm hlayoutname
      Text(hlayoutname,s)
      if s[0]=='\0' then
        change hinfo color=LIGHTRED
        change hinfo text="Invalid name!"
        flashtime=Time()+1000
      else
        err=0
        f=Fopen(s,"wb")
        if f==NULL err=1
        // Save main layout.
        if err==0 && Fwrite(layout,768,f)!=768 err=2
        // Determine number of layout extentions to save.
        nextent=0
        if err==0 then
          for i=4,i<768,i++ do         // First 4 bytes are validity marker
            if $char($EXT3+i)!=0 break
          enddo
          if i<768 nextent=5
          if nextent==0 then
            for i=4,i<768,i++ do
              if $char($EXT2+i)!=0 break
            enddo
            if i<768 nextent=4
          endif
          if nextent==0 then
            for i=4,i<768,i++ do
              if $char($EXT1+i)!=0 break
            enddo
            if i<768 nextent=3
          endif
          if nextent==0 then
            for i=4,i<768,i++ do
              if $char($EXT0+i)!=0 break
            enddo
            if i<768 nextent=2
          endif
          if nextent==0 then
            for i=0,i<768,i++
              if extention[i]!=0 break
            enddo
            if i<768 nextent=1
          endif
        endif
        if err==0 && nextent>=1 then
          if Fwrite(extention,768,f)!=768 err=2
        endif
        if err==0 && nextent>=2 then
          $int4($EXT0)=0x30747845
          if Fwrite($EXT0,768,f)!=768 err=2
        endif
        if err==0 && nextent>=3 then
          $int4($EXT1)=0x31747845
          if Fwrite($EXT1,768,f)!=768 err=2
        endif
        if err==0 && nextent>=4 then
          $int4($EXT2)=0x32747845
          if Fwrite($EXT2,768,f)!=768 err=2
        endif
        if err==0 && nextent>=5 then
          $int4($EXT3)=0x33747845
          if Fwrite($EXT3,768,f)!=768 err=2
        endif
        Fclose(f)
        if err==1 then
          change hinfo color=LIGHTRED
          change hinfo text="Error saving layout to file!"
          flashtime=Time()+1000
        else if err==2 then
          change hinfo color=LIGHTRED
          change hinfo text="Unable to create file!"
          flashtime=Time()+1000
        else
          break
        endif
      endif
    else if Pressed(hcancel) then
      change hinfo color=BLACK
      return 1
    endif
    wait
  enddo
  Memcpy($LAY,layout,768)
  Memcpy($EXTLAY,extention,768)
  SYS.Broadcast(8,"CHG LAY")           // Inform others that layout changed
  if reload==0 return 0
  change hinfo text="Reloading layout"
  clear hright
  draw window=hright font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5 color=BLACK
  draw text="Now reloading corrected layout and layout extentions to tester."
  draw show
  err=0
  // Reload measurement parameters. Answer indicates whether and how many
  // additional layout extentions are supported. Layout may be larger than
  // tester accepts!
  buf[0]=S_LOADRUN
  buf[1]=4                             // Reload measurement parameters
  $int4(buf+2)=0                       // Dummy zero bytes
  Memcpy(buf+6,layout,768)
  if SYS.Sendimm(0,774,buf)<=0 err=1   // Unable to send command
  t=Time(); i=-1
  while $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("Reloading layout - %i s",j)
      i=j
    endif
    if j>=120 then
      SYS.Killimm(0)
      err=2; break                     // Timeout
    endif
    wait
  enddo
  if err==0 && $A[0].answer!=S_LOADRUN then
    err=3
  endif
  // Calculate total number of layout extentions to load.
  nextent=0
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 then
    maxextent=1
  else if $A[0].length>=7 then
    maxextent=$char($A[0]+6)
  else
    maxextent=1
  endif
  if maxextent>=5 then
    for i=4,i<768,i++ do               // First 4 bytes are validity marker
      if $char($EXT3+i)!=0 break
    enddo
    if i<768 nextent=5
  endif
  if nextent==0 && maxextent>=4 then
    for i=4,i<768,i++ do
      if $char($EXT2+i)!=0 break
    enddo
    if i<768 nextent=4
  endif
  if nextent==0 && maxextent>=3 then
    for i=4,i<768,i++ do
      if $char($EXT1+i)!=0 break
    enddo
    if i<768 nextent=3
  endif
  if nextent==0 && maxextent>=2 then
    for i=4,i<768,i++ do
      if $char($EXT0+i)!=0 break
    enddo
    if i<768 nextent=2
  endif
  if nextent==0 then
    for i=0,i<768,i++ do
      if $char($EXTLAY+i)!=0 break
    enddo
    if i<768 nextent=1
  endif
  // Send additional layout extentions. Note that main extention is sent
  // afterwards, this is the recommended order (although this does not matter
  // if tester was completely loaded before).
  for j=1,j<nextent && err==0,j++ do   // Note: nextent<=5
    buf[0]=S_LOADRUN
    buf[1]=20                          // Load additional layout extention
    $int4(buf+2)=j-1                   // Index
    if j==1 then
      Memcpy(buf+6,$EXT0,768)
    else if j==2 then
      Memcpy(buf+6,$EXT1,768)
    else if j==3 then
      Memcpy(buf+6,$EXT2,768)
    else
      Memcpy(buf+6,$EXT3,768)
    endif
    if SYS.Sendimm(j,774,buf)<=0 err=1 // Unable to send command
  enddo
  // Send main layout extention.
  if err==0 && nextent>=1 then
    buf[0]=S_LOADRUN
    buf[1]=15                          // Load main layout extention
    $int4(buf+2)=0                     // Dummy zero bytes
    Memcpy(buf+6,$EXTLAY,768)
    if SYS.Sendimm(0,774,buf)<=0 err=1 // Unable to send command
  endif
  i=-1
  while err==0 do
    for j=0,j<nextent,j++ do
      if $A[j].length==0 break
      if $A[j].answer!=S_LOADRUN err=3
    enddo
    if j>=nextent break                // All answers are back
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("Reloading layout - %i s",j)
      i=j
    endif
    if j>=120 then
      for j=0,j<nextent,j++ do
        SYS.Killimm(j)
      enddo
      err=2; break                     // Timeout
    endif
    wait
  enddo
  i=Checkgloberrors()                  // Necessary after measurement test
  if err==0 || i!=0 return i
  change hinfo text="!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Unable to send command!"
  else if err==2 then
    draw text="No answer within 90 seconds!"
  else
    draw text="Command executed incorrectly!"
  endif
  draw at 6,60 wrap=RIGHTX-5 color=BLACK
  hretry=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?2?"
    help="????D??22a???"
  endc
  draw text="Script was unable to load tester with corrected layout. It is "
  draw text="necessary to re-check the status of the tester."
  draw show
  while 1 do
    if Pressed(hretry) return 1        // Check tester status again
    if Pressed(hexit) return -1        // Quit script
    wait
  enddo
end

// Given Y coordinate in millimeters, selects rail on the top side. Returns
// rail on succes, and -1 on any error.
function int Toprailfromy(float y)
  int rail
  for rail=0,rail<$LAY.nfing,rail++ do
    if $LAY.side[rail]!=0 continue
    if $LAY.top[rail]/1000.0<=y continue
    if $LAY.bottom[rail]/1000.0>y continue
    break
  enddo
  if rail>=$LAY.nfing return -1
  return rail
end

// Gets list of features (MF_xxx) supported by measurement card and presence of
// 300 mA source. If command fails, variables are zeroed assuming only basical
// functionality.
function int Getfeatures()
  int t
  char buf[32]
  features=0
  has300ma=0
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return
  buf[0]=S_INPORT32
  buf[1]=0xFF                          // Crate controller
  $uint4(buf+2)=0x1002001F             // Query features of measurement card
  SYS.Sendimm(0,6,buf)
  buf[0]=S_INPORT32
  buf[1]=0x80                          // Measurement card
  $uint4(buf+2)=0x10020020             // Query presence of 300 mA source
  SYS.Sendimm(1,6,buf)
  buf[0]=S_INPORT32
  buf[1]=0x00                          // Head 0
  $uint4(buf+2)=0x8000000A             // Query support for turning driver off
  SYS.Sendimm(2,6,buf)
  t=Time()
  // Getfeatures() may be called when soft reset or some other initialization
  // is still pending, therefore very long timeout.
  while $A[0].length==0 || $A[1].length==0 || $A[2].length==0 do
    if Time()-t>10000 return           // Timeout
    wait
  enddo
  if $A[0].length>5 && $A[0].answer==S_INPORT32 then
    features=$uint4($A[0]+5)
  endif
  if $A[1].length>5 && $A[1].answer==S_INPORT32 then
    has300ma=$uint4($A[1]+5)
  endif
  if $A[2].length>5 && $A[2].answer==S_INPORT32 then
    supportsoff=$uint4($A[2]+5) & 0x80000000

  supportsoff=1                        // TEMPORARY! HA. HA. HA.

  endif
end

// Reads current tester temperature (in 1/10-th of degree). If necessary, uses
// USB sensor. If operator interrupted C adjust, returns -1. if there was a
// command sending or receiving error, returns 1. Otherwise, returns
// temperature in the range 10..999, which corresponds to 1..99.9 degrees. It
// is the responsibility of caller to display and process errors.
function int Readtemperature()
  int ident,t,temp
  char s[128]
  float etemp
  if ($EXTLAY.measopt & HCM_TMEASOFF) then
    temp=220                           // Default temperature
  else
    sprintf(s,"INPORT %i",0x2011)      // Read effective (smoothed) temperature
    ident=SERV.Cmdimm(32,s)
    if ident<=0 return 1               // Unable to send command
    t=Time()                           // Timeout 5 seconds
    while $A[32].length==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Time()-t>5000 return 1        // Timeout exhausted
      wait
    enddo
    if $A[32].length!=7 return 1       // Bad length of answer
    if $A[32].answer!=S_INPORT return 1// Bad answer
    temp=$uint2($A[32]+5)
  endif
  if temp==220 then                    // Default temperature, try USB sensor
    if SYS.Exttemperature(&etemp)==0 then
      temp=Floor(etemp*10.0+0.5)
    endif
  endif
  return Min(999,Max(10,temp))
end

// Queries quick C support. Returns -1 if operator interrupted the calibration,
// -2 on error, 0 if quick C is not supported or on error, and 1 if it is
// supported.
function int Isquickcavailable()
  int ident,t
  char s[128]
  if ($LAY.config & LC_OHTYPE)==LC_NOFIELD then
    return 1                           // Quick C MUST be supported
  endif
  sprintf(s,"INPORT %i",0x20E0)        // Read type of control hardware
  ident=SERV.Cmdimm(32,s)
  if ident<=0 return -2                // Unable to send command
  t=Time()+5000                        // Timeout 5 seconds
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as interrupt
    if t<Time() return -2              // Timeout exhausted
    wait
  enddo
  if $A[32].length!=7 return -2        // Bad length of answer
  if $A[32].answer!=S_INPORT return -2 // Bad answer
  return ($uint2($A[32]+5)!=0)
end

// Sets test voltage, Volts, and short-to-antenna detection limit, Ohms, for
// field and fast capacity measurements. Returns 0 on success and -1 on error
// or if this feature is not supported.
function int Setfcparameters(float umax,float r)
  int ident,t
  char buf[128]
  // Only A5/A6 support variable threshold.
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 return -1
  if umax!=0.0 then
    umax=Max(0.1,Min(umax,10.0))       // Only 0.1..10 V range is allowed
  endif
  r=Max(1.0e7,Min(r,1.0e8))            // Only 10..100 M range is allowed
  buf[0]=S_DEBUG
  buf[1]=0x0E                          // Set field/capacity parameters
  $float4(buf+2)=r                     // Short threshold
  $int2(buf+6)=0                       // Frequency for capacity measurements
  $int2(buf+8)=0                       // Frequency for field measurements
  $int2(buf+10)=-umax*1000.0           // Voltage for capacity measurements
  $int2(buf+12)=-umax*1000.0           // Voltage for field measurements
  $int2(buf+14)=0                      // Options
  $int2(buf+16)=0                      // Voltage offset for capacity
  ident=SYS.Sendimm(32,18,buf)
  if ident<=0 return -1                // Unable to send command
  t=Time()+5000                        // Timeout 5 seconds
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as interrupt
    if t<Time() return -1              // Timeout exhausted
    wait
  enddo
  if $A[32].answer!=S_DEBUG return -1  // Bad answer
  return 0
end

// Checks layout and sets global variables testertype and testersides. If
// tester is not recognized or not supported, function displays corresponding
// message.
function int Recognizetester()
  int i,w,h
  handle hok
  clear hright
  draw window=hright color=LIGHTRED font=TIMESFONT
  draw at 6,60 wrap=RIGHTX-5
  w=($LAY.rightlimit-$LAY.leftlimit)/1000
  h=Min($LAY.top[0]-$LAY.yoffset[0],$LAY.yoffset[0]-$LAY.bottom[0])/500
  testersides=0
  testerymin=9.9e99
  testerymax=-9.9e99
  ymin=9.9e99
  ymax=-9.9e99
  siderail=-9999
  for i=0,i<$LAY.nfing,i++
    if $LAY.side[i]==$LAY.side[0] then
      siderail=Max(siderail,i)
    endif
    if $LAY.side[i]==0 then testersides=testersides|1;
    else testersides=testersides|2; endif
    testerymin=Min(testerymin,$LAY.bottom[i]/1000.0)
    testerymax=Max(testerymax,$LAY.top[i]/1000.0)
    ymin=Min(ymin,$LAY.top[i]/1000.0)
    ymax=Max(ymax,$LAY.bottom[i]/1000.0)
  enddo
  if $LAY.nfing<=0 || $LAY.nfing>=16 then
    testertype=TT_WRONG                // Wrong layout
    draw text=format("Number of rails specified in the layout (%i) ",$LAY.nfing)
    draw text="is wrong. "
  else if w<=0 || h<=0 then
    testertype=TT_WRONG                // Wrong layout
    draw text="The size of the working area is wrong. "
  else if $LAY.cameras==0 && $LAY.headcameras==0 then
    testertype=TT_WRONG                // At least one camera must be present
    draw text="There are no video cameras on the tester. "
  else if ($LAY.config & 0x80)!=0 then
    if h==45 then
      testertype=TT_WRONG;             // M2 - not supported
      draw text="M2 tester is not supported by measurement system test. "
    else
      testertype=TT_WRONG;             // Contradiction in layout
      draw text="The tester is declared as M2 in the layout, but the height "
      draw text=format("of the rail is %i millimeters instead of 45. ",h)
    endif
  else if ymax-ymin>310.5 && $LAY.software!=0xB7 then
    testertype=TT_WRONG                // OlliBoard does not cover all rails
    draw text="It is impossible to place OlliBoard so that it covers all "
    draw text="available rails. "
  else if h==155 && ($LAY.config & 3)==2 then
    if w==600 && $LAY.software==0x84 then
      testertype=TT_A2;                // A1 or A2 with linear motors
    else if w==600 && $LAY.software==0x86 then
      testertype=TT_A2;                // A1 or A2 with belts
    else if w==600 && $LAY.software==0x8A then
      testertype=TT_A2H;               // A2 (MCM modification)
    else if w==600 && $LAY.software==0x8E then
      testertype=TT_A4;                // A4
    else if testersides==0x01 && ($LAY.software==0xA7 ||                       \
      ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S1;                // S1 (A7) tester
    else if w>=310 && w<=600 && testersides==0x03 &&                           \
      ($LAY.software==0xA7 || $LAY.software==0xA8 ||                           \
      ($LAY.config & LC_TYPEMASK)==LC_S1) then
      testertype=TT_S2;                // S2 tester
    else if $LAY.software==0xA9 || $LAY.software==0xAA ||                      \
      ($LAY.config & LC_TYPEMASK)==LC_S3 then
      testertype=TT_S3;                // S3 tester
    else if $LAY.software==0xB8 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A8;                // A8 tester
    else if w==600 && ($LAY.software==0xA5 || $LAY.software==0xA6) then
      testertype=TT_A6;                // A6 tester
    else if w==800 && $LAY.software==0x84 then
      testertype=TT_A2L;               // A1L or A2L with linear motors
    else if w==800 && $LAY.software==0x86 then
      testertype=TT_A2L;               // A1L or A2L with belts
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text="Unable to recognize the type of the tester. "
    endif
  else if h==215 && $LAY.software==0xA5 then
    testertype=TT_A5;                  // A5 special model
  else if h==200 then
    if w==520 && $LAY.software==0xA5 then
      testertype=TT_A5;                // A5
    else if w==450 then
      testertype=TT_A3;                // A3
    else if w==520 then
      testertype=TT_A3L;               // A3L
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 450 or 520 for A3/A5 testers. "
    endif
  else if h==225 || h==230 || h==240 then
    if w==610 && $LAY.software==0xA5 then
      testertype=TT_A5L;               // A5L
    else if w>=610 && w<=625 && $LAY.software==0xA5 &&                         \
      ($LAY.config & LC_LDMASK)==LC_LMAUTO then
      testertype=TT_A5L;               // A5A (L&M automate)
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text=format("The width of the test area is %i millimeters ",w)
      draw text="instead of expected 610 for A5L testers. "
    endif
  else if h>=250 && h<=260 then
    if $LAY.software==0xB7 || ($LAY.config & LC_TYPEMASK)==LC_A8 then
      testertype=TT_A7;                // A7
    else
      testertype=TT_WRONG;             // Unknown tester
      draw text="Unable to recognize the type of the tester. "
    endif
  else
    testertype=TT_WRONG;               // Tester not recognized
    draw text="Unable to recognize the type of the tester. "
    if h!=155 && h!=200 then
      draw color=BLACK text="Strange height of the rail "
      draw text=format("(%i millimeters instead of expected 155, ",h)
      draw text="200, 230, 240 or 255) is encountered. "
    endif
  endif
  if testertype==TT_WRONG || testertype==TT_UNDEF || testertype==TT_M2 then
    draw color=BLACK
    draw text="Therefore I don't know how to run the test. Please "
    if testertype!=TT_M2 && $LAY.cameras!=0 then
      draw text="check the settings in the layout and correct them, or "
    endif
    draw text="use different test procedure that supports given machine."
    draw at 6,30 color=LIGHTRED text="Unrecoverable error detected!"
    draw show
    clear hleft
    change hleft help="?T1??a??2a??"
    draw window=hleft color=DARKGRAY font=LARGEFONT mode=M_CENTERED
    draw at 95,70 bitmap=0,0,0,"unknown"
    draw show
    change hinfo limits=0,0
    change hinfo text="Unable to test"
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="??..."
      help="???????12a?"
    endc
    while Pressed(hok)==0 && Pressed(hexit)==0 do
      wait
    enddo
    testertype=TT_WRONG
  endif
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// CALIBRATION DATA FILE /////////////////////////////

// Reads and analyzes data from the text calibration file f. Returns 0 if data
// read correctly and -1 if some error was detected, in this case ALL previous
// data in calibration[] and calvalid[] remains unchanged and error message is
// placed in control herr. File remains open.
function int Readcalibration(handle f,handle herr)
  int valid[NPOINT]                    // Whether data[*] valid or not
  float data[NPOINT]                   // Values from calibration file
  char keydata[NKEY][80]               // Contents of calibration keys
  int i,j,k,n,err
  char s[260],name[32]
  float rexp,rmeas
  while 1 do
    s[0]='\0'; j=Fscanf(f,"%s\n",s)    // Get next line
    if j<0 break                       // End of file
    // Certification laboratory uses comma instead of decimal point. "End of
    // XX century? - Never mind!"
    for i=0,s[i]!='\0',i++ do
      if s[i]==',' s[i]='.'
    enddo
    n=0
    for i=0,n<31,i++ do                // Try to extract key
      if s[i]==' ' || s[i]=='\t' continue
      if s[i]=='=' || s[i]=='\n' || s[i]=='\r' || s[i]=='\0' || s[i]==';' break
      name[n]=Toupper(s[i]); n++
    enddo
    name[n]='\0'
    if s[i]=='=' then                  // Valid key
      for j=0,j<NKEY,j++ do            // Search for key in key table
        if Stricmp(calkey[j]+1,name)==0 break
      enddo
      if j>=NKEY then
        change herr text=format("Unknown key %s",name)
        return -1
      endif
      n=0
      for i=i+1,n<79,i++ do            // Get contents of the key
        if s[i]=='\n' || s[i]=='\r' || s[i]=='\0' || s[i]==';' break
        keydata[j][n]=s[i]; n++        // Place in temporary array!
      enddo
      keydata[j][n]='\0'
    else                               // Maybe component?
      n=0; i=0
      while s[i]==' ' || s[i]=='\t' do i++; enddo
      if s[i]=='\n' || s[i]=='\r' || s[i]=='\0' || s[i]==';' continue
      for i=i,n<7,i++ do               // Try to extract component name
        if s[i]==' ' || s[i]=='\t' break
        if s[i]=='\n' || s[i]=='\r' || s[i]=='\0' || s[i]==';' break
        name[n]=Toupper(s[i]); n++
      enddo
      for n=n,n<8,n++ do
        name[n]=' '
      enddo
      name[n]='\0'
      for j=0,j<NCOMP,j++ do           // Search for name in component table
        if Strncmp(calcomp[j],name,8)==0 break
      enddo
      if j>=NCOMP then
        change herr text=format("Unknown component %s",name)
        return -1
      endif
      if calcomp[j][8]=='\0' continue  // Dummy component
      for n=0,n<NPOINT,n++ do          // Component found, find internal index
        if Strcmp(calcomp[j]+8,xname[n])==0 break
      enddo
      if n>=NPOINT then
        change herr text=format("Internal error: unknown %s",calcomp[j]+8)
        return -1
      endif
      k=sscanf(s+i,"%g %g",&rexp,&rmeas)
      if k!=2 then
        change herr text=format("Less than 2 parameters for %s",name)
        return -1
      endif
      if name[0]=='C' then
        rexp=rexp*1.0e12               // Convert capacity into picofarads
        rmeas=rmeas*1.0e12
      endif
      if Abs(rexp-value[n])>value[n]*0.10 then
        change herr text=format("Wrong nominal value for %s",name)
        return -1
      endif
      if Stricmp(name,"SGL     ")==0 then
        if Abs(rmeas-value[n])>0.10 then
          change herr text=format("Wrong measured value for %s",name)
          return -1
        endif
      else if Stricmp(name,"DBL     ")==0 then
        if Abs(rmeas-value[n])>0.05 then
          change herr text=format("Wrong measured value for %s",name)
          return -1
        endif
      else if Stricmp(name,"WIDE    ")==0 then
        if Abs(rmeas-value[n])>0.005 then
          change herr text=format("Wrong measured value for %s",name)
          return -1
        endif
      else if name[0]=='R' then
        if Abs(rmeas-value[n])>value[n]*0.2+0.01 then
          change herr text=format("Wrong measured value for %s",name)
          return -1
        endif
      else if Abs(rmeas-value[n])>value[n]*0.25 then
        change herr text=format("Wrong measured value for %s",name)
        return -1
      endif
      valid[n]=1
      data[n]=rmeas
    endif
  enddo
  for i=0,i<NKEY,i++ do                // Check that all obligatory keys present
    if calkey[i][0]!='+' continue
    if keydata[i][0]==0 then
      change herr text=format("Obligatory key '%s' missed",calkey[i]+1)
      return -1
    endif
  enddo
  Memcpy(calibration,data,Sizeof(data))
  Memcpy(calvalid,valid,Sizeof(valid))
  Memcpy(calkeydata,keydata,Sizeof(keydata))
  return 0
end

// Asks for file with OlliBoard calibration data, checks for validity and reads
// data. Returns -1 if operator decided to interrupt the test and 0 in any
// other case.
function int Getcalibration()
  int i,err
  char drv[8],dir[260],name[260],ext[260]
  char s[260]
  handle hmodal,hname,herr,hbrowse,hdefaults,hok,hcancel
  handle hfile
  hmodal=control WINDOW
    window=NULL
    name="????D?y?Y???t"
    help=" "
    position=0,0,415,115
    bkcolor=YELLOW
    mode=M_MODAL
    size=100
  endc
  draw window=hmodal color=BROWN font=MEDIUMFONT
  draw at 5,24 text="D????t:"
  hname=control COMBOEDIT
    window=hmodal
    name="??D?"
    help="????????DD?y?Y????t??3?"
    position=5,27,340,140
  endc
  hbrowse=control BUTTON
    window=hmodal
    name="?"
    help="??DD?y?Y????t"
    position=350,27,60,24
  endc
  herr=control TEXT
    window=hmodal
    help="?D??2a???"
    position=5,57,405,24
    color=LIGHTRED
    bkcolor=LIGHTYELLOW
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
  endc
  hdefaults=control BUTTON
    window=hmodal
    name="?????"
    help="??????D?2?y(2?1?D?)"
    position=5,87,130,24
  endc
  hok=control BUTTON
    window=hmodal
    name="?"
    help="?????"
    position=145,87,130,24
  endc
  hcancel=control BUTTON
    window=hmodal
    name="???"
    help="?????????"
    position=280,87,130,24
  endc
  draw show
  err=0
  setfocus hname
  while 1 do
    if Pressed(hdefaults) then
      for i=0,i<NPOINT,i++ do
        calvalid[i]=0                  // Invalidate all calibration data
      enddo
      calname[0]='\0'
      calfile[0]='\0'
      break
    else if Pressed(hok) || Pressed(hname) then
      Text(hname,calfile)
      if calfile[0]=='\0' then         // Empty file name
        change herr text="Empty file name"
        continue
      endif
      hfile=Fopen(calfile,"rt")
      if hfile==NULL then              // No such file
        change herr text="Unable to open file"
        continue
      endif
      i=Readcalibration(hfile,herr)
      Fclose(hfile)
      if i==0 then                     // Correct file, confirm that name valid
        Fnsplit(calfile,drv,dir,name,ext)
        Fnmerge(calname,"","",name,ext)
        confirm hname
        break
      endif
    else if Pressed(hbrowse) then
      Text(hname,s)
      if s[0]=='\0' Strcpy(s,"default.cal")
      SERV.Addextention(s,".cal")
      i=SYS.Browse(hmodal,s,"Select file with calibration data",0)
      if i!=0 change hname text=s
    else if Pressed(hcancel) then
      break
    else if Pressed(hexit) then        // Well, not a case with modal window
      err=-1; break
    endif
    wait
  enddo
  destroy hmodal                       // And all child controls as well
  return err
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// DRAWING FUNCTIONS ///////////////////////////////

// Draws OlliBoard in the shuttle.
function int Drawboard()
  int i,n,y,yl,dx,dy
  float factor
  char name[32],text[80]
  clear hleft
  change hleft help="????DD???????"
  draw window=hleft
  if boardtype==1 then
    dx=181; dy=190; Strcpy(name,"ollyborg.bmp")
  else if boardtype==2 then
    dx=181; dy=125; Strcpy(name,"ollybord.bmp")
  else if boardtype==3 then
    dx=181; dy=125; Strcpy(name,"ollybrd2.bmp")
  else if boardtype==4 then
    dx=181; dy=190; Strcpy(name,"ollybrd3.bmp")
  else if boardtype==5 then
    dx=181; dy=324; Strcpy(name,"ollybrd4.bmp")
  else
    dx=181; dy=190; Strcpy(name,"ollybord.bmp")
  endif
  if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    draw at 0,6 bitmap=0,0,0,"epcosms"
  else if testertype==TT_A5L && ($LAY.config & 0x0001C040)==0x00010040 then
    draw at 0,6 bitmap=0,0,0,"a5ameas"
  else if testertype==TT_A7 && boardtype==5 then
    draw color=GRAY bkcolor=GRAY
    draw at 39,2 fillrect 60,318
    draw at 262,2 fillrect 282,318
    draw color=BLACK bkcolor=WHITE
    draw at 59,2 to 59,318
    draw at 59,8 fillrect 71,312
    draw at 261,2 to 261,318
    draw at 250,8 fillrect 262,312
    if $LAY.nfing==6 then
      yl=204; Strcpy(text,"Align with border between rails 0 and 1")
    else if $LAY.nfing<=8 then
      yl=204; Strcpy(text,"Align with center of rail 0")
    else
      yl=288
      Sprintf(text,"Align with border between rails %i and %i",                \
      baserail,baserail+1)
    endif
    draw at 70,6 bitmap=0,0,0,"ollybrd4"
    draw color=LIGHTRED
    draw at 92,yl to 23,yl to 23,325 to 63,325
    draw at 227,yl to 295,yl to 295,325 to 255,325
    draw font=SMALLFONT color=LIGHTRED mode=M_CENTERED at 160,332 text=text
  else if testertype==TT_A7 && ($LAY.config & 0x0001C040)==0x00010040 then
    draw color=DARKGRAY bkcolor=GRAY
    draw at 10,10 rect 15,280
    draw color=GRAY
    for i=0,i<12,i++ do
      draw at i*25+20,10 fillrect i*25+36,280
    enddo
    for i=0,i<11,i++ do
      draw at i*25+40,145-dy/2+3 fillellipse 6,6
      draw at i*25+40,145+dy/2-2 fillellipse 6,6
    enddo
    draw color=DARKGRAY bkcolor=WHITE
    draw at 18,145-dy/2-19 fillrect 313,145-dy/2-5
    draw at 18,145+dy/2+5 fillrect 313,145+dy/2+19
    draw at 18,145-dy/2 bitmap dx,dy,1,name
  else if testertype==TT_S3 && $LAY.nfing==2 then
    draw color=DARKGRAY bkcolor=GRAY
    draw at 70,40 fillrect 250,220
    draw at 74,44 rect 246,216
    factor=1.2
    y=169-(dy/2.0+yshift*0.42)*factor
    draw at 160-dx*factor/2,y bitmap dx*factor,dy*factor,0,name
    if yshift<80.0 then
      draw color=BLACK bkcolor=BLACK
      draw at 245,80 fillellipse 9,9
      draw at 245,180 fillellipse 9,9
      draw color=STRANGE bkcolor=YELLOW
      draw at 245,80 fillellipse 5,5
      draw at 245,180 fillellipse 5,5
      draw color=LIGHTRED
    endif
    Strcpy(text,"Align with border between rails 0 and 1")
    n=Strlen(text)
    yl=130
    y=245
    draw at 160-n*3-10,y to 160-dx*factor/2-35,y
    draw to 160-dx*factor/2-35,yl to 160-dx*factor/2+10,yl
    draw at 160+n*3+10,y to 160+dx*factor/2+35,y
    draw to 160+dx*factor/2+35,yl to 160+dx*factor/2-10,yl
    draw color=BLACK font=TERMINALFONT mode=M_CENTERED
    draw at 160,y+5 text=text
  else
    if testertype==TT_S1 && $LAY.nfing==2 && boardtype==3 &&                   \
      $LAY.rightlimit-$LAY.leftlimit>450000 then
      y=200; yl=95; Strcpy(text,"Align with center of rail 0")
    else if (testertype==TT_S2 || testertype==TT_A8) && siderail<=2 then
      y=200; yl=95
      if boardtype==2 || boardtype==3 then
        Strcpy(text,"Align with center of rail 0")
      else
        Strcpy(text,"Align with border between rails 0 and 1")
      endif
    else if testertype==TT_S1 && $LAY.nfing==2 && boardtype==3 then
      y=200; yl=95
      Strcpy(text,"Align with center of rail 0")
    else if testertype==TT_S1 && $LAY.nfing==2 &&                              \
      (boardtype==0 || boardtype==1 || boardtype==4) then
      y=295; yl=160
      Strcpy(text,"Align with center of rail 0")
    else if testertype==TT_A2 || testertype==TT_A2L || testertype==TT_A2H ||   \
      testertype==TT_A4 || testertype==TT_A6 || testertype==TT_S1 ||           \
      testertype==TT_S2 || testertype==TT_A8 then
      y=295; yl=160
      if yshift<116.0 then
        Strcpy(text,"Align with center of rail 0")
      else
        Strcpy(text,"Align with border between rails 0 and 1")
      endif
    else
      y=295
      if boardtype==0 || boardtype==1 || boardtype==4 then
        yl=95; Strcpy(text,"?1???????????")
      else
        yl=61; Strcpy(text,"?1???????????")
      endif
    endif
    draw color=GRAY bkcolor=GRAY at 10,10 fillrect 310,y
    draw color=DARKGRAY bkcolor=WHITE at 25,25 fillrect 295,y-30
    draw bkcolor=GRAY
    draw at 27,(y-5)/2-dy/2-20 fillrect 293,(y-5)/2-dy/2-5
    draw at 27,(y-5)/2+dy/2+5 fillrect 293,(y-5)/2+dy/2+20
    draw at 160-dx/2-20,10 fillrect 160-dx/2-5,y-15
    draw at 160+dx/2+5,10 fillrect 160+dx/2+20,y-15
    draw bkcolor=WHITE
    draw at 160-dx/2+30,(y-5)/2-dy/2-9 fillrect 160-dx/2+45,(y-5)/2+dy/2+9
    draw at 160+dx/2-45,(y-5)/2-dy/2-9 fillrect 160+dx/2-30,(y-5)/2+dy/2+9
    draw at 160-dx/2-9,(y-5)/2-dy/2+20 fillrect 160+dx/2+9,(y-5)/2-dy/2+35
    draw at 160-dx/2-9,(y-5)/2+dy/2-35 fillrect 160+dx/2+9,(y-5)/2+dy/2-20
    draw at 160-dx/2,(y-5)/2-dy/2 bitmap dx,dy,1,name
    n=Strlen(text)
    draw color=LIGHTRED
    draw at 160-n*3-10,y+10 to 160-dx/2-35,y+10
    draw to 160-dx/2-35,(y-5)/2-dy/2+yl to 160-dx/2+10,(y-5)/2-dy/2+yl
    draw at 160+n*3+10,y+10 to 160+dx/2+35,y+10
    draw to 160+dx/2+35,(y-5)/2-dy/2+yl to 160+dx/2-10,(y-5)/2-dy/2+yl
    draw color=BLACK font=TERMINALFONT mode=M_CENTERED
    draw at 160,y+15 text=text
  endif
  draw font=MEDIUMFONT color=DARKGRAY mode=M_CENTERED
  if calname[0]!='\0' draw at LEFTX/2,LEFTY-10 text=format("Board: %s",calname)
  draw show
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// BOARD DATA //////////////////////////////////

#define NEDIT          63              // Max number of components

// Description of the ROM edit layout. Meaning of the fields:
// NNNNNNN                             - point name, + - special parameter
//   (+8)  VVVVVVV                     - default value
//   (+16)         TFF                 - type (RCL) and factor (10**FF)
//   (+20)             OOO             - offset in romdata
//   (+24)                 MMM         - modifiers (3,4: 3+ or 4+ rows only)
//   (+28)                     ED      - enabling and disabling features
//   (+31)                        C... - component description
char romlayout[NEDIT][64] = {                                                  \
  "*Standard resistors R1 .. R15, R24",                                        \
  "R1      1.00000 R 0  32        Top resistor 1 Ohm",                         \
  "R3      3.00000 R 0  36        Top resistor 3 Ohm",                         \
  "R30     30.0000 R 0  40        Top resistor 30 Ohm",                        \
  "R294    294.000 R 0  44        Top resistor 294 Ohm",                       \
  "R2K94   2.940e3 R 3  48        Top resistor 2.94 kOhm",                     \
  "R8K87   8.870e3 R 3  52        Top resistor 8.87 kOhm",                     \
  "R29K4   29.40e3 R 3  56        Top resistor 29.4 kOhm",                     \
  "R88K7   88.70e3 R 3  60        Top resistor 88.7 kOhm",                     \
  "R978K   978.0e3 R 3  64        Top resistor 978 kOhm",                      \
  "R3M32   3.320e6 R 6  68        Top resistor 3.32 MOhm",                     \
  "R10M    10.00e6 R 6  72        Top resistor 10 MOhm",                       \
  "R47M    47.00e6 R 6  76        Top resistor 47 MOhm",                       \
  "R100M   100.0e6 R 6  80      2 Top resistor 100 MOhm",                      \
  "R200M   200.0e6 R 6  84      2 Top resistor 200 MOhm",                      \
  "R1G     1.000e9 R 9 112     1  Top resistor 1 GOhm",                        \
  "*Kelvin resistors R20 .. R23",                                              \
  "RX0R01  0.01000 R 0  96        Kelvin resistor 10 mOhm",                    \
  "RX0R1   0.10000 R 0 100        Kelvin resistor 100 mOhm",                   \
  "RX1R    1.00000 R 0 104        Kelvin resistor 1 Ohm",                      \
  "RX10R   10.0000 R 0 108        Kelvin resistor 10 Ohm",                     \
  "*Wires on the OlliBoard",                                                   \
  "+Rthin  0.04500 R 0  92        Thin 155/250-mm wire",                       \
  "+Rsgl   0.09000 R 0  88        Single-sided 155/250-mm",                    \
  "+Rwide  0.00400 R 0 124        Wide 155/250-mm wire",                       \
  "*Standard capacitors C5 .. C10",                                            \
  "C27P    35.0000 C 0 136        Capacitor 27+8..27 pF",                      \
  "C270P   270.000 C 0 140        Capacitor 270 pF",                           \
  "C2N7    2700.00 C 3 144        Capacitor 2.7 nF",                           \
  "C22N    22.00e3 C 3 148        Capacitor 22 nF",                            \
  "C220N   220.0e3 C 3 152        Capacitor 220 nF",                           \
  "C2U2    2.200e6 C 6 156        Capacitor 2.2 uF",                           \
  "*Low C C11 .. C22, top to bottom",                                          \
  "+C1p.3  1.70000 C 0 172 4      Capacitor 1.7 pF, row 4",                    \
  "+C1p.2  1.70000 C 0 168 3      Capacitor 1.7 pF, row 3",                    \
  "+C1p.1  1.70000 C 0 164        Capacitor 1.7 pF, row 2",                    \
  "+C1p.0  1.70000 C 0 160        Capacitor 1.7 pF, bottom",                   \
  "+C3p.3  2.90000 C 0 188 4      Capacitor 2.9 pF, row 4",                    \
  "+C3p.2  2.90000 C 0 184 3      Capacitor 2.9 pF, row 3",                    \
  "+C3p.1  2.90000 C 0 180        Capacitor 2.9 pF, row 2",                    \
  "+C3p.0  2.90000 C 0 176        Capacitor 2.9 pF, bottom",                   \
  "+C5p.3  5.40000 C 0 204 4      Capacitor 5.4 pF, row 4",                    \
  "+C5p.2  5.40000 C 0 200 3      Capacitor 5.4 pF, row 3",                    \
  "+C5p.1  5.40000 C 0 196        Capacitor 5.4 pF, row 2",                    \
  "+C5p.0  5.40000 C 0 192        Capacitor 5.4 pF, bottom",                   \
  "*Optional capacitors",                                                      \
  "C47U    47.00e6 C 6 232     2  Capacitor 47 uF",                            \
  "C100U   100.0e6 C 6 236     2  Capacitor 100 uF",                           \
  "*Optional inductances",                                                     \
  "L470N   0.47000 L 0 256     2  Inductance 0.47 uH",                         \
  "L1U     1.00000 L 0 260     2  Inductance 1 uH",                            \
  "L10U    10.0000 L 0 264     2  Inductance 10 uH",                           \
  "L100U   100.000 L 0 268     2  Inductance 100 uH",                          \
  "L470U   470.000 L 0 272     2  Inductance 470 uH",                          \
  "L4M7    4.700e3 L 3 276     2  Inductance 4.7 mH",                          \
  "" }

// Saves ROM data to text file f. Returns 0 on success and -1 on error.
function int Savecalibration(handle f)
  int i,j,rvalid,offset
  float rexp,rmeas
  char s[256]
  // Save header.
  fprintf(f,"CALIBRATIONOBJECT=atg Certification Board\n")
  if boardtype==0 then
    fprintf(f,"MODEL=ABEL304-2\n")
  else if boardtype==1 then
    fprintf(f,"MODEL=ABEL304-3\n")
  else if boardtype==3 then
    fprintf(f,"MODEL=ABEL204-0\n")
  else if boardtype==4 then
    fprintf(f,"MODEL=ABEL304-4\n")
  else if boardtype==5 then
    fprintf(f,"MODEL=ABEL504-1\n")
  else
    fprintf(f,"MODEL=UNKNOWN\n")
  endif
  fprintf(f,"MANUFACTURER=atg L&M\n")
  fprintf(f,"SERIALNO=%06i\n",romdata.serial)
  fprintf(f,"CERTIFICATENO=%06i\n",romdata.serial)
  fprintf(f,"CALIBRATIONINDEX=0\n")
  if romdata.date!=0 then
    Strtime(s,"%d-%b-%Y",2,romdata.date)
    fprintf(f,"DATEOFCALIBRATION=%s\n",s)
    Strtime(s,"%d-%b-%Y",2,romdata.date+512)
    fprintf(f,"NEXTCALIBRATION=%s\n",s)
  else
    fprintf(f,"DATEOFCALIBRATION=UNKNOWN\n")
    fprintf(f,"NEXTCALIBRATION=UNKNOWN\n")
  endif
  // Save components.
  for i=0,i<NCOMP,i++ do
    if calcomp[i][8]=='\0' continue
    rvalid=0
    for j=0,j<NEDIT,j++ do
      if romlayout[j][0]=='\0' break   // End of the list
      if romlayout[j][0]=='*' continue
      if Strcmp(calcomp[i]+8,romlayout[j])!=0 continue
      rexp=0.0
      sscanf(romlayout[j]+8,"%f",&rexp)
      sscanf(romlayout[j]+20,"%i",&offset)
      if $int4(romdata+offset)==0xFFFFFFFF break
      rmeas=$float4(romdata+offset)
      if rmeas==0.0 break               // Value undefined
      if romlayout[j][16]=='C' then
        rexp=rexp*1.0e-12              // Convert capacity into farads
        rmeas=rmeas*1.0e-12
      endif
      rvalid=1
      break
    enddo
    if rvalid==0 continue
    for j=0,j<8,j++ do
      if calcomp[i][j]==' ' || calcomp[i][j]=='\0' break
      s[j]=calcomp[i][j]
    enddo
    while j<6 do
      s[j]=' '; j++
    enddo
    s[j]='\0'
    if Abs(rexp)<0.01 || Abs(rmeas)<0.01 then
      fprintf(f,"%6s %12.5e %12.5e\n",s,rexp,rmeas)
    else
      fprintf(f,"%6s %12.5g %12.5g\n",s,rexp,rmeas)
    endif
  enddo
end

// Applies parameters from romdata to the board.
function int Applydallasmemory()
  int i,j,nedit,offset
  float v
  if romdatavalid==0 return            // No data
  for nedit=0,nedit<NEDIT,nedit++ do
    if romlayout[nedit][0]=='\0' break // End of the list
    if romlayout[nedit][0]=='*' continue
    romlayout[nedit][23]='\0'
    sscanf(romlayout[nedit]+20,"%i",&offset)
    if $int4(romdata+offset)==0xFFFFFFFF continue
    v=$float4(romdata+offset)
    if v==0.0 continue                 // Value undefined
    for i=7,i>1 && romlayout[nedit][i]==' ',i-- do
      romlayout[nedit][i]='\0'
    enddo
    for j=0,j<NPOINT,j++ do
      if Strcmp(romlayout[nedit],xname[j])==0 then
        value[j]=v
        break
      endif
    enddo
  enddo
end

// Service function, calculates standard CRC of the supplied data, size bytes
// long.
function int Crc(char *data,int size)
  int i,l,crc;
  crc=0xFFFFFFFF
  for l=0,l<size,l++ do
    crc=crc^(data[l]<<24);
    for i=0,i<8,i++ do
      crc=((crc & 0x80000000)?(crc<<1)^0x04C11DB7:crc<<1)
    enddo
  enddo
  return crc
end

// Reads romdata from the Dallas memory. If userpos is 1, uses pad coordinates
// scanned by the operator. Returns 0 on success, 1 if chip is missing or not
// supported by Crate, 2 if operation failed and -1 if operator interrupted the
// script.
function int Readdallasmemory(int userpos)
  int i,n,nz,head0,head1,page,attempt,t,xyvalid,err
  float x0,y0,x1,y1,temp
  char s[512]
  rompresent=0
  xyvalid=0
  if (features & (MF_DMEM|MF_DMEMCRATE))!=(MF_DMEM|MF_DMEMCRATE) then
    romdatavalid=0                     // Dallas memory is not supported
    return 1
  endif
  // It is important that only two fingers contact board. High input capacities
  // may distort the signal.
  if userpos==0 then
    head0=-1; head1=-1; nz=0
    n=sprintf(s,"M ")
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      if head0<0 then
        head0=i
      else if head1<0 then
        head1=i
      else
        n=n+sprintf(s+n,"%i(Z) ",i)
        nz++
      endif
    enddo
    if head0<0 || head1<0 then
      return 2                         // No heads to read Dallas
    endif
    if nz>0 then
      sprintf(s+n,"NOP")
      SYS.Killimm(32)
      SERV.Cmdimm(32,s)
      t=Time()
      while 1 do
        if $A[32].length>0 break
        if Time()-t>2000 break         // Timeout is not important
        if Pressed(hexit) return -1
        wait
      enddo
    endif
  endif
  for page=0,page<16,page++ do
    for attempt=3,attempt>0,attempt-- do
      if xyvalid==0 then
        // Standard mode: this script uses first available heads to read data.
        // On testers with limited working area Dallas potentiometer may be in
        // the alternative position. User-defined position: any heads on the
        // top side.
        if userpos==0 then
          Convertpad(&x0,&y0,"DALLAS",head0,DELTA)
          Convertpad(&x1,&y1,"GND2",head1,DELTA)
          if x0<$LAY.leftlimit/1000.0 then
            head0=1; head1=0
            Convertpad(&x0,&y0,"DALALT",head0,DELTA)
            Convertpad(&x1,&y1,"GND2",head1,DELTA)
          endif
        else
          if dallaspad1[0]>dallaspad2[0]+10.0 then
            temp=dallaspad1[0]; dallaspad1[0]=dallaspad2[0]; dallaspad2[0]=temp
            temp=dallaspad1[1]; dallaspad1[1]=dallaspad2[1]; dallaspad2[1]=temp
          endif
          head0=Toprailfromy(dallaspad1[1])*2
          head1=Toprailfromy(dallaspad2[1])*2+1
          x0=dallaspad1[0]; y0=dallaspad1[1]
          x1=dallaspad2[0]; y1=dallaspad2[1]
        endif
        xyvalid=1
      endif
      n=sprintf(s,"M %i[%g,%gA10] %i[%g,%gA10] ",                              \
        head0,x0,y0,head1,x1,y1)
      sprintf(s+n,"DEBUG(0x3C,%i,%i,0,0x%02X,0x%02X,0,0,32,0,0)",              \
        head0,head1,(page*32) & 0xFF,((page*32)>>8) & 0xFF)
      SYS.Killimm(32)
      SERV.Cmdimm(32,s)
      err=0
      t=Time()
      while err==0 do
        if $A[32].length>0 break
        if Time()-t>10000 err=1
        if Pressed(hexit) return -1
        wait
      enddo
      if $A[32].answer==S_DEBUG && ($int2($A[32]+5) & 0x8000)==0 rompresent=1
      if $A[32].answer!=S_DEBUG || $A[32].length!=39 err=1
      if ($int2($A[32]+5) & 0x8801)!=0x0001 err=1
      if err!=0 then
        xyvalid=0                      // Retry with different coordinates
        continue
      endif
      Memcpy(romdata+page*32,$A[32]+7,32)
      break
    enddo
    if attempt==0 break
  enddo
  if rompresent==0 then
    romdatavalid=0; return 1
  else if page<16 then
    romdatavalid=0; return 2
  else if Memcmp(romdata.magic,"OLLI",4)!=0 then
    romdatavalid=0; return 2
  else if romdata.crc!=Crc(romdata,508) then
    romdatavalid=0; return 2
  endif
  romdatavalid=1
  Applydallasmemory()
  return 0
end

// Writes romdata to the Dallas memory. If userpos is 1, uses pad coordinates
// scanned by the operator. Returns 0 on success, 1 if chip is missing or not
// supported by Crate, 2 if operation failed and -1 if operator interrupted the
// script.
function int Writedallasmemory(int userpos)
  int i,n,head0,head1,page,attempt,t,xyvalid,err
  float x0,y0,x1,y1,temp
  char s[512]
  if (features & (MF_DMEM|MF_DMEMCRATE))!=(MF_DMEM|MF_DMEMCRATE) then
    return 1                           // Dallas memory is not supported
  endif
  Memcpy(romdata.magic,"OLLI",4)
  romdata.crc=Crc(romdata,508)
  xyvalid=0
  for page=0,page<16,page++ do
    for attempt=3,attempt>0,attempt-- do
      if xyvalid==0 then
        // Standard mode: this script unconditionally uses heads 0 and 1 to
        // read data. On testers with limited working area Dallas potentiometer
        // may be in the alternative position. User-defined position: any heads
        // on the top side.
        if userpos==0 then
          head0=-1; head1=-1
          for i=0,i<$LAY.nfing*2,i++ do
            if used[i]==0 continue
            if head0<0 then
              head0=i
            else if head1<0 then
              head1=i
              break
            endif
          enddo
          if head0<0 || head1<0 then
            return 2                   // No heads to read Dallas
          endif
          Convertpad(&x0,&y0,"DALLAS",head0,DELTA)
          Convertpad(&x1,&y1,"GND2",head1,DELTA)
          if x0<$LAY.leftlimit/1000.0 then
            head0=1; head1=0
            Convertpad(&x0,&y0,"DALALT",head0,DELTA)
            Convertpad(&x1,&y1,"GND2",head1,DELTA)
          endif
        else
          if dallaspad1[0]>dallaspad2[0]+10.0 then
            temp=dallaspad1[0]; dallaspad1[0]=dallaspad2[0]; dallaspad2[0]=temp
            temp=dallaspad1[1]; dallaspad1[1]=dallaspad2[1]; dallaspad2[1]=temp
          endif
          head0=Toprailfromy(dallaspad1[1])*2
          head1=Toprailfromy(dallaspad2[1])*2+1
          x0=dallaspad1[0]; y0=dallaspad1[1]
          x1=dallaspad2[0]; y1=dallaspad2[1]
        endif
        xyvalid=1
      endif
      n=sprintf(s,"M %i[%g,%gA10] %i[%g,%gA10] ",                              \
        head0,x0,y0,head1,x1,y1)
      n=n+sprintf(s+n,"DEBUG(0x3D,%i,%i,0,0x%02X,0x%02X,0,0,0",                \
        head0,head1,(page*32) & 0xFF,((page*32)>>8) & 0xFF)
      for i=0,i<32,i++ do
        n=n+sprintf(s+n,",%i",$char(romdata+page*32+i))
      enddo
      sprintf(s+n,")")
      SYS.Killimm(32)
      SERV.Cmdimm(32,s)
      err=0
      t=Time()
      while err==0 do
        if $A[32].length>0 break
        if Time()-t>10000 err=1
        if Pressed(hexit) return -1
        wait
      enddo
      if $A[32].answer!=S_DEBUG err=1
      if ($int2($A[32]+5) & 0x8801)!=0x0001 err=1
      if err==0 break                  // Data successfully written
      xyvalid=0                        // Retry with different coordinates
    enddo
    if attempt==0 return 2             // Unable to write data
  enddo
  // Report success.
  return 0
end

// Sets all fields in romdata to default values. Serial number remains
// unchanged.
function int Dallasdefaults()
  int i,j,k,serial,nedit,offset
  float r
  char s[256]
  serial=romdata.serial
  Memset(romdata,0,Sizeof(romdata))
  Memcpy(romdata.magic,"OLLI",4)
  if serial!=0xFFFFFFFF romdata.serial=serial
  Strtime(s,"%d,%m,%Y",0,0)
  sscanf(s,"%i,%i,%i",&i,&j,&k)
  romdata.date=(i+j*32+(k-1980)*512) & 0xFFFF
  for nedit=0,nedit<64,nedit++ do
    if romlayout[nedit][0]=='\0' break
    if romlayout[nedit][0]=='*' continue
    romlayout[nedit][15]='\0'
    sscanf(romlayout[nedit]+8,"%g",&r)
    romlayout[nedit][23]='\0'
    sscanf(romlayout[nedit]+20,"%i",&offset)
    $float4(romdata+offset)=r
  enddo
end

// Allows to edit the contents of the Dallas memory. If userpos is 1, uses pad
// coordinates scanned by the operator.
function int Editdallasmemory(int userpos)
  int i,j,k,c,y,n,nedit,offset[NEDIT],disabled[NEDIT],get,update,save
  float value,factor[NEDIT]
  char s[260],t[260]
  handle f
  handle hchild,hedit[NEDIT],hserial,hdate,htoday,hoperator,hwarning
  handle htype
  handle hdefaults,hfile,hread,hflash,hback,hfocusl,hfocusr
  change hinfo limits=0,0
  change hinfo text="Edit ROM contents"
  clear hright
  // Replace left window.
  change hleft position=-1000,*,*,*
  hchild=control CHILD
    window=hmain
    position=5,5,LEFTX,LEFTY
    help=" "
    size=4096
    bkcolor=LIGHTYELLOW
    limits=LEFTX-24,1525
    mode=M_VSCROLL
  endc
  draw window=hchild mode=M_LEFT
  y=10
  for nedit=0,nedit<NEDIT,nedit++ do
    if romlayout[nedit][0]=='\0' break // End of the list
    if romlayout[nedit][0]=='*' then
      // Intermediate text.
      draw font=MEDIUMFONT color=LIGHTRED mode=M_CENTERED
      draw at LEFTX/2-9,y+22 text=romlayout[nedit]+1
      hedit[nedit]=NULL
      y=y+29
    else
      // Prepare brief component description.
      for i=7,i>1 && romlayout[nedit][i]==' ',i-- do
        romlayout[nedit][i]='\0'
      enddo
      // Extract data from romdata.
      romlayout[nedit][23]='\0'
      sscanf(romlayout[nedit]+20,"%i",offset+nedit)
      factor[nedit]=1.0
      romlayout[nedit][19]='\0'
      sscanf(romlayout[nedit]+17,"%i",&i)
      while i>0 do
        factor[nedit]=factor[nedit]/10.0; i--
      enddo
      while i<0 do
        factor[nedit]=factor[nedit]*10.0; i++
      enddo
      if romlayout[nedit][24]=='4' && boardtype!=5 then
        disabled[nedit]=1
      else if romlayout[nedit][24]=='3' && (boardtype==2 || boardtype==3) then
        disabled[nedit]=1
      else
        disabled[nedit]=0
      endif
      // Create edit control.
      draw font=TIMESFONT color=BLACK mode=M_LEFT
      draw at 5,y+18 text=romlayout[nedit]+31
      n=Strcpy(s,"Measured value of ")
      Strcpy(s+n,romlayout[nedit]+31)
      s[n]=Tolower(s[n])
      hedit[nedit]=control EDIT
        window=hchild
        position=170,y,74,22
        text=""
        help=s
        bkcolor=(disabled[nedit]?LIGHTGRAY:WHITE)
        mode=M_BORDER
      endc
      if disabled[nedit] disable hedit[nedit]
      if Memcmp(romlayout[nedit]+16,"R-3",3)==0 then
        Strcpy(s,"mOhm")
      else if Memcmp(romlayout[nedit]+16,"R 0",3)==0 then
        Strcpy(s,"Ohm")
      else if Memcmp(romlayout[nedit]+16,"R 3",3)==0 then
        Strcpy(s,"kOhm")
      else if Memcmp(romlayout[nedit]+16,"R 6",3)==0 then
        Strcpy(s,"MOhm")
      else if Memcmp(romlayout[nedit]+16,"R 9",3)==0 then
        Strcpy(s,"GOhm")
      else if Memcmp(romlayout[nedit]+16,"C 0",3)==0 then
        Strcpy(s,"pF")
      else if Memcmp(romlayout[nedit]+16,"C 3",3)==0 then
        Strcpy(s,"nF")
      else if Memcmp(romlayout[nedit]+16,"C 6",3)==0 then
        Strcpy(s,"uF")
      else if Memcmp(romlayout[nedit]+16,"L 0",3)==0 then
        Strcpy(s,"uH")
      else if Memcmp(romlayout[nedit]+16,"L 3",3)==0 then
        Strcpy(s,"mH")
      else
        Strcpy(s,"")
      endif
      draw at 250,y+18 text=s
      y=y+27
    endif
  enddo
  draw show
  // Controls in the right window.
  draw window=hright color=BLACK font=INFOFONT
  draw at 10,26 text="Serial"
  draw at 10,56 text="Certified on"
  draw at 10,86 text="Operator"
  draw at 10,116 text="Board type"
  draw show
  hserial=control EDIT
    window=hright
    position=90,8,90,22
    help="D???6??DDo?"
    mode=M_BORDER
  endc
  hdate=control EDIT
    window=hright
    position=90,38,90,22
    help="????"
    mode=M_BORDER|M_NOEDIT
  endc
  htoday=control BUTTON
    window=hright
    position=190,38,66,22
    name="??"
    help="???????????????a???"
    bkcolor=LIGHTGRAY
    mode=M_DBLCLICK
  endc
  hoperator=control EDIT
    window=hright
    position=90,68,90,22
    help="?DD???2??D???"
    mode=M_BORDER
  endc
  htype=control COMBOLIST
    window=hright
    position=90,97,166,200
    help="D?????t?"
  endc
  add htype text="Standard"
  add htype text="1000V and 1 GOhm"
  add htype text="Tripod acceptance"
  switch romdata.features & BF_TYPE
  case BF_1000V:                       // Supports 1000V and resistor 1 GOhm
    change htype select=1
  case BF_TRIPOD:                      // Tripod acceptance board
    change htype select=2
  default:                             // Standard set of components
    change htype select=0
  endsw
  hwarning=control TEXT
    window=hright
    position=10,200,RIGHTX-20,22
    help=" "
    color=LIGHTRED
    font=MEDIUMFONT
  endc
  hread=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY-21,120,24
    name="??ROM"
    help="??????ROM??D???y?Y"
  endc
  hflash=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY-21,120,24
    name="??ROM"
    help="?????y?Y?????ROM"
  endc
  hdefaults=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+12,120,24
    name="?????"
    help="?????????"
    mode=M_DBLCLICK
  endc
  hfile=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+12,120,24
    name="????t"
    help="?????2?y???t"
  endc
  if userpos then
    hback=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+45,120,24
      name="3"
      help="???1??????"
    endc
  else
    hback=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY+45,120,24
      name="??"
      help="?????2?"
    endc
  endif
  get=0                                // Get contents of all controls
  update=3                             // Update controls and 1 GOhm
  save=0                               // Write data to memory
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(htoday) then
      Strtime(s,"%d,%m,%Y",0,0)
      sscanf(s,"%i,%i,%i",&i,&j,&k)
      romdata.date=(i+j*32+(k-1980)*512) & 0xFFFF
      get=1; update=update | 1
    else if Pressed(htype) then
      if Status(htype)==1 then
        i=BF_1000V
      else if Status(htype)==2 then
        i=BF_TRIPOD
      else
        i=BF_STD
      endif
      if (romdata.features & BF_TYPE)!=i then
        romdata.features=(romdata.features & (~BF_TYPE)) | i
        update=3
      endif
    else if Pressed(hread) then
      i=Readdallasmemory(userpos)
      if i<0 return -1
      if i==0 then
        change hwarning text="Data read"
        update=3
      else
        change hwarning text="Can't read ROM!"
      endif
    else if Pressed(hflash) then
      get=1; update=update | 1; save=1
    else if Pressed(hdefaults) then
      Dallasdefaults()
      update=3
    else if Pressed(hfile) then
      getini("ComboEditAutoSave","OlliBoard calib[0]","%s",s)
      if s[0]=='\0' Strcpy(s,"default.cal")
      SERV.Addextention(s,".cal")
      i=SYS.Browse(hmain,s,"Select file to save calibration data",0)
      if i==0 continue
      f=Fopen(s,"wt")
      if f==NULL then
        Error("Unable to open file",s)
        continue
      endif
      if Savecalibration(f)!=0 then
        Error("Error writing data to file",s)
      endif
      Fclose(f)
    else if Pressed(hback) then
      change hleft position=4,4,LEFTX,LEFTY
      destroy hchild
      return 0
    endif
    // If focus is changed, get contents and redraw all controls.
    if hfocusl!=Getfocus(hchild) then
      hfocusl=Getfocus(hchild)
      change hwarning text=""
      get=1; update=update | 1
    else if hfocusr!=Getfocus(hright) then
      hfocusr=Getfocus(hright)
      change hwarning text=""
      get=1; update=update | 1
    endif
    // Get contents of all controls.
    if get then
      i=0; Text(hserial,s); sscanf(s,"%i",&i)
      if i>=0 && i<=999999 romdata.serial=i
      Memset(s,0,4); Text(hoperator,s); Memcpy(romdata.operator,s,4)
      for nedit=0,nedit<64,nedit++ do
        if romlayout[nedit][0]=='\0' break
        if romlayout[nedit][0]=='*' continue
        if disabled[nedit] continue
        // To avoid floating rounding errors, I update romdata only if text
        // is changed.
        value=$float4(romdata+offset[nedit])*factor[nedit]
        sprintf(t,"%g",value)
        Text(hedit[nedit],s)
        if Strcmp(s,t)==0 continue
        value=0.0; sscanf(s,"%g",&value)
        $float4(romdata+offset[nedit])=value/factor[nedit]
      enddo
      get=0
    endif
    // Update contents of all controls.
    if update & 2 then
      // We need to enable or disable controls in the child window depending on
      // the board type.
      for k=0,k<nedit,k++ do
        c=Toupper(romlayout[k][28])
        if c>='0' && c<='9' then
          i=(c-'0')<<BFTYPESHIFT
        else if c>='A' && c<='F' then
          i=(c-'A'+10)<<BFTYPESHIFT
        else
          i=-1
        endif
        if i>=0 then
          if (romdata.features & BF_TYPE)!=i then
            disabled[k]=1
          else
            disabled[k]=0
          endif
        endif
        c=Toupper(romlayout[k][29])
        if c>='0' && c<='9' then
          i=(c-'0')<<BFTYPESHIFT
        else if c>='A' && c<='F' then
          i=(c-'A'+10)<<BFTYPESHIFT
        else
          i=-1
        endif
        if i>=0 then
          if (romdata.features & BF_TYPE)==i then
            disabled[k]=1
          else
            disabled[k]=0
          endif
        endif
        if disabled[k]==0 then
          enable hedit[k]
          change hedit[k] bkcolor=WHITE
        else
          change hedit[k] text=""
          change hedit[k] bkcolor=LIGHTGRAY
          disable hedit[k]
        endif
      enddo
      update=update & 0xFFFFFFFD
    endif
    if update & 1 then
      change hserial text=format("%i",romdata.serial)
      if romdata.date==0 then
        change hdate text="   (No date)"
      else
        Strtime(s,"%d-%b-%Y",2,romdata.date)
        change hdate text=s
      endif
      change hoperator text=format("%.4s",romdata.operator)
      switch romdata.features & BF_TYPE
      case BF_1000V:                   // Supports 1000V and resistor 1 GOhm
        change htype select=1
      case BF_TRIPOD:                  // Tripod acceptance board
        change htype select=2
      default:                         // Standard set of components
        change htype select=0
      endsw
      for nedit=0,nedit<64,nedit++ do
        if romlayout[nedit][0]=='\0' break
        if romlayout[nedit][0]=='*' continue
        if disabled[nedit] continue
        value=$float4(romdata+offset[nedit])*factor[nedit]
        change hedit[nedit] text=format("%g",value)
      enddo
      update=update & 0xFFFFFFFE
    endif
    // Save data to Dallas memory.
    if save then
      i=Writedallasmemory(userpos)
      if i<0 then
        return -1
      else if i>0 then
        change hwarning text="Unable to save data"
      else
        change hwarning text="Data saved"
        Applydallasmemory()
      endif
      save=0
    endif
    wait
  enddo
end

// Warns operator if board certification is expired.
function int Verifyexpirydate()
  int i,j,k,date
  char s[64]
  handle hcontinue
  if romdatavalid==0 return 0          // Unable to determine state
  Strtime(s,"%d,%m,%Y",0,0)
  sscanf(s,"%i,%i,%i",&i,&j,&k)
  date=(i+j*32+(k-1980)*512) & 0xFFFF
  if date-romdata.date<512 return 0    // Board is certified
  notcertified=1
  change hinfo limits=0,0
  change hinfo text="Certification expired!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  draw text=format("Certification for OlliBoard %06i ",romdata.serial)
  draw text="has expired. " color=BLACK text="Tester certification done "
  draw text="with this board will be only conditionally valid."
  draw show
  hcontinue=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?"
    help="???D?2a?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcontinue) return 0
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// OLLIBOARD HANDLING //////////////////////////////

#define NBOARD         6               // Number of supported board types

// Sets boardtype. Returns 1 if user wants to update Dallas EEPROM data, 0 on
// standard procedure and -1 if user cancelled test.
function int Getboardtype()
  int i,j,x,y,x0[NBOARD],y0[NBOARD],dx[NBOARD],dy[NBOARD],by[NBOARD]
  int type[NBOARD],choicemask,fullmask,vsize,fullsize,redraw,btn,oldbtn
  float lhr
  handle hburn,hok,hchild,hboard[NBOARD]
  char brdname[NBOARD][16] = {                                                 \
    "2K5001", "2K5002", "2K5003", "2K5004", "BEL304-4", "BEL504-1" }
  char bmpname[NBOARD][16] = {                                                 \
    "ollybord.bmp", "ollyborg.bmp", "ollybord.bmp", "ollybrd2.bmp",            \
    "ollybrd3.bmp", "ollybrd4.bmp" }
  char brdexpl[NBOARD][64] = {                                                 \
    "(3DDo????y??)",    "(3DDo????e??)",                    \
    "(2DDo????y??)", "(2DDo????e??)",               \
    "(3 rows, Kelvin test area)",  "(4 rows, for A7)" }
  getini("Meastest","Board type","%i",&boardtype)
  // Choose between BEL204-x (2 lines of pads, low resistance option), BEL304-x
  // (classical, 3 lines of pads) and BEL504-1 (A7 large, 4 rows).
  if testertype==TT_A7 && testersides==3 && $LAY.nfing>=6 then
    choicemask=0x20                    // Only XXL for A7
    vsize=360
  else if testertype==TT_S1 && $LAY.nfing==2 then
    choicemask=0x1F                    // Large or small
    vsize=542
  else if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||      \
    testertype==TT_A2H || testertype==TT_A4 || testertype==TT_A6 ||            \
    testertype==TT_S1 || (testertype==TT_S2 && siderail>2) ||                  \
    (testertype==TT_S3  && siderail>2) || (testertype==TT_A8 && siderail>2)    \
  then
    choicemask=0x13                    // Large (tin or gold)
    vsize=377
  else if testertype==TT_S3 then
    choicemask=0x0C                    // Large cut or small
    vsize=365
  else if testertype==TT_A3 || testertype==TT_A3L || testertype==TT_A5 ||      \
    testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8 then
    choicemask=0x1F                    // Large or small
    vsize=542
  else if testertype==TT_S2 && $LAY.nfing<=4 then
    choicemask=0x0C                    // Large cut or small
    vsize=365
  else
    boardtype=0; rowdist=155.0
    linewidth=0.300
    return 0                           // Undefined board
  endif
  if (choicemask & (1<<boardtype))==0 then
    boardtype=0
    while (choicemask & (1<<boardtype))==0 do
      boardtype++
    enddo
  endif
  clear hright
  // If there is no choice, skip selection.
  for j=0,j<NBOARD,j++ do
    if choicemask==(1<<j) then
      boardtype=j
      setini("Meastest","Board type","%i",boardtype)
      Drawboard()
      goto skipchoice
    endif
  enddo
  change hinfo limits=0,0
  change hinfo text="????D??"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="????Y?o??????Da??D???"
  //if (choicemask & 0x03)==0x03 then
    //draw text=" Tinned and gold-plated board have slightly different "
    //draw text="capacities (influence capacity and field measurements), "
    //draw text="resistance of printed wires (precise 4-wire measurements) "
    //draw text="and wire cross-section (inductance corrections)."
  //endif
  draw show
  if (features & (MF_DMEM|MF_DMEMCRATE))!=(MF_DMEM|MF_DMEMCRATE) then
    hburn=NULL
  else
    hburn=control CHECKBOX
      window=hright
      position=10,USERY-80,RIGHTX-15,22
      name="???D?y?Y"
      help="???????a?D???"
      font=INFOFONT
    endc
  endif
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?"
    help="?????"
  endc
redrawleft:
  if hburn!=NULL && Status(hburn)!=0 then
    fullmask=0x3F
    fullsize=750
  else
    fullmask=choicemask
    fullsize=vsize
  endif
  clear hleft
  for i=0,i<NBOARD,i++ do
    hboard[i]=NULL
  enddo
  hchild=control CHILD
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    limits=LEFTX-24,fullsize
    color=WHITE
    bkcolor=WHITE
    mode=M_VSCROLL
    size=1024
  endc
  y=(fullmask & 0x13?8:30)
  j=0
  for i=0,i<NBOARD,i++ do
    if (fullmask & (1<<i))==0 continue
    x0[j]=10; dx[j]=109; y0[j]=y
    if i==0 || i==1 || i==4 then
      dy[j]=114; by[j]=114
    else if i==2 then
      dy[j]=70; by[j]=114
    else if i==5 then
      dy[j]=194; by[j]=194
    else
      dy[j]=75; by[j]=75
    endif
    type[j]=i
    hboard[j]=control RADIO
      window=hchild
      position=x0[j]+dx[j]+16,y0[j]+7,100,24
      text=brdname[i]
      help=brdname[i]
      font=MEDIUMFONT
      mode=(boardtype==i?M_CHECKED:0)
    endc
    y=y+dy[j]+(fullmask & 0x13?9:15)
    j++
  enddo
  redraw=1
  oldbtn=0
  while 1 do
    for j=0,j<NBOARD,j++ do
      if hboard[j]==NULL break
      if Pressed(hboard[j]) then
        boardtype=type[j]
        redraw=1
      endif
    enddo
    if Mousexy(hchild,&x,&y,&btn)==1 then
      if (btn & 1)!=0 && (oldbtn & 1)==0 then
        y=y+Limit3(hchild)
        for j=0,j<NBOARD,j++ do
          if hboard[j]==NULL break
          if x>=x0[j] && x<x0[j]+dx[j] && y>=y0[j] && y<y0[j]+dy[j] then
            change hboard[j] mode=M_CHECKED
            boardtype=type[j]
            redraw=1
            break
          endif
        enddo
      endif
      oldbtn=btn
    else if hburn!=NULL && Pressed(hburn) then
      boardtype=0
      while (choicemask & (1<<boardtype))==0 do
        boardtype++
      enddo
      goto redrawleft
    else if Pressed(hok) then
      setini("Meastest","Board type","%i",boardtype)
      Drawboard()
      break
    else if Pressed(hexit) then
      Drawboard()
      return -1
    endif
    if redraw then
      draw window=hchild color=WHITE bkcolor=WHITE clear
      for j=0,j<NBOARD,j++ do
        if hboard[j]==NULL break
        draw at x0[j],y0[j] bitmap=dx[j],by[j],0,bmpname[type[j]]
        if dy[j]<by[j] then
          draw color=WHITE bkcolor=WHITE
          draw at x0[j],y0[j]+dy[j]
          draw fillrect x0[j]+dx[j],y0[j]+by[j]
        endif
        draw color=BLACK font=INFOFONT mode=M_LEFT
        draw at 150,y0[j]+47 text=brdexpl[type[j]]
        if type[j]==boardtype then
          draw color=LIGHTRED bkcolor=LIGHTRED
          draw at x0[j]-5,y0[j]-5
          draw fillrect x0[j],y0[j]+dy[j]+5
          draw at x0[j]-5,y0[j]-5
          draw fillrect x0[j]+dx[j]+5,y0[j]
          draw at x0[j]+dx[j],y0[j]-5
          draw fillrect x0[j]+dx[j]+5,y0[j]+dy[j]+5
          draw at x0[j]-5,y0[j]+dy[j]
          draw fillrect x0[j]+dx[j]+5,y0[j]+dy[j]+5
        endif
      enddo
      draw show
      redraw=0
    endif
    wait
  enddo
skipchoice:
  if testertype==TT_S1 && $LAY.nfing==2 && boardtype==3 then
    if $LAY.rightlimit-$LAY.leftlimit>450000 then
      yshift=$LAY.top[0]/1000.0        // Pads on the border between two rails
      for i=0,i<$LAY.nfing*2,i++ do
        if i/2==0 then
          ypos0[i]=$LAY.top[i/2]/1000.0-yshift
          ypos[i]=ypos0[i]-1.0; yalt[i]=ypos[i]
        else
          ypos0[i]=$LAY.bottom[i/2]/1000.0-yshift
          ypos[i]=ypos0[i]+1.0; yalt[i]=ypos[i]
        endif
      enddo
      onborder=1
    else
      yshift=$LAY.yoffset[0]/1000.0    // Pads in the middle of the rail
      for i=0,i<$LAY.nfing*2,i++ do
        ypos0[i]=$LAY.yoffset[i/2]/1000.0-yshift
        ypos[i]=ypos0[i]; yalt[i]=ypos0[i]
      enddo
      onborder=0
    endif
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=118.0
    endif
  else if testertype==TT_S1 && $LAY.nfing==2 &&                                \
    (boardtype==0 || boardtype==1 || boardtype==4) then
    yshift=$LAY.yoffset[0]/1000.0      // Pads in the middle of the rail
    for i=0,i<$LAY.nfing*2,i++ do
      ypos0[i]=$LAY.yoffset[i/2]/1000.0-yshift
      ypos[i]=ypos0[i]; yalt[i]=ypos0[i]
    enddo
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=118.0
    endif
    onborder=0
  else if testertype==TT_A2 || testertype==TT_A2L || testertype==TT_A2H ||     \
    testertype==TT_A4 || testertype==TT_A6 || testertype==TT_S1 ||             \
    testertype==TT_S2 || testertype==TT_S3 ||                                  \
    (testertype==TT_A8 && siderail>2)                                          \
  then
    if ymax-ymin<155.5 then
      yshift=$LAY.yoffset[0]/1000.0    // Pads in the middle of the rail
      for i=0,i<$LAY.nfing*2,i++ do
        ypos0[i]=$LAY.yoffset[i/2]/1000.0-yshift
        ypos[i]=ypos0[i]; yalt[i]=ypos0[i]
      enddo
      onborder=0
    else
      yshift=$LAY.top[0]/1000.0        // Pads on the border between two rails
      for i=0,i<$LAY.nfing*2,i++ do
        if $LAY.top[i/2]/1000.0<=ymax then
          ypos0[i]=$LAY.top[i/2]/1000.0-yshift
          ypos[i]=ypos0[i]-1.0
          yalt[i]=$LAY.bottom[i/2]/1000.0-yshift+1.0
          if yalt[i]<0.0 yalt[i]=ypos[i]
        else
          ypos0[i]=$LAY.bottom[i/2]/1000.0-yshift
          ypos[i]=ypos0[i]+1.0
          yalt[i]=$LAY.top[i/2]/1000.0-yshift-1.0
          if yalt[i]>310.0 yalt[i]=ypos[i]
        endif
      enddo
      onborder=1
    endif
    strokev=50
    strokep=50
    strokez=5.0
    if $LAY.nfing<=4 then
      shuttlex=14.0
      shuttley=30.0
    else if ($LAY.config & 0x0001C040)==0x00008040 ||                          \
      ($LAY.config & 0x0001C040)==0x00018040 then
      shuttlex=0.0
      shuttley=42.0                    // Automate
    else
      shuttlex=14.0
      shuttley=38.0
    endif
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=118.0
    endif
  else if testertype==TT_A7 && testersides==0x03 &&                            \
    $LAY.nfing>=6 && boardtype==5 then
    // Assumes A7 XXL Olliboard (boardtype=5).
    if $LAY.nfing==6 then
      // Second row between rails 0 and 1.
      yshift=$LAY.top[0]/1000.0+baserail*250.0-250.0
      for i=0,i<$LAY.nfing*2,i++ do
        ypos0[i]=$LAY.yoffset[i/2]/1000.0-yshift+125.0
        ypos[i]=ypos0[i]-1.0
        yalt[i]=ypos0[i]-250.0+1.0
      enddo
      onborder=1
    else if $LAY.nfing==8 then
      // Pads in the middle of the rail.
      yshift=$LAY.yoffset[0]/1000.0+baserail*250.0
      for i=0,i<$LAY.nfing*2,i++ do
        ypos0[i]=$LAY.yoffset[i/2]/1000.0-yshift
        ypos[i]=ypos0[i]; yalt[i]=ypos0[i]
      enddo
      onborder=0
    else
      // Pads on the border between two rails.
      yshift=$LAY.top[0]/1000.0+baserail*250.0
      for i=0,i<$LAY.nfing*2,i++ do
        ypos0[i]=$LAY.yoffset[i/2]/1000.0-yshift+125.0
        ypos[i]=ypos0[i]-1.0
        yalt[i]=ypos0[i]-250.0+1.0
        if ypos0[i]>875.0 then
          ypos0[i]=ypos0[i]-250.0
          ypos[i]=yalt[i]
        else if yalt[i]<(-125.0) then
          yalt[i]=ypos[i]
        endif
      enddo
      onborder=1
    endif
    strokev=50
    strokep=50
    strokez=5.0
    shuttlex=22.0
    shuttley=yshift-baserail*25.0
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else
      headcamradius=183.0
    endif
  else
    // A3/A5 modifications and A7.
    if boardtype==2 || boardtype==3 then
      yshift=$LAY.top[0]/1000.0-155.0/2// Rail border between the pad lines
      for i=0,i<$LAY.nfing*2,i++ do
        if $LAY.yoffset[i/2]<$LAY.top[0] then
          ypos0[i]=$LAY.top[0]/1000.0-155.0/2-yshift
          ypos[i]=ypos0[i]
          yalt[i]=ypos[i]
        else
          ypos0[i]=$LAY.top[0]/1000.0+155.0/2-yshift
          ypos[i]=ypos0[i]
          yalt[i]=ypos[i]
        endif
      enddo
      onborder=0
    else
      yshift=$LAY.top[0]/1000.0-155.0  // Pads on the border between two rails
      for i=0,i<$LAY.nfing*2,i++ do
        if $LAY.yoffset[i/2]<$LAY.top[0] then
          ypos0[i]=$LAY.top[0]/1000.0-155.0-yshift
          ypos[i]=ypos0[i]
          yalt[i]=$LAY.top[0]/1000.0-yshift-1.0
        else
          ypos0[i]=$LAY.top[0]/1000.0+155.0-yshift
          ypos[i]=ypos0[i]
          yalt[i]=$LAY.top[0]/1000.0-yshift+1.0
        endif
      enddo
      onborder=1
    endif
    strokev=50
    strokep=50
    strokez=5.0
    if testertype==TT_A7 then
      shuttlex=11.0
      shuttley=21.7
    else if ($LAY.config & 0x0001C000)==0x0000C000 then
      shuttlex=14.0                    // A5 wide
      shuttley=46.5
    else
      shuttlex=11.0                    // Standard shuttle
      shuttley=44.0
    endif
    if $EXTLAY.headcamradius!=0 then
      headcamradius=$EXTLAY.headcamradius/1000.0
    else if testertype==TT_A7 then
      headcamradius=183.0
    else
      headcamradius=153.0
    endif
  endif
  lhr=$EXTLAY.headcamradius/1000.0
  if lhr!=0.0 headcamradius=lhr
  // Set distance between the rows of pads on the Olliboard.
  if boardtype==5 then
    rowdist=250.0
    linewidth=0.200
  else
    rowdist=155.0
    linewidth=0.300
  endif
  // Position of board in shuttle preset above is only a default. Read
  // corrected position from .ini file.
  getini("Meastest","Shuttle","%g,%g",&shuttlex,&shuttley)
  if hburn==NULL return 0
  return (Status(hburn)?1:0)
end

// Sets rails to test. Returns 0 on success or -1 if user interrupted script.
function int Setrails()
  int i,n,update
  handle hfrom,hto,hwarn,hok
  clear hright
  change hinfo limits=0,0
  change hinfo text="1??"
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="??????Da2a?????1."
  draw font=INFOFONT color=BLACK
  draw at 17,117 text="1: "
  draw at 159,117 text="?"
  draw show
  hfrom=control COMBOLIST
    window=hright
    position=86,98,69,150
    mode=M_VSCROLL
  endc
  hto=control COMBOLIST
    window=hright
    position=176,98,69,150
    mode=M_VSCROLL
  endc
  firstrail=0
  if testersides==0x3 then
    for i=0,i<$LAY.nfing/2,i++
      add hfrom text=format(" %i (%i)",i,i+$LAY.nfing/2)
      add hto text=format(" %i (%i)",i,i+$LAY.nfing/2)
    enddo
    change hfrom help="?2?(??2?)1?a?2a?"
    change hto help="2a??D??o???2?(??2?)1"
    lastrail=Min(firstrail+4,$LAY.nfing/2-1)
  else
    for i=0,i<$LAY.nfing,i++
      add hfrom text=format("  %i",i)
      add hto text=format("  %i",i)
    enddo
    change hfrom help="1?a?2a?"
    change hto help="2a??D??o??1"
    lastrail=Min(firstrail+4,$LAY.nfing-1)
  endif
  change hfrom select=firstrail
  change hto select=lastrail
  hwarn=control TEXT
    window=hright
    position=20,155,RIGHTX-40,60
    help=" "
    color=LIGHTRED
    mode=M_CENTERED
  endc
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY+30,120,24
    name="?"
    help="???2?D???DD?Y??"
  endc
  update=1
  while 1 do
    if Pressed(hexit)!=0 then
      return -1
    else if Pressed(hok) then
      break
    else if Pressed(hfrom) then
      firstrail=Status(hfrom)
      lastrail=Status(hto)
      if lastrail<firstrail lastrail=firstrail
      if lastrail>firstrail+4 lastrail=firstrail+4
      change hfrom select=firstrail
      change hto select=lastrail
      update=1
    else if Pressed(hto) then
      firstrail=Status(hfrom)
      lastrail=Status(hto)
      if lastrail<firstrail firstrail=lastrail
      if lastrail>firstrail+4 firstrail=lastrail-4
      change hfrom select=firstrail
      change hto select=lastrail
      update=1
    endif
    if update then
      n=lastrail-firstrail+1
      if n==5 || (testersides==0x3 && n==$LAY.nfing/2) ||                      \
        (testersides!=0x3 && n==$LAY.nfing)                                    \
      then
        change hwarn text=""
      else
        change hwarn text="a, ?2a?????1!"
      endif
      update=0
    endif
    wait
  enddo
  // Set list of used rails.
  Memset(used,0,Sizeof(used))
  nused=0
  for i=firstrail*2,i<(lastrail+1)*2,i++ do
    used[i]=1
    nused++
  enddo
  if testersides==0x3 then
    for i=firstrail*2,i<(lastrail+1)*2,i++ do
      used[$LAY.nfing+i]=1
      nused++
    enddo
  endif
  baserail=Max(0,lastrail-4)
  return 0
end

// Returns 0 on success, >0 in case of communication error or -1 if operator
// decided to interrupt the test.
function int Installboard()
  int i,t,err,head,side,channel,x,y,portdata,prevdata,ident
  int movecamera,delta,videoon,videosizex,videosizey,changed
  float xcoord,ycoord,angle,defzoom,zoom
  char s[256],buf[128]
  handle hstatus,hhavedata,hunlock,hvideo,hok,hl,hc,hr
  handle hshuttlex,hshuttley,hshxscr,hshyscr
  handle hview,hlivevideo,hzoom
  clear hright
  change hinfo limits=0,0
  change hinfo text="???D??"
  hhavedata=control BUTTON
    window=hright
    position=5,USERY-10,RIGHTX-10,24
    name="D?y?Y"
    help="?1????D2a???D?y?Y???t???"
  endc
  hunlock=control BUTTON
    window=hright
    position=5,USERY+25,RIGHTX/3-5,24
    name="?a??"
    help="?????a?????"
  endc
  hvideo=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY+25,RIGHTX/3-5,24
    name="?"
    help="???1???????2?Y????"
  endc
  hok=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY+25,RIGHTX/3-9,24
    name="?"
    help="D??2?y??"
  endc
  draw window=hleft color=BLACK font=INFOFONT
  draw at 15,LEFTY-12 text="????: X="
  draw at 220,LEFTY-12 text="Y="
  draw show
  hshuttlex=control EDIT
    window=hleft
    position=150,LEFTY-30,45,23
    text=format(" %.1f",shuttlex)
    help="????D2??X?????????a"
    font=MEDIUMFONT
  endc
  hshxscr=control VSCROLL
    window=hleft
    position=195,LEFTY-30,18,23
    help="???????X????????1?"
    limits=1,-1
  endc
  hshuttley=control EDIT
    window=hleft
    position=245,LEFTY-30,45,23
    text=format(" %.1f",shuttley+baserail*rowdist/10.0)
    help="????D??Y??????????"
    font=MEDIUMFONT
  endc
  hshyscr=control VSCROLL
    window=hleft
    position=290,LEFTY-30,18,23
    help="???????Y????????1?"
    limits=1,-1
  endc
  disable hvideo
  disable hok
  if ($LAY.config & 0x0001C040)==0x00008040 then
    // Automatical shuttle.
    disable hunlock
    change hshuttlex color=LIGHTGRAY
    change hshuttlex bkcolor=LIGHTGRAY
    disable hshxscr
  else if ($LAY.config & 0x0001C040)==0x00018040 then
    // S2 automatical shuttle.
    change hshuttlex color=LIGHTGRAY
    change hshuttlex bkcolor=LIGHTGRAY
    change hshuttley color=LIGHTGRAY
    change hshuttley bkcolor=LIGHTGRAY
    disable hshxscr
    disable hshyscr
  else
    // Manual shuttle.
    hstatus=control TEXT
      window=hright
      name="??a????"
      position=5,190,RIGHTX-10,21
      font=MEDIUMFONT
      color=BLACK
      bkcolor=PINK
      mode=M_CENTERED|M_BORDER
    endc
  endif
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  //draw text="Please install "
  //if boardtype==1 then
  //  draw text="OlliBoard with gold-coated pads (BEL304-3) "
  //else if boardtype==2 then
   // draw text="sawed-off OlliBoard (BEL304) "
  //else if boardtype==3 then
    //draw text="small OlliBoard (BEL204-0) "
 // else if boardtype==4 then
   // draw text="new OlliBoard (BEL304-4) "
  //else if boardtype==5 then
  //  draw text="large A7 OlliBoard (BEL504-1) "
  //else
    //draw text="OlliBoard with tin-coated pads (BEL304-2) "
 // endif
 // draw text=" as shown on the picture. "
  //if ($LAY.config & 0x0001C040)!=0x00008040 &&                                 \
    //($LAY.config & 0x0001C040)!=0x00018040 then
    //draw text="Press " font=MAINFONT text="Unlock " font=TIMESFONT
    //draw text="to unlock the shuttle. "
   // if testertype==TT_A2 || testertype==TT_A3 || testertype==TT_A3L ||         \
     // testertype==TT_A4 then
     // draw text="If shuttle is locked, use " font=MAINFONT text="Video "
     // draw font=TIMESFONT text="together with 'Release' button on the tester "
     // draw text="to adjust Y position. "
    //else
      //draw text="Use " font=MAINFONT text="Video " font=TIMESFONT
      //draw text="to check position of the board. "
   // endif
  //else
    //draw text="Use " font=MAINFONT text="Video " font=TIMESFONT
    //draw text="to check position of the board. "
  //endif
  draw text="????Y???????????D??," font=MAINFONT text="?" font=TIMESFONT
  draw text="?" 
  draw text="2D?????????.?1?D?-?D?2?y"
  draw text="," font=MAINFONT
  draw text="D?y?Y" font=TIMESFONT
  draw text="?." font=MAINFONT text="?" font=TIMESFONT text="?a?D?."
  //draw text="be read automatically). Press " font=MAINFONT text="OK "
  //draw font=TIMESFONT text="when board is correctly installed."
  draw show
  t=0; err=0; videoon=0
  portdata=-1; prevdata=portdata
  ycoord=yshift                        // Emergency solution
  for i=0,i<$LAY.nfing*2,i++ do
    if used[i]!=0 then
      ycoord=ypos0[i]+yshift
      break
    endif
  enddo
  head=Camerafromy(ycoord,&channel,&side,&angle)
  if head<0 err=3
  while err==0 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if i==0x20 then                  // Shuttle locked in test position
        enable hvideo
        enable hok
        if hstatus!=NULL change hstatus text="??????"
      else if (i & 0x10)==0 then
        disable hvideo; disable hok
        if hstatus!=NULL change hstatus text="2?????"
      else
        disable hvideo; disable hok
        if hstatus!=NULL change hstatus text="3????"
      endif
      prevdata=portdata
    endif
    if Pressed(hhavedata) then
      err=Getcalibration()
      if videoon==0 Drawboard()        // Name of board maybe changed
    else if Pressed(hunlock) then
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      if videoon!=0 then
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        videoon=0
      endif
    else if Pressed(hvideo) then
      if videoon==0 then
        disable hshxscr
        disable hshyscr
        hl=control BUTTON
          window=hright
          position=5,USERY+50,RIGHTX/3-5,24
          name="<< ?"
          help="????????2.5o?"
        endc
        hc=control BUTTON
          window=hright
          position=5+RIGHTX/3,USERY+50,RIGHTX/3-5,24
          name="?DD?"
          help="?????????DD?"
        endc
        hr=control BUTTON
          window=hright
          position=5+2*(RIGHTX/3),USERY+50,RIGHTX/3-9,24
          name="?"
          help="????????2.5o?"
        endc
        hview=control CHILD            // Video is not yet here, create controls
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          bkcolor=VIDEOFILL
        endc
        Bccreate(hview,-1,-1,channel,1)
        hzoom=control CUSTOMBOX
          window=hview
          position=235,303,80,21
          name="?"
          help="????y???2?"
          color=BROWN
        endc
        SYS.Videosize(channel,&videosizex,&videosizey,&i)
        if videosizex==0 || videosizey==0 then
          defzoom=0.5
        else
          defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
        endif
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
          Bcgetbri(channel),Bcgetctr(channel),                                 \
          (channel<0?0:2)|(longexp?4:0),angle)
        movecamera=1; xcoord=$LAY.xoffset/1000.0
        x=(LEFTX-10)/2; y=288/2
        draw window=hlivevideo color=LIGHTRED
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        videoon=1
      else
        Bcdelete()                     // Video is already here, remove controls
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        enable hshxscr
        enable hshyscr
        videoon=0
      endif
    else if Pressed(hok) && (portdata & 0x35)==0x20 then
      break
    else if Pressed(hexit) then
      err=-1
    else if Pressed(hshuttlex) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      shuttlex=Min(60.0,Max(0.0,shuttlex))
      change hshuttlex text=format(" %.1f",shuttlex)
    else if Pressed(hshxscr) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      delta=Status(hshxscr)
      shuttlex=Min(60.0,Max(0.0,shuttlex+delta*0.5))
      change hshuttlex text=format(" %.1f",shuttlex)
      change hshxscr select=0
    else if Pressed(hshuttley) then
      Text(hshuttley,s); sscanf(s,"%f",&shuttley);
      shuttley=Min(60.0,Max(0.0,shuttley-baserail*rowdist/10.0))
      change hshuttley text=format(" %.1f",shuttley+baserail*rowdist/10.0)
    else if Pressed(hshyscr) then
      Text(hshuttley,s); sscanf(s,"%f",&shuttley);
      delta=Status(hshyscr)
      shuttley=Min(60.0,Max(0.0,shuttley-baserail*rowdist/10.0+delta*0.5))
      change hshuttley text=format(" %.1f",shuttley+baserail*rowdist/10.0)
      change hshyscr select=0
    endif
    if videoon then
      changed=Bcupdate()
      if (changed & 0x01)!=0 || Pressed(hzoom) then
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      endif
      if (changed & 0x02)!=0 then
        movecamera=1
      endif
      if Pressed(hc) then
        xcoord=$LAY.xoffset/1000.0
        movecamera=1
      else if Pressed(hl) then
        xcoord=Max(xcoord-2.5,leftvlimit)
        movecamera=1
      else if Pressed(hr) then
        xcoord=Min(xcoord+2.5,rightvlimit)
        movecamera=1
      endif
      if movecamera!=0 && head>=0 then
        if $LAY.cameras!=0 then
          sprintf(buf,"M %i(%g,%g) NOP",                                       \
          $LAY.nfing*2+channel,xcoord,ycoord)
        else if $LAY.headcameras!=0 then
          SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
          sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          SERV.Cmdimm(33,buf)
          sprintf(buf,"M @%i[%g,%g] NOP",head,xcoord,ycoord)
        endif
        SERV.Cmdimm(32,buf)            // Move camera to middle row of pads
        movecamera=0
      endif
    endif
    if t==0 then                       // Send next port query
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      ident=SYS.Sendimm(0,3,buf)
      t=Time()+5000                    // Timeout 5 seconds
    else if $A[0].length>0 then
      if $A[0].answer==S_INPORT then
        portdata=$A[0].inport          // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if t<Time() then
      SYS.Killsend(ident)
      err=1                            // No answer from tester
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  if videoon!=0 then
    Bcdelete()
    destroy hview
    destroy hl
    destroy hc
    destroy hr
    enable hshxscr
    enable hshyscr
  endif
  if err>0 then
    if head>=0 then
      sprintf(buf,"M %i(Z) NOP",head)
      SERV.Cmdimm(32,buf)              // Move camera in home position
    endif
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="???"
      help="???22a???"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    if err==1 then
      draw at 6,30 color=LIGHTRED text="Communication error! "
      draw at 6,60 color=BLACK
      draw text="There was no answer from tester within 5 seconds. "
    else if err==2 then
      draw at 6,30 color=LIGHTRED text="Communication error! "
      draw at 6,60 color=BLACK
      draw text="Test procedure received unexpected answer. "
    else
      draw at 6,30 color=LIGHTRED text="Internal error! "
      draw at 6,60 color=BLACK
      draw text="Unable to select video camera. "
    endif
    if err!=2 draw text="Please check connection with crate controller. "
    draw text="Press " font=MAINFONT text="Retry " font=TIMESFONT
    draw text="to check tester status and, eventually, reboot it."
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  setini("Meastest","Shuttle","%g,%g",shuttlex,shuttley)
  return err
end

// Asks L&M for the value of the specified parameter. Sets value to the received
// string <parm>=<answer> (i.e. parm and equation sign are included). Returns 0
// on success, 1 on failure and -1 if user cancelled test.
function int Getlmparameter(char *parm,char *value)
  int i,n
  char buf[768]
  SYS.Killimm(33)
  buf[0]=S_LMAUTO
  buf[1]=3                             // Get parameter
  n=2+sprintf(buf+2,"%s",parm)
  SYS.Sendimm(33,n,buf)
  while $A[33].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[33].answer!=S_LMAUTO return 1  // Bad answer
  for i=0,i<$A[33].length-6,i++ do
    value[i]=$char($A[33]+6+i)
  enddo
  value[i]='\0'
  return 0
end

// Sends text command to L&M automation and waits for answer. Returns 1 on
// success, 0 on failure, 2 on timeout and -1 if user cancelled test.
function int Sendlmcommand(char *cmd,char *answer,char *error,int timeout)
  int m,n,status
  char buf[768]
  SYS.Killimm(32)
  buf[0]=S_LMAUTO
  buf[1]=4                             // Send command
  $uint2(buf+2)=timeout                // Timeout, seconds
  n=4+sprintf(buf+4,"%s\n",cmd)
  n=n+sprintf(buf+n,"%s",answer)
  SYS.Sendimm(32,n,buf)
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  if $A[32].answer!=S_LMAUTO return 0  // Bad answer
  status=$uint2($A[32]+6)
  if (status & 0x01) return 2          // Timeout
  if $char($A[32]+8)=='1' then
    n=8
    m=0                                // Success
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      error[m]=$char($A[32]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 1
  else
    n=8                                // Error
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      n++
    enddo
    if $char($A[32]+n)=='\n' && n<$A[32].length n++
    m=0
    while $char($A[32]+n)!='\n' && n<$A[32].length do
      error[m]=$char($A[32]+n)
      m++; n++
    enddo
    error[m]='\0'
    return 0
  endif
end

// Gets actual teachin settings for L&M hardware. Settings are saved to the
// array lmteachin[], prefix MECH.Teachin is replaced by MECH.Para. Returns 0
// on success, >0 in the case of communication error or -1 if operator decided
// to interrupt the test.
function int Getteachinsettings()
  int i
  nlmteachin=0
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO return 0
  i=Getlmparameter("MECH.Teachin.ShuttleX",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  i=Getlmparameter("MECH.Teachin.ShuttleY",lmteachin[nlmteachin])
  if i!=0 return i
  Memcpy(lmteachin[nlmteachin]+5,"Para",4)
  Strcpy(lmteachin[nlmteachin]+9,lmteachin[nlmteachin]+12)
  nlmteachin++
  i=Getlmparameter("MECH.Para.BoardH",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  i=Getlmparameter("MECH.Para.BoardW",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  i=Getlmparameter("MECH.Para.UseCatcherOnly",lmteachin[nlmteachin])
  if i!=0 return i
  nlmteachin++
  return 0
end

// Installs board in L&M automatical shuttle. Returns 0 on success, >0 in case
// of communication error or -1 if operator decided to interrupt the test.
function int InstallboardLM()
  int i,t,nfing,setpos,prevdata,portdata,adjusting,adjusted,shuttle,delta,err
  char s[512],buf[256],path[260],errtxt[256]
  handle f,hstatus,hhavedata,hload,hunload,hadjust
  handle hshuttlex,hshxscr,hok,hyes,hno
  nfing=$LAY.nfing
  // On testers with split shuttle, board must be installed into the left
  // shuttle.
  shuttle=0
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  for i=0,i<nfing,i++
    sprintf(buf,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,buf)
  enddo
  t=Time()
  while (1) do
    for i=0,i<nfing,i++
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=nfing break                  // All answers came
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>10000 break            // No answer within 10 s timeout
    wait
  enddo
  clear hright
  change hinfo limits=0,0
  // Check whether there is a board in the shuttle. It may happen that previous
  // test was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  if $A[32].length==7 && $A[32].answer==S_INPORT then
    portdata=$A[32].inport
  else
    portdata=0
  endif
  if (portdata & 0x35)!=0x20 then
    // Set positions of L&M actuators.
    if boardtype==2 || boardtype==3 then
      Strcpy(path,"c:\\hardware\\shuttle_ollyboard2.txt")
    else
      Strcpy(path,"c:\\hardware\\shuttle_ollyboard3.txt")
    endif
    f=Fopen(path,"rb")
    if f==NULL then
      Strcpy(path,"c:\\hardware\\shuttle_ollyboard.txt")
      f=Fopen(path,"rb")
    endif
    if f!=NULL then
      Fclose(f)
      change hinfo text="Setting up shuttle..."
      sprintf(s,"PS.Cmd=FileRead %s",path)
      i=Sendlmcommand(s,"PS.Ready.FileRead",errtxt,5)
      if i<0 return -1
      setpos=(i==1)
    else
      setpos=0                         // Shuttle positions not set
    endif
  else
    setpos=0
  endif
  if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    draw window=hleft color=BLACK font=INFOFONT
    draw at 15,LEFTY-12 text="????: X="
    draw show
    hshuttlex=control EDIT
      window=hleft
      position=150,LEFTY-30,45,23
      text=format(" %.1f",shuttlex)
      help="????D2??X?????????a"
      font=MEDIUMFONT
    endc
    hshxscr=control VSCROLL
      window=hleft
      position=195,LEFTY-30,18,23
      help="???????X????????1?"
      limits=1,-1
    endc
  else
    hshuttlex=NULL
    hshxscr=NULL
  endif
  // Set manual automation mode.
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    change hinfo text="Setting pure manual mode..."
    if pulledshuttle<0 then
      i=Sendlmcommand("MECH.Cmd=SetMode 5","MECH.Ready.SetMode",errtxt,20)
    else
      i=0
    endif
    if i>=0 then
      if pulledshuttle<0 then
        sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i 1",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
      else
        sprintf(buf,"MECH.Cmd=A8eaRepositionPullCalib %i 1",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaRepositionPullCalib",errtxt,0xFFFF)
      endif
      if i>=0 pulledshuttle=shuttle
    endif
  else
    change hinfo text="Switching to manual mode..."
    i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,20)
  endif
  if i<0 return -1
  // Installation controls.
  change hinfo text="???D??"
  hstatus=control TEXT
    window=hright
    name="??a????"
    position=8,160,RIGHTX-16,21
    font=MEDIUMFONT
    color=BLACK
    bkcolor=PINK
    mode=M_CENTERED|M_BORDER
  endc
  hhavedata=control BUTTON
    window=hright
    position=8,USERY-55,RIGHTX-16,24
    name="D?y?Y"
    help="?1????D2a???D?y?Y???t???"
  endc
  hload=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY-10,120,24
    name="???"
    help="???1??????D??"
  endc
  hunload=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY-10,120,24
    name="D???"
    help="???????D???D??"
  endc
  hadjust=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+25,120,24
    name="??"
    help="????1?????????????"
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+25,120,24
    name="?"
    help="D??2?y??"
  endc
  disable hok
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="Now install OlliBoard. Press "
  draw font=MAINFONT text="Adjust " font=TIMESFONT text="to adjust widht and "
  draw text="height of the shuttle manually. Press " font=MAINFONT text="OK "
  draw font=TIMESFONT text="when OlliBoard board is locked in the shuttle. "
  draw text="If you have file with individual OlliBoard parameters, press "
  draw font=MAINFONT text="D?y?Y" font=TIMESFONT text=". (If "
  draw text="there is a ROM chip on the board, data will be read "
  draw text="automatically)."
  draw show
  // Main loop.
  t=0; err=0; prevdata=-1
  adjusting=0
  adjusted=0
  while err==0 do
    if portdata!=prevdata then
      i=portdata & 0x35
      if adjusting then
        change hstatus text="Adjustment mode"
        enable hload
        disable hunload
        disable hadjust
        disable hok
      else if i==0x20 then             // Shuttle locked in test position
        change hstatus text="Board in the shuttle"
        disable hload
        enable hunload
        disable hadjust
        enable hok
      else
        change hstatus text="Shuttle out"
        enable hload
        enable hunload
        enable hadjust
        disable hok
      endif
      prevdata=portdata
    endif
    if Pressed(hhavedata) then
      err=Getcalibration()
      Drawboard()                      // Name of board maybe changed
    else if Pressed(hload) then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
        if pulledshuttle!=shuttle then
          pulledshuttle=shuttle
          sprintf(buf,"MECH.Cmd=A8eaPreparePullCalib %i 1",shuttle)
          i=Sendlmcommand(buf,"MECH.Ready.A8eaPreparePullCalib",errtxt,0xFFFF)
          if i<0 return -1
        endif
      endif
      buf[0]=S_LOCKDOOR
      if testertype!=TT_S3 || ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO then
        buf[1]=1                       // Lock door
      else if shuttle==0 then
        buf[1]=80                      // Load board in left shuttle
      else
        buf[1]=81                      // Load board in right shuttle
      endif
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
    else if Pressed(hunload) then
      if adjusting then
        i=Sendlmcommand("MECH.Para.Teachin=0","",errtxt,10)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=TeachInFinished",                            \
          "MECH.Ready.TeachInFinished",errtxt,60)
        if i<0 return -1
        i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,60)
        if i<0 return -1
        adjusting=0
        prevdata=-1
      endif
      buf[0]=S_LOCKDOOR; buf[1]=0      // Unlock door
      SYS.Send(2,buf,0)                // Do not wait for answer, no need
      if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then      ////////////////////CHECK, ALSO SEQUENCE
        sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i 1",shuttle)
        i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
        if i<0 return -1
        pulledshuttle=-1
      endif
    else if Pressed(hadjust) then
      i=Sendlmcommand("MECH.Cmd=SetMode 4","MECH.Ready.SetMode",errtxt,60)
      if i<0 return -1
      i=Sendlmcommand("MECH.Para.Teachin=1","",errtxt,10)
      if i<0 return -1
      adjusting=1
      adjusted=1
      prevdata=-1
    else if hshuttlex!=NULL && Pressed(hshuttlex) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      shuttlex=Min(100.0,Max(0.0,shuttlex))
      change hshuttlex text=format(" %.1f",shuttlex)
    else if hshxscr!=NULL && Pressed(hshxscr) then
      Text(hshuttlex,s); sscanf(s,"%f",&shuttlex);
      delta=Status(hshxscr)
      shuttlex=Min(100.0,Max(0.0,shuttlex+delta*0.5))
      change hshuttlex text=format(" %.1f",shuttlex)
      change hshxscr select=0
    else if Pressed(hok) && (portdata & 0x35)==0x20 then
      setini("Meastest","Shuttle","%g,%g",shuttlex,shuttley)
      if adjusted!=0 then
        // Shuttle settings were probably changed, ask to update file.
        clear hright
        change hinfo limits=0,0
        change hinfo text="Save shuttle settings"
        draw window=hright color=BLACK font=TIMESFONT
        draw at 6,30 wrap=RIGHTX-5
        draw text="Would you like to save the actual shuttle settings to the "
        draw text="disk, so that the next test will automatically use "
        draw text="them?\n\n" color=GRAY text="Note: board size and catchers "
        draw text="remain unchanged; if necessary, edit them directly in the "
        draw text=format("file %s.",path)
        hyes=control BUTTON
          window=hright
          position=RIGHTX/2-124,USERY,120,24
          name="?"
          help="??????????????t"
        endc
        hno=control BUTTON
          window=hright
          position=RIGHTX/2+5,USERY,120,24
          name="?"
          help="??????????D1?D???????"
        endc
        while 1 do
          if Pressed(hexit) then
            return -1
          else if Pressed(hno) then
            break
          else if Pressed(hyes) then
            Getteachinsettings()
            if nlmteachin>0 then
              f=Fopen(path,"wt")
              if f!=NULL then
                for i=0,i<nlmteachin,i++ do
                  fprintf(f,"%s\n",lmteachin[i])
                enddo
                Fclose(f)
              endif
            endif
            break
          endif
          wait
        enddo
      endif
      break
    else if Pressed(hexit) then
      return -1
    endif
    if t==0 then                       // Send next port query
      SYS.Killimm(32)
      buf[0]=S_INPORT
      $uint2(buf+1)=0x00F0             // Hardware control port
      SYS.Sendimm(32,3,buf)
      t=Time()                         // Timeout 5 seconds
    else if $A[32].length>0 then
      if $A[32].answer==S_INPORT then
        portdata=$A[32].inport         // Correct answer
        t=0
      else
        err=2                          // Wrong answer from tester
      endif
    else if Time()-t>5000 then
      t=0
      err=1                            // No answer from tester
    endif
    wait
  enddo
  if err>0 then
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="???"
      help="???22a???"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED text="Communication error! "
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from tester within 5 seconds. "
    else if err==2 then
      draw text="Test procedure received unexpected answer. "
    else
      draw text="Board loading error. "
    endif
    if err!=2 draw text="Please check connection with crate controller. "
    draw text="Press " font=MAINFONT text="Retry " font=TIMESFONT
    draw text="to check tester status and, eventually, reboot it."
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  return err
end

// Installs OlliBoard in EPCOS automatical shuttle. Returns 0 on success, >0
// in case of communication error or -1 if operator decided to interrupt the
// script.
function int InstallboardEPCOS()
  int i,t,nfing,head,channel,side,x,y,movecamera,err
  int videoon,videosizex,videosizey,changed
  float angle,xcoord,zoom,defzoom
  char s[256],errtxt[256],buf[64]
  handle hvideo,hok,hl,hc,hr,hview,hlivevideo,hzoom
  nfing=$LAY.nfing
  err=0
  videoon=0
  clear hright
  change hinfo limits=0,0
  // Move all heads in home position. This movement is not critical, so I don't
  // check for possible errors.
  for i=0,i<nfing,i++
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,s)
  enddo
  t=Time()
  while (1) do
    for i=0,i<nfing,i++
      if $A[i].length==0 break         // Some answers are still not here
    enddo
    if i>=nfing break                  // All answers came
    if Pressed(hexit) return -1        // Operator interrupted calibration
    if Time()-t>10000 break            // No answer within 10 s timeout
    wait
  enddo
  if ($GLOBAL.debugmode & 0x40)==0 then
    // Move shuttle into the test position.
    change hinfo text="Setting manual mode..."
    errtxt[2]=0
    i=Sendlmcommand("MECH.Cmd=SetMode","MECH.Ready.SetMode",errtxt,10)
    if i<0 return -1
    if errtxt[2]!='2' then
      i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,10)
      if i<0 return -1
    endif
    change hinfo text="Moving up vacuum plate..."
    i=Sendlmcommand("MECH.Cmd=LifterToTestPos",                                \
      "MECH.Ready.LifterToTestPos",errtxt,20)
    if i<0 return -1
    if i==2 err=1                      // Timeout
    if i==0 err=2                      // Unable to move plate
//    i=Sendlmcommand("MECH.Cmd=Vacuum 0",                                       \
//      "MECH.Ready.Vacuum",errtxt,5)
//    if i<0 return -1
//    if i==2 err=1                      // Timeout
//    if i==0 err=2                      // Unable to turn off vacuum
  endif
  if err==0 then
    change hinfo text="???D??"
    hvideo=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="?"
      help="???1??????2Y?????"
    endc
    hok=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="?"
      help="D??2?y??"
    endc
    head=Camerafromy(yshift+155.0,&channel,&side,&angle)
    draw window=hright color=BLACK font=TIMESFONT
    draw at 6,30 wrap=RIGHTX-5
    draw text="Please install holder and OlliBoard (BEL304), as shown "
    draw text="on the left picture. Use video camera to check its position. "
    draw text="Press " font=MAINFONT text="OK " font=TIMESFONT text="when "
    draw text="board is correctly installed."
    draw show
  endif
  while err==0 do
    if head>=0 && Pressed(hvideo) then
      if videoon==0 then
        hl=control BUTTON              // Video is not yet here, create controls
          window=hright
          position=5,USERY+30,RIGHTX/3-5,24
          name="<< ?"
          help="????????2.5o?"
        endc
        hc=control BUTTON
          window=hright
          position=5+RIGHTX/3,USERY+30,RIGHTX/3-5,24
          name="?DD?"
          help="?????????DD?"
        endc
        hr=control BUTTON
          window=hright
          position=5+2*(RIGHTX/3),USERY+30,RIGHTX/3-9,24
          name="?"
          help="????????2.5o?"
        endc
        hview=control CHILD
          window=hleft
          position=0,0,LEFTX,LEFTY
          help=" "
          color=BROWN
          bkcolor=LIGHTYELLOW
          size=128
        endc
        hlivevideo=control GRAPH
          window=hview
          position=5,5,LEFTX-10,288
          bkcolor=VIDEOFILL
        endc
        Bccreate(hview,-1,-1,channel,0)
        hzoom=control CUSTOMBOX
          window=hview
          position=235,303,80,21
          name="?"
          help="????y???2?"
          color=BROWN
        endc
        SYS.Videosize(channel,&videosizex,&videosizey,&i)
        if videosizex==0 || videosizey==0 then
          defzoom=0.5
        else
          defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
        endif
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
          Bcgetbri(channel),Bcgetctr(channel),                                 \
          (channel<0?0:2)|(longexp?4:0),angle)
        movecamera=1; xcoord=$LAY.xoffset/1000.0
        x=(LEFTX-10)/2; y=288/2
        draw window=hlivevideo color=LIGHTRED
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
        draw show
        videoon=1
      else
        Bcdelete()                     // Video is already here, remove controls
        destroy hview; hview=NULL
        destroy hl; hl=NULL
        destroy hc; hc=NULL
        destroy hr; hr=NULL
        videoon=0
      endif
    else if Pressed(hok) then
      break
    else if Pressed(hexit) then
      err=-1
    endif
    if videoon then
      changed=Bcupdate()
      if (changed & 0x01)!=0 || Pressed(hzoom) then
        zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
        Bcsetcam(channel)
        SYS.Videoangle(hlivevideo,channel,side,zoom,                           \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      endif
      if (changed & 0x02)!=0 then
        movecamera=1
      endif
      if Pressed(hc) then
        xcoord=$LAY.xoffset/1000.0
        movecamera=1
      else if Pressed(hl) then
        xcoord=Max(xcoord-2.5,leftvlimit)
        movecamera=1
      else if Pressed(hr) then
        xcoord=Min(xcoord+2.5,rightvlimit)
        movecamera=1
      endif
      if movecamera!=0 && head>=0 then
        if $LAY.cameras!=0 then
          sprintf(buf,"M %i(%g,%g) NOP",                                       \
          $LAY.nfing*2+channel,xcoord,yshift+155.0)
        else if $LAY.headcameras!=0 then
          SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
          sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
          SERV.Cmdimm(33,buf)
          sprintf(buf,"M @%i[%g,%g] NOP",head,xcoord,yshift+155.0)
        endif
        SERV.Cmdimm(32,buf)            // Move camera to middle row of pads
        movecamera=0
      endif
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  if videoon!=0 then
    Bcdelete()
    destroy hview
    destroy hl
    destroy hc
    destroy hr
  endif
  if err>0 then
    if head>=0 then
      sprintf(buf,"M %i(Z) NOP",head)
      SERV.Cmdimm(32,buf)              // Move camera in home position
    endif
    clear hright
    hok=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="???"
      help="???22a???"
    endc
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=LIGHTRED text="Communication error! "
    draw at 6,60 color=BLACK
    if err==1 then
      draw text="There was no answer from tester within expected timeout. "
    else
      draw text="Tester was unable to move up the vacuum plate. "
    endif
    if err!=2 draw text="Please check connection with crate controller. "
    draw text="Press " font=MAINFONT text="Retry " font=TIMESFONT
    draw text="to check tester status and, eventually, reboot it."
    while 1 do
      if Pressed(hok) then
        break
      else if Pressed(hexit) then
        err=-1; break
      endif
      wait
    enddo
  endif
  return err
end

// Allows to find rough position of the OlliBoard in the shuttle. Returns -1 if
// operator interrupted test, 0 if both crosses are found correctly and
// automatical scanning is requested, 1 if both crosses are found correctly and
// operator decided to omit automatical scanning and 2 if operator requested to
// change board placement.
function int Positionboard()
  int i,ret,head,prevhead,channel,side,x,y,selected,firstpos,changepos
  int newvideo,newlights,videosizex,videosizey,changed
  float d,posx,posy,vstep,yborder,angle,zoom,xsc,ysc,defzoom
  char buf[256]
  handle hmanual,hpos1,hpos2,hok,hrepos,hu,hl,hr,hd,hx,hy
  handle hview,hlivevideo,hzoom
  clear hleft
  clear hright
  wait; wait; wait                     // Force redraw to avoid overlapping
  change hinfo limits=0,0
  change hinfo text="2?????"
  ret=0
  if (testertype==TT_A5L && $LAY.cameras!=0 &&                                 \
    (boardtype==0 || boardtype==1 || boardtype==4)) || boardtype==2 then
    // A5L large board: Lower crosses are not reachable by dedicated camera;
    // S2/8: Shortened OlliBoard.
    pos1x=$LAY.xoffset/1000.0-(crossx[5]-crossx[4])/2.0
    pos2x=$LAY.xoffset/1000.0+(crossx[5]-crossx[4])/2.0
    pos1y=yshift+crossy[4]
    pos2y=yshift+crossy[5]
  else
    pos1x=$LAY.xoffset/1000.0-(crossx[1]-crossx[0])/2.0
    pos2x=$LAY.xoffset/1000.0+(crossx[1]-crossx[0])/2.0
    pos1y=yshift+crossy[0]
    pos2y=yshift+crossy[1]
  endif
  posy=0.0
  i=getini("Meastest","Left cross","%g,%g",&posx,&posy)
  posy=posy+baserail*rowdist
  if i==2 && Abs(posy-pos1y)<50.0 then
    pos1x=posx; pos1y=posy
    getini("Meastest","Right cross","%g,%g",&pos2x,&pos2y)
    pos2y=pos2y+baserail*rowdist
  endif
  // If crosses are not reachable, force manual scanning of the left- and
  // rightmost pads.
  if Camerafromy(pos1y,&channel,&side,&angle)<0 ||                             \
    Camerafromy(pos2y,&channel,&side,&angle)<0                                 \
  then
    usepads=1
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]!=0 break
    enddo
    pos1x=pos1x-55.0
    pos2x=pos2x+55.0
    pos1y=ypos0[i]+yshift
    pos2y=ypos0[i]+yshift
    for useborder=0,useborder<$LAY.nfing,useborder++ do
      if pos1y<$LAY.top[useborder]/1000.0+25.0 break
    enddo
    posy=0
    i=getini("Meastest","Left pad","%g,%g",&posx,&posy)
    posy=posy+baserail*rowdist
    if i==2 && Abs(posy-pos1y)<50.0 then
      pos1x=posx; pos1y=posy
      getini("Meastest","Right pad","%g,%g",&pos2x,&pos2y)
      pos2y=pos2y+baserail*rowdist
    endif
  else
    usepads=0
    useborder=-1
  endif
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  if usepads then
    draw text="Now find position of two outmost pads on the border between "
    draw text=format("the rails %i and %i. Press ",useborder,useborder+1)
    draw font=MAINFONT text="Pad 1 " font=TIMESFONT text="and " font=MAINFONT
    draw text="Pad 2 " font=TIMESFONT text="to select pads, "
  else
    draw text="" font=MAINFONT text="??1" font=TIMESFONT text="?"
    draw font=MAINFONT text="??2" font=TIMESFONT text="??Y???"  font=TIMESFONT
    draw text="???DD?.\n"
  endif
  draw text="" font=MAINFONT text="?" font=TIMESFONT text="?a?D?,?D"
  draw text="??D??????,\n"
  draw text="" font=MAINFONT text="?????"
  //draw font=TIMESFONT text="if you need to unlock shuttle and change board "
  //draw text="position."
  draw color=DARKGRAY font=INFOFONT at 18,USERY-81 text="? X="
  if usepads then
    i=1
  else
    i=0
    getini("Meastest","Skip autoscan","%i",&i)
  endif
  hmanual=control CUSTOMBOX
    window=hright
    position=10,USERY-130,RIGHTX-20,22
    name="?TD??????"
    help="???D?o????????????"
    mode=(i==0?0:M_CHECKED)
  endc
  if usepads disable hmanual
  hx=control TEXT
    window=hright
    position=83,USERY-100,54,22
    help="????X?"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 140,USERY-81 text=", Y="
  hy=control TEXT
    window=hright
    position=168,USERY-100,54,22
    help="????Y?"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 227,USERY-81 text="mm"
  draw show
  hu=control BUTTON
    window=hright
    position=60,USERY-58,40,40
    name="?"
    help="??????????"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hl=control BUTTON
    window=hright
    position=18,USERY-15,40,40
    name=""
    help="?????????"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hr=control BUTTON
    window=hright
    position=102,USERY-15,40,40
    name=""
    help="?????????"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hd=control BUTTON
    window=hright
    position=60,USERY+27,40,40
    name="??"
    help="????????????"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hpos1=control BUTTON
    window=hright
    position=166,USERY-57,RIGHTX-180,24
    name=(usepads?"2a?1":"??1")
    help="?????????????????"
    color=LIGHTRED
    bkcolor=YELLOW
  endc
  selected=1
  hpos2=control BUTTON
    window=hright
    position=166,USERY-27,RIGHTX-180,24
    name=(usepads?"2a? 2":"??2")
    help="???????t??????????"
  endc
  hok=control BUTTON
    window=hright
    position=166,USERY+12,RIGHTX-180,24
    name="?"
    help="??D???????????"
  endc
  disable hok
  hrepos=control BUTTON
    window=hright
    position=166,USERY+42,RIGHTX-180,24
    name="?????"
    help="?1?Da???D??????????"
  endc
  disable hrepos
  hview=control CHILD
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    bkcolor=VIDEOFILL
    help="??????"
  endc
  Bccreate(hview,-1,-1,channel,1)
  hzoom=control CUSTOMBOX
    window=hview
    position=235,303,80,21
    name="?"
    help="????y???2?"
    color=BROWN
  endc
  SYS.Videosize(channel,&videosizex,&videosizey,&i)
  if videosizex==0 || videosizey==0 then
    defzoom=0.5
  else
    defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
  endif
  x=(LEFTX-10)/2; y=288/2
  changepos=1                          // Force camera movement
  firstpos=1                           // Change second offset simultaneously
  SYS.Killimm(32); $A[32].length=1     // Mark answer as available
  newvideo=1                           // Change camera settings
  newlights=1                          // Change illumination settings
  prevhead=-1                          // Previous head is as yet undefined
  while 1 do
    changed=Bcupdate()
    if (changed & 0x01)!=0 newvideo=1
    if (changed & 0x02)!=0 then
      changepos=1
      newlights=1
    endif
    if changepos==0 && $A[32].length>1 then
      enable hok
      enable hrepos
    endif
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hok) then
      if usepads then
        setini("Meastest","Left pad","%g,%g",pos1x,pos1y-baserail*rowdist)
        setini("Meastest","Right pad","%g,%g",pos2x,pos2y-baserail*rowdist)
        ret=1
      else
        setini("Meastest","Left cross","%g,%g",pos1x,pos1y-baserail*rowdist)
        setini("Meastest","Right cross","%g,%g",pos2x,pos2y-baserail*rowdist)
        ret=Status(hmanual);
        setini("Meastest","Skip autoscan","%i",ret)
      endif
      break
    else if Pressed(hrepos) then
      ret=2; break
    else if Pressed(hpos1) && selected!=1 then
      change hpos1 color=LIGHTRED
      change hpos1 bkcolor=YELLOW
      change hpos2 color=BLACK
      change hpos2 bkcolor=GRAY
      selected=1; changepos=1; firstpos=0
    else if Pressed(hpos2) && selected!=2 then
      change hpos2 color=LIGHTRED
      change hpos2 bkcolor=YELLOW
      change hpos1 color=BLACK
      change hpos1 bkcolor=GRAY
      selected=2; changepos=1; firstpos=0
    else if Pressed(hzoom) then
      newvideo=1
    endif
    if selected==1 then
      posx=pos1x; posy=pos1y
    else
      posx=pos2x; posy=pos2y
    endif
    vstep=VSTEP
    if Status(hmanual)==1 vstep=vstep/10.0
    if Pressed(hu) then
      d=Min(VSTEP*2,vstep*(Status(hu)+1))
      if (firstpos) pos2y=pos2y+d
      posy=posy+d; changepos=1
    else if Pressed(hl) then
      d=Min(VSTEP*2,vstep*(Status(hl)+1))
      if (firstpos) pos2x=pos2x-d
      posx=posx-d; changepos=1
    else if Pressed(hr) then
      d=Min(VSTEP*2,vstep*(Status(hr)+1))
      if (firstpos) pos2x=pos2x+d
      posx=posx+d; changepos=1
    else if Pressed(hd) then
      d=Min(VSTEP*2,vstep*(Status(hd)+1))
      if (firstpos) pos2y=pos2y-d
      posy=posy-d; changepos=1
    endif
    if changepos!=0 then
      if selected==1 then
        pos1x=posx; pos1y=posy
      else
        pos2x=posx; pos2y=posy
      endif
      if usepads then
        yborder=$LAY.top[useborder]/1000.0
        pos1x=Max(leftvlimit,Min(rightvlimit-360.0,pos1x))
        pos1y=Max(yborder-MAXDY,Min(yborder+MAXDY,pos1y))
        pos2x=Max(leftvlimit+360.0,Min(rightvlimit,pos2x))
        pos2y=Max(yborder-MAXDY,Min(yborder+MAXDY,pos2y))
      else if (testertype==TT_A5L && $LAY.cameras!=0 &&                        \
        (boardtype==0 || boardtype==1 || boardtype==4)) || boardtype==2 then
        pos1x=Max(leftvlimit,Min(rightvlimit-(crossx[5]-crossx[4]),pos1x))
        pos1y=Max(yshift+crossy[4]-MAXDY,Min(yshift+crossy[4]+MAXDY,pos1y))
        pos2x=Max(leftvlimit+(crossx[5]-crossx[4]),Min(rightvlimit,pos2x))
        pos2y=Max(yshift+crossy[5]-MAXDY,Min(yshift+crossy[5]+MAXDY,pos2y))
      else
        pos1x=Max(leftvlimit,Min(rightvlimit-(crossx[1]-crossx[0]),pos1x))
        pos1y=Max(yshift+crossy[0]-MAXDY,Min(yshift+crossy[0]+MAXDY,pos1y))
        pos2x=Max(leftvlimit+(crossx[1]-crossx[0]),Min(rightvlimit,pos2x))
        pos2y=Max(yshift+crossy[1]-MAXDY,Min(yshift+crossy[1]+MAXDY,pos2y))
      endif
      if selected==1 then
        posx=pos1x; posy=pos1y
      else
        posx=pos2x; posy=pos2y
      endif
      change hx text=format("%5.1f",posx)
      change hy text=format("%5.1f",posy)
      if $A[32].length!=0 then
        // Previous movement is finished, start new.
        head=Camerafromy(posy,&channel,&side,&angle)
        if head<0 then
          ;
        else if $LAY.cameras!=0 then   // Dedicated camera
          sprintf(buf,"M %i(%g,%g) NOP",head,posx,posy)
        else                           // Head camera, move other heads away
          if head!=prevhead || newlights then
            for i=0,i<$LAY.nfing*2,i++ do
              if i==head continue
              if used[i]==0 continue
              sprintf(buf,"M %i(Z) NOP",i)
              SERV.Cmdimm(33,buf)
            enddo
            if prevhead>=0 then
              sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,0",prevhead)
              SERV.Cmdimm(33,buf)
            endif
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
            SERV.Cmdimm(33,buf)
            prevhead=head
            newlights=0
          endif
          sprintf(buf,"M @%i[%g,%g] NOP",head,posx,posy)
          newvideo=1
        endif
        SERV.Cmdimm(32,buf)
        changepos=0
      endif
    endif
    if newvideo then
      Camerafromy(posy,&channel,&side,&angle)
      zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
      Bcsetcam(channel)
      SYS.Videoangle(hlivevideo,channel,side,zoom,                             \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      draw window=hlivevideo bkcolor=VIDEOFILL color=LIGHTRED clear
      if usepads then
        xsc=6.4; ysc=6.4               // Default video magnification
        getini("System","Video scale[0]","%f,%f",&xsc,&ysc)
        xsc=Max(0.2,Min(12.0,xsc))     // mm per 512 pixel
        ysc=Max(0.2,Min(12.0,ysc))
        xsc=512.0/xsc*zoom             // Screen pixel per mm
        ysc=512.0/ysc*zoom
        draw at x-1.0*xsc,y-2.5*ysc rect x+1.0*xsc+1.0,y+2.5*ysc+1.0
      else
        draw at x-20,y to x-5,y at x+6,y to x+21,y
        draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
      endif
      draw show
      newvideo=0
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  Bcdelete()
  destroy hview
  return ret
end

// Searches for the cross in the vicinity of the given coordinates. Returns -1
// if operator decided to interrupt the test, 2 if procedure was unable to
// define fiducial, 3 if cross was not found, 4 if camera was unable to reach
// the cross, and 0 if fiducial was found correctly and posx and posy are
// assigned corrected coordinates.
function int Searchcross(handle hlivevideo,float *posx,float *posy)
  int i,j,t,head,active,channel,videox,videoy,side,clip
  int attempts,nfound,err
  float x,y,dx,dy,bestx,besty,angle,zoom,xsc,ysc,found[4][3],corrmax
  char s[256]
  handle hfid[3]
  x=posx[0]; y=posy[0]
  attempts=8; err=0
  active=-1                            // Active head is yet undefined
  Camerafromy(y,&channel,&side,&angle)
  SYS.Videosize(channel,&videox,&videoy,&j)
  if videox==0 || videoy==0 then
    zoom=0.5
  else
    zoom=Max((LEFTX-8.0)/videox,290.0/videoy)
  endif
  SYS.Killimm(32)                      // Recover from previous scanning
  while (attempts>0 && err==0) do
    attempts--
    head=Camerafromy(y,&channel,&side,&angle)
    if head<0 then
      err=1; break
    endif
    Bcsetcam(channel)
    SYS.Videoangle(hlivevideo,channel,side,zoom,                               \
      Bcgetbri(channel),Bcgetctr(channel),                                     \
      (channel<0?0:2)|(longexp?4:0),angle)
    if head!=active then
      // Define fiducials for new camera, first deleting existing ones.
      for j=0,j<3,j++ do
        if hfid[j]!=NULL SYS.Deletemodel(hfid[j])
      enddo
      sprintf(s,"Video scale[%i]",side)
      xsc=6.4; ysc=6.4                 // Default video magnification
      getini("System",s,"%f,%f",&xsc,&ysc)
      xsc=Max(0.2,Min(12.0,xsc))
      ysc=Max(0.2,Min(12.0,ysc))
      for j=0,j<3,j++ do               // Different thickness (-25%,0,+25%)
        hfid[j]=SYS.Syntmodel(channel,SYNT_CROSS,                              \
          512.0/xsc,128.0*linewidth*(j+3)/xsc,0,0,0)
        if hfid[j]==NULL err=2         // Unable to define fiducial
      enddo
      if err!=0 break
    endif
    // Move camera into the coordinates. In case of head cameras, all other
    // heads must be moved away.
    if $LAY.cameras!=0 then            // Dedicated camera
      sprintf(s,"M %i(%g,%gA5) NOP",head,x,y)
      clip=0
    else                               // Head camera, move other heads away
      if head!=active then
        for i=0,i<$LAY.nfing*2,i++ do
          if i==head continue
          sprintf(s,"M %i(Z) NOP",i)
          SERV.Cmdimm(33,s)
        enddo
        if active>=0 then
          sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,0",active)
          SERV.Cmdimm(33,s)
        endif
        sprintf(s,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
        SERV.Cmdimm(33,s)
      endif
      sprintf(s,"M @%i[%g,%g] NOP",head,x,y)
      clip=((head^side) & 1?1:-1)
    endif
    SERV.Cmdimm(32,s)
    active=head
    t=Time()
    while $A[32].length==0 && err==0 do
      if Pressed(hexit) err=-1         // Operator interrupted test
      if Time()-t>10000 err=1          // Timeout
      wait
    enddo
    if err!=0 break
    if $A[32].answer!=S_NOP then
      err=1; break
    endif
    delay 200                          // Some additional delay for camera
    SYS.Nextframe(channel)
    SYS.Videosize(channel,&videox,&videoy,&j)
    corrmax=0.0
    for j=0,j<3,j++ do
      if hfid[j]==NULL continue
      nfound=SYS.Recognangle(hfid[j],0,0,videox,videoy,found,angle,clip)
      if nfound==0 continue
      if found[0,2]>corrmax then
        bestx=found[0,0]
        besty=found[0,1]
        corrmax=found[0,2]
      endif
    enddo
    dx=(bestx-videox/2)*xsc/512.0
    dy=(besty-videoy/2)*ysc/512.0
    // Offsets dx and dy are given in millimeters along the camera
    // axes. We must rotate them into the tester coordinates.
    x=x+(dx*Cos(angle)+dy*Sin(angle))*(side==0?1.0:-1.0)
    y=y-(dy*Cos(angle)-dx*Sin(angle))
    if Abs(dx)<0.1 && Abs(dy)<0.1 then
      posx[0]=x                        // Fiducial found exactly
      posy[0]=y
      break
    endif
  enddo
  delay 750                            // Psychology
  if attempts<=0 err=3
  // Clean up and report result.
  for j=0,j<3,j++ do
    if hfid[j]!=NULL SYS.Deletemodel(hfid[j])
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  return err
end

// Gets type of attached automation (half-automate, automate etc.) into the
// global variables automationtype and isauto. As these parameters are not
// important for the calibration, there is no error processing.
function int Getautomationtype()
  int t
  char buf[32]
  buf[0]=S_DEBUG
  buf[1]=0x14                          // Query type of the automation
  SYS.Sendimm(32,2,buf)
  t=Time()
  automationtype=AUTO_UNKNOWN
  isauto=0
  while $A[32].length==0 do
    if Time()-t>2000 then
      SYS.Killimm(32)                  // Timeout, automation type is unknown
      return
    endif
    wait
  enddo
  if $A[32].answer!=S_DEBUG || $A[32].length!=9 return
  automationtype=$uint2($A[32]+5)
  if automationtype==AUTO_A2 || automationtype==AUTO_A4SEMI ||                 \
    automationtype==AUTO_A4FULL || automationtype==AUTO_A6SEMI ||              \
    automationtype==AUTO_A6FULL || automationtype==AUTO_A5LMSEMI ||            \
    automationtype==AUTO_A5LMFULL || automationtype==AUTO_S2LMMAN ||           \
    automationtype==AUTO_S2LMSEMI || automationtype==AUTO_S2LMFULL ||          \
    automationtype==AUTO_S2LMDCF || automationtype==AUTO_A7LMSEMI ||           \
    automationtype==AUTO_A7LMFULL || automationtype==AUTO_A8LMMAN ||           \
    automationtype==AUTO_A8LMSEMI || automationtype==AUTO_A8LMFULL ||          \
    automationtype==AUTO_SPLIT                                                 \
  then
    isauto=1
  else
    isauto=0
  endif
end

// Given rough fiducial coordinates, this function scans OlliBoard optically
// and calculates necessary coordinate conversion coefficients.
function int Scanboard(int manualonly)
  int i,j,err,x,y
  float r,xmin,xmax,ymin,ymax
  char s[64]
  handle hview,hlivevideo,hreplace,hfinish
  clear hright
  change hinfo limits=0,0
  change hinfo text="Checking coordinates..."
  r=Sqrt((pos1x-pos2x)*(pos1x-pos2x)+(pos1y-pos2y)*(pos1y-pos2y))
  delay 500                            // Merchandizing...
  if (usepads==0 && (r<250.0-MAXERR || r>250.0+MAXERR)) ||                     \
    (usepads!=0 && (r<360.0-MAXERR || r>360.0+MAXERR)) then
    err=1                              // Wrong distance between crosses
  endif
  if err==0 then
    hview=control CHILD
      window=hleft
      position=0,0,LEFTX,LEFTY
      help=" "
      color=BROWN
      bkcolor=LIGHTYELLOW
      size=128
    endc
    hlivevideo=control GRAPH
      window=hview
      position=5,5,LEFTX-10,288
      bkcolor=VIDEOFILL
      help="??????"
    endc
    x=(LEFTX-10)/2; y=288/2
    draw window=hlivevideo color=LIGHTRED
    draw at x-20,y to x-5,y at x+6,y to x+21,y
    draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
    draw show
  endif
  if manualonly==0 && usepads==0 then
    if err==0 then
      change hinfo text="?????..."
      err=Searchcross(hlivevideo,&pos1x,&pos1y)
      if err<0 return -1               // Operator interrupted test
    endif
    if err==0 then
      err=Searchcross(hlivevideo,&pos2x,&pos2y)
      if err<0 return -1               // Operator interrupted test
    endif
  endif
  if err==0 then
    r=Sqrt((pos1x-pos2x)*(pos1x-pos2x)+(pos1y-pos2y)*(pos1y-pos2y))
    if (usepads==0 && (r<250.0-MAXERR || r>250.0+MAXERR)) ||                   \
      (usepads!=0 && (r<360.0-MAXERR || r>360.0+MAXERR)) then
      err=1
    endif
  endif
  // Move heads and cameras into the home positions.
  for i=0,i<$LAY.nfing*2,i++ do
    if used[i]==0 continue
    sprintf(s,"M %i(Z) NOP",i)
    SERV.Cmdimm(32,s)
  enddo
  delay 1000                           // Psychologically necessary delay
  if hview!=NULL destroy hview
  if err==0 then
    if usepads==0 then
      setini("Meastest","Left cross","%g,%g",pos1x,pos1y-baserail*rowdist)
      setini("Meastest","Right cross","%g,%g",pos2x,pos2y-baserail*rowdist)
    endif
    if usepads then
      convcfi=(pos2x-pos1x)/360.0
      convsfi=(pos2y-pos1y)/360.0
      convdx=pos1x+rowdist*convsfi
      convdy=pos1y+(yshift-$LAY.top[useborder]/1000.0)*convcfi
    else if (testertype==TT_A5L && $LAY.cameras!=0 &&                          \
      (boardtype==0 || boardtype==1 || boardtype==4)) || boardtype==2 then
      r=(crossx[5]-crossx[4])*(crossx[5]-crossx[4])+                           \
        (crossy[5]-crossy[4])*(crossy[5]-crossy[4])
      convcfi=((crossx[5]-crossx[4])*(pos2x-pos1x)+                            \
        (crossy[5]-crossy[4])*(pos2y-pos1y))/r
      convsfi=((crossx[5]-crossx[4])*(pos2y-pos1y)-                            \
        (crossy[5]-crossy[4])*(pos2x-pos1x))/r
      convdx=pos1x-crossx[4]*convcfi+crossy[4]*convsfi
      convdy=pos1y-crossx[4]*convsfi-crossy[4]*convcfi
    else
      r=(crossx[1]-crossx[0])*(crossx[1]-crossx[0])+                           \
        (crossy[1]-crossy[0])*(crossy[1]-crossy[0])
      convcfi=((crossx[1]-crossx[0])*(pos2x-pos1x)+                            \
        (crossy[1]-crossy[0])*(pos2y-pos1y))/r
      convsfi=((crossx[1]-crossx[0])*(pos2y-pos1y)-                            \
        (crossy[1]-crossy[0])*(pos2x-pos1x))/r
      convdx=pos1x-crossx[0]*convcfi+crossy[0]*convsfi
      convdy=pos1y-crossx[0]*convsfi-crossy[0]*convcfi
    endif
    if boardtype==5 then
      Convert(&xmin,&ymin,-10.0,-35.0,0.0)
      Convert(&xmax,&ymax,365.0,755.0,0.0)
    else
      Convert(&xmin,&ymin,-10.0,-35.0,0.0)
      Convert(&xmax,&ymax,365.0,315.0,0.0)
    endif
    sprintf(s,"???? %g,%g,%g,%g",xmin,ymin,xmax,ymax)
    SERV.Cmdimm(32,s)                  // Allow whole board
    if testertype==TT_S1 || testertype==TT_S2 then
      // Define Z map to avoid components.
      sprintf(s,"DEFREGION %g,%g,%g,%g,H=7.0",xmin,ymin,xmax,ymax)
      SERV.Cmdimm(32,s)
      SERV.Cmdimm(32,"MAKEZMAP")
    endif
    sprintf(s,"STROKE %i,%i,%g",strokev,strokep,strokez)
    SERV.Cmdimm(32,s)                  // Set default stroke
    Strcpy(s,"EXACTINIT 0,0,0")
    SERV.Cmdimm(32,s)                  // No power/current limitations
    return 0                           // No errors, pads found correctly
  endif
  change hinfo text="Scanning error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Bad distance between crosses!"
    draw at 6,60 color=BLACK
    draw text="The distance between positioning fiducials on the OlliBoard is "
    draw text=format("%i mm. However, measured distance is ",usepads?360:250)
    draw text=format("%.1f mm. ",r)
    draw text="Maybe you have selected wrong fiducials, or installed old "
    draw text="(currently unsupported) revision BEL304-1. "
  else if err==2 then
    draw text="Unable to define fiducial!"
    draw at 6,60 color=BLACK
    draw text="Either you have no frame grabber, or some other script uses "
    draw text="all available fiducial handles, or magnification of the camera "
    draw text="in file OLLYTEST.INI is wrong. "
  else if err==3 then
    draw text="Unable to find cross!"
    draw at 6,60 color=BLACK
    draw text="Either you selected wrong place, or picture is too unclear, or "
    draw text="magnification of the camera in file OLLYTEST.INI is wrong. "
  else if err==4 then
    draw text="Unable to move camera!"
    draw at 6,60 color=BLACK
    draw text="Video camera cannot reach specified pad. "
  endif
  draw text="Please decide what to do next."
  draw show
  hreplace=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="?????"
    help="???????????D??"
  endc
  hfinish=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="??"
    help="?????3?2a?"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1                        // Operator interrupted test
    else if Pressed(hreplace) then
      return 1                         // Change board placement or rescan
    else if Pressed(hfinish) then
      return 2                         // Operator stopped test
    endif
    wait
  enddo
end

// Checks electrically placement of the OlliBoard. Returns -1 if operator
// interrupted test, 1 if it is necessary to check load status of the tester,
// 2 if it is necessary to repeat electrical test, and 0 if test is OK.
function int Electrocheck()
  int i,t,nbad,err,head,c
  float x1,y1,x2,y2,r,res,cap,capmax
  char s[128]
  handle hretry,hreload,hcont
  clear hright
  change hinfo limits=0,0
  change hinfo text="?2D??..."
  for i=0,i<$LAY.nfing*2-2,i=i+2 do    // Send commands
    if used[i]==0 || used[i+2]==0 continue
    SYS.Killimm(i)
    if $LAY.rightlimit-$LAY.leftlimit<400000 then
      Convertpad(&x1,&y1,"L47U",i,0.0)
      Convertpad(&x2,&y2,"L47U",i+2,0.0)
    else
      Convertpad(&x1,&y1,"RES0",i,0.0)
      Convertpad(&x2,&y2,"RES0",i+2,0.0)
    endif
    sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] R(%i,%i)",                          \
      i,x1,y1,acc,i+2,x2,y2,acc,i,i+2)
    SERV.Cmdimm(i,s)
    SYS.Killimm(i+1)
    if $LAY.rightlimit-$LAY.leftlimit<400000 then
      Convertpad(&x1,&y1,"HV",i+1,0.0)
      Convertpad(&x2,&y2,"HV",i+3,0.0)
    else
      Convertpad(&x1,&y1,"P3",i+1,0.0)
      Convertpad(&x2,&y2,"P3",i+3,0.0)
    endif
    sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] R(%i,%i)",                          \
      i+1,x1,y1,acc,i+3,x2,y2,acc,i+1,i+3)
    SERV.Cmdimm(i+1,s)
  enddo
  t=Time()
  while 1 do                           // Wait till all answers come back
    if Pressed(hexit) return -1        // Operator interrupted test
    for i=0,i<$LAY.nfing*2-2,i++ do
      if used[i]==0 || used[i+2]==0 continue
      if $A[i].length==0 break
    enddo
    if i>=$LAY.nfing*2-2 break         // All answers came
    if Time()-t>15000 then
      err=1; break                     // Timeout 15 seconds
    endif
    wait
  enddo
  if err==0 then
    for i=0,i<$LAY.nfing*2-2,i++ do
      if used[i]==0 || used[i+2]==0 continue
      if $A[i].answer==S_ERROR then
        err=2; break                   // Some error
      else if $A[i].answer!=S_MOVE || $A[i].subansw!=S_RMEAS then
        err=3; break                   // Unbelievable, wrong answer
      endif
      r=$A[i].r
      if ($A[i].status & 0x0100) r=r*1.0e-6
      if r<(-1.0) || r>10.0 then
        head=i; err=4; break           // Bad resistance (>10 Ohm or negative)
      endif
    enddo
  endif
  // If command is supported, check for possible contact of OlliBoard to
  // the shuttle.
  if err==0 && (features & MF_FIXCDC)!=0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      SYS.Killimm(i)
      if (i & 1)==0 then
        Convertpad(&x1,&y1,"GND1",i,0.0)
      else
        Convertpad(&x1,&y1,"GND2",i,0.0)
      endif
      sprintf(s,"M %i[%g,%gA%i] SHC(%i,RC)",i,x1,y1,acc,i)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()
    while 1 do                         // Wait till all answers come back
      if Pressed(hexit) return -1      // Operator interrupted test
      for i=0,i<$LAY.nfing*2,i++ do
        if used[i]==0 continue
        if $A[i].length==0 break
      enddo
      if i>=$LAY.nfing*2 break         // All answers came
      if Time()-t>15000 then
        err=1; break                   // Timeout 15 seconds
      endif
      wait
    enddo
    nbad=0                             // Analyse answers
    for i=0,i<$LAY.nfing*2 && err==0,i++ do
      if used[i]==0 continue
      if $A[i].answer!=S_MOVE then
        nbad=0; break                  // Unsupported command?
      endif
      res=$float4($A[i]+8)
      cap=$float4($A[i]+12)
      if testertype==TT_S1 then
        capmax=1500.0                  // Board directly on the shuttle!
      else if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
        capmax=350.0
      else if testertype==TT_S3 &&                                             \
        ($LAY.nfing>2 || $LAY.rightlimit-$LAY.leftlimit>450000) then
        capmax=750.0
      else if testertype==TT_S3 then
        capmax=350.0
      else
        capmax=150.0
      endif
      if res<1.0e6 || cap>capmax nbad++
    enddo
    if err==0 && nbad>1 err=5          // 1 error is acceptable
  endif
  // Move all heads in home positions.
  if err==0 then
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      sprintf(s,"M %i(Z) NOP",i)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()
    while 1 do                         // Wait till all answers come back
      if Pressed(hexit) return -1      // Operator interrupted test
      for i=0,i<$LAY.nfing*2,i++ do
        if used[i]==0 continue
        if $A[i].length==0 break
      enddo
      if i>=$LAY.nfing*2 break         // All answers came
      if Time()-t>15000 then
        err=1; break                   // Timeout 15 seconds
      endif
      wait
    enddo
    if err==0 return 0                 // Electrical check passed
  endif
  change hinfo text="???"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within 15 seconds. "
  else if err==2 then
    draw text="Tester reports error!"
    draw at 6,60 color=BLACK
    draw text="Embedded software was unable to execute measurement command "
    draw text="correctly. The exact reason is displayed in red in the main "
    draw text="Ollytest window. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Embedded software returned unexpected answer. "
  else if err==4 then
    draw text="???!"
    draw at 6,60 color=BLACK
    draw text="D?????????D10 Ohm????"
    //draw text="not exceed 10 Ohm. However, resistance measured between heads "
    c=(head & 1)==0?'L':'R'
    draw text=format("%i%c and %i%c ??2a??? %.3g Ohm? ",head/2,c,head/2+1,c,r)
  else if err==5 then
    draw text="Possible contact to shuttle!"
    draw at 6,60 color=BLACK
    draw text="OlliBoard may have electrical contact to the shuttle. If this "
    draw text="is really the case, all subsequent measurements may be noisy, "
    draw text="unreliable or invalid. "
  endif
  draw text="????????2?2?"
  draw show
  hretry=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="???"
    help="????2a??"
  endc
  hreload=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="?????"
    help="????2?2a???????"
  endc
  if err==5 disable hreload
  hcont=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="?D?"
    help="?D?o1???o"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hretry) return 2
    if Pressed(hreload) return 1
    if Pressed(hcont) return 0
    wait
  enddo
end

// Reads electrically 16-bit identification code of the OlliBoard. Returns -1
// if operator interrupted test, 1 if it is necessary to replace board, 2 if
// operator requested to rescan ID code and 0 if code is correctly read.
function int Readboardcode()
  int i,j,t,err,id[2]
  float x1,y1,x2,y2,y,r,shift
  char s[128]
  handle hretry,hreload,hcont
  if boardtype==2 || ($LAY.rightlimit-$LAY.leftlimit)/1000.0<=330.0 then
    return 0                           // ID code is sawed off
  endif
  clear hright
  change hinfo limits=0,0
  change hinfo text="??DDo?..."
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="???D???????DDo??o????????? "
  //draw text="digits of the serial number. It is coded in the left bottom "
  //draw text="corner and allows for secure use of board-specific "
  //draw text="calibration data."
  draw show
  shift=0.0
  for j=0,j<2,j++ do                   // Read ID twice for reliability
    Convertpad(&x2,&y2,"GND1",baserail*2+1,DELTA)
  again:
    for i=0,i<16,i++ do                // Individual bits
      SYS.Killimm(i)                   // Recover from previous action
      // ID code is scanned always by the base rail.
      if boardtype==3 || boardtype==4 then
        y=-31.0                        // Y coordinate of identification bits
      else
        y=-30.0
      endif
      Convert(&x1,&y1,idx[i]+shift,y,DELTA)
      if y1<testerymin-2.5 return 0     // Large board in 2-rail A6/A8/S1/S2
      sprintf(s,"M %i(%g,%gA80H3) %i[%g,%g] R(0,1)",                           \
        baserail*2+0,x1,y1,baserail*2+1,x2,y2)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()
    while 1 do                         // Wait till all answers come back
      if Pressed(hexit) return -1      // Operator interrupted test
      for i=0,i<16,i++ do
        if $A[i].length==0 break
      enddo
      if i>=16 break                   // All answers came
      if Time()-t>20000 then
        err=1; break                   // Timeout 20 seconds
      endif
      wait
    enddo
    if err==0 then
      for i=0,i<16,i++ do
        if $A[i].answer==S_ERROR then
          err=2; break                 // Some error
        else if $A[i].answer!=S_MOVE || $A[i].subansw!=S_RMEAS then
          err=3; break                 // Unbelievable, wrong answer
        endif
        r=$A[i].r; if ($A[i].status & 0x0100) r=r*1.0e-6
        if r>10000000.0 then           // High resistance - logical 1
          id[j]=id[j] | (0x0001<<(15-i))
        else if r>100.0 then
          err=4; break                 // Strange resistance
        endif
      enddo
    endif
    if j==0 && shift==0.0 && id[0]==0xFFFF then
      // This can be the small OlliBoard with Dallas memory and design error.
      id[0]=0; shift=-1.5
      goto again
    endif
    if err!=0 break
  enddo
  if err==0 then
    sprintf(s,"M %i(Z) %i(Z) NOP",baserail*2+0,baserail*2+1)
    SERV.Cmdimm(32,s)
  endif
  if err==0 && id[0]!=id[1] err=5      // Different ID read on second pass
  if err==0 && calkeydata[3][0]!='\0' && (id[0] & 0xFFF0)!=0 then
    i=Max(2,Strlen(calkeydata[3])-1)   // Check that serial number is correct
    if Isdigit(calkeydata[3][i-2])==0 || Isdigit(calkeydata[3][i-1])==0 ||     \
      Isdigit(calkeydata[3][i]==0) err=7
    j=(calkeydata[3][i-2]-'0')*256+(calkeydata[3][i-1]-'0')*16+                \
      (calkeydata[3][i]-'0')
    if j!=(id[0] & 0xFFF0)/16 err=7
  endif
  boardidcode=id[0]
  if err==0 then
    if (boardidcode & 0x7)!=0x1 && (boardidcode & 0x7)!=0x2 then
      err=6                            // Invalid revision of the board
    else
      draw window=hright font=TIMESFONT color=BLACK at 6,130
      draw text=format("Board ID code: %03X-%01X",                             \
        boardidcode/16,boardidcode & 0x0F)
      if (boardidcode & 0x7)==0x2 then
        draw at 6,160 text="This board supports low resistance test."
      endif
      draw show
      t=Time()+3000                    // Delay 3 sec to show ID code
      while Time()<t do
        wait
      enddo
      return 0                         // Code scanned succesfully
    endif
  endif
  change hinfo text="DDo??"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within 15 seconds. "
  else if err==2 then
    draw text="Tester reports error!"
    draw at 6,60 color=BLACK
    draw text="Embedded software was unable to execute measurement command "
    draw text="correctly. The exact reason is displayed in red in the main "
    draw text="Ollytest window. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Embedded software returned unexpected answer. "
  else if err==4 then
    draw text="3?!"
    draw at 6,60 color=BLACK
    draw text="DDo??e?3???"
    draw text="100 Ohm ? 10 MOhm??"
    //draw text="specified limits. "
  else if err==5 then
    draw text="Unstable ID!"
    draw at 6,60 color=BLACK
    draw text="Different identification codes scanned on the first and second "
    draw text="pass. "
  else if err==6 then
    draw text="Wrong board revision!"
    draw at 6,60 color=BLACK
    draw text="Revision of the board coded in 3 least significant ID bits "
    draw text="is not supported by this script. "
  else if err==7 then
    draw text="Mismatched calibration data!"
    draw at 6,60 color=BLACK
    draw text="Identification code on the OlliBoard "
    draw text=format("(%03X-%01X) does not match serial ",id[0]/16,id[0] & 0xF)
    draw text=format("number from the calibration file (%s). ",calkeydata[3])
  endif
  draw text="????????2?2?"
  draw show
  hretry=control BUTTON
    window=hright
    position=5,USERY,RIGHTX/3-5,24
    name="???"
    help="???????e??"
  endc
  hreload=control BUTTON
    window=hright
    position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
    name="?????"
    help="????2?2a???????"
  endc
  hcont=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
    name="?D?"
    help="?D?o1???o"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hretry) return 2
    if Pressed(hreload) return 1
    if Pressed(hcont) return 0
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// TEST SELECTION ////////////////////////////////

// Function asks for next action. Returns action code ACT_xxx.
function int Selectaction()
  handle hadjust,hneedles,hquick,hlong,hsingle
  handle haccept,hcertify,hextern,hstroke,hfinish
  clear hright
  change hinfo limits=0,0
  change hinfo text="????????"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="??????D????:"
  draw show
  hadjust=control BUTTON
    window=hright
    position=20,39,RIGHTX-40,22
    text="D?2?y"
    help="??y??Y?o??D2a?"
    bkcolor=PINK
  endc
  hneedles=control BUTTON
    window=hright
    position=20,64,RIGHTX-40,22
    text="?2?????"
    help="?2?D??????D?"
    bkcolor=LIGHTGRAY
  endc
  hquick=control BUTTON
    window=hright
    position=20,97,RIGHTX-40,22
    text="??2a?"
    help="???2?a2a?1|?"
    bkcolor=LIGHTGRAY
  endc
  hlong=control BUTTON
    window=hright
    position=20,122,RIGHTX-40,22
    text="???2a?"
    help="????2?D2a?1|?"
    bkcolor=LIGHTGRAY
  endc
  hsingle=control BUTTON
    window=hright
    position=20,147,RIGHTX-40,22
    text="??????2a?"
    help="?2??2a?1|?"
    bkcolor=PINK
  endc
  haccept=control BUTTON
    window=hright
    position=20,172,RIGHTX-40,22
    text="??2a?"
    help="??DD?D???2a?"
    bkcolor=LIGHTGRAY
  endc
  if boardtype==2 || $LAY.rightlimit-$LAY.leftlimit<400000 disable haccept
  hcertify=control BUTTON
    window=hright
    position=20,197,RIGHTX-40,22
    text="D?2a??"
    help="??DDD?y2a?"
    bkcolor=LIGHTGRAY
  endc
  hextern=control BUTTON
    window=hright
    position=20,230,RIGHTX-40,22
    text="2a?a2??a?t"
    help="2a????D???a2?2??t"
    bkcolor=LIGHTGRAY
  endc
  if boardtype==2 || (romdata.features & BF_TYPE)==BF_TRIPOD disable hextern
  hstroke=control BUTTON
    window=hright
    position=20,263,RIGHTX-40,22
    text="???2a"
    help="DT??Z?2a2?y(?1|o??)"
    bkcolor=LIGHTGRAY
  endc
  hfinish=control BUTTON
    window=hright
    position=20,USERY+51,RIGHTX-40,22
    name="3"
    help="??3???"
  endc
  while 1 do
    if Pressed(hexit) return ACT_QUIT
    if Pressed(hadjust) return ACT_SELADJ
    if Pressed(hneedles) return ACT_NEEDLES
    if Pressed(hquick) return ACT_QUICK
    if Pressed(hlong) return ACT_LONG
    if Pressed(hsingle) return ACT_SELSINGLE
    if Pressed(haccept) return ACT_SELACCEPT
    if Pressed(hcertify) return ACT_CERTIFY
    if Pressed(hextern) return ACT_EXTERN
    if Pressed(hstroke) return ACT_STROKE
    if Pressed(hfinish) then
      SYS.Softreset(0); softreset=1
      return ACT_QUIT
    endif
    wait
  enddo
end

// Function asks for next adjustment action. Returns action code ACT_xxx.
function int Selectadjust()
  int i,j,firsttime
  char s[100]
  handle hadjmeas,hadjf,hadjl,hadjxl,hadju,hprotocol
  handle hpassword,heditrom,hmannoise,hback
  clear hright
  change hinfo limits=0,0
  change hinfo text="????????"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="??????D????:"
  hadjmeas=control BUTTON
    window=hright
    position=20,50,RIGHTX-40,22
    text="???"
    help="?2????D??y?2a?2?y"
    bkcolor=LIGHTGRAY
  endc
  hadjf=control BUTTON
    window=hright
    position=20,75,RIGHTX-40,22
    text="?????Y"
    help="??oa??????Y?"
    bkcolor=LIGHTGRAY
  endc
  hadjl=control BUTTON
    window=hright
    position=20,100,RIGHTX-40,22
    text="???2???D"
    help="2????D??y?2?2???D2a?2?y"
    bkcolor=LIGHTGRAY
  endc
  hadjxl=control BUTTON
    window=hright
    position=20,125,RIGHTX-40,22
    text="??a2???D"
    help="2????D??ya2???D2a?2?y"
    bkcolor=LIGHTGRAY
  endc
  hadju=control BUTTON
    window=hright
    position=20,150,RIGHTX-40,22
    text="??12???Y"
    help="??y?Y?a??t2a?"
    bkcolor=LIGHTGRAY
  endc
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
  then
    disable hadjl                      // Only A5/A6/A7/S1 support RL
    disable hadjxl
    disable hadju                      // Only A5/A6/A7/S1 support Universal C
  else if (features & MF_UNIC)==0 then
    disable hadju                      // Universal C is not supported
  endif



if $LAY.nfing>=12 disable hadju



  if (features & MF_EXTMEAS)==0 then
    disable hadjxl
  endif
  hprotocol=control BUTTON
    window=hright
    position=20,175,RIGHTX-40,22
    text="D-2?y"
    help="2??????????t??D-2a?2?y"
    bkcolor=LIGHTGRAY
  endc
  draw font=INFOFONT at 20,230 text="?a?????:"
  hpassword=control EDIT
    window=hright
    position=155,210,91,24
    text=wordofwisdom
    help="???????a????1|?"
    mode=M_BORDER|M_PASSWORD
  endc
  heditrom=control BUTTON
    window=hright
    position=20,245,RIGHTX-40,22
    text="?-2???"
    help="?-???ROM?D?2?y?Da????"
    bkcolor=LIGHTGRAY
  endc
  disable heditrom
  hmannoise=control BUTTON
    window=hright
    position=20,270,RIGHTX-40,22
    text="???????2a?"
    help="??DD????2a??????Da????"
    bkcolor=LIGHTGRAY
  endc
  disable hmannoise
  hback=control BUTTON
    window=hright
    position=20,USERY+51,RIGHTX-40,22
    name="???2?"
    help="?????2?"
  endc
  draw show
  firsttime=1
  while 1 do
    if Pressed(hexit) return ACT_QUIT
    if Pressed(hadjmeas) return ACT_RADJ
    if Pressed(hadjf) return ACT_FADJ
    if Pressed(hadjl) return ACT_LADJ
    if Pressed(hadjxl) return ACT_LXADJ
    if Pressed(hadju) return ACT_UCADJ
    if Pressed(hprotocol) return ACT_PROTM
    if Pressed(hpassword) || firsttime then
      // Hmm, this security is really unique!
      Text(hpassword,wordofwisdom)
      j=0
      for i=0,i<100 && wordofwisdom[i]!='\0',i++ do
        j=((j<<3)|(j>>29)) ^ wordofwisdom[i]
      enddo
      if (features & (MF_DMEM|MF_DMEMCRATE))!=(MF_DMEM|MF_DMEMCRATE) then
        disable heditrom
      else if j==0x003D4FB0 then
        enable heditrom
      else
        disable heditrom
      endif
      if (testertype!=TT_A7 && testertype!=TT_A8) || supportsoff==0 then
        disable hmannoise
      else if j==0x003D4FB0 then
        enable hmannoise
      else
        disable hmannoise
      endif
      firsttime=0
    endif
    if Pressed(heditrom) return ACT_EDITROM
    if Pressed(hmannoise) return ACT_MANNOIS
    if Pressed(hback) return ACT_BACK
    wait
  enddo
end

// Function asks to exclude some kinds of test from the certification. Sets
// excludetests to the combination of bits EXCL_xxx. Returns 0 on success, 1
// to return to main menu and -1 if operator interrupted the calibration.
function int Excludetests()
  handle hexactr,hkelvin,hrc,hcrt,hunic,hhv,hnooem,hok,hcancel
  clear hright
  change hinfo limits=0,0
  change hinfo text="??????"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="??????D??D?D?"
  draw text="2a??????:"
  excludetests=0
  getini("Meastest","Exclude tests","%i",&excludetests)
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8 then
    excludetests=excludetests|EXCL_CRT|EXCL_UNIC
  endif
  if (features & MF_CRT)==0 || nused<8 then
    excludetests=excludetests|EXCL_CRT
  endif
  if (features & MF_UNIC)==0 then
    excludetests=excludetests|EXCL_UNIC
  endif
  if boardtype!=3 && boardtype!=4 then
    excludetests=excludetests & (~EXCL_KELVIN)
  endif
  hexactr=control CHECKBOX
    window=hright
    position=20,53,235,20
    name="????2a?"
    help="???????2a?"
    mode=(excludetests & EXCL_EXACTR?0:M_CHECKED)
  endc
  if $LAY.probetype==0 then
    hkelvin=control CHECKBOX
      window=hright
      position=20,73,235,20
      name="4??2a?"
      help="????D4??2a?"
      mode=(excludetests & EXCL_KELVIN?0:M_CHECKED)
    endc
    if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&        \
      testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&           \
      testertype!=TT_A7 && testertype!=TT_A8) ||                               \
      (boardtype!=3 && boardtype!=4) || nused<4                                \
    then
      disable hkelvin
    endif
  else
    hkelvin=control CHECKBOX
      window=hright
      position=20,73,235,20
      name="????2a?"
      help="????D?a????2a?"
      mode=(excludetests & EXCL_KELVIN?0:M_CHECKED)
    endc
    if boardtype!=3 && boardtype!=4 disable hkelvin
  endif
  hrc=control CHECKBOX
    window=hright
    position=20,93,235,20
    name="??DD R||C 2a?"
    help="????DY??2a?"
    mode=(excludetests & EXCL_RPARC?0:M_CHECKED)
  endc
  hcrt=control CHECKBOX
    window=hright
    position=20,113,235,20
    name="CRT?Y2a?"
    help="?????D3?????|2a?"
    mode=(excludetests & EXCL_CRT?0:M_CHECKED)
  endc
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    (features & MF_CRT)==0 || nused<8                                          \
    disable hcrt
  hunic=control CHECKBOX
    window=hright
    position=20,133,235,20
    name="??Y"
    help="????D??Y2a?"
    mode=(excludetests & EXCL_UNIC?0:M_CHECKED)
  endc
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || (features & MF_UNIC)==0         \
    disable hunic
  hhv=control CHECKBOX
    window=hright
    position=20,153,235,20
    name="????12a?"
    help="????D???12a?"
    mode=(excludetests & EXCL_HV?0:M_CHECKED)
  endc
  draw at 6,212 color=BLACK
  draw text="?1?2a??????-2??t?y???"
  draw text="?1?????T??"
  draw text="D-o"
  hnooem=control CHECKBOX
    window=hright
    position=20,254,235,20
    name="y??t"
    help="?22a????1???-32??t?????"
  endc
  draw show
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+35,120,24
    name="D?"
    help="???a?D?"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+35,120,24
    name="???"
    help="???2?"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hok) then
      excludetests=0
      if Status(hexactr)==0 excludetests=excludetests|EXCL_EXACTR
      if Status(hkelvin)==0 excludetests=excludetests|EXCL_KELVIN
      if Status(hrc)==0 excludetests=excludetests|EXCL_RPARC
      if Status(hcrt)==0 excludetests=excludetests|EXCL_CRT
      if Status(hunic)==0 excludetests=excludetests|EXCL_UNIC
      if Status(hhv)==0 excludetests=excludetests|EXCL_HV
      nooem=Status(hnooem)
      setini("Meastest","Exclude tests","%i",excludetests)
      return 0
    else if Pressed(hcancel) then
      return 1
    endif
    wait
  enddo
end

// Function asks for the high voltage to be used during continuous acceptance
// test. Returns -1 if operator interrupted test, or action number otherwise.
function int Selectacceptance()
  handle haccept250,haccept500,hback
  clear hright
  change hinfo limits=0,0
  change hinfo text="????????"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="????????1????12a?"
  draw text=":"
  draw show
  haccept250=control BUTTON
    window=hright
    position=20,110,RIGHTX-40,22
    text="250 V HV"
    help="????1250 V????DD?D?D?2a?"
    bkcolor=LIGHTGRAY
  endc
  haccept500=control BUTTON
    window=hright
    position=20,136,RIGHTX-40,22
    text="500 V HV"
    help="????1500 V????DD?D?D?2a?"
    bkcolor=LIGHTGRAY
  endc
  hback=control BUTTON
    window=hright
    position=20,USERY+51,RIGHTX-40,22
    name="???2?"
    help="?????2?"
  endc
  while 1 do
    if Pressed(hexit) return ACT_QUIT
    if Pressed(haccept250) return ACT_ACC250
    if Pressed(haccept500) return ACT_ACC500
    if Pressed(hback) return ACT_BACK
    wait
  enddo
end

// Function asks for extra action. Returns -1 if operator interrupted test, or
// sets repeat to selected count and returns action number (0 to go back to
// previous screen).
function int Extraaction(int *repeat)
  int y,delta,ret
  char s[256]
  handle hrepeat,hrepscroll,hautorep,hshowmeas,hstrict,hlowvolt,hdiff
  handle hrtest,hmultiref,hexactrtest,hkelvintest,hfourtest,hrctest
  handle hexactrctest,hftest,hctest,hcrttest,hunic,hownc,hltest,hhvtest
  handle hnoise,hclean,hreplay,hback
  clear hright
  change hinfo limits=0,0
  change hinfo text="????????"
  draw window=hright font=INFOFONT wrap=RIGHTX-5 color=BLACK
  draw at 10,27 text="2a?:"
  hrepeat=control EDIT
    window=hright
    position=161,8,50,22
    help="2a??D????2a??????"
    font=MEDIUMFONT
    mode=M_BORDER
  endc
  if repeat[0]==0 then
    change hrepeat text="Def"
  else
    change hrepeat text=format("%i",repeat[0])
  endif
  hrepscroll=control VSCROLL
    window=hright
    position=211,8,19,22
    help="???????????y"
    limits=1,-1
  endc
  hautorep=control CHECKBOX
    window=hright
    position=10,35,100,20
    text="?D?"
    help="?D?????????2a?"
    font=INFOFONT
    mode=(autorep?M_CHECKED:0)
  endc
  hshowmeas=control CHECKBOX
    window=hright
    position=RIGHTX/2,35,100,20
    text="?2?????"
    help="??????2a?D-"
    font=INFOFONT
    mode=(logmeas?M_CHECKED:0)
  endc
  hstrict=control CHECKBOX
    window=hright
    position=10,57,100,20
    text="?????T??"
    help="??????D?D??D????T??"
    font=INFOFONT
    mode=(singlecert?0:M_CHECKED)
  endc
  hlowvolt=control CHECKBOX
    window=hright
    position=RIGHTX/2,57,100,20
    text="??1"
    help="???2a???1"
    font=INFOFONT
    mode=(lowvolt?M_CHECKED:0)
  endc
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    (features & (MF_RLIM|MF_RLIMCRATE))!=(MF_RLIM|MF_RLIMCRATE)                \
    disable hlowvolt
  hdiff=control CHECKBOX
    window=hright
    position=10,79,100,20
    text="2?e???D"
    help="??DD2????D2a?"
    font=INFOFONT
    mode=(differentiall?M_CHECKED:0)
  endc
  if (romdata.features & BF_TYPE)!=BF_TRIPOD disable hdiff
  y=112
  // Resistance.
  hrtest=control BUTTON
    window=hright
    position=10,y,RIGHTX/3-10,20
    text="R"
    help="?a????2a?"
    bkcolor=LIGHTGRAY
  endc
  hexactrtest=control BUTTON
    window=hright
    position=RIGHTX/3+5,y,RIGHTX/3-10,20
    text="???R"
    help="?a?????2a?"
    bkcolor=LIGHTGRAY
  endc
  if $LAY.probetype==0 then
    hfourtest=control BUTTON
      window=hright
      position=2*(RIGHTX/3),y,RIGHTX/3-10,20
      text="4??"
      help="?a????4???2a?"
      bkcolor=LIGHTGRAY
    endc
    if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&        \
      testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&           \
      testertype!=TT_A7 && testertype!=TT_A8) ||                               \
      (boardtype!=3 && boardtype!=4 && boardtype!=5) ||                        \
      (testersides!=0x03 && lastrail==firstrail)                               \
    then
      disable hfourtest
    endif
  else if $LAY.probetype==1 then
    hkelvintest=control BUTTON
      window=hright
      position=2*(RIGHTX/3),y,RIGHTX/3-10,20
      text="Kelvin"
      help="??a????????a???2a??"
      bkcolor=LIGHTGRAY
    endc
  endif
  y=y+24
  hrctest=control BUTTON
    window=hright
    position=10,y,RIGHTX/3-10,20
    text="R||C"
    help="?a???R | | C2a?"
    bkcolor=LIGHTGRAY
  endc
  hexactrctest=control BUTTON
    window=hright
    position=RIGHTX/3+5,y,RIGHTX/3-10,20
    text="???R||C"
    help="?a?????R | | C2a?"
    bkcolor=LIGHTGRAY
  endc
  hmultiref=control BUTTON
    window=hright
    position=2*(RIGHTX/3),y,RIGHTX/3-10,20
    text="?2???R"
    help="?a?????2????2a?"
    bkcolor=LIGHTGRAY
  endc
  y=y+30
  // Field, capacity, inductance.
  hftest=control BUTTON
    window=hright
    position=10,y,RIGHTX/3-10,20
    text="?3?"
    help="?a??3?2a?"
    bkcolor=LIGHTGRAY
  endc
  if ($LAY.config & LC_OHTYPE)==LC_NOFIELD disable hftest
  hctest=control BUTTON
    window=hright
    position=RIGHTX/3+5,y,RIGHTX/3-10,20
    text="C"
    help="????Y2a?(?3?o???Y)"
    bkcolor=LIGHTGRAY
  endc
  hcrttest=control BUTTON
    window=hright
    position=2*(RIGHTX/3),y,RIGHTX/3-10,20
    text="CRT"
    help="?a?3???y??2a?"
    bkcolor=LIGHTGRAY
  endc
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || (features & MF_CRT)==0 ||       \
    (testersides==0x03 && lastrail-firstrail<1) ||                             \
    (testersides!=0x03 && lastrail-firstrail<3)                                \
    disable hcrttest
  y=y+24
  hunic=control BUTTON
    window=hright
    position=10,y,RIGHTX/3-10,20
    text="?C"
    help="?a???Y2a?"
    bkcolor=LIGHTGRAY
  endc
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || (features & MF_UNIC)==0         \
    disable hunic
  hownc=control BUTTON
    window=hright
    position=RIGHTX/3+5,y,RIGHTX/3-10,20
    text="?C"
    help="?a?2a?????Y"
    bkcolor=LIGHTGRAY
  endc
  if testersides!=0x03 || lastrail-firstrail<1 || (features & MF_MULTIC)==0    \
    disable hownc                      // Need extra heads on both sides
  hltest=control BUTTON
    window=hright
    position=2*(RIGHTX/3),y,RIGHTX/3-10,20
    text="L"
    help="?a???D2a?"
    bkcolor=LIGHTGRAY
  endc
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    $LAY.rightlimit-$LAY.leftlimit<400000                                      \
  then
    disable hltest                     // Only A5/A6/S1 support RL measurement
  endif
  y=y+30
  // Other measurements.
  hhvtest=control BUTTON
    window=hright
    position=10,y,RIGHTX/3-10,20
    text="HV"
    help="?a????12a?"
    bkcolor=LIGHTGRAY
  endc
  y=y+30
  hnoise=control BUTTON
    window=hright
    position=10,y,RIGHTX/3-10,20
    text="??"
    help="2???2a?"
    bkcolor=LIGHTGRAY
  endc
  hclean=control BUTTON
    window=hright
    position=RIGHTX/3+5,y,RIGHTX/3-10,20
    text="???"
    help="?a??????3D"
    bkcolor=LIGHTGRAY
  endc
  hreplay=control BUTTON
    window=hright
    position=2*(RIGHTX/3),y,RIGHTX/3-10,20
    text="??2?"
    help="??2a??2???"
    bkcolor=LIGHTGRAY
  endc
  if nreplay==0 || (nreplay==1 && replay[0].head<0) disable hreplay
  hback=control BUTTON
    window=hright
    position=40,USERY+48,RIGHTX-80,22
    name="???2?"
    help="?????2?"
  endc
  draw show
  while 1 do
    if Pressed(hrepeat) || Pressed(hrepscroll) then
      delta=Status(hrepscroll)
      repeat[0]=0; Text(hrepeat,s); sscanf(s,"%i",repeat)
      repeat[0]=Min(999,Max(0,repeat[0]+delta))
      if repeat[0]==0 then
        change hrepeat text="Def"
      else
        change hrepeat text=format("%i",repeat[0])
      endif
      change hrepscroll select=0
    else if Pressed(hautorep) then
      autorep=Status(hautorep)
    else if Pressed(hshowmeas) then
      logmeas=Status(hshowmeas)
    else if Pressed(hstrict) then
      singlecert=(Status(hstrict)==0?1:0)
    else if Pressed(hlowvolt) then
      lowvolt=Status(hlowvolt)
    else if Pressed(hdiff) then
      differentiall=Status(hdiff)
    endif
    if Pressed(hexit) then
      ret=ACT_QUIT; break
    else if Pressed(hrtest) then
      ret=ACT_R; break
    else if Pressed(hmultiref) then
      ret=ACT_MULTI; break
    else if Pressed(hexactrtest) then
      ret=ACT_E; break
    else if Pressed(hkelvintest) then
      ret=ACT_KELVIN; break
    else if Pressed(hfourtest) then
      ret=ACT_4WIRE; break
    else if Pressed(hrctest) then
      ret=ACT_RC; break
    else if Pressed(hexactrctest) then
      ret=ACT_EC; break
    else if Pressed(hftest) then
      ret=ACT_F; break
    else if Pressed(hctest) then
      ret=ACT_C; break
    else if Pressed(hcrttest) then
      ret=ACT_CRT; break
    else if Pressed(hunic) then
      ret=ACT_UNIC; break
    else if Pressed(hownc) then
      ret=ACT_OWNC; break
    else if Pressed(hltest) then
      ret=ACT_RL; break
    else if Pressed(hhvtest) then
      ret=ACT_HV; break
    else if Pressed(hnoise) then
      ret=ACT_NOISE; break
    else if Pressed(hclean) then
      ret=ACT_CLEAN; break
    else if Pressed(hreplay) then
      ret=ACT_REPLAY; break
    else if Pressed(hback) then
      ret=ACT_BACK; break
    endif
    wait
  enddo
  confirm hrepeat
  repeat[0]=0; Text(hrepeat,s); sscanf(s,"%i",repeat)
  repeat[0]=Min(999,Max(0,repeat[0]))
  return ret
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// PROTOCOLLING /////////////////////////////////

function int Splittext(char *s,int limit,char *s1,char *s2)
  int i
  i=Strlen(s)
  if i<=limit then
    Strcpy(s1,s)
    s2[0]='\0'
  else
    for i=limit,i>1,i-- do
      if s[i]==' ' break
    enddo
    Memcpy(s1,s,i); s1[i]='\0'
    Strcpy(s2,s+i+1)
  endif
end

// Opens protocol files in Rich Text Format and/or in plain text.
function int Openprotocols()
  int i,j,t,opt,usetxt,usertf
  handle htxtframe,husetxt,htxtname,htxtbrowse
  handle hrtfframe,husertf,hrtfname,hrtfbrowse,hopen,hcancel
  handle habs,hrel,hpercent,hexterr,hlongerr,hextlog,hok
  char txtname[270],rtfname[270],s[128],s1[128],s2[128],type[64]
  clear hright
  change hinfo limits=0,0
  change hinfo text="??D-???t"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="????D-???tDotxt????RTF???? "
  //draw text="(formatted, MS-Word compatible), none or both."
  draw show
  usetxt=1; usertf=0; logmode=2; extendedlog=1; extendederr=1; longerr=1
  getini("Meastest","Files","%i,%i,%i,%i,%i,%i",                               \
    &usetxt,&usertf,&logmode,&extendedlog,&extendederr,&longerr)
  htxtframe=control CHILD
    window=hright
    position=6,85,253,56
    help=" "
    color=CYAN
    bkcolor=WHITECYAN
    size=128
  endc
  draw window=htxtframe color=BLACK font=INFOFONT
  draw at 5,22 text="TXT ???:" show
  husetxt=control CUSTOMBOX
    window=htxtframe
    position=118,3,50,20
    name="?"
    help="?????????aD-"
    mode=(usetxt==0?0:M_CHECKED)
  endc
  htxtbrowse=control BUTTON
    window=htxtframe
    position=174,4,75,20
    name="?"
    help="?????????D-???t???3?"
    bkcolor=LIGHTGRAY
  endc
  if usetxt==0 disable htxtbrowse
  htxtname=control COMBOEDIT
    window=htxtframe
    position=4,28,245,120
    name="2a?Text"
    help="???????????????D-???t???3?"
    mode=M_VSCROLL
  endc
  Text(htxtname,txtname)
  if txtname[0]=='\0' then
    add htxtname text="c:\\hardware\\meastest.txt"
    change htxtname select=0
  endif
  if usetxt==0 disable htxtname
  hrtfframe=control CHILD
    window=hright
    position=6,150,253,56
    help=" "
    color=CYAN
    bkcolor=WHITECYAN
    size=128
  endc
  draw window=hrtfframe color=BLACK font=INFOFONT
  draw at 5,22 text="RTF???:" show
  husertf=control CUSTOMBOX
    window=hrtfframe
    position=118,3,50,20
    name="?"
    help="????????aD-"
    mode=(usertf==0?0:M_CHECKED)
  endc
  hrtfbrowse=control BUTTON
    window=hrtfframe
    position=174,4,75,20
    name="?"
    help="????????D-???t??"
    bkcolor=LIGHTGRAY
  endc
  if usertf==0 disable hrtfbrowse
  hrtfname=control COMBOEDIT
    window=hrtfframe
    position=4,28,245,120
    name="2a?RTF"
    help="?RTF??????????D-???t???3? "
    mode=M_VSCROLL
  endc
  Text(hrtfname,rtfname)
  if rtfname[0]=='\0' then
    add hrtfname text="c:\\hardware\\meastest.rtf"
    change hrtfname select=0
  endif
  if usertf==0 disable hrtfname
  hopen=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="?aD-"
    help="???aD-???t"
  endc
  if usetxt==0 && usertf==0 disable hopen
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="?1y"
    help="?TDD-"
  endc
  while 1 do
    if Pressed(husetxt) then           // Allow use of plain text protocol
      usetxt=Status(husetxt)
      if usetxt==0 then
        disable htxtbrowse
        disable htxtname
        if usertf==0 disable hopen
      else if txtok==0 then
        enable htxtbrowse
        enable htxtname
        enable hopen
      endif
    else if Pressed(husertf) then      // Allow use of Rich Text protocol
      usertf=Status(husertf)
      if usertf==0 then
        disable hrtfbrowse
        disable hrtfname
        if usetxt==0 disable hopen
      else if rtfok==0 then
        enable hrtfbrowse
        enable hrtfname
        enable hopen
      endif
    else if Pressed(htxtbrowse) then   // Select .txt file name
      Text(htxtname,txtname)
      SERV.Addextention(txtname,".txt")
      i=SYS.Browse(hmain,txtname,"Select name of plain text file",0)
      if i!=0 change htxtname text=txtname
    else if Pressed(hrtfbrowse) then   // Select .rtf file name
      Text(hrtfname,rtfname)
      SERV.Addextention(rtfname,".rtf")
      i=SYS.Browse(hmain,rtfname,"Select name of RTF file",0)
      if i!=0 change hrtfname text=rtfname
    else if Pressed(hexit) then        // Operator interrupted test
      return -1
    else if Pressed(hopen) then        // Open protocols
      t=Readtemperature()
      if t==(-1) return -1             // Operator interrupted test
      if testertype==TT_A2 then
        j=sprintf(type,"A2/%i",$LAY.nfing*2)
      else if testertype==TT_A2L then
        j=sprintf(type,"A2/%iL",$LAY.nfing*2)
      else if testertype==TT_A2H then
        j=sprintf(type,"A2/%iM",$LAY.nfing*2)
      else if testertype==TT_A3 || testertype==TT_A3L then
        j=sprintf(type,"A3/%i",$LAY.nfing*2)
      else if testertype==TT_A4 then
        j=sprintf(type,"A4/%i",$LAY.nfing*2)
      else if testertype==TT_A5 then
        j=sprintf(type,"A5/%i",$LAY.nfing*2)
      else if testertype==TT_A5L then
        j=sprintf(type,"A5/%iL",$LAY.nfing*2)
      else if testertype==TT_A6 then
        j=sprintf(type,"A6/%i",$LAY.nfing*2)
      else if testertype==TT_S1 then
        j=sprintf(type,"S1/%i",$LAY.nfing*2)
      else if testertype==TT_S2 then
        j=sprintf(type,"S2/%i",$LAY.nfing*2)
      else if testertype==TT_S3 then
        j=sprintf(type,"S3/%i",$LAY.nfing*2)
      else if testertype==TT_A7 then
        if ($LAY.config & LC_LDMASK)==LC_LMAUTO then
          j=sprintf(type,"A7/%iA",$LAY.nfing*2)
        else if ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
          j=sprintf(type,"A7/%ieA",$LAY.nfing*2)
        else
          j=sprintf(type,"A7/%i",$LAY.nfing*2)
        endif
      else if testertype==TT_A8 then
        j=sprintf(type,"A8/%i",$LAY.nfing*2)
      else
        j=sprintf(type,"Unknown")
      endif
      if $LAY.cameras==1 || $LAY.cameras==2 then
        j=j+sprintf(type+j," with 1 camera")
      else if $LAY.cameras==3 then
        j=j+sprintf(type+j," with 2 cameras")
      endif
      if usetxt && txtok==0 then
        confirm htxtname
        Text(htxtname,txtname)
        hlog=Fopen(txtname,"wt")
        if hlog!=NULL then
          txtok=1
          destroy husetxt
          destroy htxtbrowse
          destroy htxtname
          destroy htxtframe
          disable hcancel
          fprintf(hlog,"\n                  ")
          fprintf(hlog,"M E A S U R E M E N T   S Y S T E M   T E S T\n\n")
          fprintf(hlog,"                                  ")
          fprintf(hlog,"Version %s\n\n",VERSION)
          fprintf(hlog,"      Tester type:        %s\n",type)
          Splittext(crateversion,50,s1,s2)
          fprintf(hlog,"      Crate controller:   %s\n",s1)
          if s2[0]!='\0' fprintf(hlog,"                          %s\n",s2)
          Splittext(layoutversion,50,s1,s2)
          fprintf(hlog,"      Layout:             %s\n",s1)
          if s2[0]!='\0' fprintf(hlog,"                          %s\n",s2)
          Splittext(headversion,50,s1,s2)
          fprintf(hlog,"      Head controller:    %s\n",s1)
          if s2[0]!='\0' fprintf(hlog,"                          %s\n",s2)
          fprintf(hlog,"      Test tool:          ")
          if boardtype==0 then
            fprintf(hlog,"BEL304-2 (OlliBoard)\n")
          else if boardtype==1 then
            fprintf(hlog,"BEL304-3 (OlliBoard Gold)\n")
          else if boardtype==2 then
            fprintf(hlog,"BEL304-2 (sawed off OlliBoard)\n")
          else if boardtype==3 then
            fprintf(hlog,"BEL204-0 (OlliBoard Small)\n")
          else if boardtype==4 then
            fprintf(hlog,"BEL304-4 (OlliBoard New)\n")
          else
            fprintf(hlog,"BEL304-2 or -3 (OlliBoard)\n")
          endif
          if romdatavalid then
            fprintf(hlog,"      Board S/N:          %06i\n",romdata.serial)
            fprintf(hlog,"      Certified by:       %.4s\n",romdata.operator)
            Strtime(s,"%d-%b-%Y",2,romdata.date)
            fprintf(hlog,"      Certified on:       %s\n",s)
            Strtime(s,"%d-%b-%Y",2,romdata.date+512)
            fprintf(hlog,"      Valid till:         %s\n",s)
          else
            fprintf(hlog,"      Board ID code:      %03X-%01X\n",              \
              boardidcode/16,boardidcode & 0x0F)
            if calname[0]!=0 then
              fprintf(hlog,"      Calibration file:   %s\n",calfile)
              for i=0,i<NKEY,i++ do
                if calkeydata[i][0]=='\0' continue
                fprintf(hlog,"                          %-18.18s = %s\n",      \
                calkey[i]+1,calkeydata[i])
              enddo
            endif
          endif
          if testersides==0x03 then
            fprintf(hlog,"      Rails in use:       %i(%i) - %i(%i)\n",        \
            firstrail,firstrail+$LAY.nfing/2,                                  \
            lastrail,lastrail+$LAY.nfing/2)
          else
            fprintf(hlog,"      Rails in use:       %i - %i\n",                \
            firstrail,lastrail)
          endif
          fprintf(hlog,"      Signal filtering:   ")
          opt=$int4($EXTLAY+496)
          if (opt & (HCM_FILTERC|HCM_FILTMASK))==0 then
            fprintf(hlog,"None\n")
          else if (opt & (HCM_FILTERC|HCM_FILTMASK))==HCM_FILTERC then
            fprintf(hlog,"Capacities over 300 pF\n")
          else
            if (opt & HCM_FILTMASK)==HCM_F500K then
              fprintf(hlog,"500 kHz")
            else if (opt & HCM_FILTMASK)==HCM_F100K then
              fprintf(hlog,"100 kHz")
            else if (opt & HCM_FILTMASK)==HCM_F20K then
              fprintf(hlog,"20/50 kHz")
            else
              fprintf(hlog,"Unknown filter")
            endif
            if opt & HCM_FILTERC then
              fprintf(hlog,", capacities over 300 pF")
            endif
            fprintf(hlog,"\n")
          endif
          Strtime(s,"%a %d-%b-%Y %H:%M",0,0)
          fprintf(hlog,"      Start on:           %s\n",s)
          fprintf(hlog,"      Tester temperature: ")
          if t>=10 && t<990 then
            fprintf(hlog,"%.1f C\n",t/10.0)
          else
            fprintf(hlog,"Unable to measure\n")
          endif
          fprintf(hlog,"\n--------------------------------------")
          fprintf(hlog,"---------------------------------------\n")
        endif
      endif
      if usertf && rtfok==0 then
        confirm hrtfname
        Text(hrtfname,rtfname)
        i=ROpen(rtfname)
        if i==0 then
          rtfok=1
          destroy husertf
          destroy hrtfbrowse
          destroy hrtfname
          destroy hrtfframe
          disable hcancel
          Strtime(s,"%a %d-%b-%Y %H:%M",0,0)
          RParagraph(RTF_CENTERED|RTF_HEADER|RTF_FIRST)
          RFmt(RTF_TIMES,RTF_ITALIC,12)
          RAddtext(" ")
          RParagraph(RTF_CENTERED|RTF_HEADER|RTF_THINBRD)
          RFmt(RTF_TIMES,RTF_ITALIC,9)
          RAddfmt("Measurement system test %s - page ",s)
          RAddpagenumber()
          RParagraph(RTF_CENTERED|RTF_SPACE)
          RFmt(RTF_ARIAL,RTF_BOLD|RTF_UL,18)
          RAddtext("Measurement system test")
          RFmt(RTF_ARIAL,RTF_BOLD,14)
          RAddfmt("\n\nVersion %s",VERSION)
          RParagraph(RTF_LEFT)
          RFmt(RTF_TIMES,RTF_NORMAL,12)
          RAddfmt("\n\tTester type:\t\t%s\n",type)
          Splittext(crateversion,50,s1,s2)
          RAddfmt("\tCrate controller:\t%s\n",s1)
          if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
          Splittext(layoutversion,50,s1,s2)
          RAddfmt("\tLayout:\t\t%s\n",s1)
          if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
          Splittext(headversion,50,s1,s2)
          RAddfmt("\tHead controller:\t%s\n",s1)
          if s2[0]!='\0' RAddfmt("\t\t\t\t%s\n",s2)
          if boardtype==0 then
            RAddtext("\tTest tool:\t\tBEL304-2 (OlliBoard)\n")
          else if boardtype==1 then
            RAddtext("\tTest tool:\t\tBEL304-3 (OlliBoard Gold)\n")
          else if boardtype==2 then
            RAddtext("\tTest tool:\t\tBEL304-2 (sawed off OlliBoard)\n")
          else if boardtype==3 then
            RAddtext("\tTest tool:\t\tBEL204-0 (OlliBoard Small)\n")
          else if boardtype==4 then
            RAddtext("\tTest tool:\t\tBEL304-4 (OlliBoard New)\n")
          else
            RAddtext("\tTest tool:\t\tBEL304-2 or -3 (OlliBoard)\n")
          endif
          if romdatavalid then
            RAddfmt("\tBoard ID code:\t%06i\n",romdata.serial)
            RAddfmt("\tCertified by:\t\t%.4s\n",romdata.operator)
            Strtime(s,"%d-%b-%Y",2,romdata.date)
            RAddfmt("\tCertified on:\t\t%s\n",s)
            Strtime(s,"%d-%b-%Y",2,romdata.date+512)
            RAddfmt("\tValid till:\t\t%s\n",s)
          else
            RAddfmt("\tBoard ID code:\t%03X-%01X\n",                           \
              boardidcode/16,boardidcode & 0x0F)
            if calname[0]!=0 then
              RAddfmt("\tCalibration file:\t%s\n",calfile)
              for i=0,i<NKEY,i++ do
                if calkeydata[i][0]=='\0' continue
                RAddfmt("\t\t\t\t%s = %s\n",calkey[i]+1,calkeydata[i])
              enddo
            endif
          endif
          if testersides==0x03 then
            RAddfmt("\tRails in use:\t\t%i(%i) - %i(%i)\n",                    \
            firstrail,firstrail+$LAY.nfing/2,                                  \
            lastrail,lastrail+$LAY.nfing/2)
          else
            RAddfmt("\tRails in use:\t\t%i - %i\n",firstrail,lastrail)
          endif
          RAddtext("\tSignal filtering:\t")
          opt=$int4($EXTLAY+496)
          if (opt & (HCM_FILTERC|HCM_FILTMASK))==0 then
            RAddtext("None\n")
          else if (opt & (HCM_FILTERC|HCM_FILTMASK))==HCM_FILTERC then
            RAddtext("Capacities over 300 pF\n")
          else
            if (opt & HCM_FILTMASK)==HCM_F500K then
              RAddtext("500 kHz")
            else if (opt & HCM_FILTMASK)==HCM_F100K then
              RAddtext("100 kHz")
            else if (opt & HCM_FILTMASK)==HCM_F20K then
              RAddtext("20/50 kHz")
            else
              RAddtext("Unknown filter")
            endif
            if opt & HCM_FILTERC then
              RAddtext(", capacities over 300 pF")
            endif
            RAddtext("\n")
          endif
          Strtime(s,"%a %d-%b-%Y %H:%M",0,0)
          RAddfmt("\tStart on:\t\t%s\n",s)
          RAddtext("\tTester temperature:\t")
          if t>=10 && t<990 then
            RAddfmt("%.1f C\n",t/10.0)
          else
            RAddtext("Unable to measure\n")
          endif
        endif
      endif
      if (usetxt==0 || txtok) && (usertf==0 || rtfok) break
    else if Pressed(hcancel) then      // No protocols
      return 0
    endif
    wait
  enddo
  clear hright
  change hinfo limits=0,0
  change hinfo text="????D-??"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="??????D-?????"
  draw window=hright font=INFOFONT at 11,96 color=BLACK
  draw text="????2a?y?Y:"
  draw show
  habs=control RADIO
    window=hright
    position=35,102,190,20
    text="?D??o??"
    help="?????D?o?2a??"
    font=INFOFONT
  endc
  hrel=control RADIO
    window=hright
    position=35,122,190,20
    text="????2?"
    help="?????D?o?2a?2?"
    font=INFOFONT
  endc
  hpercent=control RADIO
    window=hright
    position=35,142,190,20
    text="?2?"
    help="????2a?2???"
    font=INFOFONT
  endc
  if logmode==0 change habs mode=M_CHECKED
  if logmode==1 change hrel mode=M_CHECKED
  if logmode==2 change hpercent mode=M_CHECKED
  hexterr=control CHECKBOX
    window=hright
    position=13,166,240,20
    text="?????D"
    help="????2a?oD??2??1???D"
    font=INFOFONT
    mode=(extendederr?M_CHECKED:0)
  endc
  hlongerr=control CHECKBOX
    window=hright
    position=35,188,240,20
    text="??????1???"
    help="???????????2?"
    font=INFOFONT
    mode=(longerr?M_CHECKED:0)
  endc
  if extendederr==0 disable hlongerr
  hextlog=control CHECKBOX
    window=hright
    position=13,210,240,20
    text="??????1y?Y"
    help="2a??D??2a???D?oy?Y"
    font=INFOFONT
    mode=(extendedlog?M_CHECKED:0)
  endc
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?"
    help="?????"
  endc
  while 1 do
    if Pressed(hexit) then             // Operator interrupted test
      return -1
    else if Pressed(habs) then
      logmode=0
    else if Pressed(hrel) then
      logmode=1
    else if Pressed(hpercent) then
      logmode=2
    else if Pressed(hexterr) then
      extendederr=Status(hexterr)
      if extendederr==0 then
        disable hlongerr
      else
        enable hlongerr
      endif
    else if Pressed(hlongerr) then
      longerr=Status(hlongerr)
    else if Pressed(hextlog) then
      extendedlog=Status(hextlog)
    else if Pressed(hok) then
      break
    endif
    wait
  enddo
  setini("Meastest","Files","%i,%i,%i,%i,%i,%i",                               \
  usetxt,usertf,logmode,extendedlog,extendederr,longerr)
end

// Closes protocol files in Rich Text Format and/or in plain text.
function int Closeprotocols()
  char s[128]
  Strtime(s,"%a %d-%b-%Y %H:%M\n",0,0)
  if txtok then
    fprintf(hlog,"\n\n      Finished on:        %s",s)
    Fclose(hlog); hlog=NULL; txtok=0
  endif
  if rtfok then
    RParagraph(RTF_LEFT)
    RFmt(RTF_TIMES,RTF_NORMAL,12)
    RAddfmt("\n\tFinished on:\t\t%s\n",s)
    RClose(); rtfok=0
  endif
end

// Initializes error list.
function int Initerrlist()
  Memset(errlist,0,Sizeof(errlist))
end

// Starts new section in replay list.
function int Addreplaysection(format text)
  int i=0
  while text[i]==' ' do i++; enddo
  if text[i]=='\0' return
  if nreplay>0 && replay[nreplay-1].head<0 then
    // Previous section is empty, discard it.
    nreplay--
  endif
  if nreplay>=NREPLAY then
    nreplay--                          // Make room by discarding oldest item
    Memcpy(replay[0],replay[1],Sizeof(replay[1]))
  endif
  replay[nreplay].head=-1
  Strncpy(replay[nreplay].err,text+i,80)
  replay[nreplay].cmd[0]='\0'
  nreplay++
end

// Adds error to head. To add general errors, set head=-1. If cmd is not empty,
// adds error to replay list.
function int Adderr(char *cmd,int type,int head,format text)
  int i,n
  if cmd[0]!='\0' && head>=0 then
    n=Strlen(cmd)
    // Length of preserved commands is limited.
    if n<768 then
      // The measurements frequently repeat. Do not add them, even if text
      // is different.
      for i=nreplay-1,i>=0,i-- do
        if replay[i].head<0 then
          i=-1; break                  // Begin of section
        endif
        if Strcmp(replay[i].cmd,cmd)==0 break
      enddo
      if i<0 then
        if nreplay>=NREPLAY then
          nreplay--                    // Make room by discarding oldest item
          Memcpy(replay[0],replay[1],Sizeof(replay[1]))
        endif
        replay[nreplay].head=head
        Strncpy(replay[nreplay].err,text,80)
        Strcpy(replay[nreplay].cmd,cmd)
        nreplay++
      endif
    endif
  endif
  if extendederr==0 return
  for i=0,text[i]!='\0',i++ do
    if text[i]=='|' then
      if longerr then
        text[i]=' '
      else
        text[i]='\0'
      endif
    endif
  enddo
  if head<0 || head>32 head=32
  for i=0,i<NERR,i++ do
    if errlist[type,head,i][0]=='\0' then
      Strcpy(errlist[type,head,i],text)
      break
    else if Strcmp(errlist[type,head,i],text)==0 then
      break                            // Identical string
    endif
  enddo
end

// Writes error list of given type to protocols (0: both, 1: .TXT, 2: .RTF). If
// forhead is non-negative, protocols only the specified head (or rail this
// head belongs to).
function int Flusherrlist(int type,int protocol,int byrail,int forhead)
  int i,j,head,nlines
  nlines=0
  if extendederr==0 return
  for i=-1,i<32,i++ do
    head=(i<0?32:i)
    if forhead>=0 then
      if byrail then
        if (i & 0x1E)!=(forhead & 0x1E) continue
      else
        if i!=forhead continue
      endif
    endif
    for j=0,j<NERR,j++ do
      if errlist[type,head,j][0]=='\0' break
      if nlines==0 && forhead<0 then   // List begins
        if txtok && forhead<0 && (protocol==0 || protocol==1) then
          fprintf(hlog,"\n\n     List of errors detected during this test:\n")
        endif
        if rtfok && (protocol==0 || protocol==2) then
          RParagraph(RTF_FORMAT|RTF_INDENT); RFmt(RTF_TIMES,RTF_BOLD,9)
          RAddtext("\nList of errors detected during this test:\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
      endif
      if txtok && (protocol==0 || protocol==1) then
        if j>0 then                    // Next head-related line
          fprintf(hlog,"               ")
        else if head==32 then          // General message
          fprintf(hlog,"\n     General:  ")
        else if byrail then            // Rail
          fprintf(hlog,"\n     Rail %2i:  ",head/2)
        else                           // Head
          fprintf(hlog,"\n     Head %2i%c: ",head/2,(head & 1?'R':'L'))
        endif
        fprintf(hlog,"%s%s\n",errlist[type,head,j],(j==NERR-1?"...":""))
      endif
      if rtfok && (protocol==0 || protocol==2) then
        if j>0 then                    // Next head-related line
          RAddtext("\t")
        else if head==32 then          // General message
          RFmt(RTF_TIMES,RTF_NORMAL,3); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddtext("General:  ")
        else if byrail then            // Rail
          RFmt(RTF_TIMES,RTF_NORMAL,3); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddfmt("Rail %2i:   ",head/2)
        else                           // Head
          RFmt(RTF_TIMES,RTF_NORMAL,3); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddfmt("Head %2i%c:  ",head/2,(head & 1?'R':'L'))
        endif
        RAddfmt("\t%s%s\n",errlist[type,head,j],(j==NERR-1?"...":""))
      endif
      nlines++
      if nlines>(longerr?50:25) then   // Limit number of messages
        if txtok && (protocol==0 || protocol==1) then
          fprintf(hlog,"\n     Number of errors exceeds %i. ",nlines-1)
          fprintf(hlog,"All remaining messages are discarded.\n")
        endif
        if rtfok && (protocol==0 || protocol==2) then
          RFmt(RTF_TIMES,RTF_NORMAL,3); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_BOLD,9)
          RAddfmt("Number of errors exceeds %i. ",nlines-1)
          RAddtext("All remaining messages are discarded.")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
        return
      endif
    enddo
  enddo
end

// Removes errors of given type from the error list.
function int Discarderrlist(int type)
  int head,i,j
  if type<0 || type>=4 return
  for head=0,head<=32,head++ do
    for j=0,j<NERR,j++ do
      errlist[type,head,j,0]='\0'
    enddo
  enddo
end

// Starts legend in open TXT and RTF protocols.
function int Startexplanation()
  if txtok then
    fprintf(hlog,"\n")
    Strcpy(expl,"     "); nexpl=5
  endif
  if rtfok then
    RParagraph(RTF_FORMAT)
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RAddtext("\n\t")
  endif
end

// Adds legend (explanation) to open TXT (with formatting) and RTF protocols.
// The formatting itself is rudimentary, don't use too long words.
function int Explain(format text)
  int i,j,k,changed,nonspace
  char s[256]
  if txtok then
    i=0
    while text[i]!='\0' do
      if text[i]=='\n' then
        expl[nexpl]='\0'
        fprintf(hlog,"%s\n",expl)      // Flush and begin the new line
        Strcpy(expl,"     "); nexpl=5
        i++
        continue
      endif
      for j=i,text[j]!='\0' && text[j]!=' ' && text[j]!='\n',j++ do; enddo
      if (i==j && text[j]==' ') j++    // Single blank is allowed
      if nexpl+j-i>77 then
        while nexpl>1 && expl[nexpl-1]==' ' do nexpl--; enddo
        while nexpl<77 do              // Insert spaces for nice alignment
          k=0; changed=0; nonspace=0
          while nexpl<77 && k<nexpl do
            if expl[k]!=' ' then
              nonspace=1
            else if nonspace then
              Memcpy(expl+k+1,expl+k,nexpl-k)
              expl[k]=' '; k++
              while k<nexpl && expl[k]==' ' do k++; enddo
              nexpl++; changed=1
            endif
            k++
          enddo
        enddo
        expl[nexpl]='\0'
        fprintf(hlog,"%s\n",expl)      // Flush and begin the new line
        while text[i]==' ' do i++; enddo
        nexpl=0
      endif
      if j>i then
        Memcpy(expl+nexpl,text+i,j-i)
        nexpl=nexpl+j-i; i=j
      endif
    enddo
  endif
  if rtfok then
    j=0
    for i=0,text[i]!='\0',i++ do
      s[j]=text[i]; j++
      if text[i]=='\n' then
        s[j]='\t'; j++
      endif
    enddo
    s[j]='\0'
    RAddtext(s)
  endif
end

// Adds centered text in big bold letters to protocols.
function int Texttolog(format text)
  int i,n
  if txtok then
    fprintf(hlog,"\n")
    n=Strlen(text)
    for i=0,i<(77-n)/2,i++ do
      fprintf(hlog," ")
    enddo
    fprintf(hlog,"%s\n\n",text)
  endif
  if rtfok then
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddtext("\n")
    RAddtext(text)
    RAddtext("\n")
  endif
end

// Finishes legend in open TXT file (RTF file is self-formatting).
function int Endexplanation()
  if txtok && nexpl>0 then
    expl[nexpl]='\0'
    fprintf(hlog,"%s\n",expl)      // Flush and begin the new line
    nexpl=0
  endif
end

// Initializes test summary.
function int Clearsummary()
  nsummary=0
  summarygood=1
end

// Adds single string of formatted text to the summary.
function int Summary(int passed,format text)
  if nsummary<NSUMMARY then
    summary[nsummary,0]=passed
    Strncpy(summary[nsummary]+1,text,78)
    summary[nsummary,79]='\0'
    nsummary++
  endif
  if passed==0 summarygood=0           // Final result: NOT PASSED
end

// Flushes summary to list and protocol files. Returns 1 if test is passed and
// 0 if not.
function int Printsummary(format text)
  int i,j,k,n,c,fullset,good
  char s[80],t[80]
  if nsummary==0 return 0              // No summary data, skip printouts
  n=lastrail-firstrail+1
  if n==5 || (testersides==0x3 && n==$LAY.nfing/2) ||                          \
    (testersides!=0x3 && n==$LAY.nfing) then                                   \
    fullset=1
  else
    fullset=0
  endif
  if hlist!=NULL then
    add hlist text=""
    add hlist text=""
    change hlist color=RED
    add hlist text="                    TEST SUMMARY"
    if nooem then
      add hlist text=""
      add hlist text="DISCLAIMER:  Due to the fact that 3rd-party parts"
      add hlist text="are used in the  daily tests, atg will  not cover"
      add hlist text="any guarantee for long-time tester stability."
    endif
    for i=0,i<=nsummary,i++ do         // Each summary line and Grand Summary
      add hlist text=""
      if i<nsummary then
        Strcpy(s,summary[i]+1); good=summary[i][0]
      else
        Strcpy(s,text); good=summarygood
        add hlist text=""
      endif
      change hlist color=(good?(i==nsummary?LIGHTBLUE:BLACK):LIGHTRED)
      j=0
      while 1 do                       // Split s[j] into several t[k]
        while s[j]==' ' do j++; enddo  // Skip leading spaces
        n=0
        for k=0,k<36,k++ do
          c=s[j+k]
          if c=='\0' then break;
          else if c==' ' then n=k; endif
          t[k]=c
        enddo
        if (c=='\0' || n==0) n=k
        if j==0 then
          j=n
          while n<39 do t[n]=' '; n++; enddo
          if good==0 then
            sprintf(t+n,"%s","NOT PASSED")
          else if fullset==0 then
            sprintf(t+n,"%s","INCOMPLETE")
          else
            sprintf(t+n,"%s","PASSED")
          endif
        else
          j=j+n; t[n]='\0'
        endif
        add hlist text=t
        if c=='\0' break
      enddo
    enddo
  endif
  if txtok then
    fprintf(hlog,"\n\n                          T E S T     S U M M A R Y\n")
    for i=0,i<=nsummary,i++ do         // Each summary line and Grand Summary
      fprintf(hlog,"\n")
      if i<nsummary then
        Strcpy(s,summary[i]+1); good=summary[i][0]
      else
        Strcpy(s,text); good=summarygood
      endif
      j=0
      while 1 do                       // Split s[j] into several t[k]
        while s[j]==' ' do j++; enddo  // Skip leading spaces
        n=0
        for k=0,k<60,k++ do
          c=s[j+k]
          if c=='\0' then break;
          else if c==' ' then n=k; endif
          t[k]=c
        enddo
        if (c=='\0' || n==0) n=k
        if j==0 then
          j=n
          while n<67 do t[n]=' '; n++; enddo
          if good==0 then
            Sprintf(t+n,"%s","NOT PASSED")
          else if fullset==0 && notcertified then
            sprintf(t+n,"%s","INCOMPLETE & EXPIRED")
          else if fullset==0 then
            sprintf(t+n,"%s","INCOMPLETE")
          else if notcertified then
            Sprintf(t+n,"%s","EXPIRED")
          else
            Sprintf(t+n,"%s","PASSED")
          endif
        else
          j=j+n; t[n]='\0'
        endif
        fprintf(hlog,"%s\n",t)
        if c=='\0' break
      enddo
    enddo
    if good!=0 && notcertified!=0 then
      fprintf(hlog,"\n     Certification of test board is more than 1 year ")
      fprintf(hlog,"old.  Although all steps\nwere successful, the result is ")
      fprintf(hlog,"set to EXPIRED.\n")
    endif
    if good!=0 && fullset==0 then
      fprintf(hlog,"\n     Certification was  limited to rails %2i..%2i. ",    \
        firstrail,lastrail)
      fprintf(hlog," Therefore  it is marked  as\nINCOMPLETE.\n")
    endif
    if nooem then
      fprintf(hlog,"\n     DISCLAIMER:  Due to the fact that non-original OEM ")
      fprintf(hlog,"parts are used in the\ndaily tests, this certification is ")
      fprintf(hlog,"only valid under provison.\n     Under this circumstance  ")
      fprintf(hlog,"we will not cover  any guarantee  for long-time\n")
      fprintf(hlog,"stability.\n")
    endif
    fprintf(hlog,"\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  if rtfok then
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddfmt("\nTest summary")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    for i=0,i<=nsummary,i++ do         // Each summary line and Grand Summary
      if i<nsummary then
        Strcpy(s,summary[i]+1); good=summary[i][0]
      else
        Strcpy(s,text); good=summarygood
      endif
      if i==0 then
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,7.0)
      else
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,7.0)
      endif
      RCell(RTF_LEFT|RTF_THINBRD|RTF_SPACE,130.0)
      RAddtext(s)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,29.0)
      if good==0 then
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("NOT PASSED")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
      else if fullset==0 && notcertified then
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("INCOMPLETE & EXPIRED")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
      else if fullset==0 then
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("INCOMPLETE")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
      else if notcertified then
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("EXPIRED")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
      else
        RAddtext("PASSED")
      endif
    enddo
    if good!=0 && notcertified!=0 then
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,7.0)
      RCell(RTF_FORMAT|RTF_THINBRD,159.0)
      RFmt(RTF_ARIAL,RTF_BOLD,12)
      RAddtext("Certification of test board is more than 1 year old. Although ")
      RAddtext("all steps were successful, the result is set to EXPIRED")
    endif
    if good!=0 && fullset==0 then
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,7.0)
      RCell(RTF_FORMAT|RTF_THINBRD,159.0)
      RFmt(RTF_ARIAL,RTF_BOLD,12)
      RAddfmt("Certification was limited to rails %i..%i. ",firstrail,lastrail)
      RAddtext("Therefore it is marked as INCOMPLETE")
    endif
    if nooem then
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,7.0)
      RCell(RTF_FORMAT|RTF_THINBRD,159.0)
      RFmt(RTF_ARIAL,RTF_BOLD,12)
      RAddtext("DISCLAIMER: Due to the fact that non-original OEM parts are ")
      RAddtext("used in the daily tests, this certification is only valid ")
      RAddtext("under proviso.\nUnder this circumstance we will not cover ")
      RAddtext("any guarantee for long-time stability.")
    endif
    REndtable()
  endif
  Clearsummary()
  return good
end

// Asks whether user wants to repeat the section of the measurements. Returns
// 1 if yes, 0 if no and -1 if user decided to terminate script.
function int Askrepeat(char *text)
  handle hnever,hno,hyes,halways
  if allowrepeat==0 return 0           // User decided: no more repeats
  if allowrepeat==2 return 1           // User decided: repeat all tests
  // We must ask user whether to repeat the section.
  change hinfo text="2???1y"
  change hinfo limits=0,0
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text=format("%s ??? ",text)
  draw text="??????D?2a??e?"
  draw show
  hnever=control BUTTON
    window=hright
    position=30,110,RIGHTX-60,24
    text="2?"
    help="???e????2????"
  endc
  hno=control BUTTON
    window=hright
    position=30,150,RIGHTX-60,24
    text="?"
    help="???e???"
  endc
  hyes=control BUTTON
    window=hright
    position=30,190,RIGHTX-60,34
    text="?"
    help="???2a?2??"
    bkcolor=PINK
  endc
  halways=control BUTTON
    window=hright
    position=30,240,RIGHTX-60,24
    text="?"
    help="???2a??2????"
  endc
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hnever) then
      allowrepeat=0; return 0
    else if Pressed(hno) then
      return 0
    else if Pressed(hyes) then
      return 1
    else if Pressed(halways) then
      allowrepeat=1; return 1
    endif
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// REPLAY LIST //////////////////////////////////

function int Replaylist()
  int i,j,n,x,y,dy,btn,prevbtn,selected,redraw,headlist,bracket
  char s[1024]
  handle hchild,hcmd,hsend,hcopy,hback,hclear
  if nreplay>0 && replay[nreplay-1].head<0 then
    // Previous section is empty, discard it.
    nreplay--
  endif
  clear hright
  change hinfo text="Replay bad measurements"
  change hinfo limits=0,0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="To repeat measurement that was reported as bad, select it in "
  draw text="the list and press " font=MAINFONT text="Send" font=TIMESFONT
  draw text=". Press " font=MAINFONT text="Copy " font=TIMESFONT
  draw text="to copy command to the clipboard. Note that measurement options "
  draw text="precise coordinates and positions of free heads may differ!\n"
  draw text="Selected measurement:"
  draw show
  hcmd=control EDIT
    window=hright
    position=5,135,RIGHTX-10,112
    help="????2a?1?a???"
    mode=M_BORDER|M_VSCROLL|M_NOEDIT
  endc
  hsend=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+12,120,24
    name="?"
    help="????????????2a??"
  endc
  hcopy=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+12,120,24
    name="?????D"
    help="?????????????????"
  endc
  hclear=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+44,120,24
    name="??3y"
    help="??????3y?2a??D"
    mode=M_DBLCLICK
  endc
  hback=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+44,120,24
    name="3"
    help="??????2?"
  endc
  change hleft position=-1000,*,*,*
  dy=18
  hchild=control CHILD                 // Replaces left window
    window=hmain
    position=5,5,LEFTX,LEFTY
    help=" "
    size=128*NREPLAY
    bkcolor=WHITE
    limits=640,dy*(nreplay+3)
    mode=M_VSCROLL|M_HSCROLL
  endc
  selected=-1
  redraw=1
  prevbtn=0
  while 1 do
    if Pressed(hexit) then
      change hleft position=4,4,LEFTX,LEFTY
      destroy hchild
      return -1
    else if Pressed(hsend) then
      if selected>=0 && selected<nreplay && replay[selected].cmd[0]!='\0' then
        // Invalid sequence of replays may easily cause deadlock between the
        // heads. As a countermeasure, I send unused heads into the home
        // position. The recognition of heads within the commands is not
        // easy, but errors are usually not critical.
        Strcpy(s,replay[selected].cmd)
        headlist=0
        bracket=0
        i=0
        // Attention, text strings are not yet supported!
        while s[i]!='\0' do
          if bracket!=0 then
            while s[i]!='\0' && s[i]!=bracket do
              i++
            enddo
            if s[i]==bracket i++
            bracket=0
            continue
          endif
          if s[i]=='(' then
            bracket=')'; i++; continue
          endif
          if Isdigit(s[i])==0 && s[i]!='\0' then
            i++; continue
          endif
          j=0
          while Isdigit(s[i]) do
            j=j*10+s[i]-'0'; i++
          enddo
          if s[i]=='L' || s[i]=='l' then
            j=j*2; i++
          else if s[i]=='R' || s[i]=='r' then
            j=j*2+1; i++
          endif
          while s[i]==' ' do i++; enddo
          if s[i]=='(' then
            headlist=headlist | (1<<j); bracket=')'; i++
          else if s[i]=='[' then
            headlist=headlist | (1<<j); bracket=']'; i++
          endif
        enddo
        n=sprintf(s,"M ")
        for i=0,i<$LAY.nfing*2,i++ do
          if (headlist & (1<<i))!=0 continue
          n=n+sprintf(s+n,"%i(Z) ",i)
        enddo
        if n>2 then
          sprintf(s+n,"NOP")
          SERV.Cmdimm(32,s)
        endif
        // Now the command.
        SERV.Cmdimm(32,replay[selected].cmd)
      endif
    else if Pressed(hcopy) then
      if selected>=0 && selected<nreplay && replay[selected].cmd[0]!='\0' then
        Clipcopy(replay[selected].cmd)
      endif
    else if Pressed(hclear) then
      nreplay=0
      selected=-1
      redraw=1
      change hchild offset=0,0
      change hchild limits=640,100
    else if Pressed(hback) then
      change hleft position=4,4,LEFTX,LEFTY
      destroy hchild
      return 0
    endif
    if Mousexy(hchild,&x,&y,&btn)==1 then
      if (btn & 1)!=0 && prevbtn==0 then
        prevbtn=1
        i=(y+Limit3(hchild))/dy-2
        if i>=0 && i<nreplay && replay[i].head>=0 && selected!=i then
          selected=i
          redraw=1
        endif
      else if (btn & 1)==0 then
        prevbtn=0
      endif
    endif
    if redraw then
      redraw=0
      clear hchild
      draw window=hchild color=BLACK bkcolor=WHITE font=MAINFONT
      draw at LEFTX/2-9,dy+3 mode=M_CENTERED
      draw text="List of bad measurements"
      draw mode=M_LEFT
      for i=0,i<nreplay,i++ do
        y=(i+2)*dy
        if replay[i].head<0 then
          draw color=LIGHTRED at 4,y+dy-1 text=replay[i].err
        else
          draw color=GRAY bkcolor=(i==selected?GRAY:WHITE)
          draw at -1,y fillrect 641,y+dy+1
          draw at 27,y to 27,y+dy
          draw at 4,y+dy-1 color=BLACK
          draw text=format("%i%s",replay[i].head/2,replay[i].head & 1?"R":"L")
          draw at 30,y+dy-1
          draw text=replay[i].err
        endif
      enddo
      draw show
      if selected>=0 && selected<nreplay then
        change hcmd text=replay[selected].cmd
        enable hsend
        enable hcopy
      else
        change hcmd text=""
        disable hsend
        disable hcopy
      endif
      if nreplay>0 then
        enable hclear
      else
        disable hclear
      endif
    endif
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// TESTS /////////////////////////////////////

// Checks the quality of the contacting by testing each needle against all
// others connected in parallel for single-pin needles, or by checking loop
// resistance for Kelvin needles.
function int Checkneedles()
  int i,k,n,q,t,head,nhead,nbad[32],ncont[32],nhir[32],err
  float r,x[32],y[32],dx,dy,xpark[32],ypark[32],sigma[32][5]
  char s[512]
  handle hinterrupt,hcont
  clear hright
  change hinfo text="????2"
  change hinfo limits=0,0
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  add hlist text="               CONTACTING QUALITY"
  Addreplaysection("CONTACTING QUALITY")
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="?2a????????"
  if $LAY.probetype==1 then
    draw text="???????????"
  else
    //draw text="measuring resistance between each needle and all other "
    draw text="?????????? "
  endif
  draw text=format(" %i ??2???????2???? ",NCONT)
  if $LAY.probetype==1 then
    draw text=format("?1????2?3?1y %g Ohm ",STABKLOOP)
    draw text=format("2??D? %g Ohm.?2a?31|.",STABKSIGMA)
  else
    draw text=format("?1????2?3?1y %g Ohm ",STABRMAX)
    draw text=format("2??D? %g Ohm.?2a?31|",STABRSIGMA)
  endif
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???:  " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ?1?2????D-?Y? "
    ////draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D?????2a?"
  endc
  add hlist text=""
  add hlist text=" Head     Mean  Minimal  Maximal    Sigma  Passed"
  add hlist text=""
  Clearoversurface()
  Initerrlist()
  err=0
  nhead=$LAY.nfing*2
  // Find base points of contact for all heads.
  for head=0,head<nhead && err==0,head++ do
    if used[head]==0 continue
    Convertpad(x+head,y+head,(head & 1?"GND2":"GND1"),head,0.0)
    xpark[head]=(head & 1?x[head]+10.0:x[head]-10.0)
    ypark[head]=(y[head]>$LAY.yoffset[head/2]/1000.0?y[head]-10.0:y[head]+10.0)
  enddo
  // Test all heads.
  for head=0,head<nhead && err==0,head++ do
    if used[head]==0 continue
    Initsigma(sigma[head])
    nbad[head]=0
    ncont[head]=0
    nhir[head]=0
    // Statistics for each head. Note that I make measurements 4 times in each
    // contacting point, to take into account the contact stability. Note also
    // that I use ordinary resistance which is much more sensitive to bad
    // contacts than precise R.
    for n=0,n<NCONT/4 && err==0,n++ do
      change hinfo limits=head*NCONT+n*4,nhead*NCONT
      // Move heads.
      k=sprintf(s,"M ")
      for i=0,i<nhead,i++ do
        if used[i]==0 continue
        if i==head then                // Head under test
          dx=Random(DELTA)+Random(DELTA)-DELTA
          dy=Random(DELTA)+Random(DELTA)-DELTA
          k=k+sprintf(s+k,"%i[%g,%gA10] ",i,x[i]+dx,y[i]+dy)
        else if $LAY.probetype==1 then
          k=k+sprintf(s+k,"%i(%i,%i) ",i,xpark[i],ypark[i])
        else
          k=k+sprintf(s+k,"%i[%g,%g] ",i,x[i],y[i])
        endif
      enddo
      if $LAY.probetype==1 then
        sprintf(s+k,"DN(%i) CONTKELV(%i)",head,head)
      else
        k=k+sprintf(s+k,"R(%i",head)
        for i=0,i<nhead,i++ do
          if used[i]==0 continue
          if i==head continue
          k=k+sprintf(s+k,",%i",i)
        enddo
        sprintf(s+k,")")
      endif
      // Send 4 measurements at once.
      for i=0,i<4 && err==0,i++ do
        SYS.Killimm(i)
        if SERV.Cmdimm(i,s)<0 err=1
      enddo
      // Wait for answers.
      t=Time()
      while err==0 do
        for i=0,i<4,i++ do
          if $A[i].length==0 break
        enddo
        if i>=4 break                  // All answers here
        if Pressed(hexit) err=-1       // Operator interrupted test
        if Time()-t>10000 err=2        // Timeout
        if Pressed(hinterrupt) err=4   // Operator interrupted test
        wait
      enddo
      // Process answers.
      for i=0,i<4,i++ do
        if $LAY.probetype==1 then
          if $A[i].answer!=S_MOVE || $A[i].subansw!=M_CONTKELV then
            err=3; break
          endif
          if $A[i].status & 0x8800 then
            Adderr(s,0,head,"Bad measurement")
            nbad[head]++
          endif
          if $A[i].status & 0x0200 then
            Adderr(s,0,head,"No contact")
            ncont[head]++
          endif
          r=$A[i].r
          if r>STABKLOOP then
            Adderr(s,0,head,                                                   \
              "High resistance|(%.1f Ohm, expecting max. %g Ohm)",r,STABKLOOP)
            nhir[head]++
          endif
        else
          if $A[i].answer!=S_MOVE || $A[i].subansw!=M_RMEAS then
            err=3; break
          endif
          if $A[i].status & 0x8000 then
            Adderr(s,0,head,"Bad measurement")
            nbad[head]++
          endif
          r=$A[i].r; if ($A[i].status & 0x0100) r=r*1.0e-6
          if r>STABRMAX then
            Adderr(s,0,head,                                                   \
              "High resistance|(%.1f Ohm, expecting max. %g Ohm)",r,STABRMAX)
            nhir[head]++
          endif
        endif
        Addsigma(sigma[head],r)
      enddo
    enddo
    // Display message in the list window.
    if err==0 then
      q=nbad[head]+ncont[head]+nhir[head]
      if $LAY.probetype==1 then
        if Getsigma(sigma[head])>STABKSIGMA q=1
      else
        if Getsigma(sigma[head])>STABRSIGMA q=1
      endif
      change hlist color=(q==0?BLACK:LIGHTRED)
      add hlist text=format("%3i%c  %8.2g %8.2g %8.2g %8.2g    %s",            \
        head/2,head & 1?'R':'L',Getmean(sigma[head]),                          \
        Getmin(sigma[head]),Getmax(sigma[head]),Getsigma(sigma[head]),         \
        (q==0?"Yes":"No"))
      ;
    endif
  enddo
  if err==(-1) return -1               // Operator interrupted test
  // Write measured data to .TXT protocol.
  if err==0 && txtok!=0 then
    fprintf(hlog,"\n                              Contacting quality\n\n")
    fprintf(hlog,"Head      Mean    Minimal    Maximal      Sigma")
    fprintf(hlog,"    Bad  HighR  NoCont  Passed\n\n")
    for head=0,head<nhead,head++ do
      if used[head]==0 continue
      q=nbad[head]+ncont[head]+nhir[head]
      if $LAY.probetype==1 then
        if Getsigma(sigma[head])>STABKSIGMA q=1
      else
        if Getsigma(sigma[head])>STABRSIGMA q=1
      endif
      fprintf(hlog,"%2i%c %10.3g %10.3g %10.3g %10.3g",                        \
        head/2,head & 1?'R':'L',Getmean(sigma[head]),                          \
        Getmin(sigma[head]),Getmax(sigma[head]),Getsigma(sigma[head]))
      fprintf(hlog,"  %5i  %5i",nbad[head],nhir[head])
      if $LAY.probetype==1 then
        fprintf(hlog,"  %5i",ncont[head])
      else
        fprintf(hlog,"     - ")
      endif
      fprintf(hlog,"      %s\n\n",(q==0?"Yes":" No"))
    enddo
    Flusherrlist(0,1,0,-1)
  endif
  // Write measured data to .RTF protocol.
  if err==0 && rtfok!=0 then           // Write measured data to .RTF protocol
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddfmt("\nContacting quality")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP|RTF_KEEPNEXT,0.0,6.0)
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,14.0); RAddtext("Head")
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,22.0); RAddtext("Mean")
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,22.0); RAddtext("Minimal")
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,22.0); RAddtext("Maximal")
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,22.0); RAddtext("Sigma")
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,14.0); RAddtext("Bad")
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,14.0); RAddtext("High R")
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,14.0); RAddtext("No cont")
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,15.0); RAddtext("Passed")
    for head=0,head<nhead,head++ do
      if used[head]==0 continue
      q=nbad[head]+ncont[head]+nhir[head]
      if $LAY.probetype==1 then
        if Getsigma(sigma[head])>STABKSIGMA q=1
      else
        if Getsigma(sigma[head])>STABRSIGMA q=1
      endif
      RTable(RTF_CENTERED|RTF_BORDER|RTF_THINSP,0.0,5.0)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,14.0)
      RFmt(RTF_TIMES,RTF_NORMAL,9);
      sprintf(s,"%i%c",head/2,(head & 1)?'R':'L'); RAddtext(s)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,22.0)
      RFmt(RTF_TIMES,(q?RTF_BOLD:RTF_NORMAL),9);
      sprintf(s,"%.3g",Getmean(sigma[head])); RAddtext(s)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,22.0)
      sprintf(s,"%.3g",Getmin(sigma[head])); RAddtext(s)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,22.0)
      sprintf(s,"%.3g",Getmax(sigma[head])); RAddtext(s)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,22.0)
      sprintf(s,"%.3g",Getsigma(sigma[head])); RAddtext(s)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,14.0)
      sprintf(s,"%i",nbad[head]); RAddtext(s)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,14.0)
      sprintf(s,"%i",nhir[head]); RAddtext(s)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,14.0)
      if $LAY.probetype==1 then
        sprintf(s,"%i",ncont[head]); RAddtext(s)
      else
        RAddtext("--")
      endif
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,15.0)
      RAddtext(q?"No":"Yes")
    enddo
    REndtable()
    Flusherrlist(0,2,0,-1)
  endif
  if err==0 then
    Startexplanation()
    Explain("Comments to the table above: This test checks the reliability ")
    Explain("of the contacting between the needles and the PCB. Each head ")
    Explain("makes %i ",NCONT)
    if $LAY.probetype==1 then
      Explain("measurements of loop resistance (analog cables plus Kelvin ")
      Explain("pins plus resistance of the contacts). ")
    else
      Explain("resistance measurements against all other heads connected ")
      Explain("together. ")
    endif
    Explain("Test is passed when (a) all measurements are good (stable and ")
    Explain("reliable results, even after several retests); (b) measured ")
    Explain("resistance does not exceed ")
    Explain("%g Ohm; and (c) the ",($LAY.probetype==1?STABKLOOP:STABRMAX))
    Explain("dispersion (mean difference between the measurements) does not ")
    Explain("exceed %g Ohm.",($LAY.probetype==1?STABKSIGMA:STABRSIGMA))
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  // Error detected.
  change hlist color=LIGHTRED
  add hlist text="Contacting test interrupted!"
  if err==4 return 1                   // Operator interrupted test
  clear hright
  change hinfo text="?2a??"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Contacting test or one of the service routines found some "
    draw text="error in internal data structures. Please contact atg. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid resistance "
    draw text="measurement. "
  endif
  draw text="Contacting test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Service function, asks user to enter the test voltage and, if usermax is not
// zero, reported resistance. Returns 0 on success, -1 if user decided to
// interrupt script and 1 if user cancelled test.
function int Getutest(float *umax,float *rmax,int usermax)
  int update
  char s[100]
  handle humax,humaxscr,hrmax,hrmaxscr,hok,hcancel
  change hinfo limits=0,0
  change hinfo text="Select test parameters"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please select the maximal allowed test voltage"
  if usermax draw text=" and reported resistance"
  draw text=":"
  draw at 41,100 font=INFOFONT text="Umax = "
  humax=control EDIT
    window=hright
    position=95,81,60,24
    help="2a???1??"
    font=MEDIUMFONT
  endc
  humaxscr=control VSCROLL
    window=hright
    position=155,81,22,24
    help="?????2a???1"
    limits=1,-1
    font=MEDIUMFONT
  endc
  draw at 185,100 font=INFOFONT text="Volts"
  if usermax then
    draw at 41,140 font=INFOFONT text="Rmax = "
    hrmax=control EDIT
      window=hright
      position=95,121,60,24
      help="????????"
      font=MEDIUMFONT
    endc
    hrmaxscr=control VSCROLL
      window=hright
      position=155,121,22,24
      help="???????????"
      limits=1,-1
      font=MEDIUMFONT
    endc
    draw at 185,140 font=INFOFONT text="MOhms"
  endif
  draw show
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="?"
    help="?????a?1???????2a? "
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="???"
    help="????1y2a?"
  endc
  update=1
  while 1 do
    if Pressed(humaxscr) then
      Text(humax,s); sscanf(s,"%g",umax)
      umax[0]=umax[0]+Status(humaxscr)*0.1
      change humaxscr select=0
      update=1
    else if usermax!=0 && Pressed(hrmaxscr) then
      Text(hrmax,s); sscanf(s,"%g",rmax)
      rmax[0]=rmax[0]+Status(hrmaxscr)*10.0
      change hrmaxscr select=0
      update=1
    endif
    if update then
      if umax[0]<0.10 umax[0]=0.10
      if umax[0]>10.0 umax[0]=10.0
      change humax text=format("%g",umax[0])
      if usermax then
        if rmax[0]<10.0 rmax[0]=10.0
        if rmax[0]>200.0 rmax[0]=200.0
        change hrmax text=format("%g",rmax[0])
      endif
      update=0
    endif
    if Pressed(hexit) then
      return -1
    else if Pressed(hok) then
      Text(humax,s); sscanf(s,"%g",umax)
      if umax[0]<0.10 umax[0]=0.10
      if umax[0]>10.0 umax[0]=10.0
      if usermax then
        Text(hrmax,s); sscanf(s,"%g",rmax)
        if rmax[0]<10.0 rmax[0]=10.0
        if rmax[0]>200.0 rmax[0]=200.0
      endif
      break
    else if Pressed(hcancel) then
      Text(humax,s); sscanf(s,"%g",umax)
      if usermax then
        Text(hrmax,s); sscanf(s,"%g",rmax)
      endif
      return 1
    endif
    wait
  enddo
end

// Function performs resistance test (zero parallel capacity). If par is not 0,
// measurement is performed against all opposite fingers connected in parallel.
function int Rtest(int ntest,int exact,int uselim,int certify,int par,int log)
  char rpairs[22][14]= {             \ // Pad pairs used in resistance test
    "1 GND1  GND2",                  \ // Shortcut
    "1 R1    GND2",                  \ // 1 Ohm
    "1 R3    GND2",                  \ // 3 Ohms
    "1 R30   GND2",                  \ // 30 Ohms
    "1 R294  GND2",                  \ // 294 Ohms
    "1 R30   R294",                  \ // 324 Ohms
    "1 R2K94 GND2",                  \ // 2.94 K
    "2 R294  R2K94",                 \ // 3.234 K
    "2 R8K87 GND2",                  \ // 8.87 K
    "2 R2K94 R8K87",                 \ // 11.81 K
    "2 R29K4 GND2",                  \ // 29.4 K
    "2 R88K7 GND2",                  \ // 88.7 K
    "2 R29K4 R88K7",                 \ // 118.1 K
    "2 R978K GND2",                  \ // 978 K
    "3 R88K7 R978K",                 \ // 1.067 M
    "3 R3M32 GND2",                  \ // 3.32 M
    "3 R10M  GND2",                  \ // 10.0 M
    "3 R47M  GND2",                  \ // 47.0 M
    "3 R100M GND2",                  \ // 100 M
    "3 R200M GND2",                  \ // 200 M
    "3 RINF  GND2",                  \ // Infinite resistance
    "" };
  int i,j,k,l,l1,l2,m,n,p,q,t,part,err,nr,good,zheadtype,maxfailed
  int units[35],excluded[35],rretest[35],rbad[35],rfailed[35]
  float x1,x2,x[32],y[32],prevfactor,percent,rabslo,eabslo,rfactorhi,efactorhi
  float r,f,umax,rmax,limitmin[35],limitmax[35],tmean[35],tmax[35]
  float rexp[35],rsigma[35][5],factor[32]
  float fmean[35,32],fmin[35,32],fmax[35,32]
  char comp[32],name1[8],name2[8],s[128],s1[512],s2[512],suffix[64],buf[32]
  handle hinterrupt,hcont
  if ntest==0 ntest=(exact?5:10)       // As in certification
  // Get voltage and resistance limits.
  if uselim then
    i=Getutest(&utestmax,&rtestmax,1)
    if i!=0 return i
    umax=utestmax; rmax=rtestmax
  else
    umax=12.0; rmax=200.0
  endif
  zheadtype=$EXTLAY.zheadtype
  if certify==0 then
    rabslo=RABSLO                      // Strict conditions
    eabslo=EABSLO
    rfactorhi=RFACTORHI
    efactorhi=EFACTORHI
    maxfailed=0                        // Bad measurements are not allowed
  else
    if softtouch then
      rabslo=RABSLO*3.0                // Soft touch needles are unreliable
      eabslo=EABSLO*3.0
    else
      rabslo=RABSLO*2.0                // Certification, don't be too strict
      eabslo=EABSLO*2.0
    endif
    rfactorhi=RFACTORHI*1.5
    efactorhi=EFACTORHI*2.0
    maxfailed=2*ntest*FAILRATE+MAXFAILED
  endif
  for nr=0,rpairs[nr][0]!='\0',nr++ do; enddo
  change hinfo limits=0,0
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    (features & (MF_RLIM|MF_RLIMCRATE))!=(MF_RLIM|MF_RLIMCRATE) then
    umax=12.0                          // Limitations are not supported
    rmax=0.0
  else
    umax=Max(0.1,Min(umax,12.0))
    if rmax!=0.0 rmax=Max(10.0,Min(rmax,200.0))
  endif
  if exact then
    if par==0 then
      Strcpy(s,"EXACT RESISTANCE TEST")
    else
      Strcpy(s,"EXACT MULTIREFERENCE RESISTANCE TEST")
    endif
  else
    if par==0 then
      Strcpy(s,"ORDINARY RESISTANCE TEST")
    else
      Strcpy(s,"ORDINARY MULTIREFERENCE RESISTANCE TEST")
    endif
  endif
  i=Strlen(s)
  if umax<10.0 then
    i=i+sprintf(s+i," AT %g VOLTS",umax)
  endif
  if rmax>0.0 && rmax<200.0 then
    i=i+sprintf(s+i," TILL %g MOHM",rmax)
  endif
  i=Max(0,24-i/2)
  Memset(s1,' ',i)
  s1[i]='\0'
  add hlist text=format("%s%s",s1,s)
  Addreplaysection("%s",s)
  add hlist text=""
  add hlist text=" Expected R      Mean   Minimal   Maximal  Passed"
  prevfactor=0.0
  good=1
  Clearoversurface()
  Initerrlist()
  if log then
    i=sprintf(s,"Resistance measurements")
    if umax<10.0 i=i+sprintf(s+i,", U=%g V",umax)
    if rmax>0.0 && rmax<200.0 i=i+sprintf(s+i,", Rmax=%g MOhm",rmax)
    if txtok then
      fprintf(hlog,"\n%s:\n",s)
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\n%s:\n",s)
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  for i=0,i<nr,i++ do                  // For all resistor values
    if err!=0 break
  repeat:
    clear hright
    if exact then
      if umax>=10.0 then
        change hinfo text="????2a?"
      else
        change hinfo text=format("Exact R at %g V",umax)
      endif
    else
      if umax>=10.0 then
        change hinfo text="???2a?"
      else
        change hinfo text=format("Ordinary R at %g V",umax)
      endif
    endif
    draw window=hright font=TIMESFONT wrap=RIGHTX-5
    draw at 6,30 color=BLACK
    if exact then
      draw text="????2a????2????"
      draw text="???. "
    else
      draw text="???2a?o?,"
      draw text="??D??"
      draw text="?2?."
    endif
    draw text=format("\n\n???????2 %i ????????o?",nr)
    draw text=format("%i?",ntest*2)
    if umax<10.0 then
      draw text=format("Measurements use reduced voltage (%g V). ",umax)
    endif
    if rmax>0.0 && rmax<200.0 then
      draw text=format("Reported resistance is limited to %g MOhm. ",rmax)
    endif
    draw text="2a??o????????2?2?3?1y"
    draw text=format("%g%% ",exact?EFACTORLO*100.0:RFACTORLO*100.0)
    draw text=format("+ %g Ohm,2a??31|?.",exact?eabslo:rabslo)
    draw text=format("%g MOhm?a",(exact?ETHRESHOLD:RTHRESHOLD)/1.0e6)
    draw text=format("?, ?????a? %g%%.",exact?efactorhi*100.0:rfactorhi*100.0)
    if txtok || rtfok then
      draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
      draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
      //draw text="be added to the protocol."
    endif
    draw show
    hinterrupt=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="?D??"
      help="????D???2a?"
    endc
    part=rpairs[i][0]-'1'
    for j=0,j<7,j++ do                 // Fetch name of first pad
      if (rpairs[i][j+2]==' ' || rpairs[i][j+2]=='\0') break
      name1[j]=rpairs[i][j+2]
    enddo
    name1[j]='\0'
    for j=0,j<NPOINT,j++ do            // Find first pad
      if Strcmp(name1,xname[j])==0 break
    enddo
    if j>=NPOINT then
      err=1; break                     // Invalid pad name
    else
      x1=xpos[j]; rexp[i]=value[j]
    endif
    for j=0,j<7,j++ do                 // Fetch name of second pad
      if (rpairs[i][j+8]==' ' || rpairs[i][j+8]=='\0') break
      name2[j]=rpairs[i][j+8]
    enddo
    name2[j]='\0'
    for j=0,j<NPOINT,j++ do            // Find second pad
      if Strcmp(name2,xname[j])==0 break
    enddo
    if j>=NPOINT then
      err=1; break                     // Invalid pad name
    else
      x2=xpos[j]; rexp[i]=rexp[i]+value[j]
    endif
    r=Min(rexp[i],RMAX); units[i]=0; factor[i]=1.0
    while Abs(r)>=920.0 && units[i]<3 do
      r=r/1000.0; factor[i]=factor[i]*1000.0; units[i]++
    enddo
    if (romdata.features & BF_TYPE)==BF_TRIPOD &&                              \
      (Strcmp(name1,"R100M")==0 || Strcmp(name1,"R200M")==0 ||                 \
      Strcmp(name2,"R100M")==0 || Strcmp(name2,"R200M")==0)                    \
    then
      excluded[i]=1
      continue
    else
      excluded[i]=0
    endif
    r=Min(rexp[i],RMAX)
    if exact then
      limitmin[i]=r*(1.0-EFACTORLO)-eabslo
      limitmax[i]=r*(1.0+EFACTORLO)+eabslo
      if r>ETHRESHOLD then
        limitmin[i]=limitmin[i]-(r-ETHRESHOLD)*efactorhi
        limitmax[i]=limitmax[i]+(r-ETHRESHOLD)*efactorhi
      endif
    else
      limitmin[i]=r*(1.0-RFACTORLO)-rabslo
      limitmax[i]=r*(1.0+RFACTORLO)+rabslo
      if r>RTHRESHOLD then
        limitmin[i]=limitmin[i]-(r-RTHRESHOLD)*rfactorhi
        limitmax[i]=limitmax[i]+(r-RTHRESHOLD)*rfactorhi
      endif
    endif
    if rmax>0.0 then
      r=Min(r,rmax*1.0e6)
      limitmin[i]=Min(limitmin[i],rmax*1.0e6*(1.0-EFACTORLO))
      limitmax[i]=Min(limitmax[i],rmax*1.0e6*(1.0+EFACTORLO))
    endif
    for j=0,j<$LAY.nfing*2,j=j+2 do    // Calculate coordinates of all fingers
      if used[j]==0 continue
      Convert(x+j,y+j,x1,ypos[j],DELTA)
      sprintf(s1,"M %i[%g,%gA%i] NOP",j,x[j],y[j],acc)
      if SERV.Cmdimm(j,s1)<0 err=1     // Move all fingers to pads
      Convert(x+j+1,y+j+1,x2,ypos[j+1],DELTA)
      sprintf(s2,"M %i[%g,%gA%i] NOP",j+1,x[j+1],y[j+1],acc)
      if SERV.Cmdimm(j+1,s2)<0 err=1   // Move all fingers to pads
    enddo
    tmean[i]=0.0; tmax[i]=0.0
    if certify==0 && usestat==1 then
      // Initialize measurement card statistics.
      buf[0]=S_DEBUG
      buf[1]=0x2F                      // Statistical data
      buf[2]=0x80                      // Measurement card
      buf[3]=1                         // Reset statistics
      $int2(buf+4)=0x32                // Page 0x32
      $int4(buf+6)=0                   // Must be zero
      SYS.Sendimm(32,10,buf)
    endif
    t=Time()
    while err==0 do
      for j=0,j<$LAY.nfing*2,j++ do
        if used[j]==0 continue
        if $A[j].length==0 break
      enddo
      if j>=$LAY.nfing*2 break         // All answers here
      if Pressed(hexit) err=-1         // Operator interrupted test
      if Time()-t>10000 err=2          // Timeout
      if Pressed(hinterrupt) err=4     // Operator interrupted test
      wait
    enddo
    if err!=0 break
    Initsigma(rsigma[i])
    for j=0,j<$LAY.nfing*2,j++ do
      fmean[i,j]=0.0; fmin[i,j]=1.0e99; fmax[i,j]=-1.0e99;
    enddo
    rretest[i]=0; rbad[i]=0; rfailed[i]=0
    for n=0,n<ntest,n++ do             // Statistics for each resistor
      change hinfo limits=i*ntest+n,nr*ntest
      j=0
      if umax<10.0 j=j+sprintf(suffix+j,",UMAX=%g",umax)
      if rmax>0.0 && rmax<200.0 j=j+sprintf(suffix+j,",RMAX=%g",rmax)
      suffix[j]='\0'
      for j=0,j<$LAY.nfing*2,j=j+2 do  // Test each rail
        if used[j]==0 continue
        if par==0 || r>1.0e7 then
          // Measurements within one rail.
          sprintf(s1,"M %i[%g,%gA%i] %i[%g,%gA%i] %c(%i,%i%s)",                \
          j,x[j],y[j],acc,j+1,x[j+1],y[j+1],acc,(exact?'E':'R'),j,j+1,suffix)
          sprintf(s2,"M %i[%g,%gA%i] %i[%g,%gA%i] %c(%i,%i%s)",                \
          j,x[j],y[j],acc,j+1,x[j+1],y[j+1],acc,(exact?'E':'R'),j+1,j,suffix)
        else
          // Head is tested against all opposite heads.
          l1=sprintf(s1,"M %i[%g,%gA%i]",j,x[j],y[j],acc)
          l=0
          for k=0,k<$LAY.nfing*2,k=k+2 do
            if used[k]==0 continue
            l1=l1+sprintf(s1+l1," %i[%g,%gA%i]",k+1,x[k+1],y[k+1],acc)
            l=l+sprintf(s+l,",%i",k+1)
          enddo
          sprintf(s1+l1," %c(%i%s%s)",(exact?'E':'R'),j,s,suffix)
          l2=sprintf(s2,"M %i[%g,%gA%i]",j+1,x[j+1],y[j+1],acc)
          l=0
          for k=0,k<$LAY.nfing*2,k=k+2 do
            if used[k]==0 continue
            l2=l2+sprintf(s2+l2," %i[%g,%gA%i]",k,x[k],y[k],acc)
            l=l+sprintf(s+l,",%i",k)
          enddo
          sprintf(s2+l2," %c(%i%s%s)",(exact?'E':'R'),j+1,s,suffix)
        endif
        if SERV.Cmdimm(0,s1)<0 err=1   // To speed up test (but still detect
        if SERV.Cmdimm(1,s2)<0 err=1   // all possible problems), send at once
        if SERV.Cmdimm(2,s1)<0 err=1   // 4 commands (2 in each direction)
        if SERV.Cmdimm(3,s2)<0 err=1
        t=Time()
        while err==0 do
          for k=0,k<4,k++ do
            if $A[k].length==0 break
          enddo
          if k>=4 break                // All answers here
          if Pressed(hexit) err=-1     // Operator interrupted test
          if Time()-t>20000 err=2      // Timeout
          if Pressed(hinterrupt) err=4 // Operator interrupted test
          wait
        enddo
        if err!=0 break
        for k=0,k<4,k++ do
          q=j+(k & 1)
          if $A[k].answer!=S_MOVE then
            err=3; break               // Unexpected answer
          endif
          r=$A[k].r; if ($A[k].status & 0x0100) r=r*1.0e-6
          if $A[k].status & 0x1000 rretest[i]++
          if rexp[i]>1000000.0 then p=2; f=1000000.0;
          else if rexp[i]>1000.0 then p=1; f=1000.0;
          else p=0; f=1.0; endif
          if $A[k].status & 0x0800 then
            if rexp[i]>RMAX then sprintf(comp,"open 200 MOhm");
            else if part==0 then sprintf(comp,"%.4g Ohm",rexp[i]);
            else if part==1 then sprintf(comp,"%.4g kOhm",rexp[i]/1000.0);
            else sprintf(comp,"%.4g MOhm",rexp[i]/1.0e6); endif
            Adderr((k==0 || k==2?s1:s2),part,q,"Bad measurements at %s",comp)
            rbad[i]++; rfailed[i]++
          else if r<limitmin[i] || r>limitmax[i] then
            if rexp[i]>RMAX then sprintf(comp,"open 200 MOhm");
            else if part==0 then sprintf(comp,"%.4g Ohm",rexp[i]);
            else if part==1 then sprintf(comp,"%.4g kOhm",rexp[i]/1000.0);
            else sprintf(comp,"%.4g MOhm",rexp[i]/1.0e6); endif
            if extendederr==0 then
              Adderr((k==0 || k==2?s1:s2),part,q,                              \
              "Resistance out of limits (%.4g..%.4g %s) at %s",                \
              limitmin[i]/f,limitmax[i]/f,runitname[p],comp)
            else
              Adderr((k==0 || k==2?s1:s2),part,q,                              \
              "Resistance %.4g %s out of limits (%.4g..%.4g %s) at %s",        \
              r/f,runitname[p],limitmin[i]/f,limitmax[i]/f,runitname[p],comp)
            endif
            rfailed[i]++
          endif
          Addsigma(rsigma[i],r)
          if log then
            if exact then
              m=sprintf(s,"  Exact R ")
            else
              m=sprintf(s,"  R ")
            endif
            m=m+sprintf(s+m,"(%5.4g %4s), ",rexp[i]/f,runitname[p])
            m=m+sprintf(s+m,"heads %2i - ",q)
            if par then
              m=m+sprintf(s+m,"all: ")
            else
              m=m+sprintf(s+m,"%2i: ",q^1)
            endif
            sprintf(s+m,"%8.5g %4s, status %04X",r/f,runitname[p],$A[k].status)
            lprintf(GREEN,"%s",s)
            if txtok!=0 then
              fprintf(hlog,"%s\n",s)
            endif
            if rtfok!=0 then
              RAddfmt("%s\n",s)
            endif
          endif
          fmean[i,q]=fmean[i,q]+r
          fmin[i,q]=Min(fmin[i,q],r)
          fmax[i,q]=Max(fmax[i,q],r)
        enddo
        if err!=0 break
        if par==0 || r>1.0e7 then
          if (exact && r>1000.0) || r>100000.0 then
            sprintf(s1,"M %i[%g,%g] %i[%g,%g] NOP",                            \
              j,x[j]-0.5,y[j],j+1,x[j+1]+0.5,y[j+1])
            if SERV.Cmdimm(4,s1)<0 err=1
            t=Time()+10000             // Timeout 10 seconds
            while $A[4].length==0 && err==0 do
              if Pressed(hexit) err=-1 // Button "Exit" works as interrupt
              if t<Time() err=1        // Timeout exhausted
              wait
            enddo
          endif
        endif
        if err!=0 break
      enddo
      if err!=0 break
    enddo
    if certify==0 && usestat==1 then
      // Read measurement statistics.
      buf[0]=S_DEBUG
      buf[1]=0x2F                      // Statistical data
      buf[2]=0x80                      // Measurement card
      buf[3]=1                         // Reset statistics afterwards
      $int2(buf+4)=0x32                // Page 0x32
      $int4(buf+6)=0                   // Must be zero
      SYS.Sendimm(0,10,buf)
      t=Time()
      while err==0 do
        if $A[0].length!=0 break
        if Pressed(hexit) err=-1       // Operator interrupted test
        if Time()-t>10000 err=2        // Timeout
        if Pressed(hinterrupt) err=4   // Operator interrupted test
        wait
      enddo
      if err==0 && $A[0].answer==S_DEBUG then
        tmean[i]=$uint4($A[0]+5+0*4)/1000.0
        tmax[i]=$uint4($A[0]+5+1*4)/1000.0
      endif
    endif
    // Measurements for resistance i finished. Correct mean values and display
    // message in the list window.
    if err==0 then
      for j=0,j<$LAY.nfing*2,j++ do
        if used[j]==0 continue
        fmean[i,j]=fmean[i,j]/(2*ntest)
      enddo
      r=Min(rexp[i],RMAX)/factor[i]
      if factor[i]!=prevfactor then
        add hlist text=""
        prevfactor=factor[i]
      endif
      if rexp[i]<=RMAX then
        j=sprintf(s1,"%6.3g ",r)
        if units[i]==0 j=j+Sprintf(s1+j," Ohm")
        if units[i]==1 j=j+Sprintf(s1+j,"kOhm")
        if units[i]==2 j=j+Sprintf(s1+j,"MOhm")
        if units[i]==3 j=j+Sprintf(s1+j,"GOhm")
      else
        j=sprintf(s1," Open 200 M")
      endif
      q=(rfailed[i]<=maxfailed)
      if q==0 good=0
      sprintf(s1+j," %9.3g %9.3g %9.3g    %s",                                 \
        Getmean(rsigma[i])/factor[i],Getmin(rsigma[i])/factor[i],              \
        Getmax(rsigma[i])/factor[i],q?"Yes":"No")
      change hlist color=(q?BLACK:LIGHTRED)
      add hlist text=s1
      if rpairs[i][0]!=rpairs[i+1][0] then
        sprintf(s1,"%s ?2a????? %.3g %s",                 \
          exact?"Exact":"??",r,runitname[units[i]])
        if good==0 && certify!=0 then
          j=Askrepeat(s1)
          if j<0 return -1
          if j==1 then
            while i>0 && rpairs[i][0]==rpairs[i-1][0] do
              i--
            enddo
            Discarderrlist(part)
            good=1
            goto repeat
          endif
        endif
        Summary(good,"%s",s1)
        good=1
      endif
    endif
    if err!=0 break
  enddo
  if err==(-1) return -1               // Operator interrupted test
  if err==0 && txtok!=0 then           // Write measured data to .TXT protocol
    k=0                                // Index of first resistor in rpairs
    while rpairs[k][0]!='\0' do        // For all tables
      part=rpairs[k][0]-'1'
      fprintf(hlog,"\n                 %s resistance measurements - part %c\n",\
        (exact?"    Exact":"  Ordinary"),rpairs[k][0])
      if umax<10.0 fprintf(hlog,                                               \
        "                       Test voltage is limited to %g V\n",umax)
      if rmax>0.0 && rmax<200.0 fprintf(hlog,                                  \
        "                  Reported resistance is limited to %g MOhm\n",rmax)
      if par fprintf(hlog,                                                     \
        "                             (Multireference mode)\n")
      fprintf(hlog,"\nHead    Limits")
      for i=k,rpairs[i][0]==rpairs[k][0],i++ do
        if rexp[i]<=RMAX then
          fprintf(hlog,"%9.4g",rexp[i]/factor[i])
        else
          fprintf(hlog,"     Open")
        endif
      enddo
      fprintf(hlog,"\n              ")
      for i=k,rpairs[i][0]==rpairs[k][0],i++ do
        if rexp[i]<=RMAX then
          fprintf(hlog,"%9s",runitname[units[i]])
        else
          fprintf(hlog,"    =200M")
        endif
      enddo
      for j=0,j<$LAY.nfing*2,j++ do    // For all heads
        if used[j]==0 continue
        fprintf(hlog,"\n\n%2i%c       Mean",j/2,(j & 1)?'R':'L')
        for n=k,n<i,n++ do
          if excluded[n] then
            fprintf(hlog,"       - ")
          else
            fprintf(hlog,"%9.4g",fmean[n,j]/factor[n])
          endif
        enddo
        fprintf(hlog,"\n      %s",logmode==0?"    Rmin":"Diff min")
        for n=k,n<i,n++ do
          r=Min(rexp[n],RMAX); f=factor[n]
          if excluded[n] then
            fprintf(hlog,"         ")
          else if logmode==1 then      // Differences
            fprintf(hlog,"%+9.2g",(fmin[n,j]-r)/f)
          else if logmode==2 && r<100.0 then // Low diffs
            fprintf(hlog,"%+8.2gr",(fmin[n,j]-r)/f)
          else if logmode==2 then      // Percentages
            percent=(fmin[n,j]-r)/r*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.4g",fmin[n,j]/f)
          endif
        enddo
        fprintf(hlog,"\n      %s",logmode==0?"    Rmax":"Diff max")
        for n=k,n<i,n++ do
          r=Min(rexp[n],RMAX); f=factor[n]
          if excluded[n] then
            fprintf(hlog,"         ")
          else if logmode==1 then      // Differences
            fprintf(hlog,"%+9.2g",(fmax[n,j]-r)/f)
          else if logmode==2 && r<100.0 then // Low diffs
            fprintf(hlog,"%+8.2gr",(fmax[n,j]-r)/f)
          else if logmode==2 then      // Percentages
            percent=(fmax[n,j]-r)/r*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.4g",fmax[n,j]/f)
          endif
        enddo
      enddo
      fprintf(hlog,"\n\n All      Mean")
      for n=k,n<i,n++ do
        if excluded[n] then
          fprintf(hlog,"       - ")
        else
          fprintf(hlog,"%9.4g",Getmean(rsigma[n])/factor[n])
        endif
      enddo
      fprintf(hlog,"\n      %s",logmode==0?"    Rmin":"Diff min")
      for n=k,n<i,n++ do
        r=Min(rexp[n],RMAX); f=factor[n]
        if excluded[n] then
          fprintf(hlog,"         ")
        else if logmode==1 then        // Differences
          fprintf(hlog,"%+9.2g",(Getmin(rsigma[n])-r)/f)
        else if logmode==2 && r<100.0 then // Low diffs
          fprintf(hlog,"%+8.2gr",(Getmin(rsigma[n])-r)/f)
        else if logmode==2 then        // Percentages
          percent=(Getmin(rsigma[n])-r)/r*100.0
          if percent>99.0 then fprintf(hlog,"    > 99%%");
          else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
          else fprintf(hlog,"%+8.2g%%",percent); endif
        else                           // Absolute values
          fprintf(hlog,"%9.4g",Getmin(rsigma[n])/f)
        endif
      enddo
      fprintf(hlog,"\n      %s",logmode==0?"    Rmax":"Diff max")
      for n=k,n<i,n++ do
        r=Min(rexp[n],RMAX); f=factor[n]
        if excluded[n] then
          fprintf(hlog,"         ")
        else if logmode==1 then        // Differences
          fprintf(hlog,"%+9.2g",(Getmax(rsigma[n])-r)/f)
        else if logmode==2 && r<100.0 then // Low diffs
          fprintf(hlog,"%+8.2gr",(Getmax(rsigma[n])-r)/f)
        else if logmode==2 then        // Percentages
          percent=(Getmax(rsigma[n])-r)/r*100.0
          if percent>99.0 then fprintf(hlog,"    > 99%%");
          else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
          else fprintf(hlog,"%+8.2g%%",percent); endif
        else                           // Absolute values
          fprintf(hlog,"%9.4g",Getmax(rsigma[n])/f)
        endif
      enddo
      fprintf(hlog,"\n         Sigma")
      for n=k,n<i,n++ do
        if excluded[n] then
          fprintf(hlog,"         ")
        else
          f=factor[n]
          fprintf(hlog,"%9.2g",Getsigma(rsigma[n])/f)
        endif
      enddo
      fprintf(hlog,"\n       Retests")
      for n=k,n<i,n++ do
        if excluded[n] then
          fprintf(hlog,"         ")
        else
          fprintf(hlog,"%9i",rretest[n])
        endif
      enddo
      fprintf(hlog,"\n         Bad R")
      for n=k,n<i,n++ do
        if excluded[n] then
          fprintf(hlog,"         ")
        else
          fprintf(hlog,"%9i",rbad[n])
        endif
      enddo
      if certify==0 && usestat==1 then
        fprintf(hlog,"\n     Tmean, ms")
        for n=k,n<i,n++ do
          if excluded[n] || tmean[n]==0 then
            fprintf(hlog,"         ")
          else
            fprintf(hlog,"%9.1f",tmean[n])
          endif
        enddo
        fprintf(hlog,"\n      Tmax, ms")
        for n=k,n<i,n++ do
          if excluded[n] || tmax[n]==0 then
            fprintf(hlog,"         ")
          else
            fprintf(hlog,"%9.1f",tmax[n])
          endif
        enddo
      endif
      fprintf(hlog,"\n\nPassed        ")
      for n=k,n<i,n++ do
        if excluded[n] then
          fprintf(hlog,"         ")
        else
          fprintf(hlog,"      %s",rfailed[n]>maxfailed?" No":"Yes")
        endif
      enddo
      if logmode==2 && rpairs[k][0]=='1' then
        fprintf(hlog,"\n\nLetter 'r' means difference in Ohms")
      endif
      Flusherrlist(part,1,0,-1)
      fprintf(hlog,"\n\n--------------------------------------")
      fprintf(hlog,"---------------------------------------\n")
      k=i
    enddo
  endif
  if err==0 && rtfok!=0 then           // Write measured data to .RTF protocol
    k=0                                // Index of first resistor in rpairs
    while rpairs[k][0]!='\0' do        // For all tables
      part=rpairs[k][0]-'1'
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      RAddfmt("\n%s resistance measurements - part %c",                        \
        (exact?"Exact":"Ordinary"),rpairs[k][0])
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      if umax<10.0 RAddfmt("\nTest voltage is limited to %g V",umax)
      if rmax>0.0 && rmax<200.0                                                \
        RAddfmt("\nReported resistance is limited to %g MOhm",rmax)
      if par RAddtext("\n(Multireference mode)")
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,8.0)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0); RAddtext("Head")
      RCell(RTF_CENTERED|RTF_THINBRD,19.0); RAddtext("Limits")
      for i=k,rpairs[i][0]==rpairs[k][0],i++ do
        RCell(RTF_CENTERED|RTF_THINBRD,18.0)
          if rexp[i]<=RMAX then
          sprintf(s1,"%.4g\n%s",rexp[i]/factor[i],runitname[units[i]])
          RAddtext(s1)
          if logmode==2 && rexp[i]<100.0 then
            RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("*")
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
        else
          RAddtext("Open\n(")
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("?")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("200 M)")
        endif
      enddo
      for j=0,j<$LAY.nfing*2,j++ do    // For all heads
        if used[j]==0 continue
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,12.0)
        RCell(RTF_CENTERED|RTF_THINBRD,14.0)
        RFmt(RTF_TIMES,RTF_NORMAL,5); RAddtext("\n")
        RFmt(RTF_TIMES,RTF_NORMAL,9);
        sprintf(s1,"%i\n(%i%c)",j,j/2,(j & 1)?'R':'L'); RAddtext(s1)
        RCell(RTF_RIGHT|RTF_THINBRD,19.0)
        RAddtext("Mean \n")
        RAddtext(logmode==0?"Rmin \nRmax ":"Diff min \nDiff max ")
        for n=k,n<i,n++ do
          RCell(RTF_CENTERED|RTF_THINBRD,18.0)
          if excluded[n] then
            RFmt(RTF_TIMES,RTF_NORMAL,9)
            RAddtext("\n-")
            continue
          endif
          q=(fmin[n,j]>=limitmin[n] && fmax[n,j]<=limitmax[n])
          RFmt(RTF_TIMES,q==1?RTF_NORMAL:RTF_BOLD,9)
          r=Min(rexp[n],RMAX); f=factor[n]
          if logmode==1 then           // Differences
            RAddfmt("%.4g\n%+.2g\n%+.2g",fmean[n,j]/f,                         \
            (fmin[n,j]-r)/f,(fmax[n,j]-r)/f)
          else if logmode==2 && r<100.0 then // Low diffs
            RAddfmt("%.4g\n%+.2g",fmean[n,j]/f,(fmin[n,j]-r)/f)
            RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
            RFmt(RTF_TIMES,q==1?RTF_NORMAL:RTF_BOLD,9)
            RAddfmt("\n%+.2g",(fmax[n,j]-r)/f)
            RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
          else if logmode==2 then      // Percentages
            RAddfmt("%.4g\n",fmean[n,j]/f)
            percent=(fmin[n,j]-r)/r*100.0
            if percent>99.0 then RAddtext("> 99%\n");
            else if percent<(-99.0) then RAddtext("<-99%\n");
            else RAddfmt("%+.2g%%\n",percent); endif
            percent=(fmax[n,j]-r)/r*100.0
            if percent>99.0 then RAddtext("> 99%");
            else if percent<(-99.0) then RAddtext("<-99%");
            else RAddfmt("%+.2g%%",percent); endif
          else                         // Absolute values
            RAddfmt("%.4g\n%.4g\n%.4g",fmean[n,j]/f,fmin[n,j]/f,fmax[n,j]/f)
          endif
        enddo
      enddo
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,24.0)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0);
      RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("\n\nAll\nheads")
      RCell(RTF_RIGHT|RTF_THINBRD,19.0); RAddtext("Mean \n")
      RAddtext(logmode==0?"Rmin \nRmax ":"Diff min \nDiff max ")
      RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("\ns ")
      RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("\nRetests \nBad R ")
      if certify==0 && usestat==1 RAddtext("\nTmean, ms \nTmax, ms ")
      for n=k,n<i,n++ do
        RCell(RTF_CENTERED|RTF_THINBRD,18.0)
        if excluded[n] then
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddtext("\n-")
          continue
        endif
        RFmt(RTF_TIMES,rfailed[n]<=maxfailed?RTF_NORMAL:RTF_BOLD,9)
        r=Min(rexp[n],RMAX); f=factor[n]
        if logmode==1 then             // Differences
          RAddfmt("%.4g\n%+.2g\n%+.2g",Getmean(rsigma[n])/f,                   \
          (Getmin(rsigma[n])-r)/f,(Getmax(rsigma[n])-r)/f)
        else if logmode==2 && r<100.0 then // Low diffs
          RAddfmt("%.4g\n%+.2gr\n%+.2gr",Getmean(rsigma[n])/f,                 \
          (Getmin(rsigma[n])-r)/f,(Getmax(rsigma[n])-r)/f)
        else if logmode==2 then        // Percentages
          RAddfmt("%.4g\n",Getmean(rsigma[n])/f)
          percent=(Getmin(rsigma[n])-r)/r*100.0
          if percent>99.0 then RAddtext("> 99%\n");
          else if percent<(-99.0) then RAddtext("<-99%\n");
          else RAddfmt("%+.2g%%\n",percent); endif
          percent=(Getmax(rsigma[n])-r)/r*100.0
          if percent>99.0 then RAddtext("> 99%");
          else if percent<(-99.0) then RAddtext("<-99%");
          else RAddfmt("%+.2g%%",percent); endif
        else                           // Absolute values
          RAddfmt("%.4g\n%.4g\n%.4g",Getmean(rsigma[n])/f,                     \
          Getmin(rsigma[n])/f,Getmax(rsigma[n])/f)
        endif
        RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("\n?")
        RFmt(RTF_TIMES,RTF_NORMAL,9); RAddfmt("%.2g",Getsigma(rsigma[n])/f)
        RAddfmt("\n%i\n%i",rretest[n],rbad[n])
        if certify==0 && usestat==1 then
          RAddfmt("\n"); if tmean[n]!=0.0 RAddfmt("%.1f",tmean[n])
          RAddfmt("\n"); if tmax[n]!=0.0 RAddfmt("%.1f",tmax[n])
        endif
      enddo
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0);
      RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("Passed")
      RCell(RTF_RIGHT|RTF_THINBRD,19.0);
      for n=k,n<i,n++ do
        RCell(RTF_CENTERED|RTF_THINBRD,18.0)
        if excluded[n]==0 then
          RAddtext(rfailed[n]>maxfailed?"No":"Yes")
        endif
      enddo
      REndtable()
      if logmode==2 && rpairs[k][0]=='1' then
        RParagraph(RTF_FORMAT)
        RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,10); RAddtext("          *")
        RFmt(RTF_TIMES,RTF_ITALIC,10)
        RAddtext(" Differences in Ohms.")
      endif
      Flusherrlist(part,2,0,-1)
      k=i
    enddo
  endif
  if err==0 then
    Startexplanation()
    n=0
    for i=0,i<nr,i++ do
      if excluded[i]==0 n++
    enddo
    Explain("Comments to the tables above: Each of %i different ",n)
    Explain("resistors or their combinations is checked %i times ",ntest*2)
    Explain("by each finger, giving grand total of %i ",ntest*n*nused*2)
    Explain("measurements. ")
    if maxfailed==0 then
      Explain("Test is passed when (a) all measurements are good ")
      Explain("(stable and reliable result, even after several retests) ")
    else
      Explain("Test is passed if total number of bad measurements for each ")
      Explain("resistance does not exceed %i. Measurement is ",maxfailed)
      Explain("good when (a) result is stable and reliable, even after ")
      Explain("several retests, ")
    endif
    Explain("and (b) maximal difference between measured and expected values ")
    Explain("does not exceed %g%% ",exact?EFACTORLO*100.0:RFACTORLO*100.0)
    Explain("+ %g Ohm. For resistors over ",exact?eabslo:rabslo)
    Explain("%g MOhm, this limit is ",(exact?ETHRESHOLD:RTHRESHOLD)/1.0e6)
    Explain("extended by additional %g%%.",(exact?efactorhi:rfactorhi)*100.0)
    if umax<10.0 then
      Explain("\nMaximal allowed test voltage was limited to %g V. ",umax)
      Explain("This feature reduces test speed but allows to test boards ")
      Explain("with installed components.")
    endif
    if rmax>0.0 && rmax<200.0 then
      Explain("\nMaximal reported resistance was limited to %g MOhm. ",rmax)
    endif
    if par then
      Explain("\nTest for components not exceeding 10 MOhm was done in the ")
      Explain("so called \"multireference\" mode, where ")
      Explain("resistance for a finger under test is measured against all ")
      Explain("opposite fingers connected together. This may insignificantly ")
      Explain("reduce accuracy but allows for unambiguous identification of ")
      Explain("heads with unstable internal resistance or unstable contact.")
    endif
    if n<nr then
      Explain("\nNote that some resistors on the Olliboard were replaced by ")
      Explain("alternative components.")
    endif
    if certify==0 then
      Explain("\nMean and maximal duration of measurements is in milliseconds ")
      Explain("and does not include X-Y or Z movements.")
    endif
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  add hlist text="Resistance test interrupted!"
  if err==4 return 1                   // Operator interrupted test
  clear hright
  change hinfo text="Resistance error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Resistance test or one of the service routines found some "
    draw text="error in internal data structures. Please contact atg. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid resistance "
    draw text="measurement. "
  endif
  draw text="Resistance test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Tests 4-wire resistance test with Kelvin probes (zero parallel capacity)
// using standard resistors, relatively imprecise.
function int Stdkelvin(int ntest,int exact,int certify,int log)
  char rpairs[7][48]= {                                \ // Pad pairs
    ".LATEST  LATEST  R1      R1      0.001   GND",    \ // Shortcut
    "|LATEST  LATEST  R1      R1      0.045   +Rthin", \ // Long 2-sided wire
    "|SIDEL   SIDEL   SIDER   SIDER   0.100   +Rsgl",  \ // Long 1-sided wire
    "-R1      GND1    GND1    R1      1.000   R1",     \ // 1 Ohm
    "-R3      GND1    GND1    R3      3.000   R3",     \ // 3 Ohm
    "-R30     GND1    GND1    R30     30.00   R30",    \ // 30 Ohm
    "-R294    GND1    GND1    R294    294.0   R294" }    // 294 Ohm
  int i,j,k,q,m,t,nfing,opp,opposite[32],maxfailed,nogood[7][33],err
  int active[32],noconthead[32],nocontr[7],badhead[32],badr[7]
  int totalbad,totalnocont,summary,inuse[32]
  float padx[7][4],x0,y0,x1,y1,dx,dy,factor,prevfactor,percent
  float r,rexp[7],rmeas[7][33][5],rcorr[32],abserr,relerr
  char s[256],unit[5],cmd[32][256]
  handle hinterrupt,hcont
  if $LAY.probetype!=1 return 0        // Requires Kelvin probes
  nfing=$LAY.nfing
  if nused<4 return 0                  // Requires at least two rails per side
  if $LAY.side[0]!=$LAY.side[1] return 0
  ntest=Max(1,Min(ntest,100))          // Correct obvious errors
  if exact then
    abserr=EKABS
    relerr=EKFACTOR
  else
    abserr=RKABS
    relerr=RKFACTOR
  endif
  if certify==0 then
    maxfailed=0                        // Bad measurements are not allowed
  else
    if softtouch then
      abserr=abserr*3.0                // As yet there is no Kelvin soft touch
      relerr=relerr*3.0
    else
      abserr=abserr*2.0
      relerr=relerr*2.0
    endif
    maxfailed=2*ntest*FAILRATE+MAXFAILED
  endif
repeat:
  err=0
  // Get pad coordinates and expected resistances.
  for i=0,i<7,i++ do                   // For all resistances
    for j=0,j<4,j++ do
      for k=0,k<8,k++ do
        if rpairs[i][j*8+k+1]==' ' break
        s[k]=rpairs[i][j*8+k+1]
      enddo
      s[k]='\0'
      for k=0,k<NPOINT,k++ do
        if Stricmp(xname[k],s)==0 break
      enddo
      if k>=NPOINT then
        err=5
      else
        padx[i,j]=xpos[k]
      endif
    enddo
    if romdatavalid then
      rexp[i]=Getvaluebyname(rpairs[i]+41)
    else
      rexp[i]=-1.0
    endif
    if rexp[i]<0.0 then
      if i==1 then
        if boardtype==0 then rexp[i]=rowdist*RWIRETIN;
        else rexp[i]=rowdist*RWIREGOLD; endif
      else if i==2 then
        if boardtype==0 then rexp[i]=rowdist*RWIRETIN*2.0;
        else rexp[i]=rowdist*RWIREGOLD*2.0; endif
      else
        rpairs[i][40]='\0'
        if sscanf(rpairs[i]+33,"%f",rexp+i)==0 err=5
      endif
    endif
    rexp[i]=Floor(rexp[i]*1000.0)/1000.0
  enddo
  clear hright
  change hinfo limits=0,0
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  if exact then
    change hinfo text="??????D?"
    add hlist text="           EXACT KELVIN RESISTANCE TEST"
    Addreplaysection("EXACT KELVIN RESISTANCE TEST")
  else
    change hinfo text="Ordinary Kelvin test"
    add hlist text="          ORDINARY KELVIN RESISTANCE TEST"
    Addreplaysection("ORDINARY KELVIN RESISTANCE TEST")
  endif
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="????????2a? "
  if exact then
    draw text="?????\n "
  else
    draw text="low resistances (tenth parts of Ohm), "
  endif
  draw text="??3y??o???."
  draw text=format(" %g ? %g ??????????",rexp[0],rexp[6])
  draw text=format("??????????2a? %i ??",ntest)
  draw text="2a????????2??"
  draw text=format("2?3?1y %g%% + ",relerr*100.0)
  draw text=format("%g o?,2a?31|.",abserr*1000.0)
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D??4???2a?"
  endc
  add hlist text=""
  add hlist text=" Expected R      Mean   Minimal   Maximal    Pass"
  Clearoversurface()
  Initerrlist()
  if log then
    if txtok then
      fprintf(hlog,                                                            \
      "\nKelvin measurements (corrected for resistance of wires):\n")
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\nKelvin measurements (corrected for resistance of wires):\n")
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  SERV.Cmdimm(32,"EXACTINIT 0,0,0")    // No power/current limitations
  summary=1
  prevfactor=0.0
  // Initialize statistics.
  for i=0,i<7,i++ do                   // For all resistances
    Initsigma(rmeas[i][32])
    for j=0,j<nfing*2,j++ do
      Initsigma(rmeas[i][j])
      noconthead[j]=0
      badhead[j]=0
      nogood[i,j]=0
    enddo
    nocontr[i]=0
    badr[i]=0
    nogood[i,32]=0
  enddo
  Memset(inuse,0,Sizeof(inuse))
  // Make resistance measurements.
  for i=0,i<7 && err==0,i++ do         // For all resistances
    if rexp[i]<1.0 then
      factor=1000.0; Strcpy(unit,"mOhm")
    else
      factor=1.0; Strcpy(unit,"Ohm")
    endif
    if factor!=prevfactor then
      add hlist text=""
      prevfactor=factor
    endif
    // Repeat measurements ntest times for each finger.
    for k=0,k<ntest && err==0,k++ do
      change hinfo limits=i*ntest+k,7*ntest
      for j=0,j<nfing*2 && err==0,j++ do
        if used[j]==0 continue
        active[j]=0
        // Determine "opposite" head. For some measurements, opposite finger
        // belongs to the different rail.
        if rpairs[i][0]=='-' then
          opp=j^1
        else if j+2<nfing*2 && $LAY.side[j/2]==$LAY.side[j/2+1] then
          opp=j+2
        else if j-2>=0 && $LAY.side[j/2]==$LAY.side[j/2-1] then
          opp=j-2
        else
          continue                     // Oops! No opposite!
        endif
        if used[opp]==0 continue
        inuse[j]=1
        opposite[j]=opp
        // Determine Y coordinates of contacts.
        if rpairs[i][0]=='.' then      // Move fingers to the same row of pads
          if      Abs(ypos[j]-ypos[opp])<5.0 then
            y0=ypos[j]; y1=ypos[opp]
          else if Abs(ypos[j]-yalt[opp])<5.0 then
            y0=ypos[j]; y1=yalt[opp]
          else if Abs(yalt[j]-ypos[opp])<5.0 then
            y0=yalt[j]; y1=ypos[opp]
          else if Abs(yalt[j]-yalt[opp])<5.0 then
            y0=yalt[j]; y1=yalt[opp]
          else
            continue                   // Unable to move fingers away
          endif
        else if rpairs[i][0]=='|' then // Move fingers 1 row away
          y0=-10000.0
          if Abs(ypos[j]-ypos[opp])>rowdist*0.5 &&                             \
            Abs(ypos[j]-ypos[opp])<rowdist*1.5 then
            y0=ypos[j]; y1=ypos[opp]; endif
          if Abs(ypos[j]-yalt[opp])>rowdist*0.5 &&                             \
            Abs(ypos[j]-yalt[opp])<rowdist*1.5 && ypos[j]>y0 then
            y0=ypos[j]; y1=yalt[opp]; endif
          if Abs(yalt[j]-ypos[opp])>rowdist*0.5 &&                             \
            Abs(yalt[j]-ypos[opp])<rowdist*1.5 && yalt[j]>y0 then
            y0=yalt[j]; y1=ypos[opp]; endif
          if Abs(yalt[j]-yalt[opp])>rowdist*0.5 &&                             \
            Abs(yalt[j]-yalt[opp])<rowdist*1.5 && yalt[j]>y0 then
            y0=yalt[j]; y1=yalt[opp]; endif
          if y0==(-10000.0) continue   // Unable to move fingers away
        else                           // Move fingers to the topmost points
          y0=Max(ypos[j],yalt[j])
          y1=Max(ypos[opp],yalt[opp])
        endif
        // Determine X coordinates and calculate head-dependent correction for
        // resistance of wires.
        if (j & 1)==0 then
          x0=padx[i,0]; x1=padx[i,1]   // Ground is x1
          if rpairs[i][0]!='-' then    // No resistance correction
            rcorr[j]=0.0
          else if boardtype==0 then    // Tin-coated board
            rcorr[j]=(330.0-y0)*RWIRETIN+(330.0-y1)*RGNDTIN
          else if boardtype==5 then    // Large A7 board
            rcorr[j]=(750.0-y0)*RWIREGOLD+(750.0-y1)*RGNDGOLD
          else                         // Golden board
            rcorr[j]=(330.0-y0)*RWIREGOLD+(330.0-y1)*RGNDGOLD
          endif
        else
          x0=padx[i,2]; x1=padx[i,3]   // Ground is x0
          if rpairs[i][0]!='-' then    // No resistance correction
            rcorr[j]=0.0
          else if boardtype==0 then    // Tin-coated board
            rcorr[j]=(330.0-y0)*RGNDTIN+(330.0-y1)*RWIRETIN
          else if boardtype==5 then    // Large A7 board
            rcorr[j]=(750.0-y0)*RGNDGOLD+(750.0-y1)*RWIREGOLD
          else                         // Golden board
            rcorr[j]=(330.0-y0)*RGNDGOLD+(330.0-y1)*RWIREGOLD
          endif
        endif
        // Convert coordinates from OlliBoard to tester. Heads must move from
        // one point to another between the measurements, otherwise we can't
        // guarantee the reliability of the 4-wire measurements. I keep the
        // distance between fingers constant, to reduce resistance variations.
        Convert(&x0,&y0,x0,y0,0.0)
        Convert(&x1,&y1,x1,y1,0.0)
        dx=Random(DELTA)+Random(DELTA)-DELTA
        dy=Random(DELTA)+Random(DELTA)-DELTA
        x0=x0+dx
        y0=y0+dy
        x1=x1+dx
        y1=y1+dy
        // Send measurement command.
        sprintf(cmd[j],"M %i[%g,%gA%i] %i[%g,%gA%i] %c(%i,%i)",                \
          j,x0,y0,acc,opp,x1,y1,acc,(exact?'E':'R'),j,opp)
        if SERV.Cmdimm(j,cmd[j])<0 then
          err=5
        else
          active[j]=1                  // Command was sent
        endif
      enddo
      // Now wait till all answers come back.
      t=Time()
      while err==0 do
        for j=0,j<nfing*2,j++ do
          if active[j]==0 continue     // Command was not sent
          if $A[j].length==0 break
        enddo
        if j>=nfing*2 break            // All answers are here
        if Pressed(hexit) err=-1       // Operator interrupted test
        if Time()-t>10000 err=1        // Timeout
        if Pressed(hinterrupt) err=4   // Operator interrupted test
        wait
      enddo
      if err!=0 break
      // Gather answers. Answers with no contacts are gathered separately for
      // each resistor and don't appear in the head statistics.
      for j=0,j<nfing*2,j++ do
        if active[j]==0 continue       // Command was not sent
        if $A[j].answer==S_ERROR then
          err=2; break                 // Some error
        else if $A[j].answer!=S_MOVE then
          err=3; break                 // Unbelievable, wrong answer
        endif
        r=$A[j].r; if ($A[j].status & 0x0100) r=r*1.0e-6
        // Correct measured resistance for the resistance of connecting wires.
        r=r-rcorr[j]
        if $A[j].status & 0x0600 then  // No contact in some finger(s)
          if $A[j].status & 0x0200 then
            noconthead[j]++
            Adderr(cmd[j],0,j,"No contact at %g %s",rexp[i]*factor,unit)
          endif
          if $A[j].status & 0x0400 then
            noconthead[opposite[j]]++
            Adderr(cmd[j],0,opposite[j],                                       \
            "No contact at %g %s",rexp[i]*factor,unit)
          endif
          nocontr[i]++
          nogood[i,j]++; nogood[i,32]++
        else if $A[j].status & 0x8800 then
          badhead[j]++                 // Bad measurement (excluding nocontacts)
          badr[i]++
          Adderr(cmd[j],0,j,"Bad measurements at %g %s",rexp[i]*factor,unit)
          nogood[i,j]++; nogood[i,32]++
        else
          if r<rexp[i]*(1.0-relerr)-abserr || r>rexp[i]*(1.0+relerr)+abserr then
            if extendederr==0 then
              Adderr(cmd[j],0,j,"Resistance out of limits (%.4g..%.4g %s)",    \
              (rexp[i]*(1.0-relerr)-abserr)*factor,                            \
              (rexp[i]*(1.0+relerr)+abserr)*factor,unit)
            else
              Adderr(cmd[j],0,j,                                               \
              "Resistance %g %s out of limits (%.4g..%.4g %s)",                \
              r*factor,unit,(rexp[i]*(1.0-relerr)-abserr)*factor,              \
              (rexp[i]*(1.0+relerr)+abserr)*factor,unit)
            endif
            nogood[i,j]++; nogood[i,32]++
          endif
          Addsigma(rmeas[i][j],r)
          Addsigma(rmeas[i][32],r)
        endif
        if log then
          if exact then
            m=sprintf(s,"  Exact R ")
          else
            m=sprintf(s,"  R ")
          endif
          m=m+sprintf(s+m,"(%4.3g %4s), ",rexp[i]*factor,unit)
          m=m+sprintf(s+m,"heads %2i - %2i: ",j,opposite[j])
          sprintf(s+m,"%9.5g %4s, status %04X",r*factor,unit,$A[j].status)
          lprintf(GREEN,"%s",s)
          if txtok!=0 then
            fprintf(hlog,"%s\n",s)
          endif
          if rtfok!=0 then
            RAddfmt("%s\n",s)
          endif
        endif
      enddo
    enddo
    if nogood[i,32]>maxfailed summary=0
    // Display statistics for currently finished resistor in the list window.
    change hlist color=(nogood[i,32]>maxfailed?LIGHTRED:BLACK)
    sprintf(s," %5.3g %4s %9.3g %9.3g %9.3g    %s",rexp[i]*factor,unit,        \
      Getmean(rmeas[i][32])*factor,Getmin(rmeas[i][32])*factor,                \
      Getmax(rmeas[i][32])*factor,nogood[i,32]>maxfailed?"No":"Yes")
    add hlist text=s
  enddo
  if err==(-1) return -1               // Operator interrupted test
  if err==0 && summary==0 && certify!=0 then
    sprintf(s,"%s Kelvin measurements",exact?"Exact":"Ordinary")
    i=Askrepeat(s)
    if i<0 return -1
    if i==1 goto repeat
  endif
  // Measurements finished. Write results to protocols.
  if err==0 && txtok!=0 then           // Write measured data to .TXT protocol
    fprintf(hlog,"\n                 %s Kelvin resistance measurements\n",     \
      (exact?"    Exact":"  Ordinary"))
    fprintf(hlog,"\nHead    Limits")
    for i=0,i<7,i++ do                 // For all resistances
      fprintf(hlog,"%8.4g",rexp[i]*(rexp[i]<1.0?1000.0:1.0))
    enddo
    fprintf(hlog,"   Bad/\n              ")
    for i=0,i<7,i++ do                 // For all resistances
      fprintf(hlog,"%8s",rexp[i]<1.0?"mOhm":"Ohm")
    enddo
    fprintf(hlog,"   noct")
    for j=0,j<nfing*2,j++ do           // For all heads
      if inuse[j]==0 continue
      fprintf(hlog,"\n\n%2i%c       Mean",j/2,(j & 1)?'R':'L')
      for i=0,i<7,i++ do               // For all resistances
        if Getcount(rmeas[i,j])==0 then
          fprintf(hlog,"      --")
        else
          fprintf(hlog,"%8.4g",Getmean(rmeas[i,j])*(rexp[i]<1.0?1000.0:1.0))
        endif
      enddo
      fprintf(hlog,"%7i\n",badhead[j])
      fprintf(hlog,"      %s",logmode==0?"    Rmin":"Diff min")
      for i=0,i<7,i++ do
        r=rexp[i]; factor=(r<1.0?1000.0:1.0)
        if Getcount(rmeas[i,j])==0 then
          fprintf(hlog,"        ")
        else if logmode==1 then        // Differences
          fprintf(hlog,"%+8.2g",(Getmin(rmeas[i,j])-r)*factor)
        else if logmode==2 && r<1 then // Low diffs
          fprintf(hlog,"%+7.2gr",(Getmin(rmeas[i,j])-r)*factor)
        else if logmode==2 then        // Percentages
          percent=(Getmin(rmeas[i,j])-r)/r*100.0
          if percent>99.0 then fprintf(hlog,"   > 99%%");
          else if percent<(-99.0) then fprintf(hlog,"   <-99%%");
          else fprintf(hlog,"%+7.2g%%",percent); endif
        else                           // Absolute values
          fprintf(hlog,"%8.4g",Getmin(rmeas[i,j])*factor)
        endif
      enddo
      fprintf(hlog,"%7i\n",noconthead[j])
      fprintf(hlog,"      %s",logmode==0?"    Rmax":"Diff max")
      for i=0,i<7,i++ do
        r=rexp[i]; factor=(r<1.0?1000.0:1.0)
        if Getcount(rmeas[i,j])==0 then
          fprintf(hlog,"        ")
        else if logmode==1 then        // Differences
          fprintf(hlog,"%+8.2g",(Getmax(rmeas[i,j])-r)*factor)
        else if logmode==2 && r<1 then // Low diffs
          fprintf(hlog,"%+7.2gr",(Getmax(rmeas[i,j])-r)*factor)
        else if logmode==2 then        // Percentages
          percent=(Getmax(rmeas[i,j])-r)/r*100.0
          if percent>99.0 then fprintf(hlog,"   > 99%%");
          else if percent<(-99.0) then fprintf(hlog,"   <-99%%");
          else fprintf(hlog,"%+7.2g%%",percent); endif
        else                           // Absolute values
          fprintf(hlog,"%8.4g",Getmax(rmeas[i,j])*factor)
        endif
      enddo
      fprintf(hlog,"\n         Sigma")
      for i=0,i<7,i++ do
        if Getcount(rmeas[i,j])<3 then
          fprintf(hlog,"        ")
        else
          fprintf(hlog,"%8.3g",Getsigma(rmeas[i,j])*(rexp[i]<1.0?1000.0:1.0))
        endif
      enddo
    enddo
    fprintf(hlog,"\n\n All      Mean")
    for i=0,i<7,i++ do                 // For all resistances
      if Getcount(rmeas[i,32])==0 then
        fprintf(hlog,"      --")
      else
        fprintf(hlog,"%8.4g",Getmean(rmeas[i,32])*(rexp[i]<1.0?1000.0:1.0))
      endif
    enddo
    fprintf(hlog,"\n      %s",logmode==0?"    Rmin":"Diff min")
    for i=0,i<7,i++ do
      r=rexp[i]; factor=(r<1.0?1000.0:1.0)
      if Getcount(rmeas[i,32])==0 then
        fprintf(hlog,"        ")
      else if logmode==1 then          // Differences
        fprintf(hlog,"%+8.2g",(Getmin(rmeas[i,32])-r)*factor)
      else if logmode==2 && r<1.0 then // Low diffs
        fprintf(hlog,"%+7.2gr",(Getmin(rmeas[i,32])-r)*factor)
      else if logmode==2 then          // Percentages
        percent=(Getmin(rmeas[i,32])-r)/r*100.0
        if percent>99.0 then fprintf(hlog,"   > 99%%");
        else if percent<(-99.0) then fprintf(hlog,"   <-99%%");
        else fprintf(hlog,"%+7.2g%%",percent); endif
      else                             // Absolute values
        fprintf(hlog,"%8.4g",Getmin(rmeas[i,32])*factor)
      endif
    enddo
    fprintf(hlog,"\n      %s",logmode==0?"    Rmax":"Diff max")
    for i=0,i<7,i++ do
      r=rexp[i]; factor=(r<1.0?1000.0:1.0)
      if Getcount(rmeas[i,32])==0 then
        fprintf(hlog,"        ")
      else if logmode==1 then          // Differences
        fprintf(hlog,"%+8.2g",(Getmax(rmeas[i,32])-r)*factor)
      else if logmode==2 && r<1.0 then // Low diffs
        fprintf(hlog,"%+7.2gr",(Getmax(rmeas[i,32])-r)*factor)
      else if logmode==2 then          // Percentages
        percent=(Getmax(rmeas[i,32])-r)/r*100.0
        if percent>99.0 then fprintf(hlog,"   > 99%%");
        else if percent<(-99.0) then fprintf(hlog,"   <-99%%");
        else fprintf(hlog,"%+7.2g%%",percent); endif
      else                             // Absolute values
        fprintf(hlog,"%8.4g",Getmax(rmeas[i,32])*factor)
      endif
    enddo
    fprintf(hlog,"\n         Sigma")
    for i=0,i<7,i++ do
      if Getcount(rmeas[i,32])<3 then
        fprintf(hlog,"        ")
      else
        fprintf(hlog,"%8.3g",Getsigma(rmeas[i,32])*(rexp[i]<1.0?1000.0:1.0))
      endif
    enddo
    fprintf(hlog,"\n           Bad")
    totalbad=0
    for i=0,i<7,i++ do
      fprintf(hlog,"%8i",badr[i])
      totalbad=totalbad+badr[i]
    enddo
    fprintf(hlog,"%7i\n",totalbad)
    fprintf(hlog,"       No cont")
    totalnocont=0
    for i=0,i<7,i++ do
      fprintf(hlog,"%8i",nocontr[i])
      totalnocont=totalnocont+nocontr[i]
    enddo
    fprintf(hlog,"%7i\n",totalnocont)
    fprintf(hlog,"\nPassed        ")
    for i=0,i<7,i++ do
      fprintf(hlog,"     %s",nogood[i,32]>maxfailed?" No":"Yes")
    enddo
    fprintf(hlog,"   %s",summary==0?" No!":"Yes!")
    if logmode==2 then
      fprintf(hlog,"\n\nLetter 'r' means difference in Ohms")
    endif
    Flusherrlist(0,1,0,-1)
    fprintf(hlog,"\n\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  if err==0 && rtfok!=0 then           // Write measured data to .RTF protocol
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddfmt("\n%s Kelvin resistance measurements",(exact?"Exact":"Ordinary"))
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,8.0)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Head")
    RCell(RTF_CENTERED|RTF_THINBRD,16.0); RAddtext("Limits")
    for i=0,i<7,i++ do                 // For all resistances
      RCell(RTF_CENTERED|RTF_THINBRD,17.0)
      RAddfmt("%g\n%s",rexp[i]*(rexp[i]<1.0?1000:1),rexp[i]<1.0?"mOhm":"Ohm")
      if logmode==2 && rexp[i]<1.0 then
        RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("*")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
      endif
    enddo
    RCell(RTF_CENTERED|RTF_THINBRD,12.0)
    RAddtext("Bad/\nnoct")
    for j=0,j<nfing*2,j++ do           // For all heads
      if inuse[j]==0 continue
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,12.0)
      RCell(RTF_CENTERED|RTF_THINBRD,12.0)
      RFmt(RTF_TIMES,RTF_NORMAL,5); RAddtext("\n")
      RFmt(RTF_TIMES,RTF_NORMAL,9);
      RAddfmt("%i\n(%i%c)",j,j/2,(j & 1)?'R':'L')
      RCell(RTF_RIGHT|RTF_THINBRD,16.0)
      if logmode==0 then
        RAddtext("Mean \nRmin \nRmax ")
      else
        RAddtext("Mean \nDiff min \nDiff max ")
      endif
      RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("\ns ")
      for i=0,i<7,i++ do               // For all resistances
        q=nogood[i,j]
        RCell(RTF_CENTERED|RTF_THINBRD,17.0)
        if Getcount(rmeas[i,j])==0 then
          RAddtext("\n-")
        else
          r=rexp[i]; factor=(r<1.0?1000.0:1.0)
          RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
          RAddfmt("%.4g\n",Getmean(rmeas[i,j])*factor)
          if logmode==1 then           // Differences
            RAddfmt("%+.2g\n%+.2g",(Getmin(rmeas[i,j])-r)*factor,              \
            (Getmax(rmeas[i,j])-r)*factor)
          else if logmode==2 && r<1.0 then // Low diffs
            RAddfmt("%+.2g",(Getmin(rmeas[i,j])-r)*factor)
            RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
            RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
            RAddfmt("\n%+.2g",(Getmax(rmeas[i,j])-r)*factor)
            RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
            RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
          else if logmode==2 then      // Percentages
            percent=(Getmin(rmeas[i,j])-r)/r*100.0
            if percent>99.0 then RAddtext("> 99%\n");
            else if percent<(-99.0) then RAddtext("<-99%\n");
            else RAddfmt("%+.2g%%\n",percent); endif
            percent=(Getmax(rmeas[i,j])-r)/r*100.0
            if percent>99.0 then RAddtext("> 99%");
            else if percent<(-99.0) then RAddtext("<-99%");
            else RAddfmt("%+.2g%%",percent); endif
          else                         // Absolute values
            RAddfmt("%.4g\n%.4g",Getmin(rmeas[i,j])*factor,                    \
            Getmax(rmeas[i,j])*factor)
          endif
          if Getcount(rmeas[i,j])>=3 then
            RAddfmt("\n%.3g",Getsigma(rmeas[i,j])*factor)
          endif
        endif
      enddo
      RCell(RTF_CENTERED|RTF_THINBRD,12.0)
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RAddfmt("%i\n%i",badhead[j],noconthead[j])
    enddo
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,24.0)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0);
    RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("\n\nAll\nheads")
    RCell(RTF_RIGHT|RTF_THINBRD,16.0);
    if logmode==0 then
      RAddtext("Mean \nRmin \nRmax ")
    else
      RAddtext("Mean \nDiff min \nDiff max ")
    endif
    RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("\ns ")
    RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("\nBad \nNo cont \nPassed ")
    totalbad=0; totalnocont=0
    for i=0,i<7,i++ do                 // For all resistances
      q=(nogood[i,32]>maxfailed)
      RCell(RTF_CENTERED|RTF_THINBRD,17.0)
      RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
      r=rexp[i]; factor=(r<1.0?1000.0:1.0)
      RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
      RAddfmt("%.4g\n",Getmean(rmeas[i,32])*factor)
      if logmode==1 then           // Differences
        RAddfmt("%+.2g\n%+.2g",(Getmin(rmeas[i,32])-r)*factor,                 \
        (Getmax(rmeas[i,32])-r)*factor)
      else if logmode==2 && r<1.0 then // Low diffs
        RAddfmt("%+.2g",(Getmin(rmeas[i,32])-r)*factor)
        RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
        RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
        RAddfmt("\n%+.2g",(Getmax(rmeas[i,32])-r)*factor)
        RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
        RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
      else if logmode==2 then      // Percentages
        percent=(Getmin(rmeas[i,32])-r)/r*100.0
        if percent>99.0 then RAddtext("> 99%\n");
        else if percent<(-99.0) then RAddtext("<-99%\n");
        else RAddfmt("%+.2g%%\n",percent); endif
        percent=(Getmax(rmeas[i,32])-r)/r*100.0
        if percent>99.0 then RAddtext("> 99%");
        else if percent<(-99.0) then RAddtext("<-99%");
        else RAddfmt("%+.2g%%",percent); endif
      else                         // Absolute values
        RAddfmt("%.4g\n%.4g",Getmin(rmeas[i,32])*factor,                       \
        Getmax(rmeas[i,32])*factor)
      endif
      if Getcount(rmeas[i,32])>=3 then
        RAddfmt("\n%.3g",Getsigma(rmeas[i,32])*factor)
      else
        RAddtext("\n")
      endif
      RAddfmt("\n%i\n%i\n%s",badr[i],nocontr[i],                                \
        nogood[i,32]>maxfailed?"No":"Yes")
      totalbad=totalbad+badr[i]
      totalnocont=totalnocont+nocontr[i]
    enddo
    RCell(RTF_CENTERED|RTF_THINBRD,12.0)
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RAddfmt("\n\n\n\n%i\n%i",totalbad,totalnocont)
    RFmt(RTF_TIMES,RTF_BOLD,9)
    RAddfmt("\n%s",summary==0?"No!":"Yes!")
    REndtable()
    if logmode==2 then
      RParagraph(RTF_FORMAT)
      RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,10); RAddtext("          *")
      RFmt(RTF_TIMES,RTF_ITALIC,10)
      RAddtext(" Differences in Ohms.")
    endif
    Flusherrlist(0,2,0,-1)
  endif
  if err==0 then
    Startexplanation()
    Explain("Comments to the table above: Each of 7 different resistors ")
    Explain("is checked %i times by each finger, giving grand total of ",ntest)
    Explain("%i measurements. Every measurement fingers move ",ntest*7*nused)
    Explain("to the new positions.\nBecause OlliBoard has no ")
    Explain("dedicated low-ohmical components, ests below 1 Ohm use printed ")
    Explain("wires that may differ from head to head. For resistors 1 Ohm ")
    Explain("and above script subtracts the expected resistance of the ")
    Explain("wires. Statistics does not include measurements with bad ")
    Explain("contact or recognized as bad.\n")
    if maxfailed==0 then
      Explain("Test is passed when (a) all measurements are good ")
      Explain("(good contact, stable and reliable result) ")
    else
      Explain("Test is passed if total number of bad measurements for each ")
      Explain("resistance does not exceed %i. Measurement is ",maxfailed)
      Explain("good when (a) contacting is good and result is stable and ")
      Explain("reliable, ")
    endif
    Explain("and (b) maximal difference between measured and expected values ")
    Explain("does not exceed %g%% + %g Ohm. ",relerr*100.0,abserr)
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    Summary(summary,"%s Kelvin measurements",exact?"Exact":"Ordinary")
    return 0
  endif
  change hlist color=LIGHTRED
  add hlist text="Kelvin test interrupted!"
  if err==4 return 1                   // Operator interrupted test
  clear hright
  change hinfo text="Kelvin resistance error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    draw text="???DD?!"
    draw at 6,60 color=BLACK
    draw text="Command sent to tester was recognized as bad. Please check "
    draw text="the main log window. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid resistance "
    draw text="measurement. "
  else if err==5 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Kelvin test or one of the service routines found some "
    draw text="error in internal data structures. Please contact atg. "
  endif
  draw text="Test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

#define NKELVIN        7               // Number of resistors and opens to test

// Tests 4-wire resistance test with Kelvin probes (fourwire=0) or with single
// probes (fourwire!=0) using dedicated area (currently only EL204 and EL304-4).
function int Lowkelvin(int ntest,int certify,int fourwire,int uselim,int log)
  // First symbol: space - no correction; a, b, c, d - pairs of different
  // thickness.
  char meas[NKELVIN][32] = {         \ // List of measurement tasks and values
    " GND1   GND2   0.0000  Short",  \ // Shortcut
    "aGND2   RX0R01 0.0100  10 mOhm",\ // 0.01 Ohm
    "bRX0R01 RX0R1  0.1000  0.1 Ohm",\ // 0.1 Ohm
    "cRX0R1  RX1R   1.0000  1 Ohm",  \ // 1 Ohm
    "dRX1R   RX10R  10.000  10 Ohm", \ // 10 Ohm
    "-R30    GND1   30.000  30 Ohm", \ // 30 Ohm
    "-NOCT1  NOCT2  2.00e8  Open" }    // Full open
  int i,j,q,m,n,t,rail,rail2,nrail,opp,maxfailed,slot,summary,err
  int noct[NKELVIN][33],bad[NKELVIN][17],limit[NKELVIN][17]
  int nogood[NKELVIN][17],inuse[16]
  float r,abserr,relerr,maxerr,abssigma,relsigma,sigmaerr
  float rexp[NKELVIN],percent,delta,dx,dy,factor,lcorr,wlen,umax
  float x,y,x1,y1,x2,y2,rstat[NKELVIN][17][5],wirelength[16]
  char s[512],s1[512],u[512],cmd[32][512]
  handle hinterrupt,hcont
  if ntest==0 ntest=10                 // As in certification
  // Get voltage and resistance limits.
  if uselim then
    i=Getutest(&utestmax,&rtestmax,0)
    if i!=0 return i
    umax=utestmax
  else
    umax=12.0
  endif
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) ||                                 \
    (features & (MF_RLIM|MF_RLIMCRATE))!=(MF_RLIM|MF_RLIMCRATE) then
    umax=12.0                          // Limitations are not supported
  else
    umax=Max(0.1,Min(umax,12.0))
  endif
  if fourwire==0 && ($LAY.probetype & 1)==0 then
    add hlist text=" Kelvin needles are not installed, test not possible"
    add hlist text=""
    if txtok!=0 then
      fprintf(hlog,"\n                             Kelvin measurements\n")
      fprintf(hlog,"\n                      Kelvin needles are not installed.")
      fprintf(hlog,"\n\n\n--------------------------------------")
      fprintf(hlog,"---------------------------------------\n")
    endif
    if rtfok!=0 then
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      RAddtext("\nKelvin measurements")
      RFmt(RTF_TIMES,RTF_NORMAL,12)
      RAddtext("\n\nKelvin needles are not installed.\n")
    endif
    return 0
  else if fourwire!=0 && (($LAY.probetype & 1)!=0 || nused<4) ||               \
    (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8)                                    \
  then
    add hlist text=" Four-wire measurements arte not possible"
    add hlist text=""
    if txtok!=0 then
      fprintf(hlog,"\n                           Four-wire measurements\n   ")
      fprintf(hlog,"\n               Four-wire measurements are not possible.")
      fprintf(hlog,"\n\n\n--------------------------------------")
      fprintf(hlog,"---------------------------------------\n")
    endif
    if rtfok!=0 then
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      RAddtext("\nFour-wire measurements")
      RFmt(RTF_TIMES,RTF_NORMAL,12)
      RAddtext("\n\nFour-wire measurements are not possible.\n")
    endif
    return 0
  endif
repeat:
  nrail=$LAY.nfing
  abserr=DKABS
  relerr=DKFACTOR
  abssigma=DKSABS
  relsigma=DKSIGMA
  if certify==0 then
    maxfailed=0                        // Bad measurements are not allowed
  else
    abserr=abserr*2.0
    relerr=relerr*2.0
    abssigma=abssigma*2.0
    relsigma=relsigma*2.0
    maxfailed=2*ntest*FAILRATE+MAXFAILED
  endif
  clear hright
  change hinfo limits=0,0
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  if fourwire==0 then
    if umax>=10.0 then
      change hinfo text="Kelvin test"
    else
      change hinfo text=format("Kelvin at %g V",umax)
    endif
    Strcpy(s,"KELVIN RESISTANCE TEST")
  else
    if umax>=10.0 then
      change hinfo text="4-wire test"
    else
      change hinfo text=format("4-wire at %g V",umax)
    endif
    Strcpy(s,"4-WIRE RESISTANCE TEST")
  endif
  i=Strlen(s)
  if umax<10.0 then
    i=i+sprintf(s+i," AT %g VOLTS",umax)
  endif
  i=Max(0,24-i/2)
  Memset(s1,' ',i)
  s1[i]='\0'
  add hlist text=format("%s%s",s1,s)
  Addreplaysection("%s",s)
  if has300ma==(-1) then
    add hlist text=""
    add hlist text="WARNING: 300 mA source is absent or damaged!"
  else if ($int4($EXTLAY+496) & HCM_EXRLONG)==0 then
    add hlist text=""
    add hlist text="WARNING: Fast Kelvin measurements in layout!"
  endif
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  if fourwire==0 then
    draw text="Kelvin measurements "
  else
    draw text="4-probe measurements "
  endif
  draw text="detect extremely low resistances (less than 1 milliOhm), "
  draw text="eliminating influence of cables and contacts. "
  draw text=format("Each of %i resistors ranged from 0 Ohm ",NKELVIN-1)
  draw text=format("(shortcut) to %s is tested %i ",meas[NKELVIN-2]+23,2*ntest)
  draw text="times by each rail. Test is successful when maximal difference "
  draw text="betwen measured and expected value does not exceed "
  draw text=format("%g%% + %g mOhm.",relerr*100.0,abserr*1000.0)
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D??4???2a?"
  endc
  add hlist text=""
  add hlist text=" Expected     Mean     Min     Max  Noct Bad Pass"
  add hlist text=""
  Clearoversurface()
  Initerrlist()
  if log then
    if fourwire==0 then
      Strcpy(s,"Kelvin measurements (corrected for resistance of wires):")
    else
      Strcpy(s,"4-wire measurements (corrected for resistance of wires):")
    endif
    if txtok then
      fprintf(hlog,"\n%s\n",s)
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\n%s\n",s)
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  SERV.Cmdimm(32,"EXACTINIT 0,0,0")    // No power/current limitations
  // Isolate pad names and get resistances.
  for slot=0,slot<NKELVIN,slot++ do
    for i=1,i<23,i++ do
      if meas[slot][i]==' ' meas[slot][i]='\0'
    enddo
    err=0
    for j=0,j<NPOINT,j++ do            // Find first pad
      if Strcmp(meas[slot]+1,xname[j])==0 break
    enddo
    if j>=NPOINT then
      err=1; rexp[slot]=0.0
    else
      rexp[slot]=value[j]
    endif
    for j=0,j<NPOINT,j++ do            // Find second pad
      if Strcmp(meas[slot]+8,xname[j])==0 break
    enddo
    if j>=NPOINT then
      err=1
    else
      rexp[slot]=Max(rexp[slot],value[j])
    endif
    if err then                        // Emergency solution
      sscanf(meas[slot]+15,"%f",rexp+slot)
    endif
  enddo
  // Clear data.
  for slot=0,slot<NKELVIN,slot++ do
    for i=0,i<17,i++ do
      Initsigma(rstat[slot,i])
    enddo
  enddo
  Memset(noct,0,Sizeof(noct))
  Memset(bad,0,Sizeof(bad))
  Memset(limit,0,Sizeof(limit))
  Memset(nogood,0,Sizeof(nogood))
  Memset(inuse,0,Sizeof(inuse))
  summary=1
  err=0
  // Main test.
  for slot=0,slot<NKELVIN && err==0,slot++ do
    maxerr=rexp[slot]*relerr+abserr
    sigmaerr=rexp[slot]*relsigma+abssigma
    for n=0,n<ntest && err==0,n=n+2 do // For the number of tests
      // Send commands.
      for rail=0,rail<nrail,rail++ do  // For all rails
        if used[2*rail]==0 continue
        // Especially on the shortcut the resistance strongly depends on the
        // position of the needles. Here I make measurements more reproducible
        // by adjusting randomness and moving heads synchronously.
        if meas[slot][0]==' ' then
          delta=DELTA/5.0
        else if meas[slot][0]=='a' then
          delta=DELTA/2.0
        else
          delta=DELTA
        endif
        dx=Random(delta)+Random(delta)-delta
        dy=Random(delta)+Random(delta)-delta
        lcorr=0.0
        if fourwire==0 then
          // Kelvin measurements. Calculate pad coordinates.
          Convertpad(&x1,&y1,meas[slot]+1,rail*2+0,0.0)
          Convertpad(&x2,&y2,meas[slot]+8,rail*2+1,0.0)
          x1=x1+dx; y1=y1+dy
          x2=x2+dx; y2=y2+dy
          // Send two commands.
          m=sprintf(s,"M %i[%f,%fA20V%iP%iH%f] %i[%f,%fA20V%iP%iH%f] ",        \
            rail*2,x1,y1,strokev,strokep,strokez,                              \
            rail*2+1,x2,y2,strokev,strokep,strokez)
          if umax>=10.0 then
            sprintf(s+m,"E(%i,%i)",rail*2,rail*2+1)
          else
            sprintf(s+m,"E(%i,%i,UMAX=%g)",rail*2,rail*2+1,umax)
          endif
          SERV.Cmdimm(rail*2,s)
          Strcpy(cmd[rail*2],s)
          m=sprintf(s,"M %i[%f,%fA20V%iP%iH%f] %i[%f,%fA20V%iP%iH%f] ",        \
            rail*2,x1,y1,strokev,strokep,strokez,                              \
            rail*2+1,x2,y2,strokev,strokep,strokez)
          if umax>=10.0 then
            sprintf(s+m,"E(%i,%i)",rail*2+1,rail*2)
          else
            sprintf(s+m,"E(%i,%i,UMAX=%g)",rail*2+1,rail*2,umax)
          endif
          SERV.Cmdimm(rail*2+1,s)
          Strcpy(cmd[rail*2+1],s)
          // Calculate length of wires.
          wirelength[rail]=ypos[rail*2]
        else
          // 4-wire measurements. Calculate pad coordinates. If possible, I
          // place fingers on the same pad. Otherwise, I use fingers on the
          // opposite side. Otherwise, I use next or previous rail. Note that
          // we have at least two rails.
          rail2=-1
          if onborder then
            if rail+1<nrail && $LAY.side[rail]==$LAY.side[rail+1] then
              rail2=rail+1             // Rail above
              y1=$LAY.top[rail]/1000.0-1.0-yshift
              y2=$LAY.bottom[rail2]/1000.0+1.0-yshift
            else if rail-1>=0 && $LAY.side[rail]==$LAY.side[rail-1] then
              rail2=rail-1             // Rail below
              y1=$LAY.bottom[rail]/1000.0+1.0-yshift
              y2=$LAY.top[rail2]/1000.0-1.0-yshift
            endif
          endif
          if rail2<0 && testersides==0x3 then
            for i=0,i<nrail,i++ do
              if i==rail continue
              if used[2*i]==0 continue
              if $LAY.side[rail]==$LAY.side[i] continue
              if $LAY.bottom[rail]!=$LAY.bottom[i] continue
              if $LAY.top[rail]!=$LAY.top[i] continue
              rail2=i                  // Rail on the opposite side
              y1=ypos[rail*2]
              y2=ypos[rail2*2]
              // Top and bottom pads are not directly connected. There is some
              // distance between the pads and the througholes. I take it
              // empirically into account by reducing wire lengths by 13.5 mm.
              lcorr=13.5
              break
            enddo
          endif
          if rail2<0 then
            if rail+1<nrail then
              rail2=rail+1             // Next rail
            else
              rail2=rail-1             // Previous rail
            endif
            y1=ypos[rail*2]
            y2=ypos[rail2*2]
          endif
          if used[2*rail]==0 || used[2*rail2]==0 continue
          inuse[rail]=1
          for i=0,i<NPOINT,i++ do
            if Strcmp(meas[slot]+1,xname[i])==0 break
          enddo
          if i>=NPOINT then
            err=3
          else
            x1=xpos[i]
          endif
          for i=0,i<NPOINT,i++ do
            if Strcmp(meas[slot]+8,xname[i])==0 break
          enddo
          if i>=NPOINT then
            err=3
          else
            x2=xpos[i]
          endif
          if err!=0 break
          // Create coordinate part of the command.
          Convert(&x,&y,x1,y1,0.0)
          x=x+dx; y=y+dy
          if Strcmp(meas[slot]+8,"NOCT2")==0 then
            if y<$LAY.yoffset[rail]/1000.0 then
              y=y+5.0
            else
              y=y-5.0
            endif
          endif
          m=sprintf(u,"%i[%.3f,%.3fA20V%iP%iH%g]",                             \
            rail*2+0,x,y,strokev,strokep,strokez)
          Convert(&x,&y,x2,y1,0.0)
          x=x+dx; y=y+dy
          if Strcmp(meas[slot]+8,"NOCT2")==0 then
            if y<$LAY.yoffset[rail]/1000.0 then
              y=y+5.0
            else
              y=y-5.0
            endif
          endif
          m=m+sprintf(u+m," %i[%.3f,%.3fA20V%iP%iH%g]",                        \
            rail*2+1,x,y,strokev,strokep,strokez)
          Convert(&x,&y,x1,y2,0.0)
          x=x+dx; y=y+dy
          if Strcmp(meas[slot]+8,"NOCT2")==0 then
            if y<$LAY.yoffset[rail2]/1000.0 then
              y=y+5.0
            else
              y=y-5.0
            endif
          endif
          m=m+sprintf(u+m," %i[%.3f,%.3fA20V%iP%iH%g]",                        \
            rail2*2+0,x,y,strokev,strokep,strokez)
          Convert(&x,&y,x2,y2,0.0)
          x=x+dx; y=y+dy
          if Strcmp(meas[slot]+8,"NOCT2")==0 then
            if y<$LAY.yoffset[rail2]/1000.0 then
              y=y+5.0
            else
              y=y-5.0
            endif
          endif
          m=m+sprintf(u+m," %i[%.3f,%.3fA20V%iP%iH%g]",                        \
            rail2*2+1,x,y,strokev,strokep,strokez)
          // Send two commands.
          if umax>=10.0 then
            s1[0]='\0'
          else
            sprintf(s1,",UMAX=%g",umax)
          endif
          sprintf(cmd[rail*2],"M %s Q(%i,%i,%i,%i%s)",                         \
            u,rail2*2+0,rail*2+0,rail*2+1,rail2*2+1,s1)
          SERV.Cmdimm(rail*2,cmd[rail*2])
          sprintf(cmd[rail*2+1],"M %s Q(%i,%i,%i,%i%s)",                       \
            u,rail2*2+1,rail*2+1,rail*2+0,rail2*2+0,s1)
          SERV.Cmdimm(rail*2+1,cmd[rail*2+1])
          // Calculate length of wires.
          wirelength[rail]=Min(y1,y2)
        endif
      enddo
      if err!=0 break
      // Wait for answers.
      t=Time()
      while 1 do
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hinterrupt) then
          err=3; break
        endif
        for rail=0,rail<nrail,rail++ do
          if inuse[rail]==0 continue
          if $A[rail*2].length==0 break
          if $A[rail*2+1].length==0 break
        enddo
        if rail>=nrail break           // All answers came
        if Time()-t>10000 then
          err=1; break                 // Timeout 10 seconds
        endif
        wait
      enddo
      if err break
      // Process answers.
      for i=0,i<nrail*2,i++ do
        rail=i/2
        if inuse[rail]==0 continue
        opp=i^1
        if $A[i].answer!=S_MOVE err=2
        r=$A[i].r
        if ($A[i].status & 0x0100) r=r*1.0e-6
        if log then
          if fourwire then
            m=sprintf(s,"  4-wire ")
          else
            m=sprintf(s,"  Kelvin ")
          endif
          if rexp[slot]>1000.0 then
            m=m+sprintf(s+m,"(open),        ")
          else if rexp[slot]<1.0 then
            m=m+sprintf(s+m,"(%6.1f mOhm), ",rexp[slot]*1000.0)
          else
            m=m+sprintf(s+m,"(%7.2f Ohm), ",rexp[slot])
          endif
          m=m+sprintf(s+m,"heads %2i - %2i: ",i,i^1)
          if rexp[slot]<1.0 then
            m=m+sprintf(s+m,"%9.5g mOhm, ",r*1000.0)
          else
            m=m+sprintf(s+m,"%9.5g  Ohm, ",r)
          endif
          sprintf(s+m,"status %04X",$A[i].status)
          lprintf(GREEN,"%s",s)
          if txtok!=0 then
            fprintf(hlog,"%s\n",s)
          endif
          if rtfok!=0 then
            RAddfmt("%s\n",s)
          endif
        endif
        // If different test lines, correct resistance for twice the resistance
        // of the thick 155/250-mm line. Note that GND line is wider than the
        // remaining four (11.8 vs. 9.0 mm on EL204-0 or EL504-1, different
        // widths on EL304-4).
        if meas[slot][0]!=' ' && meas[slot][0]!='-' then
          if boardtype==3 || boardtype==5 then
            if meas[slot][0]=='a' then
              factor=1.0+11.8/9.0
            else
              factor=2.0*11.8/9.0
            endif
          else if boardtype==4 then
            if meas[slot][0]=='a' then
              factor=13.3/13.3+13.3/6.7
            else if meas[slot][0]=='b' then
              factor=13.3/6.7+13.3/8.4
            else if meas[slot][0]=='c' then
              factor=13.3/8.4+13.3/8.4
            else
              factor=13.3/8.4+13.3/9.1
            endif
          else
            factor=2.0                 // Unknown board
          endif
          wlen=wirelength[rail]
          if lcorr<wirelength[rail] wlen=wlen-lcorr
          if romdatavalid then
            r=r-factor*romdata.rlowwire*wlen/rowdist
          else
            r=r-factor*RLINED*wlen
          endif
        endif
        if ($A[i].status & 0x0200)!=0 then
          noct[slot][i]++
          noct[slot][32]++
        endif
        if slot<NKELVIN-1 && ($A[i].status & 0x0200)!=0 then
          Adderr(cmd[i],0,i,"No contact at %s",meas[slot]+23)
          nogood[slot][rail]++; nogood[slot][16]++
        else if slot==NKELVIN-1 && ($A[i].status & 0x0200)==0 then
          Adderr(cmd[i],0,i,"Pin shortcut at %s",meas[slot]+23)
          nogood[slot][rail]++; nogood[slot][16]++
        endif
        if $A[i].status & 0x0400 then
          noct[slot][opp]++
          noct[slot][32]++
        endif
        if slot<NKELVIN-1 && ($A[i].status & 0x0400)!=0 then
          Adderr(cmd[i],0,opp,"No contact at %s",meas[slot]+23)
          nogood[slot][rail]++; nogood[slot][16]++
        else if slot==NKELVIN-1 && ($A[i].status & 0x0400)==0 then
          Adderr(cmd[i],0,opp,"Pin shortcut at %s",meas[slot]+23)
          nogood[slot][rail]++; nogood[slot][16]++
        endif
        if $A[i].status & 0x0600 then
          // No contact.  Note that for Exact R and Quad R nocontact means
          // bad measurement.
        else if $A[i].status & 0x8800 then
          // Bad measurement.
          Adderr(cmd[i],0,i,"Bad measurements at %s",meas[slot]+23)
          bad[slot][rail]++; nogood[slot][rail]++
          bad[slot][16]++; nogood[slot][16]++
        else
          // More or less good measurement.
          Addsigma(rstat[slot][rail],r)
          Addsigma(rstat[slot][16],r)
          if r<rexp[slot]-maxerr || r>rexp[slot]+maxerr then
            limit[slot][rail]++
            limit[slot][16]++
            if slot<NKELVIN-1 then
              if extendederr==0 then
                Adderr(cmd[i],0,i,"Resistance out of limits (%.4g..%.4g Ohm)", \
                rexp[slot]-maxerr,rexp[slot]+maxerr)
              else
                Adderr(cmd[i],0,i,                                             \
                "Resistance %g Ohm out of limits (%.4g..%.4g Ohm)",            \
                r,rexp[slot]-maxerr,rexp[slot]+maxerr)
              endif
              nogood[slot][rail]++; nogood[slot][16]++
            endif
          endif
        endif
      enddo
    enddo
    // Display statistics for currently finished resistor in the list window.
    change hlist color=(nogood[slot,16]>maxfailed?LIGHTRED:BLACK)
    n=sprintf(s," %8.8s ",meas[slot]+23)
    if slot==NKELVIN-1 then
      n=n+sprintf(s+n,"       -       -       -")
    else
      r=Getmean(rstat[slot][16])
      if slot<=2 r=r*1000.0
      n=n+Print8(r,s+n)
      r=Getmin(rstat[slot][16])
      if slot<=2 r=r*1000.0
      n=n+Print8(r,s+n)
      r=Getmax(rstat[slot][16])
      if slot<=2 r=r*1000.0
      n=n+Print8(r,s+n)
    endif
    if nogood[slot,16]>maxfailed summary=0
    if slot<NKELVIN-1 && Getsigma(rstat[slot][16])>sigmaerr then
      Adderr("",0,-1,"Dispersion at %s exceeds %g Ohm",meas[slot]+23,sigmaerr)
      nogood[slot,16]=99999
      summary=0
    endif
    sprintf(s+n,"  %3i %3i  %s",noct[slot][32],bad[slot][16],                  \
      nogood[slot,16]>maxfailed?"No":"Yes")
    add hlist text=s
  enddo
  if err==(-1) return -1               // Operator interrupted test
  if err==0 && summary==0 && certify!=0 then
    if fourwire then
      i=Askrepeat("4-wire resistance measurements")
    else
      i=Askrepeat("Kelvin resistance measurements")
    endif
    if i<0 return -1
    if i==1 goto repeat
  endif
  // Measurements finished. Write results to protocols.
  if err==0 && txtok!=0 then           // Write measured data to .TXT protocol
    fprintf(hlog,"\n                      ")
    if fourwire then
      if umax>=10.0 then
        fprintf(hlog,"      4-wire resistance test\n")
      else
        fprintf(hlog,"4-wire resistance test at %g volt\n",umax)
      endif
    else
      if umax>=10.0 then
        fprintf(hlog,"      Kelvin resistance test\n")
      else
        fprintf(hlog,"4-wire resistance test at %g volt\n",umax)
      endif
    endif
    fprintf(hlog,"\nRail   Limits ")
    for i=0,i<NKELVIN,i++ do           // For all resistances
      if rexp[i]==0.0 then
        fprintf(hlog,"    Short")
      else if rexp[i]>1.0e8 then
        fprintf(hlog,"     Open")
      else
        fprintf(hlog," %8.4g",rexp[i]*(rexp[i]<1.0?1000.0:1.0))
      endif
    enddo
    fprintf(hlog,"\n              ")
    for i=0,i<NKELVIN,i++ do           // For all resistances
      if rexp[i]>1.0e8 then
        fprintf(hlog,"         ")
      else
        fprintf(hlog,"%9s",rexp[i]<1.0?"mOhm":"Ohm")
      endif
    enddo
    for j=0,j<nrail,j++ do             // For all rails
      if inuse[j]==0 continue
      fprintf(hlog,"\n\n %2i      Mean ",j)
      for i=0,i<NKELVIN,i++ do         // For all resistances
        if rexp[i]>1.0e8 then
          fprintf(hlog,"         ")
        else if Getcount(rstat[i,j])==0 then
          fprintf(hlog,"      --")
        else
          fprintf(hlog," %8.4g",Getmean(rstat[i,j])*(rexp[i]<1.0?1000.0:1.0))
        endif
      enddo
      fprintf(hlog,"\n     %s ",logmode==0?"    Rmin":"Diff min")
      for i=0,i<NKELVIN,i++ do
        r=rexp[i]; factor=(r<1.0?1000.0:1.0)
        if rexp[i]>1.0e8 || Getcount(rstat[i,j])==0 then
          fprintf(hlog,"         ")
        else if logmode==1 then        // Differences
          fprintf(hlog," %+8.2g",(Getmin(rstat[i,j])-r)*factor)
        else if logmode==2 && r<1 then // Low diffs
          fprintf(hlog," %+7.2gr",(Getmin(rstat[i,j])-r)*factor)
        else if logmode==2 then        // Percentages
          percent=(Getmin(rstat[i,j])-r)/r*100.0
          if percent>99.0 then fprintf(hlog,"    > 99%%");
          else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
          else fprintf(hlog," %+7.2g%%",percent); endif
        else                           // Absolute values
          fprintf(hlog," %8.4g",Getmin(rstat[i,j])*factor)
        endif
      enddo
      fprintf(hlog,"\n     %s ",logmode==0?"    Rmax":"Diff max")
      for i=0,i<NKELVIN,i++ do
        r=rexp[i]; factor=(r<1.0?1000.0:1.0)
        if rexp[i]>1.0e8 || Getcount(rstat[i,j])==0 then
          fprintf(hlog,"         ")
        else if logmode==1 then        // Differences
          fprintf(hlog," %+8.2g",(Getmax(rstat[i,j])-r)*factor)
        else if logmode==2 && r<1 then // Low diffs
          fprintf(hlog," %+7.2gr",(Getmax(rstat[i,j])-r)*factor)
        else if logmode==2 then        // Percentages
          percent=(Getmax(rstat[i,j])-r)/r*100.0
          if percent>99.0 then fprintf(hlog,"    > 99%%");
          else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
          else fprintf(hlog," %+7.2g%%",percent); endif
        else                           // Absolute values
          fprintf(hlog," %8.4g",Getmax(rstat[i,j])*factor)
        endif
      enddo
      fprintf(hlog,"\n        Sigma ")
      for i=0,i<NKELVIN,i++ do
        factor=(rexp[i]<1.0?1000.0:1.0)
        if rexp[i]>1.0e8 || Getcount(rstat[i,j])==0 then
          fprintf(hlog,"         ")
        else
          fprintf(hlog," %8.3g",Getsigma(rstat[i,j])*factor)
        endif
      enddo
      fprintf(hlog,"\n     NoCont L ")
      for i=0,i<NKELVIN,i++ do
        fprintf(hlog," %8i",noct[i,j*2])
      enddo
      fprintf(hlog,"\n     NoCont R ")
      for i=0,i<NKELVIN,i++ do
        fprintf(hlog," %8i",noct[i,j*2+1])
      enddo
      fprintf(hlog,"\n          Bad ")
      for i=0,i<NKELVIN,i++ do
        if rexp[i]>1.0e8 then
          fprintf(hlog,"         ")
        else
          fprintf(hlog," %8i",bad[i,j])
        endif
      enddo
      fprintf(hlog,"\n")
    enddo
    fprintf(hlog,"\n All     Mean ")
    for i=0,i<NKELVIN,i++ do           // For all resistances
      if rexp[i]>1.0e8 then
        fprintf(hlog,"         ")
      else if Getcount(rstat[i,16])==0 then
        fprintf(hlog,"      --")
      else
        fprintf(hlog," %8.4g",Getmean(rstat[i,16])*(rexp[i]<1.0?1000.0:1.0))
      endif
    enddo
    fprintf(hlog,"\n     %s ",logmode==0?"    Rmin":"Diff min")
    for i=0,i<NKELVIN,i++ do
      r=rexp[i]; factor=(r<1.0?1000.0:1.0)
      if rexp[i]>1.0e8 || Getcount(rstat[i,16])==0 then
        fprintf(hlog,"         ")
      else if logmode==1 then          // Differences
        fprintf(hlog," %+8.2g",(Getmin(rstat[i,16])-r)*factor)
      else if logmode==2 && r<1 then   // Low diffs
        fprintf(hlog," %+7.2gr",(Getmin(rstat[i,16])-r)*factor)
      else if logmode==2 then          // Percentages
        percent=(Getmin(rstat[i,16])-r)/r*100.0
        if percent>99.0 then fprintf(hlog,"    > 99%%");
        else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
        else fprintf(hlog," %+7.2g%%",percent); endif
      else                             // Absolute values
        fprintf(hlog," %8.4g",Getmin(rstat[i,16])*factor)
      endif
    enddo
    fprintf(hlog,"\n     %s ",logmode==0?"    Rmax":"Diff max")
    for i=0,i<NKELVIN,i++ do
      r=rexp[i]; factor=(r<1.0?1000.0:1.0)
      if rexp[i]>1.0e8 || Getcount(rstat[i,16])==0 then
        fprintf(hlog,"         ")
      else if logmode==1 then          // Differences
        fprintf(hlog," %+8.2g",(Getmax(rstat[i,16])-r)*factor)
      else if logmode==2 && r<1 then   // Low diffs
        fprintf(hlog," %+7.2gr",(Getmax(rstat[i,16])-r)*factor)
      else if logmode==2 then          // Percentages
        percent=(Getmax(rstat[i,16])-r)/r*100.0
        if percent>99.0 then fprintf(hlog,"    > 99%%");
        else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
        else fprintf(hlog," %+7.2g%%",percent); endif
      else                             // Absolute values
        fprintf(hlog," %8.4g",Getmax(rstat[i,16])*factor)
      endif
    enddo
    fprintf(hlog,"\n        Sigma ")
    for i=0,i<NKELVIN,i++ do
      factor=(rexp[i]<1.0?1000.0:1.0)
      if rexp[i]>1.0e8 || Getcount(rstat[i,16])==0 then
        fprintf(hlog,"         ")
      else
        fprintf(hlog," %8.3g",Getsigma(rstat[i,16])*factor)
      endif
    enddo
    fprintf(hlog,"\n       NoCont ")
    for i=0,i<NKELVIN,i++ do
      fprintf(hlog," %8i",noct[i,32])
    enddo
    fprintf(hlog,"\n          Bad ")
    for i=0,i<NKELVIN,i++ do
      if rexp[i]>1.0e8 then
        fprintf(hlog,"         ")
      else
        fprintf(hlog," %8i",bad[i,16])
      endif
    enddo
    fprintf(hlog,"\n Passed       ")
    for i=0,i<NKELVIN,i++ do
      fprintf(hlog,"      %s",nogood[i,16]>maxfailed?" No":"Yes")
    enddo
    fprintf(hlog,"\n")
    if logmode==2 then
      fprintf(hlog,"\nLetter 'r' means difference in Ohms")
    endif
    Flusherrlist(0,1,0,-1)
    fprintf(hlog,"\n\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  if err==0 && rtfok!=0 then           // Write measured data to .RTF protocol
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    if fourwire then
      if umax>=10.0 then
        RAddtext("\n4-wire resistance test")
      else
        RAddfmt("\n4-wire resistance test at %g volt",umax)
      endif
    else
      if umax>=10.0 then
        RAddtext("\nKelvin resistance test")
      else
        RAddfmt("\nKelvin resistance test at %g volt",umax)
      endif
    endif
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,8.0)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Rail")
    RCell(RTF_CENTERED|RTF_THINBRD,17.5); RAddtext("Limits")
    for i=0,i<NKELVIN,i++ do           // For all resistances
      RCell(RTF_CENTERED|RTF_THINBRD,18.5)
      if rexp[i]==0.0 then
        RAddtext("Short")
        if logmode==2 && rexp[i]<1.0 then
          RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("*")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
        RAddtext("\nmOhm")
      else if rexp[i]>1.0e8 then
        RAddtext("Open")
      else
        RAddfmt("%g\n%s",rexp[i]*(rexp[i]<1.0?1000:1),rexp[i]<1.0?"mOhm":"Ohm")
        if logmode==2 && rexp[i]<1.0 then
          RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("*")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
      endif
    enddo
    for j=0,j<nrail,j++ do             // For all rails
      if inuse[j]==0 continue
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,12.0)
      RCell(RTF_CENTERED|RTF_THINBRD,12.0)
      RFmt(RTF_TIMES,RTF_NORMAL,5); RAddtext("\n")
      RFmt(RTF_TIMES,RTF_NORMAL,9);
      RAddfmt("%i",j)
      RCell(RTF_RIGHT|RTF_THINBRD,17.5)
      if logmode==0 then
        RAddtext("Mean \nRmin \nRmax ")
      else
        RAddtext("Mean \nDiff min \nDiff max ")
      endif
      RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("\ns ")
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RAddtext("\nNo cont L \nNo cont R \nBad ")
      for i=0,i<NKELVIN,i++ do         // For all resistances
        q=nogood[i,j]
        RCell(RTF_CENTERED|RTF_THINBRD,18.5)
        if rexp[i]>1.0e8 then
          RAddtext("\n\n\n")
        else if Getcount(rstat[i,j])==0 then
          RAddtext("\n-\n\n")
        else
          r=rexp[i]; factor=(r<1.0?1000.0:1.0)
          RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
          RAddfmt("%.4g\n",Getmean(rstat[i,j])*factor)
          if logmode==1 then           // Differences
            RAddfmt("%+.2g\n%+.2g",(Getmin(rstat[i,j])-r)*factor,              \
            (Getmax(rstat[i,j])-r)*factor)
          else if logmode==2 && r<1.0 then // Low diffs
            RAddfmt("%+.2gm",(Getmin(rstat[i,j])-r)*factor)
            RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
            RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
            RAddfmt("\n%+.2gm",(Getmax(rstat[i,j])-r)*factor)
            RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
            RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
          else if logmode==2 then      // Percentages
            percent=(Getmin(rstat[i,j])-r)/r*100.0
            if percent>99.0 then RAddtext("> 99%\n");
            else if percent<(-99.0) then RAddtext("<-99%\n");
            else RAddfmt("%+.2g%%\n",percent); endif
            percent=(Getmax(rstat[i,j])-r)/r*100.0
            if percent>99.0 then RAddtext("> 99%");
            else if percent<(-99.0) then RAddtext("<-99%");
            else RAddfmt("%+.2g%%",percent); endif
          else                         // Absolute values
            RAddfmt("%.4g\n%.4g",Getmin(rstat[i,j])*factor,                    \
            Getmax(rstat[i,j])*factor)
          endif
          RAddfmt("\n%.3g",Getsigma(rstat[i,j])*factor)
        endif
        RAddfmt("\n%i\n%i",noct[i,j*2],noct[i,j*2+1])
        if rexp[i]<1.0e8 then
          RAddfmt("\n%i",bad[i,j])
        endif
      enddo
    enddo
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,24.0)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0);
    RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("\n\nAll\nheads")
    RCell(RTF_RIGHT|RTF_THINBRD,17.5);
    if logmode==0 then
      RAddtext("Mean \nRmin \nRmax ")
    else
      RAddtext("Mean \nDiff min \nDiff max ")
    endif
    RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("\ns ")
    RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("\nNo cont \nBad \nPassed ")
    for i=0,i<NKELVIN,i++ do           // For all resistances
      q=(nogood[i,16]>maxfailed)
      RCell(RTF_CENTERED|RTF_THINBRD,18.5)
      RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
      if rexp[i]>1.0e8 then
        RAddtext("\n\n\n")
      else if Getcount(rstat[i,16])==0 then
        RAddtext("\n-\n\n")
      else
        r=rexp[i]; factor=(r<1.0?1000.0:1.0)
        RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
        RAddfmt("%.4g\n",Getmean(rstat[i,16])*factor)
        if logmode==1 then             // Differences
          RAddfmt("%+.2g\n%+.2g",(Getmin(rstat[i,16])-r)*factor,               \
          (Getmax(rstat[i,16])-r)*factor)
        else if logmode==2 && r<1.0 then // Low diffs
          RAddfmt("%+.2gm",(Getmin(rstat[i,16])-r)*factor)
          RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
          RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
          RAddfmt("\n%+.2gm",(Getmax(rstat[i,16])-r)*factor)
          RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
          RFmt(RTF_TIMES,q?RTF_BOLD:RTF_NORMAL,9)
        else if logmode==2 then        // Percentages
          percent=(Getmin(rstat[i,16])-r)/r*100.0
          if percent>99.0 then RAddtext("> 99%\n");
          else if percent<(-99.0) then RAddtext("<-99%\n");
          else RAddfmt("%+.2g%%\n",percent); endif
          percent=(Getmax(rstat[i,16])-r)/r*100.0
          if percent>99.0 then RAddtext("> 99%");
          else if percent<(-99.0) then RAddtext("<-99%");
          else RAddfmt("%+.2g%%",percent); endif
        else                           // Absolute values
          RAddfmt("%.4g\n%.4g",Getmin(rstat[i,16])*factor,                     \
          Getmax(rstat[i,16])*factor)
        endif
        RAddfmt("\n%.3g",Getsigma(rstat[i,16])*factor)
      endif
      RAddfmt("\n%i",noct[i,32])
      if rexp[i]<1.0e8 then
        RAddfmt("\n%i",bad[i,16])
      else
        RAddtext("\n")
      endif
      RAddfmt("\n%s",nogood[i,16]>maxfailed?" No":"Yes")
    enddo
    REndtable()
    if logmode==2 then
      RParagraph(RTF_FORMAT)
      RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,10); RAddtext("          *")
      RFmt(RTF_TIMES,RTF_ITALIC,10)
      RAddtext(" Differences in milliOhms.")
    endif
    Flusherrlist(0,2,0,-1)
  endif
  if err==0 then
    Startexplanation()
    Explain("Comments to the table above: ")
    if fourwire then
      Explain("4-wire resistance test is a substitution for Kelvin needles. ")
      Explain("It uses 4 needles and allows to measure resistances in the ")
      Explain("milliOhm range.\n")
    endif
    if umax<10.0 then
      Explain("Measurements use reduced voltage (%g V). ",umax)
    endif
    Explain("Each of %i different resistors ",NKELVIN-1)
    Explain("and one open/nocontact are measured %i times ",ntest*2)
    Explain("by each rail, giving grand total of %i ",ntest*NKELVIN*nused)
    Explain("measurements. Mean values and deviations do not include ")
    Explain("measurements with bad contact or those recognized as bad. ")
    if maxfailed==0 then
      Explain("Test is passed when (a) all measurements are good ")
      Explain("(good contact, stable and reliable result) ")
    else
      Explain("Test is passed if total number of bad measurements for each ")
      Explain("resistance does not exceed %i. Measurement is ",maxfailed)
      Explain("good when (a) contacting is good and result is stable and ")
      Explain("reliable, ")
    endif
    Explain("(b) maximal difference between measured and expected values ")
    Explain("does not exceed %g%% + %g Ohm, and (c) ",relerr*100.0,abserr)
    Explain("normal dispersion of measurements (sigma) for each resistor ")
    Explain("does not exceed %g%% + %g Ohm.",relsigma*100.0,abssigma)
    if has300ma==(-1) then
      Explain("\nATTENTION, 300 mA source on the measurement card is absent, ")
      Explain("damaged or deactivated. This significantly reduces the ")
      Explain("accuracy of %s measurements!",fourwire?"4-wire":"Kelvin")
    else if ($int4($EXTLAY+496) & HCM_EXRLONG)==0 then
      Explain("\nATTENTION, flag \"Long EXACTR with 300 mA source\" in ")
      Explain("layout is not set. This reduces the accuracy of ")
      Explain("%s measurements (but makes them ",fourwire?"4-wire":"Kelvin")
      Explain("much faster).")
    endif
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    if fourwire then
      Summary(summary,"4-wire resistance test")
    else
      Summary(summary,"Kelvin resistance test")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  if fourwire then
    add hlist text="4-wire test interrupted!"
  else
    add hlist text="Kelvin test interrupted!"
  endif
  if err==3 return 1                   // Operator interrupted test
  clear hright
  if fourwire then
    change hinfo text="4-wire resistance error"
  else
    change hinfo text="Kelvin resistance error"
  endif
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid resistance "
    draw text="measurement. "
  else if err==3 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Script was unable to select pads on the OlliBoard for "
    draw text="4-wire measurement. "
  endif
  draw text="Test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Checks resistance measurements with capacitor connected in parallel.
// Parameter umax and rreport are not yet implemented!
function int RCtest(int ntest,int exact,int uselim,float rreport,              \
  int certify,int log)
  char res[8][8]= {                  \ // Pads with resistors
    "R294",                          \ // 294 Ohms
    "R2K94",                         \ // 2.94 K
    "R29K4",                         \ // 29.4 K
    "R88K7",                         \ // 88.7 K
    "R978K",                         \ // 978 K
    "R10M",                          \ // 10.0 M
    "R100M",                         \ // 100 M
    "" };
  char cap[5][8]= {                  \ // Pads with capacitors
    "C2N7",                          \ // Capacitor 2.7 nF
    "C22N",                          \ // Capacitor 22 nF
    "C220N",                         \ // Capacitor 220 nF
    "C2U2",                          \ // Capacitor 2.2 uF
    "" };
  int i,j,k,ka,kr,kc,m,n,nr,nc,pr,pc,q,t,head,maxfailed,multitab,err
  int zheadtype,rfailed[33,8,5],rbad[33,8,5],nbad,units[8],inuse[32]
  float x,y,xa,ya,xr,yr,xc,yc,umax,percent
  float r,f,rexp[8],factor[8],fr,cexp[5],fc
  float cerr,limitmin,limitmax,rabslo,eabslo,rfactorlo,efactorlo
  float rc[33,8,5,5]                   // Head, R, C, stat
  char s[256],s1[256],cmd[256],suffix[32]
  handle hinterrupt,hcont
  if nused<4 return 0                  // Test requires at least 3 fingers
  if ntest==0 ntest=5                  // As in certification
  if ntest>32 ntest=32                 // Limited by number of buffers
  // Get voltage limits.
  if uselim then
    i=Getutest(&utestmax,&rtestmax,0)
    if i!=0 return i
    umax=utestmax
  else
    umax=12.0
  endif
  zheadtype=$EXTLAY.zheadtype
  if certify==0 then
    rabslo=RABSLO                      // Strict conditions
    eabslo=EABSLO
    maxfailed=0
  else
    if softtouch then
      rabslo=RABSLO*3.0                // Soft touch needles are unreliable
      eabslo=EABSLO*3.0
    else
      rabslo=RABSLO*2.0                // Certification, don't be too strict
      eabslo=EABSLO*2.0
    endif
    maxfailed=ntest*FAILRATE*2.0+MAXFAILED
  endif
  if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||           \
    testertype==TT_A2H || testertype==TT_A3 || testertype==TT_A3L ||           \
    testertype==TT_A4                                                          \
  then
    rfactorlo=RFACTORLO*1.5
    efactorlo=EFACTORLO*1.5
  else
    rfactorlo=RFACTORLO
    efactorlo=EFACTORLO
  endif
repeat:
  clear hright
  change hinfo limits=0,0
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  if exact then
    if umax>=10.0 then
      change hinfo text="??? R||C 2a?"
    else
      change hinfo text=format("Exact R||C at %g V",umax)
    endif
    Strcpy(s,"EXACT R||C TEST")
  else
    if umax>=10.0 then
      change hinfo text="?? R||C 2a?"
    else
      change hinfo text=format("Ordinary R||C at %g V",umax)
    endif
    Strcpy(s,"ORDINARY R||C TEST")
  endif
  i=Strlen(s)
  if umax<10.0 then
    i=i+sprintf(s+i," AT %g VOLTS",umax)
  endif
  i=Max(0,24-i/2)
  Memset(s1,' ',i)
  s1[i]='\0'
  add hlist text=format("%s%s",s1,s)
  add hlist text=""
  Addreplaysection("%s",s)
  for nr=0,res[nr][0]!='\0',nr++ do; enddo
  for nc=0,cap[nc][0]!='\0',nc++ do; enddo
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="???2?PCB??D???Y(Do3?1y1uF)"
  draw text="?????D.?a??2a???a???????,"
  draw text="??D??????,?aD??Y?,"
  draw text="??D???D????a????D|,??"
  draw text="???T???????????."
  draw text=""
  if umax<10.0 then
    draw text=format(" Measurements use reduced voltage (%g V). ",umax)
  endif
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D??R||C2a?"
  endc
  add hlist text="     R      C     Mean   Minimal   Maximal   Pass"
  for n=0,n<ntest,n++ do
    SYS.Killimm(n)                     // Remove all pending commands
  enddo
  Clearoversurface()
  Initerrlist()
  if log then
    i=sprintf(s,"R||C measurements")
    if umax<10.0 i=i+sprintf(s+i,", U=%g V",umax)
    if txtok then
      fprintf(hlog,"\n%s:\n",s)
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\n%s:\n",s)
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  err=0
  Memset(inuse,0,Sizeof(inuse))
  Memset(rc,0,Sizeof(rc))
  Memset(rfailed,0,Sizeof(rfailed))
  Memset(rbad,0,Sizeof(rbad))
  for i=0,i<nr,i++ do                  // For all resistor values
    add hlist text=""
    for k=0,k<NPOINT && xname[k][0]!='\0',k++ do
      if Strcmp(res[i],xname[k])==0 then
        rexp[i]=value[k]; break        // Resistor found
      endif
    enddo
    // Limit certification of R||C to resistances under 10 MOhm.
    if (certify!=0 || (romdata.features & BF_TYPE)==BF_TRIPOD) &&              \
      rexp[i]>1.0e7                                                            \
    then
      nr=i; break
    endif
    if rexp[i]>1000000.0 then pr=2; fr=1000000.0;
    else if rexp[i]>1000.0 then pr=1; fr=1000.0;
    else pr=0; fr=1.0; endif
    if xname[k][0]=='\0' err=1
    for j=0,j<nc,j++ do                // For all capacitor values
      for k=0,xname[k][0]!='\0',k++ do // Find capacitor value
        if Strcmp(cap[j],xname[k])==0 then
          cexp[j]=value[k]; break      // In picofarades
        endif
      enddo
      if cexp[j]>1000000.0 then pc=2; fc=1000000.0;
      else if cexp[j]>1000.0 then pc=1; fc=1000.0;
      else pc=0; fc=1.0; endif
      if xname[k][0]=='\0' err=1
      change hinfo limits=i*nc+j,nr*nc
      if exact then
        cerr=ECFACTOR*cexp[j]/1.0e6+ECEXTRA
        if certify cerr=cerr*1.5
        limitmin=rexp[i]*(1.0-efactorlo-cerr)-eabslo
        limitmax=rexp[i]*(1.0+efactorlo+cerr)+eabslo
        if rexp[i]>ETHRESHOLD then
          limitmin=limitmin-(rexp[i]-ETHRESHOLD)*EFACTORHI
          limitmax=limitmax+(rexp[i]-ETHRESHOLD)*EFACTORHI
        endif
      else
        cerr=RCFACTOR*cexp[j]/1.0e6+RCEXTRA
        if certify cerr=cerr*1.5
        limitmin=rexp[i]*(1.0-rfactorlo-cerr)-rabslo
        limitmax=rexp[i]*(1.0+rfactorlo+cerr)+rabslo
        if rexp[i]>RTHRESHOLD then
          limitmin=limitmin-(rexp[i]-RTHRESHOLD)*RFACTORHI
          limitmax=limitmax+(rexp[i]-RTHRESHOLD)*RFACTORHI
        endif
      endif
      if rexp[i]>5.0e7 && cexp[j]>1.0e6 then
        limitmin=limitmin-1.0e7        // Extra margins for 100 M || 2.2 uF
        limitmax=limitmax+1.0e7
      endif
      if umax<10.0 then
        sprintf(suffix,",UMAX=%g",umax)
      else
        suffix[0]='\0'
      endif
      for k=0,k<$LAY.nfing*2,k++ do    // For all heads
        ka=k^1                         // Opposite finger
        kr=(k & 0x1E)+$LAY.nfing       // Opposite rail
        if kr>=$LAY.nfing*2 kr=kr-$LAY.nfing*2
        kc=kr+1
        if used[k]==0 || used[ka]==0 || used[kr]==0 continue
        inuse[k]=1
        if Convertpad(&x,&y,"GND1",k,DELTA)<0.0 err=1
        if $LAY.rightlimit-$LAY.leftlimit<400000 then
          if Convertpad(&xa,&ya,(ka<k?"L47U":"HV"),ka,0.0)<0.0 err=1
        else
          if Convertpad(&xa,&ya,(ka<k?"RES0":"P3"),ka,0.0)<0.0 err=1
        endif
        if Convertpad(&xr,&yr,res[i],kr,DELTA)<0.0 err=1
        if Convertpad(&xc,&yc,cap[j],kc,DELTA)<0.0 err=1
        n=sprintf(cmd,"M %i[%g,%gA%i] %i[%g,%gA%i] %i[%g,%gA%i] ",             \
          k,x,y,acc,ka,xa,ya,acc,kr,xr,yr,acc)
        sprintf(cmd+n,"%i[%g,%gA%i] %c(%i,%i,%i%s)",                           \
          kc,xc,yc,acc,(exact?'E':'R'),k,kr,kc,suffix)
        for n=0,n<ntest && err==0,n++ do
          if SERV.Cmdimm(n,cmd)<0 err=1// Send all commands at once
        enddo
        for n=0,n<ntest && err==0,n++ do
          t=Time()                     // Wait till all answers come
          while $A[n].length==0 && err==0 do
            if Time()-t>10000+ntest*3000 err=2
            if Pressed(hexit) err=-1
            if Pressed(hinterrupt) err=4
            wait
          enddo
          if (err==0 && $A[n].answer!=S_MOVE) err=3
          if err==0 then
            r=$A[n].r; if ($A[n].status & 0x0100) r=r*1.0e-6
            if ($A[n].status & 0x0800) then
              Adderr(cmd,0,k,"Bad measurements at %g %s, %g %s",               \
                rexp[i]/fr,runitname[pr],cexp[j]/fc,cunitname[pc])
              rbad[k,i,j]++; rfailed[k,i,j]++
              rbad[32,i,j]++; rfailed[32,i,j]++
            else if r<limitmin || r>limitmax then
              if extendederr==0 then
                Adderr(cmd,0,k,"Resistance out of limits at %g %s, %g %s",     \
                rexp[i]/fr,runitname[pr],cexp[j]/fc,cunitname[pc])
              else
                Adderr(cmd,0,k,                                                \
                "Resistance %.4g %s is out of limits %.4g..%.4g %s at %g %s",  \
                r/fr,runitname[pr],limitmin/fr,limitmax/fr,runitname[pr],      \
                cexp[j]/fc,cunitname[pc])
              endif
              rfailed[k,i,j]++
              rfailed[32,i,j]++
            endif
            Addsigma(rc[k,i,j],r)
            Addsigma(rc[32,i,j],r)
            if log then
              if exact then
                m=sprintf(s,"  Exact R||C ")
              else
                m=sprintf(s,"  R||C ")
              endif
              m=m+sprintf(s+m,"(%4.4g %4s,",rexp[i]/fr,runitname[pr])
              m=m+sprintf(s+m,"%4.4g %2s) ",cexp[j]/fc,cunitname[pc])
              m=m+sprintf(s+m,"heads %2i - %2i,%2i: ",k,kr,kc)
              sprintf(s+m,"%8.5g %4s, status %04X",                            \
                r/fr,runitname[pr],$A[n].status)
              lprintf(GREEN,"%s",s)
              if txtok!=0 then
                fprintf(hlog,"%s\n",s)
              endif
              if rtfok!=0 then
                RAddfmt("%s\n",s)
              endif
            endif
          endif
        enddo
        sprintf(s,"M %i[%g,%g] %i[%g,%g] %i[%g,%g] NOP",                       \
          k,x-0.1,y,kr,xr-0.1,yr,kc,xc+0.1,yc)
        if SERV.Cmdimm(32,s)<0 err=1   // Move fingers up
        if err!=0 break
      enddo                            // End of head loop
      if err==0 then
        r=rexp[i]; units[i]=0; factor[i]=1.0
        while Abs(r)>=920.0 && units[i]<3 do
          r=r/1000.0; factor[i]=factor[i]*1000.0; units[i]++
        enddo
        n=sprintf(s,"%5.3g ",r)
        if units[i]==0 n=n+Sprintf(s+n,"r ")
        if units[i]==1 n=n+Sprintf(s+n,"k ")
        if units[i]==2 n=n+Sprintf(s+n,"M ")
        if units[i]==3 n=n+Sprintf(s+n,"G ")
        if cexp[j]<1.0e6 then
          n=n+Sprintf(s+n,"%4.3g n",cexp[j]/1.0e3)
        else
          n=n+Sprintf(s+n,"%4.3g ?",cexp[j]/1.0e6)
        endif
        q=(rfailed[32,i,j]<=maxfailed)
        n=n+sprintf(s+n,"%8.3g %9.3g %9.3g   %s",                              \
          Getmean(rc[32,i,j])/factor[i],Getmin(rc[32,i,j])/factor[i],          \
          Getmax(rc[32,i,j])/factor[i],q?"Yes":"No")
        change hlist color=(q?BLACK:LIGHTRED)
        add hlist text=s
      endif
      if err!=0 break
    enddo                              // End of capacity loop
  enddo                                // End of resistance loop
  if err==(-1) return -1               // Operator interrupted test
  if err==0 then
    t=1
    for j=0,j<nc,j++ do                // For all capacitor values
      for i=0,i<nr,i++ do              // For all resistor values
        if rfailed[32,i,j]>maxfailed t=0
      enddo
    enddo
    sprintf(s,"%s R||C measurements",exact?"Exact":"Ordinary")
    if t==0 && certify!=0 then
      i=Askrepeat(s)
      if i<0 return -1
      if i==1 goto repeat
    endif
    Summary(t,"%s",s)
  endif
  multitab=0
  if err==0 && txtok!=0 then           // Write measured data to TXT protocol
    for head=-1,head<$LAY.nfing*2,head++ do
      if head<0 then
        k=32
      else
        if extendederr==0 continue
        if inuse[head]==0 continue
        n=0
        for j=0,j<nc,j++ do
          for i=0,i<nr,i++ do
            if rfailed[head,i,j] n++
          enddo
        enddo
        if n==0 continue               // Skip head table if good measurements
        multitab=1
        k=head
      endif
      if head<0 then
        if exact then
          n=sprintf(s,"?????Y2a?")
        else
          n=sprintf(s,"????Y2a?")
        endif
      else
        fprintf(hlog,"\n")
        if exact then
          n=sprintf(s,"Bad exact R||C measurements for head %i%s",             \
          head/2,head & 1?"R":"L")
        else
          n=sprintf(s,"Bad ordinary R||C measurements for head %i%s\n",        \
          head/2,head & 1?"R":"L")
        endif
      endif
      for i=0,i<(77-n)/2,i++ do
        s1[i]=' '
      enddo
      s1[i]='\0'
      fprintf(hlog,"\n%s%s\n",s1,s)
      if head<0 && umax<10.0 fprintf(hlog,                                     \
        "                       Test voltage is limited to %g V\n",umax)
      fprintf(hlog,"\nResistance    Limits  -------------- Capacity, nF ----")
      fprintf(hlog,"----------  Bad  Passed")
      fprintf(hlog,"\n                    ")
      for j=0,j<nc,j++ do              // For all capacitor values
        fprintf(hlog,"%11.4g",cexp[j]/1.0e3)
      enddo
      for i=0,i<nr,i++ do              // For all resistor values
        if head>=0 then
          n=0
          for j=0,j<nc,j++ do
            if rfailed[head,i,j] n++
          enddo
          if n==0 continue
        endif
        f=factor[i]; r=rexp[i]
        fprintf(hlog,"\n\n%5.3g %4s      Mean",r/f,runitname[units[i]])
        q=1; nbad=0
        for j=0,j<nc,j++ do            // For all capacitor values
          if rfailed[k,i,j]>maxfailed q=0
          nbad=nbad+rbad[k,i,j]
          if head>=0 && rfailed[k,i,j]==0 then
            fprintf(hlog,"           ")
          else
            fprintf(hlog,"%11.4g",Getmean(rc[k,i,j])/f)
          endif
        enddo
        fprintf(hlog,"%5i     %s",nbad,(q?"Yes":" No"))
        fprintf(hlog,"\n            %s",logmode==0?"    Rmin":"Diff min")
        for j=0,j<nc,j++ do              // For all capacitor values
          if head>=0 && rfailed[k,i,j]==0 then
            fprintf(hlog,"           ")
          else if logmode==1 then      // Differences
            fprintf(hlog,"%+11.3g",(Getmin(rc[k,i,j])-r)/f)
          else if logmode==2 then      // Percentages
            percent=(Getmin(rc[k,i,j])-r)/r*100.0
            if percent>99.0 then fprintf(hlog,"      > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"      <-99%%");
            else fprintf(hlog,"%+10.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%11.4g",Getmin(rc[k,i,j])/f)
          endif
        enddo
        fprintf(hlog,"\n            %s",logmode==0?"    Rmax":"Diff max")
        for j=0,j<nc,j++ do            // For all capacitor values
          if head>=0 && rfailed[k,i,j]==0 then
            fprintf(hlog,"           ")
          else if logmode==1 then      // Differences
            fprintf(hlog,"%+11.3g",(Getmax(rc[k,i,j])-r)/f)
          else if logmode==2 then      // Percentages
            percent=(Getmax(rc[k,i,j])-r)/r*100.0
            if percent>99.0 then fprintf(hlog,"      > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"      <-99%%");
            else fprintf(hlog,"%+10.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%11.4g",Getmax(rc[k,i,j])/f)
          endif
        enddo
        if head>=0 then
          fprintf(hlog,"\n                 Bad")
          for j=0,j<nc,j++ do          // For all capacitor values
            if head>=0 && rfailed[k,i,j]==0 then
              fprintf(hlog,"           ")
            else
              fprintf(hlog,"%11i",rbad[k,i,j])
            endif
          enddo
        endif
      enddo
      if head<0 then
        fprintf(hlog,"\n\n    Passed          ")
        t=1
        for j=0,j<nc,j++ do            // For all capacitor values
          q=1
          for i=0,i<nr,i++ do          // For all resistor values
            if rfailed[32,i,j]>maxfailed then
              q=0; t=0; break
            endif
          enddo
          fprintf(hlog,"        %s",(q==1?"Yes":" No"))
        enddo
        fprintf(hlog,"         %s",(t==1?"YES!":" NO!"))
      endif
      if extendederr==0 && head<0 then
        Flusherrlist(0,1,0,-1)
      else if extendederr!=0 && head>=0 then
        fprintf(hlog,"\n")
        Flusherrlist(0,1,0,head)
      endif
    enddo
    fprintf(hlog,"\n\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  if err==0 && rtfok!=0 then           // Write measured data to RTF protocol
    for head=-1,head<$LAY.nfing*2,head++ do
      if head<0 then
        k=32
      else
        if extendederr==0 continue
        if inuse[head]==0 continue
        n=0
        for j=0,j<nc,j++ do
          for i=0,i<nr,i++ do
            if rfailed[head,i,j] n++
          enddo
        enddo
        if n==0 continue               // Skip head table if good measurements
        multitab=1
        k=head
      endif
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      if head<0 then
        if exact then
          RAddtext("\n?????Y2a?")
        else
          RAddtext("\n????Y2a?")
        endif
      else
        if exact then
          RAddfmt("\nBad exact R||C measurements for head %i%s",               \
          head/2,head & 1?"R":"L")
        else
          RAddfmt("\nBad ordinary R||C measurements for head %i%s",            \
          head/2,head & 1?"R":"L")
        endif
      endif
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      if head<0 && umax<10.0 RAddfmt("\nTest voltage is limited to %g V",umax)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,5.0)
      RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Resistance")
      RCell(RTF_CENTERED|RTF_THINBRD,19.0); RAddtext("Limits")
      for j=0,j<nc,j++ do              // For all capacitor values
        RCell(RTF_CENTERED|RTF_THINBRD,22.0)
        if cexp[j]<1.0e6 then
          RAddfmt("%5.3g nF",cexp[j]/1.0e3)
        else
          RAddfmt("%5.3g ",cexp[j]/1.0e6)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("F")
        endif
      enddo
      RCell(RTF_CENTERED|RTF_THINBRD,15.0); RAddtext("Bad")
      RCell(RTF_CENTERED|RTF_THINBRD,17.0); RAddtext("Passed")
      for i=0,i<nr,i++ do              // For all resistor values
        if head>=0 then
          n=0
          for j=0,j<nc,j++ do
            if rfailed[head,i,j] n++
          enddo
          if n==0 continue
        endif
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        f=factor[i]; r=rexp[i]
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,12.0)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        RAddfmt("\n%.3g %s",r/f,runitname[units[i]])
        RCell(RTF_RIGHT|RTF_THINBRD,19.0)
        RAddtext("Mean \n")
        RAddtext(logmode==0?"Rmin \nRmax ":"Diff min \nDiff max ")
        if head>=0 RAddtext("\nBad ")
        q=1; nbad=0
        for j=0,j<nc,j++ do            // For all capacitor values
          RCell(RTF_CENTERED|RTF_THINBRD,22.0)
          if rfailed[k,i,j]!=0 then
            RFmt(RTF_TIMES,RTF_BOLD,9)
            if rfailed[k,i,j]>maxfailed q=0
          else
            if head>=0 continue
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
          nbad=nbad+rbad[k,i,j]
          if logmode==1 then           // Differences
            RAddfmt("%.4g\n%+.3g\n%+.3g",Getmean(rc[k,i,j])/f,                 \
            (Getmin(rc[k,i,j])-r)/f,(Getmax(rc[k,i,j])-r)/f)
          else if logmode==2 then      // Percentages
            RAddfmt("%.4g\n",Getmean(rc[k,i,j])/f)
            percent=(Getmin(rc[k,i,j])-r)/r*100.0
            if percent>99.0 then RAddtext("> 99%\n");
            else if percent<(-99.0) then RAddtext("<-99%\n");
            else RAddfmt("%+.2g%%\n",percent); endif
            percent=(Getmax(rc[k,i,j])-r)/r*100.0
            if percent>99.0 then RAddtext("> 99%");
            else if percent<(-99.0) then RAddtext("<-99%");
            else RAddfmt("%+.2g%%",percent); endif
          else                         // Absolute values
            RAddfmt("%.4g\n%.4g\n%.4g",Getmean(rc[k,i,j])/f,                   \
            Getmin(rc[k,i,j])/f,Getmax(rc[k,i,j])/f)
          endif
          if head>=0 RAddfmt("\n%i",rbad[k,i,j])
        enddo
        RCell(RTF_CENTERED|RTF_THINBRD,15.0)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddfmt("\n%i",nbad)
        RCell(RTF_CENTERED|RTF_THINBRD,17.0)
        RAddtext(q==1?"\nYes":"\nNo")
      enddo
      if head<0 then
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Passed")
        RCell(RTF_RIGHT|RTF_THINBRD,19.0)
        t=1
        for j=0,j<nc,j++ do            // For all capacitor values
          RCell(RTF_CENTERED|RTF_THINBRD,22.0)
          q=1
          for i=0,i<nr,i++ do          // For all resistor values
            if rfailed[k,i,j]>maxfailed then
              q=0; t=0; break
            endif
          enddo
          RAddtext(q==1?"Yes":"No")
        enddo
        RCell(RTF_CENTERED|RTF_THINBRD,15.0)
        RCell(RTF_CENTERED|RTF_THINBRD,17.0)
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext(t==1?"Yes!":"No!")
      endif
      REndtable()
      if extendederr==0 && head<0 then
        Flusherrlist(0,2,0,-1)
      else if extendederr!=0 && head>=0 then
        Flusherrlist(0,2,0,head)
      endif
    enddo
  endif
  if err==0 then
    Startexplanation()
    if multitab then
      Explain("Comments to the tables above: ")
    else
      Explain("Comments to the table above: ")
    endif
    Explain("Each of %i different R-C combinations is checked ",nr*nc)
    Explain("%i times by each finger, giving grand total of ",ntest)
    Explain("%i measurements. Test ",ntest*nr*nc*nused)
    if maxfailed==0 then
      Explain("is passed when (a) all measurements are good (stable and ")
      Explain("reliable results) ")
    else
      Explain("is passed if there are not more than %i bad ",maxfailed)
      Explain("measurements for each R-C combination. Measurement is ")
      Explain("successfull when (a) result is stable and reliable ")
    endif
    Explain("and (b) maximal difference between measured ")
    Explain("and expected values does not exceed some R- and C-dependent ")
    Explain("limit. This limit is relatively high, mainly because many ")
    Explain("capacitors, including those on OlliBoard, suffer from the ")
    Explain("polarization effects in dielectric.")
    if umax<10.0 then
      Explain("\nMaximal allowed test voltage was limited to %g V. ",umax)
      Explain("This feature reduces test speed but allows to test boards ")
      Explain("with installed components.")
    endif
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  add hlist text="R||C test interrupted!"
  if err==4 return 1                   // Operator interrupted test
  clear hright
  change hinfo limits=0,0
  change hinfo text="R||C ?"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="R||C test found some error in internal data structures. "
    draw text="Please contact atg. "
  else if err==2 then
    draw text="3?!"
    draw at 6,60 color=BLACK
    draw text="???3????D????e. \n"
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid resistance "
    draw text="measurement. "
  endif
  draw text="2a??D??."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Checks field measurements and capacity adjustment. Allowed noise in
// certification mode is higher.
function int Ftest(int ntest,int certify,int log)
  int i,j,k,ko,kg,ka,m,n,t,err,widths,widthc,summary,adjusted,fnoise
  int maxfailed,badfields[33],headbad[32,32],inuse[32]
  float fsin[33][5],fcos[33][5],fc[33][5],zc,zr,ffactor
  float smean,smin,smax,cmean,cmin,cmax,saver,caver
  float msmin,msmax,mcmin,mcmax
  float headcmean[32,32],headcmin[32,32],headcmax[32,32]
  float headsmean[32,32],headsmin[32,32],headsmax[32,32]
  float x,y,xo,yo,xg,yg,xa,ya
  char s[256],cmd[32,256]
  handle hinterrupt,hcont
  if $LAY.nfing<2 return 0             // Test requires at least 3 fingers
  if ntest==0 ntest=16                 // As in certification
  if ntest>32 ntest=32                 // Limited by number of buffers
  if certify==0 then
    fnoise=FNOISE
    maxfailed=0
  else
    fnoise=FNOISECERT
    maxfailed=ntest*FAILRATE*2.0+MAXFAILED
  endif
  if boardtype==5 then
    fnoise=(fnoise+1)/2                // Due to high capacity between nets
  endif
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="?3?2a?"
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  add hlist text="                     FIELD TEST"
  add hlist text=""
  Addreplaysection("FIELD TEST")
  if ($LAY.config & LC_OHTYPE)==LC_NOFIELD then
    add hlist text=" This tester does not support field measurements"
    add hlist text=""
    if txtok!=0 then
      fprintf(hlog,"\n                             Field measurements\n")
      fprintf(hlog,"\n                  This tester does not support ")
      fprintf(hlog,"?3?2a?.\n")
      fprintf(hlog,"\n\n--------------------------------------")
      fprintf(hlog,"---------------------------------------\n")
    endif
    if rtfok!=0 then
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      RAddtext("\n?3?2a?")
      RFmt(RTF_TIMES,RTF_NORMAL,12)
      RAddtext("\n\nThis tester does not support field measurements.\n")
    endif
    return 0
  endif
  add hlist text="Head  -------Sine------   ------Cosine-----  Pass"
  add hlist text="       Mean  dMin  dMax    Mean  dMin  dMax"
  add hlist text=""
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="?a?1yy????2ao????"
  draw text="???DD??????2a?,?D2??D???"
  draw text="????T???. ???y?"
  draw text=format("[%i..%i]",SINMIN,SINMAX)
  draw text="??,"
  draw text="?3??a?t?D??????"
  draw text=format("[%i..%i]",COSMIN,COSMAX)
  draw text="ADC???,2????????2a???"
  draw text=format("?2??3?1y %i ??.",fnoise)
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D???3?2a?"
  endc
  for n=0,n<ntest && err==0,n++ do
    SYS.Killimm(n)                     // Remove all pending commands
  enddo
  if boardtype==5 then
    SERV.Cmdimm(32,"OUTPORT 0x20F0,8") // Set 4 V antenna voltage
  else
    SERV.Cmdimm(32,"OUTPORT 0x20F0,16")// Set 8 V antenna voltage
  endif
  // New versions of embedded software scale field results to default voltage
  // (4 V), and we need to rescale it back.
  if boardtype==5 then
    ffactor=1.0
  else if features & MF_FSCALE then
    ffactor=2.0
  else
    ffactor=1.0
  endif
  Initsigma(fsin[$LAY.nfing*2])
  Initsigma(fcos[$LAY.nfing*2])
  Initsigma(fc[$LAY.nfing*2])
  Clearoversurface()
  Initerrlist()
  Memset(inuse,0,Sizeof(inuse))
  for i=0,i<$LAY.nfing*2,i=i+2 do      // Move all fingers toward PCB
    if used[i]==0 continue
    Convertpad(&x,&y,"GND1",i,DELTA)
    Convertpad(&xo,&yo,"HV",i+1,DELTA)
    sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] NOP",i,x,y,acc,i+1,xo,yo,acc)
    SERV.Cmdimm(32,s)
  enddo
  if log then
    if txtok then
      fprintf(hlog,"\n?3?2a?:\n")
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\n?3?2a?:\n")
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  for k=0,k<$LAY.nfing*2,k++ do        // For all heads
    Initsigma(fsin[k])
    Initsigma(fcos[k])
    Initsigma(fc[k])
    ko=k^1                             // Opposite finger
    kg=(k & 0x1E)+$LAY.nfing           // Opposite rail
    if kg>=$LAY.nfing*2 kg=kg-$LAY.nfing*2
    ka=kg+1                            // Now calculate pad coordinates
    if used[k]==0 || used[kg]==0 || used[ka]==0 continue
    inuse[k]=1
    // Capacities between F1, F2 and F3 lines on the XXL board are very high,
    // in excess of 100 pF, and are no longer suitable to make tests of the
    // field measurements. I use alternative nets.
    if boardtype==5 then
      if Convertpad(&x,&y,"C27P",k,DELTA)<0.0 err=1
      if Convertpad(&xo,&yo,(ko<k?"GND1":"HV"),ko,0.0)<0.0 err=1
      if Convertpad(&xg,&yg,"F1",kg,DELTA)<0.0 err=1
      if Convertpad(&xa,&ya,"C270P",ka,DELTA)<0.0 err=1
    else
      if Convertpad(&x,&y,"F1",k,DELTA)<0.0 err=1
      if Convertpad(&xo,&yo,(ko<k?"GND1":"HV"),ko,0.0)<0.0 err=1
      if Convertpad(&xg,&yg,"GND1",kg,DELTA)<0.0 err=1
      if Convertpad(&xa,&ya,"F2",ka,DELTA)<0.0 err=1
    endif
    j=sprintf(cmd[k],"M %i[%g,%gA%i] %i[%g,%gA%i] %i[%g,%gA%i] %i[%g,%gA%i] ", \
      k,x,y,acc,ko,xo,yo,acc,kg,xg,yg,acc,ka,xa,ya,acc)
    if boardtype==5 then
      j=j+sprintf(cmd[k]+j,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",                 \
      k,ka,kg,kg,kg,kg,kg,kg,kg,kg)
      sprintf(cmd[k]+j,"%i,%i,%i,%i,%i,%i,%i,%i)",                             \
      kg,kg,kg,kg,kg,kg,kg,kg)         // Total of 16 antennae
    else
      j=j+sprintf(cmd[k]+j,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",                 \
      k,kg,ka,ka,ka,ka,ka,ka,ka,ka)
      sprintf(cmd[k]+j,"%i,%i,%i,%i,%i,%i,%i,%i)",                             \
      ka,ka,ka,ka,ka,ka,ka,ka)         // Total of 16 antennae
    endif
    for n=0,n<ntest && err==0,n++ do
      if SERV.Cmdimm(n,cmd[k])<0 err=1 // Send all commands at once
    enddo
    for n=0,n<ntest && err==0,n++ do
      change hinfo limits=k*ntest+n,$LAY.nfing*2*ntest
      t=Time()                         // Wait till all answers come
      while $A[n].length==0 && err==0 do
        if Time()-t>10000 err=2
        if Pressed(hexit) err=-1
        if Pressed(hinterrupt) err=4
        wait
      enddo
      if (err==0 && $A[n].answer!=S_MOVE) err=3
      if err==0 then                   // Answer OK, add to statistics
        smean=0; smin=32767; smax=-32768
        cmean=0; cmin=32767; cmax=-32768
        for j=0,j<16,j++ do
          Addsigma(fsin[k],$int2($A[n]+32+4*j)*ffactor)
          Addsigma(fcos[k],$int2($A[n]+34+4*j)*ffactor)
          Addsigma(fsin[$LAY.nfing*2],$int2($A[n]+32+4*j)*ffactor)
          Addsigma(fcos[$LAY.nfing*2],$int2($A[n]+34+4*j)*ffactor)
          smean=smean+$int2($A[n]+32+4*j)*ffactor
          smin=Min(smin,$int2($A[n]+32+4*j)*ffactor)
          smax=Max(smax,$int2($A[n]+32+4*j)*ffactor)
          cmean=cmean+$int2($A[n]+34+4*j)*ffactor
          cmin=Min(cmin,$int2($A[n]+34+4*j)*ffactor)
          cmax=Max(cmax,$int2($A[n]+34+4*j)*ffactor)
        enddo
        headsmean[k,n]=smean/16.0
        headsmin[k,n]=smin
        headsmax[k,n]=smax
        headcmean[k,n]=cmean/16.0
        headcmin[k,n]=cmin
        headcmax[k,n]=cmax
        SERV.Convertfield($A[n],&zc,&zr)
        Addsigma(fc[k],zc)
        Addsigma(fc[$LAY.nfing*2],zc)
        if log then
          m=sprintf(s,"  Head %2i: ",k)
          m=m+sprintf(s+m,"sin=%7.1f (%5i..%5i), ",smean/16.0,smin,smax)
          m=m+sprintf(s+m,"cos=%7.1f (%5i..%5i), ",cmean/16.0,cmin,cmax)
          sprintf(s+m,"st=%04X",$A[n].status)
          lprintf(GREEN,"%s",s)
          if txtok!=0 then
            fprintf(hlog,"%s\n",s)
          endif
          if rtfok!=0 then
            RAddfmt("%s\n",s)
          endif
        endif
      endif
      if ($A[n].status & 0x1800)!=0 then
        Adderr(cmd[k],0,k,"2???3?")
        badfields[k]++
        badfields[$LAY.nfing*2]++
        headbad[k,n]=1
      else
        headbad[k,n]=0
      endif
      if Pressed(hexit) err=-1
      if Pressed(hinterrupt) err=4
    enddo
    if (k & 1)==0 then
      Convertpad(&x,&y,((k & 1)==0?"GND1":"HV"),k,0.0)
      sprintf(s,"M %i[%g,%gH30] NOP",k,x,y)
      SERV.Cmdimm(32,s)                // Move test finger away from the pad
    else
      Convertpad(&x,&y,"GND1",k & 0xFE,DELTA)
      Convertpad(&xo,&yo,"HV",k | 0x01,DELTA)
      sprintf(s,"M %i[%g,%gH30] %i[%g,%gH30] NOP",                             \
        k & 0xFE,x,y,k | 0x01,xo,yo)
      SERV.Cmdimm(32,s)                // Move fingers in base positions
      Convertpad(&x,&y,"GND1",kg,DELTA)
      Convertpad(&xo,&yo,"HV",ka,DELTA)
      sprintf(s,"M %i[%g,%gH30] %i[%g,%gH30] NOP",                             \
        kg,x,y,ka,xo,yo)
      SERV.Cmdimm(32,s)                // Move fingers in base positions
    endif
    if err!=0 break
    smean=Getmean(fsin[k]); smin=Getmin(fsin[k]); smax=Getmax(fsin[k])
    cmean=Getmean(fcos[k]); cmin=Getmin(fcos[k]); cmax=Getmax(fcos[k])
    j=0
    for n=0,n<ntest,n++ do
      if headsmin[k,n]<SINMIN || headsmax[k,n]>SINMAX then
        if extendederr==0 then
          Adderr(cmd[k],0,k,"Field sine component out of expected limits")
        else if headsmin[k,n]<SINMIN then
          Adderr(cmd[k],0,k,                                                   \
          "Field sine component (%g bits) out of expected limits (%g..%g)",    \
          headsmin[k,n],SINMIN,SINMAX)
        else
          Adderr(cmd[k],0,k,                                                   \
          "Field sine component (%g bits) out of expected limits (%g..%g)",    \
          headsmax[k,n],SINMIN,SINMAX)
        endif
        j++
      else if headcmin[k,n]<COSMIN || headcmax[k,n]>COSMAX then
        if extendederr==0 then
          Adderr(cmd[k],0,k,"Field cosine component out of expected limits")
        else if headcmin[k,n]<COSMIN then
          Adderr(cmd[k],0,k,                                                   \
          "Field cosine component (%g bits) out of expected limits (%g..%g)",  \
          headcmin[k,n],COSMIN,COSMAX)
        else
          Adderr(cmd[k],0,k,                                                   \
          "Field cosine component (%g bits) out of expected limits (%g..%g)",  \
          headcmax[k,n],COSMIN,COSMAX)
        endif
        j++
      else if smean-headsmin[k,n]>fnoise || headsmax[k,n]-smean>fnoise then
        if extendederr==0 then
          Adderr(cmd[k],0,k,"Unstable field sine component")
        else if smean-headsmin[k,n]>fnoise then
          Adderr(cmd[k],0,k,                                                   \
          "Field sine component (%g bits) differs too much from mean (%g..%g)",\
          headsmin[k,n],smean-fnoise,smean+fnoise)
        else
          Adderr(cmd[k],0,k,                                                   \
          "Field sine component (%g bits) differs too much from mean (%g..%g)",\
          headsmax[k,n],smean-fnoise,smean+fnoise)
        endif
        j++
      else if cmean-headcmin[k,n]>fnoise || headcmax[k,n]-cmean>fnoise then
        if extendederr==0 then
          Adderr(cmd[k],0,k,"Unstable field cosine componnet")
        else if cmean-headcmin[k,n]>fnoise then
          Adderr(cmd[k],0,k,                                                   \
          "Field cosine (%g bits) differs too much from mean (%g..%g)",        \
          headcmin[k,n],cmean-fnoise,cmean+fnoise)
        else
          Adderr(cmd[k],0,k,                                                   \
          "Field cosine (%g bits) differs too much from mean (%g..%g)",        \
          headcmax[k,n],cmean-fnoise,cmean+fnoise)
        endif
        j++
      endif
    enddo
    change hlist color=(j<=maxfailed?BLACK:LIGHTRED)
    sprintf(s,"%2i%c  %6i%6i%6i  %6i%6i%6i  %s",                               \
      k/2,(k & 1?'R':'L'),smean,smin-smean,smax-smean,                         \
      cmean,cmin-cmean,cmax-cmean,(j<=maxfailed?"Yes":"No"))
    add hlist text=s
    // If possible, verify full field amplitude and input capacity of the
    // on-head board.
    if boardtype==3 || boardtype==4 || boardtype==5 then

      //---===============---------====-==========-----------======-----========

    endif
  enddo
  // Now check whether input capacities are properly adjusted. This check is
  // more or less meaningless on EL504 due to the badly shielded alternative
  // nets on Olliboard.
  if boardtype!=5 && err==0 then
    smean=Getmean(fsin[$LAY.nfing*2])
    cmean=Getmean(fcos[$LAY.nfing*2])
    adjusted=1
    for k=0,k<$LAY.nfing*2,k++ do      // For all heads
      if inuse[k]==0 continue
      if Abs(Getmean(fsin[k])-smean)>FEQUAL adjusted=0
      if Abs(Getmean(fcos[k])-cmean)>FEQUAL adjusted=0
      if Getmean(fsin[k])<SINMIN || Getmean(fsin[k])>SINMAX adjusted=0
    enddo
    add hlist text=""
    if adjusted then
      change hlist color=BLACK
      add hlist text="Input capacities are correctly aligned"
    else
      change hlist color=LIGHTRED
      add hlist text="Input capacities are NOT aligned!"
    endif
  endif
  if err==(-1) return -1               // Operator interrupted test
  // Get overall success status.
  if err==0 then
    t=1
    saver=Getmean(fsin[$LAY.nfing*2])
    caver=Getmean(fcos[$LAY.nfing*2])
    for k=0,k<$LAY.nfing*2,k++ do      // For all heads
      if inuse[k]==0 continue
      smean=Getmean(fsin[k]); smin=Getmin(fsin[k]); smax=Getmax(fsin[k])
      cmean=Getmean(fcos[k]); cmin=Getmin(fcos[k]); cmax=Getmax(fcos[k])
      j=0
      for n=0,n<ntest,n++ do
        if headsmin[k,n]<SINMIN || headsmax[k,n]>SINMAX ||                     \
        smean-headsmin[k,n]>fnoise || headsmax[k,n]-smean>fnoise ||            \
        headcmin[k,n]<COSMIN || headcmax[k,n]>COSMAX ||                        \
        cmean-headcmin[k,n]>fnoise || headcmax[k,n]-cmean>fnoise ||            \
        (saver!=0.0 && headsmean[k,n]!=0.0 &&                                  \
        Abs(caver/saver-headcmean[k,n]/headsmean[k,n])>FPHASE) ||              \
        headbad[k,n]!=0 j++
      enddo
      if j>maxfailed t=0
    enddo
    if t==0 && certify!=0 then
      i=Askrepeat("?3?2a?")
      if i<0 return -1
      if i==1 goto repeat
    endif
    Summary(t,"?3?2a?")
  endif
  // Write data to protocols.
  if err==0 && txtok!=0 then           // Write measured data to TXT protocol
    fprintf(hlog,"\n                             ?3?2a?\n")
    fprintf(hlog,"\nHead    --------- Sine ---------    ")
    fprintf(hlog," -------- Cosine --------     Bad  Passed")
    fprintf(hlog,"\n         Mean  dMin  dMax  Sigma")
    fprintf(hlog,"      Mean  dMin  dMax  Sigma  fields\n")
    t=0
    msmin=9.0e99; msmax=-9.0e99
    mcmin=9.0e99; mcmax=-9.0e99
    saver=Getmean(fsin[$LAY.nfing*2])
    caver=Getmean(fcos[$LAY.nfing*2])
    for k=0,k<$LAY.nfing*2,k++ do      // For all heads
      if inuse[k]==0 continue
      fprintf(hlog,"\n%3i%c",k/2,(k & 1?'R':'L'))
      smean=Getmean(fsin[k]); smin=Getmin(fsin[k]); smax=Getmax(fsin[k])
      cmean=Getmean(fcos[k]); cmin=Getmin(fcos[k]); cmax=Getmax(fcos[k])
      msmin=Min(msmin,smin-smean)
      msmax=Max(msmax,smax-smean)
      mcmin=Min(mcmin,cmin-cmean)
      mcmax=Max(mcmax,cmax-cmean)
      fprintf(hlog," %8.1f%6i%6i%7.1f ",                                       \
        smean,smin-smean,smax-smean,Getsigma(fsin[k]))
      fprintf(hlog," %8.1f%6i%6i%7.1f %7i",                                    \
        cmean,cmin-cmean,cmax-cmean,Getsigma(fcos[k]),badfields[k])
      j=0
      for n=0,n<ntest,n++ do
        if headsmin[k,n]<SINMIN || headsmax[k,n]>SINMAX ||                     \
        smean-headsmin[k,n]>fnoise || headsmax[k,n]-smean>fnoise ||            \
        headcmin[k,n]<COSMIN || headcmax[k,n]>COSMAX ||                        \
        cmean-headcmin[k,n]>fnoise || headcmax[k,n]-cmean>fnoise ||            \
        (saver!=0.0 && headsmean[k,n]!=0.0 &&                                  \
        Abs(caver/saver-headcmean[k,n]/headsmean[k,n])>FPHASE) ||              \
        headbad[k,n]!=0 j++
      enddo
      fprintf(hlog,"     %s",j<=maxfailed?"Yes":" No")
      if j>maxfailed t=1
    enddo
    fprintf(hlog,"\n\nMean")
    fprintf(hlog," %8.1f%6i%6i        ",saver,msmin,msmax)
    fprintf(hlog," %8.1f%6i%6i        ",caver,mcmin,mcmax)
    fprintf(hlog,"%7i     %s\n",badfields[$LAY.nfing*2],t==0?"Yes":" No")
    if boardtype!=5 then
      fprintf(hlog,"\nInput capacities of on-head boards are %s aligned",      \
      adjusted?"correctly":"NOT")
    endif
    Flusherrlist(0,1,0,-1)
    fprintf(hlog,"\n\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  if err==0 && rtfok!=0 then           // Write measured data to RTF protocol
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddtext("\n?3?2a?")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Head")
    RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("C, pF")
    widths=RCell(RTF_CENTERED|RTF_THINBRD,55.5);
    RAddtext("S i n e")
    widthc=RCell(RTF_CENTERED|RTF_THINBRD,55.5);
    RAddtext("C o s i n e")
    RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddtext("Bad")
    RCell(RTF_CENTERED|RTF_THINBRD,13.0); RAddtext("Passed")
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0)
    widths=widths-RCell(RTF_CENTERED|RTF_THINBRD,17.0); RAddtext("Mean")
    widths=widths-RCell(RTF_CENTERED|RTF_THINBRD,13.0); RAddtext("Min diff")
    widths=widths-RCell(RTF_CENTERED|RTF_THINBRD,13.0); RAddtext("Max diff")
    RCelltwips(RTF_CENTERED|RTF_THINBRD,widths);
    RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("s")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    widthc=widthc-RCell(RTF_CENTERED|RTF_THINBRD,17.0); RAddtext("Mean")
    widthc=widthc-RCell(RTF_CENTERED|RTF_THINBRD,13.0); RAddtext("Min diff")
    widthc=widthc-RCell(RTF_CENTERED|RTF_THINBRD,13.0); RAddtext("Max diff")
    RCelltwips(RTF_CENTERED|RTF_THINBRD,widthc)
    RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("s")
    RCell(RTF_CENTERED|RTF_THINBRD,11.0)
    RCell(RTF_CENTERED|RTF_THINBRD,13.0)
    t=0
    msmin=9.0e99; msmax=-9.0e99
    mcmin=9.0e99; mcmax=-9.0e99
    saver=Getmean(fsin[$LAY.nfing*2])
    caver=Getmean(fcos[$LAY.nfing*2])
    for k=0,k<=$LAY.nfing*2,k++ do     // For all heads and summary
      if inuse[k]==0 continue
      summary=(k==$LAY.nfing*2)
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,12.0)
      smean=Getmean(fsin[k]); smin=Getmin(fsin[k]); smax=Getmax(fsin[k])
      cmean=Getmean(fcos[k]); cmin=Getmin(fcos[k]); cmax=Getmax(fcos[k])
      if summary then
        RAddtext("Mean")
      else
        RAddfmt("%i%c",k/2,(k & 1?'R':'L'))
        msmin=Min(msmin,smin-smean)
        msmax=Max(msmax,smax-smean)
        mcmin=Min(mcmin,cmin-cmean)
        mcmax=Max(mcmax,cmax-cmean)
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,12.0)
      RAddfmt("%.4g",Getmean(fc[k]))
      RCell(RTF_CENTERED|RTF_THINBRD,17.0)
      j=(smin<SINMIN || smax>SINMAX);
      RFmt(RTF_TIMES,j==0?RTF_NORMAL:RTF_BOLD,9); RAddfmt("%.1f",smean)
      RCell(RTF_CENTERED|RTF_THINBRD,13.0)
      j=((summary?-msmin:smean-smin)>fnoise);
      RFmt(RTF_TIMES,j==0?RTF_NORMAL:RTF_BOLD,9)
      RAddfmt("%i",summary?msmin:smin-smean)
      RCell(RTF_CENTERED|RTF_THINBRD,13.0)
      j=((summary?msmax:smax-smean)>fnoise);
      RFmt(RTF_TIMES,j==0?RTF_NORMAL:RTF_BOLD,9)
      RAddfmt("%i",summary?msmax:smax-smean)
      RCelltwips(RTF_CENTERED|RTF_THINBRD,widths)
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      if summary==0 RAddfmt("%.1f",Getsigma(fsin[k]))
      RCell(RTF_CENTERED|RTF_THINBRD,17.0)
      j=(cmin<COSMIN || cmax>COSMAX);
      RFmt(RTF_TIMES,j==0?RTF_NORMAL:RTF_BOLD,9); RAddfmt("%.1f",cmean)
      RCell(RTF_CENTERED|RTF_THINBRD,13.0)
      j=((summary?-mcmin:cmean-cmin)>fnoise);
      RFmt(RTF_TIMES,j==0?RTF_NORMAL:RTF_BOLD,9)
      RAddfmt("%i",summary?mcmin:cmin-cmean)
      RCell(RTF_CENTERED|RTF_THINBRD,13.0)
      j=((summary?mcmax:cmax-cmean)>fnoise);
      RFmt(RTF_TIMES,j==0?RTF_NORMAL:RTF_BOLD,9)
      RAddfmt("%i",summary?mcmax:cmax-cmean)
      RCelltwips(RTF_CENTERED|RTF_THINBRD,widthc)
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      if summary==0 RAddfmt("%.1f",Getsigma(fcos[k]))
      RCell(RTF_CENTERED|RTF_THINBRD,11.0)
      j=(badfields[k]!=0);
      RFmt(RTF_TIMES,j==0?RTF_NORMAL:RTF_BOLD,9)
      RAddfmt("%i",badfields[k])
      RCell(RTF_CENTERED|RTF_THINBRD,13.0)
      j=0
      if summary==0 then
        for n=0,n<ntest,n++ do
          if headsmin[k,n]<SINMIN || headsmax[k,n]>SINMAX ||                   \
          smean-headsmin[k,n]>fnoise || headsmax[k,n]-smean>fnoise ||          \
          headcmin[k,n]<COSMIN || headcmax[k,n]>COSMAX ||                      \
          cmean-headcmin[k,n]>fnoise || headcmax[k,n]-cmean>fnoise ||          \
          (saver!=0.0 && headsmean[k,n]!=0.0 &&                                \
          Abs(caver/saver-headcmean[k,n]/headsmean[k,n])>FPHASE) ||            \
          headbad[k,n]!=0 j++
        enddo
        if j>maxfailed then
          RAddtext("No"); t=1
        else
          RAddtext("Yes")
        endif
      else
        RFmt(RTF_TIMES,RTF_BOLD,9); RAddtext(t==0?"Yes!":"No!")
      endif
    enddo
    REndtable()
    if boardtype!=5 then
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RAddfmt("\n\tInput capacities of on-head boards are %s aligned.",        \
      adjusted?"correctly":"NOT")
    endif
    Flusherrlist(0,2,0,-1)
  endif
  if err==0 then
    Startexplanation()
    Explain("Comments to the table above: Each mean value in the table is an ")
    Explain("average of %i single measurements. They may ",16*ntest)
    Explain("significantly differ from each other, which means that input ")
    Explain("capacities of the fingers are not aligned but does not mean ")
    Explain("that measurement system itself is out of order. Test is passed ")
    Explain("when ")
    if maxfailed!=0 then
      Explain("there are at most %i bad measurements for each ",maxfailed)
      Explain("head. Field measurement is good if ")
    endif
    Explain("(a) for each separate finger, all measured sine and cosine ")
    Explain("components lie within %i bits from the mean for this ",fnoise)
    Explain("finger; (b) sine amplitude lies in range %i..%i ",SINMIN,SINMAX)
    Explain("bits; (c) cosine amplitude lies in range %i..%i ",COSMIN,COSMAX)
    Explain("bits and (d) phase (ratio cosine/sine) differs by not more than ")
    Explain("%g radian from the mean value.",FPHASE)
    if rtfok then
      Explain(" Capacity is not analyzed and placed here for reference ")
      Explain("purposes only.")
    endif
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  add hlist text="Field test interrupted!"
  if err==4 return 1                   // Operator interrupted test
  clear hright
  change hinfo limits=0,0
  change hinfo text="Field error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Field test found some error in internal data structures. "
    draw text="Please contact atg. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid field "
    draw text="measurement. "
  endif
  draw text="Test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Calculates means of two sets of data removing points which have maximal
// absolute deviation from the mean value. Number of points to remove is
// selected automatically. At most 100 points are allowed. Returns number of
// remaining points. Straightforward and slow but reliable implementation.
function int Smartmean(int n,int use[],                                        \
  float c[],float z[],float *cmean,float *zmean)
  int i,j,k,nreal,ibad
  char err[100]
  float sumc,sumz,r,rbad
  nreal=0
  for i=0,i<n,i++ do
    if use[i]!=0 nreal++
  enddo
  if nreal==0 then
    cmean[0]=0.0; zmean[0]=0.0         // Correct possible error
    return 0
  endif
  if nreal>100 nreal=100
  k=(nreal-1)/4                        // Number of points to remove
  while 1 do
    j=0; sumc=0.0; sumz=0.0
    for i=0,i<n,i++ do                 // Calculate actual mean values
      if use[i]==0 continue
      if err[i]!=0 continue
      sumc=sumc+c[i]
      sumz=sumz+z[i]
      j++
    enddo
    if j>0 then
      sumc=sumc/j; cmean[0]=sumc
      sumz=sumz/j; zmean[0]=sumz
    endif
    if k<=0 return j                   // All bad points removed
    rbad=0.0; ibad=-1
    for i=0,i<n,i++ do                 // Find point with maximal deviation
      if use[i]==0 continue
      if err[i]!=0 continue
      r=(c[i]-sumc)*(c[i]-sumc)+(z[i]-sumz)*(z[i]-sumz)
      if r>=rbad then
        rbad=r; ibad=i
      endif
    enddo
    if ibad>=0 err[ibad]=1             // Remove point with maximal deviation
    k--
  enddo
end

// Checks capacity measurements.
function int Ctest(int ntest,int certify,int uselim,int log)
  char cap[16][8]= {                 \ // Pads with capacitors
    " C0PA",                         \ // Alternative no contact
    " SIDER",                        \ // Right contact to test side effects
    " C27P",                         \ // Capacitor 27 pF + 8 pF parasitics
    " C270P",                        \ // Capacitor 270 pF
    " C2N7",                         \ // Capacitor 2.7 nF
    " C22N",                         \ // Capacitor 22 nF
    "RC220N",                        \ // Capacitor 220 nF, first diff test
    " C2U2",                         \ // Capacitor 2.2 uF
    "XC1P7",                         \ // Extended: Capacitor 1.7 pF
    "XC2P9",                         \ // Extended: Capacitor 2.9 pF
    "XC5P4",                         \ // Extended: Capacitor 5.4 pF
    "YC47U",                         \ // Extended: Capacitor 47 uF
    "YC100U",                        \ // Extended: Capacitor 100 uF
    "" };
  int i,i0,i1,i2,j,k,ko,kr,ka,m,n,nreduced,nc,q,t,zheadtype,err
  int units[16],nmeasf,nmeasq,usefield,firstdifferent
  int shorts0[2,33],shorts10[2,33],opens10[2,33]
  int shorts1[2,33],shorts50[2,33],opens50[2,33]
  int nfailed,maxfailed,excluded[16],good[6],inuse[32]
  int fbad[16],fshort[16],qbad[16],qshort[16],bad333[33]
  float umax,crepeat,cfctabs,fnoise,phaseexp,phasedif,zc,zr
  float rin,rrea,cfactor,phdiff,sidemargin,sidexmargin,zdiff
  float cexp[16],cteor[16],factor[16]
  float fc[33][16][5],fr[33][16][5],qc[33][16][5],qr[33][16][5]
  float fsin[32][16][5],fcos[32][16][5]
  float headfc[32,16,32],headfz[32,16,32],headqc[32,16,32],headqz[32,16,32]
  float x,y,xo,yo,xr,yr,xa,ya
  float f,c,r,extr,zmin,zmax,zsigma,percent
  float cc[32],rr[32],fcmean[16],frmean[16],qcmean[16],qrmean[16]
  float tmeanf[16][5],tmeanq[16][5]
  float fcfirst[32][5],fcnext[32][5]
  char headfbad[32,16,32],headqbad[32,16,32]
  char s[256],buf[32],name[32],fgood[33,16],qgood[33,16],mtype[32]
  char cmd[256],fcmd[16,32][256],qcmd[16,32][256]
  handle hinterrupt,hcont
  if nused<4 return 0                  // Test requires at least 3 fingers
  if ntest==0 ntest=16                 // As in certification
  if ntest>32 ntest=32                 // Limited by number of buffers
repeat:
  // Get voltage limits.
  if uselim then
    i=Getutest(&utestmax,&rtestmax,0)
    if i!=0 return i
    umax=utestmax
  else
    umax=0.0                           // Use default C voltage (usually 4 V)
  endif
  if certify==0 then
    maxfailed=0
  else
    maxfailed=ntest*nused*FAILRATE+MAXFAILED
  endif
  if testertype==TT_A1 || testertype==TT_A2 || testertype==TT_A2L ||           \
    testertype==TT_A2H || testertype==TT_A3 || testertype==TT_A3L ||           \
    testertype==TT_A4                                                          \
  then
    crepeat=CREPOLD
  else
    crepeat=CREPEAT
  endif
  if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
    cfctabs=CFCTABS*2.0
  else
    cfctabs=CFCTABS
  endif
  fnoise=FNOISECERT*2.0
  // On-head boards declared in layout as LC_PHADJ may be either old with
  // relatively high phase shift (ca. 5 degrees), or the new ones with shift
  // under 1 degree. I extend the limits so that both cases are covered.
  // Anyway, what's important is that all shifts are equal.
  if ($LAY.config & LC_OHTYPE)==LC_PHADJ then
    usefield=1
    phaseexp=(PHASEEXPX+PHASEEXP)/2.0
    phasedif=PHASEEXP+PHASEDIF-phaseexp
  else if ($LAY.config & LC_OHTYPE)==LC_NOFIELD then
    usefield=0
    phaseexp=(PHASEEXPX+PHASEEXP)/2.0
    phasedif=Abs(PHASEEXPX-PHASEEXP)/2.0+PHASEDIF
  else
    usefield=1
    phaseexp=PHASEEXP
    phasedif=PHASEDIF
  endif
  zheadtype=$EXTLAY.zheadtype
  j=0
  for nc=0,cap[nc][0]!='\0',nc++ do
    if (cap[nc][0]=='X' || cap[nc][0]=='Y') &&                                 \
      (romdata.features & BF_TYPE)!=BF_TRIPOD                                  \
      break                            // Skip extended components
    if Stricmp(cap[nc]+1,"SIDER")==0 &&                                        \
      (testertype==TT_S2 || (testertype==TT_A8 && testersides!=0x03) ||        \
      (testertype==TT_S3 && testersides!=0x03))                                \
    then
      excluded[nc]=1
    else
      excluded[nc]=0
    endif
    // Only one component may be used in the first-measurement-different test.
    if cap[nc][0]=='R' then
      if j!=0 then
        cap[nc][0]=' '
      else
        j=1
      endif
    endif
  enddo
  clear hright
  change hinfo limits=0,0
  if uselim then
    change hinfo text=format("Capacity at %g V",umax)
    Addreplaysection("Capacity at %g V",umax)
  else
    change hinfo text="?Y2a?"
    Addreplaysection("?Y2a?")
  endif
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  if allowvarshort then
    if uselim then
      add hlist text=format("       SHORTS TO ANTENNA (10/50 M, %g V)",umax)
    else
      add hlist text="    SHORTS TO ANTENNA (10/50 MOhm threshold)"
    endif
    add hlist text=""
    add hlist text="Head  Expect  -----Shorts-----  ---Opens---  Pass"
    if (romdata.features & BF_TYPE)==BF_TRIPOD then
      add hlist text="              00/00/10/47 MOhm  47 M / OPEN"
    else
      add hlist text="              00/00/10/47 MOhm  47/200 MOhm"
    endif
  else
    if uselim then
      add hlist text=format("             SHORTS TO ANTENNA (%g V)",umax)
    else
      add hlist text="                 SHORTS TO ANTENNA"
    endif
    add hlist text=""
    add hlist text="Head  Expect  Shorts 0/10 MOhm  Opens 47 M   Pass"
  endif
  add hlist text=""
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="?a??2a??2?Y??DDo???.?D"
  draw text=format("?2??????? %.2f%% + ",crepeat*100.0)
  draw text=format("%.0f fF",CREPABS*1000.0)
  draw text="????. ?????"
  draw text="22??o??a,?2?"
  draw text=format("?%.0f%%??",CFACTOR*100.0)
  draw text="??"
  draw text="?"
  draw text="?."
  if uselim then
    draw text=format(" Measurements use non-standard voltage %g V. ",umax)
  endif
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D???Y2a?"
  endc
  for n=0,n<ntest && err==0,n++ do
    SYS.Killimm(n)                     // Remove all pending commands
  enddo
  SERV.Cmdimm(32,"OUTPORT 0x20F0,8")   // Set 4 V antenna voltage
  for i=0,i<nc,i++ do                  // For all capacities
    // Initialize ovarall field statistics.
    Initsigma(fc[$LAY.nfing*2,i])
    Initsigma(fr[$LAY.nfing*2,i])
    Initsigma(tmeanf[i])
    fbad[i]=0; fshort[i]=0
    // Initialize overall fast capacity statistics.
    Initsigma(qc[$LAY.nfing*2,i])
    Initsigma(qr[$LAY.nfing*2,i])
    Initsigma(tmeanq[i])
    qbad[i]=0; qshort[i]=0
    for j=0,xname[j][0]!='\0',j++ do   // Find capacitor value
      if Strcmp(cap[i]+1,xname[j])==0 then
        cexp[i]=value[j]; break        // In picofarades
      endif
    enddo
    if xname[j][0]=='\0' err=1
    zc=cexp[i]; units[i]=0; factor[i]=1.0
    while Abs(zc)>=920.0 && units[i]<2 do
      zc=zc/1000.0; factor[i]=factor[i]*1000.0; units[i]++
    enddo
  enddo
  Memset(shorts0,0,Sizeof(shorts0))
  Memset(shorts1,0,Sizeof(shorts1))
  Memset(shorts10,0,Sizeof(shorts10))
  Memset(shorts50,0,Sizeof(shorts50))
  Memset(opens10,0,Sizeof(opens10))
  Memset(opens50,0,Sizeof(opens50))
  Memset(inuse,0,Sizeof(inuse))
  Clearoversurface()
  Initerrlist()
  if allowquickc==(-1) err=-1          // Operator interrupted the calibration
  nmeasf=0; nmeasq=0
  // Heads moving over the OlliBoard may influence capacity measurements,
  // especially low (35 pF and less). I move all fingers so that they always
  // stay over the board. It's OK that some extended components lie outside
  // the covered area.
  for i=0,i<$LAY.nfing*2,i=i+2 do      // Move all fingers toward PCB
    if used[i]==0 continue
    Convertpad(&x,&y,"GND1",i,0.0)
    Convertpad(&xo,&yo,"C270P",i+1,0.0)
    sprintf(s,"M %i[%g,%gA%iH50] %i[%g,%gA%iH50] NOP",i,x,y,acc,i+1,xo,yo,acc)
    SERV.Cmdimm(32,s)
    bad333[k]=0
  enddo
  bad333[32]=0
  delay 500                            // I'm too lazy to wait for all answers
  if log then
    if txtok then
      fprintf(hlog,"\nCapacity measurements:\n")
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\nCapacity measurements:\n")
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  firstdifferent=0
  for k=0,k<$LAY.nfing*2,k++ do        // For all heads
    ko=k^1                             // Opposite finger
    kr=(k & 0x1E)+$LAY.nfing           // Resistor for shorts test
    if kr>=$LAY.nfing*2 kr=kr-$LAY.nfing*2
    ka=kr+1                            // Ground antenna
    if used[k]==0 || used[kr]==0 || used[ka]==0 continue
    inuse[k]=1
    if $LAY.rightlimit-$LAY.leftlimit<400000 then
      if Convertpad(&xo,&yo,(ko<k?"L47U":"HV"),ko,0.0)<0.0 err=1
    else
      if Convertpad(&xo,&yo,(ko<k?"RES0":"P3"),ko,0.0)<0.0 err=1
    endif
    if (romdata.features & BF_TYPE)==BF_TRIPOD && ko<k then
      xo=xo-10.0
    endif
    if Convertpad(&xa,&ya,"GND2",ka,DELTA)<0.0 err=1
    if err!=0 break
    Initsigma(fcfirst[k])
    Initsigma(fcnext[k])
    for i=0,i<nc && err==0,i++ do      // For all capacities
      change hinfo limits=k*nc+i,nused*nc
      if excluded[i]!=0 continue
      if Convertpad(&x,&y,cap[i]+1,k,DELTA)<0.0 err=1
      if Convertpad(&xr,&yr,"R10M",kr,DELTA)<0.0 err=1
      if err!=0 break
      // Activate test voltage (and restore other test parameters, if changed).
      Setfcparameters(umax,1.0e7)
      // Field measurements (skip unsupported capacities).
      Initsigma(fc[k,i])
      Initsigma(fr[k,i])
      Initsigma(fsin[k,i])
      Initsigma(fcos[k,i])
      if usefield!=0 && cap[i][0]!='X' && cap[i][0]!='Y' &&                    \
        (($LAY.config & 0x400)!=0 || cexp[i]<300.0)                            \
      then
        if certify==0 && usestat==1 then
          // Reset measurement statistics.
          buf[0]=S_DEBUG
          buf[1]=0x2F                  // Statistical data
          buf[2]=0x80                  // Measurement card
          buf[3]=1                     // Reset statistics
          $int2(buf+4)=0x32            // Page 0x32
          $int4(buf+6)=0               // Must be zero
          SYS.Sendimm(32,10,buf)
        endif
        n=sprintf(cmd,"M %i[%g,%gA%i] %i[%g,%gA%iH50] %i[%g,%gA%iH50] ",       \
          k,x,y,acc,ko,xo,yo,acc,kr,xr,yr,acc)
        sprintf(cmd+n,"%i[%g,%gA%i] F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i)",      \
          ka,xa,ya,acc,k,ka,ka,ka,ka,ka,ka,ka,ka,ka,ka)
        Strcpy(fcmd[i,k],cmd)
        // Prepare command for possible first-measurement-different test.
        sprintf(cmd+n,"%i[%g,%gA%i] R(%i,%i)",ka,xa,ya,acc,k,ka)
        for n=0,n<ntest && err==0,n++ do
          if SERV.Cmdimm(n,fcmd[i,k])<0 err=1
          nmeasf++
        enddo
        for n=0,n<ntest && err==0,n++ do
          t=Time()                     // Wait till all answers come
          while $A[n].length==0 && err==0 do
            if Time()-t>10000 err=2
            if Pressed(hexit) err=-1
            if Pressed(hinterrupt) err=4
            wait
          enddo
          if (err==0 && $A[n].answer!=S_MOVE) err=3
          zc=0.0; zr=0.0
          SERV.Convertfield($A[n],&zc,&zr)
          Addsigma(fc[k,i],zc)
          Addsigma(fr[k,i],zr)
          Addsigma(fc[$LAY.nfing*2,i],zc)
          Addsigma(fr[$LAY.nfing*2,i],zr)
          headfc[k,i,n]=zc
          headfz[k,i,n]=zr
          if ($A[n].status & 0x1800)!=0 then
            Adderr(fcmd[i,k],0,k,"Bad measurements at %.3g %s",                \
              cexp[i]/factor[i],cunitname[units[i]])
            fbad[i]++
            headfbad[k,i,n]=1
          else
            headfbad[k,i,n]=0
          endif
          if ($A[n].status & 0x0020)!=0 then
            Adderr(fcmd[i,k],0,k,"Shorts at %.3g %s",                          \
              cexp[i]/factor[i],cunitname[units[i]])
            fshort[i]++
            headfbad[k,i,n]=1
          endif
          for j=1,j<10,j++ do
            if Abs($int2($A[n]+28+4*j))>500 then
              Addsigma(fsin[k,i],$int2($A[n]+28+4*j))
            endif
            if Abs($int2($A[n]+30+4*j))>250 then
              Addsigma(fcos[k,i],$int2($A[n]+30+4*j))
            endif
          enddo
          if log then
            m=sprintf(s,"  Field  %2i(%2i) at ",k,ka)
            j=sprintf(s+m,"%.3g %s:",cexp[i]/factor[i],cunitname[units[i]])
            while j<10 do s[m+j]=' '; j++; enddo
            m=m+j
            m=m+sprintf(s+m,"C=%7.3g, Z=%7.3g %s, ",                           \
              zc/factor[i],zr/factor[i],cunitname[units[i]])
            m=m+sprintf(s+m,"st=%04X",$A[n].status)
            if ($A[n].status & 0x1820)!=0 then
              m=m+sprintf(s+m," (")
              if ($A[n].status & 0x1800)!=0 then
                m=m+sprintf(s+m,"bad")
                if ($A[n].status & 0x0020)!=0 m=m+sprintf(s+m,",")
              endif
              if ($A[n].status & 0x0020)!=0 m=m+sprintf(s+m,"short")
              m=m+sprintf(s+m,")")
            endif
            lprintf(GREEN,"%s",s)
            if txtok!=0 then
              fprintf(hlog,"%s\n",s)
            endif
            if rtfok!=0 then
              RAddfmt("%s\n",s)
            endif
          endif
        enddo
        // Some on-head boards react badly on reswitching of the ZERO signal.
        // Check if on-head board has this defect. I do not test old machines -
        // even if they are affected, there is no software solution.
        if err==0 && cap[i][0]=='R' &&                                         \
          (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||     \
          testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||       \
          testertype==TT_A7 || testertype==TT_A8)                              \
        then
          for n=0,n<12,n++ do
            SERV.Cmdimm(0,cmd)
            SERV.Cmdimm(1,fcmd[i,k])
            SERV.Cmdimm(2,fcmd[i,k])
            t=Time()                   // Wait till all three answers come
            while err==0 do
              if $A[0].length>0 && $A[1].length>0 && $A[2].length>0 break
              if Time()-t>10000 err=2
              if Pressed(hexit) err=-1
              if Pressed(hinterrupt) err=4
              wait
            enddo
            if err!=0 break
            // Crate will keep the order of commands.
            if ($A[1].status & 0x1800)==0 then
              SERV.Convertfield($A[1],&zc,&zr)
              if zc>=0.9*Getmax(fc[k,i]) Addsigma(fcfirst[k],zc)
            endif
            if ($A[2].status & 0x1800)==0 then
              SERV.Convertfield($A[2],&zc,&zr)
              if zc>=0.9*Getmax(fc[k,i]) Addsigma(fcnext[k],zc)
            endif
          enddo
          if Getcount(fcfirst[k])>=4 && Getcount(fcnext[k])>=4 &&              \
            Getxmean(fcfirst[k])<Getxmean(fcnext[k])*(1.0-CREPEAT/2.0) then
            firstdifferent=1
          endif
        endif
        // Read measurement statistics.
        if certify==0 && usestat==1 && err==0 then
          buf[0]=S_DEBUG
          buf[1]=0x2F                  // Statistical data
          buf[2]=0x80                  // Measurement card
          buf[3]=1                     // Reset statistics afterwards
          $int2(buf+4)=0x32            // Page 0x32
          $int4(buf+6)=0               // Must be zero
          SYS.Sendimm(0,10,buf)
          t=Time()
          while err==0 do
            if $A[0].length!=0 break
            if Pressed(hexit) err=-1
            if Time()-t>10000 err=2
            if Pressed(hinterrupt) err=4
            wait
          enddo
          if err==0 && $A[0].answer==S_DEBUG then
            Addsigma(tmeanf[i],$uint4($A[0]+5+0*4)/1000.0)
          endif
        endif
      endif
      if err!=0 break
      // Quick capacity measurements.
      if allowquickc==0 continue
      if certify==0 && usestat==1 then
        // Reset measurement statistics.
        buf[0]=S_DEBUG
        buf[1]=0x2F                    // Statistical data
        buf[2]=0x80                    // Measurement card
        buf[3]=1                       // Reset statistics
        $int2(buf+4)=0x32              // Page 0x32
        $int4(buf+6)=0                 // Must be zero
        SYS.Sendimm(32,10,buf)
      endif
      Initsigma(qc[k,i])
      Initsigma(qr[k,i])
      n=sprintf(cmd,"M %i[%g,%gA%i] %i[%g,%gA%iH50] %i[%g,%gA%iH50] ",         \
        k,x,y,acc,ko,xo,yo,acc,kr,xr,yr,acc)
      sprintf(cmd+n,"%i[%g,%gA%i] A(%i,0,%i)",ka,xa,ya,acc,k,ka)
      // Measurements on high capacitors take very long. I reduce the number
      // of measurements.
      if cap[i][0]=='Y' then
        nreduced=Min(ntest,Max(4,ntest/2))
      else
        nreduced=ntest
      endif
      for n=0,n<nreduced && err==0,n++ do
        if SERV.Cmdimm(n,cmd)<0 err=1  // Send all quick C commands at once
        nmeasq++
      enddo
      Strcpy(qcmd[i,k],cmd)
      for n=0,n<nreduced && err==0,n++ do
        t=Time()                       // Wait till all answers come
        while $A[n].length==0 && err==0 do
          if Time()-t>10000 err=2
          if Pressed(hexit) err=-1
          if Pressed(hinterrupt) err=4
          wait
        enddo
        if (err==0 && $A[n].answer!=S_MOVE) err=3
        zc=0.0; zr=0.0
        SERV.Convertfastc($A[n],&zc,&zr)
        Addsigma(qc[k,i],zc)
        Addsigma(qr[k,i],zr)
        Addsigma(qc[$LAY.nfing*2,i],zc)
        Addsigma(qr[$LAY.nfing*2,i],zr)
        headqc[k,i,n]=zc
        headqz[k,i,n]=zr
        if ($A[n].status & 0x1800)!=0 then
          Adderr(cmd,1,k,"Bad measurements at %.3g %s",                        \
            cexp[i]/factor[i],cunitname[units[i]])
          qbad[i]++
          headqbad[k,i,n]=1
        else
          headqbad[k,i,n]=0
        endif
        if ($A[n].status & 0x0020)!=0 then
          Adderr(cmd,1,k,"Shorts at %.3g %s",                                  \
            cexp[i]/factor[i],cunitname[units[i]])
          qshort[i]++
          headqbad[k,i,n]=1
        endif
        if log then
          m=sprintf(s,"  Fast C %2i(%2i) at ",k,ka)
          j=sprintf(s+m,"%.3g %s:",cexp[i]/factor[i],cunitname[units[i]])
          while j<10 do s[m+j]=' '; j++; enddo
          m=m+j
          m=m+sprintf(s+m,"C=%7.3g, Z=%7.3g %s, ",                             \
            zc/factor[i],zr/factor[i],cunitname[units[i]])
          m=m+sprintf(s+m,"st=%04X",$A[n].status)
          if ($A[n].status & 0x1820)!=0 then
            m=m+sprintf(s+m," (")
            if ($A[n].status & 0x1800)!=0 then
              m=m+sprintf(s+m,"bad")
              if ($A[n].status & 0x0020)!=0 m=m+sprintf(s+m,",")
            endif
            if ($A[n].status & 0x0020)!=0 m=m+sprintf(s+m,"short")
            m=m+sprintf(s+m,")")
          endif
          lprintf(GREEN,"%s",s)
          if txtok!=0 then
            fprintf(hlog,"%s\n",s)
          endif
          if rtfok!=0 then
            RAddfmt("%s\n",s)
          endif
        endif
      enddo
      // Read measurement statistics.
      if certify==0 && usestat==1 && err==0 then
        buf[0]=S_DEBUG
        buf[1]=0x2F                    // Statistical data
        buf[2]=0x80                    // Measurement card
        buf[3]=1                       // Reset statistics afterwards
        $int2(buf+4)=0x32              // Page 0x32
        $int4(buf+6)=0                 // Must be zero
        SYS.Sendimm(0,10,buf)
        t=Time()
        while err==0 do
          if $A[0].length!=0 break
          if Pressed(hexit) err=-1
          if Time()-t>10000 err=2
          if Pressed(hinterrupt) err=4
          wait
        enddo
        if err==0 && $A[0].answer==S_DEBUG then
          Addsigma(tmeanq[i],$uint4($A[0]+5+0*4)/1000.0)
        endif
      endif
    enddo

//--- change hinfo???

    // Test shorts to antenna, both for field and for fast C.
    for q=0,q<2,q++ do
      if q==0 then
        if usefield==0 continue
        Strcpy(mtype,"field")
      else
        if allowquickc==0 break
        Strcpy(mtype,"fast C")
      endif
      // Short to antenna 0 Ohm (must be detected).
      if Convertpad(&x,&y,"GND2",k,DELTA)<0.0 err=1
      if Convertpad(&xr,&yr,"GND1",kr,DELTA)<0.0 err=1
      if Convertpad(&xa,&ya,"C270P",ka,DELTA)<0.0 err=1
      n=sprintf(cmd,                                                           \
        "M %i[%g,%gA%i] %i[%g,%gA%iH50] %i[%g,%gA%i] %i[%g,%gA%i] ",           \
        k,x,y,acc,ko,xo,yo,acc,kr,xr,yr,acc,ka,xa,ya,acc)
      if q==0 then                     // Field
        sprintf(cmd+n,"F(%i,%i,%i)",k,ka,kr)
      else                             // Fast C
        sprintf(cmd+n,"A(%i,0,%i,%i)",k,ka,kr)
      endif
      for n=0,n<ntest && err==0,n++ do
        if SERV.Cmdimm(n,cmd)<0 err=1  // Send all short test commands at once
      enddo
      for n=0,n<ntest && err==0,n++ do
        t=Time()                       // Wait till all answers come
        while $A[n].length==0 && err==0 do
          if Time()-t>10000 err=2
          if Pressed(hexit) err=-1
          if Pressed(hinterrupt) err=4
          wait
        enddo
        if (err==0 && $A[n].answer!=S_MOVE) err=3
        if ($A[n].status & 0x0020)!=0 then
          shorts0[q,k]++; shorts0[q,$LAY.nfing*2]++
        else
          Adderr(cmd,2,k,"0 Ohm short (%s, 10 M threshold) not detected",mtype)
        endif
        if log then
          m=sprintf(s,"  %s %2i(%2i,%2i) (GND-GND-270pF),  10 M threshold: ",  \
            q==0?"Field  short":"Fast C short",k,kr,ka)
          m=m+sprintf(s+m,"st=%04X",$A[n].status)
          if ($A[n].status & 0x0020)==0 sprintf(s+m," (missed)")
          lprintf(GREEN,"%s",s)
          if txtok!=0 then
            fprintf(hlog,"%s\n",s)
          endif
          if rtfok!=0 then
            RAddfmt("%s\n",s)
          endif
        endif
      enddo
      // Short to antenna 10 M (must be detected).
      if Convertpad(&x,&y,"GND2",k,DELTA)<0.0 err=1
      if Convertpad(&xr,&yr,"R10M",kr,DELTA)<0.0 err=1
      if Convertpad(&xa,&ya,"C270P",ka,DELTA)<0.0 err=1
      n=sprintf(cmd,                                                           \
        "M %i[%g,%gA%i] %i[%g,%gA%iH50] %i[%g,%gA%i] %i[%g,%gA%i] ",           \
        k,x,y,acc,ko,xo,yo,acc,kr,xr,yr,acc,ka,xa,ya,acc)
      if q==0 then                     // Field
        sprintf(cmd+n,"F(%i,%i,%i)",k,ka,kr)
      else                             // Fast C
        sprintf(cmd+n,"A(%i,0,%i,%i)",k,ka,kr)
      endif
      for n=0,n<ntest && err==0,n++ do
        if SERV.Cmdimm(n,cmd)<0 err=1  // Send all short test commands at once
      enddo
      for n=0,n<ntest && err==0,n++ do
        t=Time()                       // Wait till all answers come
        while $A[n].length==0 && err==0 do
          if Time()-t>10000 err=2
          if Pressed(hexit) err=-1
          if Pressed(hinterrupt) err=4
          wait
        enddo
        if (err==0 && $A[n].answer!=S_MOVE) err=3
        if ($A[n].status & 0x0020)!=0 then
          shorts10[q,k]++; shorts10[q,$LAY.nfing*2]++
        else
          Adderr(cmd,2,k,"10 M short (%s, 10 M threshold) not detected",mtype)
        endif
        if log then
          m=sprintf(s,"  %s %2i(%2i,%2i) (GND-10M-270pF),  10 M threshold: ",  \
            q==0?"Field  short":"Fast C short",k,kr,ka)
          m=m+sprintf(s+m,"st=%04X",$A[n].status)
          if ($A[n].status & 0x0020)==0 sprintf(s+m," (missed)")
          lprintf(GREEN,"%s",s)
          if txtok!=0 then
            fprintf(hlog,"%s\n",s)
          endif
          if rtfok!=0 then
            RAddfmt("%s\n",s)
          endif
        endif
      enddo
      // Short to antenna 47 M (must not be detected).
      if Convertpad(&xr,&yr,"R47M",kr,DELTA)<0.0 err=1
      n=sprintf(cmd,                                                           \
        "M %i[%g,%gA%i] %i[%g,%gA%iH50] %i[%g,%gA%i] %i[%g,%gA%i] ",           \
        k,x,y,acc,ko,xo,yo,acc,kr,xr,yr,acc,ka,xa,ya,acc)
      if q==0 then                     // Field
        sprintf(cmd+n,"F(%i,%i,%i)",k,ka,kr)
      else                             // Fast C
        sprintf(cmd+n,"A(%i,0,%i,%i)",k,ka,kr)
      endif
      for n=0,n<ntest && err==0,n++ do
        if SERV.Cmdimm(n,cmd)<0 err=1  // Send all short test commands at once
      enddo
      for n=0,n<ntest && err==0,n++ do
        t=Time()                       // Wait till all answers come
        while $A[n].length==0 && err==0 do
          if Time()-t>10000 err=2
          if Pressed(hexit) err=-1
          if Pressed(hinterrupt) err=4
          wait
        enddo
        if (err==0 && $A[n].answer!=S_MOVE) err=3
        if ($A[n].status & 0x0020)==0 then
          opens10[q,k]++; opens10[q,$LAY.nfing*2]++
        else
          Adderr(cmd,2,k,"False 47 M short (%s, 10 M threshold) detected",mtype)
        endif
        if log then
          m=sprintf(s,"  %s %2i(%2i,%2i) (GND-47M-270pF),  10 M threshold: ",  \
            q==0?"Field  short":"Fast C short",k,kr,ka)
          m=m+sprintf(s+m,"st=%04X",$A[n].status)
          if ($A[n].status & 0x0020)!=0 sprintf(s+m," (false short)")
          lprintf(GREEN,"%s",s)
          if txtok!=0 then
            fprintf(hlog,"%s\n",s)
          endif
          if rtfok!=0 then
            RAddfmt("%s\n",s)
          endif
        endif
      enddo
      if allowvarshort then
        // Tests with 50 M short-to-antenna threshold.
        Setfcparameters(umax,5.0e7)
        // Short to antenna 0 Ohm (must be detected).
        if Convertpad(&x,&y,"GND2",k,DELTA)<0.0 err=1
        if Convertpad(&xr,&yr,"GND1",kr,DELTA)<0.0 err=1
        if Convertpad(&xa,&ya,"C270P",ka,DELTA)<0.0 err=1
        n=sprintf(cmd,                                                         \
          "M %i[%g,%gA%i] %i[%g,%gA%iH50] %i[%g,%gA%i] %i[%g,%gA%i]",          \
          k,x,y,acc,ko,xo,yo,acc,kr,xr,yr,acc,ka,xa,ya,acc)
        if q==0 then                   // Field
          sprintf(cmd+n," F(%i,%i,%i)",k,ka,kr)
        else                           // Fast C
          sprintf(cmd+n," A(%i,0,%i,%i)",k,ka,kr)
        endif
        for n=0,n<ntest && err==0,n++ do
          if SERV.Cmdimm(n,cmd)<0 err=1// Send all short test commands at once
        enddo
        for n=0,n<ntest && err==0,n++ do
          t=Time()                     // Wait till all answers come
          while $A[n].length==0 && err==0 do
            if Time()-t>10000 err=2
            if Pressed(hexit) err=-1
            if Pressed(hinterrupt) err=4
            wait
          enddo
          if (err==0 && $A[n].answer!=S_MOVE) err=3
          if ($A[n].status & 0x0020)!=0 then
            shorts1[q,k]++; shorts1[q,$LAY.nfing*2]++
          else
            Adderr(cmd,2,k,                                                    \
            "0 Ohm short (%s, 50 M threshold) not detected",mtype)
          endif
          if log then
            m=sprintf(s,"  %s %2i(%2i,%2i) (GND-GND-270pF),  50 M threshold: ",\
              q==0?"Field  short":"Fast C short",k,kr,ka)
            m=m+sprintf(s+m,"st=%04X",$A[n].status)
            if ($A[n].status & 0x0020)==0 sprintf(s+m," (missed)")
            lprintf(GREEN,"%s",s)
            if txtok!=0 then
              fprintf(hlog,"%s\n",s)
            endif
            if rtfok!=0 then
              RAddfmt("%s\n",s)
            endif
          endif
        enddo
        // Short to antenna 47 M (must be detected).
        if Convertpad(&x,&y,"GND2",k,DELTA)<0.0 err=1
        if Convertpad(&xr,&yr,"R47M",kr,DELTA)<0.0 err=1
        if Convertpad(&xa,&ya,"C270P",ka,DELTA)<0.0 err=1
        n=sprintf(cmd,                                                         \
          "M %i[%g,%gA%i] %i[%g,%gA%iH50] %i[%g,%gA%i] %i[%g,%gA%i]",          \
          k,x,y,acc,ko,xo,yo,acc,kr,xr,yr,acc,ka,xa,ya,acc)
        if q==0 then                   // Field
          sprintf(cmd+n," F(%i,%i,%i)",k,ka,kr)
        else                           // Fast C
          sprintf(cmd+n," A(%i,0,%i,%i)",k,ka,kr)
        endif
        for n=0,n<ntest && err==0,n++ do
          if SERV.Cmdimm(n,cmd)<0 err=1// Send all short test commands at once
        enddo
        for n=0,n<ntest && err==0,n++ do
          t=Time()                     // Wait till all answers come
          while $A[n].length==0 && err==0 do
            if Time()-t>10000 err=2
            if Pressed(hexit) err=-1
            if Pressed(hinterrupt) err=4
            wait
          enddo
          if (err==0 && $A[n].answer!=S_MOVE) err=3
          if ($A[n].status & 0x0020)!=0 then
            shorts50[q,k]++; shorts50[q,$LAY.nfing*2]++
          else
            Adderr(cmd,2,k,"47 M short (%s, 50 M threshold) not detected",mtype)
          endif
          if log then
            m=sprintf(s,"  %s %2i(%2i,%2i) (GND-47M-270pF),  50 M threshold: ",\
              q==0?"Field  short":"Fast C short",k,kr,ka)
            m=m+sprintf(s+m,"st=%04X",$A[n].status)
            if ($A[n].status & 0x0020)==0 sprintf(s+m," (missed)")
            lprintf(GREEN,"%s",s)
            if txtok!=0 then
              fprintf(hlog,"%s\n",s)
            endif
            if rtfok!=0 then
              RAddfmt("%s\n",s)
            endif
          endif
        enddo
        // Short to antenna 200 M/open (must not be detected).
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          if Convertpad(&xr,&yr,"NOCT1",kr,DELTA)<0.0 err=1
        else
          if Convertpad(&xr,&yr,"R200M",kr,DELTA)<0.0 err=1
        endif
        n=sprintf(cmd,                                                         \
          "M %i[%g,%gA%i] %i[%g,%gA%iH50] %i[%g,%gA%i] %i[%g,%gA%i]",          \
          k,x,y,acc,ko,xo,yo,acc,kr,xr,yr,acc,ka,xa,ya,acc)
        if q==0 then                   // Field
          sprintf(cmd+n," F(%i,%i,%i)",k,ka,kr)
        else                           // Fast C
          sprintf(cmd+n," A(%i,0,%i,%i)",k,ka,kr)
        endif
        for n=0,n<ntest && err==0,n++ do
          if SERV.Cmdimm(n,cmd)<0 err=1// Send all short test commands at once
        enddo
        for n=0,n<ntest && err==0,n++ do
          t=Time()                     // Wait till all answers come
          while $A[n].length==0 && err==0 do
            if Time()-t>10000 err=2
            if Pressed(hexit) err=-1
            if Pressed(hinterrupt) err=4
            wait
          enddo
          if (err==0 && $A[n].answer!=S_MOVE) err=3
          if ($A[n].status & 0x0020)==0 then
            opens50[q,k]++; opens50[q,$LAY.nfing*2]++
          else if (romdata.features & BF_TYPE)==BF_TRIPOD then
            Adderr(cmd,2,k,                                                    \
            "False short on OPEN (%s, 50 M threshold) detected",mtype)
          else
            Adderr(cmd,2,k,                                                    \
            "False 200 M short (%s, 50 M threshold) detected",mtype)
          endif
          if log then
            m=sprintf(s,"  %s %2i(%2i,%2i) (GND-%s-270pF), 50 M threshold: ",  \
              q==0?"Field  short":"Fast C short",k,kr,ka,                      \
              (romdata.features & BF_TYPE)==BF_TRIPOD?"OPEN":"200M")
            m=m+sprintf(s+m,"st=%04X",$A[n].status)
            if ($A[n].status & 0x0020)!=0 sprintf(s+m," (false short)")
            lprintf(GREEN,"%s",s)
            if txtok!=0 then
              fprintf(hlog,"%s\n",s)
            endif
            if rtfok!=0 then
              RAddfmt("%s\n",s)
            endif
          endif
        enddo
        Setfcparameters(umax,1.0e7)    // Restore old threshold
      endif
    enddo
    j=1
    if usefield &&                                                             \
      (shorts0[0,k]!=ntest || shorts10[0,k]!=ntest || opens10[0,k]!=ntest) j=0
    if allowvarshort && usefield &&                                            \
      (shorts1[0,k]!=ntest || shorts50[0,k]!=ntest || opens50[0,k]!=ntest) j=0
    if allowquickc &&                                                          \
      (shorts0[1,k]!=ntest || shorts10[1,k]!=ntest || opens10[1,k]!=ntest) j=0
    if allowvarshort && allowquickc &&                                         \
      (shorts1[1,k]!=ntest || shorts50[1,k]!=ntest || opens50[1,k]!=ntest) j=0
    change hlist color=(j==0?LIGHTRED:BLACK)
    if allowquickc==0 then             // Field only
      if allowvarshort then
        add hlist text=format(                                                 \
        "%2i%c  %5i    %3i %3i %3i %3i    %3i %3i     %s",                     \
        k/2,(k & 1)==0?'L':'R',ntest,                                          \
        shorts0[0,k],shorts1[0,k],shorts10[0,k],shorts50[0,k],                 \
        opens10[0,k],opens50[0,k],j==0?"No":"Yes")
      else
        add hlist text=format("%2i%c  %5i      %4i  %4i        %4i       %s",  \
        k/2,(k & 1)==0?'L':'R',ntest,shorts0[0,k],shorts10[0,k],opens10[0,k],  \
        j==0?"No":"Yes")
      endif
    else if usefield==0 then
      if allowvarshort then
        add hlist text=format(                                                 \
        "%2i%c  %5i    %3i %3i %3i %3i    %3i %3i     %s",                     \
        k/2,(k & 1)==0?'L':'R',ntest,                                          \
        shorts0[1,k],shorts1[1,k],shorts10[1,k],shorts50[1,k],                 \
        opens10[1,k],opens50[1,k],j==0?"No":"Yes")
      else
        add hlist text=format("%2i%c  %5i      %4i  %4i        %4i       %s",  \
        k/2,(k & 1)==0?'L':'R',ntest,shorts0[1,k],shorts10[1,k],opens10[1,k],  \
        j==0?"No":"Yes")
      endif
    else
      if allowvarshort then
        add hlist text=format(                                                 \
        "%2i%c  %5i    %3i %3i %3i %3i    %3i %3i     %s",                     \
        k/2,(k & 1)==0?'L':'R',2*ntest,                                        \
        shorts0[0,k]+shorts0[1,k],shorts1[0,k]+shorts1[1,k],                   \
        shorts10[0,k]+shorts10[1,k],shorts50[0,k]+shorts50[1,k],               \
        opens10[0,k]+opens10[1,k],opens50[0,k]+opens50[1,k],j==0?"No":"Yes")
      else
        add hlist text=format("%2i%c  %5i      %4i  %4i        %4i       %s",  \
        k/2,(k & 1)==0?'L':'R',ntest,shorts0[0,k]+shorts0[1,k],                \
        shorts10[0,k]+shorts10[1,k],opens10[0,k]+opens10[1,k],j==0?"No":"Yes")
      endif
    endif
    if (k & 1)!=0 then
      Convertpad(&x,&y,"GND1",k & 0xFE,0.0)
      Convertpad(&xo,&yo,"C270P",k | 0x01,0.0)
      sprintf(s,"M %i[%g,%gA%iH50] %i[%g,%gA%iH50] NOP",                       \
        k & 0xFE,x,y,acc,k | 0x01,xo,yo,acc)
      SERV.Cmdimm(32,s)                // Move fingers in base positions
      Convertpad(&x,&y,"GND1",kr,0.0)
      Convertpad(&xo,&yo,"C270P",ka,0.0)
      sprintf(s,"M %i[%g,%gA%iH50] %i[%g,%gA%iH50] NOP",                       \
        kr,x,y,acc,ka,xo,yo,acc)
      SERV.Cmdimm(32,s)                // Move fingers in base positions
    endif
  enddo
  if err==(-1) return -1               // Operator interrupted test
  // Check results of field measurements.
  for i=0,i<nc,i++ do                  // For all capacities
    if usefield==0 break
    fgood[$LAY.nfing*2,i]=1
    if excluded[i]!=0 || cap[i][0]=='X' || cap[i][0]=='Y' continue
    // Take into account the (active) input resistance of I-U converter. As
    // this resistance is important only for capacity over 30 nF, I always take
    // input resistance of on-head with Dallas potentiometer.
    rin=285.0                          // Input resistance of active on-head
    rrea=rin*2*3.1415926536*1953.1*cexp[i]*1.0e-12
    zc=cexp[i]/(1.0+rrea*rrea)
    if cexp[i]>5.0e5 zc=zc*0.7         // Empirical correction for 1 k
    cteor[i]=zc
    if ($LAY.config & 0x400)==0 && cexp[i]>=300.0 continue
    for k=0,k<$LAY.nfing*2,k++ do      // For all heads
      if inuse[k]==0 continue
      cc[k]=Getmean(fc[k][i])
      rr[k]=Getmean(fr[k][i])
    enddo
    // When capacity is measured on side effect field, there are strong side
    // effects between pads and contacting heads. I take it into account by
    // allowing additional capacity margin. A5/A6 soft touch splinogramms also
    // feature strong side effects due to inadequate shielding. A5/A6 with
    // normal needles on splinogramm-ready parallelograms also have higher
    // parasitic capacity to board.
    if Stricmp(cap[i]+1,"SIDER")==0 then
      sidemargin=SIDERMARGIN           // High capacity to rest of world
    else if (testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3) &&   \
      Stricmp(cap[i]+1,"C27P")==0 then
      sidemargin=SIDERMARGIN/2         // A bit lower capacity to world and dog
    else if softtouch then
      sidemargin=SIDEMARGIN            // A5/A6 with splinogramms
    else if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||   \
      testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3) then
      sidemargin=SIDEMARGIN/2          // A5, A6 or S1
    else
      sidemargin=0.0
    endif
    if $LAY.probetype==1 then
      sidexmargin=sidemargin+KELVINMARGIN
      zdiff=CREPABS+KELVINMARGIN/2
    else
      sidexmargin=sidemargin
      zdiff=CREPABS
    endif
    Smartmean($LAY.nfing*2,inuse,cc,rr,&c,&r)
    fcmean[i]=c; frmean[i]=r
    nfailed=0
    for k=0,k<$LAY.nfing*2,k++ do      // For all heads
      if inuse[k]==0 continue
      // Check for invalid analog keys on the on-head boards (MAX333A marked
      // as MAX333).
      if cexp[i]>100.0 && cexp[i]<500.0 &&                                     \
        (Getsigma(fsin[k,i])>fnoise*2 && Getsigma(fcos[k,i])>fnoise*2) then
        bad333[k]=1
        bad333[32]=1
      endif
      if cexp[i]>200000.0 && Getmean(fc[k,i])>cteor[i]*2.0 then
        bad333[k]=1
        bad333[32]=1
      endif
      // New script feature allows for some percentage of bad measurements in
      // the certification mode. Check number of bad measurements.
      for n=0,n<ntest,n++ do
        j=0
        if headfbad[k,i,n] then
          j=1;
        else if cexp[i]<30000.0 then
          if headfc[k,i,n]<zc*(1.0-CFACTOR)-cfctabs-sidemargin ||              \
            headfc[k,i,n]>zc*(1.0+CFACTOR)+cfctabs+sidemargin then j=1;
          else if headfc[k,i,n]<c*(1.0-crepeat)-CREPABS-sidexmargin ||         \
            headfc[k,i,n]>c*(1.0+crepeat)+CREPABS+sidexmargin then j=1;
          endif
        else if cexp[i]<300000.0 then
          if headfc[k,i,n]<zc*(1.0-CFACTORHI) ||                               \
            headfc[k,i,n]>zc*(1.0+CFACTORHI) then j=1;
          else if headfc[k,i,n]<c*(1.0-CFACTOR) ||                             \
            headfc[k,i,n]>c*(1.0+CFACTOR) then j=1;
          endif
        else
          if headfc[k,i,n]<c*(1.0-CFACTORHI) ||                                \
            headfc[k,i,n]>c*(1.0+CFACTORHI) then j=1;
          endif
        endif
        if cexp[i]<3000.0 then
          if Atan2(headfz[k,i,n]+CREPABS,zc)-phaseexp<(-phasedif) ||           \
            Atan2(headfz[k,i,n]-CREPABS,zc)-phaseexp>phasedif ||               \
            Abs(headfz[k,i,n]-r)>c*crepeat+zdiff+sidemargin then j=1;
          endif
        endif
        if j!=0 nfailed++
      enddo
      // Dependless on certification mode, report all detected errors.
      j=1; zmin=Getmin(fc[k][i]); zmax=Getmax(fc[k][i])
      sprintf(name,"%.3g %s",cexp[i]/factor[i],cunitname[units[i]])
      if cexp[i]<30000.0 then          // Over 30 nF C and repeatability worse
        if zmin<zc*(1.0-CFACTOR)-cfctabs-sidemargin ||                         \
          zmax>zc*(1.0+CFACTOR)+cfctabs+sidemargin then
          if extendederr==0 then
            Adderr(fcmd[i,k],0,k,                                              \
            "Measured capacity %s differs from expected",name)
          else
            if zmin<zc*(1.0-CFACTOR)-cfctabs-sidemargin then
              extr=zmin
            else
              extr=zmax
            endif
            Adderr(fcmd[i,k],0,k,                                              \
              "Measured capacity %.4g %s differs from expected %.4g..%.4g %s", \
              extr/factor[i],cunitname[units[i]],                              \
              (zc*(1.0-CFACTOR)-cfctabs-sidemargin)/factor[i],                 \
              (zc*(1.0+CFACTOR)+cfctabs+sidemargin)/factor[i],                 \
              cunitname[units[i]])
            ;
          endif
          j=0
        else if zmin<c*(1.0-crepeat)-CREPABS-sidemargin ||                     \
          zmax>c*(1.0+crepeat)+CREPABS+sidemargin then
          if extendederr==0 then
            Adderr(fcmd[i,k],0,k,"Capacity %s differs too much from mean",name)
          else
            if zmin<c*(1.0-crepeat)-CREPABS-sidemargin then
              extr=zmin
            else
              extr=zmax
            endif
            Adderr(fcmd[i,k],0,k,                                              \
              "Capacity %.4g %s differs too much from mean %.4g..%.4g %s",     \
              extr/factor[i],cunitname[units[i]],                              \
              (c*(1.0-crepeat)-CREPABS-sidemargin)/factor[i],                  \
              (c*(1.0+crepeat)+CREPABS+sidemargin)/factor[i],                  \
              cunitname[units[i]])
            ;
          endif
          j=0
        endif
        if certify==0 && zmax-zmin>c*crepeat+CREPABS+sidemargin then
          Adderr(fcmd[i,k],0,k,"Capacity %s is too unstable|(%.4g..%.4g %s)",  \
            name,zmin/factor[i],zmax/factor[i],cunitname[units[i]])
          j=0; nfailed++
        endif
      else if cexp[i]<300000.0 then
        if zmin<zc*(1.0-CFACTORHI) || zmax>zc*(1.0+CFACTORHI) then
          if extendederr==0 then
            Adderr(fcmd[i,k],0,k,                                              \
            "Measured capacity %s differs from expected",name)
          else
            if zmin<zc*(1.0-CFACTORHI) then
              extr=zmin
            else
              extr=zmax
            endif
            Adderr(fcmd[i,k],0,k,                                              \
              "Measured capacity %.4g %s differs from expected %.4g..%.4g %s", \
              extr/factor[i],cunitname[units[i]],                              \
              zc*(1.0-CFACTORHI)/factor[i],zc*(1.0+CFACTORHI)/factor[i],       \
              cunitname[units[i]])
            ;
          endif
          j=0
        else if zmin<c*(1.0-CFACTOR) || zmax>c*(1.0+CFACTOR) then
          if extendederr==0 then
            Adderr(fcmd[i,k],0,k,"Capacity %s differs too much from mean",name)
          else
            if zmin<c*(1.0-CFACTOR) then
              extr=zmin
            else
              extr=zmax
            endif
            Adderr(fcmd[i,k],0,k,                                              \
              "Capacity %.4g %s differs too much from mean %.4g..%.4g %s",     \
              extr/factor[i],cunitname[units[i]],                              \
              c*(1.0-CFACTOR)/factor[i],c*(1.0+CFACTOR)/factor[i],             \
              cunitname[units[i]])
            ;
          endif
          j=0
        endif
        if certify==0 && zmax-zmin>c*CREPHIGH then
          Adderr(fcmd[i,k],0,k,"Capacity %s is too unstable|(%.4g..%.4g %s)",  \
          name,zmin/factor[i],zmax/factor[i],cunitname[units[i]])
          j=0; nfailed++
        endif
      else
        if zmin<c*(1.0-CFACTORHI) || zmax>c*(1.0+CFACTORHI) then
          if extendederr==0 then
            Adderr(fcmd[i,k],0,k,                                              \
            "Measured capacity %s differs from expected",name)
          else
            if zmin<zc*(1.0-CFACTORHI) then
              extr=zmin
            else
              extr=zmax
            endif
            Adderr(fcmd[i,k],0,k,                                              \
              "Measured capacity %.4g %s differs from expected %.4g..%.4g %s", \
              extr/factor[i],cunitname[units[i]],                              \
              c*(1.0-CFACTORHI)/factor[i],c*(1.0+CFACTORHI)/factor[i],         \
              cunitname[units[i]])
            ;
          endif
          j=0
        endif
        if certify==0 && zmax-zmin>c*CFACTOR then
          Adderr(fcmd[i,k],0,k,"Capacity %s is too unstable|(%.4g..%.4g %s)",  \
          name,zmin/factor[i],zmax/factor[i],cunitname[units[i]])
          j=0; nfailed++
        endif
      endif
      if cexp[i]<3000.0 then
        if cexp[i]>1.0 then
          phdiff=Atan2(Getmin(fr[k][i])+CREPABS,zc)-phaseexp
          if phdiff<(-phasedif) then
            if extendederr==0 then
              Adderr(fcmd[i,k],0,k,                                            \
              "Phase differs too much from expected at %s",name)
            else
              Adderr(fcmd[i,k],0,k,                                            \
              "Phase %.4f rad differs too much from expected %.4f..%.4f at %s",\
              Atan2(Getmin(fr[k][i]),zc),                                      \
              phaseexp-phasedif,phaseexp+phasedif,name)
            endif
            j=0
          endif
          phdiff=Atan2(Getmax(fr[k][i])-CREPABS,zc)-phaseexp
          if phdiff>phasedif then
            if extendederr==0 then
              Adderr(fcmd[i,k],0,k,                                            \
              "Phase differs too much from expected at %s",name)
            else
              Adderr(fcmd[i,k],0,k,                                            \
              "Phase %.4f rad differs too much from expected %.4f..%.4f at %s",\
              Atan2(Getmax(fr[k][i]),zc),                                      \
              phaseexp-phasedif,phaseexp+phasedif,name)
            endif
            j=0
          endif
        endif
        if Abs(Getmin(fr[k][i])-r)>c*crepeat+zdiff+sidemargin ||               \
          Abs(Getmax(fr[k][i])-r)>c*crepeat+zdiff+sidemargin then
          if extendederr==0 then
            Adderr(fcmd[i,k],0,k,                                              \
            "Z component of %s differs too much from mean",name)
          else
            if Abs(Getmin(fr[k][i])-r)>c*crepeat+zdiff+sidemargin then
              extr=Getmin(fr[k][i])
            else
              extr=Getmax(fr[k][i])
            endif
            Adderr(fcmd[i,k],0,k,                                              \
            "Z component %.4g %s differs too much from mean %.4g..%.4g on %s", \
            extr/factor[i],cunitname[units[i]],                                \
            (r-c*crepeat-zdiff-sidemargin)/factor[i],                          \
            (r+c*crepeat+zdiff+sidemargin)/factor[i],name)
          endif
          j=0
        endif
      endif
      if Getsigma(fsin[k,i])>fnoise || Getsigma(fcos[k,i])>fnoise then
        if extendederr==0 then
          Adderr(fcmd[i,k],0,k,"High field noise at %s",name)
        else
          Adderr(fcmd[i,k],0,k,                                                \
          "High field noise %.1f / %.1f bits (allowed %g bits) at %s",         \
          Getsigma(fsin[k,i]),Getsigma(fcos[k,i]),fnoise,name)
        endif
        j=0
      endif
      fgood[k,i]=j
    enddo
    if nfailed>maxfailed then
      // Number of bad measurements is too high, mark capacity as bad.
      fgood[$LAY.nfing*2,i]=0
    endif
  enddo
  // Check results of quick capacity measurements.
  for i=0,i<nc,i++ do                  // For all capacities
    if allowquickc==0 break
    qgood[$LAY.nfing*2,i]=1
    if excluded[i]!=0 continue
    for k=0,k<$LAY.nfing*2,k++ do      // For all heads
      if inuse[k]==0 continue
      cc[k]=Getmean(qc[k][i])
      rr[k]=Getmean(qr[k][i])
    enddo
    // When capacity is measured on side effect field, there are strong side
    // effects between pads and contacting heads. I take it into account by
    // allowing additional capacity margin. A5/A6 soft touch splinogramms also
    // feature strong side effects due to inadequate shielding. A5/A6 with
    // normal needles on splinogramm-ready parallelograms also have higher
    // parasitic capacity to board.
    if Stricmp(cap[i]+1,"SIDER")==0 then
      sidemargin=SIDERMARGIN           // High capacity to rest of world
    else if (testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3) &&   \
      Stricmp(cap[i]+1,"C27P")==0 then
      sidemargin=SIDERMARGIN/2         // A bit lower capacity to world and dog
    else if softtouch then
      sidemargin=SIDEMARGIN            // A5/A6 with splinogramms
    else if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6) then
      sidemargin=SIDEMARGIN/2          // A5 or A6
    else
      sidemargin=0.0
    endif
    if $LAY.probetype==1 then
      sidexmargin=sidemargin+KELVINMARGIN
      zdiff=CREPABS+KELVINMARGIN/2
    else
      sidexmargin=sidemargin
      zdiff=CREPABS
    endif
    Smartmean($LAY.nfing*2,inuse,cc,rr,&c,&r)
    qcmean[i]=c; qrmean[i]=r
    nfailed=0
    sprintf(name,"%.3g %s",cexp[i]/factor[i],cunitname[units[i]])
    for k=0,k<$LAY.nfing*2,k++ do      // For all heads
      if inuse[k]==0 continue
      // New script feature allows for some percentage of bad measurements in
      // the certification mode. Check number of bad measurements.
      for n=0,n<ntest,n++ do
        j=0
        if headqbad[k,i,n] then
          j=1
        endif
        if headqc[k,i,n]<cexp[i]*(1.0-CFACTOR)-CFCTABS-sidemargin ||           \
          headqc[k,i,n]>cexp[i]*(1.0+CFACTOR)+CFCTABS+sidemargin j=1
        // Low capacitors in the extended area may differ from one rail to
        // another, don't compare them with mean.
        if cap[i][0]!='X' &&                                                   \
          (headqc[k,i,n]<c*(1.0-crepeat)-CREPABS-sidexmargin ||                \
          headqc[k,i,n]>c*(1.0+crepeat)+CREPABS+sidexmargin) j=1
        if cexp[i]<3000.0 && cexp[i]>1.0 &&                                    \
          (Atan2(headqz[k,i,n]+CREPABS,cc[k])-phaseexp<(-phasedif) ||          \
          Atan2(headqz[k,i,n]-CREPABS,cc[k])-phaseexp>phasedif) j=1
        if cexp[i]<3000.0 &&                                                   \
          Abs(headqz[k,i,n]-r)>c*crepeat+zdiff+sidemargin j=1
        if j!=0 nfailed++
      enddo
      // Dependless on certification mode, report all detected errors.
      j=1
      zmin=Getmin(qc[k][i])
      zmax=Getmax(qc[k][i])
      if zmin<cexp[i]*(1.0-CFACTOR)-cfctabs-sidemargin ||                      \
        zmax>cexp[i]*(1.0+CFACTOR)+cfctabs+sidemargin then
        if extendederr==0 then
          Adderr(qcmd[i,k],1,k,                                                \
          "Measured capacity %s differs from expected",name)
        else
          if zmin<cexp[i]*(1.0-CFACTOR)-cfctabs-sidemargin then
            extr=zmin
          else
            extr=zmax
          endif
          Adderr(qcmd[i,k],1,k,                                                \
            "Measured capacity %.4g %s differs from expected %.4g..%.4g %s",   \
            extr/factor[i],cunitname[units[i]],                                \
            (cexp[i]*(1.0-CFACTOR)-cfctabs-sidemargin)/factor[i],              \
            (cexp[i]*(1.0+CFACTOR)+cfctabs+sidemargin)/factor[i],              \
            cunitname[units[i]])
          ;
        endif
        j=0
      endif
      if cap[i][0]!='X' && (zmin<c*(1.0-crepeat)-CREPABS-sidexmargin ||        \
        zmax>c*(1.0+crepeat)+CREPABS+sidexmargin) then
        if extendederr==0 then
          Adderr(qcmd[i,k],1,k,"Capacity %s differs too much from mean",name)
        else
          if zmin<c*(1.0-crepeat)-CREPABS-sidexmargin then
            extr=zmin
          else
            extr=zmax
          endif
          Adderr(qcmd[i,k],1,k,                                                \
            "Capacity %.4g %s differs too much from mean %.4g..%.4g %s",       \
            extr/factor[i],cunitname[units[i]],                                \
            (c*(1.0-crepeat)-CREPABS-sidexmargin)/factor[i],                   \
            (c*(1.0+crepeat)+CREPABS+sidexmargin)/factor[i],                   \
            cunitname[units[i]])
          ;
        endif
        j=0
      endif
      if certify==0 && cap[i][0]!='X' &&                                       \
        zmax-zmin>c*crepeat+CREPABS+sidexmargin then
        Adderr(qcmd[i,k],1,k,"Capacity %s is too unstable|(%.4g..%.4g %s)",    \
          name,zmin/factor[i],zmax/factor[i],cunitname[units[i]])
        j=0; nfailed++
      endif
      if cexp[i]<3000.0 then
        if cexp[i]>1.0 then
          phdiff=Atan2(Getmin(qr[k][i])+CREPABS,cc[k])-phaseexp
          if phdiff<(-phasedif) then
            if extendederr==0 then
              Adderr(qcmd[i,k],1,k,                                            \
              "Phase at %s differs too much from expected",name)
            else
              Adderr(qcmd[i,k],1,k,                                            \
              "Phase %.4f rad differs too much from expected %.4f..%.4f at %s",\
              Atan2(Getmin(qr[k][i]),cc[k]),                                   \
              phaseexp-phasedif,phaseexp+phasedif,name)
            endif
            j=0
          endif
          phdiff=Atan2(Getmax(qr[k][i])-CREPABS,cc[k])-phaseexp
          if phdiff>phasedif then
            if extendederr==0 then
              Adderr(qcmd[i,k],1,k,                                            \
              "Phase at %s differs too much from expected",name)
            else
              Adderr(qcmd[i,k],1,k,                                            \
              "Phase %.4f rad differs too much from expected %.4f..%.4f at %s",\
              Atan2(Getmax(qr[k][i]),cc[k]),                                   \
              phaseexp-phasedif,phaseexp+phasedif,name)
            endif
            j=0
          endif
        endif
        if cap[i][0]!='X' &&                                                   \
          (Abs(Getmin(qr[k][i])-r)>c*crepeat+zdiff+sidemargin ||               \
          Abs(Getmax(qr[k][i])-r)>c*crepeat+zdiff+sidemargin)                  \
        then
          if extendederr==0 then
            Adderr(qcmd[i,k],1,k,                                              \
            "Z component of %s differs too much from mean",name)
          else
            if Abs(Getmin(qr[k][i])-r)>c*crepeat+zdiff+sidemargin then
              extr=Getmin(qr[k][i])
            else
              extr=Getmax(qr[k][i])
            endif
            Adderr(qcmd[i,k],1,k,                                              \
            "Z component %.4g %s differs too much from mean %.4g..%.4g on %s", \
            extr/factor[i],cunitname[units[i]],                                \
            (r-c*crepeat-zdiff-sidemargin)/factor[i],                          \
            (r+c*crepeat+zdiff+sidemargin)/factor[i],name)
          endif
          j=0
        endif
      endif
      qgood[k,i]=j
    enddo
    if nfailed>maxfailed then
      // Number of bad measurements is too high, mark capacity as bad.
      qgood[$LAY.nfing*2,i]=0
    endif
  enddo
  good[0]=1; good[1]=1; good[2]=1
  good[3]=1; good[4]=1; good[5]=1
  if err==0 then                       // Display measured data on the screen
    for n=0,n<2,n++ do                 // Ordinary and fast capacity
      add hlist text=""
      add hlist text=""
      change hlist color=RED
      if n==0 then
        if usefield==0 then
          add hlist text=" This tester does not support field measurements"
          add hlist text=""
          continue
        endif
        if uselim then
          add hlist text=format("          CAPACITY MEASUREMENTS AT %g V",umax)
        else
          add hlist text="              CAPACITY MEASUREMENTS"
        endif
      else
        if allowquickc==0 then
          add hlist text="   This tester does not support quick capacity"
          add hlist text=""
          break
        endif
        if uselim then
          add hlist text=format("       QUICK CAPACITY MEASUREMENTS AT %g V",  \
          umax)
        else
          add hlist text="           QUICK CAPACITY MEASUREMENTS"
        endif
      endif
      add hlist text=""
      add hlist text="Expected     Mean    dMin    dMax   Z-comp   Pass"
      add hlist text=""
      k=$LAY.nfing*2
      m=0
      for i=0,i<nc,i++ do
        if excluded[i]!=0 continue
        if n==0 && (cap[i][0]=='X' || cap[i][0]=='Y') continue
        if n==0 then
          if ($LAY.config & 0x400)==0 && cexp[i]>=300.0 continue
          zc=fcmean[i]; zmin=Getmin(fc[k][i]); zmax=Getmax(fc[k][i])
          zr=frmean[i]; j=fgood[k,i]
        else
          zc=qcmean[i]; zmin=Getmin(qc[k][i]); zmax=Getmax(qc[k][i])
          zr=qrmean[i]; j=qgood[k,i]
        endif
        if j==0 good[n]=0
        if m==0 && (cap[i][0]=='X' || cap[i][0]=='Y') then
          add hlist text=""
          m=1
        endif
        f=factor[i]
        change hlist color=(j==0?LIGHTRED:BLACK)
        add hlist text=format("%5.3g %2s %8.4g %7.3g %7.3g %8.4g   %s",        \
        cexp[i]/f,cunitname[units[i]],zc/f,(zmin-zc)/f,(zmax-zc)/f,            \
        zr/f,j==0?"No":"Yes")
      enddo
    enddo
    if bad333[32]!=0 then
      change hlist color=LIGHTRED
      add hlist text=""
      add hlist text=""
      add hlist text="ATTENTION, please check your on-head boards. It's"
      add hlist text="possible that some of them contain chips  MAX333A"
      add hlist text="falsely labelled as  MAX333.  Suspicious on-heads"
      n=sprintf(s,"are: ")
      for k=0,k<$LAY.nfing*2,k++ do
        if inuse[k]==0 continue
        if bad333[k]==0 continue
        n=n+sprintf(s+n,"%i%c,",k/2,k & 1?'R':'L')
      enddo
      s[n-1]='.'
      add hlist text=s
    endif
    if firstdifferent then
      change hlist color=LIGHTRED
      add hlist text=""
      add hlist text=""
      add hlist text="ATTENTION, please check your on-head boards. Some"
      add hlist text="of them  report slightly  lower capacity  for the"
      add hlist text="first measurement after resistance  or soft reset"
      add hlist text="('ZERO' signal). Suspicious on-heads are:"
      add hlist text=""
      change hlist color=RED
      add hlist text="Head      First measurement   Next measurements"
      add hlist text=""
      change hlist color=LIGHTRED
      for k=0,k<$LAY.nfing*2,k++ do
        if inuse[k]==0 continue
        if Getcount(fcfirst[k])>=4 && Getcount(fcnext[k])>=4 &&                \
          Getxmean(fcfirst[k])<Getxmean(fcnext[k])*(1.0-CREPEAT/2.0) then
          add hlist text=format("%2i%s        %10.2f nF       %10.2f nF",      \
          k/2,k & 1?"R":"L",Getxmean(fcfirst[k])/1000.0,                       \
          Getxmean(fcnext[k])/1000.0)
        endif
      enddo
      add hlist text=""
      add hlist text="Update of embedded software (f_prog,bin) may help"
      add hlist text="to resolve this problem."
    endif
  endif
  if err==0 && usefield!=0 then
    good[2]=(nused*ntest-shorts0[0,$LAY.nfing*2]<=maxfailed) &&                \
      (nused*ntest-shorts10[0,$LAY.nfing*2]<=maxfailed) &&                     \
      (nused*ntest-opens10[0,$LAY.nfing*2]<=maxfailed)
    if allowvarshort!=0 then
      good[4]=(nused*ntest-shorts1[0,$LAY.nfing*2]<=maxfailed) &&              \
      (nused*ntest-shorts50[0,$LAY.nfing*2]<=maxfailed) &&                     \
      (nused*ntest-opens50[0,$LAY.nfing*2]<=maxfailed)
    endif
  endif
  if err==0 && allowquickc!=0 then
    good[3]=(nused*ntest-shorts0[1,$LAY.nfing*2]<=maxfailed) &&                \
      (nused*ntest-shorts10[1,$LAY.nfing*2]<=maxfailed) &&                     \
      (nused*ntest-opens10[1,$LAY.nfing*2]<=maxfailed)
    if allowvarshort!=0 then
      good[5]=(nused*ntest-shorts1[1,$LAY.nfing*2]<=maxfailed) &&              \
      (nused*ntest-shorts50[1,$LAY.nfing*2]<=maxfailed) &&                     \
      (nused*ntest-opens50[1,$LAY.nfing*2]<=maxfailed)
    endif
  endif
  if err==0 then
    if (good[0]==0 || good[1]==0 || good[2]==0 || good[3]==0 ||                \
      good[4]==0 || good[5]==0) && certify then
      i=Askrepeat("?Y2a?")
      if i<0 return -1
      if i==1 goto repeat
    endif
    if usefield!=0 then
      Summary(good[0],"Ordinary (field) capacity measurements")
      if allowvarshort==0 then
        Summary(good[2],"Detection of short to antenna (field)")
      else
        Summary(good[2],                                                       \
        "Detection of short to antenna (field, 10 MOhm threshold)")
        Summary(good[4],                                                       \
        "Detection of short to antenna (field, 50 MOhm threshold)")
      endif
    endif
    if allowquickc!=0 then
      Summary(good[1],"Quick capacity measurements")
      if allowvarshort==0 then
        Summary(good[3],"Detection of short to antenna (fast C)")
      else
        Summary(good[3],                                                       \
        "Detection of short to antenna (fast C, 10 MOhm threshold)")
        Summary(good[5],                                                       \
        "Detection of short to antenna (fast C, 50 MOhm threshold)")
      endif
    endif
  endif
  if err==0 && txtok!=0 then           // Write measured data to TXT protocol
    for n=0,n<3,n++ do                 // Field, fast, extended fast capacity
      if n==0 then
        if usefield==0 then
          fprintf(hlog,"\n                  This tester does not support ")
          fprintf(hlog,"field measurements.\n")
          continue
        endif
        fprintf(hlog,"\n                         ")
        fprintf(hlog,"   ?Y2a?\n")
        i0=0; i1=Min(nc,8)
      else if allowquickc==0 then
        fprintf(hlog,"\n             This tester does not support ")
        fprintf(hlog,"quick capacity measurements.\n")
        break
      else if n==1 then
        fprintf(hlog,"\n                         ")
        fprintf(hlog,"Quick capacity measurements\n")
        i0=0; i1=Min(nc,8)
      else if (romdata.features & BF_TYPE)==BF_TRIPOD then
        fprintf(hlog,"\n\n")
        i0=Min(nc,8); i1=nc
      else
        break
      endif
      if uselim!=0 && n<2 fprintf(hlog,                                        \
        "                          Test voltage is set to %g V\n",umax)
      if (n==0) then fprintf(hlog,"\n   C Nominal ");
      else fprintf(hlog,"\n             "); endif
      for i=i0,i<i1,i++ do             // For all capacities
        fprintf(hlog,"%8.3g",cexp[i]/factor[i])
      enddo
      if n==0 then
        fprintf(hlog,"\n  C Expected ");
        for i=i0,i<i1,i++ do           // For all capacities
          fprintf(hlog,"%8.3g",cteor[i]/factor[i])
        enddo
      endif
      fprintf(hlog,"\nHead  Limits ")
      for i=i0,i<i1,i++ do             // For all capacities
        fprintf(hlog,"%8s",cunitname[units[i]])
      enddo
      for k=0,k<=$LAY.nfing*2,k++ do   // For all heads and summary
        if k==$LAY.nfing*2 then
          fprintf(hlog,"\n\nAll     Mean ")
        else
          if inuse[k]==0 continue
          fprintf(hlog,"\n\n%2i%c     Mean ",k/2,(k & 1?'R':'L'))
        endif
        for i=i0,i<i1,i++ do
          if excluded[i]==0 &&                                                 \
            (n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0)                 \
          then
            if k<$LAY.nfing*2 then
              zc=(n==0?Getmean(fc[k][i]):Getmean(qc[k][i]))/factor[i]
            else
              zc=(n==0?fcmean[i]:qcmean[i])/factor[i]
            endif
            fprintf(hlog,"%8.4g",zc)
          else
            fprintf(hlog,"       -")
          endif
        enddo
        if logmode==0 then fprintf(hlog,"\n        Cmin ");
        else fprintf(hlog,"\n    Diff min "); endif
        for i=i0,i<i1,i++ do
          if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
            if excluded[i] then
              fprintf(hlog,"        ")
            else
              if n==0 then
                c=fcmean[i]; zmin=Getmin(fc[k][i])
              else
                c=qcmean[i]; zmin=Getmin(qc[k][i])
              endif
              f=factor[i]
              if logmode==1 then       // Differences
                fprintf(hlog,"%+8.3g",(zmin-c)/f)
              else if logmode==2 && c<25.0 then // Low diffs
                fprintf(hlog,"%+7.2gp",(zmin-c)/f)
              else if logmode==2 then  // Percentages
                percent=(zmin-c)/c*100.0
                if percent>99.0 then fprintf(hlog,"   > 99%%");
                else if percent<(-99.0) then fprintf(hlog,"   <-99%%");
                else fprintf(hlog,"%+7.2g%%",percent); endif
              else                     // Absolute values
                fprintf(hlog,"%8.4g",zmin/f)
              endif
            endif
          endif
        enddo
        if logmode==0 then fprintf(hlog,"\n        Cmax ");
        else fprintf(hlog,"\n    Diff max "); endif
        for i=i0,i<i1,i++ do
          if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
            if excluded[i] then
              fprintf(hlog,"        ")
            else
              if n==0 then
                c=fcmean[i]; zmax=Getmax(fc[k][i])
              else
                c=qcmean[i]; zmax=Getmax(qc[k][i])
              endif
              f=factor[i]
              if logmode==1 then       // Differences
                fprintf(hlog,"%+8.3g",(zmax-c)/f)
              else if logmode==2 && c<25.0 then // Low diffs
                fprintf(hlog,"%+7.2gp",(zmax-c)/f)
              else if logmode==2 then  // Percentages
                percent=(zmax-c)/c*100.0
                if percent>99.0 then fprintf(hlog,"   > 99%%");
                else if percent<(-99.0) then fprintf(hlog,"   <-99%%");
                else fprintf(hlog,"%+7.2g%%",percent); endif
              else                     // Absolute values
                fprintf(hlog,"%8.4g",zmax/f)
              endif
            endif
          endif
        enddo
        if k==$LAY.nfing*2 then
          fprintf(hlog,"\n       Sigma ")
          for i=i0,i<i1,i++ do
            if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
              if excluded[i] then
                fprintf(hlog,"        ")
              else
                if n==0 then zsigma=Getsigma(fc[k][i]);
                else zsigma=Getsigma(qc[k][i]); endif
                fprintf(hlog,"%8.3g",zsigma/factor[i])
              endif
            endif
          enddo
        endif
        fprintf(hlog,"\n           Z ")
        for i=i0,i<i1,i++ do
          if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
            if excluded[i] then
              fprintf(hlog,"        ")
            else if n>0 && cexp[i]>7500.0 then
              fprintf(hlog,"       -")
            else                       // Z component available
              if n==0 then zr=(k==$LAY.nfing*2?frmean[i]:Getmean(fr[k][i]))
              else zr=(k==$LAY.nfing*2?qrmean[i]:Getmean(qr[k][i])); endif
              fprintf(hlog,"%8.4g",zr/factor[i])
            endif
          endif
        enddo
        if n==0 && k<$LAY.nfing*2 then
          fprintf(hlog,"\n     F noise ");
          for i=i0,i<i1,i++ do
            if excluded[i] then
              fprintf(hlog,"        ")
            else
              fprintf(hlog,"%8.2g",                                            \
              Max(Getsigma(fsin[k,i]),Getsigma(fcos[k,i])))
            endif
          enddo
        endif
        if k==$LAY.nfing*2 then
          if logmode==0 then fprintf(hlog,"\n        Zmin ");
          else fprintf(hlog,"\n    Zdif min "); endif
          for i=i0,i<i1,i++ do
            if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
              if excluded[i]!=0 || (n>0 && cexp[i]>7500.0) then
                fprintf(hlog,"        ")
              else                     // Z component available
                if n==0 then
                  c=fcmean[i]; zr=frmean[i]; zmin=Getmin(fr[k][i])
                else
                  c=qcmean[i]; zr=qrmean[i]; zmin=Getmin(qr[k][i])
                endif
                f=factor[i]
                if logmode==1 then     // Differences
                  fprintf(hlog,"%+8.3g",(zmin-zr)/f)
                else if logmode==2 && c<25.0 then // Low diffs
                  fprintf(hlog,"%+7.2gp",(zmin-zr)/f)
                else if logmode==2 then // Percentages to capacity
                  percent=(zmin-zr)/c*100.0
                  if percent>99.0 then fprintf(hlog,"   > 99%%");
                  else if percent<(-99.0) then fprintf(hlog,"   <-99%%");
                  else fprintf(hlog,"%+7.2g%%",percent); endif
                else                   // Absolute values
                  fprintf(hlog,"%8.4g",zmin/f)
                endif
              endif
            endif
          enddo
          if logmode==0 then fprintf(hlog,"\n        Zmax ");
          else fprintf(hlog,"\n    Zdif max "); endif
          for i=i0,i<i1,i++ do
            if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
              if excluded[i] || (n>0 && cexp[i]>7500.0) then
                fprintf(hlog,"        ")
              else                     // Z component available
                if n==0 then
                  c=fcmean[i]; zr=frmean[i]; zmax=Getmax(fr[k][i])
                else
                  c=qcmean[i]; zr=qrmean[i]; zmax=Getmax(qr[k][i])
                endif
                f=factor[i]
                if logmode==1 then     // Differences
                  fprintf(hlog,"%+8.3g",(zmax-zr)/f)
                else if logmode==2 && c<25.0 then // Low diffs
                  fprintf(hlog,"%+7.2gp",(zmax-zr)/f)
                else if logmode==2 then // Percentages to capacity
                  percent=(zmax-zr)/c*100.0
                  if percent>99.0 then fprintf(hlog,"   > 99%%");
                  else if percent<(-99.0) then fprintf(hlog,"   <-99%%");
                  else fprintf(hlog,"%+7.2g%%",percent); endif
                else                   // Absolute values
                  fprintf(hlog,"%8.4g",zmax/f)
                endif
              endif
            endif
          enddo
          fprintf(hlog,"\n         Bad ")
          for i=i0,i<i1,i++ do
            if excluded[i] then
              fprintf(hlog,"        ")
            else if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
              fprintf(hlog,"%8i",n==0?fbad[i]:qbad[i])
            endif
          enddo
          fprintf(hlog,"\n       Short ")
          for i=i0,i<i1,i++ do
            if excluded[i] then
              fprintf(hlog,"        ")
            else if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
              fprintf(hlog,"%8i",n==0?fshort[i]:qshort[i])
            endif
          enddo
          if certify==0 && usestat==1 then
            fprintf(hlog,"\n   Tmean, ms ")
            for i=i0,i<i1,i++ do
              if n==0 then
                if excluded[i] || Getmean(tmeanf[i])==0.0 then
                  fprintf(hlog,"        ")
                else
                  fprintf(hlog,"%8.1f",Getmean(tmeanf[i]))
                endif
              else
                if excluded[i] || Getmean(tmeanq[i])==0.0 then
                  fprintf(hlog,"        ")
                else
                  fprintf(hlog,"%8.1f",Getmean(tmeanq[i]))
                endif
              endif
            enddo
          endif
        endif
      enddo
      fprintf(hlog,"\n\nPassed       ")
      for i=i0,i<i1,i++ do
        if excluded[i] then
          fprintf(hlog,"        ")
        else if n==0 && (($LAY.config & 0x400)!=0 || cexp[i]<300.0) then
          fprintf(hlog,"     %s",fgood[$LAY.nfing*2,i]==0?" No":"Yes")
        else if n>0 then
          fprintf(hlog,"     %s",qgood[$LAY.nfing*2,i]==0?" No":"Yes")
        endif
      enddo
      if logmode==2 && ((romdata.features & BF_TYPE)!=BF_TRIPOD || n!=1) then
        fprintf(hlog,"\n\nLetter 'p' means capacity in picofarades.")
      endif
      if n==0 then
        fprintf(hlog,"\n\n     Expected capacity is recalculated from the ")
        fprintf(hlog,"nominal taking  into  account\ninput resistance of ")
        fprintf(hlog,"the on-head amplifier.")
        if ($LAY.config & 0x400)==0 then
          fprintf(hlog,"  This tester  is not equipped with\nactive on-head  ")
          fprintf(hlog,"boards  and  so  is  unable to measure capacities ")
          fprintf(hlog,"over 300 pF\nduring ordinary field measurements.")
        endif
      endif
      if n==0 && bad333[32]!=0 then
        fprintf(hlog,"\n\n     ATTENTION, please check your on-head boards.  ")
        fprintf(hlog,"It's possible that some of\nthem contain chips MAX333A ")
        fprintf(hlog,"falsely labelled as MAX333.  Such on-heads feature\n")
        fprintf(hlog,"high  field noise in 100..500 pF range and falsify  ")
        fprintf(hlog,"capacity exceeding 50 nF.\nSuspicious heads are: ")
        j=0
        for k=0,k<$LAY.nfing*2,k++ do
          if inuse[k]==0 continue
          if bad333[k]==0 continue
          if j!=0 fprintf(hlog,",")
          fprintf(hlog,"%i%c",k/2,k & 1?'R':'L')
          j=1
        enddo
        fprintf(hlog,".\n")
      endif
      if n==0 && firstdifferent then
        fprintf(hlog,"\n\n     ATTENTION, please check the on-head boards. ")
        fprintf(hlog,"Some of them report slightly\nlower capacity for the ")
        fprintf(hlog,"first measurement after resistance or soft reset (ZERO")
        fprintf(hlog,"\nsignal). Suspicious on-heads are:\n\n")
        fprintf(hlog,"Head      First measurement   Next measurements\n\n")
        for k=0,k<$LAY.nfing*2,k++ do
          if inuse[k]==0 continue
          if Getcount(fcfirst[k])>=4 && Getcount(fcnext[k])>=4 &&              \
            Getxmean(fcfirst[k])<Getxmean(fcnext[k])*(1.0-CREPEAT/2.0) then
            fprintf(hlog,"%2i%s       %10.2f nF       %10.2f nF\n",            \
            k/2,k & 1?"R":"L",Getxmean(fcfirst[k])/1000.0,                     \
            Getxmean(fcnext[k])/1000.0)
          endif
        enddo
        fprintf(hlog,"\nUpdate of embedded software (f_prog,bin) may help to ")
        fprintf(hlog,"resolve this problem.\n")
      endif
      if (romdata.features & BF_TYPE)!=BF_TRIPOD || n!=1 then
        Flusherrlist(Min(n,1),1,0,-1)
        fprintf(hlog,"\n\n--------------------------------------")
        fprintf(hlog,"---------------------------------------\n")
      endif
    enddo
  endif
  if err==0 && rtfok!=0 then           // Write measured data to RTF protocol
    for n=0,n<3,n++ do                 // Field, fast, extended fast capacity
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      if n==0 then
        RAddtext("\n?Y2a?")
        if usefield==0 then
          RFmt(RTF_TIMES,RTF_NORMAL,12)
          RAddtext("\n\nThis tester does not support field measurements.\n")
          continue
        endif
        i0=0; i1=Min(nc,8); i2=8
      else if n==1 then
        RAddtext("\nQuick capacity measurements")
        if allowquickc==0 then
          RFmt(RTF_TIMES,RTF_NORMAL,12)
          RAddtext("\n\nThis tester does not support quick capacity ")
          RAddtext("measurements.\n")
          break
        endif
        i0=0; i1=Min(nc,8); i2=8
      else if (romdata.features & BF_TYPE)==BF_TRIPOD then
        i0=Min(nc,8); i1=nc; i2=16
      else
        break
      endif
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      if uselim!=0 && n<2 RAddfmt("\nTest voltage is set to %g V",umax)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,6.5)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0); RAddtext("\nHead")
      if n==0 then                     // Field capacity
        RCell(RTF_RIGHT|RTF_THINBRD,17.0);
        RAddtext("Nominal \nExpected \nUnits ")
        for i=i0,i<i2,i++ do
          RCell(RTF_CENTERED|RTF_THINBRD,16.0)
          if i>=i1 continue
          RAddfmt("%.3g\n(%.3g)\n%s",                                          \
          cexp[i]/factor[i],cteor[i]/factor[i],cunitname[units[i]])
        enddo
      else                             // Quick capacity
        RCell(RTF_CENTERED|RTF_THINBRD,17.0);
        RAddtext("\nLimits")
        for i=i0,i<i2,i++ do
          RCell(RTF_CENTERED|RTF_THINBRD,16.0)
          if i>=i1 continue
          RAddfmt("%.3g\n%s",cexp[i]/factor[i],cunitname[units[i]])
        enddo
      endif
      for k=0,k<=$LAY.nfing*2,k++ do   // For all heads and summary
        if k<$LAY.nfing*2 && inuse[k]==0 continue
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,16.0)
        RCell(RTF_CENTERED|RTF_THINBRD,14.0)
        if k==$LAY.nfing*2 then
          RAddtext("\n\n\nAll heads")
        else
          RAddfmt("\n%i\n(%i%c)",k,k/2,(k & 1?'R':'L'))
        endif
        RCell(RTF_RIGHT|RTF_THINBRD,17.0)
        RAddtext("Mean \n")
        RAddtext(logmode==0?"Cmin \nCmax ":"Diff min \nDiff max ")
        if k==$LAY.nfing*2 then
          RFmt(RTF_SYMBOL,RTF_NORMAL,9)
          RAddtext("\ns ")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
        RAddtext("\nZ ")
        if n==0 && k<$LAY.nfing*2 then
          RAddtext("\nF noise ")
        endif
        if k==$LAY.nfing*2 then
          RAddtext(logmode==0?"\nZmin \nZmax ":"\nZdif min \nZdif max ")
          RAddtext("\nBad \nShort ")
          if certify==0 && usestat==1 RAddtext("\ndT, ms ")
        endif
        for i=i0,i<i2,i++ do
          RCell(RTF_CENTERED|RTF_THINBRD,16.0)
          if i>=i1 continue
          if excluded[i]!=0 then
            RAddtext("-")
          else if n>0 || ($LAY.config & 0x400)!=0 || cexp[i]<300.0 then
            if n==0 then
              c=fcmean[i]
              zc=(k==$LAY.nfing*2?c:Getmean(fc[k][i]))
              zmin=Getmin(fc[k][i]); zmax=Getmax(fc[k][i])
              zsigma=Getsigma(fc[k][i]);
              zr=(k==$LAY.nfing*2?frmean[i]:Getmean(fr[k][i]))
              RFmt(RTF_TIMES,fgood[k,i]==0?RTF_BOLD:RTF_NORMAL,9)
            else
              c=qcmean[i]
              zc=(k==$LAY.nfing*2?c:Getmean(qc[k][i]))
              zmin=Getmin(qc[k][i]); zmax=Getmax(qc[k][i])
              zsigma=Getsigma(qc[k][i])
              zr=(k==$LAY.nfing*2?qrmean[i]:Getmean(qr[k][i]))
              RFmt(RTF_TIMES,qgood[k,i]==0?RTF_BOLD:RTF_NORMAL,9)
            endif
            f=factor[i]
            j=sprintf(s,"%.4g\n",zc/f)
            if logmode==1 then         // Differences
              j=j+sprintf(s+j,"%+.3g\n%+.3g",(zmin-c)/f,(zmax-c)/f)
            else if logmode==2 && c<25.0 then // Low diffs
              j=j+sprintf(s+j,"%+.2g pF\n%+.2g pF",(zmin-c)/f,(zmax-c)/f)
            else if logmode==2 then    // Percentages
              percent=(zmin-c)/c*100.0
              if percent>99.0 then j=j+sprintf(s+j,"> 99%%\n");
              else if percent<(-99.0) then j=j+sprintf(s+j,"<-99%%\n");
              else j=j+sprintf(s+j,"%+.2g%%\n",percent); endif
              percent=(zmax-c)/c*100.0
              if percent>99.0 then j=j+sprintf(s+j,"> 99%%");
              else if percent<(-99.0) then j=j+sprintf(s+j,"<-99%%");
              else j=j+sprintf(s+j,"%+.2g%%",percent); endif
            else                       // Absolute values
              j=j+sprintf(s+j,"%.4g\n%.4g",zmin/f,zmax/f)
            endif
            j=j+sprintf(s+j,"\n")
            if k==$LAY.nfing*2 then
              j=j+sprintf(s+j,"%.3g\n",zsigma/f)
            endif
            if n>0 && cexp[i]>7500.0 then
              j=j+sprintf(s+j,"-")     // No Z component
            else
              j=j+sprintf(s+j,"%.4g",zr/f)
            endif
            if n==0 && k<$LAY.nfing*2 then
              j=j+sprintf(s+j,"\n%.2g",                                        \
              Max(Getsigma(fsin[k,i]),Getsigma(fcos[k,i])))
            endif
            if k==$LAY.nfing*2 then
              if n>0 && cexp[i]>7500.0 then
                j=j+sprintf(s+j,"\n\n")
              else
                if n==0 then
                  c=fcmean[i]
                  zr=Getmean(fr[k][i])
                  zmin=Getmin(fr[k][i]); zmax=Getmax(fr[k][i])
                  RFmt(RTF_TIMES,fgood[k,i]==0?RTF_BOLD:RTF_NORMAL,9)
                else
                  c=qcmean[i]
                  zr=Getmean(qr[k][i])
                  zmin=Getmin(qr[k][i]); zmax=Getmax(qr[k][i])
                  RFmt(RTF_TIMES,qgood[k,i]==0?RTF_BOLD:RTF_NORMAL,9)
                endif
                f=factor[i]
                j=j+sprintf(s+j,"\n")
                if logmode==1 then     // Differences
                  j=j+sprintf(s+j,"%+.3g\n%+.3g",(zmin-zr)/f,(zmax-zr)/f)
                else if logmode==2 && c<25.0 then // Low diffs
                  j=j+sprintf(s+j,"%+.2g pF\n%+.2g pF",(zmin-zr)/f,(zmax-zr)/f)
                else if logmode==2 then // Percentages to capacity
                  percent=(zmin-zr)/c*100.0
                  if percent>99.0 then j=j+sprintf(s+j,"> 99%%\n");
                  else if percent<(-99.0) then j=j+sprintf(s+j,"<-99%%\n");
                  else j=j+sprintf(s+j,"%+.2g%%\n",percent); endif
                  percent=(zmax-zr)/c*100.0
                  if percent>99.0 then j=j+sprintf(s+j,"> 99%%");
                  else if percent<(-99.0) then j=j+sprintf(s+j,"<-99%%");
                  else j=j+sprintf(s+j,"%+.2g%%",percent); endif
                else                   // Absolute values
                  j=j+sprintf(s+j,"%.4g\n%.4g",zmin/f,zmax/f)
                endif
              endif
              j=j+sprintf(s+j,"\n%i",n==0?fbad[i]:qbad[i])
              j=j+sprintf(s+j,"\n%i",n==0?fshort[i]:qshort[i])
              if certify==0 && usestat==1 then
                j=j+sprintf(s+j,"\n")
                if n==0 && Getmean(tmeanf[i])!=0.0 then
                  j=j+sprintf(s+j,"%.1f",Getmean(tmeanf[i]))
                else if n!=0 && Getmean(tmeanq[i])!=0.0 then
                  j=j+sprintf(s+j,"%.1f",Getmean(tmeanq[i]))
                endif
              endif
            endif
            RAddtext(s)
          else
            RAddtext("\n\n\n-")
          endif
        enddo
      enddo
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0); RAddtext("Passed")
      RCell(RTF_CENTERED|RTF_THINBRD,17.0)
      for i=i0,i<i2,i++ do             // For all capacities
        RCell(RTF_CENTERED|RTF_THINBRD,16.0)
        if i>=i1 continue
        if excluded[i]!=0 then
          RAddtext("-")
        else if n==0 && (($LAY.config & 0x400)!=0 || cexp[i]<300.0) then
          RAddtext(fgood[$LAY.nfing*2,i]==0?"No":"Yes")
        else if n>0 then
          RAddtext(qgood[$LAY.nfing*2,i]==0?"No":"Yes")
        endif
      enddo
      REndtable()
      if n==0 then
        RAddtext("\tExpected capacity is recalculated from the nominal taking ")
        RAddtext("into account input resistance of the on-head amplifier. ")
        if ($LAY.config & 0x400)==0 then
          RAddtext("This tester is not equipped with active on-head boards ")
          RAddtext("and therefore unable to measure capacities over 300 pF ")
          RAddtext("during ordinary field measurements.")
        endif
      endif
      if n==0 && bad333[32]!=0 then
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("\n\n\tATTENTION, ")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddtext("please check your on-head boards. It's possible that some ")
        RAddtext("of them contain chips MAX333A falsely labelled as MAX333. ")
        RAddtext("Such on-heads feature high field noise in 100..500 pF ")
        RAddtext("range and falsify capacities exceeding 50 nF. Suspicious ")
        RAddtext("heads are: ")
        j=0
        for k=0,k<$LAY.nfing*2,k++ do
          if inuse[k]==0 continue
          if bad333[k]==0 continue
          if j!=0 RAddtext(", ")
          RAddfmt("%i%c",k/2,k & 1?'R':'L')
          j=1
        enddo
        RAddtext(".")
      endif
      if n==0 && firstdifferent then
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("\n\n\tATTENTION, ")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddtext("please check your on-head boards. Some of them report ")
        RAddtext("slightly lower capacity for the first measurement after ")
        RAddtext("resistance or soft reset (ZERO signal). Suspicious on-")
        RAddtext("heads are:\n")
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Head")
        RCell(RTF_CENTERED|RTF_THINBRD,30.0); RAddtext("First measurement, nF")
        RCell(RTF_CENTERED|RTF_THINBRD,30.0); RAddtext("Next measurements, nF")
        for k=0,k<$LAY.nfing*2,k++ do
          if inuse[k]==0 continue
          if Getcount(fcfirst[k])>=4 && Getcount(fcnext[k])>=4 &&              \
            Getxmean(fcfirst[k])<Getxmean(fcnext[k])*(1.0-CREPEAT/2.0) then
            RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
            RCell(RTF_CENTERED|RTF_THINBRD,12.0)
            RAddfmt("%i%c",k/2,(k & 1)==0?'L':'R')
            RCell(RTF_CENTERED|RTF_THINBRD,30.0)
            RAddfmt("%.2f",Getxmean(fcfirst[k])/1000.0)
            RCell(RTF_CENTERED|RTF_THINBRD,30.0)
            RAddfmt("%.2f",Getxmean(fcnext[k])/1000.0)
          endif
        enddo
        REndtable()
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddtext("\n\tUpdate of embedded software (")
        RFmt(RTF_TIMES,RTF_ITALIC,9)
        RAddtext("f_prog,bin")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddtext(") may help to resolve this problem.\n")
      endif
      if (romdata.features & BF_TYPE)!=BF_TRIPOD || n!=1 then
        Flusherrlist(Min(n,1),2,0,-1)
      endif
    enddo
  endif
  if err==0 then
    Startexplanation()
    Explain("Comments to the tables above: Tests include as many as ")
    if usefield!=0 then
      Explain("%i ordinary ",nmeasf)
    endif
    if usefield==0 && allowquickc!=0 then
      Explain("%i quick ",nmeasq)
    else if allowquickc!=0 then
      Explain("and %i quick ",nmeasq)
    endif
    Explain("capacity measurements. Capacity test is passed when ")
    if maxfailed==0 then
      Explain("(a) all measurements are stable and reliable ")
    else
      Explain("total number of bad measurements for each capacitor is at ")
      Explain("most %i (out of %i). Measurement ",maxfailed,ntest*nused)
      Explain("is good if (a) data is stable and reliable ")
    endif
    Explain("(no shorts to antenna, multiplexer is not overloaded); (b) for ")
    Explain("capacitors up to 30 nF, difference between measured and expected ")
    Explain("capacity doesn't exceed %g%% + %g pF; ",CFACTOR*100.0,cfctabs)
    Explain("(c) difference between measured and mean capacity is less than ")
    Explain("%g%% + %g pF",crepeat*100,CREPABS)
    if ($LAY.config & 0x400)!=0 && usefield!=0 then
      Explain(" (up to %g%% for ordinary measurements ",CFACTORHI*100)
      Explain("over 30 nF)")
    endif
    Explain("; (d) difference between measured and mean Z component is less ")
    Explain("than %g%% of mean capacity + %g pF; ",crepeat*100.0,CREPABS)
    if usefield==0 then
      Explain("and ")
    endif
    Explain("(e) for capacitors up to 3 nF, phase (cosine/sine) lies in ")
    Explain("range %g .. %g",phaseexp-phasedif,phaseexp+phasedif)
    if usefield!=0 then
      Explain("; and (f) field noise does not exceed %g bits",fnoise)
    endif
    Explain(". Mean values do not include heads with highest deviations. ")
    if allowquickc!=0 then
      Explain("Starting from approx. 7 nF, quick capacity measurements use ")
      Explain("charge/discharge technique, so Z component is unavailable.")
    endif
    if uselim then
      Explain("\nAntenna voltage in this test was set to %g V.",umax)
    endif
    for j=0,j<nc,j++ do                // Find pad SIDER
      if Strcmp(cap[j]+1,"SIDER")==0 break
    enddo
    if testertype==TT_S2 && j<nc && excluded[j] then
      Explain("\nPad %.1f pF is not a real capacitor, it is formed ",cexp[j])
      Explain("by the printed patterns on the OlliBoard. Due to the low ")
      Explain("distance between the board and the moving heads, its measured ")
      Explain("capacity strongly depends on the position of the heads. ")
      Explain("Therefore this capacitor is excluded from the test.")
    else if (testertype==TT_S3 || testertype==TT_A8) && j<nc && excluded[j] then
      Explain("\nPad %.1f pF is not a real capacitor, it is formed ",cexp[j])
      Explain("by the printed patterns on the OlliBoard and therefore ")
      Explain("strongly influenced by shuttle. This capacitor is excluded ")
      Explain("from the test.")
    else if softtouch then
      // A5/A6 with soft touch needles (splinogramms).
      Explain("\nDue to strong parasitic capacity between soft touch ")
      Explain("needle, board and moving heads, limits for low capacitors ")
      Explain("are extended by additional %.3f pF.",SIDEMARGIN)
    else if j<nc then
      Explain("\nDue to strong parasitic capacity between heads and ")
      Explain("board, limits for capacitor %.1f pF are ",cexp[j])
      Explain("extended by %.3f pF.",SIDERMARGIN)
    endif
    if $LAY.probetype==1 then
      Explain("\nKelvin needles may have different own capacities to antenna, ")
      Explain("which are strongly position-dependent. Test allows for ")
      Explain("head-to-head differences up to %.3f pF.",KELVINMARGIN)
    endif
    if certify==0 then
      Explain("\nMean duration of measurements is in milliseconds and does ")
      Explain("not include X-Y or Z movements.")
    endif
    Endexplanation()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------")
      fprintf(hlog,"---------------------------------------\n")
    endif
  endif
  if err==0 && txtok!=0 then           // Write measured data to TXT protocol
    for q=0,q<2,q++ do
      if q==0 then
        if usefield==0 continue
        Strcpy(mtype,"field")
      else
        if allowquickc==0 break
        Strcpy(mtype,"fast C")
      endif
      if allowvarshort then
        fprintf(hlog,"\n                 Shorts to antenna (%s, ",mtype)
        fprintf(hlog,"threshold 10 MOhm)\n")
      else
        fprintf(hlog,"\n                               Shorts to antenna ")
        fprintf(hlog,"(%s)\n",mtype)
      endif
      if uselim fprintf(hlog,                                                  \
        "                          Test voltage is set to %g V\n",umax)
      fprintf(hlog,"\n   Head     Shorts at 0 Ohm    Shorts at 10 M    ")
      fprintf(hlog,"Opens at 47 M     Passed\n")
      for k=0,k<=$LAY.nfing*2,k++ do   // For all heads and summary
        if k==$LAY.nfing*2 then
          fprintf(hlog,"\n   All    ")
        else
          if inuse[k]==0 continue
          fprintf(hlog,"\n%5i%c    ",k/2,(k & 1?'R':'L'))
        endif
        j=1
        n=(k==$LAY.nfing*2?nused*ntest:ntest)
        if (k==$LAY.nfing*2 && k*ntest-shorts0[q,k]>maxfailed) ||              \
          (k!=$LAY.nfing*2 && shorts0[q,k]!=ntest) j=0
        fprintf(hlog,"%7i of %3i",shorts0[q,k],n)
        if (k==$LAY.nfing*2 && k*ntest-shorts10[q,k]>maxfailed) ||             \
          (k!=$LAY.nfing*2 && shorts10[q,k]!=ntest) j=0
        fprintf(hlog,"%11i of %3i",shorts10[q,k],n)
        if (k==$LAY.nfing*2 && k*ntest-opens10[q,k]>maxfailed) ||              \
          (k!=$LAY.nfing*2 && opens10[q,k]!=ntest) j=0
        fprintf(hlog,"%11i of %3i",opens10[q,k],n)
        fprintf(hlog,"        %s",j==0?"No":"Yes")
      enddo
      fprintf(hlog,"\n\n   Passed   ")
      j=1
      if nused*ntest-shorts0[q,$LAY.nfing*2]>maxfailed then
        j=0; fprintf(hlog,"          No")
      else
        fprintf(hlog,     "         Yes")
      endif
      if nused*ntest-shorts10[q,$LAY.nfing*2]>maxfailed then
        j=0; fprintf(hlog,"                No")
      else
        fprintf(hlog,     "               Yes")
      endif
      if nused*ntest-opens10[q,$LAY.nfing*2]>maxfailed then
        j=0; fprintf(hlog,"                No")
      else
        fprintf(hlog,     "               Yes")
      endif
      fprintf(hlog,"        %s",j==0?"No!":"Yes!")
      if allowvarshort then
        fprintf(hlog,"\n\n                 Shorts to antenna (%s, ",mtype)
        fprintf(hlog,"threshold 50 MOhm)\n")
        if uselim fprintf(hlog,                                                \
          "                          Test voltage is set to %g V\n",umax)
        fprintf(hlog,"\n   Head     Shorts at 0 Ohm    Shorts at 47 M    ")
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          fprintf(hlog,"Opens at OPEN     Passed\n")
        else
          fprintf(hlog,"Opens at 200 M    Passed\n")
        endif
        for k=0,k<=$LAY.nfing*2,k++ do // For all heads and summary
          if k==$LAY.nfing*2 then
            fprintf(hlog,"\n   All    ")
          else
            if inuse[k]==0 continue
            fprintf(hlog,"\n%5i%c    ",k/2,(k & 1?'R':'L'))
          endif
          j=1
          n=(k==$LAY.nfing*2?nused*ntest:ntest)
          if (k==$LAY.nfing*2 && k*ntest-shorts1[q,k]>maxfailed) ||            \
            (k!=$LAY.nfing*2 && shorts1[q,k]!=ntest) j=0
          fprintf(hlog,"%7i of %3i",shorts1[q,k],n)
          if (k==$LAY.nfing*2 && k*ntest-shorts50[q,k]>maxfailed) ||           \
            (k!=$LAY.nfing*2 && shorts50[q,k]!=ntest) j=0
          fprintf(hlog,"%11i of %3i",shorts50[q,k],n)
          if (k==$LAY.nfing*2 && k*ntest-opens50[q,k]>maxfailed) ||            \
            (k!=$LAY.nfing*2 && opens50[q,k]!=ntest) j=0
          fprintf(hlog,"%11i of %3i",opens50[q,k],n)
          fprintf(hlog,"        %s",j==0?"No":"Yes")
        enddo
        fprintf(hlog,"\n\n   Passed   ")
        j=1
        if nused*ntest-shorts1[q,$LAY.nfing*2]>maxfailed then
          j=0; fprintf(hlog,"          No")
        else
          fprintf(hlog,     "         Yes")
        endif
        if nused*ntest-shorts50[q,$LAY.nfing*2]>maxfailed then
          j=0; fprintf(hlog,"                No")
        else
          fprintf(hlog,     "               Yes")
        endif
        if nused*ntest-opens50[q,$LAY.nfing*2]>maxfailed then
          j=0; fprintf(hlog,"                No")
        else
          fprintf(hlog,     "               Yes")
        endif
        fprintf(hlog,"        %s",j==0?"No!":"Yes!")
      endif
    fprintf(hlog,"\n")
    enddo
    Flusherrlist(2,1,0,-1)
    fprintf(hlog,"\n---------------------------------------")
    fprintf(hlog,"--------------------------------------\n")
  endif
  if err==0 && rtfok!=0 then           // Write measured data to RTF protocol
    for q=0,q<2,q++ do
      if q==0 then
        if usefield==0 continue
        Strcpy(mtype,"field")
      else
        if allowquickc==0 break
        Strcpy(mtype,"fast C")
      endif
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      if allowvarshort then
        RAddfmt("\nShorts to antenna (%s, threshold 10 MOhm)",mtype)
      else
        RAddfmt("\nShorts to antenna (%s)",mtype)
      endif
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      if uselim RAddfmt("\nTest voltage is set to %g V",umax)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,5.0)
      RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Head")
      RCell(RTF_CENTERED|RTF_THINBRD,30.0); RAddtext("Shorts at 0 Ohm")
      RCell(RTF_CENTERED|RTF_THINBRD,30.0); RAddtext("Shorts at 10 M")
      RCell(RTF_CENTERED|RTF_THINBRD,30.0); RAddtext("Opens at 47 M")
      RCell(RTF_CENTERED|RTF_THINBRD,16.0); RAddtext("Passed")
      for k=0,k<=$LAY.nfing*2,k++ do   // For all heads and summary
        if k<$LAY.nfing*2 && inuse[k]==0 continue
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        if k==$LAY.nfing*2 then
          RAddtext("All heads")
        else
          RAddfmt("%i  (%i%c)",k,k/2,(k & 1?'R':'L'))
        endif
        j=1
        RCell(RTF_CENTERED|RTF_THINBRD,30.0)
        if (k==$LAY.nfing*2 && nused*ntest-shorts0[q,k]>maxfailed) ||          \
          (k!=$LAY.nfing*2 && shorts0[q,k]!=ntest) then
          RFmt(RTF_TIMES,RTF_BOLD,9); j=0
        else
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
        RAddfmt("%i out of %i",shorts0[q,k],k==$LAY.nfing*2?nused*ntest:ntest)
        RCell(RTF_CENTERED|RTF_THINBRD,30.0)
        if (k==$LAY.nfing*2 && nused*ntest-shorts10[q,k]>maxfailed) ||         \
          (k!=$LAY.nfing*2 && shorts10[q,k]!=ntest) then
          RFmt(RTF_TIMES,RTF_BOLD,9); j=0
        else
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
        RAddfmt("%i out of %i",shorts10[q,k],k==$LAY.nfing*2?nused*ntest:ntest)
        RCell(RTF_CENTERED|RTF_THINBRD,30.0)
        if (k==$LAY.nfing*2 && nused*ntest-opens10[q,k]>maxfailed) ||          \
          (k!=$LAY.nfing*2 && opens10[q,k]!=ntest) then
          RFmt(RTF_TIMES,RTF_BOLD,9); j=0
        else
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        endif
        RAddfmt("%i out of %i",opens10[q,k],k==$LAY.nfing*2?nused*ntest:ntest)
        RCell(RTF_CENTERED|RTF_THINBRD,16.0)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddtext(j==0?"No":"Yes")
      enddo
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Passed")
      j=1
      RCell(RTF_CENTERED|RTF_THINBRD,30.0)
      if nused*ntest-shorts0[q,$LAY.nfing*2]>maxfailed then
        RFmt(RTF_TIMES,RTF_BOLD,9); j=0; RAddtext("No")
      else
        RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("Yes")
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,30.0)
      if nused*ntest-shorts10[q,$LAY.nfing*2]>maxfailed then
        RFmt(RTF_TIMES,RTF_BOLD,9); j=0; RAddtext("No")
      else
        RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("Yes")
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,30.0)
      if nused*ntest-opens10[q,$LAY.nfing*2]>maxfailed then
        RFmt(RTF_TIMES,RTF_BOLD,9); j=0; RAddtext("No")
      else
        RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("Yes")
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,16.0)
      RFmt(RTF_TIMES,RTF_BOLD,9); RAddtext(j==0?"No!":"Yes!")
      REndtable()
      if allowvarshort then
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_BOLD,14)
        RAddfmt("\nShorts to antenna (%s, threshold 50 MOhm)",mtype)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        if uselim RAddfmt("\nTest voltage is set to %g V",umax)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,5.0)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Head")
        RCell(RTF_CENTERED|RTF_THINBRD,30.0); RAddtext("Shorts at 0 Ohm")
        RCell(RTF_CENTERED|RTF_THINBRD,30.0); RAddtext("Shorts at 47 M")
        RCell(RTF_CENTERED|RTF_THINBRD,30.0);
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          RAddtext("Opens at OPEN")
        else
          RAddtext("Opens at 200 M")
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,16.0); RAddtext("Passed")
        for k=0,k<=$LAY.nfing*2,k++ do // For all heads and summary
          if k<$LAY.nfing*2 && inuse[k]==0 continue
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          if k==$LAY.nfing*2 then
            RAddtext("All heads")
          else
            RAddfmt("%i  (%i%c)",k,k/2,(k & 1?'R':'L'))
          endif
          j=1
          RCell(RTF_CENTERED|RTF_THINBRD,30.0)
          if (k==$LAY.nfing*2 && nused*ntest-shorts1[q,k]>maxfailed) ||        \
            (k!=$LAY.nfing*2 && shorts1[q,k]!=ntest) then
            RFmt(RTF_TIMES,RTF_BOLD,9); j=0
          else
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
          RAddfmt("%i out of %i",shorts1[q,k],k==$LAY.nfing*2?k*ntest:ntest)
          RCell(RTF_CENTERED|RTF_THINBRD,30.0)
          if (k==$LAY.nfing*2 && nused*ntest-shorts50[q,k]>maxfailed) ||       \
            (k!=$LAY.nfing*2 && shorts50[q,k]!=ntest) then
            RFmt(RTF_TIMES,RTF_BOLD,9); j=0
          else
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
          RAddfmt("%i out of %i",shorts50[q,k],k==$LAY.nfing*2?k*ntest:ntest)
          RCell(RTF_CENTERED|RTF_THINBRD,30.0)
          if (k==$LAY.nfing*2 && nused*ntest-opens50[q,k]>maxfailed) ||        \
            (k!=$LAY.nfing*2 && opens50[q,k]!=ntest) then
            RFmt(RTF_TIMES,RTF_BOLD,9); j=0
          else
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
          RAddfmt("%i out of %i",opens50[q,k],k==$LAY.nfing*2?nused*ntest:ntest)
          RCell(RTF_CENTERED|RTF_THINBRD,16.0)
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddtext(j==0?"No":"Yes")
        enddo
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Passed")
        j=1
        RCell(RTF_CENTERED|RTF_THINBRD,30.0)
        if nused*ntest-shorts1[q,$LAY.nfing*2]>maxfailed then
          RFmt(RTF_TIMES,RTF_BOLD,9); j=0; RAddtext("No")
        else
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("Yes")
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,30.0)
        if nused*ntest-shorts50[q,$LAY.nfing*2]>maxfailed then
          RFmt(RTF_TIMES,RTF_BOLD,9); j=0; RAddtext("No")
        else
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("Yes")
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,30.0)
        if nused*ntest-opens50[q,$LAY.nfing*2]>maxfailed then
          RFmt(RTF_TIMES,RTF_BOLD,9); j=0; RAddtext("No")
        else
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("Yes")
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,16.0)
        RFmt(RTF_TIMES,RTF_BOLD,9); RAddtext(j==0?"No!":"Yes!")
        REndtable()
      endif
    enddo
    Flusherrlist(2,2,0,-1)
  endif
  if err==0 then
    Startexplanation()
    if allowvarshort then
      Explain("Comments to the tables above: This tester supports variable ")
      Explain("threshold for detection of shorts to antenna. First threshold ")
      Explain("is set to 10 MOhm. Each head makes %i measurements ",ntest)
      Explain("on resistors 0 and 10 M (both must be recognized as shorts) ")
      Explain("and %i tests with resistor 47 M (must be open). Then ",ntest)
      Explain("threshold is increased to 50 MOhm. In this case resistors 0 ")
      Explain("and 47 M must be recognized as shorts and ")
      Explain("%s - as open. ",                                                \
        (romdata.features & BF_TYPE)==BF_TRIPOD?"open":"200 M")
      if usefield!=0 && allowquickc then
        Explain("The procedure is repeated again for fast C. ")
        Explain("Total number of measurements is %i.",ntest*nused*12)
      else
        Explain("Total number of measurements is %i.",ntest*nused*6)
      endif
    else
      Explain("Comments to the table above: Short-to-antenna detection has ")
      Explain("fixed threshold of approx. 12 MOhm. Each head makes %i ",ntest)
      Explain("measurements with resistors 0 and 10 M (must be ")
      Explain("recognized as shorts) and %i tests with resistor 47 M ",ntest)
      Explain("(must be open). ")
      if usefield!=0 && allowquickc!=0 then
        Explain("The procedure is repeated again for fast C. ")
        Explain("Total number of measurements is %i.",ntest*nused*6)
      else
        Explain("Total number of measurements is %i.",ntest*nused*3)
      endif
    endif
    if maxfailed!=0 then
      Explain(" Test is recognized as good if number of falsely recognized ")
      Explain("opens or shorts in each series doesn't exceed %i.",maxfailed)
    endif
    if uselim then
      Explain("\nAntenna voltage in this test was set to %g V.",umax)
    endif
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  add hlist text="Capacity test interrupted!"
  if err==4 return 1                   // Operator interrupted test
  clear hright
  change hinfo limits=0,0
  change hinfo text="Capacity error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Capacity test found some error in internal data structures. "
    draw text="Please contact atg. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid field "
    draw text="measurement. "
  endif
  draw text="Test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Checks charge rise time measurements.
function int Crttest(int ntest,int certify,int log)
  char data[7,64] = {  \ // Head, left, right, C(pF), R(MOhm), factor, name
    "NOCT1   NOCT1   NOCT2   0.000   2000.   1.0000  No contact",              \
    "C27P    GND1    GND2    35.00   2000.   1.0230  35 pF",                   \
    "C270P   GND1    GND2    270.0   2000.   1.0087  270 pF",                  \
    "C2N7    GND1    GND2    2700.   1000.   1.0020  2.7 nF",                  \
    "C22N    GND1    GND2    22000   200.0   1.0060  22 nF",                   \
    "GND1    R10M    C2N7    2700.   10.00   1.0210  2.7 nF 10 M",             \
    "HV      GND1    GND2    0.000   0.000   1.0000  Breakdown" };
  int arrow[24] = {                  \ // HV warning arrow
    3,0,8,0,6,5,8,5,4,13,5,13,3,15,2,13,3,13,4,8,2,8,3,0 };
  int i,j,t,l,m,n,nc,h,rail,nhead,ncmd,maxbad,initstatus,inuse[32],err
  int nbad[7,33],nnocont[7,33],nbadbreak[33],good[7,33],globalgood
  float cexp[7],rexp[7],factor[7],a[7,33,5],b[7,33,5],c[7,33,5],r[7,33,5]
  float fastc,fastr,meanc,minc,maxc,meanr,minr,maxr,ubreak,x,y,xl,yl,xr,yr
  float diff,percent
  char s[512],p[1024],ccmd[32][512]
  handle hinterrupt,hcont
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
    return                             // Unsupported measurement
  if nused<4 return                    // Need two reference heads
  nhead=$LAY.nfing*2
  if ntest==0 ntest=16                 // As in certification
  ntest=Max(1,Min(ntest,32))           // Correct obvious errors
repeat:
  clear hright
  change hinfo limits=0,0
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  change hinfo text="CRT 2a?"
  Addreplaysection("CRT test")
  add hlist text="                     CRT TEST"
  add hlist text=""
  add hlist text=" Component       C (AC)   C (CRT)   R (CRT)  Pass"
  add hlist text=""
  draw window=hright color=LIGHTRED bkcolor=PINK
  for i=0,i<24,i++ do
    arrow[i]=arrow[i]*20+30
  enddo
  draw polygon=arrow,11
  draw font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="CRT 2a??o??????1o???Y??1?"
  draw text="?2a??1????????MSD?,??"
  draw text="2?Da??2a??"
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D??CRT2a?"
  endc
  nc=7                                 // Number of R||C combinations
  // Remove all pending commands.
  for i=0,i<ntest,i++ do
    SYS.Killimm(i)
  enddo
  // Parse test description.
  for n=0,n<nc,n++ do
    for j=0,j<6,j++ do
      i=j*8
      while data[n,i]!=' ' do i++; enddo
      data[n,i]='\0'
    enddo
    sscanf(data[n]+3*8,"%g",cexp+n)
    sscanf(data[n]+4*8,"%g",rexp+n)
    sscanf(data[n]+5*8,"%g",factor+n)
  enddo
  Clearoversurface()
  Initerrlist()
  if log then
    if txtok then
      fprintf(hlog,"\nCRT measurements:\n")
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\nCRT measurements:\n")
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  err=0
  // Initialize CRT measurements to 250 V. All capacitors on the OlliBoard
  // easily withstand this voltage.
  initstatus=0
  ncrterr=0
  if SERV.Cmdimm(0,"CRTINIT 250")<0 err=1
  t=Time()
  while err==0 && $A[0].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as interrupt
    if Pressed(hinterrupt) err=5
    if Time()-t>10000 err=2            // Timeout
    wait
  enddo
  if err==0 then
    if $A[0].answer==S_ERROR then
      err=3                            // CRT is not supported
    else if $A[0].answer!=S_CRTINIT then
      err=4                            // Invalid answer
    else if $uint4($A[0]+5)!=0 then
      initstatus=$uint4($A[0]+5)
      change hlist color=LIGHTRED
      add hlist text=format(" CRT initialization error 0x%08X",initstatus)
      add hlist text=""
    endif
  endif
  for n=0,n<nc && err==0,n++ do
    Initsigma(a[n,32])                 // Reference C
    Initsigma(b[n,32])                 // Breakdown voltage
    Initsigma(c[n,32])                 // CRT capacity
    Initsigma(r[n,32])                 // CRT resistance
    nbad[n,32]=0
    nnocont[n,32]=0
    nbadbreak[32]=0
  enddo
  Memset(inuse,0,Sizeof(inuse))
  // Main test.
  globalgood=(initstatus==0)
  if certify then
    maxbad=MAXFAILED+2*ntest*FAILRATE
  else
    maxbad=0
  endif
  for n=0,n<nc && initstatus==0 && err==0,n++ do
    if (romdata.features & BF_TYPE)==BF_TRIPOD && n==nc-1                      \
      continue                         // Glow lamp is not available
    for h=0,h<nhead && err==0,h++ do   // For all heads
      if used[h]==0 continue
      // Select reference rail. First try rail on different side.
      rail=-1
      for j=0,j<$LAY.nfing,j++ do
        if j==h/2 continue
        if used[j*2]==0 continue
        if $LAY.side[j]==$LAY.side[h/2] continue
        rail=j
      enddo
      // Then try just different rail.
      if rail<0 then
        for j=0,j<$LAY.nfing,j++ do
          if j==h/2 continue
          if used[j*2]==0 continue
          rail=j
        enddo
      endif
      if rail<0 continue
      inuse[h]=1
      // Get coordinates of antenna heads.
      if Convertpad(&xl,&yl,data[n]+8,rail*2,DELTA)<0.0 err=1
      if Convertpad(&xr,&yr,data[n]+16,rail*2+1,DELTA)<0.0 err=1
      // Prepare constant part of the command. To minimize influence, remaining
      // heads stay at home positions.
      l=sprintf(s,"M ")
      for i=0,i<nhead,i++ do
        if i==h then
          continue                     // Will be added later
        else if used[i]==0 then
          continue
        else if i==rail*2 then
          l=l+sprintf(s+l,"%i[%g,%gA%i] ",i,xl,yl,acc)
        else if i==rail*2+1 then
          l=l+sprintf(s+l,"%i[%g,%gA%i] ",i,xr,yr,acc)
        else
          l=l+sprintf(s+l,"%i(Z) ",i)
        endif
      enddo
      Initsigma(a[n,h])                // Reference C
      Initsigma(b[n,h])                // Breakdown voltage
      Initsigma(c[n,h])                // CRT capacity
      Initsigma(r[n,h])                // CRT resistance
      nbad[n,h]=0
      nnocont[n,h]=0
      nbadbreak[h]=0
      for i=0,i<ntest && err==0,i++ do
        change hinfo limits=n*nhead*ntest+h*ntest+i,nc*nhead*ntest
        // I send a package consisting of 4(2)+1 commands: two CRT measurements
        // and two capacity measurements except for R and breakdown. The first
        // measurement in each packet is a dummy.
        if Convertpad(&x,&y,data[n],h,DELTA)<0.0 err=1
        sprintf(s+l,"%i[%g,%gA%i] CRT(%i,%i,%i)",h,x,y,acc,h,rail*2,rail*2+1)
        SERV.Cmdimm(0,s)               // Dummy measurement, will be discarded
        SERV.Cmdimm(1,s)               // CRT
        SERV.Cmdimm(2,s)
        Strcpy(ccmd[h],s)
        ncmd=3
        if n<=5 then
          // Note that measurement at position 5 reports shortcut, unless
          // instructed not to do so.
          sprintf(s+l,"%i[%g,%gA%i] A(%i,0%s,%i,%i)",                          \
            h,x,y,acc,h,(n==5?"N":""),rail*2,rail*2+1)
          SERV.Cmdimm(3,s)             // Reference capacity
          SERV.Cmdimm(4,s)
          ncmd=5
        endif
        // Wait for answers.
        t=Time()
        while err==0 do
          for j=0,j<ncmd,j++ do
            if $A[j].length==0 break
          enddo
          if j>=ncmd break             // All answers came
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if Pressed(hinterrupt) err=5 // Operator interrupted test
          if Time()-t>10000 err=2      // Timeout
          wait
        enddo
        // Analyse answers. First answer is discarded.
        for j=1,j<ncmd && err==0,j++ do
          if j==1 || j==2 then         // CRT
            if $A[j].answer!=S_MOVE || $A[j].subcmd!=M_CRT then
              Adderr(ccmd[h],0,h,"Invalid answer at %s",data[n]+48)
              continue
            endif
            if log then
              m=sprintf(p,"  CRT (%s),",data[n]+48)
              while m<20 do
                p[m]=' '; m++
              enddo
              m=m+sprintf(p+m,"heads %2i - %2i,%2i: ",h,rail*2,rail*2+1)
              sprintf(p+m,"%8.5g pf %8.5g MOhm, status %04X",                  \
                $float4($A[j]+9),$float4($A[j]+13)/1.0e6,$A[j].status)
              lprintf(GREEN,"%s",p)
              if txtok!=0 then
                fprintf(hlog,"%s\n",p)
              endif
              if rtfok!=0 then
                RAddfmt("%s\n",p)
              endif
            endif
            if $A[j].status & 0x8914 then
              Adderr(ccmd[h],0,h,"Bad measurements at %s",data[n]+48)
              nbad[n,h]++
              nbad[n,32]++
            else if $A[j].status & 0x0020 then
              // Some versions of measurement software send negative voltage.
              ubreak=Abs($float4($A[j]+13))
              if n==nc-1 then
                if ubreak<BRKMIN || ubreak>BRKMAX then
                 if extendederr==0 then
                    Adderr(ccmd[h],0,h,                                        \
                    "Invalid breakdown voltage at %s",data[n]+48)
                  else
                    Adderr(ccmd[h],0,h,                                        \
                    "Breakdown voltage %g out of limits %g..%g V at %s",       \
                    ubreak,BRKMIN,BRKMAX,data[n]+48)
                  endif
                  nbadbreak[h]++
                  nbadbreak[32]++
                endif
              else
                Adderr(ccmd[h],0,h,"Breakdowns at %s",data[n]+48)
                nbad[n,h]++
                nbad[n,32]++
              endif
              Addsigma(b[n,h],ubreak)
              Addsigma(b[n,32],ubreak)
            else if cexp[n]>0.1 && $float4($A[j]+9)<cexp[n]*0.33 then
              Adderr(ccmd[h],0,h,"Too low capacity at %s",data[n]+48)
              nnocont[n,h]++
              nnocont[n,32]++
            else
              Addsigma(c[n,h],$float4($A[j]+9))
              Addsigma(c[n,32],$float4($A[j]+9))
              Addsigma(r[n,h],$float4($A[j]+13)/1.0e6)
              Addsigma(r[n,32],$float4($A[j]+13)/1.0e6)
              if n==nc-1 && $float4($A[j]+13)>GLOWRMAX then
               if extendederr==0 then
                  Adderr(ccmd[h],0,h,                                          \
                  "Invalid glow lamp resistance at %s",data[n]+48)
                else
                  Adderr(ccmd[h],0,h,                                          \
                  "Glow lamp resistance %.3g k exceeds limit %g k at %s",      \
                  $float4($A[j]+13)/1000.0,GLOWRMAX/1000.0,data[n]+48)
                endif
                nbadbreak[h]++
                nbadbreak[32]++
              endif
            endif
          else                         // Reference capacity
            if $A[j].answer!=S_MOVE || $A[j].subcmd!=M_FASTC continue
            SERV.Convertfastc($A[j],&fastc,&fastr)
            if log then
              m=sprintf(p,"  C (%s),",data[n]+48)
              while m<20 do
                p[m]=' '; m++
              enddo
              m=m+sprintf(p+m,"heads %2i - %2i,%2i: ",h,rail*2,rail*2+1)
              sprintf(p+m,"%8.5g pf, status %04X",fastc,$A[j].status)
              lprintf(GREEN,"%s",p)
              if txtok!=0 then
                fprintf(hlog,"%s\n",p)
              endif
              if rtfok!=0 then
                RAddfmt("%s\n",p)
              endif
            endif
            if $A[j].status & 0x9820 then
              continue
            endif
            if cexp[n]>0.1 && fastc<cexp[n]*0.33 then
              continue                 // Sure no contact?
            endif
            Addsigma(a[n,h],fastc)
            Addsigma(a[n,32],fastc)
          endif
        enddo
      enddo
    enddo
    if err!=0 break
    // Component measured. Decide whether measurements are good and display
    // information.
    fastc=Getmean(a[n,32])*factor[n]; if fastc<cexp[n]/3.0 fastc=cexp[n]
    meanc=Getmean(c[n,32])
    meanr=Getmean(r[n,32])
    good[n,32]=1
    for h=0,h<nhead,h++ do
      if inuse[h]==0 continue
      good[n,h]=1
      if nbad[n,h]>maxbad || nnocont[n,h]>maxbad then
        good[n,h]=0
        good[n,32]=0
      endif
      if n<nc-1 then                   // Regular measurements
        if Getcount(b[n,h])>maxbad then
          good[n,h]=0
          good[n,32]=0
        endif
        diff=fastc*CRTFACTOR+CRTABS
        if rexp[n]<20.0 diff=diff*3.0  // Capacity may be influenced by R
        if fastc-Getmin(c[n,h])>diff || Getmax(c[n,h])-fastc>diff then
          Adderr(ccmd[h],0,h,"High C-CRT capacity difference at %s",data[n]+48)
          good[n,h]=0
          good[n,32]=0
        endif
        if n==5 && (rexp[n]-Getmin(r[n,h])>rexp[n]*CRTRFACT ||                 \
          Getmax(r[n,h])-rexp[n]>rexp[n]*CRTRFACT) then
          Adderr(ccmd[h],0,h,"Invalid resistance at %s",data[n]+48)
          good[n,h]=0
          good[n,32]=0
        else if n!=5 && Getmin(r[n,h])<rexp[n] then
          Adderr(ccmd[h],0,h,"Invalid resistance at %s",data[n]+48)
          good[n,h]=0
          good[n,32]=0
        endif
      else                             // Breakdown
        if nbadbreak[h]>maxbad then
          good[n,h]=0
          good[n,32]=0
        endif
      endif
    enddo
    change hlist color=(good[n,32]?BLACK:LIGHTRED)
    add hlist text=format(" %-11s   %8.5g  %8.5g  %8.5g  %s",                  \
      data[n]+48,fastc,meanc,meanr,good[n,32]?"Yes":"No")
    if good[n,32]==0 globalgood=0
  enddo
  // Test finished.
  if err==0 then
    if globalgood==0 && certify!=0 then
      i=Askrepeat("CRT measurements")
      if i<0 return -1
      if i==1 goto repeat
    endif
    Summary(globalgood,"CRT measurements")
  endif
  if err==0 && txtok!=0 then           // Write measured data to TXT protocol
    fprintf(hlog,"\n                               CRT measurements\n")
    if initstatus!=0 then
      fprintf(hlog,"\nMeasurement system  test  was unable to  initialize "    \
      "CRT measurements.  Tester\nreported error 0x%08X.\n\n",initstatus)
    endif
    if ncrterr>0 then
      fprintf(hlog,"\nDuring initialization, measurement card detected "       \
        "several  CRT-related  errors\nthat may influence test results:\n\n")
      for i=0,i<ncrterr,i++ do
        SERV.Decodeanswer(crterr[i],s,p,0xFFFFFFFF)
        fprintf(hlog,"  %s\n",s)
      enddo
      fprintf(hlog,"\n")
    endif
    if initstatus==0 then
      fprintf(hlog,"\n      Cexp,pF ")
      for n=0,n<nc-1,n++ do
        fprintf(hlog,"%9g",cexp[n])
      enddo
      fprintf(hlog,"    Break")
      fprintf(hlog,"\nHead   Rexp,M ")
      for n=0,n<nc-1,n++ do
        fprintf(hlog,"%9g",rexp[n])
      enddo
      fprintf(hlog,"\n\n     C(AC),pF ")
      for n=0,n<nc-1,n++ do
        fprintf(hlog,"%9.5g",Getmean(a[n,32]))
      enddo
      fprintf(hlog,"        -\n")
      fprintf(hlog,"    Corrected ")
      for n=0,n<nc-1,n++ do
        fprintf(hlog,"%9.5g",Getmean(a[n,32])*factor[n])
      enddo
      fprintf(hlog,"        -\n")
      for h=0,h<=nhead,h++ do
        // Mean capacity.
        if h==nhead then
          h=32
          fprintf(hlog,"\nAll      C,pF ")
        else
          if inuse[h]==0 continue
          fprintf(hlog,"\n%2i%s      C,pF ",h/2,h & 1?"R":"L")
        endif
        for n=0,n<nc-1,n++ do
          fprintf(hlog,"%9.5g",Getmean(c[n,h]))
        enddo
        if (romdata.features & BF_TYPE)!=BF_TRIPOD && Getcount(b[nc-1,h])>0 then
          fprintf(hlog,"%7.5g V\n",Getmean(b[nc-1,h]))
        else
          fprintf(hlog,"        -\n")
        endif
        // Minimal capacity.
        if logmode==0 then
          fprintf(hlog,"      Cmin,pF ")
        else
          fprintf(hlog,"     Diff min ")
        endif
        for n=0,n<nc-1,n++ do
          fastc=Getmean(a[n,32])*factor[n]; if fastc<cexp[n]/3.0 fastc=cexp[n]
          minc=Getmin(c[n,h])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+9.2g",minc-fastc)
          else if logmode==2 && cexp[n]<10.0 then // Low diffs
            fprintf(hlog,"%+8.2gp",minc-fastc)
          else if logmode==2 then      // Percentages
            percent=(minc-fastc)/fastc*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.5g",minc)
          endif
        enddo
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          fprintf(hlog,"\n")
        else if Getcount(b[nc-1,h])>0 then
          fprintf(hlog,"%+7.0f V\n",Getmin(b[nc-1,h]))
        else
          fprintf(hlog,"        -\n")
        endif
        // Maximal capacity.
        if logmode==0 then
          fprintf(hlog,"      Cmax,pF ")
        else
          fprintf(hlog,"     Diff max ")
        endif
        for n=0,n<nc-1,n++ do
          fastc=Getmean(a[n,32])*factor[n]; if fastc<cexp[n]/3.0 fastc=cexp[n]
          maxc=Getmax(c[n,h])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+9.2g",maxc-fastc)
          else if logmode==2 && cexp[n]<10.0 then // Low diffs
            fprintf(hlog,"%+8.2gp",maxc-fastc)
          else if logmode==2 then      // Percentages
            percent=(maxc-fastc)/fastc*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.5g",maxc)
          endif
        enddo
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          fprintf(hlog,"\n")
        else if Getcount(b[nc-1,h])>0 then
          fprintf(hlog,"%+7.0f V\n",Getmax(b[nc-1,h]))
        else
          fprintf(hlog,"        -\n")
        endif
        // Sigma (all heads only)
        if h==32 then
          fprintf(hlog,"     Sigma,pF ")
          for n=0,n<nc-1,n++ do
            fprintf(hlog,"%9.5g",Getsigma(c[n,h]))
          enddo
          fprintf(hlog,"\n")
        endif
        // Mean resistance.
        fprintf(hlog,"       R,MOhm ")
        for n=0,n<nc-1,n++ do
          fprintf(hlog,"%9.4g",Getmean(r[n,h]))
        enddo
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          fprintf(hlog,"\n")
        else if Getcount(r[nc-1,h])>0 then
          fprintf(hlog,"%9.4g\n",Getmean(r[nc-1,h]))
        else
          fprintf(hlog,"        -\n")
        endif
        // Minimal resistance.
        if logmode==0 then
          fprintf(hlog,"    Rmin,MOhm ")
        else
          fprintf(hlog,"     Diff min ")
        endif
        for n=0,n<nc-1,n++ do
          minr=Getmin(r[n,h])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+9.2g",minr-rexp[n])
          else if logmode==2 then      // Percentages
            percent=(minr-rexp[n])/rexp[n]*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.4g",minr)
          endif
        enddo
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          fprintf(hlog,"\n")
        else if Getcount(r[nc-1,h])>0 then
          meanr=Getmean(r[nc-1,h])
          minr=Getmin(r[nc-1,h])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+9.2g",minr-meanr)
          else if logmode==2 && meanr>0 then // Percentages
            percent=(minr-meanr)/meanr*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.4g",minr)
          endif
          fprintf(hlog,"\n")
        else
          fprintf(hlog,"        -\n")
        endif
        // Maximal resistance.
        if logmode==0 then
          fprintf(hlog,"    Rmax,MOhm ")
        else
          fprintf(hlog,"     Diff max ")
        endif
        for n=0,n<nc-1,n++ do
          maxr=Getmin(r[n,h])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+9.2g",maxr-rexp[n])
          else if logmode==2 then      // Percentages
            percent=(maxr-rexp[n])/rexp[n]*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.4g",maxr)
          endif
        enddo
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          fprintf(hlog,"\n")
        else if Getcount(r[nc-1,h])>0 then
          meanr=Getmean(r[nc-1,h])
          maxr=Getmin(r[nc-1,h])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+9.2g",maxr-meanr)
          else if logmode==2 && meanr>0 then // Percentages
            percent=(maxr-meanr)/meanr*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.4g",maxr)
          endif
          fprintf(hlog,"\n")
        else
          fprintf(hlog,"        -\n")
        endif
        // Sigma (all heads only)
        if h==32 then
          fprintf(hlog,"   Sigma,MOhm ")
          for n=0,n<nc-1,n++ do
            fprintf(hlog,"%9.4g",Getsigma(r[n,h]))
          enddo
          fprintf(hlog,"\n")
        endif
        // Bad measurements.
        fprintf(hlog,"     Bad/Noct ")
        for n=0,n<nc,n++ do
          if (romdata.features & BF_TYPE)==BF_TRIPOD && n==nc-1                \
            continue
          fprintf(hlog,"  %3i/%3i",nbad[n,h],nnocont[n,h])
        enddo
        fprintf(hlog,"\n")
      enddo
      fprintf(hlog,"\n       Passed ")
      for n=0,n<nc,n++ do
        if (romdata.features & BF_TYPE)==BF_TRIPOD && n==nc-1                  \
          continue
        fprintf(hlog,"%9.9s",good[n,32]?"Yes":"No")
      enddo
      fprintf(hlog,"\n")
      if logmode==2 then
        fprintf(hlog,"\nLetters 'p' and 'V' mean differences ")
        fprintf(hlog,"in picofarades  and breakdown voltage in\nvolts\n")
      else
        fprintf(hlog,"\nLetter 'V' means breakdown voltage in volts\n")
      endif
    endif
    Flusherrlist(0,1,0,-1)
    fprintf(hlog,"\n\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  if err==0 && rtfok!=0 then           // Write measured data to .RTF protocol
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddtext("\nCRT measurements")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    if initstatus!=0 then
      RParagraph(RTF_FORMAT)
      RAddfmt("Measurement system test was unable to initialize CRT "          \
      "measurements. Tester reported error 0x%08X.",initstatus)
    endif
    if ncrterr>0 then
      RParagraph(RTF_FORMAT)
      RAddfmt("\nDuring initialization, measurement card detected several "    \
        "CRT-related errors that may influence test results:\n\n")
      for i=0,i<ncrterr,i++ do
        SERV.Decodeanswer(crterr[i],s,p,0xFFFFFFFF)
        RAddfmt("  %s\n",s)
      enddo
    endif
    if initstatus==0 then
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,8.0)
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddtext("\nHead")
      RCell(RTF_RIGHT|RTF_THINBRD,23.0); RAddtext("Cexp, pF\nRexp, MOhm")
      for n=0,n<nc-1,n++ do
        RCell(RTF_CENTERED|RTF_THINBRD,18.0);
        RAddfmt("%g\n%g",cexp[n],rexp[n])
      enddo
      RCell(RTF_CENTERED|RTF_THINBRD,17.0); RAddtext("Break")
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,11.0)
      RCell(RTF_RIGHT|RTF_THINBRD,23.0); RAddtext("C(AC), pF\nAC corrected")
      for n=0,n<nc-1,n++ do
        RCell(RTF_CENTERED|RTF_THINBRD,18.0);
        RAddfmt("%.5g\n%.5g",Getmean(a[n,32]),Getmean(a[n,32])*factor[n])
      enddo
      RCell(RTF_CENTERED|RTF_THINBRD,17.0)
      for h=0,h<=nhead,h++ do
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,11.0)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        if h==nhead then
          h=32
          RAddfmt("\nAll")
        else
          if inuse[h]==0 continue
          RAddfmt("\n%2i%s",h/2,h & 1?"R":"L")
        endif
        RCell(RTF_RIGHT|RTF_THINBRD,23.0)
        RAddtext("C, pF\n")
        if logmode==0 then
          RAddtext("Cmin, pF\nCmax, pF\n")
        else
          RAddtext("Diff min\nDiff max\n")
        endif
        if h==32 then
          RAddtext("Sigma, pF\n")
        endif
        RAddtext("R, MOhm\n")
        if logmode==0 then
          RAddtext("Rmin, MOhm\n Rmax, MOhm\n")
        else
          RAddtext("Diff min\nDiff max\n")
        endif
        if h==32 then
          RAddtext("Sigma, pF\n")
        endif
        RAddtext("Bad/Noct")
        for n=0,n<nc-1,n++ do
          RCell(RTF_CENTERED|RTF_THINBRD,18.0);
          if good[n,h]==0 then
            RFmt(RTF_TIMES,RTF_BOLD,9)
          else
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
          RAddfmt("%.5g\n",Getmean(c[n,h]))
          fastc=Getmean(a[n,32])*factor[n]; if fastc<cexp[n]/3.0 fastc=cexp[n]
          minc=Getmin(c[n,h])
          maxc=Getmax(c[n,h])
          if logmode==1 then           // Differences
            RAddfmt("%+.5g\n%+.5g\n",minc-fastc,maxc-fastc)
          else if logmode==2 && cexp[n]<10.0 then // Low diffs
            RAddfmt("%+.5gp\n%+.5gp\n",minc-fastc,maxc-fastc)
          else if logmode==2 then      // Percentages
            percent=(minc-fastc)/fastc*100.0
            if percent>99.0 then RAddfmt("> 99%%\n");
            else if percent<(-99.0) then RAddfmt("<-99%%\n");
            else RAddfmt("%+.2f%%\n",percent); endif
            percent=(maxc-fastc)/fastc*100.0
            if percent>99.0 then RAddfmt("> 99%%\n");
            else if percent<(-99.0) then RAddfmt("<-99%%\n");
            else RAddfmt("%+.2f%%\n",percent); endif
          else                         // Absolute values
            RAddfmt("%.5g\n%.5g\n",minc,maxc)
          endif
          if h==32 then
            RAddfmt("%.5g\n",Getsigma(c[n,h]))
          endif
          RAddfmt("%.5g\n",Getmean(r[n,h]))
          minr=Getmin(r[n,h])
          maxr=Getmax(r[n,h])
          if logmode==1 then           // Differences
            RAddfmt("%+.4g\n%+.4g\n",minr-rexp[n],maxr-rexp[n])
          else if logmode==2 then      // Percentages
            percent=(minr-rexp[n])/rexp[n]*100.0
            if percent>99.0 then RAddfmt("> 99%%\n");
            else if percent<(-99.0) then RAddfmt("<-99%%\n");
            else RAddfmt("%+.2f%%\n",percent); endif
            percent=(maxr-rexp[n])/rexp[n]*100.0
            if percent>99.0 then RAddfmt("> 99%%\n");
            else if percent<(-99.0) then RAddfmt("<-99%%\n");
            else RAddfmt("%+.2f%%\n",percent); endif
          else                         // Absolute values
            RAddfmt("%.4g\n%.4g\n",minr,maxr)
          endif
          if h==32 then
            RAddfmt("%.4g\n",Getsigma(r[n,h]))
          endif
          RAddfmt("%i / %i",nbad[n,h],nnocont[n,h])
        enddo
        RCell(RTF_CENTERED|RTF_THINBRD,17.0)
        if (romdata.features & BF_TYPE)==BF_TRIPOD then
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddtext("-")
        else
          if good[nc-1,h]==0 then
            RFmt(RTF_TIMES,RTF_BOLD,9)
          else
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
          if Getcount(b[nc-1,h])>0 then
            RAddfmt("%.0f V\n%.0f V\n%.0f V\n",                                \
            Getmean(b[nc-1,h]),Getmin(b[nc-1,h]),Getmax(b[nc-1,h]))
          else
            RAddtext("-\n-\n-\n")
          endif
          if h==32 then
            RAddtext("\n")
          endif
          if Getcount(r[nc-1,h])>0 then
            meanr=Getmean(r[nc-1,h])
            minr=Getmin(r[nc-1,h])
            maxr=Getmax(r[nc-1,h])
            RAddfmt("%.4g\n",meanr)
            if logmode==1 then         // Differences
              RAddfmt("%+.4g\n%+.4g\n",minr-meanr,maxr-meanr)
            else if logmode==2 && meanr>0 then // Percentages
              percent=(minr-meanr)/meanr*100.0
              if percent>99.0 then RAddfmt("> 99%%\n");
              else if percent<(-99.0) then RAddfmt("<-99%%\n");
              else RAddfmt("%+.2f%%\n",percent); endif
              percent=(maxr-meanr)/meanr*100.0
              if percent>99.0 then RAddfmt("> 99%%\n");
              else if percent<(-99.0) then RAddfmt("<-99%%\n");
              else RAddfmt("%+.2f%%\n",percent); endif
            else                       // Absolute values
              RAddfmt("%.4g\n%.4g\n",minr,maxr)
            endif
          else
            RAddtext("-\n-\n-\n")
          endif
          if h==32 then
            RAddtext("\n")
          endif
          RAddfmt("%i / %i",nbad[nc-1,h],nnocont[nc-1,h])
        endif
      enddo
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RCell(RTF_CENTERED|RTF_THINBRD,11.0)
      RCell(RTF_RIGHT|RTF_THINBRD,23.0); RAddtext("Passed")
      for n=0,n<nc,n++ do
        RCell(RTF_CENTERED|RTF_THINBRD,(n==nc-1?17.0:18.0));
        if (romdata.features & BF_TYPE)==BF_TRIPOD && n==nc-1 continue
        RAddfmt("%s",(good[n,32]?"Yes":"No"))
      enddo
      REndtable()
      Flusherrlist(0,2,0,-1)
    endif
  endif
  if err==0 && initstatus==0 then
    Startexplanation()
    if (romdata.features & BF_TYPE)==BF_TRIPOD then
      n=nc-1
    else
      n=nc
    endif
    Explain("Comments to the table above: Each of %i different R-C ",n)
    Explain("combinations is checked %i times by each finger, giving ",ntest*2)
    Explain("grand total of %i measurements. Test is passed ",ntest*n*nused*2)
    if maxbad==0 then
      Explain("when (a) all measurements are good (stable and ")
      Explain("reliable results, no false breakdowns); ")
    else
      Explain("when (a) there are not more than %i bad measurements, ",maxbad)
      Explain("no-contacts and/or false breakdowns for each cell; ")
    endif
    Explain("(b) measured CRT capacity differs not more than %g pF + ",CRTABS)
    Explain("%g%% from the AC or charge-discharge capacity ",CRTFACTOR*100)
    Explain("(more if parallel resistor is connected). Note that direct ")
    Explain("capacity from wire to tester influences AC and CRT measurements ")
    Explain("in opposite directions, therefore there are empirical factors ")
    Explain("that corrects measurements on a weakly shielded OlliBoard; and ")
    Explain("(c) CRT resistance differs not more than %g%% from ",CRTRFACT*100)
    Explain("expected. ")
    if (romdata.features & BF_TYPE)==BF_TRIPOD then
      Explain("Note that glow lamp is replaced by another component, ")
      Explain("therefore breakdown measurements are omitted.")
    else
      Explain("For measurements on the glow lamp, reported breakdown ")
      Explain("voltage must lie in the range %g..%g volt ",BRKMIN,BRKMAX)
      Explain("or reported resistance must be lower than ")
      Explain("%g MOhm.",GLOWRMAX*1.0e-6)
    endif
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
  endif
  if err==0 return 0
  change hlist color=LIGHTRED
  add hlist text="CRT test interrupted!"
  if err==5 return 1                   // Operator interrupted test
  clear hright
  change hinfo limits=0,0
  change hinfo text="CRT error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="CRT test found some error in internal data structures. "
    draw text="Please contact atg. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="CRT not supported!"
    draw at 6,60 color=BLACK
    draw text="It looks like your tester does not support CRT. "
  else if err==4 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid CRT "
    draw text="measurement. "
  endif
  draw text="Test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Checks universal capacity measurements.
function int Unictest(int ntest,int certify,int log)
  char res[5][8] = {                 \ // Pads with resistors
    "GND1",                          \ // 0 Ohm
    "R294",                          \ // 294 Ohm
    "R2K94",                         \ // 2.94 kOhm
    "R29K4",                         \ // 29.4 kOhm
    "" };
  char cap[5][8] = {                 \ // Pads with capacitors
    "C2N7",                          \ // Capacitor 2.7 nF
    "C22N",                          \ // Capacitor 22 nF
    "C220N",                         \ // Capacitor 220 nF
    "C2U2",                          \ // Capacitor 2.2 uF
    "" };
  float rcap[5] = {                  \ // Own resistance of capacitor @ 2 kHz
    21.0,                            \ // Capacitor 2.7 nF
    19.0,                            \ // Capacitor 22 nF
    1.9,                             \ // Capacitor 220 nF
    0.2,                             \ // Capacitor 2.2 uF
    0.0 };
  // Indices in arrays and loops: [m=setting, k=head, i=resistor, j=capacitor].
  int i,j,k,l,m,n,p,q,t,nr,nc,pr,pc,nrep,nhead
  int nbad[2,5,5],nlimit[2,5,5],pass[2,5,5],cpass[2,5],totalpass[2],err
  float x,y,rexp[5],cexp[4],fr,fc,c,r,cglob[2,5,5,5],rglob[2,5,5,5]
  float climit,rlimit,deltac,percent
  char s[256],cmd[1024]
  handle hinterrupt,hcont
  if (testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&          \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8) || (features & MF_UNIC)==0         \
    return 0                           // Measurement is not supported
  if ntest==0 ntest=2                  // As in certification
repeat:
  change hinfo limits=0,0
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  change hinfo text="??Y2a?"
  Addreplaysection("Universal C test")
  add hlist text="              UNIVERSAL CAPACITY TEST"
  add hlist text=""
  add hlist text=" Cexp   Rexp   F   U      Cmean      Rmean   Pass"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="??Y2a??a?2??2a????"
  draw text="??eC+R?||R2?D????????"
  draw text="?1o?Y2a?????"
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D???2a?"
  endc
  // Prepare for test.
  nhead=$LAY.nfing*2
  for nr=0,res[nr][0]!='\0',nr++ do; enddo
  for nc=0,cap[nc][0]!='\0',nc++ do; enddo
  ntest=Max(1,Min(ntest,32))
  for n=0,n<ntest && err==0,n++ do
    SYS.Killimm(n)                     // Remove all pending commands
  enddo
  Clearoversurface()
  Initerrlist()
  if log then
    if txtok then
      fprintf(hlog,"\nUniversal capacity measurements:\n")
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\nUniversal capacity measurements:\n")
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  err=0
  nrep=5                               // Number of different test points
  // Test.
  for i=0,i<nr && err==0,i++ do        // For all resistor values
    add hlist text=""
    for k=0,xname[k][0]!='\0',k++ do
      if Strcmp(res[i],xname[k])==0 then
        rexp[i]=value[k]; break        // Resistor found
      endif
    enddo
    if rexp[i]>1000000.0 then pr=2; fr=1000000.0;
    else if rexp[i]>1000.0 then pr=1; fr=1000.0;
    else pr=0; fr=1.0; endif
    if xname[k][0]=='\0' err=1
    for j=0,j<nc && err==0 ,j++ do     // For all capacitor values
      for k=0,xname[k][0]!='\0',k++ do // Find capacitor value
        if Strcmp(cap[j],xname[k])==0 then
          cexp[j]=value[k]; break      // In picofarades
        endif
      enddo
      if cexp[j]>1000000.0 then pc=2; fc=1000000.0;
      else if cexp[j]>1000.0 then pc=1; fc=1000.0;
      else pc=0; fc=1.0; endif
      if xname[k][0]=='\0' err=1
      // Determine required accuracy of measurements.
      if cexp[j]<=30000.0 then
        climit=cexp[j]*CFACTOR
      else
        climit=cexp[j]*CFACTORHI
      endif
      if cexp[j]>200000.0 && rexp[i]>2000.0 climit=climit*2.0
      if cexp[j]>2000000.0 && rexp[i]>20000.0 climit=climit*2.5
      rlimit=RCPRODUCT/cexp[j]+UCRFACTOR*rexp[i]+UCRABS
      if certify!=0 then
        climit=climit*1.5
        rlimit=rlimit*1.5
      endif
      // Initialize statistics.
      for m=0,m<2,m++ do
        nbad[m,i,j]=0
        nlimit[m,i,j]=0
        pass[m,i,j]=1
        Initsigma(cglob[m,i,j])
        Initsigma(rglob[m,i,j])
      enddo
      for p=0,p<nrep && err==0 ,p++ do  // At nrep different points
        change hinfo limits=i*nc*nrep+j*nrep+p,nr*nc*nrep
        for k=0,k<nhead && err==0,k++ do // For all heads
          if used[k]==0 continue
          // Select coordinates. All resistors are to the left from all
          // capacitors.
          l=sprintf(cmd,"M ")
          for m=0,m<nhead && err==0,m++ do
            if used[m]==0 continue
            if m==(k & 0x1E) then
              if Convertpad(&x,&y,res[i],m,DELTA)<0.0 err=1
            else if m==(k | 0x01) then
              if Convertpad(&x,&y,cap[j],m,DELTA)<0.0 err=1
            else if (m & 1)==0 then
              if Convertpad(&x,&y,res[i],m,0.0)<0.0 err=1
              x=x-5.0
            else
              if Convertpad(&x,&y,cap[j],m,0.0)<0.0 err=1
              x=x+5.0
            endif
            if (m & 0x1E)==(k & 0x1E) then
              l=l+sprintf(cmd+l," %i[%g,%gA%i]",m,x,y,acc)
            else
              if y>$LAY.yoffset[m/2]/1000.0 then
                y=y-5.0
              else
                y=y+5.0
              endif
              l=l+sprintf(cmd+l," %i(%g,%g)",m,x,y)
            endif
          enddo
          for m=0,m<2 && err==0,m++ do // For two measurement settings
            if m==0 then
              sprintf(cmd+l," UC(%i,%i,U=1.0,F=1000,BR,N)",k,k^1)
            else
              sprintf(cmd+l," UC(%i,%i,U=4.0,F=2000,BR,N)",k,k^1)
            endif
            for n=0,n<ntest && err==0,n++ do
              if SERV.Cmdimm(n,cmd)<0 err=1  // Send ntest commands at once
            enddo
            for n=0,n<ntest && err==0,n++ do
              t=Time()                     // Wait till answer comes
              while $A[n].length==0 && err==0 do
                if Time()-t>20000 err=2
                if Pressed(hexit) err=-1
                if Pressed(hinterrupt) err=4
                wait
              enddo
              if (err==0 && $A[n].answer!=S_MOVE) err=3
              if err==0 then
                if ($A[i].status & 0x8800)!=0 then
                  Adderr(cmd,m,k,"Bad measurements at %g %s, %g %s",           \
                    rexp[i]/fr,runitname[pr],cexp[j]/fc,cunitname[pc])
                  nbad[m,i,j]++
                else
                  c=$float4($A[n]+10)  // Picofarades
                  r=$float4($A[n]+14)  // Ohms
                  r=r-rcap[j]
                  if Abs(c-cexp[j])>climit then
                    Adderr(cmd,m,k,"Capacity out of limits at %g %s, %g %s",   \
                    rexp[i]/fr,runitname[pr],cexp[j]/fc,cunitname[pc])
                    nlimit[m,i,j]++
                  else if Abs(r-rexp[i])>rlimit then
                    Adderr(cmd,m,k,"Resistance out of limits at %g %s, %g %s", \
                    rexp[i]/fr,runitname[pr],cexp[j]/fc,cunitname[pc])
                    nlimit[m,i,j]++
                  endif
                  // Sure nocontacts are filtered out.
                  if c>cexp[j]*0.1 then
                    Addsigma(cglob[m,i,j],c)
                    Addsigma(rglob[m,i,j],r)
                  endif
                  if log then
                    q=sprintf(s,"  UC (%4.4g %4s,",rexp[i]/fr,runitname[pr])
                    q=q+sprintf(s+q,"%4.4g %2s) ",cexp[j]/fc,cunitname[pc])
                    q=q+sprintf(s+q,"heads %2i - %2i:",k,k^1)
                    q=q+sprintf(s+q,"  C = %7.4g %s",c/fc,cunitname[pc])
                    sprintf(s+q,"  R = %7.4g %s",r/fr,runitname[pr])
                    lprintf(GREEN,"%s",s)
                    if txtok!=0 then
                      fprintf(hlog,"%s\n",s)
                    endif
                    if rtfok!=0 then
                      RAddfmt("%s\n",s)
                    endif
                  endif
                endif
              endif
            enddo
          enddo
        enddo
      enddo
      if err!=0 break
      // Measurements for one component combination are finished. Check whether
      // measurements are valid and show statistics on the screen.
      for m=0,m<2,m++ do
        if certify==0 then
          if nbad[m,i,j]>0 pass[m,i,j]=0
          if nlimit[m,i,j]>0 pass[m,i,j]=0
        else
          if nbad[m,i,j]>nrep*ntest*FAILRATE+MAXFAILED pass[m,i,j]=0
          if nlimit[m,i,j]>nrep*ntest*FAILRATE+MAXFAILED pass[m,i,j]=0
        endif
        if i==nr-1 && j==nc-1 then
          deltac=cexp[j]               // Do not compare
        else
          deltac=cexp[j]*UCREPEAT*(1.0+i/2.0)
        endif
        if m==0 deltac=deltac*2.0      // Significantly lower accuracy
        if certify deltac=deltac*1.5
        if Getmax(cglob[m,i,j])-Getmin(cglob[m,i,j])>deltac*2 then
          pass[m,i,j]=0
        endif
        q=sprintf(s,"%4g%s  %4g%s",                                            \
          cexp[j]/fc,cunitshort[pc],rexp[i]/fr,runitshort[pr])
        q=q+sprintf(s+q,"  %s",(m==0?"1k  1V":"2k  4V"))
        q=q+sprintf(s+q," %10.2f",Getmean(cglob[m,i,j])/fc)
        q=q+sprintf(s+q," %10.2f",Getmean(rglob[m,i,j])/fr)
        sprintf(s+q,"   %s",pass[m,i,j]?"Yes":"No")
        change hlist color=(pass[m,i,j]?BLACK:LIGHTRED)
        add hlist text=s
      enddo
    enddo                              // End of capacity loop
  enddo                                // End of resistance loop
  if err==(-1) return -1               // Operator interrupted test
  if err==0 then
    for m=0,m<2,m++ do
      totalpass[m]=1
      for j=0,j<nc,j++ do
        cpass[m,j]=1
      enddo
    enddo
    for i=0,i<nr,i++ do                // For all resistor values
      for j=0,j<nc,j++ do              // For all capacitor values
        for m=0,m<2,m++ do             // For two measurement settings
          if pass[m,i,j]==0 totalpass[m]=0
          if pass[m,i,j]==0 cpass[m,j]=0
        enddo
      enddo
    enddo
    if (totalpass[0]==0 || totalpass[1]==0) && certify!=0 then
      i=Askrepeat("Universal C measurements")
      if i<0 return -1
      if i==1 goto repeat
    endif
    Summary(totalpass[0] & totalpass[1],"Universal C measurements")
  endif
  if err==0 && txtok!=0 then           // Write measured data to TXT protocol
    for m=0,m<2,m++ do
      fprintf(hlog,"\n                ")
      if m==0 then
        fprintf(hlog,"Universal capacity measurements at 1 V, 1 kHz\n")
      else
        fprintf(hlog,"Universal capacity measurements at 4 V, 2 kHz\n")
      endif
      fprintf(hlog,"\nResistance     Value  -------------- Capacity, nF ----")
      fprintf(hlog,"----------  Bad  Passed")
      fprintf(hlog,"\n                    ")
      for j=0,j<nc,j++ do              // For all capacitor values
        fprintf(hlog,"%11.4g",cexp[j]/1.0e3)
      enddo
      fprintf(hlog,"\n\n          Own R, Ohm")
      for j=0,j<nc,j++ do              // For all capacitor values
        fprintf(hlog,"%11.4g",rcap[j])
      enddo
      for i=0,i<nr,i++ do                // For all resistor values
        pc=1; fc=1000.0
        if rexp[i]>1000000.0 then pr=2; fr=1000000.0;
        else if rexp[i]>1000.0 then pr=1; fr=1000.0;
        else pr=0; fr=1.0; endif
        fprintf(hlog,"\n\n%5.3g %4s    Mean C",rexp[i]/fr,runitname[pr])
        k=0; q=1
        for j=0,j<nc,j++ do
          fprintf(hlog,"%11.4g",Getmean(cglob[m,i,j])/fc)
          k=k+nbad[m,i,j]
          if pass[m,i,j]==0 q=0
        enddo
        fprintf(hlog,"%5i     %s",k,(q?"Yes":" No"))
        fprintf(hlog,"\n            %s",logmode==0?"    Cmin":"Diff min")
        for j=0,j<nc,j++ do
          c=Getmean(cglob[m,i,j])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+11.3g",(Getmin(cglob[m,i,j])-c)/fc)
          else if logmode==2 && c==0.0 then
            fprintf(hlog,"           ")
          else if logmode==2 then      // Percentages
            percent=(Getmin(cglob[m,i,j])-c)/c*100.0
            if percent>99.0 then fprintf(hlog,"      > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"      <-99%%");
            else fprintf(hlog,"%+10.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%11.4g",Getmin(cglob[m,i,j])/fc)
          endif
        enddo
        fprintf(hlog,"\n            %s",logmode==0?"    Cmax":"Diff max")
        for j=0,j<nc,j++ do
          c=Getmean(cglob[m,i,j])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+11.3g",(Getmax(cglob[m,i,j])-c)/fc)
          else if logmode==2 && c==0.0 then
            fprintf(hlog,"           ")
          else if logmode==2 then      // Percentages
            percent=(Getmax(cglob[m,i,j])-c)/c*100.0
            if percent>99.0 then fprintf(hlog,"      > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"      <-99%%");
            else fprintf(hlog,"%+10.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%11.4g",Getmax(cglob[m,i,j])/fc)
          endif
        enddo
        fprintf(hlog,"\n             Sigma C")
        for j=0,j<nc,j++ do
          fprintf(hlog,"%11.4g",Getsigma(cglob[m,i,j])/fc)
        enddo
        fprintf(hlog,"\n              Mean R")
        for j=0,j<nc,j++ do
          fprintf(hlog,"%11.4g",Getmean(rglob[m,i,j])/fr)
        enddo
        fprintf(hlog,"\n            %s",logmode==0?"    Rmin":"Diff min")
        for j=0,j<nc,j++ do
          r=Getmean(rglob[m,i,j])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+11.3g",(Getmin(rglob[m,i,j])-r)/fr)
          else if logmode==2 && r==0.0 then
            fprintf(hlog,"           ")
          else if logmode==2 then      // Percentages
            percent=(Getmin(rglob[m,i,j])-r)/r*100.0
            if percent>99.0 then fprintf(hlog,"      > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"      <-99%%");
            else fprintf(hlog,"%+10.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%11.4g",Getmin(rglob[m,i,j])/fr)
          endif
        enddo
        fprintf(hlog,"\n            %s",logmode==0?"    Rmax":"Diff max")
        for j=0,j<nc,j++ do
          r=Getmean(rglob[m,i,j])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+11.3g",(Getmax(rglob[m,i,j])-r)/fr)
          else if logmode==2 && r==0.0 then
            fprintf(hlog,"           ")
          else if logmode==2 then      // Percentages
            percent=(Getmax(rglob[m,i,j])-r)/r*100.0
            if percent>99.0 then fprintf(hlog,"      > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"      <-99%%");
            else fprintf(hlog,"%+10.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%11.4g",Getmax(rglob[m,i,j])/fr)
          endif
        enddo
        fprintf(hlog,"\n             Sigma R")
        for j=0,j<nc,j++ do
          fprintf(hlog,"%11.4g",Getsigma(rglob[m,i,j])/fr)
        enddo
        fprintf(hlog,"\n           Bad/Limit")
        for j=0,j<nc,j++ do
          sprintf(s,"%i/%i",nbad[m,i,j],nlimit[m,i,j])
          fprintf(hlog,"%11s",s)
        enddo
      enddo
      fprintf(hlog,"\n\n              Passed")
      for j=0,j<nc,j++ do
        fprintf(hlog,"%11s",cpass[m,j]==0?"No":"Yes")
      enddo
      fprintf(hlog,"         %s",totalpass[m]?"YES!":" NO!")
      Flusherrlist(m,1,0,-1)
      fprintf(hlog,"\n\n--------------------------------------")
      fprintf(hlog,"---------------------------------------\n")
    enddo
  endif
  if err==0 && rtfok!=0 then           // Write measured data to RTF protocol
    for m=0,m<2,m++ do
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      if m==0 then
        RAddtext("\nUniversal capacity measurements at 1 V, 1 kHz")
      else
        RAddtext("\nUniversal capacity measurements at 4 V, 2 kHz")
      endif
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,5.0)
      RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("\nResistance")
      RCell(RTF_RIGHT|RTF_THINBRD,19.0); RAddtext("Value \nOwn R ")
      for j=0,j<nc,j++ do              // For all capacitor values
        RCell(RTF_CENTERED|RTF_THINBRD,22.0)
        if cexp[j]<1.0e6 then
          RAddfmt("%5.3g nF",cexp[j]/1.0e3)
        else
          RAddfmt("%5.3g ",cexp[j]/1.0e6)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("F")
        endif
        RAddfmt("\n(%g Ohm)",rcap[j])
      enddo
      RCell(RTF_CENTERED|RTF_THINBRD,15.0); RAddtext("Bad")
      RCell(RTF_CENTERED|RTF_THINBRD,17.0); RAddtext("Passed")
      for i=0,i<nr,i++ do              // For all resistor values
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        if rexp[i]>1000000.0 then pr=2; fr=1000000.0;
        else if rexp[i]>1000.0 then pr=1; fr=1000.0;
        else pr=0; fr=1.0; endif
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,12.0)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        RAddfmt("\n%.3g %s",rexp[i]/fr,runitname[pr])
        RCell(RTF_RIGHT|RTF_THINBRD,19.0)
        if logmode==0 then
          RAddtext("Mean C \nCmin \nCmax \n")
        else
          RAddtext("Mean C \nDiff min \nDiff max \n")
        endif
        RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("s \n")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        if logmode==0 then
          RAddtext("Mean R \nRmin \nRmax \n")
        else
          RAddtext("Mean R \nDiff min \nDiff max \n")
        endif
        RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("s \n")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddtext("Bad/Limit")
        k=0; q=1
        for j=0,j<nc,j++ do            // For all capacitor values
          k=k+nbad[m,i,j]
          if pass[m,i,j]==0 q=0
          if cexp[j]>1000000.0 then pc=2; fc=1000000.0;
          else if cexp[j]>1000.0 then pc=1; fc=1000.0;
          else pc=0; fc=1.0; endif
          RCell(RTF_CENTERED|RTF_THINBRD,22.0)
          if pass[m,i,j]==0 then
            RFmt(RTF_TIMES,RTF_BOLD,9)
          else
            RFmt(RTF_TIMES,RTF_NORMAL,9)
          endif
          c=Getmean(cglob[m,i,j])
          RAddfmt("%.4g\n",c/fc)
          if logmode==1 then           // Differences
            RAddfmt("%+.3g\n",(Getmin(cglob[m,i,j])-c)/fc)
            RAddfmt("%+.3g\n",(Getmax(cglob[m,i,j])-c)/fc)
          else if logmode==2 && c==0.0 then
            RAddfmt("\n\n")
          else if logmode==2 then      // Percentages
            percent=(Getmin(cglob[m,i,j])-c)/c*100.0
            if percent>99.0 then RAddfmt("> 99%%\n");
            else if percent<(-99.0) then RAddfmt("<-99%%\n");
            else RAddfmt("%+.2g%%\n",percent); endif
            percent=(Getmax(cglob[m,i,j])-c)/c*100.0
            if percent>99.0 then RAddfmt("> 99%%\n");
            else if percent<(-99.0) then RAddfmt("<-99%%\n");
            else RAddfmt("%+.2g%%\n",percent); endif
          else
            RAddfmt("%.4g\n",Getmin(cglob[m,i,j])/fc)
            RAddfmt("%.4g\n",Getmax(cglob[m,i,j])/fc)
          endif
          RAddfmt("%.4g\n",Getsigma(cglob[m,i,j])/fc)
          r=Getmean(rglob[m,i,j])
          RAddfmt("%.4g\n",r/fr)
          if logmode==1 then           // Differences
            RAddfmt("%+.3g\n",(Getmin(rglob[m,i,j])-r)/fr)
            RAddfmt("%+.3g\n",(Getmax(rglob[m,i,j])-r)/fr)
          else if logmode==2 && r==0.0 then
            RAddfmt("\n\n")
          else if logmode==2 then      // Percentages
            percent=(Getmin(rglob[m,i,j])-r)/r*100.0
            if percent>99.0 then RAddfmt("> 99%%\n");
            else if percent<(-99.0) then RAddfmt("<-99%%\n");
            else RAddfmt("%+.2g%%\n",percent); endif
            percent=(Getmax(rglob[m,i,j])-r)/r*100.0
            if percent>99.0 then RAddfmt("> 99%%\n");
            else if percent<(-99.0) then RAddfmt("<-99%%\n");
            else RAddfmt("%+.2g%%\n",percent); endif
          else
            RAddfmt("%.4g\n",Getmin(rglob[m,i,j])/fr)
            RAddfmt("%.4g\n",Getmax(rglob[m,i,j])/fr)
          endif
          RAddfmt("%.4g\n",Getsigma(rglob[m,i,j])/fr)
          RAddfmt("%i / %i",nbad[m,i,j],nlimit[m,i,j])
        enddo
        RCell(RTF_CENTERED|RTF_THINBRD,15.0)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddfmt("\n%i",k)
        RCell(RTF_CENTERED|RTF_THINBRD,17.0)
        RAddtext(q==1?"\nYes":"\nNo")
      enddo
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Passed")
      RCell(RTF_RIGHT|RTF_THINBRD,19.0)
      for j=0,j<nc,j++ do
        RCell(RTF_CENTERED|RTF_THINBRD,22.0)
        RAddtext(cpass[m,j]?"Yes":"No")
      enddo
      RCell(RTF_CENTERED|RTF_THINBRD,15.0)
      RCell(RTF_CENTERED|RTF_THINBRD,17.0)
      RFmt(RTF_TIMES,RTF_BOLD,9)
      RAddtext(totalpass[m]?"Yes!":"No!")
      REndtable()
      Flusherrlist(m,2,0,-1)
    enddo
  endif
  if err==0 then
    Startexplanation()
    Explain("Comments to the table above: Each of %i serially connected ",nr*nc)
    Explain("R-C combinations is checked %i times by each finger, ",ntest*nrep)
    Explain("giving grand total of %i measurements. ",ntest*nrep*nr*nc*nused)
    if certify==0 then
      Explain("Test is passed when (a) all measurements are good (stable and ")
      Explain("reliable result), ")
    else
      n=nrep*ntest*FAILRATE+MAXFAILED
      Explain("Test is passed if there are not more than %i bad ",n)
      Explain("and/or out-of-range measurements for each R-C combination. ")
      Explain("Measurement is successfull when (a) result is stable and ")
      Explain("reliable, ")
    endif
    Explain("(b) maximal difference between measured and expected values ")
    Explain("does not exceed some R- and C-dependent limit ")
    Explain("(capacity: %g%% for C<30 nF, ",CFACTOR*(certify?150.0:100.0))
    Explain("highest RC compination is not checked, ")
    Explain("%g%% above 30 nF; ",CFACTORHI*(certify?150.0:100.0))
    Explain("resistance: %g/C Ohm ",RCPRODUCT*(certify?1.5:1.0))
    Explain("+ %g%% ",UCRFACTOR*(certify?150.0:100.0))
    Explain("+ %g Ohm), ",UCRABS*(certify?1.5:1.0))
    Explain("and (c) maximal capacity difference between the values for the ")
    Explain("given R-C combination (repeatability) is not worser than ")
    Explain("%g to ",UCREPEAT*(certify?300.0:200.0))
    Explain("%g%%, depending on voltage, ",UCREPEAT*(certify?1500.0:1000.0))
    Explain("frequency and serial resistance. Measurements take into ")
    Explain("account own resistance of the capacitors.")
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  if err==4 return 1                   // Operator interrupted test
  add hlist text="Universal C test interrupted!"
  clear hright
  change hinfo limits=0,0
  change hinfo text="Universal C error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Universal C test found some error in internal data structures. "
    draw text="Please contact atg. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid universal C "
    draw text="measurement. "
  endif
  draw text="Test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Checks HV measurements. In certification mode, 50 V test is not performed.
// If both hardware and OlliBoard support 1000 V, 1000 V test is performed.
// Resistances from 10 k to 10 M are tested by A5/A6 only once or twice due to
// their slowness.
function int HVtest(int ntest,int certify,int log)
  char rpairs500[10][14]= {          \ // Pads for HV500
    ":GND1\0  GND2",                 \ // Shortcut
    "*R2K94\0 R8K87",                \ // 11.81 k
    "*R29K4\0 R88K7",                \ // 118.1 k
    "*R88K7\0 R978K",                \ // 1.067 M
    "*R10M\0  GND2",                 \ // 10.0 M
    " R100M\0 GND2",                 \ // 100 M
    " R200M\0 GND2",                 \ // 200 M
    " RINF\0  GND2",                 \ // Infinite resistance
    " GND1\0  HV",                   \ // Breakdown (must be last in array!)
    "" };
  char rpairss3[10][14]= {           \ // Pads for HV1000 (1G unreachable)
    ":GND1\0  GND2",                 \ // Shortcut
    "*R2K94\0 R8K87",                \ // 11.81 k
    "*R88K7\0 R978K",                \ // 1.067 M
    "*R10M\0  GND2",                 \ // 10.0 M
    " R47M\0  GND2",                 \ // 47 M
    " R100M\0 GND2",                 \ // 100 M
    " R200M\0 GND2",                 \ // 200 M
    " RINF\0  GND2",                 \ // Infinite resistance
    " GND1\0  HV",                   \ // Breakdown (must be last in array!)
    "" };
  char rpairs1000[10][14]= {         \ // Pads for HV1000
    ":GND1\0  GND2",                 \ // Shortcut
    "*R88K7\0 R978K",                \ // 1.067 M
    "*R10M\0  GND2",                 \ // 10.0 M
    " R47M\0  GND2",                 \ // 47 M
    " R100M\0 GND2",                 \ // 100 M
    " R200M\0 GND2",                 \ // 200 M
    " R1G\0   GND2",                 \ // 1 G
    " RINF\0  GND2",                 \ // Infinite resistance
    " GND1\0  HV",                   \ // Breakdown (must be last in array!)
    "" };
  int vscale[4] = { 50,250,500,1000 }  // Test voltage
  int arrow[24] = {                  \ // HV warning arrow
    3,0,8,0,6,5,8,5,4,13,5,13,3,15,2,13,3,13,4,8,2,8,3,0 };
  int i,j,k,m,n,q,t,passed,vindex,vindexmax,vmax,nr,isa5,localv,err
  int comment1,comment2,nhvtest,oldhvtest,inistatus[4],units[10],rbad[4][10]
  int nretry,ntotal,nlow,nmid,nloop[10],nfailed[10],maxfailed[10]
  int skipped[4][10],skippedr
  float rmeas,f,percent,rexp[10],factor[10],r[4][10][5],brk[4][10][5]
  float limitmin[4][10],limitmax[4][10],tmean[4][10],tmax[4][10]
  float x1,x2,x[32],y[32],deltax,d
  char s[256],s1[256],s2[256],extra[1024],buf[64],rpairs[10][14],name[64]
  handle hinterrupt,hcont
  if (ntest==0) then
    if $LAY.nfing>=12 then
      ntest=8
    else if $LAY.nfing>=10 then
      ntest=10
    else
      ntest=16
    endif
  endif
  if ntest>32 ntest=32                 // Limited by number of buffers
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8                                     \
  then
    nlow=Max(1,ntest/8)
    nmid=Max(4,ntest/2)
  else
    nlow=ntest
    nmid=ntest
  endif
  // Determine maximal voltage.
  vmax=$EXTLAY.hvumax
  if vmax==0 then
    if ($EXTLAY.measopt & HCM_HVTYPE)==HCM_HV1000 then
      vmax=1000
    else if ($EXTLAY.measopt & HCM_HVTYPE)==HCM_HVAUTO then
      vmax=500                         // Security first
    else
      vmax=500
    endif
  endif
  if (romdata.features & BF_TYPE)==BF_1000V then
    vscale[3]=Min(1000,vmax)
    vindexmax=(vmax>=600?4:3)
    if ($LAY.rightlimit-$LAY.leftlimit)/1000.0<=330.0 then
      Memcpy(rpairs,rpairss3,Sizeof(rpairs))
    else
      Memcpy(rpairs,rpairs1000,Sizeof(rpairs))
    endif
  else
    vindexmax=3
    Memcpy(rpairs,rpairs500,Sizeof(rpairs))
  endif
  ntotal=0
  for nr=0,rpairs[nr][0]!='\0',nr++ do
    if rpairs[nr][0]=='*' then         // Strongly reduced number of tests
      nloop[nr]=nlow
      maxfailed[nr]=2*nlow*FAILRATE+MAXFAILED
      ntotal=ntotal+nlow
    else if rpairs[nr][0]==':' then    // Reduced number of tests
      nloop[nr]=nmid
      maxfailed[nr]=2*nmid*FAILRATE+MAXFAILED
      ntotal=ntotal+nmid
    else
      nloop[nr]=ntest
      maxfailed[nr]=2*ntest*FAILRATE+MAXFAILED
      ntotal=ntotal+ntest
    endif
    if certify==0 maxfailed[nr]=0
  enddo
  clear hright
  change hinfo limits=0,0
  change hinfo text="???12a?"
  Addreplaysection("HV measurements")
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  add hlist text="             HIGH VOLTAGE MEASUREMENTS"
  add hlist text=""
  add hlist text="Volt Expected    Rmean     Rmin     Rmax Brk Pass"
  draw window=hright color=LIGHTRED bkcolor=PINK
  for i=0,i<24,i++ do
    arrow[i]=arrow[i]*20+30
  enddo
  draw polygon=arrow,11
  draw font=TIMESFONT wrap=RIGHTX-5 at 6,30
  draw text="???1! ???e?D??!\n\n" color=BLACK
  draw text="???12a?o?"
  if vindexmax==4 then
    if certify==0 then
      draw text=format("%i, %i, %i o %i V",                                \
      vscale[0],vscale[1],vscale[2],vscale[3])
    else
      draw text=format("%i, %i o %i V. ",vscale[1],vscale[2],vscale[3])
    endif
  else
    if certify==0 then
      draw text=format("%i, %i o %i V. ",vscale[0],vscale[1],vscale[2])
    else
      draw text=format("%i o %i V. ",vscale[1],vscale[2])
    endif
  endif
  draw text="??o"
  draw text="??"
  draw text="??1. "
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D???Y2a?"
  endc
  for n=0,n<32,n++ do
    SYS.Killimm(n)                     // Remove all pending commands
  enddo
  Clearoversurface()
  Initerrlist()
  if log then
    if txtok then
      fprintf(hlog,"\nHigh voltage measurements:\n")
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddtext("\nHigh voltage measurements:\n")
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8                                     \
  then
    isa5=1
  else
    isa5=0
  endif
  nhvtest=0
  Memset(skipped,0,Sizeof(skipped))
  skippedr=0
  err=0
  for vindex=(certify?1:0),vindex<vindexmax && err==0,vindex++ do
    oldhvtest=nhvtest
  repeat:
    add hlist text=""
    for i=0,i<$LAY.nfing*2,i++ do      // Move all heads in home positions
      if used[i]==0 continue
      sprintf(s,"M %i(Z) NOP",i)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()
    while 1 do                         // Wait till all answers come back
      for i=0,i<$LAY.nfing*2,i++ do
        if used[i]==0 continue
        if $A[i].length==0 break
      enddo
      if i>=$LAY.nfing*2 then
        break                          // All answers came
      else if Pressed(hexit) then
        return -1                      // Operator interrupted test
      else if Time()-t>15000 then
        err=1; break                   // Timeout 15 seconds
      else if Pressed(hinterrupt) then
        err=4; break                   // Interrupt button pressed
      endif
      wait
    enddo
    if err!=0 break                    // Test cannot continue
    vmax=vscale[vindex]                // Voltage in volts
    nhvtest++
    passed=1
    for i=0,i<nr && err==0,i++ do      // For all resistors
      if i==0 || (i==1 && isa5!=0) then
        nretry=0
      retryinit:
        SYS.Killimm(32)
        if i==0 && isa5!=0 then
          // First component (shortcut) is measured in the fastest possible
          // mode and with increased Z stroke. Such measurements fail or report
          // false breakdowns in the very annoying case of jumping fingers.
          localv=strokev //Min(strokev+40,120)
          deltax=0.010
          buf[0]=S_HVINIT              // HV initialization
          $uint2(buf+1)=vmax           // Test voltage
          $uint2(buf+3)=0              // Mode
          $uint2(buf+5)=1000           // Maximal current, uA
          $uint2(buf+7)=100            // Maximal resistance, MOhm
          $uint4(buf+9)=2              // Sustain time, ms
          $uint4(buf+13)=500000        // Rising speed, V/ms
          $uint2(buf+17)=0             // Duration of initialization
          $uint4(buf+19)=0             // Reserved, must be zero
          $uint4(buf+23)=0             // Reserved, must be zero
          $uint4(buf+27)=0             // Reserved, must be zero
          SYS.Sendimm(32,31,buf)
        else if isa5!=0 then
          // A5, all subsequent components.
          localv=strokev
          deltax=0.000
          buf[0]=S_HVINIT              // HV initialization
          $uint2(buf+1)=vmax           // Test voltage
          $uint2(buf+3)=0              // Mode
          $uint2(buf+5)=1000           // Maximal current, uA
          $uint2(buf+7)=2000           // Maximal resistance, MOhm
          $uint4(buf+9)=30             // Sustain time, ms
          $uint4(buf+13)=100000        // Rising speed, V/ms
          $uint2(buf+17)=0             // Duration of initialization
          $uint4(buf+19)=0             // Reserved, must be zero
          $uint4(buf+23)=0             // Reserved, must be zero
          $uint4(buf+27)=0             // Reserved, must be zero
          SYS.Sendimm(32,31,buf)
        else
          // A2-based testers, all components.
          localv=strokev
          deltax=0.000
          buf[0]=S_HVINIT              // HV initialization
          $uint2(buf+1)=vmax           // Test voltage
          $uint2(buf+3)=1              // Max capacity, nanofarads
          $uint2(buf+5)=10             // Accuracy 10 promille (1%)
          $uint2(buf+7)=30             // Test time 30 ms
          $uint2(buf+9)=5              // Raise time 5 ms per 100 volt
          SYS.Sendimm(32,11,buf)
        endif
        t=Time()
        while 1 do                     // Wait till answer comes back
          if $A[32].length!=0 then
            break                      // Answer came
          else if Pressed(hexit) then
            return -1                  // Operator interrupted test
          else if Time()-t>15000 then
            err=1; break               // Timeout 15 seconds
          else if Pressed(hinterrupt) then
            err=4; break               // Interrupt button pressed
          endif
          wait
        enddo
        if $A[32].answer!=S_HVINIT err=3 // Unexpected answer
        if err!=0 break                // Test cannot continue
        j=$int4($A[32]+5)
        if vindexmax==4 && $int2($A[32]+9)<600 then
          vindexmax=3                  // Don't use 1000V verification
        endif
        if $int2($A[32]+9)<500 then    // Don't use 500V verification
          vindexmax=2
        endif
        nretry++
        if j!=0 && nretry<3 goto retryinit
        inistatus[vindex]=j
        if vindex==(certify?1:0) && (j & 0x80000000)!=0 then
          change hlist color=LIGHTRED
          add hlist text="HV card is not recognized"
          add hlist text=""
          err=2; break                 // HV card absent
        else if j!=0 then
          SERV.Decodeanswer($A[32],s,extra,0xFFFFFFFF)
          change hlist color=LIGHTRED
          add hlist text=format("Unable to initialize HV card for %i V",vmax)
          add hlist text=s
          add hlist text=""
          sprintf(s,"???12a?? %i V",vmax)
          if certify!=0 then
            j=Askrepeat(s)
            if j<0 return -1
            if j==1 then
              nhvtest=oldhvtest
              goto repeat
            endif
          endif
          Summary(0,"%s",s)
          break                        // Continue with another voltage
        endif
      endif
      Initsigma(r[vindex,i])
      Initsigma(brk[vindex,i])
      rbad[vindex][i]=0
      tmean[vindex,i]=0.0; tmax[vindex,i]=0.0
      nfailed[i]=0
      for j=0,xname[j][0]!='\0',j++ do // Find resistance between pads
        if Strcmp(rpairs[i]+1,xname[j])==0 then
          x1=xpos[j]
          rexp[i]=value[j]             // In Ohms
          break
        endif
      enddo
      if xname[j][0]=='\0' err=5
      for j=0,xname[j][0]!='\0',j++ do // Find resistance between pads
        if Strcmp(rpairs[i]+8,xname[j])==0 then
          rexp[i]=rexp[i]+value[j]
          x2=xpos[j]
          break
        endif
      enddo
      if rexp[i]>0.9*HVRMAX rexp[i]=HVRMAX
      if xname[j][0]=='\0' err=5
      rmeas=Min(rexp[i],HVRMAX)
      limitmin[vindex][i]=rmeas*(1.0-HVFACTORLO-HVVCORR/vmax)-HVABSLO
      limitmax[vindex][i]=rmeas*(1.0+HVFACTORLO+HVVCORR/vmax)+HVABSLO
      if rmeas>HVTHRESHOLD then
        limitmin[vindex][i]=limitmin[vindex][i]-(rmeas-HVTHRESHOLD)*HVFACTORHI
        limitmax[vindex][i]=limitmax[vindex][i]+(rmeas-HVTHRESHOLD)*HVFACTORHI
      endif
      if rexp[i]>HVRMAX*0.9 limitmax[vindex][i]=1.0e99
      units[i]=0; factor[i]=1.0
      while Abs(rmeas)>=920.0 && units[i]<3 do
        rmeas=rmeas/1000.0; factor[i]=factor[i]*1000.0; units[i]++
      enddo
      if i==nr-1 && vmax>=BRKMIN then
        limitmin[vindex][i]=GLOWRMIN   // Breakdown resistance
        limitmax[vindex][i]=GLOWRMAX
        rmeas=75.0
        factor[i]=1000.0; units[i]=1
      endif
      if err!=0 break
      if vmax>500 && rpairs[i][0]=='*' then
        skipped[vindex][i]=1
        skippedr=skippedr|1            // Not specified for HV1000
        continue
      endif
      if (romdata.features & BF_TYPE)==BF_TRIPOD &&                            \
        (Strcmp(rpairs[i]+1,"R100M")==0 || Strcmp(rpairs[i]+8,"R100M")==0 ||   \
        Strcmp(rpairs[i]+1,"R200M")==0 || Strcmp(rpairs[i]+8,"R200M")==0 ||    \
        Strcmp(rpairs[i]+1,"HV")==0 || Strcmp(rpairs[i]+8,"HV")==0)            \
      then
        skipped[vindex][i]=1
        skippedr=skippedr|2            // Component is missing
        continue
      endif
      for j=0,j<$LAY.nfing*2,j=j+2 do  // Calculate coordinates of all fingers
        if used[j]==0 continue
        Convert(x+j,y+j,x1,ypos[j],DELTA)
        sprintf(s,"M %i[%g,%gA%iV%iP%i] NOP",                                  \
          j,x[j],y[j],acc,localv,strokep)
        if SERV.Cmdimm(j,s)<0 err=1    // Move all fingers to pads
        Convert(x+j+1,y+j+1,x2,ypos[j+1],DELTA)
        sprintf(s,"M %i[%g,%gA%iV%iP%i] NOP",                                  \
          j+1,x[j+1],y[j+1],acc,localv,strokep)
        if SERV.Cmdimm(j+1,s)<0 err=1  // Move all fingers to pads
      enddo
      t=Time()
      while err==0 do
        for j=0,j<$LAY.nfing*2,j++ do
          if used[j]==0 continue
          if $A[j].length==0 break
        enddo
        if j>=$LAY.nfing*2 break       // All answers here
        if Pressed(hexit) err=-1       // Operator interrupted test
        if Time()-t>10000 err=1        // Timeout
        if Pressed(hinterrupt) err=4   // Operator interrupted test
        wait
      enddo
      if err!=0 break
      delay 1000                       // Reduces tester vibrations after move
      if certify==0 && usestat==1 then
        // Initialize measurement card statistics.
        buf[0]=S_DEBUG
        buf[1]=0x2F                    // Statistical data
        buf[2]=0x80                    // Measurement card
        buf[3]=1                       // Reset statistics
        $int2(buf+4)=0x32              // Page 0x32
        $int4(buf+6)=0                 // Must be zero
        SYS.Sendimm(32,10,buf)
      endif
      // Statistics for selected resistor.
      for n=0,n<nloop[i],n++ do
        change hinfo limits=(vindex*nr+i)*ntest+n*ntest/nloop[i],              \
          vindexmax*nr*ntest
        // Test each rail.
        for j=0,j<$LAY.nfing*2,j=j+2 do
          if used[j]==0 continue
          sprintf(s1,"M %i[%g,%gA%iV%iP%i] %i[%g,%gA%iV%iP%i] H(%i,%i)",       \
            j,x[j],y[j],acc,localv,strokep,                                    \
            j+1,x[j+1],y[j+1],acc,localv,strokep,j,j+1)
          sprintf(s2,"M %i[%g,%gA%iV%iP%i] %i[%g,%gA%iV%iP%i] H(%i,%i)",       \
            j,x[j]-deltax,y[j],acc,localv,strokep,                             \
            j+1,x[j+1]+deltax,y[j+1],acc,localv,strokep,j+1,j)
          // To speed up test (but still detect all possible problems), send at
          // once 4 commands (2 in each direction).
          if SERV.Cmdimm(0,s1)<0 err=5
          if SERV.Cmdimm(1,s2)<0 err=5
          if SERV.Cmdimm(2,s1)<0 err=5
          if SERV.Cmdimm(3,s2)<0 err=5
          t=Time()
          while err==0 do
            for k=0,k<4,k++ do
              if $A[k].length==0 break
            enddo
            if k>=4 break              // All answers here
            if Pressed(hexit) err=-1   // Operator interrupted test
            if Time()-t>10000 err=1    // Timeout 10 s
            if Pressed(hinterrupt) err=4
            wait
          enddo
          if err!=0 break
          m=sprintf(name,"%g V, ",vscale[vindex])
          if rexp[i]>=HVRMAX then
            sprintf(name+m,"open")
          else if i==nr-1 then
            sprintf(name+m,"glow lamp")
          else
            sprintf(name+m,"%.3g %s",rexp[i]/factor[i],runitname[units[i]])
          endif
          for k=0,k<4,k++ do
            if $A[k].answer!=S_MOVE then
              err=3; break             // Unexpected answer
            endif
            m=0
            rmeas=$A[k].r
            if ($A[k].status & 0x0020)!=0 then
              Addsigma(brk[vindex][i],rmeas)
              if i!=nr-1 || vmax<BRKMIN then
                if extendederr==0 then
                  Adderr(s1,vindex,j,"Unexpected breakdown at %s",name)
                else
                  Adderr(s1,vindex,j,                                          \
                  "Unexpected breakdown %g V at %s",rmeas,name)
                endif
                m=1
              endif
            else
              Addsigma(r[vindex][i],rmeas)
              if i==nr-1 && vmax>=BRKMIN then
                // Expecting break, but may be R.
                if (rmeas<GLOWRMIN || rmeas>GLOWRMAX) then
                  if extendederr==0 then
                    Adderr(s1,vindex,j,                                        \
                    "Invalid resistance of glow lamp at %s",name)
                  else
                    Adderr(s1,vindex,j,                                        \
                    "Resistance of glow (%g k) out of limits (%g..%g k) at %s",\
                    rmeas/1000.0,GLOWRMIN/1000.0,GLOWRMAX/1000.0,name)
                  endif
                  m=1
                endif
              else
                // Ordinary measurement, check range.
                if rmeas<=limitmin[vindex][i] ||                               \
                  rmeas>=limitmax[vindex][i] then
                  if extendederr==0 then
                    Adderr(s1,vindex,j,                                        \
                    "Resistance out of range at %s",name)
                  else
                    Adderr(s1,vindex,j,                                        \
                    "Resistance %.4g %s out of range %.4g..%.4g %s at %s",     \
                    rmeas/factor[i],runitname[units[i]],                       \
                    limitmin[vindex][i]/factor[i],                             \
                    limitmax[vindex][i]/factor[i],runitname[units[i]],name)
                  endif
                  m=1
                endif
              endif
            endif
            if ($A[k].status & 0x005F)!=0 then
              Adderr(s1,vindex,j,"Bad measurements at %s",name)
              rbad[vindex][i]++; m=1
            endif
            if m!=0 nfailed[i]++       // Count of unsuccessfull measurements
            if log then
              m=sprintf(s,"  HV heads %2i-%2i (%s):",j,j+1,name)
              while m<36 do s[m]=' '; m++; enddo
              if ($A[k].status & 0x0020)!=0 then
                m=m+sprintf(s+m,"Break %g V",rmeas)
              else
                m=m+sprintf(s+m,"R=%.3g %4s",                                  \
                rmeas/factor[i],runitname[units[i]])
              endif
              sprintf(s+m,", status %04X",$A[k].status)
              lprintf(GREEN,"%s",s)
              if txtok!=0 then
                fprintf(hlog,"%s\n",s)
              endif
              if rtfok!=0 then
                RAddfmt("%s\n",s)
              endif
            endif
          enddo
          if err!=0 break
          sprintf(s,"M %i[%g,%g] %i[%g,%g] NOP",                               \
            j,x[j]-0.1,y[j],j+1,x[j+1]+0.1,y[j+1])
          if SERV.Cmdimm(32,s)<0 err=1
        enddo
        if err!=0 break
      enddo
      if nfailed[i]>maxfailed[i] passed=0
      if certify==0 && usestat==1 then
        // Read measurement statistics.
        buf[0]=S_DEBUG
        buf[1]=0x2F                    // Statistical data
        buf[2]=0x80                    // Measurement card
        buf[3]=1                       // Reset statistics afterwards
        $int2(buf+4)=0x32              // Page 0x32
        $int4(buf+6)=0                 // Must be zero
        SYS.Sendimm(0,10,buf)
        t=Time()
        while err==0 do
          if $A[0].length!=0 break
          if Pressed(hexit) err=-1     // Operator interrupted test
          if Time()-t>10000 err=1      // Timeout
          if Pressed(hinterrupt) err=4 // Operator interrupted test
          wait
        enddo
        if err==0 && $A[0].answer==S_DEBUG then
          tmean[vindex,i]=$uint4($A[0]+5+0*4)/1000.0
          tmax[vindex,i]=$uint4($A[0]+5+1*4)/1000.0
        endif
      endif
      // Measurements for resistance i finished. Display message.
      if err==0 then
        if vmax==1000 then
          j=sprintf(s,"1kV ")
        else
          j=sprintf(s,"%3i ",vmax)
        endif
        if rexp[i]>=HVRMAX then
          j=j+sprintf(s+j,"     Open")
        else if i==nr-1 then           // Breakdown test
          j=j+sprintf(s+j,"Glow lamp")
        else
          sprintf(s+j,"%4.3g",rexp[i]/factor[i]); j=j+4
          if units[i]==0 j=j+Sprintf(s+j,"  Ohm")
          if units[i]==1 j=j+Sprintf(s+j," kOhm")
          if units[i]==2 j=j+Sprintf(s+j," MOhm")
          if units[i]==3 j=j+Sprintf(s+j," GOhm")
        endif
        q=1
        k=Getcount(r[vindex][i])
        if k==0 then
          j=j+Sprintf(s+j,"                           ")
          if i!=nr-1 q=0
        else
          j=j+Sprintf(s+j," %8.3g %8.3g %8.3g",                                \
            Getmean(r[vindex][i])/factor[i],                                   \
            Getmin(r[vindex][i])/factor[i],                                    \
            Getmax(r[vindex][i])/factor[i])
          if i!=nr-1 q=(Getmin(r[vindex][i])>limitmin[vindex][i] &&            \
            Getmax(r[vindex][i])<limitmax[vindex][i])
          ;
        endif
        // I allow for some part of breakdowns on glow lamp to be recognized as
        // resistor in 50..100 k range.
        if i==nr-1 && vmax>BRKMAX && k!=0 then
          if certify==0 && k>(k+Getcount(brk[vindex][i]))*NOBREAKS+1 q=0
          if Getmin(r[vindex][i])<GLOWRMIN q=0
          if Getmax(r[vindex][i])>GLOWRMAX q=0
        endif
        if (rbad[vindex][i]!=0) q=0
        if (i<nr-1 && Getcount(brk[vindex][i])!=0) q=0
        if (i==nr-1 && vmax<BRKMIN && Getcount(brk[vindex][i])!=0) q=0
        j=j+Sprintf(s+j," %3i %s",Getcount(brk[vindex][i]),q?"Yes":"No")
        change hlist color=(q?BLACK:LIGHTRED)
        add hlist text=s
      endif
      if err!=0 break
    enddo
    if err==0 then
      sprintf(s,"???12a?? %i V",vmax)
      if passed==0 && certify!=0 then
        i=Askrepeat(s)
        if i<0 return -1
        if i==1 then
          nhvtest=oldhvtest
          goto repeat
        endif
      endif
      Summary(passed,"%s",s)
    endif
  enddo
  if err==(-1) return -1               // Operator interrupted test
  if err==0 && txtok!=0 then           // Write measured data to .TXT protocol
    for vindex=(certify?1:0),vindex<vindexmax,vindex++ do
      if (inistatus[0] & 0x80000000)==0 then
        fprintf(hlog,"\n                  ")
        fprintf(hlog,"High voltage resistance measurements - %i V",            \
        vscale[vindex])
      else
        fprintf(hlog,"\nThere is no high voltage card. HV test skipped.\n\n")
        break
      endif
      if inistatus[vindex]!=0 then
        fprintf(hlog,"\n\nMeasurement system test was unable to initialize "   \
          "high voltage\nmeasurement card. Tester reported error "             \
          "0x%08X.\n\n",inistatus[vindex])
        continue
      endif
      if certify==0 && usestat==1 then
        fprintf(hlog,"\n\n  Expected R    R mean  %s   %s\n",                  \
        logmode==0?"    Rmin      Rmax":"Diff min  Diff max",                  \
        "Sigma  Test Brks  Bad dT,ms Pass")
      else                             // Additional column: dT
        fprintf(hlog,"\n\n  Expected R    R mean  %s    %s\n",                 \
        logmode==0?"    Rmin      Rmax":"Diff min  Diff max",                  \
        "Sigma  Tests Breaks   Bad  Pass")
      endif
      comment1=0; comment2=0
      for i=0,i<nr-1,i++ do
        f=factor[i]
        n=Getcount(r[vindex][i])
        if rexp[i]>0.9*HVRMAX then
          sprintf(s,"> %.4g",rexp[i]/f)
          fprintf(hlog,"\n%7s",s)
        else
          fprintf(hlog,"\n%7.4g",rexp[i]/f)
        endif
        fprintf(hlog," %-6s",runitname[units[i]])
        if skipped[vindex][i] then
          q=0
        else
          q=(Getmin(r[vindex][i])>limitmin[vindex][i] &&                       \
          Getmax(r[vindex][i])<limitmax[vindex][i] &&                          \
          Getcount(brk[vindex][i])==0 && rbad[vindex][i]==0)
        endif
        if n>0 then fprintf(hlog,"%8.4g",Getmean(r[vindex][i])/f);
        else fprintf(hlog,"       -"); endif
        if n>0 then                    // Minimum
          fprintf(hlog," ")
          rmeas=Getmin(r[vindex][i])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+9.2g",(rmeas-rexp[i])/f)
          else if logmode==2 && rexp[i]<500.0 then // Low diffs
            fprintf(hlog,"%8.2gr",(rmeas-rexp[i])/f); comment1=1;
          else if logmode==2 then      // Percentages
            percent=(rmeas-rexp[i])/rexp[i]*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.4g",rmeas/f)
          endif
        else
          fprintf(hlog,"          ")
        endif
        if n>0 then                    // Maximum
          fprintf(hlog," ")
          rmeas=Getmax(r[vindex][i])
          if logmode==1 then           // Differences
            fprintf(hlog,"%+9.2g",(rmeas-rexp[i])/f)
          else if logmode==2 && rexp[i]<500.0 then // Low diffs
            fprintf(hlog,"%8.2gr",(rmeas-rexp[i])/f); comment1=1;
          else if logmode==2 then      // Percentages
            percent=(rmeas-rexp[i])/rexp[i]*100.0
            if percent>99.0 then fprintf(hlog,"    > 99%%");
            else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
            else fprintf(hlog,"%+8.2g%%",percent); endif
          else                         // Absolute values
            fprintf(hlog,"%9.4g",rmeas/f)
          endif
        else
          fprintf(hlog,"          ")
        endif
        if certify==0 && usestat==1 then
          if n>1 then                  // Deviation
            fprintf(hlog,"%8.2g",Getsigma(r[vindex][i])/f)
          else
            fprintf(hlog,"        ")
          endif
        else
          if n>1 then
            fprintf(hlog,"%9.2g",Getsigma(r[vindex][i])/f)
          else
            fprintf(hlog,"         ")
          endif
        endif
        if skipped[vindex][i]==0 then
          if certify==0 && usestat==1 then
            fprintf(hlog,"%6i",nloop[i]*nused*2)
            fprintf(hlog,"%5i",Getcount(brk[vindex][i]))
            fprintf(hlog,"%5i",rbad[vindex][i])
            if tmean[vindex][i]==0.0 then
              fprintf(hlog,"      ")
            else if tmean[vindex][i]>99.9 then
              fprintf(hlog,"%6.0f",tmean[vindex][i])
            else
              fprintf(hlog,"%6.1f",tmean[vindex][i])
            endif
            fprintf(hlog,"%5s",q==0?" No":"Yes")
          else
            fprintf(hlog,"%7i",nloop[i]*nused*2)
            fprintf(hlog,"%7i",Getcount(brk[vindex][i]))
            fprintf(hlog,"%6i",rbad[vindex][i])
            fprintf(hlog,"%6s",q==0?" No":"Yes")
          endif
        endif
      enddo
      if skipped[vindex][i] then
        fprintf(hlog,"\n   Glow lamp         -")
      else
        fprintf(hlog,"\n   Glow lamp   (volts)")
        q=1
        k=Getcount(r[vindex][i])
        n=Getcount(brk[vindex][i])
        // I allow for some part of breakdowns on glow lamp to be recognized as
        // resistor in 50..100 k range.
        if vscale[vindex]>BRKMAX && k!=0 then
          if k>(k+n)*NOBREAKS+1 q=0
          if Getmin(r[vindex][i])<GLOWRMIN q=0
          if Getmax(r[vindex][i])>GLOWRMAX q=0
        endif
        if (rbad[vindex][i]!=0) q=0
        if (vscale[vindex]<BRKMAX && n!=0) q=0
        if n>0 then                    // Minimum and maximum
          fprintf(hlog," %8.4gv",Getmin(brk[vindex][i]))
          fprintf(hlog," %8.4gv",Getmax(brk[vindex][i]))
          comment2=1
        else
          fprintf(hlog,"                    ")
        endif
        if certify==0 && usestat==1 then
          fprintf(hlog,"%14i",nloop[i]*nused*2)
          fprintf(hlog,"%5i",n)
          fprintf(hlog,"%5i",rbad[vindex][i])
          if tmean[vindex][i]==0.0 then
            fprintf(hlog,"      ")
          else if tmean[vindex][i]>99.9 then
            fprintf(hlog,"%6.0f",tmean[vindex][i])
          else
            fprintf(hlog,"%6.1f",tmean[vindex][i])
          endif
          fprintf(hlog,"%5s",q==0?" No":"Yes")
        else
          fprintf(hlog,"%16i",nloop[i]*nused*2)
          fprintf(hlog,"%7i",n)
          fprintf(hlog,"%6i",rbad[vindex][i])
          fprintf(hlog,"%6s",q==0?" No":"Yes")
        endif
      endif
      if comment1!=0 || comment2!=0 fprintf(hlog,"\n")
      if comment1!=0 then
        fprintf(hlog,"\nLetter 'r' means difference in Ohms")
      endif
      if comment2!=0 then
        fprintf(hlog,"\nLetter 'v' means voltage in volts")
      endif
      Flusherrlist(vindex,1,1,-1)
      fprintf(hlog,"\n\n--------------------------------------")
      fprintf(hlog,"---------------------------------------\n")
    enddo
  endif
  if err==0 && rtfok!=0 then           // Write measured data to .RTF protocol
    d=(certify || usestat!=1?0.0:1.0)
    for vindex=(certify?1:0),vindex<vindexmax,vindex++ do
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      RAddtext("\nHigh voltage resistance measurements")
      if (inistatus[0] & 0x80000000)==0 then
        RAddfmt(" - %i V",vscale[vindex])
      else
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RParagraph(RTF_FORMAT)
        RAddtext("There is no high voltage card. Step skipped.")
        break
      endif
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      if inistatus[vindex]!=0 then
        RParagraph(RTF_FORMAT)
        RAddfmt("Measurement system test was unable to initialize high-"       \
          "voltage measurement card. Tester reported error "                   \
          "0x%08X.",inistatus[vindex])
        continue
      endif
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,8.0)
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RCell(RTF_CENTERED|RTF_THINBRD,19.0-d); RAddtext("Expected\nresistance")
      RCell(RTF_CENTERED|RTF_THINBRD,14.0); RAddtext("Units")
      RCell(RTF_CENTERED|RTF_THINBRD,19.0-d); RAddtext("R mean")
      RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
      RAddtext(logmode==0?"Rmin":"Diff min")
      RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
      RAddtext(logmode==0?"Rmax":"Diff max")
      RCell(RTF_CENTERED|RTF_THINBRD,17.0-d)
      RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("s")
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0-2*d); RAddtext("Tests")
      RCell(RTF_CENTERED|RTF_THINBRD,14.0-2*d)
      RAddtext(certify?"Breaks":"Brk")
      RCell(RTF_CENTERED|RTF_THINBRD,11.0-d); RAddtext("Bad")
      if certify==0 then
        RCell(RTF_CENTERED|RTF_THINBRD,d*11); RAddtext("dT,\nms")
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,13.0-d)
      RAddtext(certify?"Passed":"Pass")
      comment1=0; comment2=0
      for i=0,i<nr-1,i++ do
        f=factor[i]
        n=Getcount(r[vindex][i])
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
        if rexp[i]>0.9*HVRMAX RAddtext("> ")
        RAddfmt("%.4g",rexp[i]/f)
        RCell(RTF_CENTERED|RTF_THINBRD,14.0); RAddtext(runitname[units[i]])
        if skipped[vindex][i] then
          q=0
        else
          q=(Getmin(r[vindex][i])>limitmin[vindex][i] &&                       \
          Getmax(r[vindex][i])<limitmax[vindex][i] &&                          \
          Getcount(brk[vindex][i])==0 && rbad[vindex][i]==0)
        endif
        RFmt(RTF_TIMES,q==0?RTF_BOLD:RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
        if n>0 then RAddfmt("%.4g",Getmean(r[vindex][i])/f);
        else RAddtext("-"); endif
        RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
        if n>0 then                    // Minimum
          rmeas=Getmin(r[vindex][i])
          if logmode==1 then           // Differences
            RAddfmt("%+.2g",(rmeas-rexp[i])/f)
          else if logmode==2 && rexp[i]<500.0 then // Low diffs
            RAddfmt("%+.3g",(rmeas-rexp[i])/f)
            RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
            RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("*")
            RFmt(RTF_TIMES,q==0?RTF_BOLD:RTF_NORMAL,9); comment1=1;
          else if logmode==2 then      // Percentages
            percent=(rmeas-rexp[i])/rexp[i]*100.0
            if percent>99.0 then RAddtext("> 99%");
            else if percent<(-99.0) then RAddtext("<-99%");
            else RAddfmt("%+.2g%%",percent); endif
          else                         // Absolute values
            RAddfmt("%.4g",rmeas/f)
          endif
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
        if n>0 then                    // Maximum
          rmeas=Getmax(r[vindex][i])
          if logmode==1 then           // Differences
            RAddfmt("%+.2g",(rmeas-rexp[i])/f)
          else if logmode==2 && rexp[i]<500.0 then // Low diffs
            RAddfmt("%+.3g",(rmeas-rexp[i])/f)
            RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
            RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("*")
            RFmt(RTF_TIMES,q==0?RTF_BOLD:RTF_NORMAL,9); comment1=1;
          else if logmode==2 then      // Percentages
            percent=(rmeas-rexp[i])/rexp[i]*100.0
            if percent>99.0 then RAddtext("> 99%");
            else if percent<(-99.0) then RAddtext("<-99%");
            else RAddfmt("%+.2g%%",percent); endif
          else                         // Absolute values
            RAddfmt("%.4g",rmeas/f)
          endif
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,17.0-d)
        if n>1 then                    // Deviation
          RFmt(RTF_SYMBOL,RTF_NORMAL,9)
          RAddtext("?")                // Plus/minus symbol
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddfmt("%.2g",Getsigma(r[vindex][i])/f)
          RFmt(RTF_TIMES,q==0?RTF_BOLD:RTF_NORMAL,9)
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,14.0-2*d)
        if skipped[vindex][i]==0 then
          RAddfmt("%i",nloop[i]*nused*2)
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,14.0-2*d)
        if skipped[vindex][i]==0 then
          RAddfmt("%i",Getcount(brk[vindex][i]))
        endif
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,11.0-d);
        if skipped[vindex][i]==0 then
          RAddfmt("%i",rbad[vindex][i])
        endif
        if certify==0 && usestat==1 then
          RCell(RTF_CENTERED|RTF_THINBRD,d*11)
          if tmean[vindex][i]!=0.0 then
            RAddfmt("%.1f",tmean[vindex][i])
          endif
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,13.0-d)
        if skipped[vindex][i]==0 then
          RAddtext(q==0?"No":"Yes")
        endif
      enddo
      k=Getcount(r[vindex][i])
      n=Getcount(brk[vindex][i])
      // I allow for some part of breakdowns on glow lamp to be recognized as
      // resistor in 50..100 k range.
      q=1
      if skipped[vindex][i]==0 then
        if vscale[vindex]>BRKMAX && k!=0 then
          if k>(k+n)*NOBREAKS+1 q=0
          if Getmin(r[vindex][i])<GLOWRMIN q=0
          if Getmax(r[vindex][i])>GLOWRMAX q=0
        endif
        if (rbad[vindex][i]!=0) q=0
        if (vscale[vindex]<BRKMAX && n!=0) q=0
      endif
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
      RAddtext(certify?"Glow lamp":"Glow")
      RCell(RTF_CENTERED|RTF_THINBRD,14.0); RAddtext("Volts")
      RFmt(RTF_TIMES,q==0?RTF_BOLD:RTF_NORMAL,9)
      RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
      if skipped[vindex][i] RAddtext("-")
      RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
      if skipped[vindex][i]==0 && n>0 then
        RAddfmt("%.4g",Getmin(brk[vindex][i]))
        RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("?"); comment2=1
        RFmt(RTF_TIMES,q==0?RTF_BOLD:RTF_NORMAL,9)
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,19.0-d)
      if skipped[vindex][i]==0 && n>0 then
        RAddfmt("%.4g",Getmax(brk[vindex][i]))
        RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("?"); comment2=1
        RFmt(RTF_TIMES,q==0?RTF_BOLD:RTF_NORMAL,9)
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,17.0-d)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0-2*d)
      if skipped[vindex][i]==0 RAddfmt("%i",nloop[i]*nused*2)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0-2*d)
      if skipped[vindex][i]==0 RAddfmt("%i",n)
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RCell(RTF_CENTERED|RTF_THINBRD,11.0-d);
      if skipped[vindex][i]==0 RAddfmt("%i",rbad[vindex][i])
      if certify==0 then
        RCell(RTF_CENTERED|RTF_THINBRD,d*11)
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,13.0-d)
      if skipped[vindex][i]==0 RAddtext(q==0?"No":"Yes")
      REndtable()
      if comment1!=0 then
        RParagraph(RTF_FORMAT)
        RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,10); RAddtext("          *")
        RFmt(RTF_TIMES,RTF_ITALIC,10)
        RAddtext(" Difference in Ohms.")
      endif
      if comment2!=0 then
        RParagraph(RTF_FORMAT)
        RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,10); RAddtext("          ?")
        RFmt(RTF_TIMES,RTF_ITALIC,10)
        RAddtext(" Breakdown voltage in volts.")
      endif
      Flusherrlist(vindex,2,1,-1)
    enddo
  endif
  if err==0 then
    if nhvtest>0 then                  // No explanation if no tests
      Startexplanation()
      Explain("Comments to the tables above: Each of %i different ",nr)
      Explain("resistors or their combinations is checked ")
      if nlow==ntest then
        Explain("%i times ",ntest*2)
      else
        Explain("from %i to %i times ",nlow*2,ntest*2)
      endif
      Explain("by each finger for each voltage, giving grand total of ")
      Explain("%i measurements. ",ntotal*nused*2*vindexmax)
      if isa5 then
        Explain("To check for possible false opens due to the unstable ")
        Explain("contact, shortcut is tested in the fastest possible mode ")
        Explain("with increased stroke. ")
      endif
      Explain("Test is passed when ")
      if maxfailed[0]==0 then
        Explain("(a) all measurements are good (stable and reliable results, ")
      else
        Explain("total number of bad measurements for each resistor or glow ")
        Explain("lamp does not exceed %i. Measurement ",maxfailed[0])
        Explain("is good when (a) result is stable and reliable (")
      endif
      Explain("no unexpected breakdowns, nets are discharged) and (b) ")
      Explain("maximal difference between measured and ")
      Explain("expected values does not exceed %g%% + ",HVFACTORLO*100.0)
      Explain("%g Ohm. For resistors over %g MOhm, ",HVABSLO,HVTHRESHOLD/1.0e6)
      Explain("this limit is extended by additional %g%%. ",HVFACTORHI*100.0)
      Explain("Glow lamp must have ignition voltage in the range from ")
      Explain("%i to %i volts. In this case, tester must ",BRKMIN,BRKMAX)
      Explain("detect %i breakdowns. As glow lamp is not ",ntest*nused*2)
      Explain("a real spark gap, ")
      if certify==0 then
        Explain("up to %.0f%% of breaks ",NOBREAKS*100.0)
      else
        Explain("some breaks ")
      endif
      Explain("may be reported as shorts in range %.0f..",GLOWRMIN/1000.0)
      Explain("%.0f kOhm.",GLOWRMAX/1000.0)
      if skippedr & 2 then
        Explain("\nSome resistors on the OlliBoard are not certified for the ")
        Explain("voltage exceeding 500 V or are replaced by the alternative ")
        Explain("components. They were excluded from the test.")
      else if skippedr then
        Explain("\nSome resistors on the OlliBoard are not certified for ")
        Explain("the voltage exceeding 500 V. They were excluded from the ")
        Explain("%i V tests.",vscale[3])
      endif
      if certify==0 then
        Explain("\nMean duration of measurements is in milliseconds and does ")
        Explain("not include X-Y or Z movements.")

        /////ADD SUSTAIN TIME AND OTHER PARAMETERS!!!!!!!!!!!!!!!

      endif
      Endexplanation()
    endif
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  add hlist text="HV test interrupted!"
  if err==4 return 1                   // Operator interrupted test
  clear hright
  change hinfo text="HV test error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    draw text="No HV measurement card!"
    draw at 6,60 color=BLACK
    draw text="Tester was unable to detect presence of HV card in your tester. "
    draw text="If you do have it, please assure that it is inserted. This "
    draw text="error is not critical. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid high voltage "
    draw text="measurement. "
  else if err==5 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="High voltage test or one of the service routines found some "
    draw text="error in internal data structures. Please contact atg. "
  endif
  draw text="High voltage test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
    limits=(err==2?15000:0),0          // Wait 15 s if HV card absent
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return (err==2?0:1)
    wait
  enddo
end

// Measures own capacity of the needle and its spatial distribution.
function int Ownc(int ntest)
  int i,k,n,t,head,rail,err
  int ref[4],success[32],nbad[32]
  char s[512]
  float x,y,xref[4],yref[4],xt,yt,zc,zr,c1,c2,c3,c4
  float c[32][4][5],ctotal[32][5],diff[32]
  handle hinterrupt,hcont
  if nused<8 || testersides!=0x03 || (features & MF_MULTIC)==0 then
    return 0                           // Need additional rails on both sides
  endif
  if ntest<1 ntest=1                   // Correct obvious errors
  if ntest>32 ntest=32
  clear hright
  change hinfo limits=0,0
  change hinfo text="??Y"
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  add hlist text="             OWN CAPACITY OF THE NEEDLE"
  add hlist text=""
  add hlist text="Head    Ctotal      C1      C2      C3      C4,pf"
  add hlist text=""
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="?2a??1????????MSD?,??"
  draw text="?a??2a???Y????????2a????"
  draw text="??Y?????????3D???o"
  draw text="\n\n" font=MAINFONT
  draw text="                      C1  C2\n"
  draw text="                      C3  C4"
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D?????Y2a?"
  endc
  Clearoversurface()
  Initerrlist()
  err=0
  for head=0,head<$LAY.nfing*2,head++ do
    nbad[head]=0
    Initsigma(ctotal[head])
    for i=0,i<4,i++ do
      Initsigma(c[head][i])
    enddo
    success[head]=0
  enddo
  for head=0,head<$LAY.nfing*2 && err==0,head++ do
    if used[head]==0 continue
    // Select head position.
    Convertpad(&x,&y,"OWNC",head,0.0)
    // Select reference heads on the same side.
    for rail=0,rail<$LAY.nfing,rail++ do
      if used[rail*2]==0 continue
      if $LAY.side[rail]!=$LAY.side[head/2] continue
      Convertpad(xref+0,yref+0,"SIDEL",rail*2,DELTA)
      if Abs(yref[0]-y)>50.0 break
    enddo
    if rail<$LAY.nfing then
      Convertpad(xref+1,yref+1,"SIDER",rail*2+1,DELTA)
      ref[0]=rail*2
      ref[1]=rail*2+1
      // Select reference heads on the opposite side.
      for rail=0,rail<$LAY.nfing,rail++ do
        if used[rail*2]==0 continue
        if $LAY.side[rail]==$LAY.side[head/2] continue
        Convertpad(xref+2,yref+2,"SIDEL",rail*2,DELTA)
        if Abs(yref[2]-yref[0])<10.0 break
      enddo
      if rail<$LAY.nfing then
        Convertpad(xref+3,yref+3,"SIDER",rail*2+1,DELTA)
        ref[2]=rail*2
        ref[3]=rail*2+1
        success[head]=1
      endif
    endif
    if success[head]==1 then
      // Move all remaining heads into the defined positions.
      for k=0,k<$LAY.nfing*2,k++ do
        if used[k]==0 continue
        if k==head || k==ref[0] || k==ref[1] || k==ref[2] || k==ref[3] continue
        if (k & 1)==0 then
          Convertpad(&xt,&yt,"LATEST",k,0)
        else
          Convertpad(&xt,&yt,"R1",k,0)
        endif
        yt=$LAY.yoffset[k/2]/1000.0
        sprintf(s,"M %i[%g,%g] NOP",k,xt,yt)
        SERV.Cmdimm(32,s)
      enddo
      // Make measurements.
      change hinfo limits=head,$LAY.nfing*2
      // Create command.
      n=sprintf(s,"M %i[%g,%gA5] %i[%g,%g] %i[%g,%g] %i[%g,%g] %i[%g,%g] ",    \
        head,x,y,ref[0],xref[0],yref[0],ref[1],xref[1],yref[1],                \
        ref[2],xref[2],yref[2],ref[3],xref[3],yref[3])
      n=n+sprintf(s+n,"MC(%i,0,%i,%i,%i,%i)",head,ref[0],ref[1],ref[2],ref[3])
      // Send ntest commands at once.
      for i=0,i<ntest,i++ do
        SYS.Killimm(i)
        SERV.Cmdimm(i,s)
      enddo
      // Wait for answers.
      t=Time()
      while err==0 do
        for i=0,i<ntest,i++ do
          if $A[i].length==0 break
        enddo
        if i>=ntest break
        if Time()-t>10000 err=2
        if Pressed(hinterrupt) err=3
        if Pressed(hexit) err=-1
        wait
      enddo
      // Process answers.
      for i=0,i<ntest && err==0,i++ do
        if $A[i].subcmd!=M_MULTIC then
          err=1
        else if ($A[i].status & 0x9C20)!=0 then
          nbad[head]++
        else
          SERV.Convertfastc($A[i],&zc,&zr);
          Addsigma(ctotal[head],zc)
          for k=0,k<4,k++ do
            SERV.Convertmultic($A[i],k,&zc,&zr)
            Addsigma(c[head][k],zc)
          enddo
        endif
      enddo
    endif
    // Display information on the screen and calculate min-max difference.
    if err==0 then
      change hlist color=BLACK
      n=sprintf(s,"%2i%s ",head/2,head & 1?"R":"L")
      if success[head]==0 then
        sprintf(s+n,"Unable to select antennas")
        diff[head]=0
      else
        c1=Getmean(c[head][0])
        c2=Getmean(c[head][1])
        c3=Getmean(c[head][2])
        c4=Getmean(c[head][3])
        sprintf(s+n,"%10.3f %7.3f %7.3f %7.3f %7.3f pF",                       \
          Getmean(ctotal[head]),c1,c2,c3,c4)
        diff[head]=Max(c1,c2,c3,c4)-Min(c1,c2,c3,c4)
      endif
      add hlist text=s
    endif
  enddo
  if err==(-1) return -1               // Operator interrupted test
  // Write data to protocols.
  if err==0 && txtok!=0 then           // Write measured data to TXT protocol
    fprintf(hlog,"\n                         Own capacity of the needle\n")
    fprintf(hlog,"\n                    Locations of pads around the needle:\n")
    fprintf(hlog,"\n                                   C1   C2")
    fprintf(hlog,"\n                                      *")
    fprintf(hlog,"\n                                   C3   C4\n")
    fprintf(hlog,"\nHead  Units    Ctotal         C1       C2       ")
    fprintf(hlog,"C3       C4   Bad    Max diff\n")
    for head=0,head<$LAY.nfing*2,head++ do
      if used[head]==0 continue
      fprintf(hlog,"\n%3i%c  ",head/2,(head & 1?'R':'L'))
      if success[head]==0 then
        fprintf(hlog,"    Head is not checked, unable to select antennas")
      else
        fprintf(hlog," pF  ")
        fprintf(hlog,"%10.3f ",Getmean(ctotal[head]))
        fprintf(hlog,"%10.3f ",Getmean(c[head][0]))
        fprintf(hlog,"%8.3f ",Getmean(c[head][1]))
        fprintf(hlog,"%8.3f ",Getmean(c[head][2]))
        fprintf(hlog,"%8.3f ",Getmean(c[head][3]))
        fprintf(hlog,"%5i ",nbad[head])
        fprintf(hlog,"%11.3f ",diff[head])
      endif
    enddo
    fprintf(hlog,"\n\n\n--------------------------------------")
    fprintf(hlog,"---------------------------------------\n")
  endif
  if err==0 && rtfok!=0 then           // Write measured data to RTF protocol
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddtext("\nOwn capacity of the needle")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RAddtext("\n\nLocations of pads around the needle:\n")
    RFmt(RTF_TIMES,RTF_BOLD,10)
    RTable(RTF_CENTERED|RTF_KEEPNEXT,0.0,6)
    RCell(RTF_CENTERED,2)
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_LIGHTBG,10); RAddtext("C1")
    RCell(RTF_CENTERED,2)
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_LIGHTBG,10); RAddtext("C2")
    RCell(RTF_CENTERED,2)
    RTable(RTF_CENTERED|RTF_KEEPNEXT,0.0,2)
    RCell(RTF_CENTERED,26)
    RAddtext("*")
    RTable(RTF_CENTERED|RTF_KEEPNEXT,0.0,6)
    RCell(RTF_CENTERED,2)
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_LIGHTBG,10); RAddtext("C3")
    RCell(RTF_CENTERED,2)
    RCell(RTF_CENTERED|RTF_THINBRD|RTF_LIGHTBG,10); RAddtext("C4")
    RCell(RTF_CENTERED,2)
    REndtable()
    RFmt(RTF_TIMES,RTF_NORMAL,5)
    RAddtext("\n")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
    RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Head")
    RCell(RTF_CENTERED|RTF_THINBRD,24.0); RAddtext("C total, pF")
    RCell(RTF_CENTERED|RTF_THINBRD,22.0); RAddtext("C1, pF")
    RCell(RTF_CENTERED|RTF_THINBRD,22.0); RAddtext("C2, pF")
    RCell(RTF_CENTERED|RTF_THINBRD,22.0); RAddtext("C3, pF")
    RCell(RTF_CENTERED|RTF_THINBRD,22.0); RAddtext("C4, pF")
    RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddtext("Bad")
    RCell(RTF_CENTERED|RTF_THINBRD,24.0); RAddtext("Max diff, pF")
    for head=0,head<$LAY.nfing*2,head++ do
      if used[head]==0 continue
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,12.0)
      RAddfmt("%i%c",head/2,(head & 1?'R':'L'))
      if success[head]==0 then
        RCell(RTF_CENTERED|RTF_THINBRD,147.0)
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("Head is not checked, unable to select antennas")
      else
        RCell(RTF_CENTERED|RTF_THINBRD,24.0)
        RAddfmt("%.3f",Getmean(ctotal[head]))
        RCell(RTF_CENTERED|RTF_THINBRD,22.0)
        RAddfmt("%.3f",Getmean(c[head][0]))
        RCell(RTF_CENTERED|RTF_THINBRD,22.0)
        RAddfmt("%.3f",Getmean(c[head][1]))
        RCell(RTF_CENTERED|RTF_THINBRD,22.0)
        RAddfmt("%.3f",Getmean(c[head][2]))
        RCell(RTF_CENTERED|RTF_THINBRD,22.0)
        RAddfmt("%.3f",Getmean(c[head][3]))
        RCell(RTF_CENTERED|RTF_THINBRD,11.0)
        RAddfmt("%i",nbad[head])
        RCell(RTF_CENTERED|RTF_THINBRD,24.0)
        if diff[head]>=CREPABS then
          RFmt(RTF_TIMES,RTF_BOLD,9)
        endif
        RAddfmt("%.3f",diff[head])
      endif
    enddo
    REndtable()
  endif
  if err==0 then
    Startexplanation()
    Explain("Comments to the table above: This test measures capacity between ")
    Explain("the needle and its nearest environment, and tests dependency of ")
    Explain("this capacity on the orientation of the needle. The lower the ")
    Explain("dependency, the better is the shielding. Results are not ")
    Explain("evaluated and have no influence on the certification. However, ")
    Explain("if maximal difference exceeds %g pF, expect high number ",CREPABS)
    Explain("of retests and, in the worst case - missed shorts between small ")
    Explain("nets.")
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  add hlist text="Test interrupted!"
  if err==3 return 1                   // Operator interrupted test
  clear hright
  change hinfo limits=0,0
  change hinfo text="Own capacity test error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid capacity "
    draw text="measurement. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  endif
  draw text="Test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Estimates own inductance of the wires on the Olliboard. Mostly empirical,
// but based on: Thompson, Inductance Calculation Techniques, part II, Power
// Control and Intelligent Motion, December 1999.
function float Lcorrection(char *pad1,char *pad2,float x1,float x2,float y)
  float w,h,h2,l,d,d2,xl,xr,dummy
  if Strncmp(pad1,"GND",3)==0 && Strncmp(pad2,"GND",3)==0 then
    return 0.0                         // Shortcut, no correction needed
  endif
  Convertpad(&xl,&dummy,"RES0",0,0.0)
  xl=xl-10.0
  Convertpad(&xr,&dummy,"P3",0,0.0)
  xr=xr+10.0
  if boardtype==5 then                 // Frame height, meters
    h=Abs(yshift+3*rowdist-y)/1000.0+0.035
    h2=3*rowdist/1000.0+0.070
  else if boardtype==2 || boardtype==3 then
    h=Abs(yshift+rowdist-y)/1000.0+0.035
    h2=rowdist/1000.0+0.070
  else
    h=Abs(yshift+2*rowdist-y)/1000.0+0.035
    h2=2*rowdist/1000.0+0.070
  endif
  // Calculate inductance of the main frame.
  w=Abs(x1-x2)/1000.0+0.020            // Effective width of main frame, meters
  d=0.4*h*Log(w/0.0045)+0.2*w*Log(w/0.0006)
  // If board is cut, there are no other contours.
  if boardtype==2 return d
  // If both pads are components, loop correction is small.
  if Strncmp(pad1,"GND",3)!=0 && Strncmp(pad2,"GND",3)!=0 return d
  if pad1[0]!='G' then
    // Calculate inductance of the left frame. Physically wrong, empyrically
    // acceptable.
    w=Abs(Min(x1,x2)-xl)/1000.0        // Effective width of left frame, meters
    l=(h2-h)*2+0.185
    d2=0.4*h*Log(w/0.0004)+0.2*l*Log(l/0.0006)+1.5
  else
    // Calculate inductance of the right frame.
    w=Abs(xr-Max(x1,x2))/1000.0        // Effective width of right frame, meters
    l=(h2-h)*2+0.200
    d2=0.4*h*Log(w/0.0004)+0.2*l*Log(l/0.0006)+1.5
  endif
  d=d*d2/(d+d2)
  return d
end

// Verifies combined R-L measurements. Flag diff turns on differential
// measurements. Attention, still doesn't allow for bad measurements during the
// certification!
function int Ltest(int ntest,int certify,int diff,int log)
  // Pad1    Pad2    Own R
  char lpairstd[13][32] = {          \ // R-L measurements, standard Olliboard
    "GND1    GND2    0.000",         \ // Shortcut
    "GND1    R30     0.000",         \ // Resistor 30 Ohm
    "GND1    R294    0.000",         \ // Resistor 294 Ohm
    "L47U    GND2    2.000",         \ // Coil 47 uH
    "L47U    R30     2.000",         \ // Coil 47 uH with resistor 30 Ohm
    "L47U    R294    2.000",         \ // Coil 47 uH with resistor 294 Ohm
    "" }
  char lpairtri[13][32] = {          \ // R-L measurements, Tripod acceptance
    "GND1    GND2    0.000",         \ // Shortcut
    "GND1    R30     0.000",         \ // Resistor 30 Ohm
    "GND1    R294    0.000",         \ // Resistor 294 Ohm
    "L470N   GND2    0.200",         \ // Coil 0.47 uH
    "L1U     GND2    0.600",         \ // Coil 1 uH
    "GND1    L10U    3.200",         \ // Coil 10 uH
    "GND1    L100U   0.500",         \ // Coil 100 uH
    "R30     L100U   0.500",         \ // Coil 100 uH with resistor 30 Ohm
    "GND1    L470U   2.400",         \ // Coil 470 uH
    "R30     L470U   2.400",         \ // Coil 470 uH with resistor 30 Ohm
    "GND1    L4M7    25.00",         \ // Coil 4.7 mH
    "R294    L4M7    25.00",         \ // Coil 4.7 mH with resistor 294 Ohm
    "" }
  char diffinit[5][8] = {            \ // Pads for differential calibration
    "R978K",                         \
    "GND1",                          \
    "C27P",                          \
    "C2N7",                          \
    "" }
  int i,j,k,ko,m,n,nl,nd,p,q,t,head,isbad[13][33],nbad[13][33],zheadtype,err
  int l47present,skip[13],calibrated,part
  float r,rlo,rhi,l,llo,lhi,rabslo,lrepglo,lstat[13][33][5],rstat[13][33][5]
  float rexp[13],lexp[13],rmin,rmax,lminl,lmaxl,lming,lmaxg,lminr,lmaxr
  float x,y,xo,yo,dx,dy,percent,lmina[13],lmaxa[13],lcorr[13][32]
  char s[256],lpair[13][32],cmd[13,32][256]
  handle hinterrupt,hcont
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
  then
    return 0                           // Only A5/A6/S1 support RL measurement
  endif
  if ntest==0 ntest=32                 // As in certification
  if ntest<1 ntest=1                   // Correct obvious error
repeat:
  clear hright
  change hinfo limits=0,0
  change hinfo text="??D2a?"
  Addreplaysection("Inductivity test")
  // Set components to test.
  if (romdata.features & BF_TYPE)==BF_TRIPOD then
    Memcpy(lpair,lpairtri,Sizeof(lpairtri))
  else
    Memcpy(lpair,lpairstd,Sizeof(lpairstd))
    diff=0                             // Only classical test!
  endif
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  if diff then
    add hlist text=" DIFFERENTIAL RESISTANCE/INDUCTANCE MEASUREMENTS"
  else
    add hlist text="   COMBINED RESISTANCE/INDUCTANCE MEASUREMENTS"
  endif
  add hlist text=""
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="?a??2a??2??D??D??????D"
  draw text=format("?2? %.2f%% + %.3f uH + ",LREPEAT*100.0,LREPLOC)
  draw text=format("%.3f nH/Ohm 2?.\n",LRESACC)
  draw text="?????22??o??a??2????"
  draw text=format(" %.0f%% ",LFACTOR*100.0)
  draw text="???????."
  if txtok || rtfok then
    draw font=INFOFONT text="\n\n???: ?1??? " font=MAINFONT
    draw text="?D??" font=INFOFONT text=", ???1???2????D-?D? "
    //draw text="be added to the protocol."
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D???Y2a?"
  endc
  zheadtype=$EXTLAY.zheadtype
  for nl=0,lpair[nl][0]!='\0',nl++ do; enddo
  for nd=0,nd<4 && diffinit[nd][0]!='\0',nd++ do; enddo
  if certify==0 then
    rabslo=RABSLO                      // Strict conditions
  else if diff==0 && softtouch!=0 then
    rabslo=RABSLO*3.0                  // Soft touch needles are unreliable
  else
    rabslo=RABSLO*2.0                  // Certification, don't be too strict
  endif
  if boardtype==5 then
    lrepglo=LREPGLO*3
  else if boardtype==2 || boardtype==3 then
    lrepglo=LREPGLO*0.7
  else
    lrepglo=LREPGLO
  endif
  // Clear statistics and get nominals.
  for n=0,n<nl,n++ do
    for i=0,i<33,i++ do
      Initsigma(lstat[n][i])
      Initsigma(rstat[n][i])
      isbad[n][i]=0
      nbad[n][i]=0
    enddo
    for i=0,i<7 && lpair[n][i]!=' ' && lpair[n][i]!='\0',i++ do; enddo
    lpair[n][i]='\0'
    for i=0,i<7 && lpair[n][i+8]!=' ' && lpair[n][i+8]!='\0',i++ do; enddo
    lpair[n][i+8]='\0'
    lexp[n]=0.0
    rexp[n]=0.0
    for i=0,xname[i][0]!='\0',i++ do
      if Strcmp(lpair[n]+8,xname[i])==0 then
        if lpair[n][8]=='R' then
          rexp[n]=rexp[n]+value[i]     // In Ohm
        else
          lexp[n]=lexp[n]+value[i]     // In microhenry
        endif
        break
      endif
    enddo
    skip[n]=0
    for i=0,xname[i][0]!='\0',i++ do   // Find inductivity value
      if Strcmp(lpair[n],xname[i])==0 then
        if lpair[n][0]=='R' then
          rexp[n]=rexp[n]+value[i]     // In Ohm
        else
          lexp[n]=lexp[n]+value[i]     // In microhenry
        endif
        break
      endif
    enddo
    r=0.0; sscanf(lpair[n]+16,"%f",&r)
    rexp[n]=rexp[n]+r
  enddo
  calibrated=1                         // Assume flash L corrections present
  Clearoversurface()
  Initerrlist()
  if log then
    if txtok then
      fprintf(hlog,"\nResistance/inductivity measurements:\n")
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\nResistance/inductivity measurements:\n")
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  err=0
  // Check whether 47 uH coil is present.
  l47present=0
  if (romdata.features & BF_TYPE)!=BF_TRIPOD then
    for k=0,k<$LAY.nfing*2,k=k+2 do    // For all rails
      if used[k]==0 continue
      ko=k+1                           // Opposite finger
      Convertpad(&x,&y,"L47U",k,DELTA)
      Convertpad(&xo,&yo,"GND2",ko,DELTA)
      sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] R(%i,%i)",                          \
        k,x,y,acc,ko,xo,yo,acc,k,ko)
      if SERV.Cmdimm(k,s)<0 err=1
    enddo
    t=Time()                           // Wait till all answers come
    while err==0 do
      if Pressed(hexit) err=-1
      if Pressed(hinterrupt) err=4
      for k=0,k<$LAY.nfing*2,k=k+2 do
        if used[k]==0 continue
        if $A[k].length==0 break
      enddo
      if k>=$LAY.nfing*2 break         // All answers are back
      if Time()-t>10000 err=2
      wait
    enddo
    j=0
    for k=0,k<$LAY.nfing*2 && err==0,k=k+2 do
      if used[k]==0 continue
      if ($A[k].answer!=S_MOVE || $A[k].subansw!=S_RMEAS) continue
      r=$A[k].r
      if ($A[k].status & 0x0100) r=r*1.0e-6
      if r<(-10.0) || r>100.0 continue
      j++
    enddo
    if j>=nused/2 || j>=2 l47present=1
    if l47present==0 then
      for n=0,n<nl,n++ do
        if Stricmp(lpair[n],"L47U")==0 skip[n]=1
      enddo
    endif
  endif
  // Run electrical tests.
  for k=0,k<$LAY.nfing*2,k=k+2 do      // For all rails
    if used[k]==0 continue
    ko=k+1                             // Opposite finger
    if diff then
      // Make calibration part of differential inductance measurements. The
      // number of saved calibrations is limited by crate to 4 per each pair
      // of heads. On error, I repeat calibration up to ntest times.
      for i=0,i<ntest,i++ do           // Calibration attempts
        for n=0,n<nd && err==0,n++ do  // For all calibration points
          SYS.Killimm(n)
          Convertpad(&x,&y,diffinit[n],k,0)
          x=x+Random(DELTA/4.0)-DELTA/8.0
          y=y+Random(DELTA)-DELTA/2.0
          m=sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] ",                          \
            k,x-0.5,y,acc,ko,x+0.5,y,acc)
          sprintf(s+m,"LREF(%i,%i,LONG,DLY=15)",k,ko)
          if SERV.Cmdimm(n,s)<0 err=1
        enddo
        t=Time()                       // Wait till all answers come
        while err==0 do
          if Pressed(hexit) err=-1
          if Pressed(hinterrupt) err=4
          for n=0,n<nd,n++ do
            if $A[n].length==0 break
          enddo
          if n>=nd break               // All answers are back
          if Time()-t>10000 err=2
          wait
        enddo
        if err==0 && log!=0 then
          for n=0,n<nd,n++ do
            m=sprintf(s,"  LREF %i rail %2i: ",n+1,k/2)
            if ($A[n].answer!=S_MOVE || $A[n].subansw!=M_RLDIFF) then
              Strcpy(s+m,"Invalid answer")
            else
              r=$float4($A[n]+8); if ($A[n].status & 0x0100) r=r*1.0e-6
              sprintf(s+m,"L=%8.3g uH, R=%8.3g Ohm stat=%04X",                 \
              $float4($A[n]+12)/1000.0,r,$A[n].status)
            endif
            lprintf(GREEN,"%s",s)
            if txtok!=0 fprintf(hlog,"%s\n",s)
            if rtfok!=0 RAddfmt("%s\n",s)
          enddo
        endif
        for n=0,n<nd && err==0,n++ do  // For all calibration points
          if ($A[n].answer!=S_MOVE || $A[n].subansw!=M_RLDIFF) break
          if ($A[n].status & 0x8E00)!=0 break
        enddo
        if n>=nd break                 // Calibration succeeded
      enddo
    endif
    for n=0,n<nl && err==0,n++ do      // For all RL pairs
      change hinfo limits=(k/2)*nl+n+1,$LAY.nfing*nl
      if skip[n] continue
      for i=0,i<ntest && err==0,i++ do // Statistics
        Convertpad(&x,&y,lpair[n],k,0.0)
        Convertpad(&xo,&yo,lpair[n]+8,ko,0.0)
        if x>xo then
          Convertpad(&x,&y,lpair[n]+8,k,0.0)
          Convertpad(&xo,&yo,lpair[n],ko,0.0)
        endif
        // Calculate estimated own inductance of the wires on the board, very
        // raw and imprecise.
        if i==0 then
          lcorr[n][k]=Lcorrection(lpair[n],lpair[n]+8,x,xo,(y+yo)/2.0)
        endif
        // Best if distance between the contact points is constant.
        dx=Random(DELTA)-DELTA/2.0
        dy=Random(DELTA)-DELTA/2.0
        x=x+dx; y=y+dy
        xo=xo+dx; yo=yo+dy
        m=sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] ",k,x,y,acc,ko,xo,yo,acc)
        if diff then
          sprintf(s+m,"LMEAS(%i,%i,LONG)",k,ko)
        else
          sprintf(s+m,"RL(%i,%i)",k,ko)
        endif
        if SERV.Cmdimm(0,s)<0 err=1
        if SERV.Cmdimm(1,s)<0 err=1
        Strcpy(cmd[n,k],s)
        if diff then
          sprintf(s+m,"LMEAS(%i,%i,LONG)",ko,k)
        else
          sprintf(s+m,"RL(%i,%i)",ko,k)
        endif
        if SERV.Cmdimm(2,s)<0 err=1
        if SERV.Cmdimm(3,s)<0 err=1
        Strcpy(cmd[n,ko],s)
        t=Time()                       // Wait till all answers come
        while err==0 do
          if Pressed(hexit) err=-1
          if Pressed(hinterrupt) err=4
          for j=0,j<4,j++ do
            if $A[j].length==0 break
          enddo
          if j>=4 break                // All answers are back
          if Time()-t>10000 err=2
          wait
        enddo
        if err!=0 break
        for j=0,j<4,j++ do
          if diff then
            m=sprintf(s,"  LMEAS rail %2i: ",k/2)
          else
            m=sprintf(s,"  RL rail %2i: ",k/2)
          endif
          if ($A[j].answer!=S_MOVE || (diff==0 && $A[j].subansw!=M_RLMEAS) ||  \
            (diff!=0 && $A[j].subansw!=M_RLDIFF))                              \
          then
            Strcpy(s+m,"Invalid answer")
            err=3
          else if ($A[j].status & 0x8800)!=0 then
            sprintf(s+m,"L=%8.3g (%8.3g) uH, R=%8.3g Ohm stat=%04X",           \
              0,0,0,$A[j].status)
            nbad[n][k]++               // Bad measurement
            nbad[n][32]++
          else
            r=$float4($A[j]+8); if ($A[j].status & 0x0100) r=r*1.0e-6
            l=$float4($A[j]+12)/1000.0 // Convert to microhenry
            sprintf(s+m,"L=%8.3g (%8.3g) uH, R=%8.3g Ohm stat=%04X",           \
              $float4($A[j]+12)/1000.0,l,r,$A[j].status)
            if $A[j].status & 0x2000 calibrated=0
            Addsigma(lstat[n][k],l); Addsigma(lstat[n][32],l)
            Addsigma(rstat[n][k],r); Addsigma(rstat[n][32],r)
          endif
          if log then
            lprintf(GREEN,"%s",s)
            if txtok!=0 fprintf(hlog,"%s\n",s)
            if rtfok!=0 RAddfmt("%s\n",s)
          endif
        enddo
      enddo
    enddo
  enddo
  if err==0 then
    // Calculate limits for resistance and inductivity and generate individual
    // messages.
    for n=0,n<nl,n++ do
      if skip[n] continue
      part=n/6
      // Deviations from expected resistance.
      rmin=rexp[n]*(1.0-RFACTORLO)-rabslo
      rmax=rexp[n]*(1.0+RFACTORLO)+rabslo
      // Deviations from expected inductivity.
      lmina[n]=lexp[n]*(1.0-LFACTOR)-LFACTABS-LRESACC*rexp[n]
      lmaxa[n]=lexp[n]*(1.0+LFACTOR)+LFACTABS+LRESACC*rexp[n]
      // Global deviations from mean component inductivity.
      lming=Getmean(lstat[n][32])*(1.0-LREPEAT)-lrepglo-LRESACC*rexp[n]
      lmaxg=Getmean(lstat[n][32])*(1.0+LREPEAT)+lrepglo+LRESACC*rexp[n]
      for k=0,k<$LAY.nfing*2,k=k+2 do
        if used[k]==0 continue
        // Local deviations from mean rail inductivity.
        lminl=Getmean(lstat[n][k])*(1.0-LREPEAT)-LREPLOC-LRESACC*rexp[n]
        lmaxl=Getmean(lstat[n][k])*(1.0+LREPEAT)+LREPLOC+LRESACC*rexp[n]
        // Local deviations from measurement without resistor.
        j=n
        while j>0 &&                                                           \
          ((lpair[n][0]=='R' && Strcmp(lpair[n]+8,lpair[j-1]+8)==0) ||         \
          (lpair[n][8]=='R' && Strcmp(lpair[n],lpair[j-1])==0)) do j--; enddo
        if j<n then
          lminr=Getmean(lstat[j][k])*(1.0-LREPEAT)-LREPGLO-LRESACC*rexp[n]
          lmaxr=Getmean(lstat[j][k])*(1.0+LREPEAT)+LREPGLO+LRESACC*rexp[n]
        else
          lminr=-1.0e10
          lmaxr=+1.0e10
        endif
        r=Getmean(rstat[n][k])
        rlo=Getmin(rstat[n][k]); rhi=Getmax(rstat[n][k])
        l=Getmean(lstat[n][k])
        llo=Getmin(lstat[n][k]); lhi=Getmax(lstat[n][k])
        sprintf(s,"%g uH, %g Ohm",lexp[n],rexp[n])
        if nbad[n][k]>0 then
          Adderr(cmd[n,k],part,k,"Bad measurements at %s",s)
          isbad[n][k]=1; isbad[n][32]=1
        else if rlo<rmin || rhi>rmax then
          Adderr(cmd[n,k],part,k,                                              \
            "Resistance out of limits (%.4g..%.4g Ohm) at %s",                 \
            rmin,rmax,s)
          isbad[n][k]=1; isbad[n][32]=1
        else if llo<lmina[n] || lhi>lmaxa[n] then
          Adderr(cmd[n,k],part,k,                                              \
            "Inductivity at %s differs from expected (%.4g..%.4g uH)",         \
            s,lmina[n],lmaxa[n])
          isbad[n][k]=1; isbad[n][32]=1
        else if llo<lming || lhi>lmaxg then
          Adderr(cmd[n,k],part,k,                                              \
            "Inductivity at %s differs from average (%.4g..%.4g uH)",          \
            s,lming,lmaxg)
          isbad[n][k]=1; isbad[n][32]=1
        else if llo<lminr || lhi>lmaxr then
          Adderr(cmd[n,k],part,k,                                              \
            "Inductivity at %s differs from no-resistor (%.4g..%.4g uH)",      \
            s,lminr,lmaxr)
          isbad[n][k]=1; isbad[n][32]=1
        else if llo<lminl || lhi>lmaxl then
          Adderr(cmd[n,k],part,k,                                              \
            "Inductivity at %s differs from mean for this rail "               \
            "(%.4g..%.4g uH)",s,lminl,lmaxl)
          isbad[n][k]=1; isbad[n][32]=1
        endif
      enddo
    enddo
    // Display statistics on the screen.
    change hlist color=RED
    add hlist text=" -Expected-   -----------Measured-----------  Bad"
    add hlist text=" L,uH R,Ohm     Lmean   Lmin   Lmax        R"
    add hlist text=""
    for n=0,n<nl,n++ do
      if skip[n] continue
      r=Getmean(rstat[n][32])
      l=Getmean(lstat[n][32])
      llo=Getmin(lstat[n][32]); lhi=Getmax(lstat[n][32])
      change hlist color=(isbad[n][32]?LIGHTRED:BLACK)
      if lexp[n]<900.0 then
        add hlist text=format("%5.3g %5.3g   %7.3g%7.3g%7.3g %8.3g %4i",       \
        lexp[n],rexp[n],l,llo,lhi,r,nbad[n][32])
      else
        add hlist text=format("%5.4g %5.3g   %7.4g%7.4g%7.4g %8.3g %4i",       \
        lexp[n],rexp[n],l,llo,lhi,r,nbad[n][32])
      endif
    enddo
    if calibrated==0 then
      change hlist color=LIGHTRED
      add hlist text=""
      add hlist text="WARNING: no individual inductivity corrections!"
      add hlist text=" Please adjust inductivity to improve accuracy"
    endif
    add hlist text=""
    // Check if we need to repeat measurements.
    for n=0,n<nl,n++ do
      if isbad[n][32] break
    enddo
    if (calibrated!=1 || n<nl) && certify!=0 then
      i=Askrepeat("Inductivity measurements")
      if i<0 return -1
      if i==1 goto repeat
    endif
    Summary(calibrated==1 && n>=nl,"Resistance/inductivity measurements")
    // Write measured data to TXT protocol.
    if txtok then
      p=0
      while p<nl do
        part=p/6
        q=Min(p+6,nl)
        if nl<=6 then
          fprintf(hlog,"\n                    ")
          if diff then
            fprintf(hlog,"Differential inductivity measurements\n")
          else
            fprintf(hlog," Resistance/inductivity measurements\n")
          endif
        else
          if p>0 fprintf(hlog,"\n")
          fprintf(hlog,"\n                ")
          if diff then
            fprintf(hlog,"Differential inductivity measurements, ")
          else
            fprintf(hlog," Resistance/inductivity measurements, ")
          endif
          fprintf(hlog,"part %i\n",p/6+1)
        endif
        fprintf(hlog,"\n  Heads  L nominal, uH ")
        for n=p,n<q,n++ do
          fprintf(hlog,"%9.1f",lexp[n]); enddo
        fprintf(hlog,"\n        R nominal, Ohm ")
        for n=p,n<q,n++ do
          fprintf(hlog,"%9.1f",rexp[n]); enddo
        for k=0,k<$LAY.nfing*2,k=k+2 do
          if used[k]==0 continue
          fprintf(hlog,"\n\n%2iL -%2iR        L mean ",k/2,k/2)
          for n=p,n<q,n++ do
            if skip[n] then
              fprintf(hlog,"      ---")
            else
              fprintf(hlog,"%9.4g",Getmean(lstat[n][k]))
            endif
          enddo
          // Minimal inductivity.
          if logmode==0 then fprintf(hlog,"\n                 L min ");
          else fprintf(hlog,"\n            L diff min "); endif
          for n=p,n<q,n++ do
            l=Getmean(lstat[n][k]); llo=Getmin(lstat[n][k])
            if skip[n] then
              fprintf(hlog,"         ")
            else if logmode==1 then
              fprintf(hlog,"%+9.4g",llo-l)
            else if logmode==2 && l<3.0 then // Low diffs
              fprintf(hlog,"%+8.3gu",llo-l)
            else if logmode==2 then    // Percentages
              percent=(llo-l)/l*100.0
              if percent>99.0 then fprintf(hlog,"    > 99%%");
              else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
              else fprintf(hlog,"%+8.2g%%",percent); endif
            else                       // Absolute values
              fprintf(hlog,"%9.4g",llo)
            endif
          enddo
          // Maximal inductivity.
          if logmode==0 then fprintf(hlog,"\n                 L max ");
          else fprintf(hlog,"\n            L diff max "); endif
          for n=p,n<q,n++ do
            l=Getmean(lstat[n][k]); lhi=Getmax(lstat[n][k])
            if skip[n] then
              fprintf(hlog,"         ")
            else if logmode==1 then
              fprintf(hlog,"%+9.4g",lhi-l)
            else if logmode==2 && l<3.0 then // High diffs
              fprintf(hlog,"%+8.3gu",lhi-l)
            else if logmode==2 then    // Percentages
              percent=(lhi-l)/l*100.0
              if percent>99.0 then fprintf(hlog,"    > 99%%");
              else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
              else fprintf(hlog,"%+8.2g%%",percent); endif
            else                       // Absolute values
              fprintf(hlog,"%9.4g",lhi)
            endif
          enddo
          // Dispersion of inductivity.
          fprintf(hlog,"\n               Sigma L ");
          for n=p,n<q,n++ do
            if skip[n] then
              fprintf(hlog,"         ")
            else
              fprintf(hlog,"%9.4g",Getsigma(lstat[n][k]))
            endif
          enddo
          // Mean resistance.
          fprintf(hlog,"\n\n                R mean ")
          for n=p,n<q,n++ do
            if skip[n] then
              fprintf(hlog,"         ")
            else
              fprintf(hlog,"%9.3g",Getmean(rstat[n][k]))
            endif
          enddo
          // Minimal resistance.
          if logmode==0 then fprintf(hlog,"\n                 R min ");
          else fprintf(hlog,"\n            R diff min "); endif
          for n=p,n<q,n++ do
            r=Getmean(rstat[n][32]); rlo=Getmin(rstat[n][k])
            if skip[n] then
              fprintf(hlog,"         ")
            else if logmode==1 then
              fprintf(hlog,"%+9.3g",rlo-r)
            else if logmode==2 && r<3.0 then // Low diffs
              fprintf(hlog,"%+8.3gr",rlo-r)
            else if logmode==2 then    // Percentages
              percent=(rlo-r)/r*100.0
              if percent>99.0 then fprintf(hlog,"    > 99%%");
              else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
              else fprintf(hlog,"%+8.2g%%",percent); endif
            else                       // Absolute values
              fprintf(hlog,"%9.3g",rlo)
            endif
          enddo
          // Maximal resistance.
          if logmode==0 then fprintf(hlog,"\n                 R max ");
          else fprintf(hlog,"\n            R diff max "); endif
          for n=p,n<q,n++ do
            r=Getmean(rstat[n][32]); rhi=Getmax(rstat[n][k])
            if skip[n] then
              fprintf(hlog,"         ")
            else if logmode==1 then
              fprintf(hlog,"%+9.3g",rhi-r)
            else if logmode==2 && r<3.0 then // High diffs
              fprintf(hlog,"%+8.3gr",rhi-r)
            else if logmode==2 then    // Percentages
              percent=(rhi-r)/r*100.0
              if percent>99.0 then fprintf(hlog,"    > 99%%");
              else if percent<(-99.0) then fprintf(hlog,"    <-99%%");
              else fprintf(hlog,"%+8.2g%%",percent); endif
            else                       // Absolute values
              fprintf(hlog,"%9.3g",rhi)
            endif
          enddo
          // Dispersion of resistance.
          fprintf(hlog,"\n               Sigma R ");
          for n=p,n<q,n++ do
            if skip[n] then
              fprintf(hlog,"         ")
            else
              fprintf(hlog,"%9.3g",Getsigma(rstat[n][k]))
            endif
          enddo
        enddo
        // Number of bad measurements and passed flag.
        fprintf(hlog,"\n\n All rails      Bad RL ");
        for n=p,n<q,n++ do
          if skip[n] then
            fprintf(hlog,"         ")
          else
            fprintf(hlog,"%9i",nbad[n][32])
          endif
        enddo
        fprintf(hlog,"\n\n Passed                ");
        for n=p,n<q,n++ do
          if skip[n] then
            fprintf(hlog,"  Skipped")
          else
            fprintf(hlog,"%9.3s",isbad[n][32]?"No":"Yes")
          endif
        enddo
        if logmode==2 then
          fprintf(hlog,"\n\nLetters 'u' and 'r' mean differences ")
          fprintf(hlog,"in microhenry and Ohms")
        endif
        Flusherrlist(part,1,1,-1)
        p=q
      enddo
      if calibrated==0 then
        fprintf(hlog,"\n\nATTENTION, individual inductivity corrections are ")
        fprintf(hlog," not  available.  This  may\nreduce the accuracy of ")
        fprintf(hlog,"inductivity measurements by up to +/- 0.5 uH. Test  ")
        fprintf(hlog,"as\na whole is not passed. Please adjust inductivity!")
      endif
      fprintf(hlog,"\n\n--------------------------------------")
      fprintf(hlog,"---------------------------------------\n")
    endif
    // Write measured data to RTF protocol.
    if rtfok then
      p=0
      while p<nl do
        part=p/6
        q=Min(p+6,nl)
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_BOLD,14)
        if nl<=6 then
          if diff then
            RAddtext("\nDifferential inductivity measurements")
          else
            RAddtext("\nResistance/inductivity measurements")
          endif
        else
          if p>0 fprintf(hlog,"\n")
          if diff then
            RAddfmt("\nDifferential inductivity measurements, part %i",p/6+1)
          else
            RAddfmt("\nResistance/inductivity measurements, part %i",p/6+1)
          endif
        endif
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,6.5)
        RCell(RTF_CENTERED|RTF_THINBRD,15.0); RAddtext("Heads")
        RCell(RTF_RIGHT|RTF_THINBRD,24.0)
        RAddtext("L nominal, ")
        RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("m")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RAddtext("H\nR nominal, ")
        RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        for n=p,n<q,n++ do
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RAddfmt("%.1f\n%.1f",lexp[n],rexp[n])
        enddo
        for k=0,k<$LAY.nfing*2,k=k+2 do
          if used[k]==0 continue
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,6.5)
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RCell(RTF_CENTERED|RTF_THINBRD,15.0);
          RAddfmt("\n\n%iL-%iR",k/2,k/2)
          RCell(RTF_RIGHT|RTF_THINBRD,24.0)
          RAddtext("L mean\n")
          if logmode==0 then
            RAddtext("L min\nLmax\n");
          else
            RAddtext("L diff min\nL diff max\n")
          endif
          RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("s ")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("L\n")
          RFmt(RTF_TIMES,RTF_NORMAL,4); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("L corrected\n")
          RFmt(RTF_TIMES,RTF_NORMAL,4); RAddtext("\n")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddtext("R mean\n");
          if logmode==0 then
            RAddtext("R min\nRmax\n");
          else
            RAddtext("R diff min\nR diff max\n")
          endif
          RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("s ")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("R")
          for n=p,n<q,n++ do
            RCell(RTF_CENTERED|RTF_THINBRD,20.0)
            RFmt(RTF_TIMES,isbad[n][k]?RTF_BOLD:RTF_NORMAL,9)
            if skip[n] then
              RAddfmt("-")
              continue
            endif
            RAddfmt("%.4g\n",Getmean(lstat[n][k]))
            l=Getmean(lstat[n][k])
            llo=Getmin(lstat[n][k])
            lhi=Getmax(lstat[n][k])
            if logmode==1 then
              RAddfmt("%+.4g\n%+.4g\n",llo-l,lhi-l)
            else if logmode==2 && l<3.0 then
              RAddfmt("%+.3g ",llo-l)
              RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("m")
              RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H")
              RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("*")
              RFmt(RTF_TIMES,isbad[n][k]?RTF_BOLD:RTF_NORMAL,9)
              RAddfmt("\n%+.3g ",lhi-l)
              RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("m")
              RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H")
              RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("*")
              RFmt(RTF_TIMES,isbad[n][k]?RTF_BOLD:RTF_NORMAL,9)
              RAddtext("\n")
            else if logmode==2 then
              percent=(llo-l)/l*100.0
              if percent>99.0 then RAddfmt("> 99%%\n");
              else if percent<(-99.0) then RAddfmt("< -99%%\n");
              else RAddfmt("%+.2g%%\n",percent); endif
              percent=(lhi-l)/l*100.0
              if percent>99.0 then RAddfmt("> 99%%\n");
              else if percent<(-99.0) then RAddfmt("< -99%%\n");
              else RAddfmt("%+.2g%%\n",percent); endif
            else
              RAddfmt("%.4g\n%.4g\n",llo,lhi)
            endif
            RAddfmt("%.4g\n",Getsigma(lstat[n][k]))
            RFmt(RTF_TIMES,RTF_NORMAL,4); RAddtext("\n")
            RFmt(RTF_TIMES,isbad[n][k]?RTF_BOLD:RTF_NORMAL,9)
            RAddfmt("%.4g\n",Getmean(lstat[n][k])-lcorr[n][k])
            RFmt(RTF_TIMES,RTF_NORMAL,4); RAddtext("\n")
            RFmt(RTF_TIMES,isbad[n][k]?RTF_BOLD:RTF_NORMAL,9)
            RAddfmt("%.3g\n",Getmean(rstat[n][k]))
            r=Getmean(rstat[n][32])
            rlo=Getmin(rstat[n][k])
            rhi=Getmax(rstat[n][k])
            if logmode==1 then
              RAddfmt("%+.3g\n%+.3g",rlo-r,rhi-r)
            else if logmode==2 && r<3.0 then
              RAddfmt("%+.3g ",rlo-r)
              RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
              RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("?")
              RFmt(RTF_TIMES,isbad[n][k]?RTF_BOLD:RTF_NORMAL,9)
              RAddfmt("\n%+.3g ",rhi-r)
              RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
              RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,9); RAddtext("?")
              RFmt(RTF_TIMES,isbad[n][k]?RTF_BOLD:RTF_NORMAL,9)
            else if logmode==2 then
              percent=(rlo-r)/r*100.0
              if percent>99.0 then RAddfmt("> 99%%\n");
              else if percent<(-99.0) then RAddfmt("< -99%%\n");
              else RAddfmt("%+.2g%%\n",percent); endif
              percent=(rhi-r)/r*100.0
              if percent>99.0 then RAddfmt("> 99%%");
              else if percent<(-99.0) then RAddfmt("< -99%%");
              else RAddfmt("%+.2g%%",percent); endif
            else
              RAddfmt("%.3g\n%.3g",rlo,rhi)
            endif
            RAddfmt("\n%.3g",Getsigma(rstat[n][k]))
          enddo
        enddo
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.0)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,15.0);
        RAddtext("All")
        RCell(RTF_RIGHT|RTF_THINBRD|RTF_THINSP,24.0)
        RAddtext("Bad RL")
        for n=p,n<q,n++ do
          RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,20.0)
          RAddfmt("%i",nbad[n][32])
        enddo
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.0)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,15.0); RAddtext("Passed")
        RCell(RTF_RIGHT|RTF_THINBRD,24.0)
        for n=p,n<q,n++ do
          RCell(RTF_CENTERED|RTF_THINBRD|RTF_THINSP,20.0)
          if skip[n] then
            RAddtext("Skipped")
          else
            RAddtext(nbad[n][32]==0?"Yes":"No")
          endif
        enddo
        REndtable()
        if logmode==2 then
          RParagraph(RTF_FORMAT)
          RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,10); RAddtext("          *")
          RFmt(RTF_TIMES,RTF_ITALIC,10)
          RAddtext(" Difference in microhenry.")
          RParagraph(RTF_FORMAT)
          RFmt(RTF_TIMES,RTF_NORMAL|RTF_SUPER,10); RAddtext("          ?")
          RFmt(RTF_TIMES,RTF_ITALIC,10)
          RAddtext(" Difference in Ohms.")
        endif
        Flusherrlist(part,2,1,-1)
        p=q
      enddo
      if calibrated==0 then
        RParagraph(RTF_FORMAT)
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("\nATTENTION, individual inductivity corrections are not ")
        RAddtext("available. This may reduce the accuracy of inductivity ")
        RAddtext("measurements by up to ")
        RFmt(RTF_SYMBOL,RTF_BOLD,8); RAddtext("?")
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddtext("0.5 uH. Test as a whole is not passed. Please adjust ")
        RAddfmt("inductivity!")
      endif
    endif
    // Add explanation to protocols.
    n=0
    for i=0,i<nl,i++ do
      if skip[i]==0 n++
    enddo
    Startexplanation()
    Explain("Comments to the table above: For each R-L combination, script ")
    Explain("makes %i tests per rail, giving grand total of ",ntest*4)
    Explain("%i measurements. ",ntest*nused*2*n)
    if (romdata.features & BF_TYPE)!=BF_TRIPOD && l47present==0 then
      Explain("(Note that there is no optional 47 uH component on your ")
      Explain("OlliBoard, and corresponding tests are skipped). ")
    endif
    Explain("Inductivity test is passed when (a) all measurements are good; ")
    Explain("(b) difference between measured and expected resistance is ")
    Explain("smaller than %g%% + %g Ohm; ",RFACTORLO*100.0,rabslo)
    Explain("(c) difference between measured and expected inductivity ")
    Explain("doesn't exceed %g%% + %g uH + %g uH/Ohm; ",                       \
      LFACTOR*100.0,LFACTABS,LRESACC)
    Explain("(d) difference between measured and mean inductivity doesn't ")
    Explain("exceed %g%% + %g uH + %g uH/Ohm ",LREPEAT*100.0,LREPLOC,LRESACC)
    Explain("for the rail and %g%% + %g uH + %g uH/Ohm globally; ",         \
      LREPEAT*100.0,lrepglo,LRESACC)
    Explain("and (e) resistor in series changes measured inductivity by not ")
    Explain("more than %g uH + %g uH/Ohm.\n",LREPGLO,LRESACC)
    Explain("Note that the own inductivity of the connecting wires on the ")
    Explain("board strongly depends on the position of the contacts and may ")
    Explain("add up to %g uH to the result. Therefore mean values ",lrepglo)
    Explain("for all rails are meaningless and are not protocolled.")
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0
  endif
  change hlist color=LIGHTRED
  add hlist text="Inductivity test interrupted!"
  if err==(-1) return -1               // Operator interrupted test
  if err==4 return 1                   // Interrupt button pressed
  clear hright
  change hinfo limits=0,0
  change hinfo text="Inductivity error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Internal error!"
    draw at 6,60 color=BLACK
    draw text="Inductivity test found some error in internal data structures. "
    draw text="Please contact atg. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid RL measurement. "
    draw text="Probably your software is too old. "
  endif
  draw text="Test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Calibrates U and I parameters of measurement card and applies new parameters
// to the layout. Requires embedded software with S_EXACTINIT support.
function int Adjustmeas()
  char ra2[12][40] = {                               \ // A2 calibration
    "30000 GND1  GND2  6 Offset 0 Ohm",              \ // Shortcut
    "30000 R294  GND2  6 DC source 30 mA",           \ // 294 Ohms
    "10000 R30   R294  6 DC source 10 mA",           \ // 324 Ohms
    " 3000 R2K94 GND2  6 DC source 3 mA",            \ // 2.94 K
    " 1000 R8K87 GND2  6 DC source 1 mA",            \ // 8.87 K
    "  300 R29K4 GND2  6 DC source 0.3 mA",          \ // 29.4 K
    "  100 R88K7 GND2  6 DC source 0.1 mA",          \ // 88.7 K
    "   30 R29K4 R88K7 3 DC source 30 uA",           \ // 118.1 K
    "   10 R978K GND2  3 DC source 10 uA",           \ // 978 K
    "    0 R978K GND2  6 DC reference 9 V",          \ // 978 K
    "    0 R3M32 GND2  6 DC reference 0.9 V",        \ // 3.32 M
    "" };
  char ra5[12][40] = {                               \ // A5 calibration
    "30000 GND1  GND2  6 Offset 0 Ohm",              \ // Shortcut
    "30000 R294  GND2  6 DC source 30 mA",           \ // 294 Ohms
    "10000 R30   R294  6 DC source 10 mA",           \ // 324 Ohms
    " 3000 R2K94 GND2  6 DC source 3 mA",            \ // 2.94 K
    " 1000 R8K87 GND2  6 DC source 1 mA",            \ // 8.87 K
    "  300 R29K4 GND2  6 DC source 0.3 mA",          \ // 29.4 K
    "  100 R88K7 GND2  6 DC source 0.1 mA",          \ // 88.7 K
    "   30 R29K4 R88K7 3 DC source 30 uA",           \ // 118.1 K
    "    0 R29K4 R88K7 3 DC source 0.9 V",           \ // 118.1 K
    "    0 R3M32 GND2  6 DC source 9 V",             \ // 3.32 M
    "" };
  int i,j,k,m,n,nr,p,q,t,test,opp,current,units[12],err
  int doresist,fourwire,dofourwire,badhead,attempt,ntest,rejected
  int nbad[32],nappr[32],maxbad
  float x[32],y[32],x1,x2,r,r0,f,factor[12],parmold[12],parmnew[12]
  float rdata[32,32][12],rmean[32,32],rind[32],rappr[32],rzero[32][12]
  float rexp[12],rmeas[12],limitmin[12],limitmax[12],rsigma[12][12]
  char s[1024],name1[8],name2[8],rpairs[12][40]
  char unitc[4] = " kM"
  handle hresist,hfourwire,hshowmeas,hstart,hcancel,hcont,hinterrupt
  struct t_layout l
  clear hright
  change hinfo limits=0,0
  change hinfo text="2a?D?"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="D??2a?D?????????DT?y2?"
  draw text="?????t?D?2a?2?y?????????2a"
  draw text="??????\n\n"
  //draw text="improves the accuracy of resistance measurements. "
  if ($LAY.probetype & 0x1)==0 then
    draw text="????" font=INFOFONT text="\"?????\" "
    draw font=TIMESFONT text="????????2a?"
    draw text="oD?y???????."
  else
    draw text="???2a?????????????2?"
    draw text="Da????e2a?????DDD?y?"
  endif
  doresist=0; dofourwire=0
  getini("Meastest","Adjustment","%i,%i",&doresist,&dofourwire)
  m=152
  hresist=control CHECKBOX
    window=hright
    position=25,m,RIGHTX-50,22
    text="?????"
    help="?2?D???????????"
    mode=(($LAY.probetype & 0x1)!=0 || doresist==0 || nused<=2)?               \
      0:M_CHECKED
    font=INFOFONT
  endc
  m=m+26
  if nused<=2 || ($LAY.probetype & 0x1)!=0 disable hresist
  // If tester is SHARC-based, use 4-wire measurements.
  if nused==2 || $LAY.probetype!=0 then
    fourwire=0
  else
    fourwire=$GLOBAL.a5
  endif
  if fourwire then
    hfourwire=control CHECKBOX
      window=hright
      position=25,m,RIGHTX-50,22
      text="1?4??2a?"
      help="?2????????????2a?"
      mode=(dofourwire?M_CHECKED:0)
      font=INFOFONT
    endc
    m=m+26
  endif
  hshowmeas=control CHECKBOX
    window=hright
    position=25,m,RIGHTX-50,22
    text="????????2a?y?Y"
    help="????oD-??????2a?"
    font=INFOFONT
    mode=(logmeas?M_CHECKED:0)
  endc
  hstart=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="?a?"
    help="???a?D?2a?2?y"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="???"
    help="????????"
  endc
  draw show
  while 1 do
    if Pressed(hcancel) return 0       // Operator cancelled calibration
    if Pressed(hexit) return -1
    if Pressed(hstart) break
    if Pressed(hshowmeas) logmeas=Status(hshowmeas)
    wait
  enddo
  doresist=Status(hresist)
  if fourwire!=0 then
    dofourwire=Status(hfourwire)
  else
    dofourwire=0
  endif
  setini("Meastest","Adjustment","%i,%i",doresist,dofourwire)
  clear hright                         // No way to remove part of text
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="D??2a?D?????????DT?y2?"
  draw text="?????t?D?2a?2?y?????????2a"
  draw text="??????\n"
  //draw text="measurements."
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D????"
  endc
  err=0
  // Calibrate individual resistances.
  badhead=-1
  if doresist!=0 && nused>2 then
    add hlist text=""
    add hlist text=""
    change hlist color=RED
    add hlist text="  ???????D?"
    add hlist text=""
    change hinfo text="???"
    change hinfo limits=0,1
    attempt=0
  nextattempt:
    attempt++
    for i=0,i<$LAY.nfing*2-1,i++ do
      if used[i]==0 continue
      for j=i+1,j<$LAY.nfing*2,j++ do
        if used[j]==0 continue
        Initquantile(rdata[i,j],12)    // 10 lowest values per combination
      enddo
    enddo
    if logmeas then
      if txtok then
        fprintf(hlog,"\nIndividual head resistance adjustment:\n")
      endif
      if rtfok then
        RParagraph(RTF_LEFT|RTF_INDENT)
        RFmt(RTF_COURIER,RTF_BOLD,8)
        RAddfmt("\nIndividual head resistance adjustment:\n")
        RFmt(RTF_COURIER,RTF_NORMAL,8)
      endif
    endif
    if nused<=16 then
      ntest=12                         // 12 loops for reliability
    else
      ntest=8                          // 8 loops - too many heads
    endif
    for test=0,test<ntest && err==0,test++ do
      for i=0,i<$LAY.nfing,i++ do      // Calculate new coordinates
        if used[i*2]==0 continue
        Convertpad(x+i*2,y+i*2,"GND1",i*2,DELTA)
        Convertpad(x+i*2+1,y+i*2+1,"GND2",i*2+1,DELTA)
      enddo
      // Move fingers to contacts.
      m=sprintf(s,"M ")
      for i=0,i<$LAY.nfing*2,i++ do    // Move fingers
        if used[i]==0 continue
        m=m+sprintf(s+m,"%i[%.3f,%.3fA%i] ",i,x[i],y[i],acc)
      enddo
      sprintf(s+m,"NOP")
      SYS.Killimm(32)                  // Recover from previous test
      if SERV.Cmdimm(32,s)<0 err=1     // Unable to send command
      t=Time()
      while err==0 do                  // Wait till answer comes back
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hinterrupt) err=5
        if $A[32].length!=0 break
        if Time()-t>15000 err=1        // Timeout 15 seconds
        wait
      enddo
      // Small delay so that fingers come to rest.
      t=Time()
      while Time()-t<500 && err==0 do
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hinterrupt) err=5
        wait
      enddo
      // Measure resistances: each finger against each other.
      k=0
      for i=0,i<$LAY.nfing*2-1 && err==0,i++ do
        if used[i]==0 continue
        for j=i+1,j<$LAY.nfing*2 && err==0,j++ do
          if used[j]==0 continue
          t=$LAY.nfing*2
          change hinfo limits=t/2*(t-1)*test+k,t/2*(t-1)*ntest
          m=sprintf(s,"M %i[%.3f,%.3fA%i] %i[%.3f,%.3fA%i] ",                  \
            i,x[i],y[i],acc,j,x[j],y[j],acc)
          // All remaining heads must be up. This increases test duration but
          // reduces noise.
          for t=0,t<$LAY.nfing*2,t++ do
            if used[t]==0 continue
            if t==i || t==j continue
            m=m+sprintf(s+m,"%i[%g,%g] UP(%i) ",t,x[t],y[t],t)
          enddo
          // For reliability, I discard first two measurements and wait a bit
          // so that total time is at least 100 milliseconds.
          sprintf(s+m,"E(%i,%i)",i,j)
          if SERV.Cmdimm(0,s)<0 err=1  // Unable to send command
          sprintf(s+m,"E(%i,%i)",j,i)
          if SERV.Cmdimm(1,s)<0 err=1  // Unable to send command
          t=Time()
          while err==0 do              // Wait till all answers come back
            if Pressed(hexit) return -1
            if Pressed(hinterrupt) err=5
            if Time()-t>=100 then
              if $A[0].length!=0 && $A[1].length!=0 break
              if Time()-t>10000 err=1  // Timeout 10 seconds
            endif
            wait
          enddo
          // Now main measurements.
          sprintf(s+m,"E(%i,%i)",i,j)
          if SERV.Cmdimm(0,s)<0 err=1  // Unable to send command
          if SERV.Cmdimm(1,s)<0 err=1
          if SERV.Cmdimm(2,s)<0 err=1
          if SERV.Cmdimm(3,s)<0 err=1
          sprintf(s+m,"E(%i,%i)",j,i)
          if SERV.Cmdimm(4,s)<0 err=1  // Unable to send command
          if SERV.Cmdimm(5,s)<0 err=1
          if SERV.Cmdimm(6,s)<0 err=1
          if SERV.Cmdimm(7,s)<0 err=1
          t=Time()
          while err==0 do              // Wait till all answers come back
            if Pressed(hexit) return -1
            if Pressed(hinterrupt) err=5
            for n=0,n<8,n++ do
              if $A[n].length==0 break
            enddo
            if n>=8 break              // All answers came
            if Time()-t>10000 err=1    // Timeout 10 seconds
            wait
          enddo
          for n=0,n<8 && err==0,n++ do
            if $A[n].answer==S_ERROR then
              err=2; break             // Some error
            else if $A[n].answer!=S_MOVE then
              err=3; break             // Unbelievable, wrong answer
            endif
            r=$A[n].r; if ($A[n].status & 0x0100) r=r*1.0e-6
            if Abs(r)>1000.0 || ($A[n].status & 0x8E00)!=0 then
              rejected=1
            else
              rejected=0
              Addquantile(rdata[i,j],r)
            endif
            if logmeas then
              sprintf(s,"  Exact R, heads %2i - %2i: %8.5g Ohm, status %04X%s",\
                (n<2?i:j),(n<2?j:i),r,$A[n].status,(rejected?" - rejected":""))
              lprintf(GREEN,"%s",s)
              if txtok!=0 then
                fprintf(hlog,"%s\n",s)
              endif
              if rtfok!=0 then
                RAddfmt("%s\n",s)
              endif
            endif
          enddo
          k++
        enddo
      enddo
    enddo
    for i=0,i<$LAY.nfing*2,i++ do
      nbad[i]=0
    enddo
    for i=0,i<$LAY.nfing*2-1,i++ do
      if used[i]==0 continue
      for j=i+1,j<$LAY.nfing*2,j++ do
        if used[j]==0 continue
        rmean[i,j]=Quantmean(rdata[i,j],999)
        if rmean[i,j]>10.0 || Quantmin(rdata[i,j])<(-10.0) ||                  \
          Quantsigma(rdata[i,j],999)>0.5 || Quantcount(rdata[i,j])<10 then
          err=4
          nbad[i]++; nbad[j]++
          n=sprintf(s,"%2i%c to %2i%c: Rmin",                                  \
            i/2,(i & 1?'R':'L'),j/2,(j & 1?'R':'L'))
          r=Quantmin(rdata[i,j])
          if r<(-10.0) then n=n+Sprintf(s+n,"<-10.0, Sigma");
          else if (r>100.0) then n=n+Sprintf(s+n,">100.0, Sigma");
          else n=n+Sprintf(s+n,"=%5.3g, Sigma",r); endif
          r=Quantsigma(rdata[i,j],999)
          if (r>100.0) then Sprintf(s+n,">100.0 Ohm");
          else Sprintf(s+n,"=%5.3g Ohm",r); endif
          change hlist color=LIGHTRED
          add hlist text=s
        endif
      enddo
    enddo
    maxbad=0; badhead=-1
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      if nbad[i]>maxbad then
        maxbad=nbad[i]
        badhead=i
      endif
    enddo
    if err==4 && attempt<3 then
      err=0                            // Retry if measurements unsuccessfull
      change hinfo text="??2a??"
      add hlist text=""
      change hlist color=RED
      add hlist text="     RETRYING INDIVIDUAL FINGER RESISTANCES"
      add hlist text=""
      goto nextattempt
    endif
    // It is hardly possible, if at all, to solve appearing overdefined system
    // of equations analytically. Let us try subsequent approximations.
    for i=0,i<$LAY.nfing*2,i++ do
      rind[i]=0.0
    enddo
    for m=0,m<20 && err==0,m++ do
      for i=0,i<$LAY.nfing*2,i++ do
        rappr[i]=0.0; nappr[i]=0
      enddo
      for i=0,i<$LAY.nfing*2-1,i++ do
        if used[i]==0 continue
        for j=i+1,j<$LAY.nfing*2,j++ do
          if used[j]==0 continue
          rappr[i]=rappr[i]+rmean[i,j]/2.0
          nappr[i]++
          rappr[j]=rappr[j]+rmean[i,j]/2.0
          nappr[j]++
        enddo
      enddo
      for i=0,i<$LAY.nfing*2,i++ do
        if used[i]==0 continue
        if nappr[i]!=0 rappr[i]=rappr[i]/nappr[i]
        rind[i]=rind[i]+rappr[i]
      enddo
      for i=0,i<$LAY.nfing*2-1,i++ do
        if used[i]==0 continue
        for j=i+1,j<$LAY.nfing*2,j++ do
          if used[j]==0 continue
          rmean[i,j]=rmean[i,j]-rappr[i]-rappr[j]
        enddo
      enddo
    enddo
    // Make all individual corrections small non-negative numbers. Common part
    // of resistance will come into rzero.
    r0=1.0e30
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      rind[i]=rind[i]+$EXTLAY.radj[i]/1.0e6
      if r0>rind[i] r0=rind[i]
    enddo
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      rind[i]=rind[i]-r0
    enddo
    // Report individual corrections and update layout.
    if err==0 then
      add hlist text="Head     Previous R     Corrected R        Sigma"
      change hlist color=BLACK
      add hlist text=""
      // Calculate mean dispersions, the most sound value here.
      for i=0,i<$LAY.nfing*2,i++ do
        rappr[i]=0.0; nappr[i]=0
      enddo
      for i=0,i<$LAY.nfing*2-1,i++ do
        if used[i]==0 continue
        for j=i+1,j<$LAY.nfing*2,j++ do
          if used[j]==0 continue
          rappr[i]=rappr[i]+Quantsigma(rdata[i,j],999)
          nappr[i]++
          rappr[j]=rappr[j]+Quantsigma(rdata[i,j],999)
          nappr[j]++
        enddo
      if used[i]==0 continue
      enddo
      for i=0,i<$LAY.nfing*2,i++ do
        if used[i]==0 continue
        if nappr[i]!=0 rappr[i]=rappr[i]/nappr[i]
        add hlist text=format("%2i%c       %9.3g       %9.3g      %7.3g",      \
        i/2,(i & 1)==0?'L':'R',                                                \
        $EXTLAY.radj[i]/1.0e6,rind[i],rappr[i])
      enddo
      add hlist text=""
      if txtok!=0 then                 // Write results to .TXT protocol
        fprintf(hlog,"\n                 Adjustment of individual finger ")
        fprintf(hlog,"resistances\n\n                          --------")
        fprintf(hlog," Correction, Ohms --------\n                 ")
        fprintf(hlog,"Head     Previous      Adjusted       Sigma\n\n")
        for i=0,i<$LAY.nfing*2,i++ do
          if used[i]==0 continue
          fprintf(hlog,"         %10i%c      %8.3g      %8.3g     %7.3g\n",    \
          i/2,(i & 1)==0?'L':'R',                                              \
          $EXTLAY.radj[i]/1.0e6,rind[i],rappr[i])
        enddo
      endif
      if rtfok!=0 then                 // Write results to .RTF protocol
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_BOLD,14)
        RAddtext("\nAdjustment of individual finger resistances")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Head")
        RCell(RTF_CENTERED|RTF_THINBRD,28.0); RAddtext("Previous correction, ")
        RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,28.0); RAddtext("Adjusted correction, ")
        RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("s")
        RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext(", ")
        RFmt(RTF_SYMBOL,RTF_NORMAL,8); RAddtext("W")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        for i=0,i<$LAY.nfing*2,i++ do
          if used[i]==0 continue
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_CENTERED|RTF_THINBRD,12.0)
          RAddfmt("%i%c",i/2,(i & 1)==0?'L':'R')
          RCell(RTF_CENTERED|RTF_THINBRD,28.0)
          RAddfmt("%.3g",$EXTLAY.radj[i]/1.0e6)
          RCell(RTF_CENTERED|RTF_THINBRD,28.0)
          RAddfmt("%.3g",rind[i])
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RAddfmt("%.3g",rappr[i])
        enddo
        REndtable()
      endif
      Startexplanation()
      Explain("Comments to the table above: Each finger has its own internal ")
      Explain("resistance which adds to the resistance of the component. ")
      Explain("Calibration of individual resistances drastically improves ")
      Explain("accuracy for low-ohmical components.")
      Endexplanation()
      Oversurface()
      if txtok then
        fprintf(hlog,"\n\n--------------------------------------")
        fprintf(hlog,"---------------------------------------\n")
      endif
      for i=0,i<$LAY.nfing*2,i++ do    // Apply corrections to extended layuot
        if used[i]==0 continue
        $EXTLAY.radj[i]=rind[i]*1.0e6
      enddo
      change hinfo text="Reloading extended layout"
      change hinfo limits=0,0
      s[0]=S_LOADRUN
      s[1]=15                          // Reload layout extention
      $int4(s+2)=0                     // Dummy zero bytes
      Memcpy(s+6,$EXTLAY,768)
      SYS.Sendimm(0,774,s)
      delay 500
      t=Time()
      while err==0 do                  // Wait till all answers come back
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hinterrupt) err=5
        if $A[0].length!=0 break
        if Time()-t>5000 err=1         // Timeout 5 seconds
        wait
      enddo
      if err==0 then
        if $A[0].answer==S_ERROR then
          err=2                        // Some error
        else if $A[0].answer!=S_LOADRUN then
          err=3                        // Unbelievable, wrong answer
        endif
      endif
    endif
  endif
  // Now calibrate all resistances. The procedure is similar to Rtest().
  // Unfortunately, there are significant differences between A2 and A5. For
  // example, on A5 I use 4-wire measurements and may ask tester which layout
  // variable controls given measurement.
  if err==0 then
    add hlist text=""
    add hlist text=""
    change hlist color=RED
    add hlist text="         CALIBRATION OF MEASUREMENT CARD"
    add hlist text=""
    add hlist text=" Expected R      Mean   Minimal   Sigma      Good"
    add hlist text=""
    change hinfo text="D??"
    ntest=2
    Clearoversurface()
    attempt=0
    if $GLOBAL.a5==0 then
      Memcpy(rpairs,ra2,Sizeof(ra2))
    else
      Memcpy(rpairs,ra5,Sizeof(ra5))
    endif
    for nr=0,rpairs[nr][0]!='\0',nr++ do; enddo
    for j=0,j<$LAY.nfing*2,j++ do
      if used[j]==0 continue
      Initquantile(rzero[j],12)        // Will gather individual zeros
    enddo
  endif
  if logmeas && err==0 then
    if txtok then
      fprintf(hlog,"\nCalibration of measurement parameters:\n")
    endif
    if rtfok then
      RParagraph(RTF_LEFT|RTF_INDENT)
      RFmt(RTF_COURIER,RTF_BOLD,8)
      RAddfmt("\nCalibration of measurement parameters:\n")
      RFmt(RTF_COURIER,RTF_NORMAL,8)
    endif
  endif
  for i=0,i<nr && err==0,i++ do        // For all resistor values
    sscanf(rpairs[i],"%5i",&current)
    if current!=0 || $GLOBAL.a5==0 then
      sprintf(s,"EXACTINIT 0,%g,1",current/1000.0)
    else
      sprintf(s,"EXACTINIT 0,0,0")
    endif
    SERV.Cmdimm(32,s)                  // Fix test current
    for j=0,j<7,j++ do                 // Fetch name of first pad
      if (rpairs[i][j+6]==' ' || rpairs[i][j+6]=='\0') break
      name1[j]=rpairs[i][j+6]
    enddo
    name1[j]='\0'
    for j=0,j<NPOINT,j++ do            // Find first pad
      if Strcmp(name1,xname[j])==0 break
    enddo
    if j>=NPOINT then
      err=1; break                     // Invalid pad name
    else
      x1=xpos[j]; rexp[i]=value[j]
    endif
    for j=0,j<7,j++ do                 // Fetch name of second pad
      if (rpairs[i][j+12]==' ' || rpairs[i][j+12]=='\0') break
      name2[j]=rpairs[i][j+12]
    enddo
    name2[j]='\0'
    for j=0,j<NPOINT,j++ do            // Find second pad
      if Strcmp(name2,xname[j])==0 break
    enddo
    if j>=NPOINT then
      err=1; break                     // Invalid pad name
    else
      x2=xpos[j]; rexp[i]=rexp[i]+value[j]
    endif
    r=Min(rexp[i],RMAX)
    limitmin[i]=r*(1.0-RFACTORLO)-RABSLO*4
    limitmax[i]=r*(1.0+RFACTORLO)+RABSLO*4
    if i==0 limitmax[0]=limitmax[0]+5.0 // Will be corrected!
    if r>RTHRESHOLD then
      limitmin[i]=limitmin[i]-(r-RTHRESHOLD)*RFACTORHI
      limitmax[i]=limitmax[i]+(r-RTHRESHOLD)*RFACTORHI
    endif
    for j=0,j<$LAY.nfing*2,j=j+2 do    // Move all fingers to pads
      if used[j]==0 continue
      Convert(x+j,y+j,x1,ypos[j],DELTA)
      sprintf(s,"M %i[%g,%gA%i] NOP",j,x[j],y[j],acc)
      if SERV.Cmdimm(j,s)<0 err=1
      Convert(x+j+1,y+j+1,x2,ypos[j+1],DELTA)
      sprintf(s,"M %i[%g,%gA%i] NOP",j+1,x[j+1],y[j+1],acc)
      if SERV.Cmdimm(j+1,s)<0 err=1
    enddo
    t=Time()
    while err==0 do
      for j=0,j<$LAY.nfing*2,j++ do
        if used[j]==0 continue
        if $A[j].length==0 break
      enddo
      if j>=$LAY.nfing*2 break         // All answers here
      if Pressed(hexit) return -1      // Operator interrupted test
      if Pressed(hinterrupt) err=5
      if Time()-t>10000 err=2          // Timeout
      wait
    enddo
    if err!=0 break
    // Small delay so that fingers come to rest.
    t=Time()
    while Time()-t<500 && err==0 do
      if Pressed(hexit) return -1      // Operator interrupted test
      if Pressed(hinterrupt) err=5
      wait
    enddo
    Initquantile(rsigma[i],12)
    for n=0,n<ntest,n++ do             // Statistics for each resistor
      change hinfo limits=i*ntest+n,nr*ntest
      for j=0,j<$LAY.nfing*2,j=j+2 do  // Test each rail
        if used[j]==0 continue
        opp=j+($LAY.nfing & 0xFFFE)
        if opp>=$LAY.nfing*2 opp=opp-$LAY.nfing*2
        if used[opp]==0 continue
        // Note that shortcut measurement must be executed in standard mode,
        // not 4-wire!
        if fourwire!=0 && i>0 then
          m=sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] %i[%g,%gA%i] %i[%g,%gA%i] ",\
            j,x[j],y[j],acc,j+1,x[j+1],y[j+1],acc,                             \
            opp,x[opp],y[opp],acc,opp+1,x[opp+1],y[opp+1],acc)
          // All remaining heads must be up!
          for k=0,k<$LAY.nfing*2,k=k+2 do
            if k==j || k==opp continue
            if used[k]==0 continue
            m=m+sprintf(s+m,"%i[%g,%g] %i[%g,%g] ",                            \
            k,x[k]-0.01,y[k],k+1,x[k+1]+0.01,y[k+1])
          enddo
          sprintf(s+m,"Q(%i,%i,%i,%i)",opp,j,j+1,opp+1)
          if SERV.Cmdimm(0,s)<0 err=1
          if SERV.Cmdimm(1,s)<0 err=1
          if SERV.Cmdimm(2,s)<0 err=1
          if SERV.Cmdimm(3,s)<0 err=1
          sprintf(s+m,"Q(%i,%i,%i,%i)",opp+1,j+1,j,opp)
          if SERV.Cmdimm(4,s)<0 err=1
          if SERV.Cmdimm(5,s)<0 err=1
          if SERV.Cmdimm(6,s)<0 err=1
          if SERV.Cmdimm(7,s)<0 err=1
        else
          m=sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] ",                          \
            j,x[j],y[j],acc,j+1,x[j+1],y[j+1],acc)
          // All remaining heads must be up!
          for k=0,k<$LAY.nfing*2,k=k+2 do
            if k==j continue
            if used[k]==0 continue
            m=m+sprintf(s+m,"%i[%g,%g] %i[%g,%g] ",                            \
            k,x[k]-0.01,y[k],k+1,x[k+1]+0.01,y[k+1])
          enddo
          sprintf(s+m,"E(%i,%i)",j,j+1)
          if SERV.Cmdimm(0,s)<0 err=1
          if SERV.Cmdimm(1,s)<0 err=1
          if SERV.Cmdimm(2,s)<0 err=1
          if SERV.Cmdimm(3,s)<0 err=1
          sprintf(s+m,"E(%i,%i)",j+1,j)
          if SERV.Cmdimm(4,s)<0 err=1
          if SERV.Cmdimm(5,s)<0 err=1
          if SERV.Cmdimm(6,s)<0 err=1
          if SERV.Cmdimm(7,s)<0 err=1
        endif
        t=Time()
        while err==0 do
          for k=0,k<8,k++ do
            if $A[k].length==0 break
          enddo
          if k>=8 break                // All answers here
          if Pressed(hexit) return -1  // Operator interrupted test
          if Pressed(hinterrupt) err=5
          if Time()-t>12000 err=2      // Timeout
          wait
        enddo
        if err!=0 break
        for k=0,k<8,k++ do
          if $A[k].answer!=S_MOVE then
            err=3; break               // Unexpected answer
          endif
          r=$A[k].r; if ($A[k].status & 0x0100) r=r*1.0e-6
          // If there is no contact, or measurement is inaccurate, discard it.
          if Abs(r-rexp[i])>rexp[i]*0.15+15.0 || ($A[k].status & 0x8E00)!=0 then
            rejected=1
          else
            rejected=0
            Addquantile(rsigma[i],r)
            if i==0 Addquantile(rzero[j],r) // Gather individual zeros
          endif
          if logmeas then
            if fourwire!=0 && i>0 then
              m=sprintf(s,"  Quad R ")
            else
              m=sprintf(s,"  Exact R ")
            endif
            if rexp[i]>1000000.0 then p=2; f=1000000.0;
            else if rexp[i]>1000.0 then p=1; f=1000.0;
            else p=0; f=1.0; endif
            m=m+sprintf(s+m,"(%5.4g %4s",rexp[i]/f,runitname[p])
            if current>=1000 then
              m=m+sprintf(s+m,", %3i mA) ",current/1000)
            else if current>=1 then
              m=m+sprintf(s+m,", %3i uA) ",current)
            else
              m=m+sprintf(s+m,")         ")
            endif
            m=m+sprintf(s+m,"heads %2i - %2i: ",(k<2?j:j+1),(k<2?j+1:j))
            m=m+sprintf(s+m,"%8.5g %4s, status %04X",                          \
              r/f,runitname[p],$A[k].status)
            if rejected sprintf(s+m," - rejected")
            lprintf(GREEN,"%s",s)
            if txtok!=0 then
              fprintf(hlog,"%s\n",s)
            endif
            if rtfok!=0 then
              RAddfmt("%s\n",s)
            endif
          endif
        enddo
        if err!=0 break
        sprintf(s,"M %i[%g,%g] %i[%g,%g] NOP",                                 \
          j,x[j]-0.5,y[j],j+1,x[j+1]+0.5,y[j+1])
        if SERV.Cmdimm(4,s)<0 err=1
        t=Time()
        while $A[4].length==0 && err==0 do
          if Pressed(hexit) return -1  // Button "Exit" works as interrupt
          if Pressed(hinterrupt) err=5
          if Time()-t>5000 err=1       // Timeout exhausted
          wait
        enddo
        if err!=0 break
      enddo
      if err!=0 break
    enddo
    // Measurements for resistance i finished. Check that measurements are
    // valid and display message in list window.
    if err==0 then
      r=Min(rexp[i],RMAX); units[i]=0; factor[i]=1.0
      while Abs(r)>=920.0 && units[i]<2 do
        r=r/1000.0; factor[i]=factor[i]*1000.0; units[i]++
      enddo
      j=sprintf(s,"%6.3g ",r)
      if units[i]==0 j=j+Sprintf(s+j," Ohm")
      if units[i]==1 j=j+Sprintf(s+j,"kOhm")
      if units[i]==2 j=j+Sprintf(s+j,"MOhm")
      q=(Quantcount(rsigma[i])>=ntest && Quantmin(rsigma[i])>limitmin[i] &&    \
        Quantmax(rsigma[i])<limitmax[i])
      j=j+sprintf(s+j," %9.3g %9.3g %9.3g    %s",                              \
        Quantmean(rsigma[i],999)/factor[i],Quantmin(rsigma[i])/factor[i],      \
        Quantsigma(rsigma[i],999)/factor[i],q?"Yes":"No")
      change hlist color=(q?BLACK:LIGHTRED)
      add hlist text=s
      if q==0 then                     // Measurement unreliable, repeat
        attempt++; i--
        if attempt>3 err=4
      endif
    endif
  enddo
  add hlist text=""
  // All resistors measured.
  for i=0,i<$LAY.nfing*2,i++ do        // Move all heads in home positions
    if used[i]==0 continue
    sprintf(s,"M %i(Z) NOP",i)
    SERV.Cmdimm(i,s)
  enddo
  if err==5 return 0                   // Interrupt button pressed
  destroy hinterrupt
  t=Time()
  while err==0 do                      // Wait till all answers come back
    if Pressed(hexit) return -1        // Operator interrupted test
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      if $A[i].length==0 break
    enddo
    if i>=$LAY.nfing*2 break           // All answers came
    if Time()-t>15000 then
      err=1; break                     // Timeout 15 seconds
    endif
    wait
  enddo
  SERV.Cmdimm(32,"EXACTINIT 0,0,0")    // Restore unrestricted EXACTR meas's
  if err==0 then
    Memcpy(l,$LAY,Sizeof(l))           // Make local copy of layout
    // Zero offset is the minimum of mean zeros for all rails. This results in
    // measured shortcut resistances that are more symmetrical to 0. In the
    // previous version, zero was the minimal measured R.
    r0=1.0e30
    for j=0,j<$LAY.nfing*2,j=j+2 do
      if used[j]==0 continue
      r0=Min(r0,Quantmean(rzero[j],999))
    enddo
    r0=r0-rexp[0]                      // Measured zero offset
    l.rzero=$LAY.rzero+r0*1.0e6
    parmold[0]=$LAY.rzero; parmnew[0]=l.rzero
    for i=0,i<nr,i++ do                // Subtract zero offset from all values
      rmeas[i]=Quantmean(rsigma[i],999)-r0
    enddo
    // Correct currents in copy of layout.
    if $GLOBAL.a5==0 then              // A2 tester
      l.dc0v9=$LAY.dc0v9*rmeas[10]/rexp[10]
      parmold[10]=$LAY.dc0v9; parmnew[10]=l.dc0v9
      l.dc9v=$LAY.dc9v*rmeas[9]/rexp[9]
      parmold[9]=$LAY.dc9v; parmnew[9]=l.dc9v
      l.i10ua=$LAY.i10ua*rmeas[9]/rexp[9]*rmeas[8]/rexp[8]
      parmold[8]=$LAY.i10ua; parmnew[8]=l.i10ua
      l.i30ua=$LAY.i30ua*rmeas[9]/rexp[9]*rmeas[7]/rexp[7]
      parmold[7]=$LAY.i30ua; parmnew[7]=l.i30ua
      l.i100ua=$LAY.i100ua*rmeas[9]/rexp[9]*rmeas[6]/rexp[6]
      parmold[6]=$LAY.i100ua; parmnew[6]=l.i100ua
      l.i300ua=$LAY.i300ua*rmeas[9]/rexp[9]*rmeas[5]/rexp[5]
      parmold[5]=$LAY.i300ua; parmnew[5]=l.i300ua
      l.i1ma=$LAY.i1ma*rmeas[9]/rexp[9]*rmeas[4]/rexp[4]
      parmold[4]=$LAY.i1ma; parmnew[4]=l.i1ma
      l.i3ma=$LAY.i3ma*rmeas[9]/rexp[9]*rmeas[3]/rexp[3]
      parmold[3]=$LAY.i3ma; parmnew[3]=l.i3ma
      l.i10ma=$LAY.i10ma*rmeas[9]/rexp[9]*rmeas[2]/rexp[2]
      parmold[2]=$LAY.i10ma; parmnew[2]=l.i10ma
      l.i30ma=$LAY.i30ma*rmeas[9]/rexp[9]*rmeas[1]/rexp[1]
      parmold[1]=$LAY.i30ma; parmnew[1]=l.i30ma
    else                               // A5 tester
      l.dc9v=$LAY.dc9v*rexp[9]/rmeas[9]
      parmold[9]=$LAY.dc9v; parmnew[9]=l.dc9v
      l.dc0v9=$LAY.dc0v9*rexp[8]/rmeas[8]
      parmold[8]=$LAY.dc0v9; parmnew[8]=l.dc0v9
      l.i30ua=$LAY.i30ua*rmeas[7]/rexp[7]
      parmold[7]=$LAY.i30ua; parmnew[7]=l.i30ua
      l.i100ua=$LAY.i100ua*rmeas[6]/rexp[6]
      parmold[6]=$LAY.i100ua; parmnew[6]=l.i100ua
      l.i300ua=$LAY.i300ua*rmeas[5]/rexp[5]
      parmold[5]=$LAY.i300ua; parmnew[5]=l.i300ua
      l.i1ma=$LAY.i1ma*rmeas[4]/rexp[4]
      parmold[4]=$LAY.i1ma; parmnew[4]=l.i1ma
      l.i3ma=$LAY.i3ma*rmeas[3]/rexp[3]
      parmold[3]=$LAY.i3ma; parmnew[3]=l.i3ma
      l.i10ma=$LAY.i10ma*rmeas[2]/rexp[2]
      parmold[2]=$LAY.i10ma; parmnew[2]=l.i10ma
      l.i30ma=$LAY.i30ma*rmeas[1]/rexp[1]
      parmold[1]=$LAY.i30ma; parmnew[1]=l.i30ma
    endif
    change hlist color=RED
    add hlist text="Adjusted parameter        Old value     New value"
    add hlist text=""
    change hlist color=BLACK
    for i=0,i<nr,i++ do
      r=Pow10(rpairs[i][18]-'0')
      parmold[i]=parmold[i]/r
      parmnew[i]=parmnew[i]/r
      add hlist text=format("%-22.22s%13.3f%14.3f",                            \
      rpairs[i]+20,parmold[i],parmnew[i])
    enddo
    add hlist text=""
    if txtok!=0 then                   // Write results to .TXT protocol
      fprintf(hlog,"\n                 Adjustment of parameters of measurement")
      fprintf(hlog," card\n\n")
      fprintf(hlog," R exp      R meas       Sigma     Parameter")
      fprintf(hlog,"             Old value  New value\n\n")
      for i=0,i<nr,i++ do
        fprintf(hlog,"%6.4g %c  %8.4g %c  %8.4g     %-22.22s %8.4g   %8.4g\n", \
        rexp[i]/factor[i],unitc[units[i]],rmeas[i]/factor[i],unitc[units[i]],  \
        Quantsigma(rsigma[i],999)/factor[i],rpairs[i]+20,parmold[i],parmnew[i])
      enddo
    endif
    if rtfok!=0 then                   // Write results to .RTF protocol
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      RAddtext("\nAdjustment of parameters of measurement card")
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("R expected")
      RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("R measured")
      RCell(RTF_CENTERED|RTF_THINBRD,20.0); RFmt(RTF_SYMBOL,RTF_NORMAL,9)
      RAddtext("s"); RFmt(RTF_TIMES,RTF_NORMAL,9)
      RCell(RTF_CENTERED|RTF_THINBRD,35.0); RAddtext("Parameter")
      RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("Old value")
      RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("New value")
      for i=0,i<nr,i++ do
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RAddfmt("%.4g ",rexp[i]/factor[i])
        if unitc[units[i]]!=' ' RAddfmt("%c",unitc[units[i]])
        RFmt(RTF_SYMBOL,RTF_NORMAL,9)
        RAddtext("W"); RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RAddfmt("%.4g ",rmeas[i]/factor[i])
        if unitc[units[i]]!=' ' RAddfmt("%c",unitc[units[i]])
        RFmt(RTF_SYMBOL,RTF_NORMAL,9)
        RAddtext("W"); RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        RAddfmt("%.4g",Quantsigma(rsigma[i],999)/factor[i])
        RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext(rpairs[i]+20)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RAddfmt("%.4g",parmold[i])
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RAddfmt("%.4g",parmnew[i])
      enddo
      REndtable()
    endif
    Startexplanation()
    Explain("Comments to the table above: Layout of Flying Probe Tester ")
    Explain("contains many important electrical parameters, like output ")
    Explain("currents or voltages. Default values assure accuracy of 3 to ")
    Explain("5%%. Script tests selected components on the OlliBoard and, ")
    Explain("assuming them exact, corrects layout. This improves accuracy ")
    Explain("to typically 0.5%% (or even better). For convenience, ")
    Explain("each parameter in the table above is listed together with ")
    Explain("resistor that influences this parameter. Some resistors, ")
    Explain("however, influence other parameters, too.")
    if $GLOBAL.a5==0 then              // A2 tester
      Explain(" Resistor ")
      Explain("%.3g %c is measured twice, ",rexp[8]/factor[8],unitc[units[8]])
      Explain("using 4- and 2-wire techniques.")
    endif
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    measadjusted=1
    i=Loadlayoutmeas(l,$EXTLAY,1)
    return i                           // Electrical calibration finished
  endif
  change hlist color=LIGHTRED
  add hlist text="Calibration interrupted!"
  Startexplanation()
  Explain("ATTENTION, calibration procedure detected critical error ")
  Explain("and was unable to finish calibration of measurement parameters. ")
  Explain("Calibration was interrupted, tester layout on the hard disk was ")
  Explain("not updated.")
  Endexplanation()
  if txtok then
    fprintf(hlog,"\n\n--------------------------------------------------")
    fprintf(hlog,"---------------------------\n-------------------------")
    fprintf(hlog,"----------------------------------------------------\n")
  endif
  clear hright
  change hinfo text="D??"
  change hinfo limits=0,0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    draw text="???DD?!"
    draw at 6,60 color=BLACK
    draw text="2a?????????. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  else if err==4 then
    draw text="??!"
    draw at 6,60 color=BLACK
    draw text="?D????2a??3?3????"
    draw text="?32???? "
    if maxbad>nused/4 && badhead>=0 then
      draw text="Most errors are reported by head "
      draw text=format("%i (%i%c).",badhead,badhead/2,(badhead & 1?'R':'L'))
    endif
  endif
  draw text="D?????1?"
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Adjusts input capacity of on-head boards both in manual and automatical mode.
function int Adjustinputc()
  int i,j,k,ko,kg,ka,n,p,t,dx,yt,ant,auto,good,err
  int pause,delta,maxsin,valid[32],inuse[32],ninuse
  float x[32],y[32],xo[32],yo[32],xg[32],yg[32]
  float xa[32],ya[32],xp[32],yp[32]
  float r,ss,cs,smax,smin,cmax,cmin
  float fs[32],fc[32],ps[32],psmax,psmin,ffactor
  char s[256]
  handle hgraph,hmsg,htest,hadjust,hpause,hcancel,hcont
  auto=(($LAY.config & 0x400)==0?0:1)
  clear hright
  change hinfo limits=0,0
  if auto then
    change hinfo text="???Y??"
  else
    change hinfo text="Manual C adjustment"
  endif
  hgraph=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="???Y????1?"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  hmsg=control TEXT
    window=hgraph
    position=5,LEFTY-62,LEFTX-10,20
    color=RED
    font=MEDIUMFONT
    mode=M_CENTERED
  endc
  change hleft position=-1000,*,*,*
  if auto then
    draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
    draw text="??Y2??????t?2a?????????? "
    draw text="?2????1????22a??Y???D??"
    draw text="??2???D?3Dallas????oDT??2??????t?"
    draw text=" " font=MAINFONT text="??2a??" font=TIMESFONT
    draw text="??? " font=MAINFONT text="??"
    draw font=TIMESFONT text=" ."
    draw show
    htest=control BUTTON
      window=hright
      position=5,USERY,RIGHTX/3-5,24
      name="??2a?"
      help="????2????????????2a????YY?"
    endc
    hadjust=control BUTTON
      window=hright
      position=5+RIGHTX/3,USERY,RIGHTX/3-5,24
      name="??"
      help="????????Y2??D?????2???"
    endc
    hcancel=control BUTTON
      window=hright
      position=5+2*(RIGHTX/3),USERY,RIGHTX/3-9,24
      name="???"
      help="?????2?"
    endc
    while 1 do
      if Pressed(htest) then
        change hinfo text="?Yo?"
        auto=2; break
      else if Pressed(hadjust) then
        break
      else if Pressed(hcancel) then
        change hleft position=4,4,LEFTX,LEFTY
        destroy hgraph
        return 0
      else if Pressed(hexit) then
        change hleft position=4,4,LEFTX,LEFTY
        destroy hgraph
        return -1
      endif
      wait
    enddo
    clear hright
  endif
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  SERV.Cmdimm(32,"OUTPORT 0x20F0,16")  // Set 8 V antenna voltage
  // New versions of embedded software scale field results to default voltage
  // (4 V), and we need to rescale it back.
  if features & MF_FSCALE then
    ffactor=2.0
  else
    ffactor=1.0
  endif
  if auto==0 then
    draw text="Now testing input capacities of on-head boards. Please wait at "
    draw text="least 1 full cycle before adjusting any potentiometers."
    hpause=control BUTTON
      window=hright
      position=RIGHTX/2-124,USERY,120,24
      name="?Y"
      help="????Y3D2??????????"
    endc
    hcancel=control BUTTON
      window=hright
      position=RIGHTX/2+5,USERY,120,24
      name="???"
      help="?????D?????Y??"
    endc
  else if auto==1 then
    draw text="2???Y???D?2??y???"
    draw text="??2a????y?2???1??"
    draw text=format("????? %i ??\n?ya?????????...",DADJLIMIT)
    hpause=NULL
    hcancel=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="???"
      help="?????D?????Y??"
    endc
  else                                 // Auto verification
    draw text="?y?2a?2???Y.?"
    draw font=MAINFONT text="???" font=TIMESFONT text="????12a?."
    hpause=NULL
    hcancel=control BUTTON
      window=hright
      position=(RIGHTX-120)/2,USERY,120,24
      name="???"
      help="?????D?????Y??"
    endc
  endif
  draw color=BLACK bkcolor=BLACK at 8,120 fillrect 33,120+17
  draw at 13,136 font=TIMESFONT color=WHITE text="0L"
  draw color=PINK bkcolor=PINK at 8,143 fillrect 33,143+17
  draw color=LIGHTGRAY at 8,166 rect 33,166+17
  draw at 13,182 font=TIMESFONT color=LIGHTRED text="99"
  draw color=LIGHTGRAY at 8,189 rect 33,189+17
  draw at 10,205 font=TIMESFONT color=LIGHTBLUE text="-99"
  draw color=BLACK at 8,212 rect 33,212+17
  draw at 12,228 font=TIMESFONT color=BLACK text=format("%.1f",FNOISE*0.7)
  draw color=BLACK font=INFOFONT
  draw at 40,111 text="??:"
  draw at 40,136 text="- ??3??"
  draw at 40,159 text="- ?TD?2????"
  draw at 40,182 text="- 3?????"
  draw at 40,205 text="- 3???"
  draw at 40,228 text="- ??y?2?"
  draw show
  Memset(inuse,0,Sizeof(inuse))
  err=0; pause=0; good=0; ant=0
  // Calculate all necessary coordinates.
  for k=0,k<$LAY.nfing*2,k++ do        // For all heads
    if used[k]==0 continue
    if Convertpad(x+k,y+k,"F1",k,DELTA/2.0)<0.0 err=2
    xo[k]=x[k]+((k & 1)==0?-3.0:3.0); yo[k]=y[k]
    if Convertpad(xg+k,yg+k,"GND1",k,DELTA)<0.0 err=2
    if Convertpad(xa+k,ya+k,"F2",k,DELTA)<0.0 err=2
    if Convertpad(xp+k,yp+k,((k & 1)==0?"NOCT1":"NOCT2"),k,0)<0.0 err=2
    yp[k]=$LAY.yoffset[k/2]/1000.0
    ps[k]=256.0                        // Initial potentiometer setting
    valid[k]=0                         // All measurements invalid
  enddo
  // Main loop.
  while err==0 do
    if auto==1 then
      // Write new data to Dallas potentiometers. Note: changes extended layout!
      for k=0,k<$LAY.nfing*2 && err==0,k++ do
        sprintf(s,"OUTPORT %i,%i",0x80E0+(k/2)*0x0100+(k & 1)*0x0002,ps[k])
        SERV.Cmdimm(32,s)              // No need to wait for answer
      enddo
    endif
    ninuse=0
    for k=0,k<$LAY.nfing*2 && err==0,k++ do
      // Decide which heads serve this time as antennae.
      if ant==(k & 0xFE) then          // Antennae must be changed
        ant=(ant+$LAY.nfing) & 0xFE
        if ant>=$LAY.nfing*2 ant=ant-$LAY.nfing*2
        if ant==(k & 0xFE) then
          ant=ant+2
          if ant>=$LAY.nfing*2 ant=ant-$LAY.nfing*2
        endif
      endif
      if used[k]==0 || used[ant]==0 continue
      inuse[k]=1; ninuse++
      // Move heads in measurement or basic positions.
      for i=0,i<$LAY.nfing*2 && err==0,i++ do
        if used[i]==0 continue
        if i==k then                   // Meas finger
          sprintf(s,"M %i[%g,%gA%i] NOP",i,x[i],y[i],acc)
        else if i==ant then            // First antennae finger
          sprintf(s,"M %i[%g,%gA%i] NOP",i,xg[i],yg[i],acc)
        else if i==ant+1 then          // Second antennae finger
          sprintf(s,"M %i[%g,%gA%i] NOP",i,xa[i],ya[i],acc)
        else                           // Any other finger
          sprintf(s,"M %i[%g,%gA255] NOP",i,xo[i],yo[i])
        endif
        if SERV.Cmdimm(i,s)<0 err=2    // Send command
      enddo
      // Wait till all heads in measurement or basic positions.
      t=Time()
      for i=0,i<$LAY.nfing*2 && err==0,i++ do
        if used[i]==0 continue
        while err==0 do
          if Time()-t>10000 err=1
          if Pressed(hexit) err=-1
          if Pressed(hcancel) pause=-1
          if hpause!=NULL && pause==0 then
            if Pressed(hpause) pause=1
          endif
          if $A[i].length!=0 break
          wait
        enddo
        if (err==0 && $A[i].answer!=S_NOP) err=3
      enddo
      // Field measurement. I allow up to 3 retests.
      for p=0,p<3 && err==0,p++ do
        ko=k^1                         // Opposite finger
        kg=ant                         // Ground antenna
        ka=kg+1                        // Active antenna
        j=sprintf(s,"M %i[%g,%gA%i] %i[%g,%gA%i] %i[%g,%gA%i] %i[%g,%gA%i] ",  \
          k,x[k],y[k],acc,ko,xo[ko],yo[ko],acc,                                \
          kg,xg[kg],yg[kg],acc,ka,xa[ka],ya[ka],acc)
        j=j+sprintf(s+j,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",                    \
          k,kg,ka,ka,ka,ka,ka,ka,ka,ka)  // Total of 24 antennae
        sprintf(s+j,"%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i)",        \
          ka,ka,ka,ka,ka,ka,ka,ka,ka,ka,ka,ka,ka,ka,ka,ka)
        if SERV.Cmdimm(0,s)<0 err=2    // Send command
        t=Time()                       // Wait for answer
        while err==0 do
          if Time()-t>10000 err=1
          if Pressed(hexit) err=-1
          if Pressed(hcancel) pause=-1
          if hpause!=NULL && pause==0 then
            if Pressed(hpause) pause=1
          endif
          if $A[0].length!=0 break
          wait
        enddo
        if (err==0 && ($A[0].answer!=S_MOVE || $A[0].subansw!=S_FIELD)) err=3
        ss=0.0; smin=9e99; smax=-9e99
        cs=0.0; cmin=9e99; cmax=-9e99
        for j=0,j<24,j++ do
          ss=ss+$int2($A[0]+32+4*j)*ffactor
          smin=Min(smin,$int2($A[0]+32+4*j)*ffactor)
          smax=Max(smax,$int2($A[0]+32+4*j)*ffactor)
          cs=cs+$int2($A[0]+34+4*j)*ffactor
          cmin=Min(cmin,$int2($A[0]+34+4*j)*ffactor)
          cmax=Max(cmax,$int2($A[0]+34+4*j)*ffactor)
        enddo
        fs[k]=ss/24.0
        fc[k]=cs/24.0
        valid[k]=(smax-smin<50 && cmax-cmin<=50 &&                             \
          smin>=SINMIN && smax<=SINMAX && cmin>=COSMIN && cmax<=COSMAX)?1:-1
        if valid[k]==1 break
      enddo
      // Display new field deviations.
      draw window=hgraph color=BLACK bkcolor=WHITE clear
      ss=0.0; cs=0.0; n=0
      for i=0,i<$LAY.nfing*2,i++ do
        if valid[i]==0 continue
        ss=ss+fs[i]; cs=cs+fc[i]
        n++
      enddo
      maxsin=-1
      if n>0 then
        ss=ss/n; cs=cs/n
        draw at LEFTX/2,LEFTY-20 mode=M_CENTERED font=TIMESFONT
        draw text=format("?D? ?y?: %.1f, ?: %.1f bits",ss,cs)
        r=0.0
        for i=0,i<$LAY.nfing*2,i++ do
          if Abs(fs[i]-ss)>r then
            maxsin=i
            r=Abs(fs[i]-ss)
          endif
        enddo
      endif
      draw mode=M_CENTERED font=MEDIUMFONT
      draw at LEFTX/2,28 text="?3?2?"
      draw mode=M_LEFT font=SMALLFONT color=DARKGRAY
      dx=LEFTX/2+11
      for j=0,j<2,j++ do
        draw at  4+dx*j,50 text=""
        draw at 29+dx*j,50 text="?y?"
        draw at 72+dx*j,50 text="?"
        if auto draw at 119+dx*j,50 text="Pot"
      enddo
      delta=0
      draw font=TIMESFONT
      for i=0,i<$LAY.nfing*2,i++ do
        if delta==0 && $LAY.side[i/2]!=$LAY.side[0] delta=20
        if valid[i]==0 continue
        yt=80+22*(i/2)+delta
        j=i & 1
        if i==k then
          draw color=BLACK bkcolor=BLACK at 2+dx*j,yt-16 fillrect 22+dx*j,yt+1
          draw color=WHITE
        else
          draw color=WHITE bkcolor=WHITE at 2+dx*j,yt-16 fillrect 22+dx*j,yt+1
          draw color=DARKGRAY
        endif
        draw at 4+dx*j,yt text=format("%i%c",i/2,(i& 1?'R':'L'))
        if maxsin==i then
          draw color=BLACK bkcolor=(valid[i]<0?PINK:WHITE)
        else if valid[i]<0 then
          draw color=PINK bkcolor=PINK
        else
          draw color=WHITE bkcolor=WHITE
        endif
        draw at 24+dx*j,yt-16 fillrect 115+dx*j,yt+1
        if fs[i]-ss<(-FNOISE*0.7) then
          draw color=LIGHTBLUE
        else if fs[i]-ss>FNOISE*0.7 then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 29+dx*j,yt text=format("%.1f",fs[i]-ss)
        if fc[i]-cs<(-FNOISE*0.7) then
          draw color=LIGHTBLUE
        else if fc[i]-cs>FNOISE*0.7 then
          draw color=LIGHTRED
        else
          draw color=BLACK
        endif
        draw at 72+dx*j,yt text=format("%.1f",fc[i]-cs)
        if auto==1 draw color=DARKGRAY at 117+dx*j,yt text=format("%.0f",ps[i])
      enddo
      draw show
      if pause>0 then
        // Test paused.
        pause=0
        change hpause text="?D?"
        change hpause help="???D?2a?"
        change hpause color=LIGHTRED
        change hpause bkcolor=YELLOW
        // Move heads in pause positions.
        for i=0,i<$LAY.nfing*2,i=i+2 do
          if used[i]==0 continue
          sprintf(s,"M %i[%g,%g] %i[%g,%g] NOP",                               \
            i,xp[i],yp[i],i+1,xp[i+1],yp[i+1])
          SERV.Cmdimm(32,s)
        enddo
        while 1 do
          if Pressed(hpause) then
            break
          else if Pressed(hexit) then
            change hleft position=4,4,LEFTX,LEFTY
            destroy hgraph
            return -1
          else if Pressed(hcancel) then
            pause=-1; break
          endif
          wait
        enddo
        change hpause text="Pause"
        change hpause help=                                                    \
          "Press to pause procedure and move heads in adjust positions"
        change hpause color=BLACK
        change hpause bkcolor=GRAY
      endif
      if pause<0 break                 // Test interrupted
    enddo
    if pause<0 break                   // Test interrupted
    if auto==1 then
      // The full cycle of measurements is finished. Readjust potentiometers.
      ss=0.0; j=0
      for i=0,i<$LAY.nfing*2,i++ do
        if inuse[i]==0 continue
        ss=ss+fs[i]
        if valid[i]<=0 j=1
      enddo
      if j!=0 then                     // Some fields recognized as bad
        change hmsg text="2???3?!"
        continue
      endif
      ss=ss/ninuse                     // Mean value
      if ss<1000 then
        change hmsg text="Low mean field!"
        continue
      endif
      psmin=1.0e99; psmax=-1.0e99
      smin=1.0e99; smax=-1.0e99
      for i=0,i<$LAY.nfing*2,i++ do    // Check for correctness
        if inuse[i]==0 continue
        r=ps[i]-(fs[i]-ss)/ss*DADJFACTOR
        psmin=Min(psmin,r)
        psmax=Max(psmax,r)
        smin=Min(smin,fs[i])
        smax=Max(smax,fs[i])
      enddo
      if psmax-psmin>509.0 then        // Unable to adjust potentiometers
        change hmsg text="Input capacities too different!"
        good=0; continue
      endif
      if psmin<1.0 then
        r=1.0-psmin
      else if psmax>510.0 then
        r=510.0-psmax
      else
        r=0.0
      endif
      clear hmsg
      if smax-smin<DADJLIMIT then
        good++
        if good>=4 then                // Adjustment finished!
          change hmsg text="Input capacities adjusted"
          for i=0,i<$LAY.nfing*2,i++ do
            if inuse[i]==0 continue
            $EXTLAY.sinadj[i]=ps[i]    // Apply changes to extended layout
          enddo
          i=Loadlayoutmeas($LAY,$EXTLAY,0)
          if i==(-1) err=-1;
          break
        endif
        continue                       // Don't adjust, simply wait longer
      endif
      for i=0,i<$LAY.nfing*2,i++ do    // Adjust potentiometers
        if inuse[i]==0 continue
        ps[i]=ps[i]-(fs[i]-ss)/ss*DADJFACTOR+r
      enddo
      good=0
      clear hmsg
    endif
  enddo
  SERV.Cmdimm(32,"OUTPORT 0x20F0,8")   // Set 4 V antenna voltage
  change hleft position=4,4,LEFTX,LEFTY
  destroy hgraph
  if err==0 return 0                   // Full success
  if err==(-1) return -1               // Operator interrupted script
  clear hright
  change hinfo text="C adjustment error"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    draw text="???DD?!"
    draw at 6,60 color=BLACK
    draw text="Tester or tester support routine rejected command sent by "
    draw text="this routine. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  endif
  draw text="Adjustment interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Calibrates inductivity measurement parameters and applies new parameters
// to layout and flash on measurement card. If extmeas is 1, measurements are
// done by external device, if 0 - by measurement card. Requires embedded
// software with S_RLMEAS support.
function int Adjustinductivity(int extmeas)
  int i,j,k,m,n,p,t,freq,err,attempt,ntest,status,rejected,flashvalid
  int oldkey,newkey,fhead[32],pressure,range,freqindex[2],oldfreq[2]
  float x[32],y[32]
  float r,rexp,ref,l,lcorr,extlr,extlrangecorr,rangediff
  float lpair[32,32][5],lmean[5],rmean[5],refmean[5],rphase[3][5],lphase[3][5]
  float lrange[2][32][5],oldflash[32,32],newflash[32,32]
  char s[1024],buf[256],extended[32,32]
  handle hfreq[2],hshowmeas,hstart,hcancel,hcont
  struct t_extlay xl
  int freqset[12] = {                                                          \
    10000, 15000, 20000, 25000, 30000, 40000,                                  \
    50000, 75000, 100000, 120000, 150000, 200000 }
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
  then
    return 0                           // Only A5/A6/S1 support RL measurement
  endif
  if extmeas!=0 && (features & MF_RLINIT)==0 then
    err=14
    goto reporterror
  else
    err=0
  endif
  clear hright
  change hinfo limits=0,0
  change hinfo text="??DD?"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  if extmeas==0 then
    draw text="?a?????D2a???D?,?D????"
    draw text="??2????D??DD2a?,?o?2????D"
    draw text="??2?y,2??2a????DDy?YD?y."
    draw text=""
  else
    draw text="???aa2??????2a????????2a"
    draw text="?1y3?D?D???????????100.."
    draw text="200 uH???o???"
    draw font=MAINFONT text="?a??"
    //draw font=TIMESFONT text="when ready."
  endif
  if extmeas!=0 && intladjusted==0 then
    draw text="\n\n?: ??????a2?2a????? "
    draw color=LIGHTRED
    if measadjusted==0 then
      draw text="???o?2???D?"
    else
      draw text="adjust internal inductivity "
    endif
    //draw color=BLACK text="prior to external measurements!"
  else if measadjusted==0 then
    draw text="\n\nao??" color=LIGHTRED text="???"
    draw text="?" color=BLACK text="?????D!"
  endif
  if extmeas!=0 then
    freqindex[0]=8
    freqindex[1]=11
    // Get old frequencies for external measurements.
    for freq=0,freq<2,freq++ do
      $A[0].length=0
      s[0]=S_DEBUG
      s[1]=0x25                        // Get individual parameter
      s[2]=0x80                        // Measurement card
      if freq==0 then
        $uint2(s+3)=4                  // External frequency 1, Hz
      else
        $uint2(s+3)=5                  // External frequency 2, Hz
      endif
      SYS.Sendimm(0,5,s)
      t=Time()+5000
      while t>Time() do
        if $A[0].length!=0 break
        wait
      enddo
      if $A[0].length==9 && $A[0].command==S_DEBUG then
        oldfreq[freq]=$int4($A[0]+5)
      else
        oldfreq[freq]=0
      endif
    enddo
    // Set test frequencies. I attempt to use the same frequencies as in flash.
    for freq=0,freq<2,freq++ do
      draw at 20,180+30*freq font=INFOFONT
      if freq==0 then
        draw text="?????:"
      else
        draw text="?t??:"
      endif
      hfreq[freq]=control COMBOLIST
        window=hright
        position=133,161+30*freq,100,250
        help=format("a2?????%i?Hz",freq+1)
      endc
      for i=0,i<12,i++ do
        add hfreq[freq] text=format("%g kHz",freqset[i]/1000.0)
        if freqset[i]==oldfreq[freq] freqindex[freq]=i
      enddo
      change hfreq[freq] select=freqindex[freq]
    enddo
  endif
  hshowmeas=control CHECKBOX
    window=hright
    position=22,234,RIGHTX-80,22
    text="????????2a?y?Y"
    help="????oD-??????2a?"
    font=INFOFONT
    mode=(logmeas?M_CHECKED:0)
  endc
  hstart=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+30,120,24
    name="?a?"
    help="??a?D???D2a?"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+30,120,24
    name="???"
    help="????????"
  endc
  draw show
  while 1 do
    if Pressed(hcancel) return 0       // Operator cancelled calibration
    if Pressed(hexit) return -1
    if extmeas!=0 && (Pressed(hfreq[0]) || Pressed(hfreq[1])) then
      freqindex[0]=Status(hfreq[0])
      freqindex[1]=Status(hfreq[1])
      if freqindex[0]==freqindex[1] then
        disable hstart
      else
        enable hstart
      endif
    endif
    if Pressed(hstart) break
    if Pressed(hshowmeas) logmeas=Status(hshowmeas)
    wait
  enddo
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="??DD???DD?D?"
  draw show
  hcancel=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="??D????DD?"
  endc
  // Recalculate head numbers in flash to those in layout.
  for i=0,i<32,i++ do
    fhead[i]=-1
  enddo
  for i=0,i<$LAY.nfing*2,i++ do
    if $LAY.side[i/2]==0 then
      fhead[i]=i
    else
      fhead[i]=i-$LAY.nfing+16
    endif
  enddo
  flashvalid=1
  // Get old version of flash corrections.
  if flashvalid then
    $A[0].length=0
    s[0]=S_DEBUG
    s[1]=0x25                          // Get individual parameter
    s[2]=0x80                          // Measurement card
    if extmeas==0 then
      $uint2(s+3)=0                    // Internal version key
    else
      $uint2(s+3)=3                    // External version key
    endif
    SYS.Sendimm(0,5,s)
    t=Time()+5000
    while t>Time() do
      if $A[0].length!=0 break
      wait
    enddo
    if $A[0].length==9 && $A[0].command==S_DEBUG then
      oldkey=$int4($A[0]+5)
    else
      oldkey=0
    endif
  endif
  // Stable contacts is a must during the L calibration.
  pressure=Max(80,strokep)
  // If external calibration, repeat it for all specified frequencies.
  for freq=0,freq<2 && err==0 ,freq++ do
    if extmeas==0 && freq>=1 break
    add hlist text=""
    add hlist text=""
    change hlist color=RED
    if extmeas==0 then
      add hlist text="    ??D2a?y?Y"
    else
      add hlist text=format("       EXTERNAL INDUCTIVITY AT F=%g KHZ",         \
      freqset[freqindex[freq]]/1000.0)
    endif
    add hlist text=""
    // Force internal or external mode.
    if (features & MF_RLINIT) then
      buf[0]=0x35                      // S_RLINIT
      if extmeas then
        $uint2(buf+1)=0x8000           // Mode
      else
        $uint2(buf+1)=0x4000
      endif
      $uint4(buf+3)=freqset[freqindex[freq]]
      $uint4(buf+7)=0                  // Default voltage
      $uint4(buf+11)=0
      $uint4(buf+15)=0
      $uint4(buf+19)=0
      $uint4(buf+23)=0
      SYS.Sendimm(32,27,buf)
    endif
    // Get old individual corrections from the flash, to display them in the
    // table for comparison and to keep in the case of partial calibration.
    // (Rather senseless if different frequency).
    for i=0,i<$LAY.nfing*2 && flashvalid==1,i++ do
      for j=0,j<$LAY.nfing*2,j++ do    // Send commands to whole row at once
        $A[j].length=0
        s[0]=S_DEBUG
        s[1]=0x25                      // Get individual parameter
        s[2]=0x80                      // Measurement card
        if extmeas==0 then             // Internal corrections
          $uint2(s+3)=64+fhead[i]*32+fhead[j]
        else if freq==0 then           // External corrections 1
          $uint2(s+3)=1313+fhead[i]*32+fhead[j]
        else                           // External corrections 2
          $uint2(s+3)=2339+fhead[i]*32+fhead[j]
        endif
        SYS.Sendimm(j,5,s)
      enddo
      t=Time()+5000
      while t>Time() do
        for j=0,j<$LAY.nfing*2,j++ do
          if $A[j].length==0 break
        enddo
        if j==$LAY.nfing*2 break
        if Pressed(hexit) return -1    // Operator interrupted test
        wait
      enddo
      for j=0,j<$LAY.nfing*2,j++ do
        if $A[j].length==9 && $A[j].command==S_DEBUG then
          oldflash[i,j]=$float4($A[j]+5)/1000.0
        else
          flashvalid=0
          if extmeas!=0 err=13
        endif
      enddo
    enddo
    // Get old resistance correction for external measurements.
    if flashvalid!=0 && extmeas!=0 then
      $A[0].length=0
      s[0]=S_DEBUG
      s[1]=0x25                        // Get individual parameter
      s[2]=0x80                        // Measurement card
      if freq==0 then
        $uint2(s+3)=1312               // External R correction 1, Ohm
      else
        $uint2(s+3)=2338               // External R correction 2, Ohm
      endif
      SYS.Sendimm(0,5,s)
      t=Time()+5000
      while t>Time() do
        if $A[0].length!=0 break
        wait
      enddo
      if $A[0].length==9 && $A[0].command==S_DEBUG then
        extlr=$float4($A[0]+5)
      else
        extlr=0.0
      endif
    endif
    // Get old shift between the ranges for external measurements.
    if flashvalid!=0 && extmeas!=0 then
      $A[0].length=0
      s[0]=S_DEBUG
      s[1]=0x25                        // Get individual parameter
      s[2]=0x80                        // Measurement card
      if freq==0 then
        $uint2(s+3)=2337               // Interrange L correction 1, nanohenry
      else
        $uint2(s+3)=3363               // Interrange L correction 2, nanohenry
      endif
      SYS.Sendimm(0,5,s)
      t=Time()+5000
      while t>Time() do
        if $A[0].length!=0 break
        wait
      enddo
      if $A[0].length==9 && $A[0].command==S_DEBUG then
        extlrangecorr=$float4($A[0]+5)/1000.0
      else
        extlrangecorr=0.0
      endif
    endif
    // Initialize statistics.
    Initsigma(lmean)
    Initsigma(rmean)
    Initsigma(refmean)
    for i=0,i<3,i++ do
      Initsigma(rphase[i])
      Initsigma(lphase[i])
    enddo
    for i=0,i<$LAY.nfing*2,i++ do
      for j=0,j<$LAY.nfing*2,j++ do
        Initsigma(lpair[i,j])
      enddo
      Initsigma(lrange[0][i])
      Initsigma(lrange[1][i])
    enddo
    Clearoversurface()
    if extmeas==0 then
      change hinfo text="???D?"
    else
      change hinfo text=format("Inductance at %i Hz",freqset[freqindex[freq]])
    endif
    change hinfo limits=0,0
    attempt=0
  nextphase:
    attempt++
    if logmeas then
      if (extmeas==0) then
        sprintf(s,"Calibration of inductivity phase")
      else
        sprintf(s,"Inductance calibration at %i Hz",freqset[freqindex[freq]])
      endif
      if txtok then
        fprintf(hlog,"\n%s:\n",s)
      endif
      if rtfok then
        RParagraph(RTF_LEFT|RTF_INDENT)
        RFmt(RTF_COURIER,RTF_BOLD,8)
        RAddfmt("\n%s:\n",s)
        RFmt(RTF_COURIER,RTF_NORMAL,8)
      endif
    endif
    // Measure resistors 1, 3 and 294 Ohm (ranges 0, 0 and 1) to correct
    // phases. Each loop is repeated twice to increase reliability. Phase
    // corrections are not necessary for external device.
    for m=0,m<6 && err==0 && extmeas==0,m++ do
      for i=0,i<$LAY.nfing,i++ do      // Calculate new coordinates
        if used[i*2]==0 continue
        if m==0 || m==1 then
          rexp=Convertpad(x+i*2,y+i*2,"R1",i*2,DELTA)
        else if m==2 || m==3 then
          rexp=Convertpad(x+i*2,y+i*2,"R3",i*2,DELTA)
        else
          rexp=Convertpad(x+i*2,y+i*2,"R294",i*2,DELTA)
        endif
        Convertpad(x+i*2+1,y+i*2+1,"GND2",i*2+1,DELTA)
      enddo
      for i=0,i<$LAY.nfing*2,i++ do    // Move fingers
        if used[i]==0 continue
        sprintf(s,"M %i[%.3f,%.3fA%i] NOP",i,x[i],y[i],acc)
        if SERV.Cmdimm(i,s)<0 err=1    // Unable to send command
      enddo
      t=Time()
      while err==0 do                  // Wait till all answers come back
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hcancel) then
          err=5; break
        endif
        for i=0,i<$LAY.nfing*2,i++ do
          if used[i]==0 continue
          if $A[i].length==0 break
        enddo
        if i>=$LAY.nfing*2 break       // All answers came
        if Time()-t>25000 err=1        // Timeout 25 seconds
        wait
      enddo
      // Measure inductivities: each right finger against each left.
      k=0
      for i=0,i<$LAY.nfing*2 && err==0,i=i+2 do
        if used[i]==0 continue
        for j=1,j<$LAY.nfing*2 && err==0,j=j+2 do
          if used[j]==0 continue
          t=$LAY.nfing*$LAY.nfing
          change hinfo limits=t*m+k+1,t*6
          sprintf(s,"M %i[%.3f,%.3fA%iP%i] %i[%.3f,%.3fA%iP%i] RL(%i,%i)",     \
            i,x[i],y[i],acc,pressure,j,x[j],y[j],acc,pressure,i,j)
          if SERV.Cmdimm(0,s)<0 err=1  // Unable to send command
          if SERV.Cmdimm(1,s)<0 err=1  // Unable to send command
          t=Time()
          while err==0 do              // Wait till all answers come back
            if Pressed(hexit) return -1
            if Pressed(hcancel) then
              err=5; break
            endif
            for n=0,n<2,n++ do
              if $A[n].length==0 break
            enddo
            if n>=2 break              // All answers came
            if Time()-t>10000 err=1    // Timeout 10 seconds
            wait
          enddo
          // Get results of RL measurements.
          for n=0,n<2 && err==0,n++ do
            if $A[n].answer==S_ERROR continue
            if $A[n].answer!=S_MOVE then
              err=3; break             // Unbelievable, wrong answer
            endif
            if ($A[n].status & 0x4000)!=0 err=11
            r=$float4($A[n]+8); if ($A[n].status & 0x0100) r=r*1.0e-6
            l=$float4($A[n]+12)/1000.0 // Convert to microhenry
            // In my analysis, I use only the differences between the measured
            // inductivities, so Y zero and connection between components are
            // unimportant.
            if romdatavalid!=0 && romdata.lwire!=0.0 then
              lcorr=l+(y[i]+y[j])/2.0*romdata.lwire/rowdist
            else
              lcorr=l+(y[i]+y[j])/2.0*LCORR
            endif
            rejected=(($A[n].status & 0x8800)!=0 || Abs(r-rexp)>5.0+rexp*0.05)
            if logmeas then
              p=sprintf(s,"  RL %2i - %2i at %3i Ohm: ",i,j,rexp)
              sprintf(s+p,"%7.4g Ohm, %6.3g (%6.3g) uH, stat=%04X%s",          \
                r,l,lcorr,$A[n].status,(rejected?" - bad":""))
              lprintf(GREEN,"%s",s)
              if txtok!=0 fprintf(hlog,"%s\n",s)
              if rtfok!=0 RAddfmt("%s\n",s)
            endif
            if rejected==0 then        // Add only good measurements
              Addsigma(rphase[m/2],r)
              Addsigma(lphase[m/2],lcorr)
            endif
          enddo
          k++
        enddo
      enddo
    enddo
    // Check that statistics of measurements is good enough (at least 60% of
    // good measurements).
    if err==0 && extmeas==0 then
      rejected=0
      for i=0,i<3,i++ do
        if Getcount(lphase[i])<nused*nused*0.6 rejected=1
      enddo
      if rejected then
        if attempt>=3 then             // Forget it, no chance
          err=4
        else
          change hinfo text="Retrying phase"
          goto nextphase
        endif
      endif
    endif
    // Correct phases in extended layout and change version of flash
    // corrections, effectively zeroing them in all subsequent measurements.
    // This must be done only once, on the first frequency.
    if err==0 && freq==0 then
      Memcpy(xl,$EXTLAY,Sizeof(xl))    // Make local copy of extended layout
      if extmeas==0 then
        xl.lphase1=xl.lphase1+(Getxmean(lphase[1])-Getxmean(lphase[0]))/       \
          (Getxmean(rphase[1])-Getxmean(rphase[0]))
        xl.lphase2=xl.lphase2+(Getxmean(lphase[2])-Getxmean(lphase[0]))/       \
          (Getxmean(rphase[2])-Getxmean(rphase[0]))
        ;
      endif
      while 1 do
        newkey=Random(0x7FFFFFFF)      // MSB is always 0
        if extmeas==0 then
          if newkey!=0 && newkey!=oldkey && newkey!=xl.lcorrversion break
        else
          newkey=(newkey & EXTM_VERSION) | EXTM_RLCORR
          if newkey!=0 && newkey!=oldkey && newkey!=$int4(xl+456) break
        endif
      enddo
      if extmeas==0 then
        xl.lcorrversion=newkey
      else
        $int4(xl+456)=newkey
      endif
      s[0]=0x06                        // S_LOADRUN
      s[1]=15                          // Reload layout extention
      $int4(s+2)=0                     // Dummy operand
      Memcpy(s+6,xl,Sizeof(xl))        // Layout extention
      SYS.Send(6+Sizeof(xl),s,0)
    endif
    // Interrange L correction, only external device HM8118.
    if extmeas!=0 && $uint2($EXTLAY+468)==EXTD_HM8118 &&                       \
      (features & MF_RLINIT)!=0                                                \
    then
      change hinfo text=format("Range shift at %g kHz",                        \
        freqset[freqindex[freq]]/1000.0)
      if logmeas then
        sprintf(s,"Interrange shift at %i Hz",freqset[freqindex[freq]])
        if txtok then
          fprintf(hlog,"\n%s:\n",s)
        endif
        if rtfok then
          RParagraph(RTF_LEFT|RTF_INDENT)
          RFmt(RTF_COURIER,RTF_BOLD,8)
          RAddfmt("\n%s:\n",s)
          RFmt(RTF_COURIER,RTF_NORMAL,8)
        endif
      endif
      for range=0,range<2 && err==0, range++ do
        // Set range.
        buf[0]=0x35                    // S_RLINIT
        if range==0 then
          $uint2(buf+1)=0x8010         // Range 1
        else
          $uint2(buf+1)=0x8020         // Range 2
        endif
        $uint4(buf+3)=freqset[freqindex[freq]]
        $uint4(buf+7)=0                // Default voltage
        $uint4(buf+11)=0
        $uint4(buf+15)=0
        $uint4(buf+19)=0
        $uint4(buf+23)=0
        SYS.Sendimm(32,27,buf)
        // Make measurements, same rail only.
        for m=0,m<8 && err==0,m++ do   // Repeat for reliability
          change hinfo limits=range*8+m,16
          for i=0,i<$LAY.nfing,i++ do  // Calculate coordinates and measure
            if used[i*2]==0 continue
            Convertpad(x+i*2,y+i*2,"R200M",i*2,DELTA/4.0)
            x[i*2]=x[i*2]-0.35
            Convertpad(x+i*2+1,y+i*2+1,"R200M",i*2+1,DELTA/4.0)
            x[i*2+1]=x[i*2+1]+0.35
            sprintf(s,"M %i[%.3f,%.3fA%iP%i] %i[%.3f,%.3fA%iP%i] RL(%i,%i)",   \
              i*2,x[i*2],y[i*2],acc,pressure,                                  \
              i*2+1,x[i*2+1],y[i*2+1],acc,pressure,i*2,i*2+1)
            SYS.Killimm(i*2)           // Recover from previous test
            SYS.Killimm(i*2+1)
            SERV.Cmdimm(32,s)          // Dummy measurement
            if SERV.Cmdimm(i*2,s)<0 err=1
            if SERV.Cmdimm(i*2+1,s)<0 err=1
          enddo
          t=Time()
          while err==0 do              // Wait till all answers come back
            if Pressed(hexit) return -1
            if Pressed(hcancel) then
              err=5; break
            endif
            for i=0,i<$LAY.nfing*2,i++ do
              if used[i]==0 continue
              if $A[i].length==0 break
            enddo
            if i>=$LAY.nfing*2 break   // All answers came
            if Time()-t>25000 err=1    // Timeout 25 seconds
            wait
          enddo
          for i=0,i<$LAY.nfing*2,i++ do
            if used[i]==0 continue
            if $A[i].answer==S_ERROR continue
            status=$A[i].status
            if (status & 0x4000)==0 err=12
            r=$float4($A[i]+8); if (status & 0x0100) r=r*1.0e-6
            l=$float4($A[i]+12)/1000.0 // Convert to microhenry
            if logmeas sprintf(s,                                              \
              "  Range[%i] %2i - %2i: %7.3g Ohm, %8.3g uH, stat=%04X",         \
              range,i & 0xFE,i|0x01,r,l,status)
            rejected=((status & 0x8800)!=0 || r<(-3.0) || r>5.0)
            if rejected==0 then
              Addsigma(lrange[range][i & 0xFE],l)
            endif
          enddo
        enddo
      enddo
      // Process results. I discard rails with too high dispersion of data.
      Initsigma(lmean)
      for i=0,i<$LAY.nfing,i++ do
        if used[i*2]==0 continue
        if Getsigma(lrange[0][i*2])>LSIGMA || Getsigma(lrange[1][i*2])>LSIGMA  \
          continue                     // Measurements are too unstable
        if Abs(Getxmean(lrange[1][i*2])-Getxmean(lrange[0][i*2]))>LRANGE       \
          continue                     // Difference is too high
        Addsigma(lmean,Getxmean(lrange[1][i*2])-Getxmean(lrange[0][i*2]))
      enddo
      if err!=0 || Getcount(lmean)==0 then
        rangediff=0.0
      else
        rangediff=Getxmean(lmean)
        $A[0].length=0
        s[0]=S_DEBUG
        s[1]=0x26                      // Write individual parameter
        s[2]=0x80                      // Measurement card
        if freq==0 then
          $uint2(s+3)=2337             // Interrange L correction 1, nanohenry
        else
          $uint2(s+3)=3363             // Interrange L correction 2, nanohenry
        endif
        $float4(s+5)=rangediff*1000.0
        SYS.Sendimm(0,9,s)
        t=Time()+5000
        while t>Time() do
          if Pressed(hexit) return -1
          if Pressed(hcancel) then
            err=5; break
          endif
          if $A[0].length!=0 break
          wait
        enddo
      endif
    else
      rangediff=0.0
    endif
    // Shortcut measurements, expected R and L are near zero. To reduce errors,
    // I send left and right fingers to the same pad roughly in the middle of
    // the working area.
    if extmeas==0 then
      change hinfo text="??D213"
    else
      change hinfo text=format("213? %i Hz",freqset[freqindex[freq]])
      buf[0]=0x35                      // S_RLINIT
      $uint2(buf+1)=0x8020             // Range 2
      $uint4(buf+3)=freqset[freqindex[freq]]
      $uint4(buf+7)=0                  // Default voltage
      $uint4(buf+11)=0
      $uint4(buf+15)=0
      $uint4(buf+19)=0
      $uint4(buf+23)=0
      SYS.Sendimm(32,27,buf)
    endif
    change hinfo limits=0,0
    attempt=0
    if extmeas==0 then
      ntest=5                          // 5 loops for reliability
    else
      ntest=2                          // External measurements are slower
    endif
    Initsigma(lmean)
  nextshortcut:
    attempt++
    if logmeas then
      if extmeas==0 then
        sprintf(s,"Calibration of inductivity zero")
      else
        sprintf(s,"Inductivity zero at %i Hz",freqset[freqindex[freq]])
      endif
      if txtok then
        fprintf(hlog,"\n%s:\n",s)
      endif
      if rtfok then
        RParagraph(RTF_LEFT|RTF_INDENT)
        RFmt(RTF_COURIER,RTF_BOLD,8)
        RAddfmt("\n%s:\n",s)
        RFmt(RTF_COURIER,RTF_NORMAL,8)
      endif
    endif
    for m=0,m<ntest && err==0,m++ do
      for i=0,i<$LAY.nfing,i++ do      // Calculate new coordinates
        if used[i*2]==0 continue
        Convertpad(x+i*2,y+i*2,"R200M",i*2,DELTA/4.0)
        x[i*2]=x[i*2]-0.35
        Convertpad(x+i*2+1,y+i*2+1,"R200M",i*2+1,DELTA/4.0)
        x[i*2+1]=x[i*2+1]+0.35
      enddo
      for i=0,i<$LAY.nfing*2,i++ do    // Move fingers
        if used[i]==0 continue
        SYS.Killimm(i)                 // Recover from previous test
        sprintf(s,"M %i[%.3f,%.3fA%i] NOP",i,x[i],y[i],acc)
        if SERV.Cmdimm(i,s)<0 err=1    // Unable to send command
      enddo
      t=Time()
      while err==0 do                  // Wait till all answers come back
        if Pressed(hexit) return -1    // Operator interrupted test
        if Pressed(hcancel) then
          err=5; break
        endif
        for i=0,i<$LAY.nfing*2,i++ do
          if used[i]==0 continue
          if $A[i].length==0 break
        enddo
        if i>=$LAY.nfing*2 break       // All answers came
        if Time()-t>25000 err=1        // Timeout 25 seconds
        wait
      enddo
      // Measure inductivities: each finger against each other.
      k=0
      for i=0,i<$LAY.nfing*2-1 && err==0,i++ do
        if used[i]==0 continue
        for j=i+1,j<$LAY.nfing*2 && err==0,j++ do
          if used[j]==0 continue
          t=$LAY.nfing*2
          change hinfo limits=t/2*(t-1)*m+k+1,t/2*(t-1)*ntest
          p=sprintf(s,"M %i[%.3f,%.3fA%iP%i] %i[%.3f,%.3fA%iP%i] ",            \
            i,x[i],y[i],acc,pressure,j,x[j],y[j],acc,pressure)
          // Note: first resistance, then inductivity to increase stability of
          // the (more important) inductivity measurements.
          sprintf(s+p,"E(%i,%i)",i,j)
          if SERV.Cmdimm(0,s)<0 err=1  // Unable to send command
          sprintf(s+p,"E(%i,%i)",j,i)
          if SERV.Cmdimm(1,s)<0 err=1  // Unable to send command
          sprintf(s+p,"RL(%i,%i)",i,j)
          if SERV.Cmdimm(2,s)<0 err=1  // Unable to send command
          sprintf(s+p,"RL(%i,%i)",j,i)
          if SERV.Cmdimm(3,s)<0 err=1  // Unable to send command
          sprintf(s+p,"RL(%i,%i)",i,j)
          if SERV.Cmdimm(4,s)<0 err=1  // Unable to send command
          sprintf(s+p,"RL(%i,%i)",j,i)
          if SERV.Cmdimm(5,s)<0 err=1  // Unable to send command
          t=Time()
          while err==0 do              // Wait till all answers come back
            if Pressed(hexit) return -1
            if Pressed(hcancel) then
              err=5; break
            endif
            for n=0,n<6,n++ do
              if $A[n].length==0 break
            enddo
            if n>=6 break              // All answers came
            if Time()-t>10000 err=1    // Timeout 10 seconds
            wait
          enddo
          // Get results of RL and reference R measurements.
          for n=0,n<6 && err==0,n++ do
            if $A[n].answer==S_ERROR continue
            if $A[n].answer!=S_MOVE then
              err=3; break             // Unbelievable, wrong answer
            endif
            status=$A[n].status
            if n<2 then                // Resistance measurements
              ref=$A[n].r; if (status & 0x0100) ref=ref*1.0e-6
              if logmeas p=sprintf(s,                                          \
                "  R  %2i - %2i: %7.3g Ohm,                       stat=%04X",  \
                i,j,ref,status)
              rejected=((status & 0x8800)!=0 || ref<(-3.0) || ref>5.0)
              if rejected==0 Addsigma(refmean,ref)
            else                       // Inductivity measurements
              if extmeas==0 && (status & 0x4000)!=0 err=11
              if extmeas!=0 && (status & 0x4000)==0 err=12
              r=$float4($A[n]+8); if (status & 0x0100) r=r*1.0e-6
              l=$float4($A[n]+12)/1000.0 // Convert to microhenry
              // Take into account the inductivity of the line on OlliBoard.
              if romdatavalid!=0 && romdata.lwire!=0.0 then
                lcorr=l-Abs(y[i]-y[j])*romdata.lwire/rowdist
              else
                lcorr=l-Abs(y[i]-y[j])*LCORR
              endif
              if logmeas p=sprintf(s,                                          \
                "  RL %2i - %2i: %7.3g Ohm, %8.3g (%6.3g) uH, stat=%04X",      \
                i,j,r,l,lcorr,status)
              rejected=((status & 0x8800)!=0 || r<(-3.0) || r>5.0)
              if rejected==0 then
                Addsigma(lmean,lcorr)
                Addsigma(lpair[i,j],lcorr)
                Addsigma(lpair[j,i],lcorr)
                Addsigma(rmean,r)
              endif
            endif
            if logmeas then
              if rejected Strcpy(s+p," - bad")
              lprintf(GREEN,"%s",s)
              if txtok!=0 fprintf(hlog,"%s\n",s)
              if rtfok!=0 RAddfmt("%s\n",s)
            endif
          enddo
          k++
        enddo
      enddo
    enddo
    // Move all heads in home positions.
    for i=0,i<$LAY.nfing*2,i++ do
      if used[i]==0 continue
      sprintf(s,"M %i(Z) NOP",i)
      SERV.Cmdimm(i,s)
    enddo
    t=Time()
    while 1 do                         // Wait till all answers come back
      if Pressed(hexit) return -1      // Operator interrupted test
      if Pressed(hcancel) then
        err=5; break
      endif
      for i=0,i<$LAY.nfing*2,i++ do
        if used[i]==0 continue
        if $A[i].length==0 break
      enddo
      if i>=$LAY.nfing*2 break         // All answers came
      if Time()-t>5000 then
        err=1; break                   // Timeout 5 seconds
      endif
      wait
    enddo
    // Check if measurements are valid. I expect that at least 50% of all
    // measurements are good, otherwise we must repeat test (in this case old
    // statistics is not discarded).
    if err==0 then
      rejected=0
      if Getcount(refmean)<nused*(nused-1)/2*ntest rejected=1
      if Getcount(lmean)<nused*(nused-1)/2*ntest rejected=1
      for i=0,i<$LAY.nfing*2-1,i++ do
        if used[i]==0 continue
        for j=i+1,j<$LAY.nfing*2,j++ do
          if used[j]==0 continue
          if Getcount(lpair[i,j])<=ntest*2 rejected=1
        enddo
      enddo
      if rejected then
        if attempt>=3 then             // Forget it, no chance
          err=4
        else
          change hinfo text="?t???DD?"
          goto nextshortcut
        endif
      endif
    endif
    // Write new data to flash.
    if err==0 && flashvalid then
      if extmeas==0 then
        lcorr=Getxmean(lmean)
      else
        lcorr=0.0
      endif
      Memset(extended,0,Sizeof(extended))
      for i=0,i<$LAY.nfing*2 && err==0,i++ do
        for j=0,j<$LAY.nfing*2,j++ do  // Send commands to whole row at once
          if i==j then
            newflash[i,j]=0.0          // Measurements with one finger?..
          else if used[i]==0 && used[j]!=0 && testertype==TT_A7 then
            // Find available finger m closest to the unavailable i on the same
            // side.
            m=-1; n=9999
            for k=0,k<$LAY.nfing,k++ do
              if used[k*2]==0 continue
              if $LAY.side[k]!=$LAY.side[i/2] continue
              if Abs(k-i/2)<n then
                n=Abs(k-i/2); m=k*2+(i & 1)
              endif
            enddo
            // Copy corrections only if there is no way to connect two heads
            // via Olliboard.
            if m>=0 && ($LAY.yoffset[i/2]-$LAY.yoffset[j/2])>1125000 then
              newflash[i,j]=Getxmean(lpair[m,j])-lcorr-0.005
              extended[i,j]=1
            else
              newflash[i,j]=oldflash[i,j]
            endif
          else if used[i]!=0 && used[j]==0 && testertype==TT_A7 then
            // Find available m finger closest to the unavailable j on the same
            // side.
            m=-1; n=9999
            for k=0,k<$LAY.nfing,k++ do
              if used[k*2]==0 continue
              if $LAY.side[k]!=$LAY.side[j/2] continue
              if Abs(k-j/2)<n then
                n=Abs(k-j/2); m=k*2+(j & 1)
              endif
            enddo
            // Copy corrections only if there is no way to connect two heads
            // via Olliboard.
            if m>=0 && ($LAY.yoffset[j/2]-$LAY.yoffset[i/2])>1125000 then
              newflash[i,j]=Getxmean(lpair[i,m])-lcorr-0.005
              extended[i,j]=1
            else
              newflash[i,j]=oldflash[i,j]
            endif
          else if used[i]==0 || used[j]==0 then
            newflash[i,j]=oldflash[i,j]
          else                         // Increase reported L by 5.0 nanohenry
            newflash[i,j]=Getxmean(lpair[i,j])-lcorr-0.005
          endif
          $A[j].length=0
          s[0]=S_DEBUG
          s[1]=0x26                    // Write individual parameter
          s[2]=0x80                    // Measurement card
          if extmeas==0 then           // Internal corrections
            $uint2(s+3)=64+fhead[i]*32+fhead[j]
          else if freq==0 then         // External corrections 1
            $uint2(s+3)=1313+fhead[i]*32+fhead[j]
          else                         // External corrections 2
            $uint2(s+3)=2339+fhead[i]*32+fhead[j]
          endif
          $float4(s+5)=newflash[i,j]*1000.0
          SYS.Sendimm(j,9,s)
        enddo
        t=Time()+5000
        while t>Time() do
          if Pressed(hexit) return -1
          if Pressed(hcancel) then
            err=5; break
          endif
          for j=0,j<$LAY.nfing*2,j++ do
            if $A[j].length==0 break
          enddo
          if j==$LAY.nfing*2 break
          wait
        enddo
        for j=0,j<$LAY.nfing*2,j++ do
          if $A[j].length==0 || $A[j].command!=S_DEBUG err=6
        enddo
      enddo
      if err==0 && extmeas!=0 then
        $A[0].length=0
        s[0]=S_DEBUG
        s[1]=0x26                      // Write individual parameter
        s[2]=0x80                      // Measurement card
        if freq==0 then
          $uint2(s+3)=1312             // External R correction 1, Ohm
        else
          $uint2(s+3)=2338             // External R correction 2, Ohm
        endif
        $float4(s+5)=Getxmean(rmean)-Getxmean(refmean)
        SYS.Sendimm(0,9,s)
        t=Time()+5000
        while t>Time() do
          if Pressed(hexit) return -1
          if Pressed(hcancel) then
            err=5; break
          endif
          if $A[0].length!=0 break
          wait
        enddo
      endif
      if err==0 && extmeas!=0 then
        $A[0].length=0
        s[0]=S_DEBUG
        s[1]=0x26                      // Write individual parameter
        s[2]=0x80                      // Measurement card
        if freq==0 then
          $uint2(s+3)=4                // External frequency 1, Hz
        else
          $uint2(s+3)=5                // External frequency 2, Hz
        endif
        $int4(s+5)=freqset[freqindex[freq]]
        SYS.Sendimm(0,9,s)
        t=Time()+5000
        while t>Time() do
          if Pressed(hexit) return -1
          if Pressed(hcancel) then
            err=5; break
          endif
          if $A[0].length!=0 break
          wait
        enddo
      endif
    endif
    // Update layout (first pass only) and log results.
    if err==0 then
      change hlist color=RED
      add hlist text="Adjusted parameter    Old value New value  Units"
      add hlist text=""
      change hlist color=BLACK
      if extmeas==0 then
        lcorr=Getxmean(lmean)
        xl.lzero=xl.lzero+lcorr*1000.0
        xl.lrshift=xl.lrshift+(Getxmean(rmean)-Getxmean(refmean))*1.0e6
        add hlist text=format("%-22.22s%9.3f%10.3f  uH",                       \
          "Residual inductivity",$EXTLAY.lzero/1000.0,xl.lzero/1000.0)
        add hlist text=format("%-22.22s%9.4f%10.4f  uH/Ohm",                   \
          "Phase correction x1",$EXTLAY.lphase2,xl.lphase2)
        add hlist text=format("%-22.22s%9.4f%10.4f  uH/Ohm",                   \
          "Phase correction x10",$EXTLAY.lphase1,xl.lphase1)
        add hlist text=format("%-22.22s%9.3f%10.3f  Ohm",                      \
          "Resistance shift",$EXTLAY.lrshift/1.0e6,xl.lrshift/1.0e6)
        add hlist text=""
      else
        add hlist text=format("%-22.22s%9i%10i  Hz",                           \
          "Frequency",oldfreq[freq],freqset[freqindex[freq]])
        add hlist text=format("%-22.22s%9.3f%10.3f  Ohm",                      \
          "Resistance shift",extlr,Getxmean(rmean)-Getxmean(refmean))
        add hlist text=format("%-22.22s%9.3f%10.3f  uH",                       \
          "Range offset",extlrangecorr,rangediff)
        add hlist text=""
      endif
      if extmeas==0 intladjusted=1
      if txtok!=0 then                 // Write results to .TXT protocol
        if extmeas==0 then
          fprintf(hlog,"\n          Calibration of internal resistance/")
          fprintf(hlog,"inductivity measurements\n\n")
        else
          fprintf(hlog,"\n             Calibration of external inductivity ")
          fprintf(hlog,"at F=%i Hz\n\n",freqset[freqindex[freq]])
        endif
        fprintf(hlog," Parameter             Old value  New value     Sigma")
        fprintf(hlog,"  Units\n\n")
        if extmeas==0 then
          fprintf(hlog,                                                        \
            " Residual inductivity   %8.4g   %8.4g   %7.4g  uH\n",             \
            $EXTLAY.lzero/1000.0,xl.lzero/1000.0,Getsigma(lmean))
          fprintf(hlog,                                                        \
            " Phase correction x1    %8.4g   %8.4g            uH/Ohm\n",       \
            $EXTLAY.lphase2,xl.lphase2)
          fprintf(hlog,                                                        \
            " Phase correction x10   %8.4g   %8.4g            uH/Ohm\n",       \
            $EXTLAY.lphase1,xl.lphase1)
          fprintf(hlog,                                                        \
            " Resistance shift       %8.4g   %8.4g            Ohm\n",          \
            $EXTLAY.lrshift/1.0e6,xl.lrshift/1.0e6)
          ;
        else
          fprintf(hlog,                                                        \
            " Frequency              %8i   %8i            Hz\n",               \
            oldfreq[freq],freqset[freqindex[freq]])
          fprintf(hlog,                                                        \
            " Resistance shift       %8.4g   %8.4g            Ohm\n",          \
            extlr,Getxmean(rmean)-Getxmean(refmean))
          fprintf(hlog,                                                        \
            " Range offset           %8.4g   %8.4g            uH\n",           \
            extlrangecorr,rangediff)
          ;
        endif
        fprintf(hlog," Flash key              %08X   %08X\n",oldkey,newkey)
        fprintf(hlog,"\n\n                      Individual inductivity ")
        fprintf(hlog,"corrections\n                        (All values ")
        fprintf(hlog,"are in microhenry)\n\n")
        for n=0,n<$LAY.nfing*2,n=n+8 do
          fprintf(hlog," Head        ")
          for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
            fprintf(hlog,"   %4i%c",i/2,i & 1?'R':'L')
          enddo
          for j=0,j<$LAY.nfing*2,j++ do
            fprintf(hlog,"\n\n %2i%c   New   ",j/2,j & 1?'R':'L')
            for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
              if i==j then
                fprintf(hlog,"     -  ")
              else if used[i]==0 || used[j]==0 then
                if extended[i,j]!=0 then
                  fprintf(hlog," %6.2g*",newflash[i,j])
                else
                  fprintf(hlog,"        ")
                endif
              else
                fprintf(hlog," %7.3g",newflash[i,j])
              endif
            enddo
            fprintf(hlog,"\n       Old   ")
            for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
              if i==j then
                fprintf(hlog,"        ")
              else
                fprintf(hlog," %7.3g",oldflash[i,j])
              endif
            enddo
          enddo
          fprintf(hlog,"\n\n")
        enddo
      endif
      if rtfok!=0 then                 // Write results to .RTF protocol
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_BOLD,14)
        RAddtext("\n")
        if extmeas==0 then RAddtext(                                           \
          "Calibration of internal resistance/inductivity measurements")
        else RAddfmt("Calibration of external inductivity at F=%i Hz",         \
          freqset[freqindex[freq]])
        endif
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,35.0); RAddtext("Parameter")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("Old value")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("New value")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0); RFmt(RTF_SYMBOL,RTF_NORMAL,9)
        RAddtext("s"); RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0); RAddtext("Units")
        if extmeas==0 then
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Residual inductivity")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",$EXTLAY.lzero/1000.0)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9);
          RAddfmt("%.4g",xl.lzero/1000.0)
          RFmt(RTF_TIMES,RTF_NORMAL,9);
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",Getsigma(lmean))
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H")
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Phase correction x1")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",$EXTLAY.lphase2)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9);
          RAddfmt("%.4g",xl.lphase2)
          RFmt(RTF_TIMES,RTF_NORMAL,9);
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H/")
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("W")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Phase correction x10")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",$EXTLAY.lphase1)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9);
          RAddfmt("%.4g",xl.lphase1)
          RFmt(RTF_TIMES,RTF_NORMAL,9);
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H/")
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("W")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
        else
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Frequency")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%i",oldfreq[freq])
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9)
          RAddfmt("%i",freqset[freqindex[freq]])
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RAddtext("Hz")
        endif
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Resistance shift")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        if extmeas==0 then
          RAddfmt("%.4g",$EXTLAY.lrshift/1.0e6)
        else
          RAddfmt("%.4g",extlr)
        endif
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RFmt(RTF_TIMES,RTF_BOLD,9)
        if extmeas==0 then
          RAddfmt("%.4g",xl.lrshift/1.0e6)
        else
          RAddfmt("%.4g",Getxmean(rmean)-Getxmean(refmean))
        endif
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("W")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        if extmeas!=0 then
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Range offset")
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RAddfmt("%.4g",extlrangecorr)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RFmt(RTF_TIMES,RTF_BOLD,9)
          RAddfmt("%.4g",rangediff)
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RCell(RTF_CENTERED|RTF_THINBRD,26.0)
          RCell(RTF_CENTERED|RTF_THINBRD,20.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("m")
          RFmt(RTF_TIMES,RTF_NORMAL,9); RAddtext("H")
        endif
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        RCell(RTF_LEFT|RTF_THINBRD,35.0); RAddtext("Flash key")
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RAddfmt("%08X",oldkey)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RFmt(RTF_TIMES,RTF_BOLD,9)
        RAddfmt("%08X",newkey)
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        RCell(RTF_CENTERED|RTF_THINBRD,26.0)
        RCell(RTF_CENTERED|RTF_THINBRD,20.0)
        REndtable()
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_BOLD,14)
        RAddtext("\nIndividual inductivity corrections")
        RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
        RFmt(RTF_TIMES,RTF_ITALIC,10)
        RAddtext("(All values are in microhenry)")
        RFmt(RTF_TIMES,RTF_NORMAL,9)
        for n=0,n<$LAY.nfing*2,n=n+8 do
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
          RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddtext("Head")
          RCell(RTF_CENTERED|RTF_THINBRD,12.0)
          for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
            RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,17.0)
            RAddfmt("%i%c",i/2,i & 1?'R':'L')
          enddo
          for j=0,j<$LAY.nfing*2,j++ do
            RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
            RCell(RTF_CENTERED|RTF_THINBRD,11.0)
            RAddfmt("%i%c",j/2,j & 1?'R':'L')
            RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("New\nOld")
            for i=n,i<n+8 && i<$LAY.nfing*2,i++ do
              if i==j then
                RCell(RTF_CENTERED|RTF_SPACE|RTF_THINBRD,17.0)
                RAddtext("-")
              else if used[i]==0 || used[j]==0 then
                RCell(RTF_CENTERED|RTF_THINBRD,17.0)
                if extended[i,j]!=0 then
                  RColour(GRAY)
                  RAddfmt("%.3g\n",newflash[i,j])
                  RColour(BLACK)
                  RAddfmt("%.3g",oldflash[i,j])
                else
                  RAddfmt("\n%.3g",oldflash[i,j])
                endif
              else
                RCell(RTF_CENTERED|RTF_THINBRD,17.0)
                RAddfmt("%.3g\n%.3g",newflash[i,j],oldflash[i,j])
              endif
            enddo
          enddo
          REndtable()
        enddo
      endif
    endif
  enddo
  // Restore default L measurement mode.
  if (features & MF_RLINIT) then
    buf[0]=0x35                        // S_RLINIT
    $uint2(buf+1)=0x0000               // Default mode
    $uint4(buf+3)=0                    // Default frequency
    $uint4(buf+7)=0                    // Default voltage
    $uint4(buf+11)=0
    $uint4(buf+15)=0
    $uint4(buf+19)=0
    $uint4(buf+23)=0
    SYS.Sendimm(32,27,buf)
  endif
  // Write new key and flash data.
  if err==0 && flashvalid then
    change hinfo text="??DDD?..."
    change hinfo limits=0,0
    if extmeas==0 then
      lcorr=Getxmean(lmean)
    else
      lcorr=0.0                        // Flash tables are biased
    endif
    $A[0].length=0
    s[0]=S_DEBUG
    s[1]=0x26                          // Write individual parameter
    s[2]=0x80                          // Measurement card
    if extmeas==0 then
      $uint2(s+3)=0                    // Internal version key
    else
      $uint2(s+3)=3                    // External version key
    endif
    $uint4(s+5)=newkey
    SYS.Sendimm(0,9,s)
    t=Time()+5000
    while t>Time() do
      if Pressed(hexit) return -1
      if Pressed(hcancel) then
        err=5; break
      endif
      if $A[0].length!=0 break
      wait
    enddo
    if $A[0].length==0 || $A[0].command!=S_DEBUG err=6
    if err==0 then
      $A[0].length=0
      s[0]=S_DEBUG
      s[1]=0x27                        // Write parameters from memory to flash
      s[2]=0x80                        // Measurement card
      SYS.Sendimm(0,3,s)
      t=Time()+10000
      while t>Time() do
        if Pressed(hexit) return -1
        if Pressed(hcancel) then
          err=5; break
        endif
        if $A[0].length!=0 break
        wait
      enddo
      if ($A[0].length==0 || $A[0].command!=S_DEBUG || $A[0].subcmd!=0) err=6
    endif
  endif
  if err==0 then
    Startexplanation()
    Explain("Comments to the tables above: To reach maximal accuracy for ")
    Explain("inductivity measurements, especially in low area, calibration ")
    Explain("measures common correction factors and saves them to layout. ")
    if flashvalid then
      Explain("Additionally, for each pair of heads it measures inductivity ")
      Explain("offset and saves it to flash memory on the measurement card. ")
    endif
    Explain("Script takes into account that thin printed lines between ")
    Explain("adjacent pads on the OlliBoard have own inductivity of ")
    if romdatavalid!=0 && romdata.lwire!=0.0 then
      Explain("%.3f microhenry.",romdata.lwire)
    else
      Explain("%.3f microhenry.",LCORR*rowdist)
    endif
    Endexplanation()
    Oversurface()
    i=Loadlayoutmeas($LAY,xl,1)
    if i<0 return i
    if i>0 err=7
    if err==0 then
      if txtok then
        fprintf(hlog,"\n\n--------------------------------------------------")
        fprintf(hlog,"---------------------------\n-------------------------")
        fprintf(hlog,"----------------------------------------------------\n")
      endif
      return 0                         // Inductivity calibration finished
    endif
  endif
reporterror:
  change hlist color=LIGHTRED
  add hlist text="Calibration interrupted!"
  Startexplanation()
  Explain("ATTENTION, calibration procedure detected critical error ")
  if err==1 then
    Explain("(timeout or command execution error) ")
  else if err==2 then
    Explain("(command execution error) ")
  else if err==3 then
    Explain("(unexpected answer) ")
  else if err==4 then
    Explain("(wrong measurements) ")
  else if err==6 then
    Explain("unable to flash data) ")
  else if err==7 then
    Explain("(unable to load or save layout) ")
  else if err==11 || err==12 then
    Explain("(invalid measurement device) ")
  else if err==13 then
    Explain("(unable to read flash data) ")
  else if err==14 then
    Explain("(unsupported external measurements) ")
  endif
  Explain("and was unable to finish inductivity calibration.")
  if err!=7 Explain(" Tester layout on the hard disk was not updated.")
  Endexplanation()
  if txtok then
    fprintf(hlog,"\n\n--------------------------------------------------")
    fprintf(hlog,"---------------------------\n-------------------------")
    fprintf(hlog,"----------------------------------------------------\n")
  endif
  clear hright
  change hinfo text="D??"
  change hinfo limits=0,0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==2 then
    draw text="???DD?!"
    draw at 6,60 color=BLACK
    draw text="Tester rejected command sent by this routine. Probably it "
    draw text="doesn't understand inductivity measurements. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  else if err==4 then
    draw text="2a??!"
    draw at 6,60 color=BLACK
    draw text="Inductivity and/or resistance measured by some fingers are "
    draw text="either out of allowed limits or very unstable. "
  else if err==6 then
    draw text="Error flashing data!"
    draw at 6,60 color=BLACK
    draw text="Measurement card was unable to flash individual corrections. "
  else if err==7 then
    draw text="Unable to save layout!"
    draw at 6,60 color=BLACK
    draw text="Script was unable to write new layout to tester and/or save "
    draw text="it to disk. "
  else if err==11 then
    draw text="?TD?2a???"
    draw at 6,60 color=BLACK
    draw text="Script makes calibration of internal inductivity measurements "
    draw text="but answer comes from the external measurement device. "
  else if err==12 then
    draw text="?TD?2a???"
    draw at 6,60 color=BLACK
    draw text="????a2???DD?,"
    draw text="??|?2a"
    draw text="?"
    draw text="?."
    draw text="???2a2??????? "
  else if err==13 then
    draw text="Inaccessible flash data!"
    draw at 6,60 color=BLACK
    draw text="Corrections for external inductivity measurements in flash on "
    draw text="the measurement card are not accessible. Probably the version "
    draw text="of embedded software (f_prog.bin) is too old and does not "
    draw text="support external corrections. "
  else if err==14 then
    draw text="Unsupported measurements!"
    draw at 6,60 color=BLACK
    draw text="Embedded software does not support external inductivity "
    draw text="measurements. Please update. "
  endif
  draw text="D????1?"
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end

// Calibrates phases and input resistances of on-head boards for universal
// capacity measurements and flashes corrections to measurement card. Requires
// embedded software with S_UNIC support.
function int Adjustuniversalc()
  int i,j,n,t,f,head,nhead,rail,flashvalid,attempt,test,swap,err
  int oldkey,newkey,isant[32],nant,fhead[32],nvalid[32],finished[32],calibrated
  float x[32],y[32]
  float oldcphase[NFREQ][32],oldrcorr[32]
  float newcphase[NFREQ][32],newrcorr[32]
  float c,r,c1,r1,z1,c2,r2,z2,uc[2,NFREQ,32,5],ur[2,NFREQ,32,5],dfi[NFREQ],dr
  char s[1024]
  handle hinterrupt,hcont
  int freq[NFREQ] = { 1, 2, 4, 8, 16, 32 }
  if testertype!=TT_A5 && testertype!=TT_A5L && testertype!=TT_A6 &&           \
    testertype!=TT_S1 && testertype!=TT_S2 && testertype!=TT_S3 &&             \
    testertype!=TT_A7 && testertype!=TT_A8                                     \
  then
    return 0                           // Only A5/A6/S1 support universal C
  endif
  clear hright
  change hinfo limits=0,0
  change hinfo text="Universal C calibration"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="This calibration will correct phase shifts and input resistances "
  draw text="of on-head boards, improving the accuracy of capacitive component "
  draw text="measurements (R+C and/or R||C)."
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D????Y2a?????"
  endc
  draw show
  err=0
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  add hlist text="    CALIBRATION OF UNIVERSAL C MEASUREMENTS"
  add hlist text=""
  // Recalculate head numbers in flash to those in layout.
  nhead=$LAY.nfing*2
  for i=0,i<32,i++ do
    fhead[i]=-1
    nvalid[i]=0
    finished[i]=0
  enddo
  for head=0,head<nhead,head++ do
    if $LAY.side[head/2]==0 then
      fhead[head]=head
    else
      fhead[head]=head-$LAY.nfing+16
    endif
  enddo
/*

  // Get old individual corrections from the flash.
  flashvalid=1
  for head=0,head<nhead && flashvalid==1,head++ do
    for j=0,j<NFREQ,j++ do
      $A[j].length=0
      s[0]=S_DEBUG
      s[1]=0x25                        // Get individual parameter
      s[2]=0x80                        // Measurement card
      $uint2(s+3)=64+1024+fhead[head]*NFREQ+j
      SYS.Sendimm(j,5,s)
    enddo
    $A[NFREQ].length=0
    s[0]=S_DEBUG
    s[1]=0x25                          // Get individual parameter
    s[2]=0x80                          // Measurement card
    $uint2(s+3)=64+1024+NFREQ*32+fhead[head]
    SYS.Sendimm(NFREQ,5,s)
    t=Time()
    while err==0 do
      for j=0,j<=NFREQ,j++ do
        if $A[j].length==0 break
      enddo
      if j>NFREQ break
      if Pressed(hexit) return -1      // Operator interrupted test
      if Time()-t>5000 err=2
      if Pressed(hinterrupt) err=5
      wait
    enddo
    for j=0,j<NFREQ,j++ do
      if $A[j].length==9 && $A[j].command==S_DEBUG then
        oldcphase[j][head]=$float4($A[j]+5)
      else
        flashvalid=0
      endif
    enddo
    if $A[NFREQ].length==9 && $A[NFREQ].command==S_DEBUG then
      oldrcorr[head]=$float4($A[NFREQ]+5)
    else
      flashvalid=0
    endif
  enddo
  // Get old version of flash corrections.
  if flashvalid then
    $A[0].length=0
    s[0]=S_DEBUG
    s[1]=0x25                          // Get individual parameter
    s[2]=0x80                          // Measurement card
    $uint2(s+3)=2                      // Universal C version key
    SYS.Sendimm(0,5,s)
    t=Time()
    while err==0 do
      if $A[0].length!=0 break
      if Pressed(hexit) return -1      // Operator interrupted test
      if Time()-t>5000 err=2
      if Pressed(hinterrupt) err=5
      wait
    enddo
    if $A[0].length==9 && $A[0].command==S_DEBUG then
      oldkey=$int4($A[0]+5)
    else
      oldkey=0
    endif
  endif
  if flashvalid then
    Memcpy(newcphase,oldcphase,Sizeof(newcphase))
    Memcpy(newrcorr,oldrcorr,Sizeof(newrcorr))
  else
    Memset(newcphase,0,Sizeof(newcphase))
    Memset(newrcorr,0,Sizeof(newrcorr))
  endif
  Clearoversurface()
  calibrated=0
  // Measure pure capacities 2.7 and 22 nF using universal C at 2 kHz. I repeat
  // this test several times till there is no difference between the runs.
  for attempt=0,attempt<8 && err==0,attempt++ do
    change hinfo text=format("C calibration, pass %i",attempt+1)
    // Calibrate all heads.
    for head=0,head<nhead && err==0,head++ do
      if finished[head] continue       // Head is calibrated
      // Initialize statistics.
      for j=0,j<2,j++ do
        for f=0,f<NFREQ,f++ do
          Initsigma(uc[j,f,head])
          Initsigma(ur[j,f,head])
        enddo
      enddo
      // Select antenna(s). If possible, I use all heads on the opposite side
      // as antennas. If not, all other rails. As a last resort, antenna is the
      // opposite finger.
      nant=0; swap=0
      for i=0,i<nhead,i++ do           // First opposite side
        if $LAY.side[i/2]!=$LAY.side[head/2] then
          isant[i]=(i & 1)+1; nant++
        else
          isant[i]=0
        endif
      enddo
      if nant==0 then                  // Then different rails
        for i=0,i<nhead,i++ do
          if i/2!=head/2 then
            isant[i]=(i & 1)+1; nant++
          endif
        enddo
      endif
      if nant==0 then                  // Then opposite head
        isant[head^1]=(i & 1)+1; nant++
        if (head & 1)==0 swap=1
      endif
      // Test two capacitors.
      for j=0,j<2 && err==0,j++ do
        // Repeat test in several different positions for the case of no or
        // unstable contact.
        for test=0,test<5 && err==0,test++ do
          change hinfo limits=head*10+j*5+test,nhead*10
          // Calculate head coordinates.
          for i=0,i<nhead,i++ do
            if i==head then
              Convertpad(x+i,y+i,(swap?"GND2":(j==0?"C2N7":"C22N")),i,DELTA)
            else if isant[i]!=0 && i==(head^1) then
              Convertpad(x+i,y+i,(swap==0?"GND2":(j==0?"C2N7":"C22N")),i,DELTA)
            else if isant[i] then
              Convertpad(x+i,y+i,(isant[i]==1?"GND1":"GND2"),i,DELTA)
            endif
          enddo
          // Prepare command.
          n=sprintf(s,"M %i[%g,%gA%i] ",head,x[head],y[head],acc)
          for i=0,i<nhead,i++ do
            if i==head continue
            if isant[i] then
              n=n+sprintf(s+n,"%i[%g,%gA%i] ",i,x[i],y[i],acc)
            else
              n=n+sprintf(s+n," %i(Z)",i)
            endif
          enddo
          n=n+sprintf(s+n,"UC(%i",head)
          for i=0,i<nhead,i++ do
            if i==head || isant[i]==0 continue
            n=n+sprintf(s+n,",%i",i)
          enddo
          // Keep n unchanged: it will be reused later.
          sprintf(s+n,",G=1,U=1.0,N,BR,F=1953)")
          // Send 16 measurements at once.
          for i=0,i<16 && err==0,i++ do
            if SERV.Cmdimm(i,s)<0 err=1
          enddo
          // Wait for answers.
          t=Time()
          while err==0 do
            for i=0,i<16,i++ do
              if $A[i].length==0 break
            enddo
            if i>=16 break
            if Pressed(hexit) err=-1
            if Time()-t>15000 err=2
            if Pressed(hinterrupt) err=5
            wait
          enddo
          // Analyse answers. First two may be unstable and I discard them.
          for i=2,i<16 && err==0,i++ do
            if $A[i].answer==S_ERROR then
              err=3; break             // UC measurements unsupported?
            else if $A[i].answer!=S_MOVE || $A[i].subcmd!=M_UNIC then
              err=4; break             // Unbelievable, wrong answer
            else if ($A[i].status & 0x9E00)==0 then
              c=$float4($A[i]+10)      // Picofarades
              r=$float4($A[i]+14)      // Ohms
              if j==0 && (c<2700.0*0.7 || c>2700.0*1.3) continue
              if j==1 && (c<22000.0*0.7 || c>22000.0*1.3) continue
              if ($A[i].status & 0x0180)!=0x0000                               \
                continue               // Not an AC measurement
              Addsigma(uc[j,1,head],c)
              Addsigma(ur[j,1,head],r) // In optimal case, 5*14=70 answers
            endif
          enddo
          // Measure shifts on other frequencies (2.7 nF). Frequency 32 kHz is
          // unsupported.
          for f=0,f<NFREQ-1,f++ do
            if f==1 continue           // Already measured
            if j!=0 continue           // Only first capacitor
            // Prepare command. Coordinates of pads are the same.
            sprintf(s+n,",G=1,U=%g,N,BR,F=%i)",(f==0?4.0:1.0),freq[f]*1000)
            // Send 16 measurements at once.
            for i=0,i<16 && err==0,i++ do
              if SERV.Cmdimm(i,s)<0 err=1
            enddo
            // Wait for answers.
            t=Time()
            while err==0 do
              for i=0,i<16,i++ do
                if $A[i].length==0 break
              enddo
              if i>=16 break
              if Pressed(hexit) err=-1
              if Time()-t>15000 err=2
              if Pressed(hinterrupt) err=5
              wait
            enddo
            // Analyse answers. First may be unstable and I discard it.
            for i=1,i<16 && err==0,i++ do
              if $A[i].answer==S_ERROR then
                err=3; break           // UC measurements unsupported?
              else if $A[i].answer!=S_MOVE || $A[i].subcmd!=M_UNIC then
                err=4; break           // Unbelievable, wrong answer
              else if ($A[i].status & 0x9E00)==0 then
                c=$float4($A[i]+10)    // Picofarades
                r=$float4($A[i]+14)    // Ohms
                if j==0 && (c<2700.0*0.7 || c>2700.0*1.3) continue
                if j==1 && (c<22000.0*0.7 || c>22000.0*1.3) continue
                if ($A[i].status & 0x0180)!=0x0000                             \
                  continue             // Not an AC measurement
                Addsigma(uc[j,f,head],c)
                Addsigma(ur[j,f,head],r)
              endif
            enddo
          enddo
        enddo
      enddo
      if err!=0 break
      // Measurements for head are finished. Check whether they are valid.
      for j=0,j<2,j++ do
        for f=0,f<NFREQ-1,f++ do
          if f!=1 && j!=0 continue
          if Getcount(uc[j,f,head])<30 break
          if Getsigma(uc[j,f,head])>30.0 break
          if Getcount(ur[j,f,head])<30 break
          if Getsigma(ur[j,f,head])>10.0 break
        enddo
        if f<NFREQ-1 break
      enddo
      if j<2 continue                  // Too few good measurements
      // Calculate corrections for f=2 kHz. At this frequency I expect the
      // following sequential resistances for standard non-patched OllyBoard:
      //   270 pF  -  250 Ohm
      //   2.7 nF  -   21 Ohm
      //    22 nF  -   19 Ohm
      //   220 nF  -  1.9 Ohm
      // At different freqiencies, resistance varies more or less as 1/f (the
      // higher the frequency, the lower the effective resistance).
      c1=Getmean(uc[0,1,head])
      r1=Getmean(ur[0,1,head])-21.0    // See above
      c2=Getmean(uc[1,1,head])
      r2=Getmean(ur[1,1,head])-19.0    // See above
      z1=1.0e12/(2*3.14159265*1953.0*c1)
      z2=1.0e12/(2*3.14159265*1953.0*c2)
      dfi[1]=-(r1-r2)/(z1-z2)
      dr=z1*dfi[1]-r1
      newcphase[1][head]=newcphase[1][head]+dfi[1]
      newrcorr[head]=newrcorr[head]+dr
      // Calculate corrections for other frequencies.
      for j=0,j<2,j++ do
        for f=0,f<NFREQ-1,f++ do
          if f==1 || j==1 continue
          c1=Getmean(uc[j,f,head])
          // Same as above, I correct for the own resistance of the capacitor.
          r1=Getmean(ur[j,f,head])-(j==0?21.0:19.0)
          dfi[f]=-r1*3.14159265*freq[f]*1953.0*c1*1.0e-12
          newcphase[f][head]=newcphase[f][head]+dfi[f]
        enddo
      enddo
      // Send corrected parameters to the measurement card.
      for f=0,f<NFREQ && err==0,f++ do
        s[0]=S_DEBUG
        s[1]=0x26                      // Write individual parameter
        s[2]=0x80                      // Measurement card
        $uint2(s+3)=64+1024+fhead[head]*NFREQ+f
        $float4(s+5)=newcphase[f][head]
        if SYS.Sendimm(0,9,s)<0 err=1
      enddo
      s[0]=S_DEBUG
      s[1]=0x26                        // Write individual parameter
      s[2]=0x80                        // Measurement card
      $uint2(s+3)=64+1024+NFREQ*32+fhead[head]
      $float4(s+5)=newrcorr[head]
      if SYS.Sendimm(1,9,s)<0 err=1
      // Wait for answers.
      t=Time()
      while err==0 do
        if $A[0].length>0 && $A[1].length>0 break
        if Pressed(hexit) return -1    // Operator interrupted test
        if Time()-t>5000 err=2
        if Pressed(hinterrupt) err=5
        wait
      enddo
      if $A[0].answer!=S_DEBUG || $A[1].answer!=S_DEBUG then
        err=4
      else
        nvalid[head]++
        for f=0,f<NFREQ-1,f++ do
          if Abs(dfi[f])>0.00070 break
        enddo
        if (nvalid[head]>=2 && f>=NFREQ-1 && Abs(dr)<7.0) then
          finished[head]=1
        endif
      endif
    enddo
    if err!=0 break
    // Check whether all heads are calibrated.
    for head=0,head<nhead,head++ do
      if finished[head]==0 break
    enddo
    if head>=nhead then
      calibrated=1; break              // Calibration finished
    endif
  enddo
  if err==0 && calibrated==0 then
    err=6
  endif
  if err==0 then
    // Change version of corrections in layout and in flash. Least significant
    // byte is the version of correction procedure (this one), currently it's
    // zero.
    newkey=(Random(0x7FFFFFFF)<<1) & 0xFFFFFF00
    $uint4($EXTLAY+452)=newkey
    s[0]=S_DEBUG
    s[1]=0x26                          // Write individual parameter
    s[2]=0x80                          // Measurement card
    $uint2(s+3)=2                      // Universal C version key
    $uint4(s+5)=newkey
    SYS.Sendimm(0,9,s)
    t=Time()
    while err==0 do
      if $A[0].length!=0 break
      if Pressed(hexit) return -1      // Operator interrupted test
      if Time()-t>5000 err=2
      if Pressed(hinterrupt) err=5
      wait
    enddo
  endif
  // Flash new data.
  if err==0 then
    $A[0].length=0
    s[0]=S_DEBUG
    s[1]=0x27                          // Write parameters from memory to flash
    s[2]=0x80                          // Measurement card
    SYS.Sendimm(0,3,s)
    t=Time()
    while err==0 do
      if $A[0].length!=0 break
      if Pressed(hexit) return -1      // Operator interrupted test
      if Time()-t>5000 err=2
      if Pressed(hinterrupt) err=5
      wait
    enddo
    if err==0 && ($A[0].command!=S_DEBUG || $A[0].subcmd!=0) err=8
  endif
  // Reload layout and save it to disk.
  if err==0 then
    i=Loadlayoutmeas($LAY,$EXTLAY,1)
    if i<0 return i
    if i>0 err=7
  endif
  // Protocol results.
  if err==0 then
    // On the screen I show only phase at 2 kHz.
    change hlist color=RED
    add hlist text="Head Parm         Old value   New value    Units"
    add hlist text=""
    change hlist color=BLACK
    for head=0,head<nhead,head++ do
      add hlist text=format("%2i%s  Phase (2kHz) %9.5f   %9.5f      rad",      \
        head/2,head & 1?"R":"L",oldcphase[1][head],newcphase[1][head])
      add hlist text=format("     Resistance     %7.1f     %7.1f      Ohm",    \
        oldrcorr[head],newrcorr[head])
      add hlist text=""
    enddo
    if txtok!=0 then                   // Write results to .TXT protocol
      fprintf(hlog,"\n                Calibration of universal capacity ")
      fprintf(hlog,"measurements\n\n")
      fprintf(hlog," Head   Parameter                     Old value         ")
      fprintf(hlog,"New value       Units\n\n")
      for head=0,head<nhead,head++ do
        fprintf(hlog," %2i%s    Phase shift at  1 kHz  %16.5f  %16.5f",        \
          head/2,head & 1?"R":"L",oldcphase[0][head],newcphase[0][head])
        fprintf(hlog,"         rad\n")
        for j=1,j<NFREQ-1,j++ do
          fprintf(hlog,"        Phase shift at %2i kHz  %16.5f  %16.5f",       \
            freq[j],oldcphase[j][head],newcphase[j][head])
          fprintf(hlog,"         rad\n")
        enddo
        fprintf(hlog,"        Input resistance       %16.2f  %16.2f",          \
          oldrcorr[head],newrcorr[head])
        fprintf(hlog,"         Ohm\n\n")
      enddo
    endif
    if rtfok!=0 then                   // Write results to .RTF protocol
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      RAddtext("\nCalibration of universal capacity measurements")
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,16.0); RAddtext("Head")
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,45.0); RAddtext("Parameter")
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,26.0); RAddtext("Old value")
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,26.0); RAddtext("New value")
      RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,20.0); RAddtext("Units")
      for head=0,head<nhead,head++ do
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
        // Head.
        RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,16.0);
        RAddfmt("%i%s",head/2,head & 1?"R":"L")
        // Parameter.
        RCell(RTF_LEFT|RTF_THINBRD,45.0);
        for j=0,j<NFREQ-1,j++ do
          RAddfmt(" Phase shift at %i kHz\n",freq[j])
        enddo
        RAddtext(" Input resistance")
        // Old value.
        RCell(RTF_CENTERED|RTF_THINBRD,26.0);
        for j=0,j<NFREQ-1,j++ do
          RAddfmt("%.5f\n",oldcphase[j][head])
        enddo
        RAddfmt("%.2f",oldrcorr[head])
        // New value.
        RCell(RTF_CENTERED|RTF_THINBRD,26.0);
        for j=0,j<NFREQ-1,j++ do
          RAddfmt("%.5f\n",newcphase[j][head])
        enddo
        RAddfmt("%.2f",newrcorr[head])
        // Units.
        RCell(RTF_CENTERED|RTF_THINBRD,20.0);
        RAddtext("Radian\n\n\n\n\nOhm")
      enddo
      REndtable()
    endif
    Startexplanation()
    Explain("Comments to the table above: To reach maximal accuracy for ")
    Explain("the component capacity measurements, calibration has measured ")
    Explain("individual parameters of the on-head boards at all supported ")
    Explain("frequencies and flashed them to the measurement card.")
    Endexplanation()
    if txtok!=0 then                   // Write results to .TXT protocol
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    Oversurface()
    // Calibration successfully finished.
    return 0
  endif
  // Some unrecoverable error was detected, inform user.
  change hlist color=LIGHTRED
  add hlist text="Calibration interrupted!"
  clear hright
  change hinfo text="D??"
  change hinfo limits=0,0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="Unable to send command!"
    draw at 6,60 color=BLACK
    draw text="Script was unable to send command to the tester. Maybe your "
    draw text="OllyTest is too old and does not match this script. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="???DD?!"
    draw at 6,60 color=BLACK
    draw text="Tester rejected command sent by this routine. Probably it "
    draw text="doesn't understand universal capacity measurements. "
  else if err==4 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  else if err==6 then
    draw text="2a??!"
    draw at 6,60 color=BLACK
    draw text="After multiple attempts to calibrate universal capacity "
    draw text="measurements, script was unable to gather reliable data. The "
    draw text="measured values are either out of allowed limits or very "
    draw text="unstable. "
  else if err==7 then
    draw text="Unable to save layout!"
    draw at 6,60 color=BLACK
    draw text="Script was unable to write new layout to tester and/or save "
    draw text="it to disk. "
  else if err==8 then
    draw text="Error flashing data!"
    draw at 6,60 color=BLACK
    draw text="Measurement card was unable to flash individual corrections. "
  endif
  draw text="Calibration interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
*/
end

#define NNOISE         5               // Max number of noise components

int    usenoise[NNOISE]                // Components selected for noise test

// Attempts to find heads that produce the most noise in the system, may be
// slow!
function int Noise()
  char nmstd[NNOISE][32] = {         \ // Comps, type, sel, range, description
    "R100M           R 0 100 M",     \ // Resistance 100 MOhm
    "R10M    C220N   P 0 10 M 220 n",\ // R||C 10 MOhm, 220 nF
    "C2N7            C+3 2.7 nF",    \ // Capacity 2.72 nF (fast C)
    "C220N           C+5 220 nF" }     // Capacity 220 nF (fast C)
  char nmtri[NNOISE][32] = {         \ // Comps, type, sel, range, description
    "R47M            R 0 47 M",      \ // Resistance 47 MOhm
    "R10M    C220N   P 0 10 M 220 n",\ // R||C 10 MOhm, 220 nF
    "C2N7            C+3 2.7 nF",    \ // Capacity 2.72 nF (fast C)
    "C220N           C+5 220 nF" }     // Capacity 220 nF (fast C)
  int i,j,jj,k,l,m,n,nn,p,t,nhead,ncomp,nsel,pressure
  int range,success,count,changed,list[33],nlist,err
  float x,y,oppx,oppy,cx,cy,dx,dy,ay,antx[32],anty[32]
  float value,maxerr,r,c,d,factor
  float stat[32,32,NNOISE,5]           // Head, antenna, component, statistics
  float hnoise[32,NNOISE,5],anoise[32,NNOISE,5],mnoise[NNOISE,5],limit[NNOISE]
  char s[1000],w[32],nm[NNOISE][32]
  handle hsel[NNOISE],hok,hcancel,hinterrupt,hcont
  nhead=$LAY.nfing*2
  if (romdata.features & BF_TYPE)==BF_TRIPOD then
    Memcpy(nm,nmtri,Sizeof(nmtri))
  else
    Memcpy(nm,nmstd,Sizeof(nmstd))
  endif
  for ncomp=0,ncomp<NNOISE,ncomp++ do
    if nm[ncomp][0]=='\0' break
    for i=0,i<16,i++ do
      if nm[ncomp][i]==' ' nm[ncomp][i]='\0'
    enddo
  enddo
  // Select components that should be tested.
  for k=0,k<ncomp,k++ do
    if usenoise[k]!=0 break
  enddo
  if k>=ncomp then
    // All components turned off, select default measurements.
    for k=0,k<ncomp,k++ do
      usenoise[k]=(nm[k,17]=='+'?1:0)
    enddo
  endif
  clear hright
  change hinfo limits=0,0
  change hinfo text="??2a?"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="????|???2a??2??t:"
  for k=0,k<ncomp,k++ do
    if nm[k][16]=='C' then
      Strcpy(s,"?? C")
    else if nm[k][16]=='F' then
      Strcpy(s,"Field")
    else if nm[k][16]=='P' then
      Strcpy(s,"R || C")
    else
      Strcpy(s,"?")
    endif
    hsel[k]=control CHECKBOX
      window=hright
      position=20,80+25*k,180,24
      text=format("%s %s",s,nm[k]+20)
      help="2a?????t?????"
      mode=(usenoise[k]?M_CHECKED:0)
    endc
  enddo
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="???"
    help="?????2?"
  endc
  hok=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="?"
    help="????a???2a?"
  endc
  changed=1
  while 1 do
    if changed!=0 then
      nsel=0
      for k=0,k<ncomp,k++ do
        if usenoise[k]!=0 nsel++
      enddo
      if nsel>0 then
        enable hok
      else
        disable hok
      endif
      changed=0
    endif
    if Pressed(hexit) then
      return -1
    else if Pressed(hcancel) then
      return 0
    else if Pressed(hok) then
      break
    endif
    for k=0,k<ncomp,k++ do
      if Pressed(hsel[k]) then
        usenoise[k]=Status(hsel[k])
        changed=1
      endif
    enddo
    wait
  enddo
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="????????????2a??o?"
  draw text="??o2a??o??2a??1????"
  draw text="?2????DD?o???2?????"
  if nused>8 then
    draw text=" Note that this test will take plenty of time!"
  endif
  draw show
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D????2a?"
  endc
  add hlist text=""
  add hlist text=""
  change hlist color=RED
  add hlist text="                  NOISE TEST"
  add hlist text=""
  // Stable contacts is a must during the noise test. We are going to detect
  // electrical noise, not mechanical!
  pressure=Max(70,strokep)
  // Calculate preliminary antenna coordinates.
  for j=0,j<nhead,j++ do
    if used[j]==0 continue
    Convertpad(antx+j,anty+j,(j & 1?"GND2":"GND1"),j,0.0)
  enddo
  err=0
  Memset(stat,0,Sizeof(stat))
  // Main test.
  for i=0,i<nhead && err==0,i++ do     // For all measurement heads
    if used[i]==0 continue
    // Move all antennas into preliminary coordinates.
    n=sprintf(s,"M ")
    for j=0,j<nhead,j++ do             // For all antennas
      if used[j]==0 continue
      if j/2==i/2 continue             // Same rail as measurement head
      n=n+sprintf(s+n,"%i[%g,%g] ",j,antx[j],anty[j])
    enddo
    sprintf(s+n,"NOP")
    if SERV.Cmdimm(32,s)<0 err=1       // Unable to send command
    t=Time()
    while $A[32].length==0 && err==0 do
      if Pressed(hexit) return -1      // Button "Exit" works as interrupt
      if Pressed(hinterrupt) err=4
      if Time()-t>5000 err=2           // Timeout exhausted
      wait
    enddo
    for k=0,k<ncomp && err==0,k++ do   // For all components
      if usenoise[k]==0 continue
      change hinfo limits=i*ncomp+k,nhead*ncomp
      for p=0,p<8 && err==0,p++ do     // Retest counter
        success=1
        value=Getvaluebyname(nm[k]+0)
        // Calculate pad coordinates.
        if nm[k][16]=='P' then         // R||C
          Convertpad(&x,&y,(i & 1?"GND2":"R1"),i,DELTA)
        else
          Convertpad(&x,&y,nm[k]+0,i,DELTA)
        endif
        for j=0,j<nhead && err==0,j++ do // For all antennas
          if used[j]==0 continue
          if j/2==i/2 continue         // Same rail as measurement head
          if Getcount(stat[i][j][k])>=50 continue
          success=0                    // Need one more loop
          // Calculate antenna coordinates and gather command.
          if nm[k][16]=='P' then
            // High resistor has only small influence on the noise. Main part
            // comes from the capacitor.
            Convertpad(&oppx,&oppy,nm[k]+0,i^1,DELTA)
            Convertpad(&cx,&cy,nm[k]+8,j,DELTA)
            Convertpad(&dx,&dy,nm[k]+8,j^1,0.0)
            if (j & 1)==0 then
              dx=dx+15.0
            else
              dx=dx-15.0
            endif
            n=sprintf(s,"M %i[%g,%gA10P%i] %i[%g,%gA10P%i] ",                  \
              i,x,y,pressure,i^1,oppx,oppy,pressure)
            n=n+sprintf(s+n,"%i[%g,%gA10P%i] %i[%g,%g] R(%i,%i,%i)",           \
              j,cx,cy,pressure,j^1,dx,dy,i,i^1,j)
            maxerr=0.3                 // Max error 30%
          else
            Convertpad(antx+j,anty+j,(j & 1?"GND2":"GND1"),j,DELTA)
            n=sprintf(s,"M %i[%g,%gA10P%i] %i(Z) %i[%g,%gA10P%i] ",            \
              i,x,y,pressure,i^1,j,antx[j],anty[j],pressure)
            if nm[k][16]=='C' ||                                               \
              (nm[k][16]=='F' && ($LAY.config & LC_OHTYPE)==LC_NOFIELD)        \
            then                       // Fast C measurement
              nm[k][16]='C'
              maxerr=0.1               // Max error 10%
              range=nm[k][18]-'0'
              sprintf(s+n,"A(%i,%iN,%i)",i,range,j)
            else if nm[k][16]=='F' then// Field measurement
              maxerr=0.1               // Max error 10%
              sprintf(s+n,"F(%i,%i)",i,j)
            else                       // Assume resistance
              maxerr=0.3               // Max error 30%
              sprintf(s+n,"R(%i,%i)",i,j)
            endif
          endif
          // Make dummy measurement and wait a bit for better contact.
          if SERV.Cmdimm(0,s)<0 err=1
          t=Time()
          while err==0 do
            if $A[0].length!=0 break
            if Pressed(hexit) return -1
            if Pressed(hinterrupt) err=4
            if Time()-t>7000 err=2
            wait
          enddo
          if err==0 then
            t=Time()
            while Time()-t<(p==0 && j==0?1000:100) do
              if Pressed(hexit) return -1
              wait
            enddo
          endif
          // Send 32 commands at once.
          for m=0,m<32 && err==0,m++ do
            if SERV.Cmdimm(m,s)<0 err=1
          enddo
          t=Time()
          while err==0 do
            for m=0,m<32 && err==0,m++ do
              if Pressed(hexit) return -1
              if $A[m].length==0 break
              if $A[m].answer!=S_MOVE err=3
            enddo
            if m>=32 break
            if Pressed(hinterrupt) err=4
            // Measurements may take plenty of time.
            if Time()-t>5000+m*5000 err=2
            wait
          enddo
          // I discard first 4 measurements as possibly unreliable.
          for m=4,m<32,m++ do
            if nm[k][16]=='C' then     // Capacity measurement
              if ($A[m].status & 0x9E20)!=0 continue
              SERV.Convertfastc($A[m],&c,&r)
              if c<value/1.5 || c>value*1.5 continue
              Addsigma(stat[i][j][k],c)
            else if nm[k][16]=='F' then// Field measurement
              SERV.Convertfield($A[m],&c,&r)
              if c<value/2.5 || c>value*1.5 continue
              Addsigma(stat[i][j][k],c)
            else                       // Assume resistance
              if ($A[m].status & 0x9E00)!=0 continue
              r=$A[m].r
              if ($A[m].status & 0x0100) r=r*1.0e-6
              if r<value/1.5 || r>value*1.5 continue
              Addsigma(stat[i][j][k],r)
            endif
          enddo
          if Getmax(stat[i][j][k])-Getxmean(stat[i][j][k])>value*maxerr ||     \
            Getxmean(stat[i][j][k])-Getmin(stat[i][j][k])>value*maxerr         \
          then
            // Noise higher than expected, discard the whole data set.
            Initsigma(stat[i][j][k])
          endif
          // If this is a resistance or R||C measurement, move antenna up.
          if nm[k][16]=='R' then
            if anty[j]>$LAY.yoffset[j/2]/1000.0 then
              ay=anty[j]-0.010
            else
              ay=anty[j]+0.010
            endif
            sprintf(s,"M %i[%g,%g] NOP",j,antx[j],ay)
            SERV.Cmdimm(32,s)
          else if nm[k][16]=='P' && (j & 1)!=0 then
            if anty[j & 0xFE]>$LAY.yoffset[j/2]/1000.0 then
              ay=anty[j]-0.010
            else
              ay=anty[j]+0.010
            endif
            n=sprintf(s,"M %i[%g,%g] ",j & 0xFE,antx[j & 0xFE],ay)
            if anty[j | 0x01]>$LAY.yoffset[j/2]/1000.0 then
              ay=anty[j]-0.010
            else
              ay=anty[j]+0.010
            endif
            n=n+sprintf(s+n,"%i[%g,%g] NOP",j | 0x01,antx[j | 0x01],ay)
            SERV.Cmdimm(32,s)
          endif
        enddo
        if success break
      enddo
    enddo
  enddo
  if err==4 return 1                   // Cancelled by user
  if err==0 then
    // Process data.
    Memset(hnoise,0,Sizeof(hnoise))
    Memset(anoise,0,Sizeof(anoise))
    Memset(mnoise,0,Sizeof(mnoise))
    for i=0,i<nhead,i++ do             // Head
      if used[i]==0 continue
      for j=0,j<nhead,j++ do           // Antenna
        if used[j]==0 continue
        if j/2==i/2 continue
        for k=0,k<ncomp,k++ do         // Component
          if usenoise[k]==0 continue
          if Getcount(stat[i,j,k])<20 continue
          d=Getxsigma(stat[i,j,k])
          Addsigma(hnoise[i,k],d)
          Addsigma(anoise[j,k],d)
          Addsigma(mnoise[k],d)
        enddo
      enddo
    enddo
    // I mark as suspicious those head-antenna combinations where noise exceeds
    // 180% of mean noise.
    factor=1.8
    for k=0,k<ncomp,k++ do
      if usenoise[k]==0 continue
      value=Getvaluebyname(nm[k]+0)
      limit[k]=Max(Getmean(mnoise[k]),value*0.0001)*factor
    enddo
    // Protocol results to list.
    change hlist color=RED
    add hlist text="Head      Comp   Type     As head   As antenna"
    add hlist text=""
    for i=0,i<nhead,i++ do
      if used[i]==0 continue
      nn=0
      for k=0,k<ncomp,k++ do
        if usenoise[k]==0 continue
        value=Getvaluebyname(nm[k]+0)
        if nn==0 then
          n=sprintf(s,"%2i%s ",i/2,i & 1?"R":"L")
        else
          n=sprintf(s,"    ")
        endif
        nn++
        count=0
        l=0
        for j=20,j<32,j++ do
          if nm[k,j]=='\0' break
          if nm[k,j]==' ' continue
          w[l]=nm[k,j]; l++
        enddo
        w[l]='\0'
        n=n+sprintf(s+n,"%10.10s ",w)
        if nm[k][16]=='C' then
          n=n+sprintf(s+n," FastC")
        else if nm[k][16]=='F' then
          n=n+sprintf(s+n," Field")
        else if nm[k][16]=='P' then
          n=n+sprintf(s+n,"  R||C")
        else
          n=n+sprintf(s+n,"     R")
        endif
        if Getcount(hnoise[i][k])==0 then
          n=n+sprintf(s+n,"         -    ")
        else
          d=Getmean(hnoise[i][k])
          n=n+sprintf(s+n,"  %9.2f",d/value*1000.0)
          if d<limit[k] then
            n=n+sprintf(s+n,"   ")
          else
            n=n+sprintf(s+n," * ")
            count++
          endif
        endif
        if Getcount(anoise[i][k])==0 then
          n=n+sprintf(s+n,"        -")
        else
          d=Getmean(anoise[i][k])
          n=n+sprintf(s+n," %9.2f",d/value*1000.0)
          if d>=limit[k] then
            n=n+sprintf(s+n," *")
            count++
          endif
        endif
        change hlist color=(count==0?BLACK:LIGHTRED)
        add hlist text=s
      enddo
      add hlist text=""
    enddo
    nlist=0
    for i=0,i<nhead,i++ do
      if used[i]==0 continue
      list[nlist]=i
      nlist++
    enddo
    list[nlist]=nhead
    if txtok!=0 then
      // Write results to .TXT protocol.
      fprintf(hlog,"\n                               ??2a?\n")
      fprintf(hlog,"                           All values are in promille\n\n")
      for n=0,n<=nlist,n=n+8 do        // Antenna groups
        fprintf(hlog," Meas   Comp.     Antenna -->\n")
        fprintf(hlog," head       ")
        for jj=n,jj<n+8 && jj<=nlist,jj++ do
          j=list[jj]
          if jj<nlist then
            fprintf(hlog,"   %4i%c",j/2,j & 1?'R':'L')
          else
            fprintf(hlog,"    Mean")
          endif
        enddo
        fprintf(hlog,"\n")
        for i=0,i<=nhead,i++ do        // Heads and mean for antenna
          if i<nhead && used[i]==0 continue
          nn=0
          for k=0,k<ncomp,k++ do       // Components
            if usenoise[k]==0 continue
            if nn==0 then
              if i==nhead then
                fprintf(hlog,"\n Mean ")
              else
                fprintf(hlog,"\n %2i%c  ",i/2,i & 1?'R':'L')
              endif
            else
              fprintf(hlog,"\n      ")
            endif
            nn++
            l=0
            for j=20,j<32,j++ do
              if nm[k,j]=='\0' break
              if nm[k,j]==' ' continue
              s[l]=nm[k,j]; l++
            enddo
            s[l]='\0'
            fprintf(hlog,"%7.7s",s)
            value=Getvaluebyname(nm[k]+0)
            for jj=n,jj<n+8 && jj<=nlist,jj++ do
              j=list[jj]
              if j<nhead && i/2==j/2 then
                fprintf(hlog,"     -  ")
              else
                if i==nhead && j==nhead then
                  count=(Getcount(mnoise[k])==0?0:999)
                  d=Getmean(mnoise[k])
                else if i==nhead then
                  count=(Getcount(anoise[j][k])==0?0:999)
                  d=Getmean(anoise[j][k])
                else if j==nhead then
                  count=(Getcount(hnoise[i][k])==0?0:999)
                  d=Getmean(hnoise[i][k])
                else
                  count=Getcount(stat[i][j][k])
                  d=Getxsigma(stat[i][j][k])
                endif
                if count<20 then
                  fprintf(hlog,"    ??? ")
                else
                  // Displayed noise is in promille.
                  fprintf(hlog,"%7.2f%s",d/value*1000.0,(d<limit[k]?" ":"*"))
                endif
              endif
            enddo
          enddo
          fprintf(hlog,"\n")
        enddo
        fprintf(hlog,"\n")
      enddo
    endif
    if rtfok!=0 then
      // Write results to .RTF protocol.
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_BOLD,14)
      RAddtext("\n??2a?")
      RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
      RFmt(RTF_TIMES,RTF_ITALIC,10)
      RAddtext("All values are in promille")
      RFmt(RTF_TIMES,RTF_NORMAL,9)
      for n=0,n<=nlist,n=n+8 do        // Antenna groups
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
        RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Meas\nhead")
        RCell(RTF_CENTERED|RTF_THINBRD|RTF_SPACE,19.0); RAddtext("Comp.")
        for jj=n,jj<n+8,jj++ do
          j=(jj>nlist?32:list[jj])
          RCell(RTF_CENTERED|RTF_THINBRD,16.0)
          if j<nhead then
            RAddfmt("Antenna\n%i%c",j/2,j & 1?'R':'L')
          else if j==nhead then
            RAddtext("Mean\nby head")
          endif
        enddo
        for i=0,i<=nhead,i++ do        // Heads and mean for antenna
          if i<nhead && used[i]==0 continue
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RCell(RTF_CENTERED|RTF_THINBRD,12.0)
          if i==nhead then
            RAddtext("Mean\nby ant.")
          else
            RAddfmt("%s%i%c",(nsel<3?"":"\n"),i/2,(i & 1?'R':'L'))
          endif
          RCell(RTF_CENTERED|RTF_THINBRD,19.0)
          nn=0
          for k=0,k<ncomp,k++ do
            if usenoise[k]==0 continue
            nn++
            RAddfmt("%s%s",nm[k]+20,nn<nsel?"\n":"")
          enddo
          for jj=n,jj<n+8,jj++ do      // Antennas and mean for head
            j=(jj>nlist?32:list[jj])
            RCell(RTF_CENTERED|RTF_THINBRD,16.0);
            if j>nhead continue
            if j<nhead && i/2==j/2 then
              RFmt(RTF_TIMES,RTF_NORMAL,9)
              RAddtext(nsel<3?"-":"\n-")
            else
              nn=0
              for k=0,k<ncomp,k++ do
                if usenoise[k]==0 continue
                nn++
                if i==nhead && j==nhead then
                  count=(Getcount(mnoise[k])==0?0:999)
                  d=Getmean(mnoise[k])
                else if i==nhead then
                  count=(Getcount(anoise[j][k])==0?0:999)
                  d=Getmean(anoise[j][k])
                else if j==nhead then
                  count=(Getcount(hnoise[i][k])==0?0:999)
                  d=Getmean(hnoise[i][k])
                else
                  count=Getcount(stat[i][j][k])
                  d=Getxsigma(stat[i][j][k])
                endif
                if count<20 then
                  RFmt(RTF_TIMES,RTF_NORMAL,9)
                  RAddtext("???")
                else
                  value=Getvaluebyname(nm[k]+0)
                  RFmt(RTF_TIMES,(d<limit[k]?RTF_NORMAL:RTF_BOLD),9)
                  RAddfmt("%.2f",d/value*1000.0)
                endif
                if nn<nsel RAddtext("\n")
              enddo
            endif
          enddo
        enddo
        REndtable()
      enddo
    endif
    Startexplanation()
    Explain("Comments to the tables above: Script tests all possible ")
    Explain("combinations of measurement and reference heads (except for ")
    Explain("heads on the same rail). For each measurement, relative noise ")
    Explain("in promille (standard deviation, or else sigma, divided by ")
    Explain("expected value and multiplied by 1000) is displayed. Value is ")
    Explain("marked if it exceeds mean noise by %.0f or ",(factor-1.0)*100.0)
    Explain("more percent. Values exceeding 1.00 are highly suspicious.")
    Endexplanation()
    Oversurface()
    if txtok then
      fprintf(hlog,"\n\n--------------------------------------------------")
      fprintf(hlog,"---------------------------\n-------------------------")
      fprintf(hlog,"----------------------------------------------------\n")
    endif
    return 0                           // Noise test successfully finished
  endif
  change hlist color=LIGHTRED
  add hlist text="Noise test interrupted!"
  Startexplanation()
  Explain("ATTENTION, calibration procedure detected critical error ")
  if err==1 then
    Explain("(command execution error) ")
  else if err==2 then
    Explain("(timeout) ")
  else if err==3 then
    Explain("(unexpected answer) ")
  endif
  Explain("and was unable to finish noise test.")
  Endexplanation()
  if txtok then
    fprintf(hlog,"\n\n--------------------------------------------------")
    fprintf(hlog,"---------------------------\n-------------------------")
    fprintf(hlog,"----------------------------------------------------\n")
  endif
  clear hright
  change hinfo text="Noise test error"
  change hinfo limits=0,0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=LIGHTRED
  if err==1 then
    draw text="???DD?!"
    draw at 6,60 color=BLACK
    draw text="Ollytest was unable to send command to the tester. Probably "
    draw text="there is some bug in the software. Please report it to atg. "
  else if err==2 then
    draw text="Timeout!"
    draw at 6,60 color=BLACK
    draw text="There is no answer from tester within expected timeout. "
  else if err==3 then
    draw text="Unexpected answer!"
    draw at 6,60 color=BLACK
    draw text="Answer received from crate is not a valid measurement. "
  endif
  draw text="Noise test interrupted."
  draw show
  hcont=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1
    if Pressed(hcont) return 1
    wait
  enddo
end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// MANUAL NOISE TEST ///////////////////////////////

#define NFACTOR        6               // Number of frequency & voltage factors
#define NHIST          151             // Numver od points in histogram

char mnbase[260] =                   \ // Basic state, zero voltages
  "00F6FF460080000000000000000000000000000008000000111111111111111100800000"   \
  "FF00000000000000000000000000000000000000B6020000122013000000000003000000"   \
  "D2C1863F0000000000000000000000000800000002003011000000000000000011111111"   \
  "1111111100080008000000000008000800000000"
char mnresist[260] =                 \ // High-ohmic resistance measurement
  "00F8FF4600800000000000000000000000000F00A84203B2111111111111111100800000"   \
  "4F170000650600006C0600001801000000030000B6020000122013000000000000000000"   \
  "000000000000000000000000000000000800000002003013000000000000000011111111"   \
  "1111111100080008000000000008000800000000"
char mnfastc[260] =                  \ // Capacity measurement (AC)
  "0033004700800000000000000000000000000F00288200F8222222222222222200800000"   \
  "F117000000000000000000007003000000030000B6020000122013000000000003000000"   \
  "7D91A5400000000000000000000000000800000002003013000000000000000022222222"   \
  "2222222200080008000000000008000800000000"
char mnchargelo[260] =               \ // Capacity (charge-discharge), low I
  "00671A4700800000000000000000000000000D00099006F4222222222222222200800000"   \
  "10140000C20D0000C20D00007003000000030000B6020000122013000000000000000000"   \
  "05F0473F0000000000000000000000000800000002003013000000000000000022222222"   \
  "2222222200080008000000000008000800000000"
char mnchargehi[260] =               \ // Capacity (charge-discharge), high I
  "00671A4700800000000000000000000000000D000A9006F4222222222222222200800000"   \
  "10140000C20D0000C20D00007003000000030000B6020000122013000000000000000000"   \
  "05F0473F0000000000000000000000000800000002003013000000000000000022222222"   \
  "2222222200080008000000000008000800000000"
char mnfield[260] =                  \ // Field measurement
  "00FCFF4600800000000000000000000000000F00289002F8111111111111111100800000"   \
  "F114000000000000000000007003000000030000B6020000122013000000000000000000"   \
  "B647BD3F0000000000000000000000000800000002003013000000000000000011111111"   \
  "1111111100080008000000000008000800000000"
char mninduct[260] =                 \ // Inductance measurement
  "00F6FF4600800000000000000000000000000F00881500F0111111111111111100800000"   \
  "211400000000000000000000D707000000080000B6020000122013000000000000000000"   \
  "000000000000000000000000000000000800000002003013000000000000000011111111"   \
  "1111111100080008000000000008000800000000"

// Service function, sets complete state of the measurement card. Uses command
// buffer 0 to send data. Returns 0 on success and -1 on error.
function int Setmeascardstate(char *s)
  int i,u
  char c1,c2,buf[256]
  buf[0]=S_DEBUG
  buf[1]=0x17                          // Set state of A5 measurement card
  buf[2]=0                             // Measurement card, currently master
  for i=0,i<128,i++ do
    c1=s[i*2]; c2=s[i*2+1]
    if c1>='0' && c1<='9' then
      u=(c1-'0')*16
    else if c1>='A' && c1<='F' then
      u=(c1-'A'+10)*16
    else if c1>='a' && c1<='f' then
      u=(c1-'a'+10)*16
    else
      return -1                        // Not a hex digit
    endif
    if c2>='0' && c2<='9' then
      u=u+c2-'0'
    else if c2>='A' && c2<='F' then
      u=u+c2-'A'+10
    else if c2>='a' && c2<='f' then
      u=u+c2-'a'+10
    else
      return -1                        // Not a hex digit
    endif
    buf[i+3]=u
  enddo
  SYS.Sendimm(0,131,buf);
end

// Manual and automatical noise measurements with the option to turn motor
// drivers on and off. Works only with the A5 measurement card!
function int Manualnoise()
  char measstd[11][48] = {                                                     \
\//  Pad1  Pad2  Set Rly1 Rly2 Name
    "GND1  R10M  HIR 0014 0011 Resistance (10 M)",                             \
    "GND1  R100M HIR 0014 0011 Resistance (100 M)",                            \
    "GND1  C220N RNC 0014 0011 R||C (100 M,220 nF)",                           \
    "GND1  C2U2  RNC 0014 0011 R||C (100 M,2.2 uF)",                           \
    "GND1  C2N7  CAC 0304 0311 Capacity AC (2.7 nF)",                          \
    "GND1  C220N CHL 0019 0016 Capacity (220 nF)",                             \
    "GND1  C2U2  CHH 0019 0016 Capacity (2.2 uF)",                             \
    "GND1  C27P  FLD 0024 0019 Field (35 pF)",                                 \
    "GND1  GND2  IND 0015 001A Inductance (short)",                            \
    "GND1  R294  IND 0015 001A Inductance (294 Ohm)",                          \
    "" }
  char meastri[11][48] = {                                                     \
    "GND1  R10M  HIR 0014 0011 Resistance (10 M)",                             \
    "GND1  R47M  HIR 0014 0011 Resistance (47 M)",                             \
    "GND1  C220N RNC 0014 0011 R||C (47 M,220 nF)",                            \
    "GND1  C2U2  RNC 0014 0011 R||C (47 M,2.2 uF)",                            \
    "GND1  C2N7  CAC 0304 0311 Capacity AC (2.7 nF)",                          \
    "GND1  C220N CHL 0019 0016 Capacity (220 nF)",                             \
    "GND1  C2U2  CHH 0019 0016 Capacity (2.2 uF)",                             \
    "GND1  C27P  FLD 0024 0019 Field (35 pF)",                                 \
    "GND1  GND2  IND 0015 001A Inductance (short)",                            \
    "GND1  R294  IND 0015 001A Inductance (294 Ohm)",                          \
    "" }
  float ffactor[NFACTOR] = {         \ // Frequency division factors
    0.5, 1, 2, 5, 10, 20 }
  float ufactor[NFACTOR] = {         \ // Amplitude multiplication factors
    0.0001, 0.0003, 0.0010, 0.0030, 0.0100, 0.0300 }
  int i,j,k,n,nhead,ntop,nbot,xs,x,y,dx,dy,update,sendstate,nbad,err
  int movestep,waitanswer,tdelay,tkeep,findex,uindex,hist[NHIST],loop
  int mindex,newmindex,head1,newhead1,head2,newhead2,mode,setbuttons
  int use3,newuse3,list[32],nlist,backlist[32]
  int state[32]                        // Bit 0: driver enabled, 1: disabled
  float x1,y1,x2,y2,x3,y3
  float r,f,v,fstep,imin[OSCCOUNT],fft[OSCCOUNT],imout[OSCCOUNT]
  float ss,fullnoise,lownoise,midnoise,highnoise,a[5],b[5],c[5]
  char s[256],buf[128],meas[11][48]
  handle hmode,hmeas,hhead1,hhead2,hmessage,hstart,hauto,hback
  handle hallon,hallenable,halloff,hx[32],hy[32],hz[32],he[32]
  handle hchild,hfplus,hfminus,huplus,huminus
  clear hright
  change hinfo limits=0,0
  change hinfo text="Manual noise test"
  nhead=$LAY.nfing*2
  if (romdata.features & BF_TYPE)==BF_TRIPOD then
    Memcpy(meas,meastri,Sizeof(meastri))
  else
    Memcpy(meas,measstd,Sizeof(measstd))
  endif
  err=0
  // Measurement selection buttons.
  mindex=5; newmindex=mindex
  use3=0; newuse3=use3                 // mindex=5 points to 2-head measurement
  findex=0
  uindex=1
  draw window=hright font=INFOFONT color=BLACK
  hmode=control BUTTON
    window=hright
    position=7,11,81,24
    help="2a???"
    font=MAINFONT
    color=BLACK
    bkcolor=LIGHTGRAY
  endc
  draw at 7,30 text="Measurement:"
  hmeas=control COMBOLIST
    window=hright
    position=92,11,163,350
    help="2a?D"
  endc
  for i=0,meas[i][0]!='\0',i++ do
    add hmeas text=meas[i]+26
    for j=0,j<26,j++ do
      if meas[i][j]==' ' meas[i][j]='\0'
    enddo
  enddo
  change hmeas select=mindex
  draw at 7,60 text="Head"
  hhead1=control COMBOLIST
    window=hright
    position=47,41,50,300
    help="?(???)2a?"
  endc
  draw at 103,60 text=", antenna(s)"
  hhead2=control COMBOLIST
    window=hright
    position=180,41,75,300
    help="?t(??)2a???? R||C,????1"
  endc
  hmessage=control TEXT
    window=hright
    position=10,72,RIGHTX-20,22
    help="2a??"
    mode=M_CENTERED
  endc
  nlist=0
  head1=-1
  head2=-1
  for i=0,i<nhead,i++ do
    if used[i]==0 then
      backlist[i]=-1
    else
      list[nlist]=i
      backlist[i]=nlist
      if head1<0 then
        head1=i; newhead1=head1
      else if head2<0 then
        head2=i; newhead2=head2
      endif
      nlist++
      sprintf(s,"%i%s",i/2,i & 1?"R":"L")
      add hhead1 text=s
      add hhead2 text=s
    endif
  enddo
  change hhead1 select=backlist[newhead1]
  change hhead2 select=backlist[newhead2]
  // Driver disable buttons.
  if $LAY.nfing<=4 then
    i=$LAY.nfing
  else
    for i=0,i<$LAY.nfing,i++ do
      if $LAY.side[i]!=0 break
    enddo
    if i==$LAY.nfing && i>5 then
      i=(i+1)/2                        // Single side, many heads
    endif
  endif
  ntop=i*2
  nbot=($LAY.nfing-i)*2
  n=Max(ntop,nbot)
  dx=Min(20,(RIGHTX-10)/n-4)           // Width of Disable buttons
  dy=(nbot==0?dx:17)
  hallon=control BUTTON
    window=hright
    position=RIGHTX/2-100,(nbot==0?137:103),60,17
    text="??a"
    help="????D???y????3?"
    font=SMALLFONT
  endc
  hallenable=control BUTTON
    window=hright
    position=RIGHTX/2-30,(nbot==0?137:103),60,17
    text="All enable"
    help="????D?3??????D????a?"
    font=SMALLFONT
  endc
  halloff=control BUTTON
    window=hright
    position=RIGHTX/2+40,(nbot==0?137:103),60,17
    text="?1?"
    help="????D???y????3?(2a?3ya)"
    font=SMALLFONT
  endc
  for i=0,i<nhead,i++ do
    if i<ntop then
      xs=(RIGHTX-dx*ntop-3*(ntop-1)-6*(ntop/2-1))/2
      x=xs+(dx+3)*i+6*(i/2)
      y=(nbot==0?175:140)
    else
      xs=(RIGHTX-dx*nbot-3*(nbot-1)-6*(nbot/2-1))/2
      x=xs+(dx+3)*(i-ntop)+6*((i-ntop)/2)
      y=230
    endif
    if (i & 1)==0 then
      draw color=BLACK font=SMALLFONT
      draw mode=M_LEFT at x+3,y-2 text="L"
      draw mode=M_RIGHT at x+2*dx,y-2 text="R"
      draw color=LIGHTRED mode=M_CENTERED font=MAINFONT
      draw at x+dx+1,y-2 text=format("%i",i/2)
    endif
    hx[i]=control BUTTON
      window=hright
      position=x,y,dx,dy
      help=format("??????????2a?%i%s?X?",           \
        i/2,i & 1?"R":"L")
      text="X"
      font=SMALLFONT
    endc
    hy[i]=control BUTTON
      window=hright
      position=x,y+dy,dx,dy
      help=format("??????????2a?%i%s?Y?",           \
        i/2,i & 1?"R":"L")
      text="Y"
      font=SMALLFONT
    endc
    hz[i]=control BUTTON
      window=hright
      position=x,y+2*dy,dx,dy
      help=format("??????????2a?%i%s?Z?",           \
        i/2,i & 1?"R":"L")
      text="Z"
      font=SMALLFONT
    endc
    he[i]=control BUTTON
      window=hright
      position=x,y+3*dy,dx,dy
      help=format("??????????2a?%i%s??y?3D",         \
        i/2,i & 1?"R":"L")
      text="E"
      font=SMALLFONT
    endc
    state[i]=0x00
  enddo
  draw show
  // Control buttons.
  hstart=control BUTTON
    window=hright
    position=5,RIGHTY-29,RIGHTX/3-5,24
    name="?a?"
    help="1?D????a?2a?"
  endc
  hauto=control BUTTON
    window=hright
    position=5+RIGHTX/3,RIGHTY-29,RIGHTX/3-5,24
    name="??"
    help="?a???2a?"
  endc
  hback=control BUTTON
    window=hright
    position=5+2*(RIGHTX/3),RIGHTY-29,RIGHTX/3-9,24
    name="??"
    help="??????2?"
  endc
  // Replace left window with the graph.
  change hleft position=-1000,*,*,*
  hchild=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help=" "
    bkcolor=WHITE
  endc
  hfplus=NULL
  // Execution loop.
  update=1
  sendstate=0xFFFFFFFF
  movestep=0; waitanswer=0
  mode=1; setbuttons=1
  Memset(imin,0,Sizeof(imin))
  SYS.Killimm(0)
  while 1 do
    // Set mode.
    if setbuttons then
      if mode==0 then
        // Simulated measurements (connections identical to measurement).
        change hmode text="Simulate"
      else
        // Standard measurements.
        change hmode text="2a?"
      endif
      clear hchild
      hfplus=NULL; hfminus=NULL; huplus=NULL; huminus=NULL
      draw window=hchild clear mode=M_CENTERED font=LARGEFONT color=LIGHTRED
      draw at LEFTX/2,65 text="Attention!"
      draw mode=M_LEFT font=TIMESFONT color=BLACK
      draw at 12,100 wrap=LEFTX-5
      draw text="This test allows you to turn off and on the motor drivers. "
      draw text="The software takes care of the situation. Still, it may "
      draw text="happen that heads collide or needles will be damaged! If "
      draw text="test is finished but heads are still unpowered, make soft "
      draw text="reset!"
      if mode==0 then
        draw text="\n\nMeasurement oscilloscope running in parallel to this "
        draw text="test may spoil the measurements. Please close it.\n\n"
        draw text="If and only if you are blessed by the atg development "
        draw text="team, you may use "font=INFOFONT text="a5meas.scr "
        draw font=TIMESFONT text="(A5Card) in parallel for better "
        draw text="troubleshooting."
      endif
      draw show
      setbuttons=0
    endif
    // Process buttons.
    if Pressed(hmode) then
      mode=!mode
      movestep=0
      waitanswer=0
      SYS.Killimm(0)
      setbuttons=1
    else if Pressed(hmeas) then
      newmindex=Status(hmeas)
      if Memcmp(meas[newmindex]+12,"RNC",3)==0 then
        newuse3=1
        if $LAY.nfing==0 disable hstart
        change hmessage text="Note: R||C uses 3 heads"
        clear hhead2
        for i=0,i<nhead,i++ do
          if used[i]==0 continue
          sprintf(s,"%i%s+%i%s",i/2,i & 1?"R":"L",i/2,i & 1?"L":"R")
          add hhead2 text=s
        enddo
        change hhead2 select=backlist[newhead2]
      else
        newuse3=0
        enable hstart
        change hmessage text=""
        clear hhead2
        for i=0,i<nhead,i++ do
          if used[i]==0 continue
          sprintf(s,"%i%s",i/2,i & 1?"R":"L")
          add hhead2 text=s
        enddo
        change hhead2 select=backlist[newhead2]
      endif
      newhead1=list[Status(hhead1)]
      newhead2=list[Status(hhead2)]
      if newuse3==0 && newhead1==newhead2 then
        newhead2=newhead1^1
        change hhead2 select=backlist[newhead2]
      else if newuse3!=0 && (newhead1 & 0xFE)==(newhead2 & 0xFE) then
        if newhead1>=2 then
          newhead2=newhead2-2
        else
          newhead2=newhead2+2
        endif
        change hhead2 select=backlist[newhead2]
      endif
    else if Pressed(hhead1) then
      newhead1=list[Status(hhead1)]
      if newuse3==0 && newhead1==newhead2 then
        newhead2=newhead1^1
        change hhead2 select=backlist[newhead2]
      else if newuse3!=0 && (newhead1 & 0xFE)==(newhead2 & 0xFE) then
        if newhead1>=2 then
          newhead2=newhead2-2
        else
          newhead2=newhead2+2
        endif
        change hhead2 select=backlist[newhead2]
      endif
    else if Pressed(hhead2) then
      newhead2=list[Status(hhead2)]
      if newuse3==0 && newhead2==newhead1 then
        newhead1=newhead2^1
        change hhead1 select=backlist[newhead1]
      else if newuse3!=0 && (newhead2 & 0xFE)==(newhead1 & 0xFE) then
        if newhead2>=2 then
          newhead1=newhead1-2
        else
          newhead1=newhead1+2
        endif
        change hhead1 select=backlist[newhead1]
      endif
    else if Pressed(hallon) then
      for i=0,i<nhead,i++ do state[i]=0x00; enddo
      update=1
      sendstate=0xFFFFFFFF
    else if Pressed(hallenable) then
      for i=0,i<nhead,i++ do state[i]=0x07; enddo
      update=1
      sendstate=0xFFFFFFFF
    else if Pressed(halloff) then
      for i=0,i<nhead,i++ do state[i]=0x0F; enddo
      update=1
      sendstate=0xFFFFFFFF
    else if hfminus!=NULL && Pressed(hfminus) && findex<NFACTOR-1 then
      findex++
    else if hfplus!=NULL && Pressed(hfplus) && findex>0 then
      findex--
    else if huplus!=NULL && Pressed(huplus) && uindex<NFACTOR-1 then
      uindex++
    else if huminus!=NULL && Pressed(huminus) && uindex>0 then
      uindex--
    else if Pressed(hstart) then
      change hmessage text=""
      if nused>2 || newuse3==0 movestep=1
    else if Pressed(hback) then
      err=0
      break
    else if Pressed(hexit) then
      err=-1
      break
    endif
    for i=0,i<nhead,i++ do
      if Pressed(hx[i]) then
        state[i]=state[i]^0x1; update=1; sendstate=1<<i
      else if Pressed(hy[i]) then
        state[i]=state[i]^0x2; update=1; sendstate=1<<i
      else if Pressed(hz[i]) then
        state[i]=state[i]^0x4; update=1; sendstate=1<<i
      else if Pressed(he[i]) then
        state[i]=state[i]^0x8; update=1; sendstate=1<<i
      endif
    enddo
    // Update state of the buttons.
    if update then
      for i=0,i<nhead,i++ do
        if i==head1 || ((use3==0 && i==head2) ||                               \
          (use3!=0 && (i & 0xFE)==(head2 & 0xFE)))                             \
        then
          disable hx[i]; change hx[i] bkcolor=LIGHTGRAY
          disable hy[i]; change hy[i] bkcolor=LIGHTGRAY
          disable hz[i]; change hz[i] bkcolor=LIGHTGRAY
          disable he[i]; change he[i] bkcolor=LIGHTGRAY
        else
          enable hx[i]
          change hx[i] bkcolor=(state[i] & 0x09?LIGHTRED:LIGHTGREEN)
          enable hy[i]
          change hy[i] bkcolor=(state[i] & 0x0A?LIGHTRED:LIGHTGREEN)
          enable hz[i]
          change hz[i] bkcolor=(state[i] & 0x0C?LIGHTRED:LIGHTGREEN)
          enable he[i]
          change he[i] bkcolor=(state[i] & 0x08?LIGHTRED:LIGHTGREEN)
        endif
      enddo
      update=0
    endif
    // Enable or disable motor drivers.
    if sendstate then
      for i=0,i<nhead,i++ do
        if (sendstate & (1<<i))==0 continue
        if i==head1 || ((use3==0 && i==head2) ||                               \
          (use3!=0 && (i & 0xFE)==(head2 & 0xFE)))                             \
        then
          j=0                          // Measurement heads must be enabled
        else
          j=state[i]
        endif
        sprintf(s,"OUTPORT32 HEAD(%i) 0x8000000A,%i",i,j)
        SERV.Cmdimm(32,s)
      enddo
      sendstate=0
    endif
    // Execute measurement sequence. Set movetep to 1 to start measurement.
    if mode==0 then
      // Simulation.
      if waitanswer then
        // As yet no answer from the tester, wait longer.
        if $A[0].length!=0 then
          waitanswer=0
          if $A[0].answer==S_ERROR then
            change hmessage text="Unable to execute command"
            change hmessage color=LIGHTRED
            movestep=0
          endif
        endif
      else if movestep==1 then
        // Remove voltage and disconnect relays.
        if Setmeascardstate(mnbase)!=0 then
          change hmessage text="Internal error: bad data"
          change hmessage color=LIGHTRED
          movestep=0
        else
          movestep=2
        endif
      else if movestep==2 then
        // If heads are changed, enable all heads and move them into the home
        // position.
        if (newhead1!=head1 && newhead1!=head2) ||                             \
          (newhead2!=head1 && newhead2!=head2) then
          SERV.Cmdimm(32,"OUTPORT32 HEAD(ALL) 0x8000000A,0")
          n=sprintf(s,"M ")
          for i=0,i<nhead,i++ do
            if used[i]==0 continue
            n=n+sprintf(s+n,"%i(Z) ",i)
          enddo
          n=n+sprintf(s+n,"NOP")
          SERV.Cmdimm(0,s)
        endif
        movestep=3
      else if movestep==3 then
        // Select new coordinates for the heads and move into the points.
        mindex=newmindex
        head1=newhead1
        head2=newhead2
        use3=newuse3
        Convertpad(&x1,&y1,meas[mindex]+0,head1,DELTA)
        if use3==0 then
          Convertpad(&x2,&y2,meas[mindex]+6,head2,DELTA)
        else
          if (romdata.features & BF_TYPE)==BF_TRIPOD then
            Convertpad(&x2,&y2,"R47M",head2 & 0xFE,DELTA)
          else
            Convertpad(&x2,&y2,"R100M",head2 & 0xFE,DELTA)
          endif
          Convertpad(&x3,&y3,meas[mindex]+6,head2 | 0x01,DELTA)
        endif
        // If heads are on the same rail, check if we need to swap them. Not
        // necessary for 3-head measurement.
        if use3==0 && ((head1^head2) & 0xFE)==0 &&                             \
          ((head1<head2 && x1>x2) || (head1>head2 && x1<x2))                   \
        then
          head1=newhead2
          head2=newhead1
          newhead1=head1
          newhead2=head2
          change hhead1 select=backlist[newhead1]
          change hhead2 select=backlist[newhead2]
          Convertpad(&x1,&y1,meas[mindex]+0,head1,DELTA)
          Convertpad(&x2,&y2,meas[mindex]+6,head2,DELTA)
          change hmessage text="Heads were swapped"
          change hmessage color=BLACK
        endif
        n=sprintf(s,"M %i[%g,%gA5V%iP%iH%f] %i[%g,%gA5V%iP%iH%f] ",            \
          head1,x1,y1,strokev,strokep,strokez,                                 \
          (use3?head2 & 0xFE:head2),x2,y2,strokev,strokep,strokez)
        if use3 n=n+sprintf(s+n,"%i[%g,%gA5V%iP%iH%f] ",                       \
          head2 | 0x01,x3,y3,strokev,strokep,strokez)
        sprintf(s+n,"DLY(5)")
        SERV.Cmdimm(0,s)
        update=1
        movestep=4
      else if movestep==4 then
        // Set enable status for remaining motor drivers and set connections on
        // the measurement card.
        sendstate=0xFFFFFFFF
        if Memcmp(meas[mindex]+12,"HIR",3)==0 then
          i=Setmeascardstate(mnresist)
        else if Memcmp(meas[mindex]+12,"RNC",3)==0 then
          i=Setmeascardstate(mnresist)
        else if Memcmp(meas[mindex]+12,"CAC",3)==0 then
          i=Setmeascardstate(mnfastc)
        else if Memcmp(meas[mindex]+12,"CHL",3)==0 then
          i=Setmeascardstate(mnchargelo)
        else if Memcmp(meas[mindex]+12,"CHH",3)==0 then
          i=Setmeascardstate(mnchargehi)
        else if Memcmp(meas[mindex]+12,"FLD",3)==0 then
          i=Setmeascardstate(mnfield)
        else if Memcmp(meas[mindex]+12,"IND",3)==0 then
          i=Setmeascardstate(mninduct)
        else
          i=-1
        endif
        if i!=0 then
          change hmessage text="Internal error: bad data"
          change hmessage color=LIGHTRED
          movestep=0
        else
          movestep=5
          tkeep=Time()
        endif
      else if movestep==5 then
        // Connect heads to analog bus.
        sscanf(meas[mindex]+16,"%04X",&i)
        sscanf(meas[mindex]+21,"%04X",&j)
        buf[0]=S_DEBUG
        buf[1]=0x4E                    // Set state of on-head boards
        buf[2]=0                       // Measurement card, currently master
        $int4(buf+3)=(i & 0x0000FFFF) | (head1<<24)
        if use3==0 then
          $int4(buf+7)=(j & 0x0000FFFF) | (head2<<24)
          SYS.Sendimm(0,11,buf)
        else
          $int4(buf+7)=(j & 0x0000FFFF) | ((head2 & 0xFE)<<24)
          $int4(buf+11)=(j & 0x0000FFFF) | ((head2 | 0x01)<<24)
          SYS.Sendimm(0,15,buf)
        endif
        movestep=6
        tdelay=Time()
      else if movestep==6 then
        // Wait 100 ms to stabilize measurements.
        if Time()-tdelay>=100 then
          movestep=7
        endif
      else if movestep==7 then
        // Trigger new oscillogramm.
        oscactive=1
        nosc=0
        buf[0]=S_TEST
        buf[1]=0x03                    // Setup A5 oscilloscope
        buf[2]=0x80                    // Master measurement card
        buf[3]=1                       // Trigger immediately
        if ffactor[findex]<0.26 then
          $uint2(buf+4)=1              // Compression
          osccount=OSCCOUNT/4
        else if ffactor[findex]<0.51 then
          $uint2(buf+4)=1
          osccount=OSCCOUNT/2
        else
          $uint2(buf+4)=ffactor[findex]+0.01
          osccount=OSCCOUNT
        endif
        $uint2(buf+6)=osccount         // Length of protocol
        buf[8]=0                       // Channels (ignored by measurement card)
        buf[9]=0
        buf[10]=0
        buf[11]=0
        SYS.Sendimm(32,12,buf)
        // Once in two seconds I read actual state of the measurement card. The
        // data is discarded, the command is here to keep fingers in contact
        // with the Olliboard.
        if Time()-tkeep>=2000 then
          buf[0]=S_DEBUG
          buf[1]=0x18                  // Get state of A5 measurement card
          buf[2]=0                     // Measurement card, currently master
          SYS.Sendimm(32,3,buf)
          tkeep=Time()
        endif
        movestep=8
        tdelay=Time()
      else if movestep==8 then
        // Wait for the oscillogramm and process data.
        if oscactive<=0 || Time()-tdelay>=500 then
          change hmessage text="Oscillogramm is lost!"
          change hmessage color=LIGHTRED
          movestep=7                   // Oscillogramm is lost, retry
        else if oscactive==2 then
          change hmessage text="Test is running"
          change hmessage color=BLACK
          oscactive=0
          draw window=hchild bkcolor=WHITE clear
          x=10; dx=Min(OSCCOUNT/2,LEFTX-20)
          y=LEFTY/2-20; dy=y-20
          // If as yet no frequency and amplification buttons, create them.
          if hfplus==NULL then
            hfplus=control BUTTON
              window=hchild
              position=20,y+20,45,18
              name="F+"
              help="???????????"
              font=FIXEDSYS
              bkcolor=LIGHTGRAY
            endc
            hfminus=control BUTTON
              window=hchild
              position=70,y+20,45,18
              name="F-"
              help="1?????????-"
              font=FIXEDSYS
              bkcolor=LIGHTGRAY
            endc
            huminus=control BUTTON
              window=hchild
              position=210,y+20,45,18
              name="U-"
              help="???"
              font=FIXEDSYS
              bkcolor=LIGHTGRAY
            endc
            huplus=control BUTTON
              window=hchild
              position=260,y+20,45,18
              name="U+"
              help="????y"
              font=FIXEDSYS
              bkcolor=LIGHTGRAY
            endc
          endif
          // Calculate frequency step between the points of Fourier transform.
          // Note that I make 2x subsampling when displaying data, so the
          // screen step is twice as large!
          fstep=1000000.0/ffactor[findex]/OSCCOUNT
          v=2.0*fstep*35.0             // Min. distance between ticks 35 pixel
          f=1.0; while v>=10.0 do v=v/10.0; f=f*10.0; enddo
          if v>5.0 then
            v=10.0
          else if v>2.0 then
            v=5.0
          else if v>1.0 then
            v=2.0
          else
            v=1.0
          endif
          v=v*f                        // Distance between ticks in Herz
          draw color=DARKGRAY at x-1,y-dy to x-1,y to x+dx,y
          draw font=SMALLFONT mode=M_CENTERED
          for f=0.0,f/(2.0*fstep)<dx,f=f+v do
            xs=f/(2.0*fstep)
            draw at x+xs,y to x+xs,y+5
            draw at x+xs,y+18
            if 2.0*fstep*dx>5000.0 then
              draw text=format("%gk",f/1000.0)
            else
              draw text=format("%g",f)
            endif
          enddo
          // Subtract mean signal level and calculate histogram and noise.
          r=0.0; ss=0.0
          for i=0,i<osccount,i++ do
            r=r+osc[i]
          enddo
          r=r/osccount
          Memset(hist,0,Sizeof(hist))
          // Histogramm: currently 4 ADC bits per pixel.
          for i=0,i<osccount,i++ do
            osc[i]=osc[i]-r
            j=Floor(osc[i]*0.25-0.5)+NHIST/2
            if j>=0 && j<NHIST hist[j]++
            ss=ss+osc[i]*osc[i]
          enddo
          fullnoise=Sqrt(ss/(osccount-1.0))
          // Make Fourier transformation and calculate noise in different
          // frequency bands.
          SYS.Fft(osccount,osc,imin,fft,imout)
          // Phase of the signal is not interesting, only the amplitude.
          for i=0,i<osccount,i++ do
            fft[i]=Sqrt(fft[i]*fft[i]+imout[i]*imout[i])
          enddo
          // Low noise (1..40 kHz).
          j=Min(1000/fstep,osccount); k=Min(40000/fstep,osccount)
          ss=0.0
          for i=j,i<k,i++ do
            ss=ss+fft[i]
          enddo
          lownoise=ss*0.001
          // Middle noise (40..100 kHz).
          j=Min(40000/fstep,osccount); k=Min(100000/fstep,osccount)
          ss=0.0
          for i=j,i<k,i++ do
            ss=ss+fft[i]
          enddo
          midnoise=ss*0.001
          // High noise (above 100 kHz).
          j=Min(100000/fstep,osccount); k=osccount
          ss=0.0
          for i=j,i<k,i++ do
            ss=ss+fft[i]
          enddo
          highnoise=ss*0.001
          // Draw FFT.
          if ffactor[findex]<0.26 then
            f=4.0*ufactor[uindex]; k=4
          else if ffactor[findex]<0.51 then
            f=2.0*ufactor[uindex]; k=2
          else
            f=1.0*ufactor[uindex]; k=1
          endif
          lownoise=lownoise*k
          midnoise=midnoise*k
          highnoise=highnoise*k
          draw color=BLACK
          for i=0,i<dx && i<osccount,i++ do
            r=(fft[i*2]+fft[i*2+1])*f
            if i==0 then
              draw at x+i,y-r
            else
              draw to x+i,y-r
            endif
          enddo
          // Draw histogram.
          x=10
          y=LEFTY-28; dy=LEFTY/2-50
          draw color=DARKGRAY
          draw at x,y to x+NHIST,y to x+NHIST,y-dy to x,y-dy to x,y
          draw at x+NHIST/2,y-dy to x+NHIST/2,y
          draw color=BLACK
          for i=0,i<NHIST,i++ do
            draw at x+i,y-Min(hist[i]*k,dy) to x+i,y
          enddo
          // Display noise.
          x=x+NHIST+10
          y=y-dy+20
          draw mode=M_LEFT font=INFOFONT color=BLACK wrap=0
          draw at x,y text="Mean noise, bits:"
          draw mode=M_RIGHT font=MEDIUMFONT at LEFTX-15,y+18
          draw text=format("%.1f",fullnoise)
          draw mode=M_LEFT font=INFOFONT
          draw at x,y+35 text="Noise 1..40 kHz, a.u.:"
          draw mode=M_RIGHT font=MEDIUMFONT at LEFTX-15,y+53
          draw text=format("%.1f",lownoise)
          draw mode=M_LEFT font=INFOFONT
          draw at x,y+70 text="Noise 40..100 kHz:"
          draw mode=M_RIGHT font=MEDIUMFONT at LEFTX-15,y+88
          draw text=format("%.1f",midnoise)
          draw mode=M_LEFT font=INFOFONT
          draw at x,y+105 text="Noise above 100 kHz:"
          draw mode=M_RIGHT font=MEDIUMFONT at LEFTX-15,y+123
          draw text=format("%.1f",highnoise)
          draw show
          movestep=7
        endif
      endif
    else
      // Real measurements.
      if movestep==1 then
        // If heads are changed, enable all heads and move them into the home
        // position.
        if (newhead1!=head1 && newhead1!=head2) ||                             \
          (newhead2!=head1 && newhead2!=head2) then
          SERV.Cmdimm(32,"OUTPORT32 HEAD(ALL) 0x8000000A,0")
          n=sprintf(s,"M ")
          for i=0,i<nhead,i++ do
            if used[i]==0 continue
            n=n+sprintf(s+n,"%i(Z) ",i)
          enddo
          n=n+sprintf(s+n,"NOP")
          SERV.Cmdimm(32,s)
        endif
        movestep=2
      else if movestep==2 then
        // If heads are changed, enable all heads and move them into the home
        // position.
        if (newhead1!=head1 && newhead1!=head2) ||                             \
          (newhead2!=head1 && newhead2!=head2) then
          SERV.Cmdimm(32,"OUTPORT32 HEAD(ALL) 0x8000000A,0")
          n=sprintf(s,"M ")
          for i=0,i<nhead,i++ do
            if used[i]==0 continue
            n=n+sprintf(s+n,"%i(Z) ",i)
          enddo
          n=n+sprintf(s+n,"NOP")
          SERV.Cmdimm(0,s)
        endif
        movestep=3
      else if movestep==3 then
        // Select new coordinates for the heads and move into the points.
        mindex=newmindex
        head1=newhead1
        head2=newhead2
        use3=newuse3
        Convertpad(&x1,&y1,meas[mindex]+0,head1,DELTA)
        if use3==0 then
          Convertpad(&x2,&y2,meas[mindex]+6,head2,DELTA)
        else
          if (romdata.features & BF_TYPE)==BF_TRIPOD then
            Convertpad(&x2,&y2,"R47M",head2 & 0xFE,DELTA)
          else
            Convertpad(&x2,&y2,"R100M",head2 & 0xFE,DELTA)
          endif
          Convertpad(&x3,&y3,meas[mindex]+6,head2 | 0x01,DELTA)
        endif
        // If heads are on the same rail, check if we need to swap them. Not
        // necessary for 3-head measurement.
        if use3==0 && ((head1^head2) & 0xFE)==0 &&                             \
          ((head1<head2 && x1>x2) || (head1>head2 && x1<x2))                   \
        then
          head1=newhead2
          head2=newhead1
          newhead1=head1
          newhead2=head2
          change hhead1 select=backlist[newhead1]
          change hhead2 select=backlist[newhead2]
          Convertpad(&x1,&y1,meas[mindex]+0,head1,DELTA)
          Convertpad(&x2,&y2,meas[mindex]+6,head2,DELTA)
          change hmessage text="Heads were swapped"
          change hmessage color=BLACK
        endif
        n=sprintf(s,"M %i[%g,%gA5V%iP%iH%f] %i[%g,%gA5V%iP%iH%f] ",            \
          head1,x1,y1,strokev,strokep,strokez,                                 \
          (use3?head2 & 0xFE:head2),x2,y2,strokev,strokep,strokez)
        if use3 n=n+sprintf(s+n,"%i[%g,%gA5V%iP%iH%f] ",                       \
          head2 | 0x01,x3,y3,strokev,strokep,strokez)
        sprintf(s+n,"DLY(250)")
        SERV.Cmdimm(32,s)
        loop=0
        Initsigma(a)
        Initsigma(b)
        Initsigma(c)
        nbad=0
        update=1
        sendstate=0xFFFFFFFF
        movestep=4
      else if movestep==4 then
        // Send 32 measurement commands into the same coordinates.
        n=sprintf(s,"M %i[%g,%gA5V%iP%iH%f] %i[%g,%gA5V%iP%iH%f] ",            \
          head1,x1,y1,strokev,strokep,strokez,                                 \
          (use3?head2 & 0xFE:head2),x2,y2,strokev,strokep,strokez)
        if use3 n=n+sprintf(s+n,"%i[%g,%gA5V%iP%iH%f] ",                       \
          head2 | 0x01,x3,y3,strokev,strokep,strokez)
        i=0
        if Memcmp(meas[mindex]+12,"HIR",3)==0 then
          n=n+sprintf(s+n,"R(%i,%i)",head1,head2)
        else if Memcmp(meas[mindex]+12,"RNC",3)==0 then
          n=n+sprintf(s+n,"R(%i,%i,%i)",head1,head2 & 0xFE,head2 | 0x01)
        else if Memcmp(meas[mindex]+12,"CAC",3)==0 then
          n=n+sprintf(s+n,"A(%i,0N,%i)",head1,head2)
        else if Memcmp(meas[mindex]+12,"CHL",3)==0 then
          n=n+sprintf(s+n,"A(%i,5N,%i)",head1,head2)
        else if Memcmp(meas[mindex]+12,"CHH",3)==0 then
          n=n+sprintf(s+n,"A(%i,7N,%i)",head1,head2)
        else if Memcmp(meas[mindex]+12,"FLD",3)==0 then
          n=n+sprintf(s+n,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i)",                  \
          head1,head2,head2,head2,head2,head2,head2,head2,head2,head2)
        else if Memcmp(meas[mindex]+12,"IND",3)==0 then
          n=n+sprintf(s+n,"RL(%i,%i)",head1,head2)
        else
          i=-1
        endif
        if i!=0 then
          change hmessage text="Internal error: bad data"
          change hmessage color=LIGHTRED
          movestep=0
        else
          for i=0,i<32,i++ do
            SYS.Killimm(i)
            SERV.Cmdimm(i,s)
          enddo
          movestep=5
        endif
      else if movestep==5 then
        // Wait till all answers are back. 32 measurements may take time. There
        // is no timeout!
        for i=0,i<32,i++ do
          if $A[i].length==0 break
        enddo
        if i==32 movestep=6
      else if movestep==6 then
        // Process answers.
        draw window=hchild clear
        draw color=BLACK font=MEDIUMFONT mode=M_CENTERED
        draw at LEFTX/2,40 wrap=0 text=meas[mindex]+26
        loop++
        draw font=INFOFONT at LEFTX/2,80
        draw text=format("Loop %i of %i",loop,8)
        draw mode=M_LEFT font=MEDIUMFONT
        if Memcmp(meas[mindex]+12,"HIR",3)==0 ||                               \
          Memcmp(meas[mindex]+12,"RNC",3)==0                                   \
        then
          for i=0,i<32,i++ do
            r=$A[i].r; if ($A[i].status & 0x0100) r=r*1.0e-6
            Addsigma(a,r)
            if ($A[i].status & 0x8800) nbad++
          enddo
          draw at 20,130 text="R ="
          SERV.Ohmstotext(Getmean(a),0,s)
          draw at 50,130 text=s
          draw at 180,130 text="?"
          SERV.Ohmstotext(Getsigma(a),0,s)
          draw at 195,130 text=s
        else if Memcmp(meas[mindex]+12,"CAC",3)==0 then
          for i=0,i<32,i++ do
            SERV.Convertfastc($A[i],&r,&v);
            Addsigma(a,r)
            Addsigma(b,v)
            if ($A[i].status & 0x9800) nbad++
          enddo
          draw at 20,130 text="C ="
          SERV.Pftotext(Getmean(a),s)
          draw at 50,130 text=s
          draw at 180,130 text="?"
          SERV.Pftotext(Getsigma(a),s)
          draw at 195,130 text=s
          draw at 20,170 text="Z ="
          SERV.Pftotext(Getmean(b),s)
          draw at 50,170 text=s
          draw at 180,170 text="?"
          SERV.Pftotext(Getsigma(b),s)
          draw at 195,170 text=s
        else if Memcmp(meas[mindex]+12,"CHL",3)==0 ||                          \
          Memcmp(meas[mindex]+12,"CHH",3)==0                                   \
        then
          for i=0,i<32,i++ do
            SERV.Convertfastc($A[i],&r,&v);
            Addsigma(a,r)
            if ($A[i].status & 0x9800) nbad++
          enddo
          draw at 20,130 text="C ="
          SERV.Pftotext(Getmean(a),s)
          draw at 50,130 text=s
          draw at 180,130 text="?"
          SERV.Pftotext(Getsigma(a),s)
          draw at 195,130 text=s
        else if Memcmp(meas[mindex]+12,"FLD",3)==0 then
          for i=0,i<32,i++ do
            for j=0,j<8,j++ do
              Addsigma(a,$int2($A[i]+32+4*j))
              Addsigma(b,$int2($A[i]+34+4*j))
            enddo
            SERV.Convertfield($A[i],&r,&v)
            Addsigma(c,r)
            if ($A[i].status & 0x9800) nbad++
          enddo
          draw at 20,130 text="Sin ="
          draw at 70,130 text=format("%8.1f",Getmean(a))
          draw at 180,130 text="?"
          draw at 195,130 text=format("%5.1f bit",Getsigma(a))
          draw at 20,170 text="Cos ="
          draw at 70,170 text=format("%8.1f",Getmean(b))
          draw at 180,170 text="?"
          draw at 195,170 text=format("%5.1f bit",Getsigma(b))
          draw at 20,210 text="C ="
          SERV.Pftotext(Getmean(c),s)
          draw at 70,210 text=s
          draw at 180,210 text="?"
          SERV.Pftotext(Getsigma(c),s)
          draw at 195,210 text=s
        else if Memcmp(meas[mindex]+12,"IND",3)==0 then
          for i=0,i<32,i++ do
            v=$float4($A[i]+12)/1000.0
            Addsigma(a,v)
            r=$float4($A[i]+8); if ($A[i].status & 0x0100) r=r*1.0e-6
            Addsigma(b,r)
            if ($A[i].status & 0x8800) nbad++
          enddo
          draw at 20,130 text="L ="
          draw at 50,130 text=format("%6.3f uH",Getmean(a))
          draw at 180,130 text="?"
          draw at 195,130 text=format("%5.3f uH",Getsigma(a))
          draw at 20,170 text="R ="
          SERV.Ohmstotext(Getmean(b),0,s)
          draw at 50,170 text=s
          draw at 180,170 text="?"
          SERV.Ohmstotext(Getsigma(b),0,s)
          draw at 195,170 text=s
        endif
        draw at 20,250
        draw text=format("Bad measurements: %i out of %i",nbad,loop*32)
        draw show
        if loop>=8 then
          movestep=0
        else
          movestep=4
        endif
      endif
    endif
    wait
  enddo
finish:
  change hleft position=4,4,LEFTX,LEFTY
  destroy hchild
  SERV.Cmdimm(32,"OUTPORT32 HEAD(ALL) 0x8000000A,0")
  n=sprintf(s,"M ")
  for i=0,i<nhead,i++ do
    if used[i]==0 continue
    n=n+sprintf(s+n,"%i(Z) ",i)
  enddo
  n=n+sprintf(s+n,"NOP")
  SERV.Cmdimm(32,s)
  return err
end

// Attempts to clean needles by contacting the side effect pads. Don't ask me
// whether this will help. Parameter repeat, multplied by 50, is the number
// of contactings. Returns -1 if operator cancels script and 0 in all remaining
// cases.
function int Cleanneedles(int repeat)
  int rail,count[16],mincount,prevcount,pending[16],err
  float x,x0,x1,y
  char s[256]
  handle hinterrupt
  clear hright
  change hinfo limits=0,0
  change hinfo text="?????"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5 color=BLACK at 6,30
  draw text="?????1y???2a2?y1?????t3"
  draw text="???????a?"
  draw text="??"
  draw font=MAINFONT text="?D??" font=TIMESFONT text="?1???."
  hinterrupt=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?D??"
    help="????D???????"
  endc
  draw show
  change hlist color=BLACK
  add hlist text="                 NEEDLE CLEANING"
  repeat=Max(repeat,1)*50
  Memset(count,0,Sizeof(count))
  Memset(pending,0,Sizeof(pending))
  err=0
  prevcount=0
  while err==0 do
    if Pressed(hexit) return -1
    if Pressed(hinterrupt) break
    mincount=repeat
    for rail=0,rail<$LAY.nfing && err==0,rail++ do
      if used[2*rail]==0 continue
      if count[rail]>=repeat continue
      if pending[rail]==0 then
        // Calculate coordinates.
        Convertpad(&x,&y,"SIDEL",rail*2,0.0)
        if y<$LAY.yoffset[rail]/1000.0 then
          y=y+0.5+Random(2.0)
        else
          y=y-0.5-Random(2.0)
        endif
        x0=x+6.0+Random(5.0)
        x1=x0+8.0
        // Send command.
        if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||     \
          testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||       \
          testertype==TT_A7 || testertype==TT_A8                               \
        then
          sprintf(s,"M %i[%g,%gA255V100P70H1] %i[%g,%gA255V100P70H1] DLY(5)",  \
          rail*2+0,x0,y,rail*2+1,x1,y)
        else
          sprintf(s,"M %i[%g,%gA255V100P70H1] %i[%g,%gA255V100P70H1] R(%i,%i)",\
          rail*2+0,x0,y,rail*2+1,x1,y,rail*2+0,rail*2+1)
        endif
        SERV.Cmdimm(rail,s)
        pending[rail]=1
      else if $A[rail].length>0 then
        count[rail]++
        pending[rail]=0
      endif
      mincount=Min(mincount,count[rail])
    enddo
    if mincount==repeat break          // Cleaning finished
    if mincount>prevcount+5 then
      change hinfo limits=mincount,repeat
      prevcount=mincount
    endif
    wait
  enddo
  if err==0 return 0
end

int    oldprothead                     // Old protocol head

// Service function, writes layout value to all possible protocols.
function int Lprot(int log,int head,char *s,int fmt,char *units,float u,int def)
  int border
  char headtext[32],val[32]
  if head!=oldprothead then
    if head<0 then
      Strcpy(headtext,"Meas card")
    else
      sprintf(headtext,"Head %i%c",head/2,head & 1?'R':'L')
    endif
    if log!=0 then
      change hlist color=LIGHTRED
      add hlist text=""
      add hlist text=headtext
      change hlist color=BLACK
    endif
    if txtok!=0 then
      fprintf(hlog,"\n")
    endif
    if rtfok!=0 then
      REndtable()
    endif
    oldprothead=head
  else
    Strcpy(headtext,"         ")
  endif
  if def!=0 && u==0.0 then
    Strcpy(val,"Default")
  else if fmt==0 then
    sprintf(val,"%.0f",u)
  else if fmt==1 then
    sprintf(val,"%.1f",u)
  else if fmt==2 then
    sprintf(val,"%.2f",u)
  else if fmt==3 then
    sprintf(val,"%.3f",u)
  else if fmt==4 then
    sprintf(val,"%.4f",u)
  else if fmt==5 then
    sprintf(val,"%.5f",u)
  else
    sprintf(val,"%g",u)
  endif
  if log!=0 then
    add hlist text=format("%-30.30s %10.10s  %s",s,val,units)
  endif
  if txtok!=0 then
    fprintf(hlog," %-10.10s  %-35.35s %10.10s      %s\n",                      \
    headtext,s,val,units)
  endif
  if rtfok!=0 then
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
    RCell(RTF_LEFT|RTF_THINBRD,26.0); RAddtext(headtext)
    RCell(RTF_LEFT|RTF_THINBRD,78.0); RAddtext(s)
    RCell(RTF_LEFT|RTF_THINBRD,33.0); RAddtext(val)
    RCell(RTF_LEFT|RTF_THINBRD,22.0); RAddtext(units)
  endif
end

// Protocols measurement parameters from layout to the log files. If ls
// is not zero, protocols also to screen.
function int Protocolmeasparms(int ls)
  int i
  if ls!=0 then
    // Header of on-screen protocol.
    change hlist color=RED
    add hlist text="              MEASUREMENT PARAMETERS"
  endif
  if txtok!=0 then
    // Header of .TXT protocol.
    fprintf(hlog,"\n                        Parameters of measurement card\n\n")
    fprintf(hlog," Card        Parameter                                Value")
    fprintf(hlog,"      Units\n")
  endif
  if rtfok!=0 then
    // Header of .RTF protocol.
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    RAddtext("\nParameters of measurement card")
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,4.5)
    RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("Card")
    RCell(RTF_CENTERED|RTF_THINBRD,78.0); RAddtext("Parameter")
    RCell(RTF_CENTERED|RTF_THINBRD,33.0); RAddtext("Value")
    RCell(RTF_CENTERED|RTF_THINBRD,22.0); RAddtext("Units")
  endif
  Lprot(ls,-1,"DC current 100 mA",4,"mA",$LAY.i100ma/1.0e6,0)
  Lprot(ls,-1,"DC current 30 mA",4,"mA",$LAY.i30ma/1.0e6,0)
  Lprot(ls,-1,"DC current 10 mA",4,"mA",$LAY.i10ma/1.0e6,0)
  Lprot(ls,-1,"DC current 3 mA",4,"mA",$LAY.i3ma/1.0e6,0)
  Lprot(ls,-1,"DC current 1 mA",4,"mA",$LAY.i1ma/1.0e6,0)
  Lprot(ls,-1,"DC current 300 uA",4,"uA",$LAY.i300ua/1000.0,0)
  Lprot(ls,-1,"DC current 100 uA",4,"uA",$LAY.i100ua/1000.0,0)
  Lprot(ls,-1,"DC current 30 uA",4,"uA",$LAY.i30ua/1000.0,0)
  Lprot(ls,-1,"DC current 10 uA",4,"uA",$LAY.i10ua/1000.0,0)
  Lprot(ls,-1,"DC voltage 9 V",4,"V",$LAY.dc9v/1.0e6,0)
  Lprot(ls,-1,"DC voltage 0.9 V",4,"V",$LAY.dc0v9/1.0e6,0)
  Lprot(ls,-1,"I-U convertor resistor",4,"kOhm",$LAY.r100k/1000.0,0)
  Lprot(ls,-1,"Shortcut resistance",3,"Ohm",$LAY.rzero/1.0e6,0)
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8                                     \
  then
    Lprot(ls,-1,"Default AC test frequency",0,"Hz",$LAY.frequency,0)
    Lprot(ls,-1,"Maximal HV test voltage",0,"V",$EXTLAY.hvumax,1)
    Lprot(ls,-1,"Residual inductance",4,"uH",$EXTLAY.lzero/1000.0,0)
    Lprot(ls,-1,"Inductance correction 1",4,"uH/Ohm",$EXTLAY.lphase1,0)
    Lprot(ls,-1,"Inductance correction 2",4,"uH/Ohm",$EXTLAY.lphase2,0)
    Lprot(ls,-1,"R correction for inductance",3,"Ohm",$EXTLAY.lrshift/1.0e6,0)
    Lprot(ls,-1,"Mains frequency",0,"Hz",$EXTLAY.mainsfreq,1)
  endif
  for i=0,i<$LAY.nfing*2,i++ do
    Lprot(ls,i,"Individual head resistance",4,"Ohm",$EXTLAY.radj[i]/1.0e6,0)
    Lprot(ls,i,"Sine adjustment",0,"",$EXTLAY.sinadj[i],0)
    if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||         \
      testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||           \
      testertype==TT_A7 || testertype==TT_A8                                   \
    then
      Lprot(ls,i,"Cosine adjustment",0,"",$EXTLAY.cosadj[i],0)
      Lprot(ls,i,"C phase adjustment",5,"rad",$int2($EXTLAY+516+2*i)/10000.0,0)
      Lprot(ls,i,"MSD correction",4,"",$EXTLAY.crtcorr[i]/10000.0,0)
      Lprot(ls,i,"Pressure correction factor",4,"",                            \
        $int2($EXTLAY+272+2*i)/1024.0,1)
      ;
    endif
  enddo
  if ls!=0 then
    add hlist text=""
  endif
  if txtok then
    fprintf(hlog,"\n\n--------------------------------------------------")
    fprintf(hlog,"---------------------------\n-------------------------")
    fprintf(hlog,"----------------------------------------------------\n")
  endif
  if rtfok!=0 then
    REndtable()
  endif
end

#define NAPOINT        256             // Number of data points in statistics

// In the 5-element collection: 0 - sum, 1- min, 2-max, 3-count, 4-bad
float  rordin[5][33][NAPOINT][5]       // Ordinary resistance
float  rexact[5][33][NAPOINT][5]       // Exact resistance
float  fieldm[2][33][NAPOINT][5]       // Field measurements
float  cordin[3][33][NAPOINT][5]       // Ordinary capacity measurements
float  cquick[4][33][NAPOINT][5]       // Quick capacity measurements
float  hvmeas[3][33][NAPOINT][5]       // High voltage measurements
float  camacc[4][33][NAPOINT][5]       // Accuracy of video recognition
float  temper   [33][NAPOINT][5]       // Temperature measurements
float  aexpec[8][5]                    // Expected mean values
float  aaccur[8][5]                    // Expected accuracy
float  aacabs[8][5]                    // Expected accuracy, absolute (sums up)
handle hgraph                          // Graph window in acceptance test
handle hazoom                          // Zoom out graphics
handle haview[8]                       // Display selection radio boxes
handle hasecl                          // Child with second-level selections
handle hasubv[5]                       // Display second-level selection
handle hahead[33]                      // Head selection buttons
handle haclos                          // Close acceptance test

char   taview[8][64] = {             \ // Names of selection radio buttons
  "???,??,294 Ohm,0.978 MOhm,10 MOhm,?a?",              \
  "????,??,294 Ohm,0.978 MOhm,10 MOhm,?a?",                 \
  "?3?,Sine component,Cosine component",                                     \
  "???Y,Zero capacity,35 pF,270 pF",                              \
  "???Y,Zero capacity,270 pF,2.7 nF,22 nF",                          \
  "???1,10 MOhm,100 MOhm,?a?",                                        \
  "2a?????,Temperature",                                            \
  "?????,Cross 1 - X,Cross 1 - Y,Cross 2 - X,Cross 2 - Y" }
char   aunits[8][5][8] = {                                                     \
  { "Ohm", "Ohm", "MOhm", "MOhm", "MOhm" },                                    \
  { "Ohm", "Ohm", "MOhm", "MOhm", "MOhm" },                                    \
  { "Bits","Bits","",     "",     ""     },                                    \
  { "pF",  "pF",  "pF",   "",     ""     },                                    \
  { "pF",  "pF",  "nF",   "nF",   ""     },                                    \
  { "MOhm","MOhm","GOhm", "",     ""     },                                    \
  { "C",   "",    "",     "",     ""     },                                    \
  { "um",  "um",  "um",   "um",   ""     } }
float afactr[8][5] = {                                                         \
  { 1.0,   1.0,   1e6,    1e6,    1e6    },                                    \
  { 1.0,   1.0,   1e6,    1e6,    1e6    },                                    \
  { 1.0,   1.0,   1.0,    1.0,    1.0    },                                    \
  { 1.0,   1.0,   1.0,    1.0,    1.0    },                                    \
  { 1.0,   1.0,   1e3,    1e3,    1.0    },                                    \
  { 1e6,   1e6,   1e9,    1.0,    1.0    },                                    \
  { 1.0,   1.0,   1.0,    1.0,    1.0    },                                    \
  { 1.0,   1.0,   1.0,    1.0,    1.0    } }

int    natest                          // Number of points in statistics
int    nacomp                          // Compression factor (cycles in point)
int    acstat                          // Statistics selected in acceptance test
int    acsubs                          // Substatistics in acceptance test
int    achead                          // Head selected in acceptance test
int    cursor                          // Point with cursor
int    astart                          // Time when test was started
int    atstop                          // Time when test was stopped

// Shows currently selected statistics in graph window.
function int Showstat()
  int tscale[14]= { 1,2,5,10,20,50,100,200,500,1000,2000,5000,10000,20000 }
  int i,j,k,x,y,x0,y0,x1,y1
  float r,vmin,vmax,xa,fx,ya,fy,factor
  float data[NAPOINT][5]
  char s[128]
  draw window=hgraph
  draw bkcolor=WHITE clear
  // Generate and draw title of graphics.
  draw mode=M_CENTERED font=MEDIUMFONT color=BLACK
  j=0; k=0
  for i=0,taview[acstat][i]!=',',i++ do
    s[j]=taview[acstat][i]; j++; enddo
  while k!=acsubs && taview[acstat][i]!='\0' do
    for i=i+1,taview[acstat][i]!=',',i++ do; enddo
    k++; enddo
  s[j]=' '; j++; s[j]='-'; j++; s[j]=' '; j++
  for i=i+1,taview[acstat][i]!=',' && taview[acstat][i]!='\0',i++ do
    s[j]=taview[acstat][i]; j++; enddo
  s[j]='\0'
  draw at LEFTX/2,20 text=s
  if achead==32 then                   // Means statistics for all heads
    sprintf(s,"?D")
  else if achead==$LAY.nfing*2 then
    sprintf(s,"Top camera")
  else if achead==$LAY.nfing*2+1 then
    sprintf(s,"Bottom camera")
  else
    sprintf(s,"Head %i%c",achead/2,(achead & 1?'R':'L'))
  endif
  draw at LEFTX/2,40 text=s
  // Dimensions of frame with graph data.
  x0=5; x1=LEFTX-5
  y0=47; y1=y0+251
  y=(y0+y1)/2
  // Conversion from point number and data value to x,y:
  // x=xa+point*fx
  // y=ya+value*fy
  xa=x0
  fx=((x1-x0)*1.0)/Max(natest,1)
  vmin=aexpec[acstat][acsubs]*(1.0-aaccur[acstat][acsubs])-                    \
    aacabs[acstat][acsubs]
  vmax=aexpec[acstat][acsubs]*(1.0+aaccur[acstat][acsubs])+                    \
    aacabs[acstat][acsubs]
  if vmax==vmin then
    fy=1.0;
  else
    fy=((y0-y1)/(Status(hazoom)==0?1.5:7.5))/(vmax-vmin)
  endif;
  ya=y-aexpec[acstat][acsubs]*fy
  factor=afactr[acstat][acsubs]
  // Generate and draw frame.
  draw color=DARKGRAY at x0-1,y0-1 rect x1+1,y1+1
  draw color=GRAY mode=M_CENTERED font=SMALLFONT at x0,y to x1,y
  for i=0,i<13,i++ do
    if tscale[i]*7>=natest*nacomp break; enddo
  draw at x0,y0 clip x1,y1
  for j=1,j<20,j++ do
    x=xa+j*tscale[i]*(fx/nacomp)
    if x>x1+50 break
    draw at x,y+5 to x,y
    draw at x,y+17 text=format("%i",j*tscale[i])
  enddo
  draw mode=M_RIGHT at x1-3,y text="Loop"
  draw mode=M_LEFT at x0+3,y
  draw text=format("%.4g %s",aexpec[acstat][acsubs]/factor,                    \
    aunits[acstat][acsubs])
  draw at x0+3,ya+vmin*fy text=format("%.4g",vmin/factor)
  draw at x0+3,ya+vmax*fy text=format("%.4g",vmax/factor)
  draw color=LIGHTGRAY at x0,ya+vmin*fy to x1,ya+vmin*fy
  draw at x0,ya+vmax*fy to x1,ya+vmax*fy
  // Draw data.
  switch acstat
    case 0: Memcpy(data,rordin[acsubs][achead],Sizeof(data))
    case 1: Memcpy(data,rexact[acsubs][achead],Sizeof(data))
    case 2: Memcpy(data,fieldm[acsubs][achead],Sizeof(data))
    case 3: Memcpy(data,cordin[acsubs][achead],Sizeof(data))
    case 4: Memcpy(data,cquick[acsubs][achead],Sizeof(data))
    case 5: Memcpy(data,hvmeas[acsubs][achead],Sizeof(data))
    case 6: Memcpy(data,temper[0],Sizeof(data))
    case 7: Memcpy(data,camacc[acsubs][achead],Sizeof(data))
  endsw
  draw color=DARKGRAY                  // Draw cursor
  draw at xa+cursor*fx,y0 to xa+cursor*fx,y1
  draw color=LIGHTBLUE
  for i=0,i<natest,i++ do              // Draw minimal values
    x=xa+i*fx
    y=Min(1000,Max(-1000,ya+data[i][1]*fy))
    if i==0 then draw at x,y;
    else draw to x,y; endif
  enddo
  for i=0,i<natest,i++ do              // Draw maximal values
    x=xa+i*fx
    y=Min(1000,Max(-1000,ya+data[i][2]*fy))
    if i==0 then draw at x,y;
    else draw to x,y; endif
  enddo
  draw color=LIGHTRED
  for i=0,i<natest,i++ do              // Draw mean values
    if data[i][3]==0.0 continue
    x=xa+i*fx
    y=Min(1000,Max(-1000,ya+data[i][0]/data[i][3]*fy))
    if i==0 then draw at x,y;
    else draw to x,y; endif
  enddo
  draw color=RED
  for i=0,i<natest,i++ do              // Draw errors
    j=data[i][4]*40.0/(4.0+data[i][4])
    if j==0 continue
    x=xa+i*fx
    draw at x,y1-j to x,y1
  enddo
  draw clip=NULL
  draw color=BLACK font=INFOFONT mode=M_LEFT
  i=(atstop-astart)/60000
  draw at x0,y1+20 text=format("2a??? %ih %02im",i/60,i%60)
  if nacomp==1 then
    draw at x0+1,y1+40 text=format("?-? %i:",cursor)
  else
    draw at x0+1,y1+40 text=format("?-? %i..%i:",                            \
    cursor*nacomp,(cursor+1)*nacomp-1)
  endif
  if data[cursor,3]!=0.0 then
    draw at x0+133,y1+40 text=format("Mean %.4g %s",                           \
      data[cursor,0]/data[cursor,3]/factor,aunits[acstat,acsubs])
    draw at x0+260,y1+40 text=format("Bad %i",data[cursor,4])
    draw at x0+133,y1+60 text=format("Min %.4g",data[cursor,1]/factor)
    draw at x0+215,y1+60 text=format("Max %.4g",data[cursor,2]/factor)
  endif
  draw show
end

// Creates a set of substatistics buttons for given statistics.
function int Substatistics(int stat)
  int i,j,k
  char s[64]
  clear hasecl
  change hasecl position=0,0,0,0
  for i=0,i<5,i++ do
    hasubv[i]=NULL
  enddo
  for j=0,taview[stat][j]!=',',j++ do; enddo
  for i=0,i<5,i++ do
    k=0
    for j=j+1,taview[stat][j]!=',' && taview[stat][j]!='\0',j++ do
      s[k]=taview[stat][j]; k++
    enddo
    if k==0 break
    s[k]='\0'
    hasubv[i]=control RADIO
      window=hasecl
      position=0,i*18,120,18
      name=s
      help="????3????"
      font=INFOFONT
      mode=(i==0?M_CHECKED:0)
    endc
  enddo
  acsubs=0
  for j=0,j<8,j++ do
    change haview[j] position=10,29+j*18+(j>stat?i*18+2:0),140,18
  enddo
  change hasecl position=35,47+stat*18,120,i*18
end

// Checks whether some button within acceptance window was activated, and if so,
// performs requested action. Also executes wait. Returns 0 if action processed
// internally, 1 if acceptance test must quit and -1 if Meastest must quit.
function int Checkforaction()
  int i,j
  for i=0,i<8,i++ do
    if Pressed(haview[i]) then
      acstat=i
      Substatistics(acstat)
      Showstat()
    endif
  enddo
  for i=0,i<5,i++ do
    if hasubv[i]==NULL break
    if Pressed(hasubv[i]) then
      acsubs=i
      Showstat()
    endif
  enddo
  for j=0,j<=$LAY.nfing,j++ do
    for i=0,i<2,i++ do
      if j==$LAY.nfing && ($LAY.cameras & (1<<i))==0 continue
      if j<$LAY.nfing && used[j*2]==0 continue
      if Pressed(hahead[2*j+i]) then
        if achead!=2*j+i then
          change hahead[achead] color=BLACK
          change hahead[achead] bkcolor=GRAY
          achead=2*j+i
          change hahead[achead] color=LIGHTRED
          change hahead[achead] bkcolor=YELLOW
        endif
        Showstat()
      endif
    enddo
  enddo
  if Pressed(haclos) then
    return 1
  else if Pressed(hexit) then
    return -1
  else if Pressed(hahead[32]) then     // Statistics for all heads
    if achead!=32 then
      change hahead[achead] color=BLACK
      change hahead[achead] bkcolor=GRAY
      achead=32
      change hahead[achead] color=LIGHTRED
      change hahead[achead] bkcolor=YELLOW
    endif
    Showstat()
  else if (Pressed(hgraph) || Status(hgraph)==1) then
    i=Limit0(hgraph)
    j=Max(0.0,Min(natest-1,(i-5.0)*Max(natest,1)/(LEFTX-10.0)+0.5))
    if j!=cursor then
      cursor=j
      Showstat()
    endif
  else if Pressed(hazoom) then
    Showstat()
  endif
  wait
end

function int Clearstatistics(float *stat,int size)
  int i
  float f[1]
  size=size/Sizeof(f)
  for i=0,i<size,i=i+5 do
    stat[i]=0.0
    stat[i+1]=+1.0e100
    stat[i+2]=-1.0e100
    stat[i+3]=0.0
    stat[i+4]=0.0
  enddo
end

function int Compressstatistics(float *stat)
  int i,j,k,q
  for j=0,j<=32,j++ do
    for i=0,i<NAPOINT/2,i++ do
      k=(j*NAPOINT+i)*5
      q=(j*NAPOINT+i*2)*5
      stat[k]=stat[q]+stat[q+5]
      stat[k+1]=Min(stat[q+1],stat[q+6])
      stat[k+2]=Max(stat[q+2],stat[q+7])
      stat[k+3]=stat[q+3]+stat[q+8]
      stat[k+4]=stat[q+4]+stat[q+9]
    enddo
    for i=i,i<NAPOINT,i++ do
      k=(j*NAPOINT+i)*5
      stat[k]=0.0
      stat[k+1]=+1.0e100
      stat[k+2]=-1.0e100
      stat[k+3]=0.0
      stat[k+4]=0.0
    enddo
  enddo
end

function int Addtostatistics(float *stat,int head,float value,int bad)
  int k
  k=(head*NAPOINT+natest)*5
  stat[k]=stat[k]+value
  stat[k+1]=Min(stat[k+1],value)
  stat[k+2]=Max(stat[k+2],value)
  stat[k+3]=stat[k+3]+1.0
  if bad!=0 stat[k+4]=stat[k+4]+1.0
  k=(32*NAPOINT+natest)*5
  stat[k]=stat[k]+value
  stat[k+1]=Min(stat[k+1],value)
  stat[k+2]=Max(stat[k+2],value)
  stat[k+3]=stat[k+3]+1.0
  if bad!=0 stat[k+4]=stat[k+4]+1.0
end

function int Printstatistics(int stat,int subs)
  int i,j,k,count[33]
  float data[NAPOINT][5]
  float r,factor,absmin[33],meanmin[33],mean[33],meanmax[33],absmax[33]
  char s[256]
  // Calculate individual statistics for each head (only if extendedlog is set)
  // and over all heads (i.e. head 32).
  if txtok==0 && rtfok==0 return       // No protocols
  for i=(extendedlog==0?32:0),i<=32,i++ do
    switch stat
      case 0: Memcpy(data,rordin[subs][i],Sizeof(data))
      case 1: Memcpy(data,rexact[subs][i],Sizeof(data))
      case 2: Memcpy(data,fieldm[subs][i],Sizeof(data))
      case 3: Memcpy(data,cordin[subs][i],Sizeof(data))
      case 4: Memcpy(data,cquick[subs][i],Sizeof(data))
      case 5: Memcpy(data,hvmeas[subs][i],Sizeof(data))
      case 6: Memcpy(data,temper[i],Sizeof(data))
      case 7: Memcpy(data,camacc[subs][i],Sizeof(data))
    endsw
    absmin[i]=1.0e100
    meanmin[i]=1.0e100
    mean[i]=0.0
    meanmax[i]=-1.0e100
    absmax[i]=-1.0e100
    count[i]=0
    for j=0,j<natest,j++ do
      if data[j][3]==0 continue
      r=data[j][0]/data[j][3]
      absmin[i]=Min(absmin[i],data[j][1])
      meanmin[i]=Min(meanmin[i],r)
      mean[i]=mean[i]+r; count[i]++
      meanmax[i]=Max(meanmax[i],r)
      absmax[i]=Max(absmax[i],data[j][2])
    enddo
    if count[i]==0 continue
    mean[i]=mean[i]/count[i]
  enddo
  if count[32]==0 return               // No data, no protocolling
  factor=afactr[stat][subs]
  // Extract title of statistics.
  j=0; k=0
  for i=0,taview[stat][i]!=',',i++ do
    s[j]=taview[stat][i]; j++; enddo
  while k!=subs && taview[stat][i]!='\0' do
    for i=i+1,taview[stat][i]!=',',i++ do; enddo
    k++; enddo
  s[j]=' '; j++; s[j]='-'; j++; s[j]=' '; j++
  for i=i+1,taview[stat][i]!=',' && taview[stat][i]!='\0',i++ do
    s[j]=taview[stat][i]; j++; enddo
  s[j]='\0'                            // Now s contains complete title
  // Log in text file.
  if (txtok!=0) then
    fprintf(hlog,"\n\n")
    for i=0,i<(77-j)/2,i++ do          // Page in .TXT is 77 characters wide
      fprintf(hlog," ")
    enddo
    fprintf(hlog,"%s\n\n",s)
    fprintf(hlog,"Head Units  Abs.minimum  Mean minimum   Mean value  "        \
      "Mean maximum  Abs.maximum\n\n")
    k=0
    for i=(extendedlog==0?32:0),i<=32,i++ do
      if count[i]==0 continue
      if stat==6 && i!=32 continue
      if i==32 then
        if k!=0 fprintf(hlog,"\n")
        fprintf(hlog,"All ");
      else
        fprintf(hlog,"%2i%c ",i/2,(i & 1)?'R':'L');
      endif
      fprintf(hlog,"%6.6s%13.4g%14.4g%13.4g%14.4g%13.4g\n",                    \
        aunits[stat][subs],absmin[i]/factor,meanmin[i]/factor,mean[i]/factor,  \
        meanmax[i]/factor,absmax[i]/factor)
      k=1
    enddo
  endif
  // Log in RTF file.
  if rtfok!=0 then
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,12)
    RAddfmt("\n%s",s)
    RFmt(RTF_TIMES,RTF_NORMAL,9)
    if extendedlog then                // Add pictures only if requested
      cursor=0; acstat=stat; acsubs=subs; achead=32
      change hazoom mode=0             // Remove check from zoom out box
      Showstat()
      RParagraph(RTF_CENTERED|RTF_SPACE)
      RAddpiczoom(hgraph,4,46,LEFTX-4,299,0,0.75)
    endif
    RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,8.5)
    RCell(RTF_CENTERED|RTF_THINBRD,14.0); RAddtext("Head")
    RCell(RTF_CENTERED|RTF_THINBRD,14.0); RAddtext("Units")
    RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("Absolute\nminimum")
    RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("Minimal\nmean")
    RCell(RTF_CENTERED|RTF_THINBRD,27.0);
    RAddtext("Mean over\nall measurements")
    RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("Maximal\nmean")
    RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddtext("Absolute\nmaximum")
    k=0
    for i=(extendedlog==0?32:0),i<=32,i++ do
      if count[i]==0 continue
      if stat==6 && i!=32 continue
      RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,4.5)
      RCell(RTF_CENTERED|RTF_THINBRD,14.0)
      if i==32 then
        RAddtext("All")
      else
        RAddfmt("%i%c",i/2,(i & 1)?'R':'L')
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,14.0)
      if k==0 then
        RAddtext(aunits[stat][subs]); k=1
      else
        RAddtext("\"")
      endif
      RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddfmt("%.4g",absmin[i]/factor)
      RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddfmt("%.4g",meanmin[i]/factor)
      RCell(RTF_CENTERED|RTF_THINBRD,27.0); RAddfmt("%.4g",mean[i]/factor)
      RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddfmt("%.4g",meanmax[i]/factor)
      RCell(RTF_CENTERED|RTF_THINBRD,26.0); RAddfmt("%.4g",absmax[i]/factor)
    enddo
    REndtable()
  endif
end

// Long acceptance test.
function int Acceptancetest(int voltage)
  char rpair[5][2][6]= {                                                       \
    { "GND1",  "GND2" }, { "R294",  "GND2" }, { "R978K", "GND1" },             \
    { "R10M",  "GND2" }, { "RINF", "GND2" } }
  char hvpair[3][2][6]= {                                                      \
    { "R10M",  "GND2" }, { "R100M",  "GND1" }, { "RINF", "GND2" } }
  char cpair[2][4][2][6]= {                                                    \
    { { "NOCT1", "NOCT2" }, { "GND1",  "C27P" }, { "GND2", "C270P" },          \
    { "GND1",  "GND2" } },                                                     \
    { { "NOCT1", "NOCT2" }, { "GND1", "C270P" }, { "GND2",  "C2N7" },          \
    { "GND2",  "C22N" } } }
  int i,j,k,ka,kg,ko,n,t,bad,comp,type,dy,yoffs,delta,inuse[32],err
  float x[32],y[32],x0,y0,x1,y1,x2,y2,x3,y3,r,c,xsc,ysc
  float xvoffs[2][2],yvoffs[2][2]
  char s[256]
  handle hfid,havideo
  clear hright
  change hinfo limits=0,0
  change hinfo text="?2a?"
  draw window=hright color=DARKGRAY font=INFOFONT
  draw at 10,24 text="???3??D??:"
  draw at RIGHTX-90,24 text="2a?:"
  draw show
  hgraph=control GRAPH
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="?D??????1?"
    color=DARKGRAY
    bkcolor=WHITE
  endc
  hazoom=control CHECKBOX
    window=hgraph
    position=8,LEFTY-23,80,20
    name="??D?"
    help="???D????D???D?5?"
    font=INFOFONT
  endc
  change hleft position=-1000,*,*,*
  for i=0,i<8,i++ do
    for j=0,taview[i][j]!=',',j++ do
      s[j]=taview[i][j]
    enddo
    s[j]='\0'
    haview[i]=control RADIO
      window=hright
      position=10,29+i*18,140,18
      text=s
      help=format("???????%c%s2a??3??D??",       \
        Tolower(s[0]),s+1)
      mode=(i==0?M_CHECKED:0)
      font=INFOFONT
    endc
  enddo
  hasecl=control CHILD
    window=hright
    position=0,0,0,0                   // Will be positioned elsewhere
    help=" "
    color=WHITE
  endc
  // Mark voltage settings.
  voltage=Min(500,Max(50,voltage))
  sprintf(taview[5],"???1 (%i v),10 MOhm,100 MOhm,?a?",voltage)
  // Create head selection buttons.
  if $LAY.nfing<=8 then dy=23; delta=6
  else if $LAY.nfing<=12 then dy=20; delta=3
  else dy=18; delta=1; endif
  hahead[32]=control BUTTON
    window=hright
    position=RIGHTX-90,29,81,dy-1
    name="??"
    help="???????D2a??3??D??"
  endc
  yoffs=0
  for j=0,j<=$LAY.nfing,j++ do
    if j<$LAY.nfing && $LAY.side[j]!=0 yoffs=delta
    if j==$LAY.nfing yoffs=yoffs+delta
    for i=0,i<2,i++ do
      if j==$LAY.nfing && ($LAY.cameras & (1<<i))==0 continue
      if j==$LAY.nfing then
        sprintf(s,"Press to display statistics for %s video camera",           \
        i==0?"top":"bottom")
      else
        sprintf(s,"Press to display statistics for head %i%c",j,i==0?'L':'R')
      endif
      hahead[j*2+i]=control BUTTON
        window=hright
        position=RIGHTX-90+i*41,29+dy*(j+1)+yoffs+delta,40,dy-1
        name=format("%i%c",j,(i==0?'L':'R'))
        help=s
      endc
      if j<$LAY.nfing && used[j*2+i]==0 disable hahead[j*2+i]
    enddo
  enddo
  achead=32
  change hahead[achead] color=LIGHTRED
  change hahead[achead] bkcolor=YELLOW
  havideo=control GRAPH
    window=hright
    position=15,268,INFOX,INFOY
    color=WHITE
    bkcolor=WHITE
    help="??2a??????"
  endc
  haclos=control BUTTON
    window=hright
    position=RIGHTX-90,309,81,dy-1
    name="?12a?"
    help="????12a?2??3??D??????????t"
  endc
  // Prepare for test.
  Clearstatistics(rordin,Sizeof(rordin))
  Clearstatistics(rexact,Sizeof(rexact))
  Clearstatistics(fieldm,Sizeof(fieldm))
  Clearstatistics(cordin,Sizeof(cordin))
  Clearstatistics(cquick,Sizeof(cquick))
  Clearstatistics(hvmeas,Sizeof(hvmeas))
  Clearstatistics(camacc,Sizeof(camacc))
  Clearstatistics(temper,Sizeof(temper))
  natest=0                             // Number of points in statistics
  nacomp=1                             // Compression factor (cycles in point)
  cursor=0
  Substatistics(0)
  astart=Time(); atstop=astart
  // Run continuous test.
  while err==0 do
    for comp=0,comp<nacomp && err==0,comp++ do
      change hinfo text=format("?2a?, ?-? %i",natest*nacomp+comp)
      // Resistance test, type=0: ordinary, 1: exact resistance
      for type=0,type<2 && err==0,type++ do
        clear havideo
        draw window=havideo color=BLACK mode=M_CENTERED font=MEDIUMFONT
        if type==0 then
          draw at INFOX/2,36 text="?" show
        else
          draw at INFOX/2,24 text="???\n?" show
        endif
        for k=0,k<5 && err==0,k++ do   // 5 different resistors
          for j=0,j<(type==0?4:1) && err==0,j++ do // Repeat
            for i=0,i<$LAY.nfing,i++ do// Rail
              if used[i*2]==0 continue
              r=Convertpad(x+i*2,y+i*2,rpair[k][0],i*2,DELTA)
              r=r+Convertpad(x+i*2+1,y+i*2+1,rpair[k][1],i*2+1,DELTA)
              if r>RMAX r=RMAX
              aexpec[type][k]=r        // Expected mean value
              if k==4 then             // Expected accuracy
                aaccur[type][k]=(type==0?RFACTORHI:EFACTORHI)
                aacabs[type][k]=0.0
              else
                aaccur[type][k]=(type==0?RFACTORLO:EFACTORLO)
                aacabs[type][k]=(type==0?RABSLO:EABSLO)
              endif
              sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] UP(%i) UP(%i) NOP",     \
                i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],i*2,i*2+1)
              SERV.Cmdimm(32,s)        // Move both fingers to points
            enddo
            for i=0,i<$LAY.nfing,i++ do// Rail
              if used[i*2]==0 continue
              sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] %c(%i,%i)",             \
                i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],                     \
                type==0?'R':'E',i*2,i*2+1)
              if SERV.Cmdimm(0,s)<0 err=1
              sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] %c(%i,%i)",             \
                i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],                     \
                type==0?'R':'E',i*2+1,i*2)
              if SERV.Cmdimm(1,s)<0 err=1
              sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] UP(%i) UP(%i) NOP",     \
                i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],i*2,i*2+1)
              SERV.Cmdimm(32,s)        // Move both fingers up
              t=Time()
              while err==0 do
                err=Checkforaction()
                atstop=Time()
                if $A[0].length!=0 && $A[1].length!=0 break
                if err==0 && atstop-t>10000 err=2
              enddo
              if err==0 && ($A[0].answer!=S_MOVE || $A[1].answer!=S_MOVE) err=1
              if err!=0 break
              r=$A[0].r; if ($A[0].status & 0x0100) r=r*1.0e-6
              bad=$A[0].status & 0x8E00
              Addtostatistics(type==0?rordin[k]:rexact[k],i*2,r,bad)
              r=$A[1].r; if ($A[1].status & 0x0100) r=r*1.0e-6
              bad=$A[1].status & 0x8E00
              Addtostatistics(type==0?rordin[k]:rexact[k],i*2+1,r,bad)
            enddo                      // End rail
          enddo                        // End repeat
        enddo                          // End resistor
      enddo
      // Field test.
      clear havideo
      draw window=havideo color=BLACK mode=M_CENTERED font=MEDIUMFONT
      draw at INFOX/2,36 text="?3?" show
      for j=0,j<8 && err==0,j++ do     // Repeat 8 times
        Memset(inuse,0,Sizeof(inuse))
        for k=0,k<$LAY.nfing*2,k++ do  // Finger
          ko=k^1                       // Opposite finger
          kg=(k & 0x1E)+$LAY.nfing     // Opposite rail
          if kg>=$LAY.nfing*2 kg=kg-$LAY.nfing*2
          ka=kg+1                      // Now calculate pad coordinates
          if used[k]==0 || used[kg]==0 || used[ka]==0 continue
          inuse[k]=1
          Convertpad(&x0,&y0,"F1",k,DELTA)
          Convertpad(&x1,&y1,(ko<k?"RES0":"P3"),ko,0.0)
          Convertpad(&x2,&y2,"GND1",kg,DELTA)
          Convertpad(&x3,&y3,"F2",ka,DELTA)
          n=sprintf(s,"M %i[%g,%g] %i[%g,%g] %i[%g,%g] %i[%g,%g] ",            \
            k,x0,y0,ko,x1,y1,kg,x2,y2,ka,x3,y3)
          n=n+sprintf(s+n,"F(%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,",                  \
            k,kg,ka,ka,ka,ka,ka,ka,ka,ka)
          sprintf(s+n,"%i,%i,%i,%i,%i,%i,%i,%i)",                              \
            ka,ka,ka,ka,ka,ka,ka,ka)   // Total of 16 antennae
          if SERV.Cmdimm(k,s)<0 err=1
        enddo
        for k=0,k<$LAY.nfing*2 && err==0,k++ do
          if inuse[k]==0 continue
          t=Time()
          while err==0 do
            err=Checkforaction()
            atstop=Time()
            if $A[k].length!=0 break
            if err==0 && atstop-t>10000 err=2
          enddo
          if err!=0 break
          for n=0,n<16,n++ do
            bad=(n==0 && ($A[k].status & 0x9E20)!=0)
            Addtostatistics(fieldm[0],k,$int2($A[k]+32+4*n),bad)
            Addtostatistics(fieldm[1],k,$int2($A[k]+34+4*n),bad)
          enddo
        enddo
      enddo
      if err==0 && natest==0 then
        aexpec[2][0]=fieldm[0][32][0][0]/fieldm[0][32][0][3]
        aaccur[2][0]=0.0
        aacabs[2][0]=FNOISE
        aexpec[2][1]=fieldm[1][32][0][0]/fieldm[1][32][0][3]
        aaccur[2][1]=0.0
        aacabs[2][1]=FNOISE
      endif
      // Capacity test, type=0: field, 1: quick (only if allowed).
      for type=0,type<2 && err==0,type++ do
        if type==1 && allowquickc==0 break
        clear havideo
        draw window=havideo color=BLACK mode=M_CENTERED font=MEDIUMFONT
        if type==0 then
          draw at INFOX/2,36 text="?Y" show
        else
          draw at INFOX/2,24 text="??\n ?Y" show
        endif
        for k=0,k<(type==0?3:4) && err==0,k++ do
          for j=0,j<3 && err==0,j++ do // Repeat
            for i=0,i<$LAY.nfing,i++ do// Rail
              if used[i*2]==0 continue
              Convertpad(x+i*2,y+i*2,cpair[type][k][0],i*2,DELTA)
              Convertpad(x+i*2+1,y+i*2+1,cpair[type][k][1],i*2+1,DELTA)
              sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] UP(%i) UP(%i) NOP",     \
                i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],i*2,i*2+1)
              SERV.Cmdimm(32,s)        // Move both fingers to points
            enddo
            for i=0,i<$LAY.nfing,i++ do// Rail
              if used[i*2]==0 continue
              n=sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] ",                    \
                i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1])
              if type==0 then
                sprintf(s+n,"F(%i,%i)",i*2,i*2+1)
              else
                sprintf(s+n,"A(%i,0,%i)",i*2,i*2+1)
              endif
              if SERV.Cmdimm(0,s)<0 err=1
              if type==0 then
                sprintf(s+n,"F(%i,%i)",i*2+1,i*2)
              else
                sprintf(s+n,"A(%i,0,%i)",i*2+1,i*2)
              endif
              if SERV.Cmdimm(1,s)<0 err=1
              sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] UP(%i) UP(%i) NOP",     \
                i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],i*2,i*2+1)
              SERV.Cmdimm(32,s)        // Move both fingers up
              t=Time()
              while err==0 do
                err=Checkforaction()
                atstop=Time()
                if $A[0].length!=0 && $A[1].length!=0 break
                if err==0 && atstop-t>10000 err=2
              enddo
              if err==0 && ($A[0].answer!=S_MOVE || $A[1].answer!=S_MOVE) err=1
              if err!=0 break
              c=0.0; r=0.0
              if type==0 then
                SERV.Convertfield($A[0],&c,&r)
              else
                SERV.Convertfastc($A[0],&c,&r)
              endif
              bad=$A[0].status & 0x9E00
              if k==0 bad=bad & 0xF9FF // Hide nocontacts for zero capacity
              Addtostatistics(type==0?cordin[k]:cquick[k],i*2,c,bad)
              c=0.0; r=0.0
              if type==0 then
                SERV.Convertfield($A[1],&c,&r)
              else
                SERV.Convertfastc($A[1],&c,&r)
              endif
              bad=$A[1].status & 0x9E00
              if k==0 bad=bad & 0xF9FF // Hide nocontacts for zero capacity
              Addtostatistics(type==0?cordin[k]:cquick[k],i*2+1,c,bad)
            enddo                      // End rail
          enddo                        // End repeat
          if natest==0 && err==0 then
            if type==0 then
              aexpec[type+3][k]=cordin[k][32][0][0]/cordin[k][32][0][3]
            else
              aexpec[type+3][k]=cquick[k][32][0][0]/cquick[k][32][0][3]
            endif
            if aexpec[type+3][k]>=30000.0 then
              aaccur[type+3][k]=CREPHIGH; aacabs[type+3][k]=0.0
            else
              aaccur[type+3][k]=CREPEAT; aacabs[type+3][k]=CREPABS
            endif
          endif
        enddo                          // End capacitor
      enddo
      // High voltage test.
      clear havideo
      draw window=havideo color=LIGHTRED mode=M_CENTERED font=MEDIUMFONT
      draw at INFOX/2,24 text=format("???1 \n ") show
      for i=0,i<$LAY.nfing,i++ do
        if used[i*2]==0 continue
        sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
        SERV.Cmdimm(i,s)               // Move fingers to home positions
      enddo
      t=Time()
      while err==0 do
        err=Checkforaction()
        atstop=Time()
        for i=0,i<$LAY.nfing,i++ do
          if used[i*2]==0 continue
          if $A[i].length==0 break
        enddo
        if i>=$LAY.nfing break
        if err==0 && atstop-t>10000 err=2
      enddo
      if err==0 then
        sprintf(s,"HVINIT %i,1,30",voltage)
        SERV.Cmdimm(0,s)               // 1% accuracy, 30 ms test time
        t=Time()
        while err==0 do
          err=Checkforaction()
          atstop=Time()
          if $A[0].length!=0 break
          if err==0 && atstop-t>15000 err=2
        enddo
      endif
      for k=0,k<3 && err==0,k++ do     // 3 different resistors
        for j=0,j<4 && err==0,j++ do   // Repeat 4 times
          for i=0,i<$LAY.nfing,i++ do  // Rail
            if used[i*2]==0 continue
            r=Convertpad(x+i*2,y+i*2,hvpair[k][0],i*2,DELTA)
            r=r+Convertpad(x+i*2+1,y+i*2+1,hvpair[k][1],i*2+1,DELTA)
            aexpec[5][k]=r             // Expected mean value
            if k==0 then               // Expected accuracy
              aaccur[5][k]=HVFACTORLO; aacabs[5][k]=HVABSLO
            else
              aaccur[5][k]=HVFACTORHI; aacabs[5][k]=0.0
            endif
            sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] UP(%i) UP(%i) NOP",       \
              i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],i*2,i*2+1)
            SERV.Cmdimm(32,s)          // Move both fingers to points
          enddo
          for i=0,i<$LAY.nfing,i++ do  // Rail
            if used[i*2]==0 continue
            sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] H(%i,%i)",                \
              i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],i*2,i*2+1)
            if SERV.Cmdimm(0,s)<0 err=1
            sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] H(%i,%i)",                \
              i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],i*2+1,i*2)
            if SERV.Cmdimm(1,s)<0 err=1
            sprintf(s,"M %i[%.3f,%.3f] %i[%.3f,%.3f] UP(%i) UP(%i) NOP",       \
              i*2,x[i*2],y[i*2],i*2+1,x[i*2+1],y[i*2+1],i*2,i*2+1)
            SERV.Cmdimm(32,s)          // Move both fingers up
            t=Time()
            while err==0 do
              err=Checkforaction()
              atstop=Time()
              if $A[0].length!=0 && $A[1].length!=0 break
              if err==0 && atstop-t>10000 err=2
            enddo
            if err==0 && ($A[0].answer!=S_MOVE || $A[1].answer!=S_MOVE) err=1
            if err!=0 break
            r=$A[0].r; bad=$A[0].status & 0x867F
            Addtostatistics(hvmeas[k],i*2,r,bad)
            r=$A[1].r; bad=$A[1].status & 0x867F
            Addtostatistics(hvmeas[k],i*2+1,r,bad)
          enddo                        // End rail
        enddo                          // End repeat
      enddo                            // End resistor
      // Tester temperature.
      if err==0 then
        aexpec[6][0]=25.0
        aaccur[6][0]=0
        aacabs[6][0]=10.0
        sprintf(s,"INPORT %i",0x2011)  // Read effective (smoothed) temperature
        if SERV.Cmdimm(0,s)<0 err=1
        t=Time()
        while err==0 do
          err=Checkforaction()
          atstop=Time()
          if $A[0].length!=0 break
          if err==0 && atstop-t>10000 err=2
        enddo
        if err==0 && $A[0].answer!=S_INPORT err=1
        if err==0 then
          Addtostatistics(temper,0,$uint2($A[0]+5)/10.0,0)
        endif
      endif
      // Video accuracy.
      if (err==0 && $LAY.cameras==3) then
        if (testertype==TT_A5L && $LAY.cameras!=0 &&                           \
          (boardtype==0 || boardtype==1 || boardtype==4)) || boardtype==2 then
          Convert(&x0,&y0,(crossx[4]+crossx[5])/2,crossy[4],0)
        else
          Convert(&x0,&y0,(crossx[0]+crossx[1])/2,crossy[0],0)
        endif
        sprintf(s,"M %i(%g,%gA5) NOP",$LAY.nfing*2+1,x0,y0)
        SERV.Cmdimm(32,s)              // Preliminary move for down camera
      endif
      clear havideo
      SYS.Autoset(i,0)                 // No automatical video adjustment
      x0=INFOX/2; y0=INFOY/2
      draw window=havideo color=VIDEOFILL bkcolor=VIDEOFILL
      draw at x0-47,y0-35 fillrect x0+47,y0+35
      draw color=LIGHTRED
      draw at x0-5,y0 to x0-12,y0 at x0+5,y0 to x0+12,y0
      draw at x0,y0-5 to x0,y0-12 at x0,y0+5 to x0,y0+12
      draw show
      for i=0,i<2 && err==0,i++ do
        if ($LAY.cameras & (1<<i))==0 continue
        SYS.Videoex(havideo,i,0,0.125,Bcgetbri(i),Bcgetctr(i),2)
        sprintf(s,"Video scale[%i]",i)
        xsc=6.4; ysc=6.4               // Default video magnification
        getini("System",s,"%f,%f",&xsc,&ysc)
        xsc=Max(1.0,Min(12.0,xsc))
        ysc=Max(1.0,Min(12.0,ysc))
        hfid=SYS.Syntmodel(i,SYNT_CROSS,512.0/xsc,512.0*0.300/xsc,0.0,0.0,0)
        if hfid==NULL continue         // Unable to define, non-critical
        for j=0,j<2 && err==0,j++ do   // Repeat 2 times
          for k=0,k<2 && err==0,k++ do // Cross
            if (testertype==TT_A5L && $LAY.cameras!=0 &&                       \
              (boardtype==0 || boardtype==1 || boardtype==4)) || boardtype==2  \
            then
              Convert(&x0,&y0,crossx[k+5],crossy[k+5],0)
            else
              Convert(&x0,&y0,crossx[k*5],crossy[k*5],0)
            endif
            sprintf(s,"M %i(%g,%gA5) NOP",$LAY.nfing*2+i,x0,y0)
            SERV.Cmdimm(0,s)           // Move camera to cross
            t=Time()
            while err==0 do
              err=Checkforaction()
              atstop=Time()
              if $A[0].length!=0 break
              if err==0 && atstop-t>10000 err=2
            enddo
            if err==0 && $A[0].answer!=S_NOP err=1
            if err!=0 break
            t=Time()                   // Some additional delay for camera
            while Time()-t<700 do
              wait
            enddo
            SYS.Nextframe(i)           // Assure that Recogn() uses new frame
            SYS.Recogn(hfid)
            bad=($FOUND.corr[0]<0.15)
            x1=$FOUND.dx[0]*xsc*1000.0/512.0
            y1=$FOUND.dy[0]*ysc*1000.0/512.0
            if natest==0 && j==0 then
              for t=1,t<8,t++ do       // Statistics for higher accuracy
                SYS.Recogn(hfid)
                x1=x1+$FOUND.dx[0]*xsc*1000.0/512.0
                y1=y1+$FOUND.dy[0]*ysc*1000.0/512.0
              enddo
              x1=x1/8.0
              y1=y1/8.0
              xvoffs[i][k]=x1
              yvoffs[i][k]=y1
            endif
            Addtostatistics(camacc[k*2],$LAY.nfing*2+i,x1-xvoffs[i][k],bad)
            Addtostatistics(camacc[k*2+1],$LAY.nfing*2+i,y1-yvoffs[i][k],bad)
            aexpec[7][k*2]=0.0
            aaccur[7][k*2]=0.0
            aacabs[7][k*2]=25.0
            aexpec[7][k*2+1]=0.0
            aaccur[7][k*2+1]=0.0
            aacabs[7][k*2+1]=25.0
          enddo
        enddo
        SYS.Videoex(havideo,i,0,0.125,Bcgetctr(i),Bcgetctr(i),0)
        sprintf(s,"M %i(Z) NOP",$LAY.nfing*2+i)
        SERV.Cmdimm(32,s)
        SYS.Deletemodel(hfid)
      enddo
      change havideo bkcolor=WHITE
      clear havideo
    enddo
    // Cycle finished, update statistics.
    if err==0 then
      natest++
      Showstat()
      if natest>=NAPOINT then          // Buffer full, compress data
        for i=0,i<5,i++ do
          Compressstatistics(rordin[i])
          Compressstatistics(rexact[i])
          if i<2 Compressstatistics(fieldm[i])
          if i<3 Compressstatistics(cordin[i])
          if i<4 Compressstatistics(cquick[i])
          if i<3 Compressstatistics(hvmeas[i])
          if i<4 Compressstatistics(camacc[i])
        enddo
        Compressstatistics(temper)
        natest=natest/2
        nacomp=nacomp*2
        cursor=cursor/2
      endif
    endif
  enddo
  // Move fingers in home positions
  for i=0,i<$LAY.nfing,i++ do
    if used[i*2]==0 continue
    sprintf(s,"M %i(Z) %i(Z) NOP",i*2,i*2+1)
    SERV.Cmdimm(i,s)
  enddo
  t=Time()
  while err==0 do
    err=Checkforaction()
    atstop=Time()
    for i=0,i<$LAY.nfing,i++ do
      if used[i*2]==0 continue
      if $A[i].length==0 break
    enddo
    if i>=$LAY.nfing break
    if err==0 && atstop-t>10000 err=2
  enddo
  // Save results to log file.
  clear hright
  change hinfo text="Saving acceptance data"
  if txtok!=0 then                     // Write results to .TXT protocol
    fprintf(hlog,"\n                 ")
    if extendedlog then
      fprintf(hlog,"   Results of continuous acceptance test\n\n")
    else
      fprintf(hlog,"Brief results of continuous acceptance test\n\n")
    endif
    i=(atstop-astart)/60000
    fprintf(hlog,"      Total test time:    %ih %02im\n",i/60,i%60)
    fprintf(hlog,"      Total loops:        %i\n",natest*nacomp)
  endif
  if rtfok!=0 then                     // Write results to .RTF protocol
    RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
    RFmt(RTF_TIMES,RTF_BOLD,14)
    if extendedlog then
      RAddtext("Results of continuous acceptance test")
    else
      RAddtext("Brief results of continuous acceptance test")
    endif
    RParagraph(RTF_LEFT)
    RFmt(RTF_TIMES,RTF_NORMAL,12)
    i=(atstop-astart)/60000
    RAddfmt("\n\tTotal test time:\t%ih %02im\n",i/60,i%60)
    RAddfmt("\tTotal loops:\t\t%i\n",natest*nacomp)
  endif
  for i=0,i<5,i++ do Printstatistics(0,i); enddo
  for i=0,i<5,i++ do Printstatistics(1,i); enddo
  for i=0,i<2,i++ do Printstatistics(2,i); enddo
  for i=0,i<3,i++ do Printstatistics(3,i); enddo
  if allowquickc then
    for i=0,i<4,i++ do Printstatistics(4,i); enddo
  endif
  for i=0,i<3,i++ do Printstatistics(5,i); enddo
  Printstatistics(6,0)
  for i=0,i<4,i++ do Printstatistics(7,i); enddo
  Startexplanation()
  Explain("Comments to the tables above: Continuous acceptance test consists ")
  Explain("of multiple loops. Each loop includes multiple resistance, field, ")
  Explain("capacity, high voltage, temperature and video measurements. ")
  Explain("For each component within the loop Script calculates mean value. ")
  Explain("How this mean varies in the time gives us qualitative estimation ")
  Explain("of the tester stability. Columns \"Minimal mean\" and ")
  Explain("\"Maximal mean\" are the extrema of such single-loop means. ")
  Explain("\"Absolute minimum\" and \"Absolute maximum\" are extrema of ")
  Explain("individual measurements, and \"Mean over all measurements\" is ")
  Explain("the mean of all measurements over the whole test time.")
  Endexplanation()
  Oversurface()
  if txtok then
    fprintf(hlog,"\n\n--------------------------------------------------")
    fprintf(hlog,"---------------------------\n-------------------------")
    fprintf(hlog,"----------------------------------------------------\n")
  endif
  // Restore position of left window.
  change hleft position=4,4,LEFTX,LEFTY
  destroy hgraph
  return err
end

// Function asks for new stroke and pressure. Returns 0 on success and -1 if
// operator interrupted test.
function int Changestroke()
  int newv,newp,redraw
  char s[256]
  handle hvelo,hvscr,hpres,hpscr,hok,hcancel
  clear hright
  change hinfo limits=0,0
  change hinfo text="???2a2?y"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="????????2a????Z???2a??\no?1|? "
  //draw text="press " font=MAINFONT text="OK " font=TIMESFONT text="to confirm "
  //draw text="your selection. Or, press " font=MAINFONT text="Cancel "
  //draw font=TIMESFONT text="to restore previous parameters."
  draw at 30,134 font=INFOFONT text="?2a"
  hvelo=control TEXT
    window=hright
    position=94,114,45,24
    help="???Z???????????ao?/??"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hvscr=control VSCROLL
    window=hright
    position=139,114,20,24
    help="??????Z????"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 167,134 text="mm/s"
  draw at 30,164 text="?1|"
  hpres=control TEXT
    window=hright
    position=94,144,45,24
    help="???Z?1|???"
    mode=M_BORDER
    font=MEDIUMFONT
  endc
  hpscr=control VSCROLL
    window=hright
    position=139,144,20,24
    help="??????Z???1|"
    limits=1,-1
    mode=M_NOTAB
  endc
  draw at 167,164 text="g"
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="?"
    help="???????"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="???"
    help="????????"
  endc
  draw show
  newv=strokev
  newp=strokep
  redraw=1
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(hvscr) then
      newv=newv+Status(hvscr)*10; change hvscr select=0
      redraw=1
    else if Pressed(hpscr) then
      newp=newp+Status(hpscr)*10; change hpscr select=0
      redraw=1
    else if Pressed(hok) then
      if newv!=strokev || newp!=strokep then
        strokev=newv
        strokep=newp
        sprintf(s,"STROKE %i,%i,%g",strokev,strokep,strokez)
        SERV.Cmdimm(32,s)
        if (txtok!=0) then
          fprintf(hlog,"\n                           New stroke parameters\n\n")
          fprintf(hlog,"      New Z stroke:       %i mm/s\n",strokev)
          fprintf(hlog,"      New Z pressure:     %i gramm\n\n",strokep)
          fprintf(hlog,"      These stroke parameters apply to all subsequent ")
          fprintf(hlog,"measurements.\n\n-------------------------------------")
          fprintf(hlog,"----------------------------------------\n------------")
          fprintf(hlog,"------------------------------------------------------")
          fprintf(hlog,"-----------\n")
        endif
        if (rtfok!=0) then
          RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
          RFmt(RTF_TIMES,RTF_BOLD,14)
          RAddfmt("\nNew stroke parameters")
          RParagraph(RTF_LEFT)
          RFmt(RTF_TIMES,RTF_NORMAL,12)
          RAddfmt("\n\tNew Z stroke:\t\t%i mm/s\n",strokev)
          RAddfmt("\tNew Z pressure:\t%i gramm\n",strokep)
          RParagraph(RTF_FORMAT)
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RAddtext("\tThese stroke parameters apply to all subsequent ")
          RAddtext("measurements.\n")
        endif
      endif
      return 0
    else if Pressed(hcancel) then
      return 0
    endif
    if redraw then
      newv=Max(10,Min(newv,120))
      newp=Max(10,Min(newp,120))
      change hvelo text=format(" %i",newv)
      change hpres text=format(" %i",newp)
      redraw=0
    endif
    wait
  enddo
end

// Function tests external component (resistor, capacitor or inductivity)
// connected to OlliBoard. Returns 0 on success and -1 if operator interrupted
// test.
function int Testextcomp()
  int i,k,m,n,t,err,type,oldtype,mult,rep,redraw,nbad,totalbad,nlines
  int repeat[10]= {                                                            \
    1, 2, 5, 10, 20, 50, 100, 200, 500, 1000 }
  float r,rexp,dummy,value,factor,pmin,pmax,stat[5],x[32],y[32]
  float e24[108] = {                                 0.000,                    \
    1.000, 1.100, 1.200, 1.300, 1.500, 1.600, 1.800, 2.000,                    \
    2.200, 2.400, 2.700, 3.000, 3.300, 3.600, 3.900, 4.300,                    \
    4.700, 5.100, 5.600, 6.200, 6.800, 7.500, 8.200, 9.100,                    \
    10.00, 11.00, 12.00, 13.00, 15.00, 16.00, 18.00, 20.00,                    \
    22.00, 24.00, 27.00, 30.00, 33.00, 36.00, 39.00, 43.00,                    \
    47.00, 51.00, 56.00, 62.00, 68.00, 75.00, 82.00, 91.00,                    \
    100.0, 110.0, 120.0, 130.0, 150.0, 160.0, 180.0, 200.0,                    \
    220.0, 240.0, 270.0, 300.0, 330.0, 360.0, 390.0, 430.0,                    \
    470.0, 510.0, 560.0, 620.0, 680.0, 750.0, 820.0, 910.0,                    \
    1000., 1100., 1200., 1300., 1500., 1600., 1800., 2000.,                    \
    2200., 2400., 2700., 3000., 3300., 3600., 3900., 4300.,                    \
    4700., 5100., 5600., 6200., 6800., 7500., 8200., 9100.,                    \
    10000, 11000, 12000, 13000, 15000, 16000, 18000, 20000 }
  char s[256]
  char multname[5][4][8] = {                                                   \
    { "Ohm",  "kOhm",  "MOhm",  "GOhm" },                                      \
    { "Ohm",  "kOhm",  "MOhm",  "GOhm" },                                      \
    { "Ohm",  "kOhm",  "MOhm",  "GOhm" },                                      \
    { "pF",   "nF",    "uF",    "mF"   },                                      \
    { "uH",   "mH",    "H",     "kH"   } }
  char typename[5][8] = {                                                      \
    "R",  "ER", "HV", "C",  "L" }
  handle hgraph,htype,hvalue,hvscroll,hmult,hrep,htest,hinit
  handle hline1,hline2,hline3,hline4,hline5,hok,hcancel
  clear hright
  change hinfo limits=0,0
  change hinfo text="a2??a?t"
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="????a2??a?t????????? "
  draw text="(D?????D " font=MAINFONT color=LIGHTRED text="P2 " font=TIMESFONT
  draw color=BLACK text="o " font=MAINFONT color=LIGHTRED text="P3."
  //draw font=TIMESFONT color=BLACK text="on the OlliBoard) as shown on the "
  draw color=BLACK text=")"
  draw text="2????2?????????"
  draw font=MAINFONT text="? " font=TIMESFONT text="?a?2a??"
  draw show
  change hleft position=-1000,*,*,*
  hgraph=control CHILD
    window=hmain
    position=5,5,LEFTX,LEFTY
    help="???o???a2??t"
    color=DARKGRAY
    bkcolor=WHITE
    size=256
  endc
  draw window=hgraph at 28,30 bitmap=0,0,0,"measext"
  draw show
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="?"
    help="???D?"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="???"
    help="????3a2??t?2a?"
  endc
  while 1 do
    if Pressed(hexit) then
      destroy hgraph
      change hleft position=4,4,LEFTX,LEFTY
      return -1
    else if Pressed(hok) then
      destroy hgraph
      change hleft position=4,4,LEFTX,LEFTY
      break
    else if Pressed(hcancel) then
      destroy hgraph
      change hleft position=4,4,LEFTX,LEFTY
      return 0
    endif
    wait
  enddo
  clear hright
  type=0; oldtype=-1
  mult=0
  rep=0
  value=0.0
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="??????D?a?t???(????t)"
  draw text="???-??y?????-?????D2a"
  draw text="?????3??2a??"
  draw text=""
  draw at 9,110 font=INFOFONT text="D:"
  draw at 9,138 font=INFOFONT text="?:"
  draw at 9,166 font=INFOFONT text="?-?:"
  htype=control COMBOLIST
    window=hright
    position=55,90,130,120
    help="????a2??t?D"
  endc
  add htype text="?"
  add htype text="Resistor (exact)"
  add htype text="Resistor (HV)"
  add htype text="Capacitor"
  add htype text="Coil"
  change htype select=type
  hvalue=control EDIT
    window=hright
    position=55,118,70,24
    help="???t??"
    bkcolor=LIGHTYELLOW
    font=MEDIUMFONT
  endc
  hvscroll=control VSCROLL
    window=hright
    position=125,118,20,24
    help="???E24DD??????????"
    limits=1,-1
  endc
  hmult=control COMBOLIST
    window=hright
    position=145,118,70,120
    help="????3?y"
    bkcolor=LIGHTYELLOW
  endc
  hrep=control COMBOLIST
    window=hright
    position=55,146,60,250
    help="?????-?y"
    mode=M_VSCROLL
  endc
  for i=0,i<10,i++ do
    add hrep text=format("%i",repeat[i])
  enddo
  draw at 10,183 rect RIGHTX-10,291
  draw at 15,203 text="??"
  draw at 15,223 text="?D?"
  draw at 15,243 text="?"
  draw at 15,263 text="?D?2?"
  draw at 15,283 text="?2?"
  draw show
  hline1=control TEXT
    window=hright
    position=80,188,170,18
    help="???2a??o???2?(????)"
    bkcolor=LIGHTGRAY
    font=INFOFONT
  endc
  hline2=control TEXT
    window=hright
    position=80,208,170,18
    help="?D?2a??"
    bkcolor=LIGHTGRAY
    font=INFOFONT
  endc
  hline3=control TEXT
    window=hright
    position=80,228,170,18
    help="?2a??"
    bkcolor=LIGHTGRAY
    font=INFOFONT
  endc
  hline4=control TEXT
    window=hright
    position=80,248,170,18
    help="???????D???2?"
    bkcolor=LIGHTYELLOW
    font=INFOFONT
  endc
  hline5=control TEXT
    window=hright
    position=80,268,170,18
    help="?????????2?"
    bkcolor=LIGHTYELLOW
    font=INFOFONT
  endc
  htest=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY+50,120,24
    name="2a?"
    help="???a?2a?"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY+50,120,24
    name="???"
    help="????3a2??t?2a?"
  endc
  redraw=1
  nlines=0
  totalbad=0
  hinit=NULL
  while 1 do
    if Pressed(hexit) then
      return -1
    else if Pressed(htype) then
      type=Status(htype)
      redraw=1
    else if hinit!=NULL && Pressed(hinit) then
      if type==2 then
        SYS.Compile("debug.scr",0)
        SYS.Start("debug",0,"HVINIT")
      endif
    else if Pressed(hvscroll) then
      Text(hvalue,s); value=0.0; sscanf(s,"%g",&value);
      value=Max(0.0,Min(value,20000.0))
      for i=0,i<108,i++ do
        if value<e24[i]-0.01 break
      enddo
      if Status(hvscroll)<0 i=i-2
      i=Max(0,Min(i,107))
      value=e24[i]
      change hvscroll select=0
      redraw=1
    else if Pressed(hmult) then
      mult=Status(hmult)
    else if Pressed(hrep) then
      rep=Status(hrep)
    else if Pressed(htest) then
      Text(hvalue,s); value=0.0; sscanf(s,"%g",&value);
      value=Max(0.0,value)
      change hvalue text=format(" %.5g",value)
      disable htype; disable hvalue; disable hvscroll
      disable hmult; disable hrep; disable htest
      if hinit!=NULL disable hinit
      clear hline1; clear hline2; clear hline3
      clear hline4; clear hline5
      Initsigma(stat)
      nbad=0
      err=0
      // Make measurements.
      for m=0,m<repeat[rep] && err==0,m++ do
        change hinfo limits=m,repeat[rep]
        for k=0,k<$LAY.nfing && err==0,k++ do
          if used[k*2]==0 continue
          Convertpad(x+k*2,y+k*2,"P2",k*2,DELTA)
          Convertpad(x+k*2+1,y+k*2+1,"P3",k*2+1,DELTA)
          n=sprintf(s,"M %i[%g,%g] %i[%g,%g] ",                                \
            k*2,x[k*2],y[k*2],k*2+1,x[k*2+1],y[k*2+1])
          if (type==0) then            // Resistance
            sprintf(s+n,"R(%i,%i)",k*2,k*2+1)
          else if (type==1) then       // Exact resistance
            if testertype>=TT_A5 then
              sprintf(s+n,"E(%i,%i,RMAX=20000,HIR)",k*2,k*2+1)
            else
              sprintf(s+n,"E(%i,%i)",k*2,k*2+1)
            endif
          else if (type==2) then       // HV
            sprintf(s+n,"H(%i,%i)",k*2,k*2+1)
          else if (type==3) then       // Capacity
            sprintf(s+n,"A(%i,0,%i)",k*2,k*2+1)
          else                         // Inductivity
            sprintf(s+n,"RL(%i,%i)",k*2,k*2+1)
          endif
          SYS.Killimm(k*2)
          SERV.Cmdimm(k*2,s)
          if (type==0) then            // Resistance
            sprintf(s+n,"R(%i,%i)",k*2+1,k*2)
          else if (type==1) then       // Exact resistance
            if testertype>=TT_A5 then
              sprintf(s+n,"E(%i,%i,RMAX=20000,HIR)",k*2+1,k*2)
            else
              sprintf(s+n,"E(%i,%i)",k*2+1,k*2)
            endif
          else if (type==2) then       // HV
            sprintf(s+n,"H(%i,%i)",k*2+1,k*2)
          else if (type==3) then       // Capacity
            sprintf(s+n,"A(%i,0,%i)",k*2+1,k*2)
          else                         // Inductivity
            sprintf(s+n,"RL(%i,%i)",k*2+1,k*2)
          endif
          SYS.Killimm(k*2+1)
          SERV.Cmdimm(k*2+1,s)
        enddo
        t=Time()
        while err==0 do                // Wait till all answers come back
          if Pressed(hexit) return -1  // Operator interrupted test
          if Pressed(hcancel) err=-1
          for i=0,i<$LAY.nfing*2,i++ do
            if used[i]==0 continue
            if $A[i].length==0 break
          enddo
          if i>=$LAY.nfing*2 break     // All answers came
          if Time()-t>15000 err=1      // Timeout 15 seconds
          wait
        enddo
        for i=0,i<$LAY.nfing*2,i++ do
          if used[i]==0 continue
          if $A[i].length==0 || $A[i].answer!=S_MOVE then
            nbad++; totalbad++
          else if ($A[i].status & 0x8800) then
            nbad++; totalbad++
          else if type==0 || type==1 || type==2 then
            r=$A[i].r; if ($A[i].status & 0x0100) r=r*1.0e-6
            Addsigma(stat,r)
          else if type==3 then
            SERV.Convertfastc($A[i],&r,&dummy)
            Addsigma(stat,r)
          else
            r=$float4($A[i]+12)/1000.0 // Convert to microhenry
            Addsigma(stat,r)
          endif
        enddo
      enddo
      change hinfo limits=0,0
      // Display results and log to file(s).
      if nlines%25==0 then
        add hlist text=""
        change hlist color=RED
        if nlines==0 then
          add hlist text=""
          add hlist text="         EXTERNAL COMPONENT MEASUREMENTS"
          add hlist text=""
        endif
        add hlist text="Type    Expected      Mean     dMin    dMax  Bad"
        add hlist text=""
        if txtok then
          if nlines==0 then
            fprintf(hlog,"\n                       ")
            fprintf(hlog,"External component measurements\n")
          endif
          fprintf(hlog,"\nType Loops    Mean Units     Min       Max  ")
          fprintf(hlog,"  Sigma Expected dMin%% dMax%%  Bad\n\n")
        endif
        if rtfok then
          if nlines>0 REndtable()
          RParagraph(RTF_CENTERED|RTF_KEEPNEXT)
          RFmt(RTF_TIMES,RTF_BOLD,14)
          if nlines==0 then
            RAddtext("\nExternal component measurements")
          endif
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE|RTF_KEEPNEXT,0.0,5.0)
          RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddtext("Type")
          RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("Loops")
          RCell(RTF_CENTERED|RTF_THINBRD,19.0); RAddtext("Mean")
          RCell(RTF_CENTERED|RTF_THINBRD,13.0); RAddtext("Units")
          RCell(RTF_CENTERED|RTF_THINBRD,18.0); RAddtext("Min")
          RCell(RTF_CENTERED|RTF_THINBRD,18.0); RAddtext("Max")
          RCell(RTF_CENTERED|RTF_THINBRD,16.0)
          RFmt(RTF_SYMBOL,RTF_NORMAL,9); RAddtext("s")
          RFmt(RTF_TIMES,RTF_NORMAL,9)
          RCell(RTF_CENTERED|RTF_THINBRD,17.0); RAddtext("Expected")
          RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("dMin")
          RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddtext("dMax")
          RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddtext("Bad")
        endif
      endif
      nlines++
      rexp=value
      if mult==1 rexp=rexp*1000.0
      if mult==2 rexp=rexp*1000000.0
      if Getcount(stat)==0 then
        pmin=0.0
        pmax=0.0
      else
        pmin=Max(-99,Min((Getmin(stat)-rexp)/(rexp==0.0?0.001:rexp)*100.0,99))
        pmax=Max(-99,Min((Getmax(stat)-rexp)/(rexp==0.0?0.001:rexp)*100.0,99))
      endif
      if rexp>=1.0e9 then k=3; factor=1.0e9;
      else if rexp>=1.0e6 then k=2; factor=1.0e6
      else if rexp>=1.0e3 then k=1; factor=1.0e3
      else k=0; factor=1.0; endif
      change hline1 text=format(" %.5g %.3g %s",                             \
        Getmean(stat)/factor,Getsigma(stat)/factor,multname[type][k])
      change hline2 text=format(" %.5g",Getmin(stat)/factor)
      change hline3 text=format(" %.5g",Getmax(stat)/factor)
      change hline4 text=format(" %.4g %s (%.3g %%)",                          \
        (Getmin(stat)-rexp)/factor,multname[type][k],pmin)
      change hline5 text=format(" %.4g %s (%.3g %%)",                          \
        (Getmax(stat)-rexp)/factor,multname[type][k],pmax)
      change hlist color=BLACK
      sprintf(s,"%2.2s%9.4g %4.4s %9.4g %7.2g%% %6.2g%%  %i",                  \
        typename[type],rexp/factor,multname[type][k],                          \
        Getmean(stat)/factor,pmin,pmax,nbad)
      add hlist text=s
      if txtok then fprintf(hlog,                                              \
        "%-3.3s %4i %9.4g %-4.4s%9.4g %9.4g %8.3g %8.4g %5.2g %5.2g %4i\n",    \
        typename[type],repeat[rep],Getmean(stat)/factor,multname[type][k],     \
        Getmin(stat)/factor,Getmax(stat)/factor,Getsigma(stat)/factor,         \
        rexp/factor,pmin,pmax,nbad)
      endif
      if rtfok then
        RTable(RTF_CENTERED|RTF_BORDER|RTF_SPACE,0.0,5.0)
        RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddtext(typename[type])
        RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddfmt("%i",repeat[rep])
        RCell(RTF_CENTERED|RTF_THINBRD,19.0);
        RAddfmt("%.4g",Getmean(stat)/factor)
        RCell(RTF_CENTERED|RTF_THINBRD,13.0); RAddtext(multname[type][k])
        RCell(RTF_CENTERED|RTF_THINBRD,18.0);
        RAddfmt("%.4g",Getmin(stat)/factor)
        RCell(RTF_CENTERED|RTF_THINBRD,18.0);
        RAddfmt("%.4g",Getmax(stat)/factor)
        RCell(RTF_CENTERED|RTF_THINBRD,16.0)
        RAddfmt("%.2g",Getsigma(stat)/factor)
        RCell(RTF_CENTERED|RTF_THINBRD,17.0); RAddfmt("%.4g",rexp/factor)
        RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddfmt("%.2g%%",pmin)
        RCell(RTF_CENTERED|RTF_THINBRD,12.0); RAddfmt("%.2g%%",pmax)
        RCell(RTF_CENTERED|RTF_THINBRD,11.0); RAddfmt("%i",nbad)
      endif
      enable htype; enable hvalue; enable hvscroll
      enable hmult; enable hrep; enable htest
      if hinit!=NULL enable hinit
    else if Pressed(hcancel) then
      if nlines>0 then
        if rtfok then
          REndtable()
        endif
        Startexplanation()
        Explain("Comments to the table%s above: For each ",nlines>25?"s":"")
        Explain("test, total number of measurements is number of loops times ")
        Explain("%i. Sigma is the standard dispersion of mean ",nused)
        Explain("value, dMin and dMax are minimal and maximal differences ")
        Explain("between measured and expected values in percent. Measurement ")
        Explain("is marked bad if tester was unable to reach stable and ")
        Explain("reliable result.")
        if totalbad>0 then
          Explain(" Bad measurements are excluded from statistics.")
        endif
        Endexplanation()
        Oversurface()
        if txtok then
          fprintf(hlog,"\n---------------------------------------------------")
          fprintf(hlog,"--------------------------\n-------------------------")
          fprintf(hlog,"----------------------------------------------------\n")
        endif
      endif
      break
    endif
    if redraw then
      if type==2 && hinit==NULL then
        hinit=control BUTTON
          window=hright
          position=190,90,50,24
          text="Init"
          help="?a3???????"
        endc
      else if type!=2 && hinit!=NULL then
        destroy hinit
        hinit=NULL
      endif
      if type!=oldtype then
        oldtype=type
        clear hmult
        for i=0,i<3,i++ do
          add hmult text=multname[type][i]
        enddo
      endif
      change hmult select=mult
      change hvalue text=format(" %.5g",value)
      change hrep select=rep
      redraw=0
    endif
    wait
  enddo
end

// Unloads board from the shuttle. Used in the case of L&M automation. Returns
// -1 if user interrupted the script and 0 in any other case.
function int Unloadboard()
  int i,j,t
  char buf[256],errtxt[256]
  if ($LAY.config & LC_LDMASK)!=LC_LMAUTO &&                                   \
    ($LAY.config & LC_LDMASK)!=LC_SPLITAUTO                                    \
    return 0                           // Does not apply
  // Check whether there is a board in the shuttle. It may happen that previous
  // test was interrupted. In this case, don't change any settings!
  SYS.Killimm(32)
  buf[0]=S_INPORT
  $uint2(buf+1)=0x00F0                 // Hardware control port
  SYS.Sendimm(32,3,buf)
  t=Time()
  while 1 do
    if $A[32].length>0 break
    if Pressed(hexit) return -1
    if Time()-t>5000 break
    wait
  enddo
  if $A[32].answer==S_INPORT && ($A[32].inport & 0x35)==0 then
//    return 0                           // Shuttle is empty
  endif
  Drawboard()
  // Make soft reset before sending commands to automation directly: heads may
  // still move!
  clear hright
  change hinfo limits=0,0
  change hinfo text="?t???"
  SYS.Softimm(32); softreset=1
  t=Time(); i=0
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Button "Exit" works as an interrupt
    j=(Time()-t)/1000
    if i!=j then
      change hinfo text=format("y?t??? - %i s",j)
      i=j
    endif
    if j>15 return 0                   // Too long soft reset
    wait
  enddo
  change hinfo limits=0,0
  change hinfo text="Unloading OlliBoard..."
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="OlliBoard will be unloaded from the shuttle. To avoid damages, "
  draw text="please remove it from the shuttle."
  draw show
  if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO &&           \
    pulledshuttle>=0                                                           \
  then
    sprintf(buf,"MECH.Cmd=A8eaRestorePullCalib %i 1",pulledshuttle)
    i=Sendlmcommand(buf,"MECH.Ready.A8eaRestorePullCalib",errtxt,0xFFFF)
    if i<0 return -1
    pulledshuttle=-1
  endif
  // For the case that tester is in the adjustment mode.
  i=Sendlmcommand("MECH.Cmd=SetMode 2","MECH.Ready.SetMode",errtxt,5)
  if i<0 return -1
  SYS.Killimm(32)
  buf[0]=S_LOCKDOOR
  buf[1]=0                             // Unlock door
  SYS.Sendimm(32,2,buf)
  while $A[32].length==0 do
    if Pressed(hexit) return -1        // Interrupt
    wait
  enddo
  return 0
end

// Warns user about unloading board from the shuttle. Used in the case of EPCOS
// tester. Returns -1 if user interrupted the script and 0 in any other case.
function int UnloadboardEPCOS()
  handle hok
  if ($LAY.config & LC_LDMASK)!=LC_EPCOSAUTO then
    return 0                           // Does not apply
  endif
  change hinfo limits=0,0
  change hinfo text="Please remove holder!"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Please don't forget to remove OlliBoard and its holder from the "
  draw text="shuttle. " color=LIGHTRED text="Attempt to unlock table when "
  draw text="holder is installed may seriously damage the tester!"
  draw show
  hok=control BUTTON
    window=hright
    position=(RIGHTX-120)/2,USERY,120,24
    name="?"
    help="???D?"
  endc
  while 1 do
    if Pressed(hexit) return -1        // Interrupt
    if Pressed(hok) break
    wait
  enddo
  return 0
end

// Alows to find position of two pads on the Olliboard using video cameras
// (either dedicated or headcams). Both pads are on the top side. Returns 0 on
// success and -1 if user cancelled script. Layout of pad arrays: x,y - in
// millimeters.
function int Dallasposition(float *pad1,float *pad2)
  int i,x,y,head,selected,changed,firstpos,changepos,prevhead,ret
  int channel,side,newvideo,newlights,videosizex,videosizey
  float miny,maxy,posx,posy,vstep,zoom,defzoom,angle
  char buf[256]
  handle hx,hy,hu,hl,hr,hd,hpos1,hpos2,hok
  handle hview,hlivevideo,hzoom
  clear hleft
  clear hright
  wait; wait; wait                     // Force redraw to avoid overlapping
  change hinfo limits=0,0
  change hinfo text="Find contacts of on-board ROM"
  ret=0
  channel=0
  // If positioned for the first time, set expected pad positions.
  pad1[0]=$LAY.xoffset/1000.0-(crossx[1]-crossx[0])/2.0-45.0
  pad1[0]=Max(leftvlimit,Min(pad1[0],rightvlimit))
  pad2[0]=$LAY.xoffset/1000.0-(crossx[1]-crossx[0])/2.0+110.0
  pad2[0]=Max(leftvlimit,Min(pad2[0],rightvlimit))
  if $LAY.cameras!=0 then
    miny=$LAY.bottom[$LAY.nfing]/1000.0
    maxy=$LAY.top[$LAY.nfing]/1000.0
  else
    miny=$LAY.bottom[0]/1000.0
    maxy=$LAY.top[0]/1000.0
    for i=1,i<$LAY.nfing,i++ do
      miny=Min(miny,$LAY.bottom[i]/1000.0)
      maxy=Max(maxy,$LAY.top[i]/1000.0)
    enddo
  endif
  pad1[1]=Max(miny,Min(yshift,maxy))
  pad2[1]=Max(miny,Min(yshift,maxy))
  // Get old pad positions.
  getini("Meastest","Left pad","%g,%g",pad1+0,pad1+1)
  getini("Meastest","Right pad","%g,%g",pad2+0,pad2+1)
  draw window=hright color=BLACK font=TIMESFONT
  draw at 6,30 wrap=RIGHTX-5
  draw text="Find position of contacts belonging to the on-board ROM ("
  draw font=MAINFONT text="Pad 1" font=TIMESFONT text=", left) and ground "
  draw text="wire (" font=MAINFONT text="Pad 2" font=TIMESFONT text=", right). "
  draw text="Press OK when ready."
  draw color=DARKGRAY font=INFOFONT at 18,USERY-121 text="? X="
  hx=control TEXT
    window=hright
    position=83,USERY-140,54,22
    help="????X?"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 140,USERY-121 text=", Y="
  hy=control TEXT
    window=hright
    position=168,USERY-140,54,22
    help="????Y?"
    font=MEDIUMFONT
    mode=M_BORDER|M_CENTERED
    bkcolor=PINK
  endc
  draw at 227,USERY-121 text="mm"
  draw show
  hu=control BUTTON
    window=hright
    position=60,USERY-78,40,40
    name="?"
    help="??????????"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hl=control BUTTON
    window=hright
    position=18,USERY-35,40,40
    name=""
    help="?????????"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hr=control BUTTON
    window=hright
    position=102,USERY-35,40,40
    name=""
    help="?????????"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hd=control BUTTON
    window=hright
    position=60,USERY+7,40,40
    name="??"
    help="????????????"
    font=MEDIUMFONT
    mode=M_REPEAT
  endc
  hpos1=control BUTTON
    window=hright
    position=166,USERY-70,RIGHTX-180,24
    name="2a?1"
    help="???2????o??(ROM)?????"
    color=LIGHTRED
    bkcolor=YELLOW
  endc
  selected=1
  hpos2=control BUTTON
    window=hright
    position=166,USERY-37,RIGHTX-180,24
    name="2a?2"
    help="??????t??o???????(??)"
  endc
  hok=control BUTTON
    window=hright
    position=166,USERY+16,RIGHTX-180,24
    name="?"
    help="??D???????????"
  endc
  disable hok
  hview=control CHILD
    window=hleft
    position=0,0,LEFTX,LEFTY
    help=" "
    color=BROWN
    bkcolor=LIGHTYELLOW
    size=128
  endc
  hlivevideo=control GRAPH
    window=hview
    position=5,5,LEFTX-10,288
    bkcolor=VIDEOFILL
    help="??????"
  endc
  Bccreate(hview,-1,-1,channel,1)
  hzoom=control CUSTOMBOX
    window=hview
    position=235,303,80,21
    name="?"
    help="????y???2?"
    color=BROWN
  endc
  x=(LEFTX-10)/2; y=288/2
  draw window=hlivevideo color=LIGHTRED
  draw at x-20,y to x-5,y at x+6,y to x+21,y
  draw at x,y-20 to x,y-5 at x,y+6 to x,y+21
  draw show
  changepos=1                          // Force camera movement
  firstpos=1                           // Change second offset simultaneously
  SYS.Killimm(32); $A[32].length=1     // Mark answer as available
  newvideo=1                           // Change camera settings
  newlights=1                          // Change illumination settings
  prevhead=-1                          // Previous head is as yet undefined
  SYS.Videosize(channel,&videosizex,&videosizey,&i)
  if videosizex==0 || videosizey==0 then
    defzoom=0.5
  else
    defzoom=Max((LEFTX-8.0)/videosizex,290.0/videosizey)
  endif
  while 1 do
    changed=Bcupdate()
    if (changed & 0x01)!=0 newvideo=1
    if (changed & 0x02)!=0 then
      changepos=1
      newlights=1
    endif
    if changepos==0 && $A[32].length>1 then
      enable hok
    endif
    if Pressed(hexit) then
      ret=-1; break
    else if Pressed(hok) then
      setini("Meastest","Left pad","%g,%g",pad1[0],pad1[1])
      setini("Meastest","Right pad","%g,%g",pad2[0],pad2[1])
      break
    else if Pressed(hpos1) && selected!=1 then
      change hpos1 color=LIGHTRED
      change hpos1 bkcolor=YELLOW
      change hpos2 color=BLACK
      change hpos2 bkcolor=GRAY
      selected=1; changepos=1; firstpos=0
    else if Pressed(hpos2) && selected!=2 then
      change hpos2 color=LIGHTRED
      change hpos2 bkcolor=YELLOW
      change hpos1 color=BLACK
      change hpos1 bkcolor=GRAY
      selected=2; changepos=1; firstpos=0
    else if Pressed(hzoom) then
      newvideo=1
    endif
    if selected==1 then
      posx=pad1[0]; posy=pad1[1]
    else
      posx=pad2[0]; posy=pad2[1]
    endif
    vstep=VSTEP/10.0
    if Pressed(hu) then
      i=Max(Status(hu)-3,1)
      if (firstpos) pad2[1]=pad2[1]+vstep*i
      posy=posy+vstep*i; changepos=1
    else if Pressed(hl) then
      i=Max(Status(hl)-3,1)
      if (firstpos) pad2[0]=pad2[0]-vstep*i
      posx=posx-vstep*i; changepos=1
    else if Pressed(hr) then
      i=Max(Status(hr)-3,1)
      if (firstpos) pad2[0]=pad2[0]+vstep*i
      posx=posx+vstep*i; changepos=1
    else if Pressed(hd) then
      i=Max(Status(hd)-3,1)
      if (firstpos) pad2[1]=pad2[1]-vstep*i
      posy=posy-vstep*i; changepos=1
    endif
    if changepos!=0 then
      if selected==1 then
        pad1[0]=posx; pad1[1]=posy
      else
        pad2[0]=posx; pad2[1]=posy
      endif
      pad1[0]=Max(leftvlimit,Min(pad1[0],rightvlimit))
      pad1[1]=Max(miny,Min(pad1[1],maxy))
      pad2[0]=Max(leftvlimit,Min(pad2[0],rightvlimit))
      pad2[1]=Max(miny,Min(pad2[1],maxy))
      if selected==1 then
        posx=pad1[0]; posy=pad1[1]
      else
        posx=pad2[0]; posy=pad2[1]
      endif
      change hx text=format("%5.1f",posx)
      change hy text=format("%5.1f",posy)
      if $A[32].length!=0 then
        // Previous movement is finished, start new.
        head=Camerafromy(posy,&channel,&side,&angle)
        if head<0 then
          ;
        else if $LAY.cameras!=0 then   // Dedicated camera
          sprintf(buf,"M %i(%g,%g) NOP",head,posx,posy)
        else                           // Head camera, move other heads away
          if head!=prevhead || newlights then
            for i=0,i<$LAY.nfing*2,i++ do
              if i==head continue
              sprintf(buf,"M %i(Z) NOP",i)
              SERV.Cmdimm(33,buf)
            enddo
            if prevhead>=0 then
              sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,0",prevhead)
              SERV.Cmdimm(33,buf)
            endif
            sprintf(buf,"OUTPORT32 HEAD(%i) 0x80000002,%i",head,illtype)
            SERV.Cmdimm(33,buf)
            prevhead=head
            newlights=0
          endif
          sprintf(buf,"M @%i[%g,%g] NOP",head,posx,posy)
          newvideo=1
        endif
        SERV.Cmdimm(32,buf)
        changepos=0
      endif
    endif
    if newvideo then
      Camerafromy(posy,&channel,&side,&angle)
      zoom=(Status(hzoom)==0?defzoom:defzoom*2.0)
      Bcsetcam(channel)
      SYS.Videoangle(hlivevideo,channel,side,zoom,                             \
        Bcgetbri(channel),Bcgetctr(channel),                                   \
        (channel<0?0:2)|(longexp?4:0),angle)
      newvideo=0
    endif
    wait
  enddo
  if $LAY.cameras==0 && $LAY.headcameras!=0 then
    SERV.Cmdimm(33,"OUTPORT32 ALL 0x80000002,0")
  endif
  Bcdelete()
  destroy hview
  return ret
end

// Asks for pasword to unlock Dallas memory. Returns ACT_EDITROM on success and
// ACT_QUIT otherwise.
function int Unlockdallas()
  int i,j
  handle hpassword,hok,hcancel
  change hinfo limits=0,0
  change hinfo text="Unlock on-board ROM"
  clear hright
  draw window=hright font=TIMESFONT wrap=RIGHTX-5
  draw at 6,30 color=BLACK
  draw text="Enter password to unlock on-board ROM. Press " font=MAINFONT
  draw text="OK " font=TIMESFONT text="when ready, or " font=MAINFONT
  draw text="Quit " font=TIMESFONT text="to close script."
  draw font=INFOFONT at 20,130 text="Password to unlock:"
  hpassword=control EDIT
    window=hright
    position=155,110,91,24
    text=wordofwisdom
    help="???????a????1|?"
    mode=M_BORDER|M_PASSWORD
  endc
  draw show
  hok=control BUTTON
    window=hright
    position=RIGHTX/2-124,USERY,120,24
    name="?"
    help="??????"
  endc
  hcancel=control BUTTON
    window=hright
    position=RIGHTX/2+5,USERY,120,24
    name="??"
    help="3????"
  endc
  while 1 do
    if Pressed(hexit) return ACT_QUIT
    if Pressed(hcancel) return ACT_QUIT
    if Pressed(hpassword) || Pressed(hok) then
      // Hmm, this security is really unique!
      Text(hpassword,wordofwisdom)
      j=0
      for i=0,i<100 && wordofwisdom[i]!='\0',i++ do
        j=((j<<3)|(j>>29)) ^ wordofwisdom[i]
      enddo
      if j==0x003D4FB0 then
        return ACT_EDITROM
      else
        change hinfo text="Invalid password!"
      endif
    endif
  enddo
end

// Main routine.
function int main()
  int i,j,n,fullset,zheadtype,action,repeat,dallasonly
  char s[512]
  for i=0,i<NPOINT,i++ do              // Extract pad coordinates and values
    sscanf(xname[i]+7,"%f %f",xpos+i,value+i)
    for j=0,j<7,j++ do
      if xname[i][j]==' ' break
    enddo
    xname[i][j]='\0'                   // Limit pad names
  enddo
  hmain=control WINDOW
    window=NULL
    position=10,10,MAINX,MAINY
    name=format("2a??32a?v%s",VERSION)
    help=" "
    size=128
  endc
  hleft=control CHILD
    window=hmain
    position=5,5,LEFTX,LEFTY
    help=" "
    color=DARKGRAY
    size=4096
  endc
  hserv=control CHILD
    window=hmain
    position=SPLIT,5,RIGHTX,SERVY
    help=" "
    color=DARKGRAY
  endc
  hright=control CHILD
    window=hmain
    position=SPLIT,10+SERVY,RIGHTX,RIGHTY
    help=" "
    color=DARKGRAY
    size=2048
  endc
  hinfo=control PROGRESS
    window=hserv
    position=-1,-1,RIGHTX+2,SERVY+2
    text="??-1?!"
    help="2a??3???"
    mode=M_PERCENT
    font=MEDIUMFONT
    limits=0,0
  endc
  hexit=control BUTTON
    window=hmain
    position=MAINX-84,MAINY-SERVY,80,SERVY-3
    name="1??"
    help="??????12a?21????"
    mode=M_DBLCLICK
  endc
  draw window=hmain bitmap=0,0,1,"bkground" show
  layoutchanged=0
  loadchanged=0
  globalerr=0
  measadjusted=0
  intladjusted=0
  softtouch=0
  boardtype=0
  rompresent=1                         // As long as opposite not stated
  notcertified=0                       // Ditto
  singlecert=0
  lowvolt=0
  differentiall=0
  utestmax=1.0
  rtestmax=200.0
  individualbc=1                       // Individual brightness and contrast
  illtype=0x07                         // Top illumunation
  updatefocus[0]=1                     // Focus is not yet set
  updatefocus[1]=1
  nreplay=0
  allowrepeat=1
  linewidth=0.300
  pulledshuttle=-1
  Bcgetini()                           // Read brightness & contrast from .ini
  Clearoversurface()                   // Clear contact-over-surface counters
  change hleft help="? (C) 2019 HengCe"
  draw window=hleft
  draw at 75,60 bitmap=0,0,0,"logo"
  draw color=DARKGRAY font=MEDIUMFONT mode=M_CENTERED
  draw at LEFTX/2,285 text="2a??32a?"
  draw at LEFTX/2,308 text=format("?? %s",VERSION)
  //draw at LEFTX/2,331 text="(A1+,A2,A3,A4,A5,A6,A7,A8,S1,S2,S3)"
  draw show
  delay 1000
reload:
  if Loadtester()!=0 goto quit         // Make sure that tester is loaded
  if Embedded()!=0 then
    SERV.Cmdimm(32,"$LIGHTS TESTING")  // Update state of traffic lights
  endif
  globalerr=globalerr & (~GE_BOOT)     // Tester is just loaded
  i=Checkgloberrors()                  // Check for errors except boot errors
  if i<0 goto quit                     // Operator interrupted the test
  if i>0 goto reload                   // Try to reload tester
  i=Getlayout()                        // Get actually loaded layout
  if i<0 goto quit                     // Operator interrupted the test
  if i>0 goto reload                   // Try to reload tester
  Getautomationtype()                  // Get type of automation
  Recognizetester()                    // Determine type of the tester
  if testertype==TT_WRONG goto quit    // Don't know how to test
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8                                     \
  then
    usestat=1                          // Supports statistical data
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,1")
  else
    usestat=0                          // Does not support statistical data
  endif
  // Soft touch needles or needles on splinogramm adapter have higher own
  // capacity. After layout is loaded, I correct value of points C0Px. Note
  // that we should do it only once!
  zheadtype=$EXTLAY.zheadtype
  if ($EXTLAY.extcfg & EXT_CAIR)!=0 &&                                         \
    (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8)                                    \
  then
    // Capacity calibration in the air.
    for i=0,i<NPOINT,i++ do            // Find pad C0Px
      if Strcmp(xname[i],"C0P1")!=0 && Strcmp(xname[i],"C0PA")!=0 continue
      value[i]=CAIRCORR
    enddo
  else if softtouch==0 && (testertype==TT_A5 || testertype==TT_A5L ||          \
    testertype==TT_A6 || testertype==TT_S1 || testertype==TT_S2 ||             \
    testertype==TT_S3 || testertype==TT_A7 || testertype==TT_A8) &&            \
    (((zheadtype & HCZ_VALID)!=0 &&                                            \
    ((zheadtype & HCZ_CONTMASK)==HCZ_CONTSPL ||                                \
    (zheadtype & HCZ_CONTMASK)==HCZ_CONTHSPL ||                                \
    (zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP)) ||                               \
    ((zheadtype & HCZ_VALID)==0 && ($LAY.config & 0x00000100)!=0)) then
    // A5/A6 with soft touch needles (splinogramms).
    for i=0,i<NPOINT,i++ do            // Find pad C0Px
      if Strcmp(xname[i],"C0P1")!=0 && Strcmp(xname[i],"C0PA")!=0 continue
      if (zheadtype & HCZ_CONTMASK)==HCZ_CONTSKP && $LAY.probetype==1 then
        value[i]=value[i]+KELVINSKPC
      else if testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 then
        value[i]=value[i]+SOFTTOUCHCS
      else
        value[i]=value[i]+SOFTTOUCHCA
      endif
    enddo
    softtouch=1
  else if splineemu==0 && (testertype==TT_A5 || testertype==TT_A5L ||          \
    testertype==TT_A6 || testertype==TT_S1 || testertype==TT_S2 ||             \
    testertype==TT_S3 || testertype==TT_A7 || testertype==TT_A8) &&            \
    ((zheadtype & HCZ_VALID)!=0 &&                                             \
    (zheadtype & HCZ_CONTMASK)==HCZ_CONTEMU) then
    // A5/A6 with splinogramm adapters (standard needles on spline fixture).
    for i=0,i<NPOINT,i++ do            // Find pad C0Px
      if Strcmp(xname[i],"C0P1")!=0 && Strcmp(xname[i],"C0PA")!=0 continue
      value[i]=value[i]+ADAPTERC
    enddo
    splineemu=1
  endif
  Getfeatures()                        // Get features of measurement card
  i=Setrails()                         // Set rails to test
  if i<0 goto quit                     // Operator interrupted the test
  i=Getboardtype()                     // Get board type (2 or 3 rows)
  if i<0 goto quit                     // Operator interrupted the test
  dallasonly=(i==1)
  // Correct coordinates of scan crosses for the case of BEL204 or S2 sawed off
  // board.
  if boardtype==5 then
    for i=0,i<8,i++ do
      crossx[i]=crossx2[i]
      crossy[i]=crossy2[i]
    enddo
  else if boardtype==3 then
    for i=0,i<8,i++ do
      crossx[i]=crossx1[i]
      crossy[i]=crossy1[i]
    enddo
  else if boardtype==2 then
    for i=0,i<8,i++ do
      crossx[i]=crossx0[i]
      crossy[i]=crossy0[i]-155.0
    enddo
  else
    for i=0,i<8,i++ do
      crossx[i]=crossx0[i]
      crossy[i]=crossy0[i]
    enddo
  endif
  if dallasonly then
    // User only wants to manage Dallas EEPROM data. There is no verifications,
    // user must select two programming pads manually.
    i=Dallasposition(dallaspad1,dallaspad2)
    if i<0 goto quit
    i=Unlockdallas()
    if i<0 goto quit
    Editdallasmemory(1)                // Edit contents of Dallas memory
    goto quit
  endif
  // For no particular reason (thank you, Robin), some versions of OlliBoard
  // have layout that differs from the standard. Correct it now.
mainproc:
  for i=0,i<NPOINT,i++ do              // Re-extract pad coordinates
    sscanf(xname[i]+7,"%f",xpos+i)
    if boardtype==4 then
      if Strcmp(xname[i],"RX0R01")==0 then
        xpos[i]=186.08
      else if Strcmp(xname[i],"RX0R1")==0 then
        xpos[i]=195.40
      else if Strcmp(xname[i],"RX1R")==0 then
        xpos[i]=205.4
      else if Strcmp(xname[i],"RX10R")==0 then
        xpos[i]=215.5
      endif
    endif
  enddo
  // Correct capacities that depend on board type.
  if (boardtype==2 || boardtype==3) && ccorrected==0 then
    for i=0,i<NPOINT,i++ do            // Find pad C0Px
      if Strcmp(xname[i],"SIDER")==0 then
        value[i]=value[i]-(boardtype==2?2.5:1.8)
      else if Strcmp(xname[i],"C27P")==0 then
        value[i]=value[i]-(boardtype==2?2.0:0.0)
      endif
    enddo
  endif
  if boardtype==5 && ccorrected==0 then
    for i=0,i<NPOINT,i++ do
      if Strcmp(xname[i],"SIDER")==0 then
        value[i]=13.5
      else if Strcmp(xname[i],"C27P")==0 then
        value[i]=53.0
      else if Strcmp(xname[i],"C270P")==0 then
        value[i]=285.0
      else if Strcmp(xname[i],"+Rsgl")==0 then
        value[i]=0.140
      else if Strcmp(xname[i],"+Rthin")==0 then
        value[i]=0.070
      else if Strcmp(xname[i],"+Rwide")==0 then
        value[i]=0.005
      endif
    enddo
  endif
  ccorrected=1
  Drawboard()
reinstall:
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    ($LAY.config & LC_LDMASK)==LC_LMAUTO then
    i=InstallboardLM()                 // Install OlliBoard in L&M shuttle
  else if testertype==TT_A8 && ($LAY.config & LC_LDMASK)==LC_LMS2AUTO &&       \
    (automationtype==AUTO_A8LMMAN || automationtype==AUTO_A8LMSEMI ||          \
    automationtype==AUTO_A8LMFULL) then
    i=InstallboardLM()                 // Install board in A8a shuttle
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    i=InstallboardLM()                 // Install board in split shuttle
  else if (testertype==TT_A7 || testertype==TT_A8) &&                          \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    i=InstallboardLM()                 // Install OlliBoard in split shuttle
  else if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    i=InstallboardEPCOS()              // Install OlliBoard in EPCOS shuttle
  else
    i=Installboard()                   // Install OlliBoard
  endif
  if i<0 goto quit                     // Operator interrupted the test
  if i>0 goto reload                   // Bad or no answer, try to reload tester
  i=Positionboard()                    // Manually find position of the board
  if i<0 goto quit                     // Operator interrupted the test
  if i==2 goto reinstall               // Board position must be changed
  i=Scanboard(i)                       // Find exact board position
  if i<0 goto quit                     // Operator interrupted the test
  if i==1 goto reinstall               // Crosses not found, retry
  if i==2 goto quit                    // Operator stopped the test
recheck:
  i=Electrocheck()                     // Check board presence electrically
  if i<0 goto quit                     // Operator interrupted the test
  if i==1 goto reinstall               // Board position must be changed
  if i==2 goto recheck                 // Repeat electrical presence check
  Drawboard()
rescan:
  i=Readdallasmemory(0)                // Try to read data from Dallas memory
  if i<0 goto quit                     // Operator interrupted the test
  if i==0 then
    i=Verifyexpirydate()               // Check whether certification valid
    if i<0 goto quit                   // Operator interrupted the test
  else                                 // Missing or unreadable Dallas memory
    i=Readboardcode()                  // Scan 16 board identification bits
    if i<0 goto quit                   // Operator interrupted the test
    if i==1 goto reinstall             // Board must be replaced or repositioned
    if i==2 goto rescan                // Repeat scanning of ID code
  endif
  i=Openprotocols()                    // Create protocol files
  if i<0 goto quit                     // Operator interrupted the test
  for i=0,i<NPOINT,i++ do              // Use calibration data, if present
    if calvalid[i]!=0 value[i]=calibration[i]
  enddo
  allowquickc=Isquickcavailable()      // Check if quick C supported
  if Setfcparameters(0.0,0.0)==0 then  // Check if variable short supported
    allowvarshort=1                    // Yes, test at 10 and 50 M
  else
    allowvarshort=0                    // No, 10 M tests only
  endif
  repeat=1                             // Default number of single test loops
mainloop:
  if hlist!=NULL add hlist text=""
actionloop:
  action=Selectaction()                // Select what to do
actionadjust:
  if action==ACT_SELADJ then           // Parameter adjustment
    action=Selectadjust()
    if action==ACT_BACK goto actionloop
  else if action==ACT_SELACCEPT then   // Voltage for continuous test
    action=Selectacceptance()
    if action==ACT_BACK goto actionloop
  else if action==ACT_SELSINGLE then   // Extended list of actions
    action=Extraaction(&repeat)
    if action==ACT_BACK goto actionloop
  endif
  if hlist==NULL then
    clear hleft
    hlist=control LIST                 // Intermediate protocol in window
      window=hleft
      position=-1,-1,LEFTX+2,LEFTY+2
      help="?D??2a??1?"
      font=TERMINALFONT
      mode=M_VSCROLL
      size=65536
    endc
  endif
  Clearsummary()                       // Clear previous summary information
  change hlist color=BLACK
  add hlist text="================================================="
  add hlist text=""
  switch action
  case ACT_QUIT:    goto quit          // Operator interrupted the test
  case ACT_RADJ:    goto adjmeas       // Adjust parameters of measurement card
  case ACT_FADJ:    goto adjf          // Adjust input capacity of on-heads
  case ACT_LADJ:    goto adjl          // Adjust internal inductivity
  case ACT_LXADJ:   goto adjlx         // Adjust external inductivity
/*
  case ACT_UCADJ:   goto adjuc         // Adjust universal capacity
*/
  case ACT_PROTM:   goto protm         // Protocol measurement parameters
  case ACT_EDITROM: goto editrom       // Edit contents of Dallas memory
  case ACT_MANNOIS: goto mannois       // Make manual noise test
  case ACT_NEEDLES: goto needles       // Check contacting
  case ACT_QUICK:   goto quick         // Quick electronics test
  case ACT_LONG:    goto long          // Long electronics test
  case ACT_ACC250:  goto accept250     // Continuous acceptance test 250 V HV
  case ACT_ACC500:  goto accept500     // Continuous acceptance test 500 V HV
  case ACT_CERTIFY: goto certify       // Certification
  case ACT_EXTERN:  goto extcomp       // Test external components
  case ACT_R:       goto singler       // Ordinary resistance test
  case ACT_MULTI:   goto singlemref    // Multireference resistance test
  case ACT_E:       goto singleer      // Exact resistance test
  case ACT_KELVIN:  goto singlekelvin  // Low-ohmical Kelvin test
  case ACT_4WIRE:   goto singlefour    // Low-ohmical 4-wire test
  case ACT_RC:      goto singlerc      // Ordinary R||C test
  case ACT_EC:      goto singleerc     // Exact R||C test
  case ACT_F:       goto singlef       // Field test
  case ACT_C:       goto singlec       // Capacity test
  case ACT_CRT:     goto singlecrt     // CRT test
  case ACT_UNIC:    goto unic          // Universal capacity test
  case ACT_OWNC:    goto ownc          // Own capacity of the needle
  case ACT_RL:      goto singlel       // Inductivity test
  case ACT_HV:      goto singlehv      // High voltage test
  case ACT_NOISE:   goto noise         // Find noisy heads
  case ACT_CLEAN:   goto clean         // Clean needles
  case ACT_REPLAY:  goto repeatbad     // Repeat bad measurement
  case ACT_STROKE:  goto setstroke     // Set stroke
  default: goto mainloop
  endsw
adjmeas:
  i=Adjustmeas()                       // Adjust parameters of measurement card
  if i<0 goto quit                     // Operator interrupted the script
  action=ACT_SELADJ                    // Select another adjust operation
  goto actionadjust
adjf:                                  // Adjust input capacity of on-heads
  i=Adjustinputc()                     // Adjust input capacity
  if i<0 goto quit                     // Operator interrupted the script
  action=ACT_SELADJ                    // Select another adjust operation
  goto actionadjust
adjl:
  i=Adjustinductivity(0)               // Adjust internal inductivity
  if i<0 goto quit                     // Operator interrupted the script
  action=ACT_SELADJ                    // Select another adjust operation
  goto actionadjust
adjlx:
  i=Adjustinductivity(1)               // Adjust external inductivity
  if i<0 goto quit                     // Operator interrupted the script
  action=ACT_SELADJ                    // Select another adjust operation
  goto actionadjust
/*
adjuc:
  i=Adjustuniversalc()                 // Adjust universal capacity
  if i<0 goto quit                     // Operator interrupted the script
  action=ACT_SELADJ                    // Select another adjust operation
  goto actionadjust
*/
protm:
  Protocolmeasparms(1)                 // Protocol measurement parameters
  action=ACT_SELADJ                    // Select another adjust operation
  goto actionadjust
editrom:
  i=Editdallasmemory(0)                // Edit contents of Dallas memory
  if i<0 goto quit                     // Operator interrupted the script
  action=ACT_SELADJ                    // Select another adjust operation
  goto actionadjust
mannois:
  i=Manualnoise()                      // Make manual noise test
  if i<0 goto quit                     // Operator interrupted the script
  action=ACT_SELADJ                    // Select another adjust operation
  goto actionadjust
needles:
  i=Checkneedles()                     // Check contacting
  if i<0 goto quit                     // Operator interrupted the script
  goto mainloop
quick:                                 // Quick electronics test
  i=Rtest(4,0,0,0,0,0)                 // Fast ordinary measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Rtest(2,1,0,0,0,0)                 // Fast accurate measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  if ($LAY.probetype & 1)!=0 && (boardtype==3 || boardtype==4) then
    i=Lowkelvin(4,0,0,0,0)             // Kelvin measurements
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  else if ($LAY.probetype & 1)==0 && $LAY.nfing>=2 && (testertype==TT_A5 ||    \
    testertype==TT_A5L || testertype==TT_A6 || testertype==TT_S1 ||            \
    testertype==TT_S2 || testertype==TT_S3 || testertype==TT_A7 ||             \
    testertype==TT_A8) && (boardtype==3 || boardtype==4) then
    i=Lowkelvin(4,0,1,0,0)             // 4-wire measurements
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  i=RCtest(2,0,0,0.0,0,0)              // Fast ordinary R||C measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=RCtest(1,1,0,0.0,0,0)              // Fast accurate R||C measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Ftest(8,0,0)                       // Fast field test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Ctest(4,0,0,0)                     // Fast capacity test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Crttest(4,0,0)                     // Charge rise time test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Unictest(2,0,0)                    // Universal capacity test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=HVtest(2,0,0)                      // Fast high voltage test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  Printsummary("SUMMARY: Quick electronics test")
  goto mainloop
long:                                  // Long electronics test
  i=Rtest(10,0,0,0,0,0)                // Long ordinary measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Rtest(10,1,0,0,0,0)                // Long accurate measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  if ($LAY.probetype & 1)!=0 && (boardtype==3 || boardtype==4) then
    i=Lowkelvin(20,0,0,0,0)            // Kelvin measurements
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  else if ($LAY.probetype & 1)==0 && $LAY.nfing>=2 && (testertype==TT_A5 ||    \
    testertype==TT_A5L || testertype==TT_A6 || testertype==TT_S1 ||            \
    testertype==TT_S2 || testertype==TT_S3 || testertype==TT_A7 ||             \
    testertype==TT_A8) && (boardtype==3 || boardtype==4) then
    i=Lowkelvin(20,0,1,0,0)            // 4-wire measurements
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  i=RCtest(10,0,0,0.0,0,0)             // Long ordinary R||C measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=RCtest(10,1,0,0.0,0,0)             // Long accurate R||C measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Ftest(32,0,0)                      // Long field test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Ctest(32,0,0,0)                    // Long capacity test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Crttest(32,0,0)                    // Charge rise time test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Unictest(16,0,0)                   // Universal capacity test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=HVtest(16,0,0)                     // Long high voltage test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  Printsummary("SUMMARY: Long electronics test")
  goto mainloop
accept250:                             // Continuous acceptance test 250 V HV
  i=Acceptancetest(250)                // Ditto
  if i<0 goto quit                     // Operator interrupted the script
  goto mainloop
accept500:                             // Continuous acceptance test 500 V HV
  i=Acceptancetest(500)                // Ditto
  if i<0 goto quit                     // Operator interrupted the script
  goto mainloop
certify:                               // Certification
  allowrepeat=1
  i=Excludetests()
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted certification
  Texttolog("CERTIFICATION")
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8                                     \
  then
    i=Cleanneedles(10)                 // Clean needles
    if i<0 goto quit                   // Operator interrupted the script
  endif
  i=Rtest(10,0,0,1,0,0)                // Ordinary measurements
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  if (excludetests & EXCL_EXACTR)==0 then
    i=Rtest(5,1,0,1,0,0)               // Accurate measurements
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  if (excludetests & EXCL_KELVIN)==0 && (boardtype==3 || boardtype==4) then
    if ($LAY.probetype & 1)!=0 then
      i=Lowkelvin(10,1,0,0,0)          // Kelvin measurements
    else if (testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||   \
      testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||           \
      testertype==TT_A7 || testertype==TT_A8) && $LAY.nfing>=2 then
      i=Lowkelvin(10,1,1,0,0)          // 4-wire measurements
    endif
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  if (excludetests & EXCL_RPARC)==0 then
    i=RCtest(5,0,0,0.0,1,0)            // Ordinary R||C measurements
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  if (excludetests & (EXCL_EXACTR|EXCL_RPARC))==0 then
    i=RCtest(5,1,0,0.0,1,0)            // Accurate R||C measurements
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  i=Ftest(16,1,0)                      // Field test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  i=Ctest(16,1,0,0)                    // Capacity test
  if i<0 goto quit                     // Operator interrupted the script
  if i==1 goto mainloop                // Operator interrupted current test
  if (excludetests & EXCL_CRT)==0 then
    i=Crttest(16,1,0)                  // Charge rise time test
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  if (excludetests & EXCL_UNIC)==0 then
    i=Unictest(2,1,0)                  // Universal capacity test
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  if (romdata.features & BF_TYPE)==BF_TRIPOD then
    i=Ltest(32,1,1,0)                  // Inductance test (differential)
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  if (excludetests & EXCL_HV)==0 then
    if $LAY.nfing>8 then               // High voltage test
      i=HVtest(10,1,0)                 // Otherwise it takes too long
    else
      i=HVtest(16,1,0)
    endif
    if i<0 goto quit                   // Operator interrupted the script
    if i==1 goto mainloop              // Operator interrupted current test
  endif
  i=Printsummary("CERTIFICATION:")
  if i>0 then
    n=lastrail-firstrail+1
    if n==5 || (testersides==0x3 && n==$LAY.nfing/2) ||                        \
      (testersides!=0x3 && n==$LAY.nfing) then                                 \
      fullset=1
    else
      fullset=0
    endif
    if notcertified then
      Addcalibrationrecord("Tester certified with expired OlliBoard")
      if fullset==0 then
        Addcalibrationrecord("Certification is valid only for rails %i..%i",   \
        firstrail,lastrail)
      endif
    else if fullset==0 then
      Addcalibrationrecord("Rails %i..%i certified",firstrail,lastrail)
    else
      Addcalibrationrecord("Tester successfully certified")
    endif
  endif
  Texttolog("END OF CERTIFICATION")
  Protocolmeasparms(0)                 // Protocol measurement parameters
  goto mainloop
extcomp:                               // Test external components
  i=Testextcomp()
  if i<0 goto quit                     // Operator interrupted the script
  goto mainloop
setstroke:                             // Set stroke
  i=Changestroke()
  if i<0 goto quit                     // Operator interrupted the script
  goto mainloop
singler:                               // Ordinary resistance test
  i=Rtest(repeat,0,lowvolt,singlecert,0,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singler      // Automatically repeat test
  goto mainloop
singlemref:                            // Multireference resistance test
  i=Rtest(repeat,0,lowvolt,singlecert,1,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singlemref   // Automatically repeat test
  goto mainloop
singleer:                              // Exact resistance test
  i=Rtest(repeat,1,lowvolt,singlecert,0,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singleer     // Automatically repeat test
  goto mainloop
singlekelvin:                          // Kelvin measurements
  if boardtype==3 || boardtype==4 then // Dedicated components
    i=Lowkelvin(repeat,singlecert,0,lowvolt,logmeas)
  else                                 // Reuse generic components
    i=Stdkelvin(repeat,1,singlecert,logmeas)
  endif
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singleer     // Automatically repeat test
  goto mainloop
singlefour:                            // 4-wire measurements (Kelvin for poor)
  if (boardtype!=3 && boardtype!=4 && boardtype!=5) || $LAY.nfing<2            \
    goto mainloop
  i=Lowkelvin(repeat,singlecert,1,lowvolt,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singleer     // Automatically repeat test
  goto mainloop
singlerc:                              // Ordinary R||C test
  i=RCtest(repeat,0,lowvolt,0.0,singlecert,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singlerc     // Automatically repeat test
  goto mainloop
singleerc:                             // Exact R||C test
  i=RCtest(repeat,1,lowvolt,0.0,singlecert,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singleerc    // Automatically repeat test
  goto mainloop
singlef:                               // Field test
  i=Ftest(repeat,singlecert,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singlef      // Automatically repeat test
  goto mainloop
singlec:                               // Capacity test
  i=Ctest(repeat,singlecert,lowvolt,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singlec      // Automatically repeat test
  goto mainloop
singlecrt:                             // CRT test
  i=Crttest(repeat,singlecert,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singlecrt    // Automatically repeat test
  goto mainloop
unic:                                  // Universal capacity test
  i=Unictest(repeat,singlecert,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto unic         // Automatically repeat test
  goto mainloop
ownc:                                  // Own capacity of the needle
  i=Ownc(repeat)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto ownc         // Automatically repeat test
  goto mainloop
singlel:                               // Inductivity test
  i=Ltest(repeat,singlecert,differentiall,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singlel      // Automatically repeat test
  goto mainloop
singlehv:                              // High voltage test
  i=HVtest(repeat,singlecert,logmeas)
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto singlehv     // Automatically repeat test
  goto mainloop
noise:
  i=Noise()
  if i<0 goto quit                     // Operator interrupted the script
  if autorep && i!=1 goto noise        // Automatically repeat test
  goto mainloop
clean:                                 // Clean needles
  i=Cleanneedles(repeat)
  if i<0 goto quit                     // Operator interrupted the script
  goto mainloop                        // No autorepeat!
repeatbad:                             // Repeat bad measurement
  i=Replaylist()
  if i<0 goto quit                     // Operator interrupted the script
  goto mainloop                        // No autorepeat!
quit:
  clear hleft
  clear hright
  change hinfo limits=0,0
  change hinfo text="3,???o..."
  destroy hexit                        // Psychology...
  hexit=NULL
  softreset=0
  Bcsetini()                           // Save brightness & contrast to .ini
  if testertype==TT_A5 || testertype==TT_A5L || testertype==TT_A6 ||           \
    testertype==TT_S1 || testertype==TT_S2 || testertype==TT_S3 ||             \
    testertype==TT_A7 || testertype==TT_A8                                     \
  then
    SERV.Cmdimm(32,"OUTPORT32 CRATE 0x80000003,0")
  endif
  if (testertype==TT_A5L || testertype==TT_A7 || testertype==TT_A8) &&         \
    (($LAY.config & LC_LDMASK)==LC_LMAUTO ||                                   \
    ($LAY.config & LC_LDMASK)==LC_SPLITAUTO)                                   \
  then
    Unloadboard()                      // Unload board if L&M or split shuttle
  else if testertype==TT_S3 && ($LAY.config & LC_LDMASK)==LC_SPLITAUTO then
    Unloadboard()                      // Unload board if S3 split shuttle
  endif
  if Embedded()!=0 then
    SERV.Cmdimm(32,"$LIGHTS WAITING")  // Update state of traffic lights
  endif
  Closeprotocols()                     // Close protocols if any
  SERV.Cmdimm(32,"OUTPORT 0x20F0,8")   // Restore 4 V antenna voltage
  if softreset==0 SYS.Softreset(0)
  if testertype==TT_A6 && ($LAY.config & LC_LDMASK)==LC_EPCOSAUTO then
    UnloadboardEPCOS()                 // Ask to remove board if EPCOS shuttle
  endif
  // Remove Z mapping and allow Z movements in the whole tester area.
  if $LAY.nfing>0 then
    sprintf(s,"???? %g,%g,%g,%g",                                          \
      $LAY.leftlimit/1000.0,$LAY.bottom[0]/1000.0,                             \
      $LAY.rightlimit/1000.0,$LAY.top[$LAY.nfing-1]/1000.0)
    SERV.Cmdimm(32,s)                  // Allow whole board
  endif
end

